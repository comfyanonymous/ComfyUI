const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./KeybindingPanel-DcEfyPZZ.js","./index-CjwCGacA.js","./index-MX9DEi8Q.js","./KeybindingPanel-CB_wEOHl.css","./ExtensionPanel-CfMfcLgI.js","./index-B1vRdV2i.js","./widgetInputs-BJ21PG7d.js","./index-BRhY6FpL.css","./userSelection-BSkuSZyR.js","./userSelection-CmI-fOSC.css","./GraphView-BCOd0Zle.js","./GraphView-CghYAxkP.css","./ServerStartView-e57oVZ6V.js","./index-B4gmhi99.js","./InstallView-D9ueAxrz.js","./InstallView-CN3CA9Fk.css","./WelcomeView-DT4bj-QV.js","./WelcomeView-DQQgHnsr.css"])))=>i.map(i=>d[i]);
var __defProp2 = Object.defineProperty;
var __name = (target, value3) => __defProp2(target, "name", { value: value3, configurable: true });
(/* @__PURE__ */ __name(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node3 of mutation.addedNodes) {
        if (node3.tagName === "LINK" && node3.rel === "modulepreload")
          processPreload(node3);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  __name(getFetchOpts, "getFetchOpts");
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
  __name(processPreload, "processPreload");
}, "polyfill"))();
/**
* @vue/shared v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
}
__name(makeMap, "makeMap");
const EMPTY_OBJ = false ? Object.freeze({}) : {};
const EMPTY_ARR = false ? Object.freeze([]) : [];
const NOOP = /* @__PURE__ */ __name(() => {
}, "NOOP");
const NO = /* @__PURE__ */ __name(() => false, "NO");
const isOn = /* @__PURE__ */ __name((key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97), "isOn");
const isModelListener = /* @__PURE__ */ __name((key) => key.startsWith("onUpdate:"), "isModelListener");
const extend$1 = Object.assign;
const remove$1 = /* @__PURE__ */ __name((arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
}, "remove$1");
const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
const hasOwn$3 = /* @__PURE__ */ __name((val, key) => hasOwnProperty$3.call(val, key), "hasOwn$3");
const isArray$5 = Array.isArray;
const isMap = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object Map]", "isMap");
const isSet = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object Set]", "isSet");
const isDate$3 = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object Date]", "isDate$3");
const isRegExp$2 = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object RegExp]", "isRegExp$2");
const isFunction$3 = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction$3");
const isString$5 = /* @__PURE__ */ __name((val) => typeof val === "string", "isString$5");
const isSymbol$1 = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol$1");
const isObject$6 = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object", "isObject$6");
const isPromise$1 = /* @__PURE__ */ __name((val) => {
  return (isObject$6(val) || isFunction$3(val)) && isFunction$3(val.then) && isFunction$3(val.catch);
}, "isPromise$1");
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = /* @__PURE__ */ __name((value3) => objectToString$1.call(value3), "toTypeString$1");
const toRawType = /* @__PURE__ */ __name((value3) => {
  return toTypeString$1(value3).slice(8, -1);
}, "toRawType");
const isPlainObject$3 = /* @__PURE__ */ __name((val) => toTypeString$1(val) === "[object Object]", "isPlainObject$3");
const isIntegerKey = /* @__PURE__ */ __name((key) => isString$5(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key, "isIntegerKey");
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction$1 = /* @__PURE__ */ __name((fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
}, "cacheStringFunction$1");
const camelizeRE$1 = /-(\w)/g;
const camelize$1 = cacheStringFunction$1((str) => {
  return str.replace(camelizeRE$1, (_2, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE$1 = /\B([A-Z])/g;
const hyphenate$1 = cacheStringFunction$1(
  (str) => str.replace(hyphenateRE$1, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction$1((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction$1((str) => {
  const s = str ? `on${capitalize$1(str)}` : ``;
  return s;
});
const hasChanged = /* @__PURE__ */ __name((value3, oldValue) => !Object.is(value3, oldValue), "hasChanged");
const invokeArrayFns = /* @__PURE__ */ __name((fns, ...arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](...arg);
  }
}, "invokeArrayFns");
const def = /* @__PURE__ */ __name((obj, key, value3, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value: value3
  });
}, "def");
const looseToNumber = /* @__PURE__ */ __name((val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
}, "looseToNumber");
const toNumber = /* @__PURE__ */ __name((val) => {
  const n = isString$5(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
}, "toNumber");
let _globalThis$1;
const getGlobalThis$1 = /* @__PURE__ */ __name(() => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
}, "getGlobalThis$1");
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
__name(genPropsAccessExp, "genPropsAccessExp");
const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "HOISTED": -1,
  "-1": "HOISTED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};
const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;
const range = 2;
function generateCodeFrame$1(source, start2 = 0, end = source.length) {
  start2 = Math.max(0, Math.min(start2, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start2 > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
  lines = lines.filter((_2, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i2 = 0; i2 < lines.length; i2++) {
    count += lines[i2].length + (newlineSequences[i2] && newlineSequences[i2].length || 0);
    if (count >= start2) {
      for (let j = i2 - range; j <= i2 + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i2) {
          const pad = start2 - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start2
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i2) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
__name(generateCodeFrame$1, "generateCodeFrame$1");
function normalizeStyle(value3) {
  if (isArray$5(value3)) {
    const res = {};
    for (let i2 = 0; i2 < value3.length; i2++) {
      const item2 = value3[i2];
      const normalized = isString$5(item2) ? parseStringStyle(item2) : normalizeStyle(item2);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$5(value3) || isObject$6(value3)) {
    return value3;
  }
}
__name(normalizeStyle, "normalizeStyle");
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item2) => {
    if (item2) {
      const tmp = item2.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
__name(parseStringStyle, "parseStringStyle");
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString$5(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value3 = styles[key];
    if (isString$5(value3) || typeof value3 === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate$1(key);
      ret += `${normalizedKey}:${value3};`;
    }
  }
  return ret;
}
__name(stringifyStyle, "stringifyStyle");
function normalizeClass(value3) {
  let res = "";
  if (isString$5(value3)) {
    res = value3;
  } else if (isArray$5(value3)) {
    for (let i2 = 0; i2 < value3.length; i2++) {
      const normalized = normalizeClass(value3[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$6(value3)) {
    for (const name in value3) {
      if (value3[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
__name(normalizeClass, "normalizeClass");
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString$5(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
__name(normalizeProps, "normalizeProps");
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value3) {
  return !!value3 || value3 === "";
}
__name(includeBooleanAttr, "includeBooleanAttr");
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
__name(isSSRSafeAttrName, "isSSRSafeAttrName");
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
function isRenderableAttrValue(value3) {
  if (value3 == null) {
    return false;
  }
  const type = typeof value3;
  return type === "string" || type === "number" || type === "boolean";
}
__name(isRenderableAttrValue, "isRenderableAttrValue");
const escapeRE = /["'&<>]/;
function escapeHtml$1(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index2;
  let lastIndex = 0;
  for (index2 = match.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str.slice(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escaped;
  }
  return lastIndex !== index2 ? html + str.slice(lastIndex, index2) : html;
}
__name(escapeHtml$1, "escapeHtml$1");
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
__name(escapeHtmlComment, "escapeHtmlComment");
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a.length; i2++) {
    equal = looseEqual(a[i2], b[i2]);
  }
  return equal;
}
__name(looseCompareArrays, "looseCompareArrays");
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate$3(a);
  let bValidType = isDate$3(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol$1(a);
  bValidType = isSymbol$1(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$5(a);
  bValidType = isArray$5(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$6(a);
  bValidType = isObject$6(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
__name(looseEqual, "looseEqual");
function looseIndexOf(arr, val) {
  return arr.findIndex((item2) => looseEqual(item2, val));
}
__name(looseIndexOf, "looseIndexOf");
const isRef$1 = /* @__PURE__ */ __name((val) => {
  return !!(val && val.__v_isRef === true);
}, "isRef$1");
const toDisplayString$1 = /* @__PURE__ */ __name((val) => {
  return isString$5(val) ? val : val == null ? "" : isArray$5(val) || isObject$6(val) && (val.toString === objectToString$1 || !isFunction$3(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
}, "toDisplayString$1");
const replacer = /* @__PURE__ */ __name((_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i2) => {
          entries[stringifySymbol(key, i2) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol$1(val)) {
    return stringifySymbol(val);
  } else if (isObject$6(val) && !isArray$5(val) && !isPlainObject$3(val)) {
    return String(val);
  }
  return val;
}, "replacer");
const stringifySymbol = /* @__PURE__ */ __name((v2, i2 = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol$1(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
  );
}, "stringifySymbol");
/**
* @vue/reactivity v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function warn$3(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
__name(warn$3, "warn$3");
let activeEffectScope;
class EffectScope {
  static {
    __name(this, "EffectScope");
  }
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (false) {
      warn$3(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l;
      for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
__name(effectScope, "effectScope");
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
__name(recordEffectScope, "recordEffectScope");
function getCurrentScope() {
  return activeEffectScope;
}
__name(getCurrentScope, "getCurrentScope");
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (false) {
    warn$3(
      `onScopeDispose() is called when there is no active effect scope to be associated with.`
    );
  }
}
__name(onScopeDispose, "onScopeDispose");
let activeEffect;
class ReactiveEffect {
  static {
    __name(this, "ReactiveEffect");
  }
  constructor(fn, trigger2, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i2 = 0; i2 < this._depsLength; i2++) {
        const dep = this.deps[i2];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v2) {
    this._dirtyLevel = v2 ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      this.onStop && this.onStop();
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
__name(triggerComputed, "triggerComputed");
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
__name(preCleanupEffect, "preCleanupEffect");
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
      cleanupDepEffect(effect2.deps[i2], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
__name(postCleanupEffect, "postCleanupEffect");
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
__name(cleanupDepEffect, "cleanupDepEffect");
function effect(fn, options3) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn, NOOP, () => {
    if (_effect.dirty) {
      _effect.run();
    }
  });
  if (options3) {
    extend$1(_effect, options3);
    if (options3.scope) recordEffectScope(_effect, options3.scope);
  }
  if (!options3 || !options3.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
__name(effect, "effect");
function stop(runner) {
  runner.effect.stop();
}
__name(stop, "stop");
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
__name(pauseTracking, "pauseTracking");
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
__name(enableTracking, "enableTracking");
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
__name(resetTracking, "resetTracking");
function pauseScheduling() {
  pauseScheduleStack++;
}
__name(pauseScheduling, "pauseScheduling");
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
__name(resetScheduling, "resetScheduling");
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  var _a;
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
    if (false) {
      (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, extend$1({ effect: effect2 }, debuggerEventExtraInfo));
    }
  }
}
__name(trackEffect, "trackEffect");
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  var _a;
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      if (false) {
        (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, extend$1({ effect: effect2 }, debuggerEventExtraInfo));
      }
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
__name(triggerEffects, "triggerEffects");
const createDep = /* @__PURE__ */ __name((cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
}, "createDep");
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(false ? "iterate" : "");
const MAP_KEY_ITERATE_KEY = Symbol(false ? "Map key iterate" : "");
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep,
      false ? {
        target,
        type,
        key
      } : void 0
    );
  }
}
__name(track, "track");
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$5(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$5(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$5(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4,
        false ? {
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        } : void 0
      );
    }
  }
  resetScheduling();
}
__name(trigger, "trigger");
function getDepFromReactive(object, key) {
  const depsMap = targetMap.get(object);
  return depsMap && depsMap.get(key);
}
__name(getDepFromReactive, "getDepFromReactive");
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l = this.length; i2 < l; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
__name(createArrayInstrumentations, "createArrayInstrumentations");
function hasOwnProperty$2(key) {
  if (!isSymbol$1(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
__name(hasOwnProperty$2, "hasOwnProperty$2");
class BaseReactiveHandler {
  static {
    __name(this, "BaseReactiveHandler");
  }
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$5(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$3(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$2;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$6(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  static {
    __name(this, "MutableReactiveHandler");
  }
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value3, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value3) && !isReadonly(value3)) {
        oldValue = toRaw(oldValue);
        value3 = toRaw(value3);
      }
      if (!isArray$5(target) && isRef(oldValue) && !isRef(value3)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value3;
          return true;
        }
      }
    }
    const hadKey = isArray$5(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$3(target, key);
    const result = Reflect.set(target, key, value3, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value3);
      } else if (hasChanged(value3, oldValue)) {
        trigger(target, "set", key, value3, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$3(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$5(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  static {
    __name(this, "ReadonlyReactiveHandler");
  }
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (false) {
      warn$3(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (false) {
      warn$3(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = /* @__PURE__ */ __name((value3) => value3, "toShallow");
const getProto = /* @__PURE__ */ __name((v2) => Reflect.getPrototypeOf(v2), "getProto");
function get$3(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
__name(get$3, "get$3");
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
__name(has, "has");
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
__name(size, "size");
function add(value3) {
  value3 = toRaw(value3);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value3);
  if (!hadKey) {
    target.add(value3);
    trigger(target, "add", value3, value3);
  }
  return this;
}
__name(add, "add");
function set$4(key, value3) {
  value3 = toRaw(value3);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value3);
  if (!hadKey) {
    trigger(target, "add", key, value3);
  } else if (hasChanged(value3, oldValue)) {
    trigger(target, "set", key, value3, oldValue);
  }
  return this;
}
__name(set$4, "set$4");
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
__name(deleteEntry, "deleteEntry");
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = false ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
__name(clear, "clear");
function createForEach(isReadonly2, isShallow2) {
  return /* @__PURE__ */ __name(function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value3, key) => {
      return callback.call(thisArg, wrap(value3), wrap(key), observed);
    });
  }, "forEach");
}
__name(createForEach, "createForEach");
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value3, done } = innerIterator.next();
        return done ? { value: value3, done } : {
          value: isPair ? [wrap(value3[0]), wrap(value3[1])] : wrap(value3),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
__name(createIterableMethod, "createIterableMethod");
function createReadonlyMethod(type) {
  return function(...args) {
    if (false) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn$3(
        `${capitalize$1(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
__name(createReadonlyMethod, "createReadonlyMethod");
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$3(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$4,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$3(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$4,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$3(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$3(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
__name(createInstrumentations, "createInstrumentations");
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$3(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
__name(createInstrumentationGetter, "createInstrumentationGetter");
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    warn$3(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
__name(checkIdentityKeys, "checkIdentityKeys");
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
__name(targetTypeMap, "targetTypeMap");
function getTargetType(value3) {
  return value3["__v_skip"] || !Object.isExtensible(value3) ? 0 : targetTypeMap(toRawType(value3));
}
__name(getTargetType, "getTargetType");
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
__name(reactive, "reactive");
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
__name(shallowReactive, "shallowReactive");
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
__name(readonly, "readonly");
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
__name(shallowReadonly, "shallowReadonly");
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$6(target)) {
    if (false) {
      warn$3(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
__name(createReactiveObject, "createReactiveObject");
function isReactive(value3) {
  if (isReadonly(value3)) {
    return isReactive(value3["__v_raw"]);
  }
  return !!(value3 && value3["__v_isReactive"]);
}
__name(isReactive, "isReactive");
function isReadonly(value3) {
  return !!(value3 && value3["__v_isReadonly"]);
}
__name(isReadonly, "isReadonly");
function isShallow(value3) {
  return !!(value3 && value3["__v_isShallow"]);
}
__name(isShallow, "isShallow");
function isProxy(value3) {
  return value3 ? !!value3["__v_raw"] : false;
}
__name(isProxy, "isProxy");
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
__name(toRaw, "toRaw");
function markRaw(value3) {
  if (Object.isExtensible(value3)) {
    def(value3, "__v_skip", true);
  }
  return value3;
}
__name(markRaw, "markRaw");
const toReactive$1 = /* @__PURE__ */ __name((value3) => isObject$6(value3) ? reactive(value3) : value3, "toReactive$1");
const toReadonly = /* @__PURE__ */ __name((value3) => isObject$6(value3) ? readonly(value3) : value3, "toReadonly");
const COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
class ComputedRefImpl {
  static {
    __name(this, "ComputedRefImpl");
  }
  constructor(getter, _setter, isReadonly2, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      if (false) {
        warn$3(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
      }
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v2) {
    this.effect.dirty = v2;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$3(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = false ? () => {
      warn$3("Write operation failed: computed value is readonly");
    } : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (false) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
__name(computed$1, "computed$1");
function trackRefValue(ref2) {
  var _a;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      ),
      false ? {
        target: ref2,
        type: "get",
        key: "value"
      } : void 0
    );
  }
}
__name(trackRefValue, "trackRefValue");
function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel,
      false ? {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal,
        oldValue: oldVal
      } : void 0
    );
  }
}
__name(triggerRefValue, "triggerRefValue");
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
__name(isRef, "isRef");
function ref(value3) {
  return createRef(value3, false);
}
__name(ref, "ref");
function shallowRef(value3) {
  return createRef(value3, true);
}
__name(shallowRef, "shallowRef");
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
__name(createRef, "createRef");
class RefImpl {
  static {
    __name(this, "RefImpl");
  }
  constructor(value3, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value3 : toRaw(value3);
    this._value = __v_isShallow ? value3 : toReactive$1(value3);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      const oldVal = this._rawValue;
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive$1(newVal);
      triggerRefValue(this, 4, newVal, oldVal);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2, 4, false ? ref2.value : void 0);
}
__name(triggerRef, "triggerRef");
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
__name(unref, "unref");
function toValue$2(source) {
  return isFunction$3(source) ? source() : unref(source);
}
__name(toValue$2, "toValue$2");
const shallowUnwrapHandlers = {
  get: /* @__PURE__ */ __name((target, key, receiver) => unref(Reflect.get(target, key, receiver)), "get"),
  set: /* @__PURE__ */ __name((target, key, value3, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value3)) {
      oldValue.value = value3;
      return true;
    } else {
      return Reflect.set(target, key, value3, receiver);
    }
  }, "set")
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
__name(proxyRefs, "proxyRefs");
class CustomRefImpl {
  static {
    __name(this, "CustomRefImpl");
  }
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
__name(customRef, "customRef");
function toRefs$1(object) {
  if (false) {
    warn$3(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray$5(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
__name(toRefs$1, "toRefs$1");
class ObjectRefImpl {
  static {
    __name(this, "ObjectRefImpl");
  }
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  static {
    __name(this, "GetterRefImpl");
  }
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef$1(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$3(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$6(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
__name(toRef$1, "toRef$1");
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
__name(propertyToRef, "propertyToRef");
const deferredComputed = computed$1;
const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw"
};
/**
* @vue/runtime-core v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
__name(pushWarningContext, "pushWarningContext");
function popWarningContext() {
  stack.pop();
}
__name(popWarningContext, "popWarningContext");
function warn$1$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
__name(warn$1$1, "warn$1$1");
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
__name(getComponentTrace, "getComponentTrace");
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
__name(formatTrace, "formatTrace");
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open2 = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close4 = `>` + postfix;
  return vnode.props ? [open2, ...formatProps(vnode.props), close4] : [open2 + close4];
}
__name(formatTraceEntry, "formatTraceEntry");
function formatProps(props) {
  const res = [];
  const keys2 = Object.keys(props);
  keys2.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
__name(formatProps, "formatProps");
function formatProp(key, value3, raw) {
  if (isString$5(value3)) {
    value3 = JSON.stringify(value3);
    return raw ? value3 : [`${key}=${value3}`];
  } else if (typeof value3 === "number" || typeof value3 === "boolean" || value3 == null) {
    return raw ? value3 : [`${key}=${value3}`];
  } else if (isRef(value3)) {
    value3 = formatProp(key, toRaw(value3.value), true);
    return raw ? value3 : [`${key}=Ref<`, value3, `>`];
  } else if (isFunction$3(value3)) {
    return [`${key}=fn${value3.name ? `<${value3.name}>` : ``}`];
  } else {
    value3 = toRaw(value3);
    return raw ? value3 : [`${key}=`, value3];
  }
}
__name(formatProp, "formatProp");
function assertNumber(val, type) {
  if (true) return;
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn$1$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$1$1(`${type} is NaN - the duration expression might be incorrect.`);
  }
}
__name(assertNumber, "assertNumber");
const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "WATCH_GETTER": 2,
  "2": "WATCH_GETTER",
  "WATCH_CALLBACK": 3,
  "3": "WATCH_CALLBACK",
  "WATCH_CLEANUP": 4,
  "4": "WATCH_CLEANUP",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
__name(callWithErrorHandling, "callWithErrorHandling");
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$3(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$5(fn)) {
    const values2 = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values2.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
    }
    return values2;
  } else if (false) {
    warn$1$1(
      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
    );
  }
}
__name(callWithAsyncErrorHandling, "callWithAsyncErrorHandling");
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = false ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      pauseTracking();
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
__name(handleError, "handleError");
function logError(err, type, contextVNode, throwInDev = true) {
  if (false) {
    const info = ErrorTypeStrings$1[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
__name(logError, "logError");
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
__name(nextTick, "nextTick");
function findInsertionIndex$1(id3) {
  let start2 = flushIndex + 1;
  let end = queue.length;
  while (start2 < end) {
    const middle = start2 + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id3 || middleJobId === id3 && middleJob.pre) {
      start2 = middle + 1;
    } else {
      end = middle;
    }
  }
  return start2;
}
__name(findInsertionIndex$1, "findInsertionIndex$1");
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex$1(job.id), 0, job);
    }
    queueFlush();
  }
}
__name(queueJob, "queueJob");
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
__name(queueFlush, "queueFlush");
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
__name(invalidateJob, "invalidateJob");
function queuePostFlushCb(cb) {
  if (!isArray$5(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
__name(queuePostFlushCb, "queuePostFlushCb");
function flushPreFlushCbs(instance, seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  if (false) {
    seen2 = seen2 || /* @__PURE__ */ new Map();
  }
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      if (false) {
        continue;
      }
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
__name(flushPreFlushCbs, "flushPreFlushCbs");
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (false) {
      seen2 = seen2 || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (false) {
        continue;
      }
      if (cb.active !== false) cb();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
__name(flushPostFlushCbs, "flushPostFlushCbs");
const getId = /* @__PURE__ */ __name((job) => job.id == null ? Infinity : job.id, "getId");
const comparator = /* @__PURE__ */ __name((a, b) => {
  const diff2 = getId(a) - getId(b);
  if (diff2 === 0) {
    if (a.pre && !b.pre) return -1;
    if (b.pre && !a.pre) return 1;
  }
  return diff2;
}, "comparator");
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  if (false) {
    seen2 = seen2 || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = false ? (job) => checkRecursiveUpdates(seen2, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen2);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen2);
    }
  }
}
__name(flushJobs, "flushJobs");
function checkRecursiveUpdates(seen2, fn) {
  if (!seen2.has(fn)) {
    seen2.set(fn, 1);
  } else {
    const count = seen2.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    } else {
      seen2.set(fn, count + 1);
    }
  }
}
__name(checkRecursiveUpdates, "checkRecursiveUpdates");
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
if (false) {
  getGlobalThis$1().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id3 = instance.type.__hmrId;
  let record = map.get(id3);
  if (!record) {
    createRecord(id3, instance.type);
    record = map.get(id3);
  }
  record.instances.add(instance);
}
__name(registerHMR, "registerHMR");
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
__name(unregisterHMR, "unregisterHMR");
function createRecord(id3, initialDef) {
  if (map.has(id3)) {
    return false;
  }
  map.set(id3, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
__name(createRecord, "createRecord");
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
__name(normalizeClassComponent, "normalizeClassComponent");
function rerender(id3, newRender) {
  const record = map.get(id3);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.effect.dirty = true;
    instance.update();
    isHmrUpdating = false;
  });
}
__name(rerender, "rerender");
function reload(id3, newComp) {
  const record = map.get(id3);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      instance.parent.effect.dirty = true;
      queueJob(() => {
        instance.parent.update();
        hmrDirtyComponents.delete(oldComp);
      });
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(
        normalizeClassComponent(instance.type)
      );
    }
  });
}
__name(reload, "reload");
function updateComponentDef(oldComp, newComp) {
  extend$1(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
__name(updateComponentDef, "updateComponentDef");
function tryWrap(fn) {
  return (id3, arg) => {
    try {
      return fn(id3, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}
__name(tryWrap, "tryWrap");
let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event2, ...args) {
  if (devtools$1) {
    devtools$1.emit(event2, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event: event2, args });
  }
}
__name(emit$1, "emit$1");
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event: event2, args }) => devtools$1.emit(event2, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
__name(setDevtoolsHook$1, "setDevtoolsHook$1");
function devtoolsInitApp(app2, version2) {
  emit$1("app:init", app2, version2, {
    Fragment,
    Text: Text$1,
    Comment,
    Static
  });
}
__name(devtoolsInitApp, "devtoolsInitApp");
function devtoolsUnmountApp(app2) {
  emit$1("app:unmount", app2);
}
__name(devtoolsUnmountApp, "devtoolsUnmountApp");
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added"
  /* COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:updated"
  /* COMPONENT_UPDATED */
);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed"
  /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = /* @__PURE__ */ __name((component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
}, "devtoolsComponentRemoved");
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
__name(createDevtoolsComponentHook, "createDevtoolsComponentHook");
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:start"
  /* PERFORMANCE_START */
);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:end"
  /* PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
__name(createDevtoolsPerformanceHook, "createDevtoolsPerformanceHook");
function devtoolsComponentEmit(component, event2, params) {
  emit$1(
    "component:emit",
    component.appContext.app,
    component,
    event2,
    params
  );
}
__name(devtoolsComponentEmit, "devtoolsComponentEmit");
function emit(instance, event2, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  if (false) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event2 in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event2) in propsOptions)) {
          warn$1$1(
            `Component emitted event "${event2}" but it is neither declared in the emits option nor as an "${toHandlerKey(event2)}" prop.`
          );
        }
      } else {
        const validator3 = emitsOptions[event2];
        if (isFunction$3(validator3)) {
          const isValid2 = validator3(...rawArgs);
          if (!isValid2) {
            warn$1$1(
              `Invalid event arguments: event validation failed for event "${event2}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event2.startsWith("update:");
  const modelArg = isModelListener2 && event2.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => isString$5(a) ? a.trim() : a);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (false) {
    devtoolsComponentEmit(instance, event2, args);
  }
  if (false) {
    const lowerCaseEvent = event2.toLowerCase();
    if (lowerCaseEvent !== event2 && props[toHandlerKey(lowerCaseEvent)]) {
      warn$1$1(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event2}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate$1(
          event2
        )}" instead of "${event2}".`
      );
    }
  }
  let handlerName;
  let handler6 = props[handlerName = toHandlerKey(event2)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize$1(event2))];
  if (!handler6 && isModelListener2) {
    handler6 = props[handlerName = toHandlerKey(hyphenate$1(event2))];
  }
  if (handler6) {
    callWithAsyncErrorHandling(
      handler6,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
__name(emit, "emit");
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendEmits = /* @__PURE__ */ __name((raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    }, "extendEmits");
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$6(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$5(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$6(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
__name(normalizeEmitsOptions, "normalizeEmitsOptions");
function isEmitListener(options3, key) {
  if (!options3 || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$3(options3, key[0].toLowerCase() + key.slice(1)) || hasOwn$3(options3, hyphenate$1(key)) || hasOwn$3(options3, key);
}
__name(isEmitListener, "isEmitListener");
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev2 = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev2;
}
__name(setCurrentRenderingInstance, "setCurrentRenderingInstance");
function pushScopeId(id3) {
  currentScopeId = id3;
}
__name(pushScopeId, "pushScopeId");
function popScopeId() {
  currentScopeId = null;
}
__name(popScopeId, "popScopeId");
const withScopeId = /* @__PURE__ */ __name((_id2) => withCtx, "withScopeId");
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = /* @__PURE__ */ __name((...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (false) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  }, "renderFnWithContext");
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
__name(withCtx, "withCtx");
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
__name(markAttrsAccessed, "markAttrsAccessed");
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs: attrs3,
    emit: emit2,
    render: render2,
    renderCache,
    props,
    data: data22,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev2 = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  if (false) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render2.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data22,
          ctx
        )
      );
      fallthroughAttrs = attrs3;
    } else {
      const render22 = Component;
      if (false) {
        markAttrsAccessed();
      }
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs3);
            },
            slots,
            emit: emit2
          } : { attrs: attrs3, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs3 : getFunctionalFallthrough(attrs3);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root23 = result;
  let setRoot = void 0;
  if (false) {
    [root23, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root23;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root23 = cloneVNode(root23, fallthroughAttrs, false, true);
      } else if (false) {
        const allAttrs = Object.keys(attrs3);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i2 = 0, l = allAttrs.length; i2 < l; i2++) {
          const key = allAttrs[i2];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$1$1(
            `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
          );
        }
        if (eventAttrs.length) {
          warn$1$1(
            `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
          );
        }
      }
    }
  }
  if (vnode.dirs) {
    if (false) {
      warn$1$1(
        `Runtime directive used on component with non-element root node. The directives will not function as intended.`
      );
    }
    root23 = cloneVNode(root23, null, false, true);
    root23.dirs = root23.dirs ? root23.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (false) {
      warn$1$1(
        `Component inside <Transition> renders non-element root node that cannot be animated.`
      );
    }
    root23.transition = vnode.transition;
  }
  if (false) {
    setRoot(root23);
  } else {
    result = root23;
  }
  setCurrentRenderingInstance(prev2);
  return result;
}
__name(renderComponentRoot, "renderComponentRoot");
const getChildRoot = /* @__PURE__ */ __name((vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren, false);
  if (!childRoot) {
    return [vnode, void 0];
  } else if (false) {
    return getChildRoot(childRoot);
  }
  const index2 = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = /* @__PURE__ */ __name((updatedRoot) => {
    rawChildren[index2] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  }, "setRoot");
  return [normalizeVNode(childRoot), setRoot];
}, "getChildRoot");
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode$1(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
          if (false) {
            return filterSingleRoot(singleRoot.children);
          }
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
__name(filterSingleRoot, "filterSingleRoot");
const getFunctionalFallthrough = /* @__PURE__ */ __name((attrs3) => {
  let res;
  for (const key in attrs3) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs3[key];
    }
  }
  return res;
}, "getFunctionalFallthrough");
const filterModelListeners = /* @__PURE__ */ __name((attrs3, props) => {
  const res = {};
  for (const key in attrs3) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs3[key];
    }
  }
  return res;
}, "filterModelListeners");
const isElementRoot = /* @__PURE__ */ __name((vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
}, "isElementRoot");
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (false) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
__name(shouldUpdateComponent, "shouldUpdateComponent");
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
__name(hasPropsChanged, "hasPropsChanged");
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root23 = parent.subTree;
    if (root23.suspense && root23.suspense.activeBranch === vnode) {
      root23.el = vnode.el;
    }
    if (root23 === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
__name(updateHOCHostEl, "updateHOCHostEl");
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
__name(resolveComponent, "resolveComponent");
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$5(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
__name(resolveDynamicComponent, "resolveDynamicComponent");
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
__name(resolveDirective, "resolveDirective");
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize$1(camelize$1(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve$1(instance[type] || Component[type], name) || // global registration
      resolve$1(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (false) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else if (false) {
    warn$1$1(
      `resolve${capitalize$1(type.slice(0, -1))} can only be used in render() or setup().`
    );
  }
}
__name(resolveAsset, "resolveAsset");
function resolve$1(registry, name) {
  return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize$1(camelize$1(name))]);
}
__name(resolve$1, "resolve$1");
const isSuspense = /* @__PURE__ */ __name((type) => type.__isSuspense, "isSuspense");
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$3(eventListener)) {
    eventListener();
  }
}
__name(triggerEvent, "triggerEvent");
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch2,
    o: { createElement: createElement2 }
  } = rendererInternals;
  const hiddenContainer = createElement2("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch2(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch2(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
__name(mountSuspense, "mountSuspense");
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch2, um: unmount, o: { createElement: createElement2 } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch2(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch2(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement2("div");
      if (isInFallback) {
        patch2(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch2(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch2(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch2(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch2(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch2(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
__name(patchSuspense, "patchSuspense");
let hasWarned$1 = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if (false) {
    hasWarned$1 = true;
    console[console.info ? "info" : "log"](
      `<Suspense> is an experimental feature and its API will likely change.`
    );
  }
  const {
    p: patch2,
    m: move,
    um: unmount,
    n: next2,
    o: { parentNode, remove: remove22 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  if (false) {
    assertNumber(timeout, `Suspense timeout`);
  }
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (false) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(
            `suspense.resolve() is called without a pending branch.`
          );
        }
        if (suspense.isUnmounted) {
          throw new Error(
            `suspense.resolve() is called on an already unmounted suspense boundary.`
          );
        }
      }
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next2(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
            anchor = next2(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next2(activeBranch);
      const mountFallback = /* @__PURE__ */ __name(() => {
        if (!suspense.isInFallback) {
          return;
        }
        patch2(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      }, "mountFallback");
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next2(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        if (false) {
          pushWarningContext(vnode2);
        }
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next2(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove22(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (false) {
          popWarningContext();
        }
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
__name(createSuspenseBoundary, "createSuspenseBoundary");
function hydrateSuspense(node3, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node3.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node3,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
__name(hydrateSuspense, "hydrateSuspense");
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
__name(normalizeSuspenseChildren, "normalizeSuspenseChildren");
function normalizeSuspenseSlot(s) {
  let block2;
  if (isFunction$3(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block2 = currentBlock;
      closeBlock();
    }
  }
  if (isArray$5(s)) {
    const singleChild = filterSingleRoot(s);
    if (false) {
      warn$1$1(`<Suspense> slots expect a single root node.`);
    }
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block2 && !s.dynamicChildren) {
    s.dynamicChildren = block2.filter((c) => c !== s);
  }
  return s;
}
__name(normalizeSuspenseSlot, "normalizeSuspenseSlot");
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$5(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
__name(queueEffectWithSuspense, "queueEffectWithSuspense");
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
__name(setActiveBranch, "setActiveBranch");
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}
__name(isVNodeSuspensible, "isVNodeSuspensible");
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (false) {
    const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
    warn$1$1(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
__name(injectHook, "injectHook");
const createHook = /* @__PURE__ */ __name((lifecycle2) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle2 === "sp") {
    injectHook(lifecycle2, (...args) => hook(...args), target);
  }
}, "createHook");
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
__name(onErrorCaptured, "onErrorCaptured");
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
__name(validateDirectiveName, "validateDirectiveName");
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value3, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$3(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value3);
      }
      bindings.push({
        dir,
        instance,
        value: value3,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
__name(withDirectives, "withDirectives");
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
__name(invokeDirectiveHook, "invokeDirectiveHook");
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray$5(source) || isString$5(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l = source.length; i2 < l; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    if (false) {
      warn$1$1(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$6(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item2, i2) => renderItem(item2, i2, void 0, cached && cached[i2])
      );
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
__name(renderList, "renderList");
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray$5(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
__name(createSlots, "createSlots");
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options3, extraOptions) {
  return isFunction$3(options3) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options3.name }, extraOptions, { setup: options3 }))()
  ) : options3;
}
__name(defineComponent, "defineComponent");
const isAsyncWrapper = /* @__PURE__ */ __name((i2) => !!i2.type.__asyncLoader, "isAsyncWrapper");
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction$3(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = /* @__PURE__ */ __name(() => {
    retries++;
    pendingRequest = null;
    return load2();
  }, "retry");
  const load2 = /* @__PURE__ */ __name(() => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject2) => {
          const userRetry = /* @__PURE__ */ __name(() => resolve2(retry()), "userRetry");
          const userFail = /* @__PURE__ */ __name(() => reject2(err), "userFail");
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (false) {
        warn$1$1(
          `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
        );
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (false) {
        throw new Error(`Invalid async component load result: ${comp}`);
      }
      resolvedComp = comp;
      return comp;
    }));
  }, "load");
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load2,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = /* @__PURE__ */ __name((err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      }, "onError");
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load2().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load2().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.effect.dirty = true;
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
__name(defineAsyncComponent, "defineAsyncComponent");
function createInnerComp(comp, parent) {
  const { ref: ref22, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref22;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
__name(createInnerComp, "createInnerComp");
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default") props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (false) {
    warn$1$1(
      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
    );
    slot = /* @__PURE__ */ __name(() => [], "slot");
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
__name(renderSlot, "renderSlot");
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
__name(ensureValidVNode, "ensureValidVNode");
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if (false) {
    warn$1$1(`v-on with no argument expects an object value.`);
    return ret;
  }
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
__name(toHandlers, "toHandlers");
const getPublicInstance = /* @__PURE__ */ __name((i2) => {
  if (!i2) return null;
  if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
  return getPublicInstance(i2.parent);
}, "getPublicInstance");
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: /* @__PURE__ */ __name((i2) => i2, "$"),
    $el: /* @__PURE__ */ __name((i2) => i2.vnode.el, "$el"),
    $data: /* @__PURE__ */ __name((i2) => i2.data, "$data"),
    $props: /* @__PURE__ */ __name((i2) => false ? shallowReadonly(i2.props) : i2.props, "$props"),
    $attrs: /* @__PURE__ */ __name((i2) => false ? shallowReadonly(i2.attrs) : i2.attrs, "$attrs"),
    $slots: /* @__PURE__ */ __name((i2) => false ? shallowReadonly(i2.slots) : i2.slots, "$slots"),
    $refs: /* @__PURE__ */ __name((i2) => false ? shallowReadonly(i2.refs) : i2.refs, "$refs"),
    $parent: /* @__PURE__ */ __name((i2) => getPublicInstance(i2.parent), "$parent"),
    $root: /* @__PURE__ */ __name((i2) => getPublicInstance(i2.root), "$root"),
    $emit: /* @__PURE__ */ __name((i2) => i2.emit, "$emit"),
    $options: /* @__PURE__ */ __name((i2) => true ? resolveMergedOptions(i2) : i2.type, "$options"),
    $forceUpdate: /* @__PURE__ */ __name((i2) => i2.f || (i2.f = () => {
      i2.effect.dirty = true;
      queueJob(i2.update);
    }), "$forceUpdate"),
    $nextTick: /* @__PURE__ */ __name((i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)), "$nextTick"),
    $watch: /* @__PURE__ */ __name((i2) => true ? instanceWatch.bind(i2) : NOOP, "$watch")
  })
);
const isReservedPrefix = /* @__PURE__ */ __name((key) => key === "_" || key === "$", "isReservedPrefix");
const hasSetupBinding = /* @__PURE__ */ __name((state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$3(state, key), "hasSetupBinding");
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data: data22, props, accessCache, type, appContext } = instance;
    if (false) {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data22[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data22 !== EMPTY_OBJ && hasOwn$3(data22, key)) {
        accessCache[key] = 2;
        return data22[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$3(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$3(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      } else if (false) {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$3(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$3(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (false) {
      if (data22 !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn$3(data22, key)) {
        warn$1$1(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn$1$1(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value3) {
    const { data: data22, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value3;
      return true;
    } else if (false) {
      warn$1$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data22 !== EMPTY_OBJ && hasOwn$3(data22, key)) {
      data22[key] = value3;
      return true;
    } else if (hasOwn$3(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      if (false) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value: value3
        });
      } else {
        ctx[key] = value3;
      }
    }
    return true;
  },
  has({
    _: { data: data22, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data22 !== EMPTY_OBJ && hasOwn$3(data22, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$3(normalizedProps, key) || hasOwn$3(ctx, key) || hasOwn$3(publicPropertiesMap, key) || hasOwn$3(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$3(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (false) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$1(
  {},
  PublicInstanceProxyHandlers,
  {
    get(target, key) {
      if (key === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_2, key) {
      const has2 = key[0] !== "_" && !isGloballyAllowed(key);
      if (false) {
        warn$1$1(
          `Property ${JSON.stringify(
            key
          )} should not start with _ which is a reserved prefix for Vue internals.`
        );
      }
      return has2;
    }
  }
);
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: /* @__PURE__ */ __name(() => instance, "get")
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: /* @__PURE__ */ __name(() => publicPropertiesMap[key](instance), "get"),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
__name(createDevRenderContext, "createDevRenderContext");
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: /* @__PURE__ */ __name(() => instance.props[key], "get"),
        set: NOOP
      });
    });
  }
}
__name(exposePropsOnRenderContext, "exposePropsOnRenderContext");
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: /* @__PURE__ */ __name(() => setupState[key], "get"),
        set: NOOP
      });
    }
  });
}
__name(exposeSetupStateOnRenderContext, "exposeSetupStateOnRenderContext");
const warnRuntimeUsage = /* @__PURE__ */ __name((method) => warn$1$1(
  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
), "warnRuntimeUsage");
function defineProps() {
  if (false) {
    warnRuntimeUsage(`defineProps`);
  }
  return null;
}
__name(defineProps, "defineProps");
function defineEmits() {
  if (false) {
    warnRuntimeUsage(`defineEmits`);
  }
  return null;
}
__name(defineEmits, "defineEmits");
function defineExpose(exposed) {
  if (false) {
    warnRuntimeUsage(`defineExpose`);
  }
}
__name(defineExpose, "defineExpose");
function defineOptions(options3) {
  if (false) {
    warnRuntimeUsage(`defineOptions`);
  }
}
__name(defineOptions, "defineOptions");
function defineSlots() {
  if (false) {
    warnRuntimeUsage(`defineSlots`);
  }
  return null;
}
__name(defineSlots, "defineSlots");
function defineModel() {
  if (false) {
    warnRuntimeUsage("defineModel");
  }
}
__name(defineModel, "defineModel");
function withDefaults(props, defaults2) {
  if (false) {
    warnRuntimeUsage(`withDefaults`);
  }
  return null;
}
__name(withDefaults, "withDefaults");
function useSlots() {
  return getContext().slots;
}
__name(useSlots, "useSlots");
function useAttrs() {
  return getContext().attrs;
}
__name(useAttrs, "useAttrs");
function getContext() {
  const i2 = getCurrentInstance();
  if (false) {
    warn$1$1(`useContext() called without active instance.`);
  }
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
__name(getContext, "getContext");
function normalizePropsOrEmits(props) {
  return isArray$5(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
__name(normalizePropsOrEmits, "normalizePropsOrEmits");
function mergeDefaults(raw, defaults2) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults2) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if (isArray$5(opt) || isFunction$3(opt)) {
        opt = props[key] = { type: opt, default: defaults2[key] };
      } else {
        opt.default = defaults2[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults2[key] };
    } else if (false) {
      warn$1$1(`props default key "${key}" has no corresponding declaration.`);
    }
    if (opt && defaults2[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
__name(mergeDefaults, "mergeDefaults");
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if (isArray$5(a) && isArray$5(b)) return a.concat(b);
  return extend$1({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
__name(mergeModels, "mergeModels");
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: /* @__PURE__ */ __name(() => props[key], "get")
      });
    }
  }
  return ret;
}
__name(createPropsRestProxy, "createPropsRestProxy");
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if (false) {
    warn$1$1(
      `withAsyncContext called without active current instance. This is likely a bug.`
    );
  }
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise$1(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
__name(withAsyncContext, "withAsyncContext");
function createDuplicateChecker() {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache2[key]) {
      warn$1$1(`${type} property "${key}" is already defined in ${cache2[key]}.`);
    } else {
      cache2[key] = type;
    }
  };
}
__name(createDuplicateChecker, "createDuplicateChecker");
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options3 = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options3.beforeCreate) {
    callHook$1(options3.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created: created3,
    beforeMount: beforeMount4,
    mounted: mounted21,
    beforeUpdate: beforeUpdate2,
    updated: updated12,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount: beforeUnmount13,
    destroyed,
    unmounted: unmounted6,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options3;
  const checkDuplicateProperties = false ? createDuplicateChecker() : null;
  if (false) {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$3(methodHandler)) {
        if (false) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (false) {
          checkDuplicateProperties("Methods", key);
        }
      } else if (false) {
        warn$1$1(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if (false) {
      warn$1$1(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data22 = dataOptions.call(publicThis, publicThis);
    if (false) {
      warn$1$1(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!isObject$6(data22)) {
    } else {
      instance.data = reactive(data22);
      if (false) {
        for (const key in data22) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: /* @__PURE__ */ __name(() => data22[key], "get"),
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (false) {
        warn$1$1(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : false ? () => {
        warn$1$1(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      } : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: /* @__PURE__ */ __name(() => c.value, "get"),
        set: /* @__PURE__ */ __name((v2) => c.value = v2, "set")
      });
      if (false) {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created3) {
    callHook$1(created3, instance, "c");
  }
  function registerLifecycleHook(register3, hook) {
    if (isArray$5(hook)) {
      hook.forEach((_hook3) => register3(_hook3.bind(publicThis)));
    } else if (hook) {
      register3(hook.bind(publicThis));
    }
  }
  __name(registerLifecycleHook, "registerLifecycleHook");
  registerLifecycleHook(onBeforeMount, beforeMount4);
  registerLifecycleHook(onMounted, mounted21);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate2);
  registerLifecycleHook(onUpdated, updated12);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount13);
  registerLifecycleHook(onUnmounted, unmounted6);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$5(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: /* @__PURE__ */ __name(() => publicThis[key], "get"),
          set: /* @__PURE__ */ __name((val) => publicThis[key] = val, "set")
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}
__name(applyOptions, "applyOptions");
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$5(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$6(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: /* @__PURE__ */ __name(() => injected.value, "get"),
        set: /* @__PURE__ */ __name((v2) => injected.value = v2, "set")
      });
    } else {
      ctx[key] = injected;
    }
    if (false) {
      checkDuplicateProperties("Inject", key);
    }
  }
}
__name(resolveInjections, "resolveInjections");
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$5(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
__name(callHook$1, "callHook$1");
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$5(raw)) {
    const handler6 = ctx[raw];
    if (isFunction$3(handler6)) {
      watch(getter, handler6);
    } else if (false) {
      warn$1$1(`Invalid watch handler specified by key "${raw}"`, handler6);
    }
  } else if (isFunction$3(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$6(raw)) {
    if (isArray$5(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler6 = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$3(handler6)) {
        watch(getter, handler6, raw);
      } else if (false) {
        warn$1$1(`Invalid watch handler specified by key "${raw.handler}"`, handler6);
      }
    }
  } else if (false) {
    warn$1$1(`Invalid watch option: "${key}"`, raw);
  }
}
__name(createWatcher, "createWatcher");
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$6(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
__name(resolveMergedOptions, "resolveMergedOptions");
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions$1(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
__name(mergeOptions$1, "mergeOptions$1");
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return /* @__PURE__ */ __name(function mergedDataFn() {
    return extend$1(
      isFunction$3(to) ? to.call(this, this) : to,
      isFunction$3(from) ? from.call(this, this) : from
    );
  }, "mergedDataFn");
}
__name(mergeDataFn, "mergeDataFn");
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
__name(mergeInject, "mergeInject");
function normalizeInject(raw) {
  if (isArray$5(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
__name(normalizeInject, "normalizeInject");
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
__name(mergeAsArray, "mergeAsArray");
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
__name(mergeObjectOptions, "mergeObjectOptions");
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$5(to) && isArray$5(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
__name(mergeEmitsOrPropsOptions, "mergeEmitsOrPropsOptions");
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
__name(mergeWatchOptions, "mergeWatchOptions");
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
__name(createAppContext, "createAppContext");
let uid$1 = 0;
function createAppAPI(render2, hydrate2) {
  return /* @__PURE__ */ __name(function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$3(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$6(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
        if (false) {
          warn$1$1(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin, ...options3) {
        if (installedPlugins.has(plugin)) {
        } else if (plugin && isFunction$3(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options3);
        } else if (isFunction$3(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options3);
        } else if (false) {
          warn$1$1(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app2;
      },
      mixin(mixin) {
        if (true) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (false) {
            warn$1$1(
              "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
            );
          }
        } else if (false) {
          warn$1$1("Mixins are only available in builds supporting Options API");
        }
        return app2;
      },
      component(name, component) {
        if (false) {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (false) {
          warn$1$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (false) {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (false) {
          warn$1$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          if (false) {
            warn$1$1(
              `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
            );
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (false) {
            context.reload = () => {
              render2(
                cloneVNode(vnode),
                rootContainer,
                namespace
              );
            };
          }
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          if (false) {
            app2._instance = vnode.component;
            devtoolsInitApp(app2, version);
          }
          return getComponentPublicInstance(vnode.component);
        } else if (false) {
          warn$1$1(
            `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
          );
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          if (false) {
            app2._instance = null;
            devtoolsUnmountApp(app2);
          }
          delete app2._container.__vue_app__;
        } else if (false) {
          warn$1$1(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value3) {
        if (false) {
          warn$1$1(
            `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
          );
        }
        context.provides[key] = value3;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  }, "createApp");
}
__name(createAppAPI, "createAppAPI");
let currentApp = null;
function provide(key, value3) {
  if (!currentInstance) {
    if (false) {
      warn$1$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value3;
  }
}
__name(provide, "provide");
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (false) {
      warn$1$1(`injection "${String(key)}" not found.`);
    }
  } else if (false) {
    warn$1$1(`inject() can only be used inside setup() or functional components.`);
  }
}
__name(inject, "inject");
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
__name(hasInjectionContext, "hasInjectionContext");
const internalObjectProto = {};
const createInternalObject = /* @__PURE__ */ __name(() => Object.create(internalObjectProto), "createInternalObject");
const isInternalObject = /* @__PURE__ */ __name((obj) => Object.getPrototypeOf(obj) === internalObjectProto, "isInternalObject");
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs3 = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs3);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (false) {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs3;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs3;
}
__name(initProps, "initProps");
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId) return true;
    instance = instance.parent;
  }
}
__name(isInHmrContext, "isInHmrContext");
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs: attrs3,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options3] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value3 = rawProps[key];
        if (options3) {
          if (hasOwn$3(attrs3, key)) {
            if (value3 !== attrs3[key]) {
              attrs3[key] = value3;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$1(key);
            props[camelizedKey] = resolvePropValue(
              options3,
              rawCurrentProps,
              camelizedKey,
              value3,
              instance,
              false
            );
          }
        } else {
          if (value3 !== attrs3[key]) {
            attrs3[key] = value3;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs3)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$3(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate$1(key)) === key || !hasOwn$3(rawProps, kebabKey))) {
        if (options3) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options3,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs3 !== rawCurrentProps) {
      for (const key in attrs3) {
        if (!rawProps || !hasOwn$3(rawProps, key) && true) {
          delete attrs3[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
  if (false) {
    validateProps(rawProps || {}, props, instance);
  }
}
__name(updateProps, "updateProps");
function setFullProps(instance, rawProps, props, attrs3) {
  const [options3, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value3 = rawProps[key];
      let camelKey;
      if (options3 && hasOwn$3(options3, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value3;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value3;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs3) || value3 !== attrs3[key]) {
          attrs3[key] = value3;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options3,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$3(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
__name(setFullProps, "setFullProps");
function resolvePropValue(options3, props, key, value3, instance, isAbsent) {
  const opt = options3[key];
  if (opt != null) {
    const hasDefault = hasOwn$3(opt, "default");
    if (hasDefault && value3 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$3(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value3 = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value3 = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value3 = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value3 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value3 === "" || value3 === hyphenate$1(key))) {
        value3 = true;
      }
    }
  }
  return value3;
}
__name(resolvePropValue, "resolvePropValue");
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendProps = /* @__PURE__ */ __name((raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys2) needCastKeys.push(...keys2);
    }, "extendProps");
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$6(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$5(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      if (false) {
        warn$1$1(`props must be strings when using array syntax.`, raw[i2]);
      }
      const normalizedKey = camelize$1(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (false) {
      warn$1$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize$1(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop2 = normalized[normalizedKey] = isArray$5(opt) || isFunction$3(opt) ? { type: opt } : extend$1({}, opt);
        if (prop2) {
          const booleanIndex = getTypeIndex(Boolean, prop2.type);
          const stringIndex = getTypeIndex(String, prop2.type);
          prop2[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop2[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$3(prop2, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$6(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
__name(normalizePropsOptions, "normalizePropsOptions");
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  } else if (false) {
    warn$1$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
__name(validatePropName, "validatePropName");
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
__name(getType, "getType");
function isSameType(a, b) {
  return getType(a) === getType(b);
}
__name(isSameType, "isSameType");
function getTypeIndex(type, expectedTypes) {
  if (isArray$5(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$3(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
__name(getTypeIndex, "getTypeIndex");
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options3 = instance.propsOptions[0];
  for (const key in options3) {
    let opt = options3[key];
    if (opt == null) continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
      false ? shallowReadonly(resolvedValues) : resolvedValues,
      !hasOwn$3(rawProps, key) && !hasOwn$3(rawProps, hyphenate$1(key))
    );
  }
}
__name(validateProps, "validateProps");
function validateProp(name, value3, prop2, props, isAbsent) {
  const { type, required, validator: validator3, skipCheck } = prop2;
  if (required && isAbsent) {
    warn$1$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value3 == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid2 = false;
    const types = isArray$5(type) ? type : [type];
    const expectedTypes = [];
    for (let i2 = 0; i2 < types.length && !isValid2; i2++) {
      const { valid, expectedType } = assertType(value3, types[i2]);
      expectedTypes.push(expectedType || "");
      isValid2 = valid;
    }
    if (!isValid2) {
      warn$1$1(getInvalidTypeMessage(name, value3, expectedTypes));
      return;
    }
  }
  if (validator3 && !validator3(value3, props)) {
    warn$1$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
__name(validateProp, "validateProp");
const isSimpleType = /* @__PURE__ */ makeMap(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function assertType(value3, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value3;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value3 instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$6(value3);
  } else if (expectedType === "Array") {
    valid = isArray$5(value3);
  } else if (expectedType === "null") {
    valid = value3 === null;
  } else {
    valid = value3 instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
__name(assertType, "assertType");
function getInvalidTypeMessage(name, value3, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message2 = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize$1).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value3);
  const expectedValue = styleValue(value3, expectedType);
  const receivedValue = styleValue(value3, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean$3(expectedType, receivedType)) {
    message2 += ` with value ${expectedValue}`;
  }
  message2 += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message2 += `with value ${receivedValue}.`;
  }
  return message2;
}
__name(getInvalidTypeMessage, "getInvalidTypeMessage");
function styleValue(value3, type) {
  if (type === "String") {
    return `"${value3}"`;
  } else if (type === "Number") {
    return `${Number(value3)}`;
  } else {
    return `${value3}`;
  }
}
__name(styleValue, "styleValue");
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
__name(isExplicable, "isExplicable");
function isBoolean$3(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
__name(isBoolean$3, "isBoolean$3");
const isInternalKey = /* @__PURE__ */ __name((key) => key[0] === "_" || key === "$stable", "isInternalKey");
const normalizeSlotValue = /* @__PURE__ */ __name((value3) => isArray$5(value3) ? value3.map(normalizeVNode) : [normalizeVNode(value3)], "normalizeSlotValue");
const normalizeSlot$1 = /* @__PURE__ */ __name((key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) {
      warn$1$1(
        `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
      );
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
}, "normalizeSlot$1");
const normalizeObjectSlots = /* @__PURE__ */ __name((rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value3 = rawSlots[key];
    if (isFunction$3(value3)) {
      slots[key] = normalizeSlot$1(key, value3, ctx);
    } else if (value3 != null) {
      if (false) {
        warn$1$1(
          `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(value3);
      slots[key] = () => normalized;
    }
  }
}, "normalizeObjectSlots");
const normalizeVNodeSlots = /* @__PURE__ */ __name((instance, children) => {
  if (false) {
    warn$1$1(
      `Non-function value encountered for default slot. Prefer function slots for better performance.`
    );
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
}, "normalizeVNodeSlots");
const initSlots = /* @__PURE__ */ __name((instance, children) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      extend$1(slots, children);
      def(slots, "_", type, true);
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
}, "initSlots");
const updateSlots = /* @__PURE__ */ __name((instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (false) {
        extend$1(slots, children);
        trigger(instance, "set", "$slots");
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
}, "updateSlots");
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$5(rawRef)) {
    rawRef.forEach(
      (r, i2) => setRef(
        r,
        oldRawRef && (isArray$5(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value3 = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  if (false) {
    warn$1$1(
      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
    );
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref3) {
    if (isString$5(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$3(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$3(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value3, refs]);
  } else {
    const _isString = isString$5(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = /* @__PURE__ */ __name(() => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$3(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$5(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$5(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (hasOwn$3(setupState, ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value3;
          if (hasOwn$3(setupState, ref3)) {
            setupState[ref3] = value3;
          }
        } else if (_isRef) {
          ref3.value = value3;
          if (rawRef.k) refs[rawRef.k] = value3;
        } else if (false) {
          warn$1$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
        }
      }, "doSet");
      if (value3) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (false) {
      warn$1$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
    }
  }
}
__name(setRef, "setRef");
let hasLoggedMismatchError = false;
const logMismatchError = /* @__PURE__ */ __name(() => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
}, "logMismatchError");
const isSVGContainer = /* @__PURE__ */ __name((container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject", "isSVGContainer");
const isMathMLContainer = /* @__PURE__ */ __name((container) => container.namespaceURI.includes("MathML"), "isMathMLContainer");
const getContainerType = /* @__PURE__ */ __name((container) => {
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
}, "getContainerType");
const isComment = /* @__PURE__ */ __name((node3) => node3.nodeType === 8, "isComment");
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch2,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove22,
      insert: insert2,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = /* @__PURE__ */ __name((vnode, container) => {
    if (!container.hasChildNodes()) {
      patch2(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  }, "hydrate");
  const hydrateNode = /* @__PURE__ */ __name((node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node3) && node3.data === "[";
    const onMismatch = /* @__PURE__ */ __name(() => handleMismatch(
      node3,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    ), "onMismatch");
    const { type, ref: ref3, shapeFlag, patchFlag } = vnode;
    let domType = node3.nodeType;
    vnode.el = node3;
    if (false) {
      def(node3, "__vnode", vnode, true);
      def(node3, "__vueParentComponent", parentComponent, true);
    }
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text$1:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert2(vnode.el = createText(""), parentNode(node3), node3);
            nextNode = node3;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node3.data !== vnode.children) {
            logMismatchError();
            node3.data = vnode.children;
          }
          nextNode = nextSibling(node3);
        }
        break;
      case Comment:
        if (isTemplateNode(node3)) {
          nextNode = nextSibling(node3);
          replaceNode(
            vnode.el = node3.content.firstChild,
            node3,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node3);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node3 = nextSibling(node3);
          domType = node3.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node3;
          const needToAdoptContent = !vnode.children.length;
          for (let i2 = 0; i2 < vnode.staticCount; i2++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i2 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node3,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node3.tagName.toLowerCase()) && !isTemplateNode(node3)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node3,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node3);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node3);
          } else if (isComment(node3) && node3.data === "teleport start") {
            nextNode = locateClosingAnchor(node3, node3.data, "teleport end");
          } else {
            nextNode = nextSibling(node3);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node3.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node3;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node3,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node3,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node3)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else if (false) {
          warn$1$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode);
    }
    return nextNode;
  }, "hydrateNode");
  const hydrateElement = /* @__PURE__ */ __name((el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content2 = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content2);
        }
        replaceNode(content2, el, parentComponent);
        vnode.el = el = content2;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next2 = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        let hasWarned2 = false;
        while (next2) {
          if (false) {
            warn$1$1(
              `Hydration children mismatch on`,
              el,
              `
Server rendered element contains more child nodes than client vdom.`
            );
            hasWarned2 = true;
          }
          logMismatchError();
          const cur = next2;
          next2 = next2.nextSibling;
          remove22(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          logMismatchError();
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (forcePatch || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (false) {
              logMismatchError();
            }
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === ".") {
              patchProp2(
                el,
                key,
                null,
                props[key],
                void 0,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  }, "hydrateElement");
  const hydrateChildren = /* @__PURE__ */ __name((node3, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned2 = false;
    for (let i2 = 0; i2 < l; i2++) {
      const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
      if (node3) {
        node3 = hydrateNode(
          node3,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text$1 && !vnode.children) {
        insert2(vnode.el = createText(""), container);
      } else {
        if (false) {
          warn$1$1(
            `Hydration children mismatch on`,
            container,
            `
Server rendered element contains fewer child nodes than client vdom.`
          );
          hasWarned2 = true;
        }
        logMismatchError();
        patch2(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node3;
  }, "hydrateChildren");
  const hydrateFragment = /* @__PURE__ */ __name((node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node3);
    const next2 = hydrateChildren(
      nextSibling(node3),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next2 && isComment(next2) && next2.data === "]") {
      return nextSibling(vnode.anchor = next2);
    } else {
      logMismatchError();
      insert2(vnode.anchor = createComment(`]`), container, next2);
      return next2;
    }
  }, "hydrateFragment");
  const handleMismatch = /* @__PURE__ */ __name((node3, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    logMismatchError();
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node3);
      while (true) {
        const next22 = nextSibling(node3);
        if (next22 && next22 !== end) {
          remove22(next22);
        } else {
          break;
        }
      }
    }
    const next2 = nextSibling(node3);
    const container = parentNode(node3);
    remove22(node3);
    patch2(
      null,
      vnode,
      container,
      next2,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    return next2;
  }, "handleMismatch");
  const locateClosingAnchor = /* @__PURE__ */ __name((node3, open2 = "[", close4 = "]") => {
    let match = 0;
    while (node3) {
      node3 = nextSibling(node3);
      if (node3 && isComment(node3)) {
        if (node3.data === open2) match++;
        if (node3.data === close4) {
          if (match === 0) {
            return nextSibling(node3);
          } else {
            match--;
          }
        }
      }
    }
    return node3;
  }, "locateClosingAnchor");
  const replaceNode = /* @__PURE__ */ __name((newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  }, "replaceNode");
  const isTemplateNode = /* @__PURE__ */ __name((node3) => {
    return node3.nodeType === 1 && node3.tagName.toLowerCase() === "template";
  }, "isTemplateNode");
  return [hydrate2, hydrateNode];
}
__name(createHydrationFunctions, "createHydrationFunctions");
function propHasMismatch(el, key, clientValue, vnode, instance) {
  let mismatchType;
  let mismatchKey;
  let actual;
  let expected;
  if (key === "class") {
    actual = el.getAttribute("class");
    expected = normalizeClass(clientValue);
    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
      mismatchType = mismatchKey = `class`;
    }
  } else if (key === "style") {
    actual = el.getAttribute("style") || "";
    expected = isString$5(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));
    const actualMap = toStyleMap(actual);
    const expectedMap = toStyleMap(expected);
    if (vnode.dirs) {
      for (const { dir, value: value3 } of vnode.dirs) {
        if (dir.name === "show" && !value3) {
          expectedMap.set("display", "none");
        }
      }
    }
    if (instance) {
      resolveCssVars(instance, vnode, expectedMap);
    }
    if (!isMapEqual(actualMap, expectedMap)) {
      mismatchType = mismatchKey = "style";
    }
  } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {
    if (isBooleanAttr(key)) {
      actual = el.hasAttribute(key);
      expected = includeBooleanAttr(clientValue);
    } else if (clientValue == null) {
      actual = el.hasAttribute(key);
      expected = false;
    } else {
      if (el.hasAttribute(key)) {
        actual = el.getAttribute(key);
      } else if (key === "value" && el.tagName === "TEXTAREA") {
        actual = el.value;
      } else {
        actual = false;
      }
      expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;
    }
    if (actual !== expected) {
      mismatchType = `attribute`;
      mismatchKey = key;
    }
  }
  if (mismatchType) {
    const format2 = /* @__PURE__ */ __name((v2) => v2 === false ? `(not rendered)` : `${mismatchKey}="${v2}"`, "format");
    const preSegment = `Hydration ${mismatchType} mismatch on`;
    const postSegment = `
  - rendered on server: ${format2(actual)}
  - expected on client: ${format2(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    {
      warn$1$1(preSegment, el, postSegment);
    }
    return true;
  }
  return false;
}
__name(propHasMismatch, "propHasMismatch");
function toClassSet(str) {
  return new Set(str.trim().split(/\s+/));
}
__name(toClassSet, "toClassSet");
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const s of a) {
    if (!b.has(s)) {
      return false;
    }
  }
  return true;
}
__name(isSetEqual, "isSetEqual");
function toStyleMap(str) {
  const styleMap = /* @__PURE__ */ new Map();
  for (const item2 of str.split(";")) {
    let [key, value3] = item2.split(":");
    key = key.trim();
    value3 = value3 && value3.trim();
    if (key && value3) {
      styleMap.set(key, value3);
    }
  }
  return styleMap;
}
__name(toStyleMap, "toStyleMap");
function isMapEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value3] of a) {
    if (value3 !== b.get(key)) {
      return false;
    }
  }
  return true;
}
__name(isMapEqual, "isMapEqual");
function resolveCssVars(instance, vnode, expectedMap) {
  const root23 = instance.subTree;
  if (instance.getCssVars && (vnode === root23 || root23 && root23.type === Fragment && root23.children.includes(vnode))) {
    const cssVars = instance.getCssVars();
    for (const key in cssVars) {
      expectedMap.set(`--${key}`, String(cssVars[key]));
    }
  }
  if (vnode === root23 && instance.parent) {
    resolveCssVars(instance.parent, instance.vnode, expectedMap);
  }
}
__name(resolveCssVars, "resolveCssVars");
let supported$1;
let perf$1;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf$1.mark(`vue-${type}-${instance.uid}`);
  }
  if (false) {
    devtoolsPerfStart(instance, type, isSupported() ? perf$1.now() : Date.now());
  }
}
__name(startMeasure, "startMeasure");
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf$1.mark(endTag);
    perf$1.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf$1.clearMarks(startTag);
    perf$1.clearMarks(endTag);
  }
  if (false) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf$1.now() : Date.now());
  }
}
__name(endMeasure, "endMeasure");
function isSupported() {
  if (supported$1 !== void 0) {
    return supported$1;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported$1 = true;
    perf$1 = window.performance;
  } else {
    supported$1 = false;
  }
  return supported$1;
}
__name(isSupported, "isSupported");
function initFeatureFlags$2() {
  const needWarn = [];
  if (false) {
    getGlobalThis$1().__VUE_OPTIONS_API__ = true;
  }
  if (false) {
    getGlobalThis$1().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (false) {
    getGlobalThis$1().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
  if (false) {
    const multi = needWarn.length > 1;
    console.warn(
      `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
__name(initFeatureFlags$2, "initFeatureFlags$2");
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options3) {
  return baseCreateRenderer(options3);
}
__name(createRenderer, "createRenderer");
function createHydrationRenderer(options3) {
  return baseCreateRenderer(options3, createHydrationFunctions);
}
__name(createHydrationRenderer, "createHydrationRenderer");
function baseCreateRenderer(options3, createHydrationFns) {
  {
    initFeatureFlags$2();
  }
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  if (false) {
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options3;
  const patch2 = /* @__PURE__ */ __name((n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = false ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text$1:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        } else if (false) {
          patchStaticNode(n1, n2, container, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (false) {
          warn$1$1("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  }, "patch");
  const processText = /* @__PURE__ */ __name((n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  }, "processText");
  const processCommentNode = /* @__PURE__ */ __name((n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  }, "processCommentNode");
  const mountStaticNode = /* @__PURE__ */ __name((n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  }, "mountStaticNode");
  const patchStaticNode = /* @__PURE__ */ __name((n1, n2, container, namespace) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace
      );
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  }, "patchStaticNode");
  const moveStaticNode = /* @__PURE__ */ __name(({ el, anchor }, container, nextSibling) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next2;
    }
    hostInsert(anchor, container, nextSibling);
  }, "moveStaticNode");
  const removeStaticNode = /* @__PURE__ */ __name(({ el, anchor }) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostRemove(el);
      el = next2;
    }
    hostRemove(anchor);
  }, "removeStaticNode");
  const processElement = /* @__PURE__ */ __name((n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  }, "processElement");
  const mountElement = /* @__PURE__ */ __name((vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (false) {
      def(el, "__vnode", vnode, true);
      def(el, "__vueParentComponent", parentComponent, true);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  }, "mountElement");
  const setScopeId = /* @__PURE__ */ __name((el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (false) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  }, "setScopeId");
  const mountChildren = /* @__PURE__ */ __name((children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch2(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  }, "mountChildren");
  const patchElement = /* @__PURE__ */ __name((n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    if (false) {
      el.__vnode = n2;
    }
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
      if (false) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev2 = oldProps[key];
            const next2 = newProps[key];
            if (next2 !== prev2 || key === "value") {
              hostPatchProp(
                el,
                key,
                prev2,
                next2,
                namespace,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        namespace
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  }, "patchElement");
  const patchBlockChildren = /* @__PURE__ */ __name((oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch2(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  }, "patchBlockChildren");
  const patchProps = /* @__PURE__ */ __name((el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next2 = newProps[key];
        const prev2 = oldProps[key];
        if (next2 !== prev2 && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev2,
            next2,
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  }, "patchProps");
  const processFragment = /* @__PURE__ */ __name((n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (false) {
          traverseStaticChildren(n1, n2);
        } else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  }, "processFragment");
  const processComponent = /* @__PURE__ */ __name((n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  }, "processComponent");
  const mountComponent = /* @__PURE__ */ __name((initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (false) {
      registerHMR(instance);
    }
    if (false) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (false) {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      if (false) {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
    if (false) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  }, "mountComponent");
  const updateComponent = /* @__PURE__ */ __name((n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (false) {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (false) {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.effect.dirty = true;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  }, "updateComponent");
  const setupRenderEffect = /* @__PURE__ */ __name((instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = /* @__PURE__ */ __name(() => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = /* @__PURE__ */ __name(() => {
            if (false) {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (false) {
              endMeasure(instance, `render`);
            }
            if (false) {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (false) {
              endMeasure(instance, `hydrate`);
            }
          }, "hydrateSubTree");
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (false) {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (false) {
            endMeasure(instance, `render`);
          }
          if (false) {
            startMeasure(instance, `patch`);
          }
          patch2(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          if (false) {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (false) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next: next2, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next2) {
              next2.el = vnode.el;
              updateComponentPreRender(instance, next2, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next2;
        let vnodeHook;
        if (false) {
          pushWarningContext(next2 || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next2) {
          next2.el = vnode.el;
          updateComponentPreRender(instance, next2, optimized);
        } else {
          next2 = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next2, vnode);
        }
        toggleRecurse(instance, true);
        if (false) {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (false) {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (false) {
          startMeasure(instance, `patch`);
        }
        patch2(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        if (false) {
          endMeasure(instance, `patch`);
        }
        next2.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next2, vnode),
            parentSuspense
          );
        }
        if (false) {
          devtoolsComponentUpdated(instance);
        }
        if (false) {
          popWarningContext();
        }
      }
    }, "componentUpdateFn");
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      NOOP,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => {
      if (effect2.dirty) {
        effect2.run();
      }
    };
    update.id = instance.uid;
    toggleRecurse(instance, true);
    if (false) {
      effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
      effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      update.ownerInstance = instance;
    }
    update();
  }, "setupRenderEffect");
  const updateComponentPreRender = /* @__PURE__ */ __name((instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  }, "updateComponentPreRender");
  const patchChildren = /* @__PURE__ */ __name((n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  }, "patchChildren");
  const patchUnkeyedChildren = /* @__PURE__ */ __name((c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch2(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  }, "patchUnkeyedChildren");
  const patchKeyedChildren = /* @__PURE__ */ __name((c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch2(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch2(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch2(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          if (false) {
            warn$1$1(
              `Duplicate keys found during update:`,
              JSON.stringify(nextChild.key),
              `Make sure keys are unique.`
            );
          }
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch2(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch2(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  }, "patchKeyedChildren");
  const move = /* @__PURE__ */ __name((vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove222 = /* @__PURE__ */ __name(() => hostInsert(el, container, anchor), "remove22");
        const performLeave = /* @__PURE__ */ __name(() => {
          leave(el, () => {
            remove222();
            afterLeave && afterLeave();
          });
        }, "performLeave");
        if (delayLeave) {
          delayLeave(el, remove222, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  }, "move");
  const unmount = /* @__PURE__ */ __name((vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      memoIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (memoIndex != null) {
      parentComponent.renderCache[memoIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove22(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  }, "unmount");
  const remove22 = /* @__PURE__ */ __name((vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (false) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove22(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = /* @__PURE__ */ __name(() => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    }, "performRemove");
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = /* @__PURE__ */ __name(() => leave(el, performRemove), "performLeave");
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  }, "remove2");
  const removeFragment = /* @__PURE__ */ __name((cur, end) => {
    let next2;
    while (cur !== end) {
      next2 = hostNextSibling(cur);
      hostRemove(cur);
      cur = next2;
    }
    hostRemove(end);
  }, "removeFragment");
  const unmountComponent = /* @__PURE__ */ __name((instance, parentSuspense, doRemove) => {
    if (false) {
      unregisterHMR(instance);
    }
    const { bum, scope, update, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (false) {
      devtoolsComponentRemoved(instance);
    }
  }, "unmountComponent");
  const unmountChildren = /* @__PURE__ */ __name((children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  }, "unmountChildren");
  const getNextHostNode = /* @__PURE__ */ __name((vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  }, "getNextHostNode");
  let isFlushing2 = false;
  const render2 = /* @__PURE__ */ __name((vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch2(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    if (!isFlushing2) {
      isFlushing2 = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing2 = false;
    }
    container._vnode = vnode;
  }, "render");
  const internals = {
    p: patch2,
    um: unmount,
    m: move,
    r: remove22,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options3
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
__name(baseCreateRenderer, "baseCreateRenderer");
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
__name(resolveChildrenNamespace, "resolveChildrenNamespace");
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
__name(toggleRecurse, "toggleRecurse");
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
__name(needTransition, "needTransition");
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$5(ch1) && isArray$5(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text$1) {
        c2.el = c1.el;
      }
      if (false) {
        c2.el = c1.el;
      }
    }
  }
}
__name(traverseStaticChildren, "traverseStaticChildren");
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u, v2, c;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c = u + v2 >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v2 = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i2] = result[u - 1];
        }
        result[u] = i2;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
__name(getSequence, "getSequence");
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
__name(locateNonHydratedAsyncRoot, "locateNonHydratedAsyncRoot");
function invalidateMount(hooks) {
  if (hooks) {
    for (let i2 = 0; i2 < hooks.length; i2++) hooks[i2].active = false;
  }
}
__name(invalidateMount, "invalidateMount");
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = /* @__PURE__ */ __name(() => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
    }
    return ctx;
  }
}, "useSSRContext");
function watchEffect(effect2, options3) {
  return doWatch(effect2, null, options3);
}
__name(watchEffect, "watchEffect");
function watchPostEffect(effect2, options3) {
  return doWatch(
    effect2,
    null,
    false ? extend$1({}, options3, { flush: "post" }) : { flush: "post" }
  );
}
__name(watchPostEffect, "watchPostEffect");
function watchSyncEffect(effect2, options3) {
  return doWatch(
    effect2,
    null,
    false ? extend$1({}, options3, { flush: "sync" }) : { flush: "sync" }
  );
}
__name(watchSyncEffect, "watchSyncEffect");
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options3) {
  if (false) {
    warn$1$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options3);
}
__name(watch, "watch");
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once: once2,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once2) {
    const _cb = cb;
    cb = /* @__PURE__ */ __name((...args) => {
      _cb(...args);
      unwatch();
    }, "cb");
  }
  if (false) {
    warn$1$1(
      `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
    );
  }
  if (false) {
    if (immediate !== void 0) {
      warn$1$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once2 !== void 0) {
      warn$1$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const warnInvalidSource = /* @__PURE__ */ __name((s) => {
    warn$1$1(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  }, "warnInvalidSource");
  const instance = currentInstance;
  const reactiveGetter = /* @__PURE__ */ __name((source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  ), "reactiveGetter");
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = /* @__PURE__ */ __name(() => source.value, "getter");
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = /* @__PURE__ */ __name(() => reactiveGetter(source), "getter");
    forceTrigger = true;
  } else if (isArray$5(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = /* @__PURE__ */ __name(() => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$3(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
      }
    }), "getter");
  } else if (isFunction$3(source)) {
    if (cb) {
      getter = /* @__PURE__ */ __name(() => callWithErrorHandling(source, instance, 2), "getter");
    } else {
      getter = /* @__PURE__ */ __name(() => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      }, "getter");
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = /* @__PURE__ */ __name(() => traverse(baseGetter()), "getter");
  }
  let cleanup;
  let onCleanup = /* @__PURE__ */ __name((fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect2.onStop = void 0;
    };
  }, "onCleanup");
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = /* @__PURE__ */ __name(() => {
    if (!effect2.active || !effect2.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  }, "job");
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = /* @__PURE__ */ __name(() => queuePostRenderEffect(job, instance && instance.suspense), "scheduler");
  } else {
    job.pre = true;
    if (instance) job.id = instance.uid;
    scheduler = /* @__PURE__ */ __name(() => queueJob(job), "scheduler");
  }
  const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = /* @__PURE__ */ __name(() => {
    effect2.stop();
    if (scope) {
      remove$1(scope.effects, effect2);
    }
  }, "unwatch");
  if (false) {
    effect2.onTrack = onTrack;
    effect2.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  if (ssrCleanup) ssrCleanup.push(unwatch);
  return unwatch;
}
__name(doWatch, "doWatch");
function instanceWatch(source, value3, options3) {
  const publicThis = this.proxy;
  const getter = isString$5(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$3(value3)) {
    cb = value3;
  } else {
    cb = value3.handler;
    options3 = value3;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options3);
  reset();
  return res;
}
__name(instanceWatch, "instanceWatch");
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
__name(createPathGetter, "createPathGetter");
function traverse(value3, depth = Infinity, seen2) {
  if (depth <= 0 || !isObject$6(value3) || value3["__v_skip"]) {
    return value3;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value3)) {
    return value3;
  }
  seen2.add(value3);
  depth--;
  if (isRef(value3)) {
    traverse(value3.value, depth, seen2);
  } else if (isArray$5(value3)) {
    for (let i2 = 0; i2 < value3.length; i2++) {
      traverse(value3[i2], depth, seen2);
    }
  } else if (isSet(value3) || isMap(value3)) {
    value3.forEach((v2) => {
      traverse(v2, depth, seen2);
    });
  } else if (isPlainObject$3(value3)) {
    for (const key in value3) {
      traverse(value3[key], depth, seen2);
    }
    for (const key of Object.getOwnPropertySymbols(value3)) {
      if (Object.prototype.propertyIsEnumerable.call(value3, key)) {
        traverse(value3[key], depth, seen2);
      }
    }
  }
  return value3;
}
__name(traverse, "traverse");
const isKeepAlive = /* @__PURE__ */ __name((vnode) => vnode.type.__isKeepAlive, "isKeepAlive");
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache2 = /* @__PURE__ */ new Map();
    const keys2 = /* @__PURE__ */ new Set();
    let current = null;
    if (false) {
      instance.__v_cache = cache2;
    }
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch2,
        m: move,
        um: _unmount,
        o: { createElement: createElement2 }
      }
    } = sharedContext;
    const storageContainer = createElement2("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch2(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (false) {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (false) {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    __name(unmount, "unmount");
    function pruneCache(filter4) {
      cache2.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter4 || !filter4(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    __name(pruneCache, "pruneCache");
    function pruneCacheEntry(key) {
      const cached = cache2.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache2.delete(key);
      keys2.delete(key);
    }
    __name(pruneCacheEntry, "pruneCacheEntry");
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = /* @__PURE__ */ __name(() => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    }, "cacheSubtree");
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache2.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (false) {
          warn$1$1(`KeepAlive should contain exactly one component child.`);
        }
        current = null;
        return children;
      } else if (!isVNode$1(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache2.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys2.delete(key);
        keys2.add(key);
      } else {
        keys2.add(key);
        if (max && keys2.size > parseInt(max, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray$5(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString$5(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp$2(pattern)) {
    return pattern.test(name);
  }
  return false;
}
__name(matches, "matches");
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
__name(onActivated, "onActivated");
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
__name(onDeactivated, "onDeactivated");
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
__name(registerKeepAliveHook, "registerKeepAliveHook");
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove$1(keepAliveRoot[type], injected);
  }, target);
}
__name(injectToKeepAliveRoot, "injectToKeepAliveRoot");
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
__name(resetShapeFlag, "resetShapeFlag");
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
__name(getInnerChild, "getInnerChild");
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
__name(useTransitionState, "useTransitionState");
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = /* @__PURE__ */ __name((instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
}, "recursiveGetSubtree");
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if (false) {
              warn$1$1(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            child = c;
            hasFound = true;
            if (true) break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode: mode2 } = rawProps;
      if (false) {
        warn$1$1(`invalid <transition> mode: ${mode2}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode2 === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.effect.dirty = true;
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode2 === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
__name(getLeavingNodesForType, "getLeavingNodesForType");
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode: mode2,
    persisted = false,
    onBeforeEnter: onBeforeEnter3,
    onEnter: onEnter7,
    onAfterEnter: onAfterEnter4,
    onEnterCancelled,
    onBeforeLeave: onBeforeLeave3,
    onLeave: onLeave5,
    onAfterLeave: onAfterLeave6,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = /* @__PURE__ */ __name((hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  }, "callHook2");
  const callAsyncHook = /* @__PURE__ */ __name((hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$5(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  }, "callAsyncHook");
  const hooks = {
    mode: mode2,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter3;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter3;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter7;
      let afterHook = onAfterEnter4;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter7;
          afterHook = onAfterAppear || onAfterEnter4;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove22) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove22();
      }
      callHook2(onBeforeLeave3, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove22();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave6, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave5) {
        callAsyncHook(onLeave5, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
__name(resolveTransitionHooks, "resolveTransitionHooks");
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
__name(emptyPlaceholder, "emptyPlaceholder");
function getKeepAliveChild(vnode) {
  if (!isKeepAlive(vnode)) {
    return vnode;
  }
  if (false) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$3(children.default)) {
      return children.default();
    }
  }
}
__name(getKeepAliveChild, "getKeepAliveChild");
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
__name(setTransitionHooks, "setTransitionHooks");
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
__name(getTransitionRawChildren, "getTransitionRawChildren");
const isTeleport = /* @__PURE__ */ __name((type) => type.__isTeleport, "isTeleport");
const isTeleportDisabled = /* @__PURE__ */ __name((props) => props && (props.disabled || props.disabled === ""), "isTeleportDisabled");
const isTargetSVG = /* @__PURE__ */ __name((target) => typeof SVGElement !== "undefined" && target instanceof SVGElement, "isTargetSVG");
const isTargetMathML = /* @__PURE__ */ __name((target) => typeof MathMLElement === "function" && target instanceof MathMLElement, "isTargetMathML");
const resolveTarget = /* @__PURE__ */ __name((props, select) => {
  const targetSelector = props && props.to;
  if (isString$5(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      if (false) {
        warn$1$1(
          `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
        );
      }
      return target;
    }
  } else {
    if (false) {
      warn$1$1(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
}, "resolveTarget");
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert: insert2, querySelector, createText, createComment }
    } = internals;
    const disabled2 = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (false) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el = false ? createComment("teleport start") : createText("");
      const mainAnchor = n2.anchor = false ? createComment("teleport end") : createText("");
      insert2(placeholder, container, anchor);
      insert2(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert2(targetAnchor, target);
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
      } else if (false) {
        warn$1$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
      }
      const mount2 = /* @__PURE__ */ __name((container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }, "mount");
      if (disabled2) {
        mount2(container, mainAnchor);
      } else if (target) {
        mount2(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled2) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          } else if (false) {
            warn$1$1(
              "Invalid Teleport target on update:",
              target,
              `(${typeof target})`
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert: insert2 }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert2(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert2(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert2(anchor, container, parentAnchor);
  }
}
__name(moveTeleport, "moveTeleport");
function hydrateTeleport(node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node3),
          vnode,
          parentNode(node3),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node3);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
__name(hydrateTeleport, "hydrateTeleport");
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node3 = vnode.children[0].el;
    while (node3 && node3 !== vnode.targetAnchor) {
      if (node3.nodeType === 1) node3.setAttribute("data-v-owner", ctx.uid);
      node3 = node3.nextSibling;
    }
    ctx.ut();
  }
}
__name(updateCssVars, "updateCssVars");
const Fragment = Symbol.for("v-fgt");
const Text$1 = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
__name(openBlock, "openBlock");
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
__name(closeBlock, "closeBlock");
let isBlockTreeEnabled = 1;
function setBlockTracking(value3) {
  isBlockTreeEnabled += value3;
}
__name(setBlockTracking, "setBlockTracking");
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
__name(setupBlock, "setupBlock");
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
__name(createElementBlock, "createElementBlock");
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
__name(createBlock, "createBlock");
function isVNode$1(value3) {
  return value3 ? value3.__v_isVNode === true : false;
}
__name(isVNode$1, "isVNode$1");
function isSameVNodeType(n1, n2) {
  if (false) {
    n1.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
__name(isSameVNodeType, "isSameVNodeType");
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
__name(transformVNodeArgs, "transformVNodeArgs");
const createVNodeWithArgsTransform = /* @__PURE__ */ __name((...args) => {
  return _createVNode(
    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
  );
}, "createVNodeWithArgsTransform");
const normalizeKey = /* @__PURE__ */ __name(({ key }) => key != null ? key : null, "normalizeKey");
const normalizeRef = /* @__PURE__ */ __name(({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$5(ref3) || isRef(ref3) || isFunction$3(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
}, "normalizeRef");
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$5(children) ? 8 : 16;
  }
  if (false) {
    warn$1$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
__name(createBaseVNode, "createBaseVNode");
const createVNode = false ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (false) {
      warn$1$1(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$5(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$6(style)) {
      if (isProxy(style) && !isArray$5(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$5(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$6(type) ? 4 : isFunction$3(type) ? 2 : 0;
  if (false) {
    type = toRaw(type);
    warn$1$1(
      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
      `
Component that was made reactive: `,
      type
    );
  }
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
__name(_createVNode, "_createVNode");
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
}
__name(guardReactiveProps, "guardReactiveProps");
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$5(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: false ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
__name(cloneVNode, "cloneVNode");
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray$5(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
__name(deepCloneVNode, "deepCloneVNode");
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text$1, null, text, flag);
}
__name(createTextVNode, "createTextVNode");
function createStaticVNode(content2, numberOfNodes) {
  const vnode = createVNode(Static, null, content2);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
__name(createStaticVNode, "createStaticVNode");
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
__name(createCommentVNode, "createCommentVNode");
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$5(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text$1, null, String(child));
  }
}
__name(normalizeVNode, "normalizeVNode");
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
__name(cloneIfMounted, "cloneIfMounted");
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$5(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$3(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
__name(normalizeChildren, "normalizeChildren");
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$5(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
__name(mergeProps, "mergeProps");
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
__name(invokeVNodeHook, "invokeVNodeHook");
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (false) {
    instance.ctx = createDevRenderContext(instance);
  } else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
__name(createComponentInstance, "createComponentInstance");
let currentInstance = null;
const getCurrentInstance = /* @__PURE__ */ __name(() => currentInstance || currentRenderingInstance, "getCurrentInstance");
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis$1();
  const registerGlobalSetter = /* @__PURE__ */ __name((key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set2) => set2(v2));
      else setters[0](v2);
    };
  }, "registerGlobalSetter");
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = /* @__PURE__ */ __name((instance) => {
  const prev2 = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev2);
  };
}, "setCurrentInstance");
const unsetCurrentInstance = /* @__PURE__ */ __name(() => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
}, "unsetCurrentInstance");
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
__name(validateComponentName, "validateComponentName");
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
__name(isStatefulComponent, "isStatefulComponent");
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
__name(setupComponent, "setupComponent");
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (false) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateComponentName(names[i2], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateDirectiveName(names[i2]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$1$1(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  if (false) {
    exposePropsOnRenderContext(instance);
  }
  const { setup: setup2 } = Component;
  if (setup2) {
    const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup2,
      instance,
      0,
      [
        false ? shallowReadonly(instance.props) : instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (false) {
          const name = (_a = Component.name) != null ? _a : "Anonymous";
          warn$1$1(
            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
          );
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
__name(setupStatefulComponent, "setupStatefulComponent");
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$3(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$6(setupResult)) {
    if (false) {
      warn$1$1(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    if (false) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    if (false) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (false) {
    warn$1$1(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
__name(handleSetupResult, "handleSetupResult");
let compile$2;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$2 = _compile;
  installWithProxy = /* @__PURE__ */ __name((i2) => {
    if (i2.render._rc) {
      i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  }, "installWithProxy");
}
__name(registerRuntimeCompiler, "registerRuntimeCompiler");
const isRuntimeOnly = /* @__PURE__ */ __name(() => !compile$2, "isRuntimeOnly");
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$2 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (false) {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$2(template, finalCompilerOptions);
        if (false) {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (true) {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
  if (false) {
    if (!compile$2 && Component.template) {
      warn$1$1(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      );
    } else {
      warn$1$1(`Component is missing template or render function: `, Component);
    }
  }
}
__name(finishComponentSetup, "finishComponentSetup");
const attrsProxyHandlers = false ? {
  get(target, key) {
    markAttrsAccessed();
    track(target, "get", "");
    return target[key];
  },
  set() {
    warn$1$1(`setupContext.attrs is readonly.`);
    return false;
  },
  deleteProperty() {
    warn$1$1(`setupContext.attrs is readonly.`);
    return false;
  }
} : {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function getSlotsProxy(instance) {
  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  }));
}
__name(getSlotsProxy, "getSlotsProxy");
function createSetupContext(instance) {
  const expose = /* @__PURE__ */ __name((exposed) => {
    if (false) {
      if (instance.exposed) {
        warn$1$1(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray$5(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn$1$1(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  }, "expose");
  if (false) {
    let attrsProxy;
    return Object.freeze({
      get attrs() {
        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
      },
      get slots() {
        return getSlotsProxy(instance);
      },
      get emit() {
        return (event2, ...args) => instance.emit(event2, ...args);
      },
      expose
    });
  } else {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
__name(createSetupContext, "createSetupContext");
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
__name(getComponentPublicInstance, "getComponentPublicInstance");
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = /* @__PURE__ */ __name((str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, ""), "classify");
function getComponentName(Component, includeInferred = true) {
  return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
__name(getComponentName, "getComponentName");
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = /* @__PURE__ */ __name((registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    }, "inferFromRegistry");
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
__name(formatComponentName, "formatComponentName");
function isClassComponent(value3) {
  return isFunction$3(value3) && "__vccOpts" in value3;
}
__name(isClassComponent, "isClassComponent");
const computed = /* @__PURE__ */ __name((getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (false) {
    const i2 = getCurrentInstance();
    if (i2 && i2.appContext.config.warnRecursiveComputed) {
      c._warnRecursive = true;
    }
  }
  return c;
}, "computed");
function useModel(props, name, options3 = EMPTY_OBJ) {
  const i2 = getCurrentInstance();
  if (false) {
    warn$1$1(`useModel() called without active instance.`);
    return ref();
  }
  if (false) {
    warn$1$1(`useModel() called with prop "${name}" which is not declared.`);
    return ref();
  }
  const camelizedName = camelize$1(name);
  const hyphenatedName = hyphenate$1(name);
  const res = customRef((track2, trigger2) => {
    let localValue;
    watchSyncEffect(() => {
      const propValue = props[name];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger2();
      }
    });
    return {
      get() {
        track2();
        return options3.get ? options3.get(localValue) : localValue;
      },
      set(value3) {
        const rawProps = i2.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && hasChanged(value3, localValue)) {
          localValue = value3;
          trigger2();
        }
        i2.emit(`update:${name}`, options3.set ? options3.set(value3) : value3);
      }
    };
  });
  const modifierKey = name === "modelValue" ? "modelModifiers" : `${name}Modifiers`;
  res[Symbol.iterator] = () => {
    let i22 = 0;
    return {
      next() {
        if (i22 < 2) {
          return { value: i22++ ? props[modifierKey] || {} : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
__name(useModel, "useModel");
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$6(propsOrChildren) && !isArray$5(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
__name(h, "h");
function initCustomFormatter() {
  if (true) {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#1677ff" };
  const stringStyle = { style: "color:#f5222d" };
  const keywordStyle = { style: "color:#eb2f96" };
  const formatter = {
    header(obj) {
      if (!isObject$6(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue2(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue2(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue2(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed2 = extractKeys(instance, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  __name(formatInstance, "formatInstance");
  function createInstanceBlock(type, target) {
    target = extend$1({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue2(target[key], false)
          ];
        })
      ]
    ];
  }
  __name(createInstanceBlock, "createInstanceBlock");
  function formatValue2(v2, asRaw = true) {
    if (typeof v2 === "number") {
      return ["span", numberStyle, v2];
    } else if (typeof v2 === "string") {
      return ["span", stringStyle, JSON.stringify(v2)];
    } else if (typeof v2 === "boolean") {
      return ["span", keywordStyle, v2];
    } else if (isObject$6(v2)) {
      return ["object", { object: asRaw ? toRaw(v2) : v2 }];
    } else {
      return ["span", stringStyle, String(v2)];
    }
  }
  __name(formatValue2, "formatValue");
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction$3(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  __name(extractKeys, "extractKeys");
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray$5(opts) && opts.includes(key) || isObject$6(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  __name(isKeyOfType, "isKeyOfType");
  function genRefFlag(v2) {
    if (isShallow(v2)) {
      return `ShallowRef`;
    }
    if (v2.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  __name(genRefFlag, "genRefFlag");
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
__name(initCustomFormatter, "initCustomFormatter");
function withMemo(memo, render2, cache2, index2) {
  const cached = cache2[index2];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  ret.memoIndex = index2;
  return cache2[index2] = ret;
}
__name(withMemo, "withMemo");
function isMemoSame(cached, memo) {
  const prev2 = cached.memo;
  if (prev2.length != memo.length) {
    return false;
  }
  for (let i2 = 0; i2 < prev2.length; i2++) {
    if (hasChanged(prev2[i2], memo[i2])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
__name(isMemoSame, "isMemoSame");
const version = "3.4.31";
const warn$2 = false ? warn$1$1 : NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1;
const devtools$2 = true ? devtools$1 : void 0;
const setDevtoolsHook = true ? setDevtoolsHook$1 : NOOP;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode$1,
  normalizeVNode,
  getComponentPublicInstance
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;
/**
* @vue/runtime-dom v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: /* @__PURE__ */ __name((child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  }, "insert"),
  remove: /* @__PURE__ */ __name((child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  }, "remove"),
  createElement: /* @__PURE__ */ __name((tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  }, "createElement"),
  createText: /* @__PURE__ */ __name((text) => doc.createTextNode(text), "createText"),
  createComment: /* @__PURE__ */ __name((text) => doc.createComment(text), "createComment"),
  setText: /* @__PURE__ */ __name((node3, text) => {
    node3.nodeValue = text;
  }, "setText"),
  setElementText: /* @__PURE__ */ __name((el, text) => {
    el.textContent = text;
  }, "setElementText"),
  parentNode: /* @__PURE__ */ __name((node3) => node3.parentNode, "parentNode"),
  nextSibling: /* @__PURE__ */ __name((node3) => node3.nextSibling, "nextSibling"),
  querySelector: /* @__PURE__ */ __name((selector) => doc.querySelector(selector), "querySelector"),
  setScopeId(el, id3) {
    el.setAttribute(id3, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content2, parent, anchor, namespace, start2, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end || !(start2 = start2.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = namespace === "svg" ? `<svg>${content2}</svg>` : namespace === "mathml" ? `<math>${content2}</math>` : content2;
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = /* @__PURE__ */ __name((props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots), "Transition");
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = /* @__PURE__ */ __name((hook, args = []) => {
  if (isArray$5(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
}, "callHook");
const hasExplicitCallback = /* @__PURE__ */ __name((hook) => {
  return hook ? isArray$5(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
}, "hasExplicitCallback");
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter: onBeforeEnter3,
    onEnter: onEnter7,
    onEnterCancelled,
    onLeave: onLeave5,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter3,
    onAppear = onEnter7,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = /* @__PURE__ */ __name((el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  }, "finishEnter");
  const finishLeave = /* @__PURE__ */ __name((el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  }, "finishLeave");
  const makeEnterHook = /* @__PURE__ */ __name((isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter7;
      const resolve2 = /* @__PURE__ */ __name(() => finishEnter(el, isAppear, done), "resolve");
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  }, "makeEnterHook");
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter3, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = /* @__PURE__ */ __name(() => finishLeave(el, done), "resolve");
      addTransitionClass(el, leaveFromClass);
      addTransitionClass(el, leaveActiveClass);
      forceReflow();
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave5)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave5, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
__name(resolveTransitionProps, "resolveTransitionProps");
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$6(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
__name(normalizeDuration, "normalizeDuration");
function NumberOf(val) {
  const res = toNumber(val);
  if (false) {
    assertNumber(res, "<transition> explicit duration");
  }
  return res;
}
__name(NumberOf, "NumberOf");
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
__name(addTransitionClass, "addTransitionClass");
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
__name(removeTransitionClass, "removeTransitionClass");
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
__name(nextFrame, "nextFrame");
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id3 = el._endId = ++endId;
  const resolveIfNotStale = /* @__PURE__ */ __name(() => {
    if (id3 === el._endId) {
      resolve2();
    }
  }, "resolveIfNotStale");
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = /* @__PURE__ */ __name(() => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  }, "end");
  const onEnd = /* @__PURE__ */ __name((e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  }, "onEnd");
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
__name(whenTransitionEnds, "whenTransitionEnds");
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = /* @__PURE__ */ __name((key) => (styles[key] || "").split(", "), "getStyleProperties");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
__name(getTransitionInfo, "getTransitionInfo");
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
}
__name(getTimeout, "getTimeout");
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
__name(toMs, "toMs");
function forceReflow() {
  return document.body.offsetHeight;
}
__name(forceReflow, "forceReflow");
function patchClass(el, value3, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value3 = (value3 ? [value3, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value3 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value3);
  } else {
    el.className = value3;
  }
}
__name(patchClass, "patchClass");
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value: value3 }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value3) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value3);
    }
  },
  mounted(el, { value: value3 }, { transition }) {
    if (transition && value3) {
      transition.enter(el);
    }
  },
  updated(el, { value: value3, oldValue }, { transition }) {
    if (!value3 === !oldValue) return;
    if (transition) {
      if (value3) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value3);
    }
  },
  beforeUnmount(el, { value: value3 }) {
    setDisplay(el, value3);
  }
};
if (false) {
  vShow.name = "show";
}
function setDisplay(el, value3) {
  el.style.display = value3 ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value3;
}
__name(setDisplay, "setDisplay");
function initVShowForSSR() {
  vShow.getSSRProps = ({ value: value3 }) => {
    if (!value3) {
      return { style: { display: "none" } };
    }
  };
}
__name(initVShowForSSR, "initVShowForSSR");
const CSS_VAR_TEXT = Symbol(false ? "CSS_VAR_TEXT" : "");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node3) => setVarsOnNode(node3, vars));
  };
  if (false) {
    instance.getCssVars = () => getter(instance.proxy);
  }
  const setVars = /* @__PURE__ */ __name(() => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  }, "setVars");
  onMounted(() => {
    watchPostEffect(setVars);
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
__name(useCssVars, "useCssVars");
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
__name(setVarsOnVNode, "setVarsOnVNode");
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
__name(setVarsOnNode, "setVarsOnNode");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev2, next2) {
  const style = el.style;
  const isCssString = isString$5(next2);
  let hasControlledDisplay = false;
  if (next2 && !isCssString) {
    if (prev2) {
      if (!isString$5(prev2)) {
        for (const key in prev2) {
          if (next2[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev2.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next2[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next2) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next2[key]);
    }
  } else {
    if (isCssString) {
      if (prev2 !== next2) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next2 += ";" + cssVarText;
        }
        style.cssText = next2;
        hasControlledDisplay = displayRE.test(next2);
      }
    } else if (prev2) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
__name(patchStyle, "patchStyle");
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$5(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null) val = "";
    if (false) {
      if (semicolonRE.test(val)) {
        warn$2(
          `Unexpected semicolon at the end of '${name}' style value: '${val}'`
        );
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate$1(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
__name(setStyle, "setStyle");
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize$1(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
__name(autoPrefix, "autoPrefix");
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value3, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value3 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value3);
    }
  } else {
    if (value3 == null || isBoolean2 && !includeBooleanAttr(value3)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol$1(value3) ? String(value3) : value3
      );
    }
  }
}
__name(patchAttr, "patchAttr");
function patchDOMProp(el, key, value3, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value3 == null ? "" : value3;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value3 == null ? "" : String(value3);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value3 == null) {
      el.removeAttribute(key);
    }
    el._value = value3;
    return;
  }
  let needRemove = false;
  if (value3 === "" || value3 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value3 = includeBooleanAttr(value3);
    } else if (value3 == null && type === "string") {
      value3 = "";
      needRemove = true;
    } else if (type === "number") {
      value3 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value3;
  } catch (e) {
    if (false) {
      warn$2(
        `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value3} is invalid.`,
        e
      );
    }
  }
  needRemove && el.removeAttribute(key);
}
__name(patchDOMProp, "patchDOMProp");
function addEventListener(el, event2, handler6, options3) {
  el.addEventListener(event2, handler6, options3);
}
__name(addEventListener, "addEventListener");
function removeEventListener(el, event2, handler6, options3) {
  el.removeEventListener(event2, handler6, options3);
}
__name(removeEventListener, "removeEventListener");
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = false ? sanitizeEventValue(nextValue, rawName) : nextValue;
  } else {
    const [name, options3] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        false ? sanitizeEventValue(nextValue, rawName) : nextValue,
        instance
      );
      addEventListener(el, name, invoker, options3);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options3);
      invokers[rawName] = void 0;
    }
  }
}
__name(patchEvent, "patchEvent");
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options3;
  if (optionsModifierRE.test(name)) {
    options3 = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options3[m[0].toLowerCase()] = true;
    }
  }
  const event2 = name[2] === ":" ? name.slice(3) : hyphenate$1(name.slice(2));
  return [event2, options3];
}
__name(parseName, "parseName");
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = /* @__PURE__ */ __name(() => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now()), "getNow");
function createInvoker(initialValue, instance) {
  const invoker = /* @__PURE__ */ __name((e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  }, "invoker");
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
__name(createInvoker, "createInvoker");
function sanitizeEventValue(value3, propName) {
  if (isFunction$3(value3) || isArray$5(value3)) {
    return value3;
  }
  warn$2(
    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value3}.`
  );
  return NOOP;
}
__name(sanitizeEventValue, "sanitizeEventValue");
function patchStopImmediatePropagation(e, value3) {
  if (isArray$5(value3)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value3.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value3;
  }
}
__name(patchStopImmediatePropagation, "patchStopImmediatePropagation");
const isNativeOn = /* @__PURE__ */ __name((key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123, "isNativeOn");
const patchProp = /* @__PURE__ */ __name((el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
}, "patchProp");
function shouldSetAsProp(el, key, value3, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$3(value3)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$5(value3)) {
    return false;
  }
  return key in el;
}
__name(shouldSetAsProp, "shouldSetAsProp");
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options3, extraOptions, hydrate2) {
  const Comp = /* @__PURE__ */ defineComponent(options3, extraOptions);
  class VueCustomElement extends VueElement {
    static {
      __name(this, "VueCustomElement");
    }
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
__name(defineCustomElement, "defineCustomElement");
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (options3, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options3, extraOptions, hydrate);
}, "defineSSRCustomElement");
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  static {
    __name(this, "VueElement");
  }
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._ob = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      if (false) {
        warn$2(
          `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
        );
      }
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        render$W(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i2 = 0; i2 < this.attributes.length; i2++) {
      this._setAttr(this.attributes[i2].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve2 = /* @__PURE__ */ __name((def2, isAsync2 = false) => {
      const { props, styles } = def2;
      let numberProps;
      if (props && !isArray$5(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize$1(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync2) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    }, "resolve");
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve2(def2, true));
    } else {
      resolve2(this._def);
    }
  }
  _resolveProps(def2) {
    const { props } = def2;
    const declaredPropKeys = isArray$5(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(camelize$1)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value3 = this.hasAttribute(key) ? this.getAttribute(key) : void 0;
    const camelKey = camelize$1(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value3 = toNumber(value3);
    }
    this._setProp(camelKey, value3, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate$1(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate$1(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate$1(key));
        }
      }
    }
  }
  _update() {
    render$W(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend$1({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        if (false) {
          instance.ceReload = (newStyles) => {
            if (this._styles) {
              this._styles.forEach((s) => this.shadowRoot.removeChild(s));
              this._styles.length = 0;
            }
            this._applyStyles(newStyles);
            this._instance = null;
            this._update();
          };
        }
        const dispatch = /* @__PURE__ */ __name((event2, args) => {
          this.dispatchEvent(
            new CustomEvent(event2, {
              detail: args
            })
          );
        }, "dispatch");
        instance.emit = (event2, ...args) => {
          dispatch(event2, args);
          if (hyphenate$1(event2) !== event2) {
            dispatch(hyphenate$1(event2), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css3) => {
        const s = document.createElement("style");
        s.textContent = css3;
        this.shadowRoot.appendChild(s);
        if (false) {
          (this._styles || (this._styles = [])).push(s);
        }
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
__name(useCssModule, "useCssModule");
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        } else if (false) {
          warn$2(`<TransitionGroup> children must be keyed.`);
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = /* @__PURE__ */ __name((props) => delete props.mode, "removeMode");
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
__name(callPendingCbs, "callPendingCbs");
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
__name(recordPosition, "recordPosition");
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
__name(applyTranslation, "applyTranslation");
function hasCSSTransform(el, root23, moveClass) {
  const clone2 = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
  clone2.style.display = "none";
  const container = root23.nodeType === 1 ? root23 : root23.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
__name(hasCSSTransform, "hasCSSTransform");
const getModelAssigner = /* @__PURE__ */ __name((vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$5(fn) ? (value3) => invokeArrayFns(fn, value3) : fn;
}, "getModelAssigner");
function onCompositionStart(e) {
  e.target.composing = true;
}
__name(onCompositionStart, "onCompositionStart");
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
__name(onCompositionEnd, "onCompositionEnd");
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim2) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim2) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value: value3 }) {
    el.value = value3 == null ? "" : value3;
  },
  beforeUpdate(el, { value: value3, oldValue, modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number2 || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value3 == null ? "" : value3;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value3 === oldValue) {
        return;
      }
      if (trim2 && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _2, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue3 = el._modelValue;
      const elementValue = getValue$1(el);
      const checked4 = el.checked;
      const assign2 = el[assignKey];
      if (isArray$5(modelValue3)) {
        const index2 = looseIndexOf(modelValue3, elementValue);
        const found = index2 !== -1;
        if (checked4 && !found) {
          assign2(modelValue3.concat(elementValue));
        } else if (!checked4 && found) {
          const filtered = [...modelValue3];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue3)) {
        const cloned = new Set(modelValue3);
        if (checked4) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked4));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value: value3, oldValue }, vnode) {
  el._modelValue = value3;
  if (isArray$5(value3)) {
    el.checked = looseIndexOf(value3, vnode.props.value) > -1;
  } else if (isSet(value3)) {
    el.checked = value3.has(vnode.props.value);
  } else if (value3 !== oldValue) {
    el.checked = looseEqual(value3, getCheckboxValue(el, true));
  }
}
__name(setChecked, "setChecked");
const vModelRadio = {
  created(el, { value: value3 }, vnode) {
    el.checked = looseEqual(value3, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue$1(el));
    });
  },
  beforeUpdate(el, { value: value3, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value3 !== oldValue) {
      el.checked = looseEqual(value3, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value: value3, modifiers: { number: number2 } }, vnode) {
    const isSetModel = isSet(value3);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number2 ? looseToNumber(getValue$1(o)) : getValue$1(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value: value3, modifiers: { number: number2 } }) {
    setSelected(el, value3);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value: value3, modifiers: { number: number2 } }) {
    if (!el._assigning) {
      setSelected(el, value3);
    }
  }
};
function setSelected(el, value3, number2) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray$5(value3);
  if (isMultiple && !isArrayValue && !isSet(value3)) {
    return;
  }
  for (let i2 = 0, l = el.options.length; i2 < l; i2++) {
    const option3 = el.options[i2];
    const optionValue = getValue$1(option3);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option3.selected = value3.some((v2) => String(v2) === String(optionValue));
        } else {
          option3.selected = looseIndexOf(value3, optionValue) > -1;
        }
      } else {
        option3.selected = value3.has(optionValue);
      }
    } else if (looseEqual(getValue$1(option3), value3)) {
      if (el.selectedIndex !== i2) el.selectedIndex = i2;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
__name(setSelected, "setSelected");
function getValue$1(el) {
  return "_value" in el ? el._value : el.value;
}
__name(getValue$1, "getValue$1");
function getCheckboxValue(el, checked4) {
  const key = checked4 ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked4;
}
__name(getCheckboxValue, "getCheckboxValue");
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
__name(resolveDynamicModel, "resolveDynamicModel");
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
__name(callModelHook, "callModelHook");
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value: value3 }) => ({ value: value3 });
  vModelRadio.getSSRProps = ({ value: value3 }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value3)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value: value3 }, vnode) => {
    if (isArray$5(value3)) {
      if (vnode.props && looseIndexOf(value3, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value3)) {
      if (vnode.props && value3.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value3) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
__name(initVModelForSSR, "initVModelForSSR");
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: /* @__PURE__ */ __name((e) => e.stopPropagation(), "stop"),
  prevent: /* @__PURE__ */ __name((e) => e.preventDefault(), "prevent"),
  self: /* @__PURE__ */ __name((e) => e.target !== e.currentTarget, "self"),
  ctrl: /* @__PURE__ */ __name((e) => !e.ctrlKey, "ctrl"),
  shift: /* @__PURE__ */ __name((e) => !e.shiftKey, "shift"),
  alt: /* @__PURE__ */ __name((e) => !e.altKey, "alt"),
  meta: /* @__PURE__ */ __name((e) => !e.metaKey, "meta"),
  left: /* @__PURE__ */ __name((e) => "button" in e && e.button !== 0, "left"),
  middle: /* @__PURE__ */ __name((e) => "button" in e && e.button !== 1, "middle"),
  right: /* @__PURE__ */ __name((e) => "button" in e && e.button !== 2, "right"),
  exact: /* @__PURE__ */ __name((e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m)), "exact")
};
const withModifiers = /* @__PURE__ */ __name((fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event2, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event2, modifiers)) return;
    }
    return fn(event2, ...args);
  });
}, "withModifiers");
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = /* @__PURE__ */ __name((fn, modifiers) => {
  const cache2 = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event2) => {
    if (!("key" in event2)) {
      return;
    }
    const eventKey = hyphenate$1(event2.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event2);
    }
  });
}, "withKeys");
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
__name(ensureRenderer, "ensureRenderer");
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
__name(ensureHydrationRenderer, "ensureHydrationRenderer");
const render$W = /* @__PURE__ */ __name((...args) => {
  ensureRenderer().render(...args);
}, "render$W");
const hydrate = /* @__PURE__ */ __name((...args) => {
  ensureHydrationRenderer().hydrate(...args);
}, "hydrate");
const createApp = /* @__PURE__ */ __name((...args) => {
  const app2 = ensureRenderer().createApp(...args);
  if (false) {
    injectNativeTagCheck(app2);
    injectCompilerOptionsCheck(app2);
  }
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app2._component;
    if (!isFunction$3(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
}, "createApp");
const createSSRApp = /* @__PURE__ */ __name((...args) => {
  const app2 = ensureHydrationRenderer().createApp(...args);
  if (false) {
    injectNativeTagCheck(app2);
    injectCompilerOptionsCheck(app2);
  }
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount2(container, true, resolveRootNamespace(container));
    }
  };
  return app2;
}, "createSSRApp");
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
__name(resolveRootNamespace, "resolveRootNamespace");
function injectNativeTagCheck(app2) {
  Object.defineProperty(app2.config, "isNativeTag", {
    value: /* @__PURE__ */ __name((tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag), "value"),
    writable: false
  });
}
__name(injectNativeTagCheck, "injectNativeTagCheck");
function injectCompilerOptionsCheck(app2) {
  if (isRuntimeOnly()) {
    const isCustomElement = app2.config.isCustomElement;
    Object.defineProperty(app2.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn$2(
          `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
        );
      }
    });
    const compilerOptions = app2.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app2.config, "compilerOptions", {
      get() {
        warn$2(msg);
        return compilerOptions;
      },
      set() {
        warn$2(msg);
      }
    });
  }
}
__name(injectCompilerOptionsCheck, "injectCompilerOptionsCheck");
function normalizeContainer(container) {
  if (isString$5(container)) {
    const res = document.querySelector(container);
    if (false) {
      warn$2(
        `Failed to mount app: mount target selector "${container}" returned null.`
      );
    }
    return res;
  }
  if (false) {
    warn$2(
      `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
    );
  }
  return container;
}
__name(normalizeContainer, "normalizeContainer");
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = /* @__PURE__ */ __name(() => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
}, "initDirectivesForSSR");
/**
* vue v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function initDev() {
  {
    initCustomFormatter();
  }
}
__name(initDev, "initDev");
if (false) {
  initDev();
}
const compile$1 = /* @__PURE__ */ __name(() => {
  if (false) {
    warn$2(
      `Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
    );
  }
}, "compile$1");
const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  DeprecationTypes,
  EffectScope,
  ErrorCodes,
  ErrorTypeStrings,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text: Text$1,
  TrackOpTypes,
  Transition,
  TransitionGroup,
  TriggerOpTypes,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize: camelize$1,
  capitalize: capitalize$1,
  cloneVNode,
  compatUtils,
  compile: compile$1,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  devtools: devtools$2,
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode: isVNode$1,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render: render$W,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString: toDisplayString$1,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef: toRef$1,
  toRefs: toRefs$1,
  toValue: toValue$2,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useModel,
  useSSRContext,
  useSlots,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn: warn$2,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
const config = {
  app_title: "ComfyUI",
  app_version: "1.3.44"
};
var isVue2$2 = false;
var isVue3$2 = true;
var Vue2$2 = void 0;
function install$2() {
}
__name(install$2, "install$2");
function set$3(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
__name(set$3, "set$3");
function del$2(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
__name(del$2, "del$2");
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
__name(getDevtoolsGlobalHook, "getDevtoolsGlobalHook");
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
__name(getTarget, "getTarget");
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof globalThis !== "undefined" && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = globalThis.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
__name(isPerformanceSupported, "isPerformanceSupported");
function now$1() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
__name(now$1, "now$1");
class ApiProxy {
  static {
    __name(this, "ApiProxy");
  }
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id3 in plugin.settings) {
        const item2 = plugin.settings[id3];
        defaultSettings[id3] = item2.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data22 = JSON.parse(raw);
      Object.assign(currentSettings, data22);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value3) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value3));
        } catch (e) {
        }
        currentSettings = value3;
      },
      now() {
        return now$1();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value3) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value3);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: /* @__PURE__ */ __name((_target, prop2) => {
        if (this.target) {
          return this.target.on[prop2];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop2,
              args
            });
          };
        }
      }, "get")
    });
    this.proxiedTarget = new Proxy({}, {
      get: /* @__PURE__ */ __name((_target, prop2) => {
        if (this.target) {
          return this.target[prop2];
        } else if (prop2 === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop2)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop2,
              args,
              resolve: /* @__PURE__ */ __name(() => {
              }, "resolve")
            });
            return this.fallbacks[prop2](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve2) => {
              this.targetQueue.push({
                method: prop2,
                args,
                resolve: resolve2
              });
            });
          };
        }
      }, "get")
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item2 of this.onQueue) {
      this.target.on[item2.method](...item2.args);
    }
    for (const item2 of this.targetQueue) {
      item2.resolve(await this.target[item2.method](...item2.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) {
      setupFn(proxy.proxiedTarget);
    }
  }
}
__name(setupDevtoolsPlugin, "setupDevtoolsPlugin");
/*!
 * pinia v2.2.2
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = /* @__PURE__ */ __name((pinia2) => activePinia = pinia2, "setActivePinia");
const getActivePinia = /* @__PURE__ */ __name(() => hasInjectionContext() && inject(piniaSymbol) || activePinia, "getActivePinia");
const piniaSymbol = false ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$2(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
__name(isPlainObject$2, "isPlainObject$2");
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
const IS_CLIENT = typeof window !== "undefined";
const _global$2 = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
function bom(blob, { autoBom = false } = {}) {
  if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
    return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
  }
  return blob;
}
__name(bom, "bom");
function download(url, name, opts) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.responseType = "blob";
  xhr.onload = function() {
    saveAs$1(xhr.response, name, opts);
  };
  xhr.onerror = function() {
    console.error("could not download file");
  };
  xhr.send();
}
__name(download, "download");
function corsEnabled(url) {
  const xhr = new XMLHttpRequest();
  xhr.open("HEAD", url, false);
  try {
    xhr.send();
  } catch (e) {
  }
  return xhr.status >= 200 && xhr.status <= 299;
}
__name(corsEnabled, "corsEnabled");
function click(node3) {
  try {
    node3.dispatchEvent(new MouseEvent("click"));
  } catch (e) {
    const evt = document.createEvent("MouseEvents");
    evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
    node3.dispatchEvent(evt);
  }
}
__name(click, "click");
const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
const saveAs$1 = !IS_CLIENT ? () => {
} : (
  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
  typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
    // Use msSaveOrOpenBlob as a second approach
    "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
      // Fallback to using FileReader and a popup
      fileSaverSaveAs
    )
  )
);
function downloadSaveAs(blob, name = "download", opts) {
  const a = document.createElement("a");
  a.download = name;
  a.rel = "noopener";
  if (typeof blob === "string") {
    a.href = blob;
    if (a.origin !== location.origin) {
      if (corsEnabled(a.href)) {
        download(blob, name, opts);
      } else {
        a.target = "_blank";
        click(a);
      }
    } else {
      click(a);
    }
  } else {
    a.href = URL.createObjectURL(blob);
    setTimeout(function() {
      URL.revokeObjectURL(a.href);
    }, 4e4);
    setTimeout(function() {
      click(a);
    }, 0);
  }
}
__name(downloadSaveAs, "downloadSaveAs");
function msSaveAs(blob, name = "download", opts) {
  if (typeof blob === "string") {
    if (corsEnabled(blob)) {
      download(blob, name, opts);
    } else {
      const a = document.createElement("a");
      a.href = blob;
      a.target = "_blank";
      setTimeout(function() {
        click(a);
      });
    }
  } else {
    navigator.msSaveOrOpenBlob(bom(blob, opts), name);
  }
}
__name(msSaveAs, "msSaveAs");
function fileSaverSaveAs(blob, name, opts, popup) {
  popup = popup || open("", "_blank");
  if (popup) {
    popup.document.title = popup.document.body.innerText = "downloading...";
  }
  if (typeof blob === "string")
    return download(blob, name, opts);
  const force = blob.type === "application/octet-stream";
  const isSafari3 = /constructor/i.test(String(_global$2.HTMLElement)) || "safari" in _global$2;
  const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((isChromeIOS || force && isSafari3 || isMacOSWebView) && typeof FileReader !== "undefined") {
    const reader = new FileReader();
    reader.onloadend = function() {
      let url = reader.result;
      if (typeof url !== "string") {
        popup = null;
        throw new Error("Wrong reader.result type");
      }
      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
      if (popup) {
        popup.location.href = url;
      } else {
        location.assign(url);
      }
      popup = null;
    };
    reader.readAsDataURL(blob);
  } else {
    const url = URL.createObjectURL(blob);
    if (popup)
      popup.location.assign(url);
    else
      location.href = url;
    popup = null;
    setTimeout(function() {
      URL.revokeObjectURL(url);
    }, 4e4);
  }
}
__name(fileSaverSaveAs, "fileSaverSaveAs");
function toastMessage(message2, type) {
  const piniaMessage = " " + message2;
  if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
  } else if (type === "error") {
    console.error(piniaMessage);
  } else if (type === "warn") {
    console.warn(piniaMessage);
  } else {
    console.log(piniaMessage);
  }
}
__name(toastMessage, "toastMessage");
function isPinia(o) {
  return "_a" in o && "install" in o;
}
__name(isPinia, "isPinia");
function checkClipboardAccess() {
  if (!("clipboard" in navigator)) {
    toastMessage(`Your browser doesn't support the Clipboard API`, "error");
    return true;
  }
}
__name(checkClipboardAccess, "checkClipboardAccess");
function checkNotFocusedError(error) {
  if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
    toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
    return true;
  }
  return false;
}
__name(checkNotFocusedError, "checkNotFocusedError");
async function actionGlobalCopyState(pinia2) {
  if (checkClipboardAccess())
    return;
  try {
    await navigator.clipboard.writeText(JSON.stringify(pinia2.state.value));
    toastMessage("Global state copied to clipboard.");
  } catch (error) {
    if (checkNotFocusedError(error))
      return;
    toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
    console.error(error);
  }
}
__name(actionGlobalCopyState, "actionGlobalCopyState");
async function actionGlobalPasteState(pinia2) {
  if (checkClipboardAccess())
    return;
  try {
    loadStoresState(pinia2, JSON.parse(await navigator.clipboard.readText()));
    toastMessage("Global state pasted from clipboard.");
  } catch (error) {
    if (checkNotFocusedError(error))
      return;
    toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
    console.error(error);
  }
}
__name(actionGlobalPasteState, "actionGlobalPasteState");
async function actionGlobalSaveState(pinia2) {
  try {
    saveAs$1(new Blob([JSON.stringify(pinia2.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (error) {
    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
    console.error(error);
  }
}
__name(actionGlobalSaveState, "actionGlobalSaveState");
let fileInput$1;
function getFileOpener() {
  if (!fileInput$1) {
    fileInput$1 = document.createElement("input");
    fileInput$1.type = "file";
    fileInput$1.accept = ".json";
  }
  function openFile() {
    return new Promise((resolve2, reject2) => {
      fileInput$1.onchange = async () => {
        const files = fileInput$1.files;
        if (!files)
          return resolve2(null);
        const file = files.item(0);
        if (!file)
          return resolve2(null);
        return resolve2({ text: await file.text(), file });
      };
      fileInput$1.oncancel = () => resolve2(null);
      fileInput$1.onerror = reject2;
      fileInput$1.click();
    });
  }
  __name(openFile, "openFile");
  return openFile;
}
__name(getFileOpener, "getFileOpener");
async function actionGlobalOpenStateFile(pinia2) {
  try {
    const open2 = getFileOpener();
    const result = await open2();
    if (!result)
      return;
    const { text, file } = result;
    loadStoresState(pinia2, JSON.parse(text));
    toastMessage(`Global state imported from "${file.name}".`);
  } catch (error) {
    toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
    console.error(error);
  }
}
__name(actionGlobalOpenStateFile, "actionGlobalOpenStateFile");
function loadStoresState(pinia2, state) {
  for (const key in state) {
    const storeState = pinia2.state.value[key];
    if (storeState) {
      Object.assign(storeState, state[key]);
    } else {
      pinia2.state.value[key] = state[key];
    }
  }
}
__name(loadStoresState, "loadStoresState");
function formatDisplay$1(display) {
  return {
    _custom: {
      display
    }
  };
}
__name(formatDisplay$1, "formatDisplay$1");
const PINIA_ROOT_LABEL = " Pinia (root)";
const PINIA_ROOT_ID = "_root";
function formatStoreForInspectorTree(store) {
  return isPinia(store) ? {
    id: PINIA_ROOT_ID,
    label: PINIA_ROOT_LABEL
  } : {
    id: store.$id,
    label: store.$id
  };
}
__name(formatStoreForInspectorTree, "formatStoreForInspectorTree");
function formatStoreForInspectorState(store) {
  if (isPinia(store)) {
    const storeNames = Array.from(store._s.keys());
    const storeMap = store._s;
    const state2 = {
      state: storeNames.map((storeId) => ({
        editable: true,
        key: storeId,
        value: store.state.value[storeId]
      })),
      getters: storeNames.filter((id3) => storeMap.get(id3)._getters).map((id3) => {
        const store2 = storeMap.get(id3);
        return {
          editable: false,
          key: id3,
          value: store2._getters.reduce((getters, key) => {
            getters[key] = store2[key];
            return getters;
          }, {})
        };
      })
    };
    return state2;
  }
  const state = {
    state: Object.keys(store.$state).map((key) => ({
      editable: true,
      key,
      value: store.$state[key]
    }))
  };
  if (store._getters && store._getters.length) {
    state.getters = store._getters.map((getterName) => ({
      editable: false,
      key: getterName,
      value: store[getterName]
    }));
  }
  if (store._customProperties.size) {
    state.customProperties = Array.from(store._customProperties).map((key) => ({
      editable: true,
      key,
      value: store[key]
    }));
  }
  return state;
}
__name(formatStoreForInspectorState, "formatStoreForInspectorState");
function formatEventData(events2) {
  if (!events2)
    return {};
  if (Array.isArray(events2)) {
    return events2.reduce((data22, event2) => {
      data22.keys.push(event2.key);
      data22.operations.push(event2.type);
      data22.oldValue[event2.key] = event2.oldValue;
      data22.newValue[event2.key] = event2.newValue;
      return data22;
    }, {
      oldValue: {},
      keys: [],
      operations: [],
      newValue: {}
    });
  } else {
    return {
      operation: formatDisplay$1(events2.type),
      key: formatDisplay$1(events2.key),
      oldValue: events2.oldValue,
      newValue: events2.newValue
    };
  }
}
__name(formatEventData, "formatEventData");
function formatMutationType(type) {
  switch (type) {
    case MutationType.direct:
      return "mutation";
    case MutationType.patchFunction:
      return "$patch";
    case MutationType.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
__name(formatMutationType, "formatMutationType");
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = "pinia:mutations";
const INSPECTOR_ID = "pinia";
const { assign: assign$1$1 } = Object;
const getStoreType = /* @__PURE__ */ __name((id3) => " " + id3, "getStoreType");
function registerPiniaDevtools(app2, pinia2) {
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia ",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app: app2
  }, (api2) => {
    if (typeof api2.now !== "function") {
      toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
    }
    api2.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: `Pinia `,
      color: 15064968
    });
    api2.addInspector({
      id: INSPECTOR_ID,
      label: "Pinia ",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: /* @__PURE__ */ __name(() => {
            actionGlobalCopyState(pinia2);
          }, "action"),
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: /* @__PURE__ */ __name(async () => {
            await actionGlobalPasteState(pinia2);
            api2.sendInspectorTree(INSPECTOR_ID);
            api2.sendInspectorState(INSPECTOR_ID);
          }, "action"),
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: /* @__PURE__ */ __name(() => {
            actionGlobalSaveState(pinia2);
          }, "action"),
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: /* @__PURE__ */ __name(async () => {
            await actionGlobalOpenStateFile(pinia2);
            api2.sendInspectorTree(INSPECTOR_ID);
            api2.sendInspectorState(INSPECTOR_ID);
          }, "action"),
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: 'Reset the state (with "$reset")',
          action: /* @__PURE__ */ __name((nodeId) => {
            const store = pinia2._s.get(nodeId);
            if (!store) {
              toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
            } else if (typeof store.$reset !== "function") {
              toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
            } else {
              store.$reset();
              toastMessage(`Store "${nodeId}" reset.`);
            }
          }, "action")
        }
      ]
    });
    api2.on.inspectComponent((payload, ctx) => {
      const proxy = payload.componentInstance && payload.componentInstance.proxy;
      if (proxy && proxy._pStores) {
        const piniaStores = payload.componentInstance.proxy._pStores;
        Object.values(piniaStores).forEach((store) => {
          payload.instanceData.state.push({
            type: getStoreType(store.$id),
            key: "state",
            editable: true,
            value: store._isOptionsAPI ? {
              _custom: {
                value: toRaw(store.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: /* @__PURE__ */ __name(() => store.$reset(), "action")
                  }
                ]
              }
            } : (
              // NOTE: workaround to unwrap transferred refs
              Object.keys(store.$state).reduce((state, key) => {
                state[key] = store.$state[key];
                return state;
              }, {})
            )
          });
          if (store._getters && store._getters.length) {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "getters",
              editable: false,
              value: store._getters.reduce((getters, key) => {
                try {
                  getters[key] = store[key];
                } catch (error) {
                  getters[key] = error;
                }
                return getters;
              }, {})
            });
          }
        });
      }
    });
    api2.on.getInspectorTree((payload) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        let stores = [pinia2];
        stores = stores.concat(Array.from(pinia2._s.values()));
        payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
      }
    });
    globalThis.$pinia = pinia2;
    api2.on.getInspectorState((payload) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
        if (!inspectedStore) {
          return;
        }
        if (inspectedStore) {
          if (payload.nodeId !== PINIA_ROOT_ID)
            globalThis.$store = toRaw(inspectedStore);
          payload.state = formatStoreForInspectorState(inspectedStore);
        }
      }
    });
    api2.on.editInspectorState((payload, ctx) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
        if (!inspectedStore) {
          return toastMessage(`store "${payload.nodeId}" not found`, "error");
        }
        const { path } = payload;
        if (!isPinia(inspectedStore)) {
          if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
            path.unshift("$state");
          }
        } else {
          path.unshift("state");
        }
        isTimelineActive = false;
        payload.set(inspectedStore, path, payload.state.value);
        isTimelineActive = true;
      }
    });
    api2.on.editComponentState((payload) => {
      if (payload.type.startsWith("")) {
        const storeId = payload.type.replace(/^\s*/, "");
        const store = pinia2._s.get(storeId);
        if (!store) {
          return toastMessage(`store "${storeId}" not found`, "error");
        }
        const { path } = payload;
        if (path[0] !== "state") {
          return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
        }
        path[0] = "$state";
        isTimelineActive = false;
        payload.set(store, path, payload.state.value);
        isTimelineActive = true;
      }
    });
  });
}
__name(registerPiniaDevtools, "registerPiniaDevtools");
function addStoreToDevtools(app2, store) {
  if (!componentStateTypes.includes(getStoreType(store.$id))) {
    componentStateTypes.push(getStoreType(store.$id));
  }
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia ",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app: app2,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: true
      }
      // useEmojis: {
      //   label: 'Use emojis in messages ',
      //   type: 'boolean',
      //   defaultValue: true,
      // },
    }
  }, (api2) => {
    const now2 = typeof api2.now === "function" ? api2.now.bind(api2) : Date.now;
    store.$onAction(({ after, onError, name, args }) => {
      const groupId = runningActionId++;
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: " " + name,
          subtitle: "start",
          data: {
            store: formatDisplay$1(store.$id),
            action: formatDisplay$1(name),
            args
          },
          groupId
        }
      });
      after((result) => {
        activeAction = void 0;
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: " " + name,
            subtitle: "end",
            data: {
              store: formatDisplay$1(store.$id),
              action: formatDisplay$1(name),
              args,
              result
            },
            groupId
          }
        });
      });
      onError((error) => {
        activeAction = void 0;
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            logType: "error",
            title: " " + name,
            subtitle: "end",
            data: {
              store: formatDisplay$1(store.$id),
              action: formatDisplay$1(name),
              args,
              error
            },
            groupId
          }
        });
      });
    }, true);
    store._customProperties.forEach((name) => {
      watch(() => unref(store[name]), (newValue, oldValue) => {
        api2.notifyComponentUpdate();
        api2.sendInspectorState(INSPECTOR_ID);
        if (isTimelineActive) {
          api2.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "Change",
              subtitle: name,
              data: {
                newValue,
                oldValue
              },
              groupId: activeAction
            }
          });
        }
      }, { deep: true });
    });
    store.$subscribe(({ events: events2, type }, state) => {
      api2.notifyComponentUpdate();
      api2.sendInspectorState(INSPECTOR_ID);
      if (!isTimelineActive)
        return;
      const eventData = {
        time: now2(),
        title: formatMutationType(type),
        data: assign$1$1({ store: formatDisplay$1(store.$id) }, formatEventData(events2)),
        groupId: activeAction
      };
      if (type === MutationType.patchFunction) {
        eventData.subtitle = "";
      } else if (type === MutationType.patchObject) {
        eventData.subtitle = "";
      } else if (events2 && !Array.isArray(events2)) {
        eventData.subtitle = events2.type;
      }
      if (events2) {
        eventData.data["rawEvent(s)"] = {
          _custom: {
            display: "DebuggerEvent",
            type: "object",
            tooltip: "raw DebuggerEvent[]",
            value: events2
          }
        };
      }
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: eventData
      });
    }, { detached: true, flush: "sync" });
    const hotUpdate = store._hotUpdate;
    store._hotUpdate = markRaw((newStore) => {
      hotUpdate(newStore);
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: " " + store.$id,
          subtitle: "HMR update",
          data: {
            store: formatDisplay$1(store.$id),
            info: formatDisplay$1(`HMR update`)
          }
        }
      });
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(INSPECTOR_ID);
      api2.sendInspectorState(INSPECTOR_ID);
    });
    const { $dispose } = store;
    store.$dispose = () => {
      $dispose();
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(INSPECTOR_ID);
      api2.sendInspectorState(INSPECTOR_ID);
      api2.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store `);
    };
    api2.notifyComponentUpdate();
    api2.sendInspectorTree(INSPECTOR_ID);
    api2.sendInspectorState(INSPECTOR_ID);
    api2.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed `);
  });
}
__name(addStoreToDevtools, "addStoreToDevtools");
let runningActionId = 0;
let activeAction;
function patchActionForGrouping(store, actionNames, wrapWithProxy) {
  const actions = actionNames.reduce((storeActions, actionName) => {
    storeActions[actionName] = toRaw(store)[actionName];
    return storeActions;
  }, {});
  for (const actionName in actions) {
    store[actionName] = function() {
      const _actionId = runningActionId;
      const trackedStore = wrapWithProxy ? new Proxy(store, {
        get(...args) {
          activeAction = _actionId;
          return Reflect.get(...args);
        },
        set(...args) {
          activeAction = _actionId;
          return Reflect.set(...args);
        }
      }) : store;
      activeAction = _actionId;
      const retValue = actions[actionName].apply(trackedStore, arguments);
      activeAction = void 0;
      return retValue;
    };
  }
}
__name(patchActionForGrouping, "patchActionForGrouping");
function devtoolsPlugin({ app: app2, store, options: options3 }) {
  if (store.$id.startsWith("__hot:")) {
    return;
  }
  store._isOptionsAPI = !!options3.state;
  if (!store._p._testing) {
    patchActionForGrouping(store, Object.keys(options3.actions), store._isOptionsAPI);
    const originalHotUpdate = store._hotUpdate;
    toRaw(store)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
    };
  }
  addStoreToDevtools(
    app2,
    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
    store
  );
}
__name(devtoolsPlugin, "devtoolsPlugin");
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app2) {
      setActivePinia(pinia2);
      if (!isVue2$2) {
        pinia2._a = app2;
        app2.provide(piniaSymbol, pinia2);
        app2.config.globalProperties.$pinia = pinia2;
        if (false) {
          registerPiniaDevtools(app2, pinia2);
        }
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2$2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  if (false) {
    pinia2.use(devtoolsPlugin);
  }
  return pinia2;
}
__name(createPinia, "createPinia");
function disposePinia(pinia2) {
  pinia2._e.stop();
  pinia2._s.clear();
  pinia2._p.splice(0);
  pinia2.state.value = {};
  pinia2._a = null;
}
__name(disposePinia, "disposePinia");
const isUseStore = /* @__PURE__ */ __name((fn) => {
  return typeof fn === "function" && typeof fn.$id === "string";
}, "isUseStore");
function patchObject(newState, oldState) {
  for (const key in oldState) {
    const subPatch = oldState[key];
    if (!(key in newState)) {
      continue;
    }
    const targetValue = newState[key];
    if (isPlainObject$2(targetValue) && isPlainObject$2(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      newState[key] = patchObject(targetValue, subPatch);
    } else {
      if (isVue2$2) {
        set$3(newState, key, subPatch);
      } else {
        newState[key] = subPatch;
      }
    }
  }
  return newState;
}
__name(patchObject, "patchObject");
function acceptHMRUpdate(initialUseStore, hot) {
  if (true) {
    return () => {
    };
  }
  return (newModule) => {
    const pinia2 = hot.data.pinia || initialUseStore._pinia;
    if (!pinia2) {
      return;
    }
    hot.data.pinia = pinia2;
    for (const exportName in newModule) {
      const useStore = newModule[exportName];
      if (isUseStore(useStore) && pinia2._s.has(useStore.$id)) {
        const id3 = useStore.$id;
        if (id3 !== initialUseStore.$id) {
          console.warn(`The id of the store changed from "${initialUseStore.$id}" to "${id3}". Reloading.`);
          return hot.invalidate();
        }
        const existingStore = pinia2._s.get(id3);
        if (!existingStore) {
          console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);
          return;
        }
        useStore(pinia2, existingStore);
      }
    }
  };
}
__name(acceptHMRUpdate, "acceptHMRUpdate");
const noop$3 = /* @__PURE__ */ __name(() => {
}, "noop$3");
function addSubscription(subscriptions, callback, detached, onCleanup = noop$3) {
  subscriptions.push(callback);
  const removeSubscription = /* @__PURE__ */ __name(() => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  }, "removeSubscription");
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
__name(addSubscription, "addSubscription");
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
__name(triggerSubscriptions, "triggerSubscriptions");
const fallbackRunWithContext = /* @__PURE__ */ __name((fn) => fn(), "fallbackRunWithContext");
const ACTION_MARKER = Symbol();
const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value3, key) => target.set(key, value3));
  } else if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$2(targetValue) && isPlainObject$2(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
__name(mergeReactiveObjects, "mergeReactiveObjects");
const skipHydrateSymbol = false ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
const skipHydrateMap = /* @__PURE__ */ new WeakMap();
function skipHydrate(obj) {
  return isVue2$2 ? (
    // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...
    /* istanbul ignore next */
    skipHydrateMap.set(obj, 1) && obj
  ) : Object.defineProperty(obj, skipHydrateSymbol, {});
}
__name(skipHydrate, "skipHydrate");
function shouldHydrate(obj) {
  return isVue2$2 ? (
    /* istanbul ignore next */
    !skipHydrateMap.has(obj)
  ) : !isPlainObject$2(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
__name(shouldHydrate, "shouldHydrate");
const { assign: assign$3 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
__name(isComputed, "isComputed");
function createOptionsStore(id3, options3, pinia2, hot) {
  const { state, actions, getters } = options3;
  const initialState = pinia2.state.value[id3];
  let store;
  function setup2() {
    if (!initialState && true) {
      if (isVue2$2) {
        set$3(pinia2.state.value, id3, state ? state() : {});
      } else {
        pinia2.state.value[id3] = state ? state() : {};
      }
    }
    const localState = false ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      toRefs$1(ref(state ? state() : {}).value)
    ) : toRefs$1(pinia2.state.value[id3]);
    return assign$3(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      if (false) {
        console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id3}".`);
      }
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store2 = pinia2._s.get(id3);
        if (isVue2$2 && !store2._r)
          return;
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  __name(setup2, "setup");
  store = createSetupStore(id3, setup2, options3, pinia2, hot, true);
  return store;
}
__name(createOptionsStore, "createOptionsStore");
function createSetupStore($id, setup2, options3 = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$3({ actions: {} }, options3);
  if (false) {
    throw new Error("Pinia destroyed");
  }
  const $subscribeOptions = { deep: true };
  if (false) {
    $subscribeOptions.onTrigger = (event2) => {
      if (isListening) {
        debuggerEvents = event2;
      } else if (isListening == false && !store._hotUpdating) {
        if (Array.isArray(debuggerEvents)) {
          debuggerEvents.push(event2);
        } else {
          console.error(" debuggerEvents should be an array. This is most likely an internal Pinia bug.");
        }
      }
    };
  }
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia2.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    if (isVue2$2) {
      set$3(pinia2.state.value, $id, {});
    } else {
      pinia2.state.value[$id] = {};
    }
  }
  const hotState = ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (false) {
      debuggerEvents = [];
    }
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
  }
  __name($patch, "$patch");
  const $reset = isOptionsStore ? /* @__PURE__ */ __name(function $reset2() {
    const { state } = options3;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$3($state, newState);
    });
  }, "$reset2") : (
    /* istanbul ignore next */
    false ? () => {
      throw new Error(`: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
    } : noop$3
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia2._s.delete($id);
  }
  __name($dispose, "$dispose");
  const action = /* @__PURE__ */ __name((fn, name = "") => {
    if (ACTION_MARKER in fn) {
      fn[ACTION_NAME] = name;
      return fn;
    }
    const wrappedAction = /* @__PURE__ */ __name(function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      __name(after, "after");
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      __name(onError, "onError");
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: wrappedAction[ACTION_NAME],
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = fn.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value3) => {
          triggerSubscriptions(afterCallbackList, value3);
          return value3;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    }, "wrappedAction");
    wrappedAction[ACTION_MARKER] = true;
    wrappedAction[ACTION_NAME] = name;
    return wrappedAction;
  }, "action");
  const _hmrPayload = /* @__PURE__ */ markRaw({
    actions: {},
    getters: {},
    state: [],
    hotState
  });
  const partialStore = {
    _p: pinia2,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options22 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options22.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
        if (options22.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$3({}, $subscribeOptions, options22)));
      return removeSubscription;
    },
    $dispose
  };
  if (isVue2$2) {
    partialStore._r = false;
  }
  const store = reactive(false ? assign$3(
    {
      _hmrPayload,
      _customProperties: markRaw(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    partialStore
    // must be added later
    // setupStore
  ) : partialStore);
  pinia2._s.set($id, store);
  const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(() => setup2({ action }))));
  for (const key in setupStore) {
    const prop2 = setupStore[key];
    if (isRef(prop2) && !isComputed(prop2) || isReactive(prop2)) {
      if (false) {
        set$3(hotState.value, key, toRef$1(setupStore, key));
      } else if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop2)) {
          if (isRef(prop2)) {
            prop2.value = initialState[key];
          } else {
            mergeReactiveObjects(prop2, initialState[key]);
          }
        }
        if (isVue2$2) {
          set$3(pinia2.state.value[$id], key, prop2);
        } else {
          pinia2.state.value[$id][key] = prop2;
        }
      }
      if (false) {
        _hmrPayload.state.push(key);
      }
    } else if (typeof prop2 === "function") {
      const actionValue = false ? prop2 : action(prop2, key);
      if (isVue2$2) {
        set$3(setupStore, key, actionValue);
      } else {
        setupStore[key] = actionValue;
      }
      if (false) {
        _hmrPayload.actions[key] = prop2;
      }
      optionsForPlugin.actions[key] = prop2;
    } else if (false) {
      if (isComputed(prop2)) {
        _hmrPayload.getters[key] = isOptionsStore ? (
          // @ts-expect-error
          options3.getters[key]
        ) : prop2;
        if (IS_CLIENT) {
          const getters = setupStore._getters || // @ts-expect-error: same
          (setupStore._getters = markRaw([]));
          getters.push(key);
        }
      }
    }
  }
  if (isVue2$2) {
    Object.keys(setupStore).forEach((key) => {
      set$3(store, key, setupStore[key]);
    });
  } else {
    assign$3(store, setupStore);
    assign$3(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: /* @__PURE__ */ __name(() => false ? hotState.value : pinia2.state.value[$id], "get"),
    set: /* @__PURE__ */ __name((state) => {
      if (false) {
        throw new Error("cannot set hotState");
      }
      $patch(($state) => {
        assign$3($state, state);
      });
    }, "set")
  });
  if (false) {
    store._hotUpdate = markRaw((newStore) => {
      store._hotUpdating = true;
      newStore._hmrPayload.state.forEach((stateKey) => {
        if (stateKey in store.$state) {
          const newStateTarget = newStore.$state[stateKey];
          const oldStateSource = store.$state[stateKey];
          if (typeof newStateTarget === "object" && isPlainObject$2(newStateTarget) && isPlainObject$2(oldStateSource)) {
            patchObject(newStateTarget, oldStateSource);
          } else {
            newStore.$state[stateKey] = oldStateSource;
          }
        }
        set$3(store, stateKey, toRef$1(newStore.$state, stateKey));
      });
      Object.keys(store.$state).forEach((stateKey) => {
        if (!(stateKey in newStore.$state)) {
          del$2(store, stateKey);
        }
      });
      isListening = false;
      isSyncListening = false;
      pinia2.state.value[$id] = toRef$1(newStore._hmrPayload, "hotState");
      isSyncListening = true;
      nextTick().then(() => {
        isListening = true;
      });
      for (const actionName in newStore._hmrPayload.actions) {
        const actionFn = newStore[actionName];
        set$3(store, actionName, action(actionFn, actionName));
      }
      for (const getterName in newStore._hmrPayload.getters) {
        const getter = newStore._hmrPayload.getters[getterName];
        const getterValue = isOptionsStore ? (
          // special handling of options api
          computed(() => {
            setActivePinia(pinia2);
            return getter.call(store, store);
          })
        ) : getter;
        set$3(store, getterName, getterValue);
      }
      Object.keys(store._hmrPayload.getters).forEach((key) => {
        if (!(key in newStore._hmrPayload.getters)) {
          del$2(store, key);
        }
      });
      Object.keys(store._hmrPayload.actions).forEach((key) => {
        if (!(key in newStore._hmrPayload.actions)) {
          del$2(store, key);
        }
      });
      store._hmrPayload = newStore._hmrPayload;
      store._getters = newStore._getters;
      store._hotUpdating = false;
    });
  }
  if (false) {
    const nonEnumerable = {
      writable: true,
      configurable: true,
      // avoid warning on devtools trying to display this property
      enumerable: false
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
      Object.defineProperty(store, p2, assign$3({ value: store[p2] }, nonEnumerable));
    });
  }
  if (isVue2$2) {
    store._r = true;
  }
  pinia2._p.forEach((extender) => {
    if (false) {
      const extensions = scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      }));
      Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
      assign$3(store, extensions);
    } else {
      assign$3(store, scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (false) {
    console.warn(`[]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
  }
  if (initialState && isOptionsStore && options3.hydrate) {
    options3.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
__name(createSetupStore, "createSetupStore");
// @__NO_SIDE_EFFECTS__
function defineStore(idOrOptions, setup2, setupOptions) {
  let id3;
  let options3;
  const isSetupStore = typeof setup2 === "function";
  if (typeof idOrOptions === "string") {
    id3 = idOrOptions;
    options3 = isSetupStore ? setupOptions : setup2;
  } else {
    options3 = idOrOptions;
    id3 = idOrOptions.id;
    if (false) {
      throw new Error(`[]: "defineStore()" must be passed a store id as its first argument.`);
    }
  }
  function useStore(pinia2, hot) {
    const hasContext = hasInjectionContext();
    pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (false ? null : pinia2) || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia2)
      setActivePinia(pinia2);
    if (false) {
      throw new Error(`[]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
    }
    pinia2 = activePinia;
    if (!pinia2._s.has(id3)) {
      if (isSetupStore) {
        createSetupStore(id3, setup2, options3, pinia2);
      } else {
        createOptionsStore(id3, options3, pinia2);
      }
      if (false) {
        useStore._pinia = pinia2;
      }
    }
    const store = pinia2._s.get(id3);
    if (false) {
      const hotId = "__hot:" + id3;
      const newStore = isSetupStore ? createSetupStore(hotId, setup2, options3, pinia2, true) : createOptionsStore(hotId, assign$3({}, options3), pinia2, true);
      hot._hotUpdate(newStore);
      delete pinia2.state.value[hotId];
      pinia2._s.delete(hotId);
    }
    if (false) {
      const currentInstance2 = getCurrentInstance();
      if (currentInstance2 && currentInstance2.proxy && // avoid adding stores that are just built for hot module replacement
      !hot) {
        const vm = currentInstance2.proxy;
        const cache2 = "_pStores" in vm ? vm._pStores : vm._pStores = {};
        cache2[id3] = store;
      }
    }
    return store;
  }
  __name(useStore, "useStore");
  useStore.$id = id3;
  return useStore;
}
__name(defineStore, "defineStore");
let mapStoreSuffix = "Store";
function setMapStoreSuffix(suffix2) {
  mapStoreSuffix = suffix2;
}
__name(setMapStoreSuffix, "setMapStoreSuffix");
function mapStores(...stores) {
  if (false) {
    console.warn(`[]: Directly pass all stores to "mapStores()" without putting them in an array:
Replace
	mapStores([useAuthStore, useCartStore])
with
	mapStores(useAuthStore, useCartStore)
This will fail in production if not fixed.`);
    stores = stores[0];
  }
  return stores.reduce((reduced, useStore) => {
    reduced[useStore.$id + mapStoreSuffix] = function() {
      return useStore(this.$pinia);
    };
    return reduced;
  }, {});
}
__name(mapStores, "mapStores");
function mapState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function() {
      return useStore(this.$pinia)[key];
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function() {
      const store = useStore(this.$pinia);
      const storeKey = keysOrMapper[key];
      return typeof storeKey === "function" ? storeKey.call(this, store) : store[storeKey];
    };
    return reduced;
  }, {});
}
__name(mapState, "mapState");
const mapGetters = mapState;
function mapActions(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return useStore(this.$pinia)[key](...args);
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return useStore(this.$pinia)[keysOrMapper[key]](...args);
    };
    return reduced;
  }, {});
}
__name(mapActions, "mapActions");
function mapWritableState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return useStore(this.$pinia)[key];
      },
      set(value3) {
        return useStore(this.$pinia)[key] = value3;
      }
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return useStore(this.$pinia)[keysOrMapper[key]];
      },
      set(value3) {
        return useStore(this.$pinia)[keysOrMapper[key]] = value3;
      }
    };
    return reduced;
  }, {});
}
__name(mapWritableState, "mapWritableState");
function storeToRefs(store) {
  if (isVue2$2) {
    return toRefs$1(store);
  } else {
    store = toRaw(store);
    const refs = {};
    for (const key in store) {
      const value3 = store[key];
      if (isRef(value3) || isReactive(value3)) {
        refs[key] = // ---
        toRef$1(store, key);
      }
    }
    return refs;
  }
}
__name(storeToRefs, "storeToRefs");
const PiniaVuePlugin = /* @__PURE__ */ __name(function(_Vue) {
  _Vue.mixin({
    beforeCreate() {
      const options3 = this.$options;
      if (options3.pinia) {
        const pinia2 = options3.pinia;
        if (!this._provided) {
          const provideCache = {};
          Object.defineProperty(this, "_provided", {
            get: /* @__PURE__ */ __name(() => provideCache, "get"),
            set: /* @__PURE__ */ __name((v2) => Object.assign(provideCache, v2), "set")
          });
        }
        this._provided[piniaSymbol] = pinia2;
        if (!this.$pinia) {
          this.$pinia = pinia2;
        }
        pinia2._a = this;
        if (IS_CLIENT) {
          setActivePinia(pinia2);
        }
        if (false) {
          registerPiniaDevtools(pinia2._a, pinia2);
        }
      } else if (!this.$pinia && options3.parent && options3.parent.$pinia) {
        this.$pinia = options3.parent.$pinia;
      }
    },
    destroyed() {
      delete this._pStores;
    }
  });
}, "PiniaVuePlugin");
const useToastStore = /* @__PURE__ */ defineStore("toast", () => {
  const messagesToAdd = ref([]);
  const messagesToRemove = ref([]);
  const removeAllRequested = ref(false);
  function add2(message2) {
    messagesToAdd.value = [...messagesToAdd.value, message2];
  }
  __name(add2, "add");
  function remove4(message2) {
    messagesToRemove.value = [...messagesToRemove.value, message2];
  }
  __name(remove4, "remove");
  function removeAll() {
    removeAllRequested.value = true;
  }
  __name(removeAll, "removeAll");
  function addAlert(message2) {
    add2({ severity: "warn", summary: "Alert", detail: message2 });
  }
  __name(addAlert, "addAlert");
  return {
    messagesToAdd,
    messagesToRemove,
    removeAllRequested,
    add: add2,
    remove: remove4,
    removeAll,
    addAlert
  };
});
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items2) => {
    const obj = {};
    for (const item2 of items2) {
      obj[item2] = item2;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item2 of arr) {
      if (checker(item2))
        return item2;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value3) => {
    if (typeof value3 === "bigint") {
      return value3.toString();
    }
    return value3;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = /* @__PURE__ */ __name((data22) => {
  const t = typeof data22;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data22) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data22)) {
        return ZodParsedType.array;
      }
      if (data22 === null) {
        return ZodParsedType.null;
      }
      if (data22.then && typeof data22.then === "function" && data22.catch && typeof data22.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data22 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data22 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data22 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
class ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value3) {
    if (!(value3 instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value3}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap$1 = /* @__PURE__ */ __name((issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
}, "errorMap$1");
let overrideErrorMap = errorMap$1;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");
const makeIssue = /* @__PURE__ */ __name((params) => {
  const { data: data22, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data: data22, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap$1 ? void 0 : errorMap$1
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
class ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value3 = await pair.value;
      syncPairs.push({
        key,
        value: value3
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value3 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value3.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value3.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value3.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value3.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = /* @__PURE__ */ __name((value3) => ({ status: "dirty", value: value3 }), "DIRTY");
const OK = /* @__PURE__ */ __name((value3) => ({ status: "valid", value: value3 }), "OK");
const isAborted = /* @__PURE__ */ __name((x2) => x2.status === "aborted", "isAborted");
const isDirty = /* @__PURE__ */ __name((x2) => x2.status === "dirty", "isDirty");
const isValid = /* @__PURE__ */ __name((x2) => x2.status === "valid", "isValid");
const isAsync = /* @__PURE__ */ __name((x2) => typeof Promise !== "undefined" && x2 instanceof Promise, "isAsync");
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, state, value3, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value3) : f ? f.value = value3 : state.set(receiver, value3), value3;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e = new Error(message2);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
  errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value3, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value3;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a, _b;
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 !== null && message2 !== void 0 ? message2 : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message2 !== null && message2 !== void 0 ? message2 : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message2 !== null && message2 !== void 0 ? message2 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
class ZodType {
  static {
    __name(this, "ZodType");
  }
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data22, params) {
    const result = this.safeParse(data22, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data22, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data22,
      parsedType: getParsedType(data22)
    };
    const result = this._parseSync({ data: data22, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data22, params) {
    const result = await this.safeParseAsync(data22, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data22, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data22,
      parsedType: getParsedType(data22)
    };
    const maybeAsyncResult = this._parse({ data: data22, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data22) => {
          if (!data22) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option3) {
    return ZodUnion.create([this, option3], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
class ZodString extends ZodType {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data22) => regex.test(data22), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message2)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message2) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
  }
  url(message2) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
  }
  emoji(message2) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
  }
  uuid(message2) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
  }
  nanoid(message2) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
  }
  cuid(message2) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
  }
  cuid2(message2) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
  }
  ulid(message2) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
  }
  base64(message2) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
  }
  ip(options3) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options3) });
  }
  datetime(options3) {
    var _a, _b;
    if (typeof options3 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options3
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options3 === null || options3 === void 0 ? void 0 : options3.precision) === "undefined" ? null : options3 === null || options3 === void 0 ? void 0 : options3.precision,
      offset: (_a = options3 === null || options3 === void 0 ? void 0 : options3.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options3 === null || options3 === void 0 ? void 0 : options3.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)
    });
  }
  date(message2) {
    return this._addCheck({ kind: "date", message: message2 });
  }
  time(options3) {
    if (typeof options3 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options3
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options3 === null || options3 === void 0 ? void 0 : options3.precision) === "undefined" ? null : options3 === null || options3 === void 0 ? void 0 : options3.precision,
      ...errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)
    });
  }
  duration(message2) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
  }
  regex(regex, message2) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message2)
    });
  }
  includes(value3, options3) {
    return this._addCheck({
      kind: "includes",
      value: value3,
      position: options3 === null || options3 === void 0 ? void 0 : options3.position,
      ...errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)
    });
  }
  startsWith(value3, message2) {
    return this._addCheck({
      kind: "startsWith",
      value: value3,
      ...errorUtil.errToObj(message2)
    });
  }
  endsWith(value3, message2) {
    return this._addCheck({
      kind: "endsWith",
      value: value3,
      ...errorUtil.errToObj(message2)
    });
  }
  min(minLength, message2) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message2)
    });
  }
  max(maxLength, message2) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message2)
    });
  }
  length(len, message2) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message2)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step2) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step2.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step2.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
class ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value3, message2) {
    return this.setLimit("min", value3, true, errorUtil.toString(message2));
  }
  gt(value3, message2) {
    return this.setLimit("min", value3, false, errorUtil.toString(message2));
  }
  lte(value3, message2) {
    return this.setLimit("max", value3, true, errorUtil.toString(message2));
  }
  lt(value3, message2) {
    return this.setLimit("max", value3, false, errorUtil.toString(message2));
  }
  setLimit(kind, value3, inclusive, message2) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value3,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value3, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value: value3,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value3, message2) {
    return this.setLimit("min", value3, true, errorUtil.toString(message2));
  }
  gt(value3, message2) {
    return this.setLimit("min", value3, false, errorUtil.toString(message2));
  }
  lte(value3, message2) {
    return this.setLimit("max", value3, true, errorUtil.toString(message2));
  }
  lt(value3, message2) {
    return this.setLimit("max", value3, false, errorUtil.toString(message2));
  }
  setLimit(kind, value3, inclusive, message2) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value3,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value3, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value: value3,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item2, i2) => {
        return def2.type._parseAsync(new ParseInputLazyPath(ctx, item2, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item2, i2) => {
      return def2.type._parseSync(new ParseInputLazyPath(ctx, item2, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    });
  }
  max(maxLength, message2) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    });
  }
  length(len, message2) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message2) }
    });
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item2) => deepPartialify(item2)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
class ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value3 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value3, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value3 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value3, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value3 = await pair.value;
          syncPairs.push({
            key,
            value: value3,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message2 !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask3) {
    const shape = {};
    util.objectKeys(mask3).forEach((key) => {
      if (mask3[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask3) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask3[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask3) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask3 && !mask3[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask3) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask3 && !mask3[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options3 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options3.map(async (option3) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option3._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option3 of options3) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option3._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
class ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option3 = this.optionsMap.get(discriminatorValue);
    if (!option3) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option3._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option3._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options3, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options3) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value3 of discriminatorValues) {
        if (optionsMap.has(value3)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value3)}`);
        }
        optionsMap.set(value3, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options3,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
class ZodIntersection extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items2 = [...ctx.data].map((item2, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item2, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items2).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items2);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value3], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value3, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value3 = await pair.value;
          if (key.status === "aborted" || value3.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value3.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value3.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value3 = pair.value;
        if (key.status === "aborted" || value3.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value3.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value3.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item2, i2) => valueType._parse(new ParseInputLazyPath(ctx, item2, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    });
  }
  max(maxSize, message2) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    });
  }
  size(size2, message2) {
    return this.min(size2, message2).max(size2, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap$1
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap$1
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items2) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items2).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value3, params) => {
  return new ZodLiteral({
    value: value3,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
class ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2, newDef = this._def) {
    return ZodEnum.create(values2, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values2, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data22) => {
      return this._def.type.parseAsync(data22, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect2 = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect2.type === "preprocess") {
      const processed = effect2.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect2.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect2.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect2.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect2.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect2.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect2);
  }
}
ZodEffects.create = (schema, effect2, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: effect2,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data22 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data22 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data22,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data22 = ctx.data;
    return this._def.type._parse({
      data: data22,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data22) => {
      if (isValid(data22)) {
        data22.value = Object.freeze(data22.value);
      }
      return data22;
    }, "freeze");
    return isAsync(result) ? result.then((data22) => freeze(data22)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data22, ctx) => {
      var _a, _b;
      if (!check(data22)) {
        const p2 = typeof params === "function" ? params(data22) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
__name(custom, "custom");
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data22) => data22 instanceof cls, params), "instanceOfType");
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
const onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
const oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
const coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$1,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
function isZodErrorLike(err) {
  return err instanceof Error && err.name === "ZodError" && "issues" in err && Array.isArray(err.issues);
}
__name(isZodErrorLike, "isZodErrorLike");
var ValidationError = class extends Error {
  static {
    __name(this, "ValidationError");
  }
  name;
  details;
  constructor(message2, options3) {
    super(message2, options3);
    this.name = "ZodValidationError";
    this.details = getIssuesFromErrorOptions(options3);
  }
  toString() {
    return this.message;
  }
};
function getIssuesFromErrorOptions(options3) {
  if (options3) {
    const cause = options3.cause;
    if (isZodErrorLike(cause)) {
      return cause.issues;
    }
  }
  return [];
}
__name(getIssuesFromErrorOptions, "getIssuesFromErrorOptions");
function isValidationError(err) {
  return err instanceof ValidationError;
}
__name(isValidationError, "isValidationError");
function isValidationErrorLike(err) {
  return err instanceof Error && err.name === "ZodValidationError";
}
__name(isValidationErrorLike, "isValidationErrorLike");
var ISSUE_SEPARATOR = "; ";
var MAX_ISSUES_IN_MESSAGE = 99;
var PREFIX = "Validation error";
var PREFIX_SEPARATOR = ": ";
var UNION_SEPARATOR = ", or ";
function prefixMessage(message2, prefix2, prefixSeparator) {
  if (prefix2 !== null) {
    if (message2.length > 0) {
      return [prefix2, message2].join(prefixSeparator);
    }
    return prefix2;
  }
  if (message2.length > 0) {
    return message2;
  }
  return PREFIX;
}
__name(prefixMessage, "prefixMessage");
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path) {
  if (path.length === 1) {
    return path[0].toString();
  }
  return path.reduce((acc, item2) => {
    if (typeof item2 === "number") {
      return acc + "[" + item2.toString() + "]";
    }
    if (item2.includes('"')) {
      return acc + '["' + escapeQuotes(item2) + '"]';
    }
    if (!identifierRegex.test(item2)) {
      return acc + '["' + item2 + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + item2;
  }, "");
}
__name(joinPath, "joinPath");
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}
__name(escapeQuotes, "escapeQuotes");
function isNonEmptyArray(value3) {
  return value3.length !== 0;
}
__name(isNonEmptyArray, "isNonEmptyArray");
function getMessageFromZodIssue(props) {
  const { issue, issueSeparator, unionSeparator, includePath } = props;
  if (issue.code === "invalid_union") {
    return issue.unionErrors.reduce((acc, zodError) => {
      const newIssues = zodError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      ).join(issueSeparator);
      if (!acc.includes(newIssues)) {
        acc.push(newIssues);
      }
      return acc;
    }, []).join(unionSeparator);
  }
  if (issue.code === "invalid_arguments") {
    return [
      issue.message,
      ...issue.argumentsError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (issue.code === "invalid_return_type") {
    return [
      issue.message,
      ...issue.returnTypeError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (includePath && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier = issue.path[0];
      if (typeof identifier === "number") {
        return `${issue.message} at index ${identifier}`;
      }
    }
    return `${issue.message} at "${joinPath(issue.path)}"`;
  }
  return issue.message;
}
__name(getMessageFromZodIssue, "getMessageFromZodIssue");
function fromZodIssue(issue, options3 = {}) {
  const {
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix: prefix2 = PREFIX,
    includePath = true
  } = options3;
  const reason = getMessageFromZodIssue({
    issue,
    issueSeparator,
    unionSeparator,
    includePath
  });
  const message2 = prefixMessage(reason, prefix2, prefixSeparator);
  return new ValidationError(message2, { cause: new ZodError([issue]) });
}
__name(fromZodIssue, "fromZodIssue");
var errorMap = /* @__PURE__ */ __name((issue, ctx) => {
  const error = fromZodIssue({
    ...issue,
    // fallback to the default error message
    // when issue does not have a message
    message: issue.message ?? ctx.defaultError
  });
  return {
    message: error.message
  };
}, "errorMap");
function fromZodError(zodError, options3 = {}) {
  if (!isZodErrorLike(zodError)) {
    throw new TypeError(
      `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
    );
  }
  return fromZodErrorWithoutRuntimeCheck(zodError, options3);
}
__name(fromZodError, "fromZodError");
function fromZodErrorWithoutRuntimeCheck(zodError, options3 = {}) {
  const {
    maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE,
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix: prefix2 = PREFIX,
    includePath = true
  } = options3;
  const zodIssues = zodError.errors;
  const reason = zodIssues.length === 0 ? zodError.message : zodIssues.slice(0, maxIssuesInMessage).map(
    (issue) => getMessageFromZodIssue({
      issue,
      issueSeparator,
      unionSeparator,
      includePath
    })
  ).join(issueSeparator);
  const message2 = prefixMessage(reason, prefix2, prefixSeparator);
  return new ValidationError(message2, { cause: zodError });
}
__name(fromZodErrorWithoutRuntimeCheck, "fromZodErrorWithoutRuntimeCheck");
var toValidationError = /* @__PURE__ */ __name((options3 = {}) => (err) => {
  if (isZodErrorLike(err)) {
    return fromZodErrorWithoutRuntimeCheck(err, options3);
  }
  if (err instanceof Error) {
    return new ValidationError(err.message, { cause: err });
  }
  return new ValidationError("Unknown error");
}, "toValidationError");
function fromError(err, options3 = {}) {
  return toValidationError(options3)(err);
}
__name(fromError, "fromError");
const zNodeId = z.union([z.number().int(), z.string()]);
const zSlotIndex = z.union([
  z.number().int(),
  z.string().transform((val) => parseInt(val)).refine((val) => !isNaN(val), {
    message: "Invalid number"
  })
]);
const zDataType = z.union([z.string(), z.array(z.string()), z.number()]);
const zVector2 = z.union([
  z.object({ 0: z.number(), 1: z.number() }).passthrough().transform((v2) => [v2[0], v2[1]]),
  z.tuple([z.number(), z.number()])
]);
const zModelFile = z.object({
  name: z.string(),
  url: z.string().url(),
  hash: z.string().optional(),
  hash_type: z.string().optional(),
  directory: z.string()
});
const zGraphState = z.object({
  lastGroupid: z.number().optional(),
  lastNodeId: z.number().optional(),
  lastLinkId: z.number().optional(),
  lastRerouteId: z.number().optional()
}).passthrough();
const zComfyLink = z.tuple([
  z.number(),
  // Link id
  zNodeId,
  // Node id of source node
  zSlotIndex,
  // Output slot# of source node
  zNodeId,
  // Node id of destination node
  zSlotIndex,
  // Input slot# of destination node
  zDataType
  // Data type
]);
const zComfyLinkExtension = z.object({
  id: z.number(),
  parentId: z.number()
}).passthrough();
const zComfyLinkObject = z.object({
  id: z.number(),
  origin_id: zNodeId,
  origin_slot: zSlotIndex,
  target_id: zNodeId,
  target_slot: zSlotIndex,
  type: zDataType,
  parentId: z.number().optional()
}).passthrough();
const zReroute = z.object({
  id: z.number(),
  parentId: z.number().optional(),
  pos: zVector2,
  linkIds: z.array(z.number()).nullish()
}).passthrough();
const zNodeOutput = z.object({
  name: z.string(),
  type: zDataType,
  links: z.array(z.number()).nullable().optional(),
  slot_index: zSlotIndex.optional()
}).passthrough();
const zNodeInput = z.object({
  name: z.string(),
  type: zDataType,
  link: z.number().nullable().optional(),
  slot_index: zSlotIndex.optional()
}).passthrough();
const zFlags = z.object({
  collapsed: z.boolean().optional(),
  pinned: z.boolean().optional(),
  allow_interaction: z.boolean().optional(),
  horizontal: z.boolean().optional(),
  skip_repeated_outputs: z.boolean().optional()
}).passthrough();
const zProperties = z.object({
  ["Node name for S&R"]: z.string().optional()
}).passthrough();
const zWidgetValues = z.union([z.array(z.any()), z.record(z.any())]);
const zComfyNode = z.object({
  id: zNodeId,
  type: z.string(),
  pos: zVector2,
  size: zVector2,
  flags: zFlags,
  order: z.number(),
  mode: z.number(),
  inputs: z.array(zNodeInput).optional(),
  outputs: z.array(zNodeOutput).optional(),
  properties: zProperties,
  widgets_values: zWidgetValues.optional(),
  color: z.string().optional(),
  bgcolor: z.string().optional()
}).passthrough();
const zGroup = z.object({
  title: z.string(),
  bounding: z.tuple([z.number(), z.number(), z.number(), z.number()]),
  color: z.string().optional(),
  font_size: z.number().optional(),
  locked: z.boolean().optional()
}).passthrough();
const zInfo = z.object({
  name: z.string(),
  author: z.string(),
  description: z.string(),
  version: z.string(),
  created: z.string(),
  modified: z.string(),
  software: z.string()
}).passthrough();
const zDS = z.object({
  scale: z.number(),
  offset: zVector2
}).passthrough();
const zConfig = z.object({
  links_ontop: z.boolean().optional(),
  align_to_grid: z.boolean().optional()
}).passthrough();
const zExtra = z.object({
  ds: zDS.optional(),
  info: zInfo.optional(),
  linkExtensions: z.array(zComfyLinkExtension).optional(),
  reroutes: z.array(zReroute).optional()
}).passthrough();
const zComfyWorkflow = z.object({
  last_node_id: zNodeId,
  last_link_id: z.number(),
  nodes: z.array(zComfyNode),
  links: z.array(zComfyLink),
  groups: z.array(zGroup).optional(),
  config: zConfig.optional().nullable(),
  extra: zExtra.optional().nullable(),
  version: z.number(),
  models: z.array(zModelFile).optional()
}).passthrough();
const zComfyWorkflow1 = z.object({
  version: z.literal(1),
  config: zConfig.optional().nullable(),
  state: zGraphState,
  groups: z.array(zGroup).optional(),
  nodes: z.array(zComfyNode),
  links: z.array(zComfyLinkObject).optional(),
  reroutes: z.array(zReroute).optional(),
  extra: zExtra.optional().nullable(),
  models: z.array(zModelFile).optional()
}).passthrough();
const zWorkflowVersion = z.object({
  version: z.number()
});
async function validateComfyWorkflow(data22, onError = console.warn) {
  const versionResult = zWorkflowVersion.safeParse(data22);
  let result;
  if (!versionResult.success) {
    const error2 = fromZodError(versionResult.error);
    onError(`Workflow does not contain a valid version.  Zod error:
${error2}`);
    return null;
  } else if (versionResult.data.version === 1) {
    result = await zComfyWorkflow1.safeParseAsync(data22);
  } else {
    result = await zComfyWorkflow.safeParseAsync(data22);
  }
  if (result.success) return result.data;
  const error = fromZodError(result.error);
  onError(`Invalid workflow against zod schema:
${error}`);
  return null;
}
__name(validateComfyWorkflow, "validateComfyWorkflow");
const nodeSlotSchema = z.object({
  BOOLEAN: z.string().optional(),
  CLIP: z.string(),
  CLIP_VISION: z.string(),
  CLIP_VISION_OUTPUT: z.string(),
  CONDITIONING: z.string(),
  CONTROL_NET: z.string(),
  CONTROL_NET_WEIGHTS: z.string().optional(),
  FLOAT: z.string().optional(),
  GLIGEN: z.string().optional(),
  IMAGE: z.string(),
  IMAGEUPLOAD: z.string().optional(),
  INT: z.string().optional(),
  LATENT: z.string(),
  LATENT_KEYFRAME: z.string().optional(),
  MASK: z.string(),
  MODEL: z.string(),
  SAMPLER: z.string().optional(),
  SIGMAS: z.string().optional(),
  STRING: z.string().optional(),
  STYLE_MODEL: z.string(),
  T2I_ADAPTER_WEIGHTS: z.string().optional(),
  TAESD: z.string(),
  TIMESTEP_KEYFRAME: z.string().optional(),
  UPSCALE_MODEL: z.string().optional(),
  VAE: z.string()
}).passthrough();
const litegraphBaseSchema = z.object({
  BACKGROUND_IMAGE: z.string(),
  CLEAR_BACKGROUND_COLOR: z.string(),
  NODE_TITLE_COLOR: z.string(),
  NODE_SELECTED_TITLE_COLOR: z.string(),
  NODE_TEXT_SIZE: z.number(),
  NODE_TEXT_COLOR: z.string(),
  NODE_SUBTEXT_SIZE: z.number(),
  NODE_DEFAULT_COLOR: z.string(),
  NODE_DEFAULT_BGCOLOR: z.string(),
  NODE_DEFAULT_BOXCOLOR: z.string(),
  NODE_DEFAULT_SHAPE: z.string(),
  NODE_BOX_OUTLINE_COLOR: z.string(),
  NODE_BYPASS_BGCOLOR: z.string(),
  DEFAULT_SHADOW_COLOR: z.string(),
  DEFAULT_GROUP_FONT: z.number(),
  WIDGET_BGCOLOR: z.string(),
  WIDGET_OUTLINE_COLOR: z.string(),
  WIDGET_TEXT_COLOR: z.string(),
  WIDGET_SECONDARY_TEXT_COLOR: z.string(),
  LINK_COLOR: z.string(),
  EVENT_LINK_COLOR: z.string(),
  CONNECTING_LINK_COLOR: z.string(),
  BADGE_FG_COLOR: z.string().optional(),
  BADGE_BG_COLOR: z.string().optional()
}).passthrough();
const comfyBaseSchema = z.object({
  ["fg-color"]: z.string(),
  ["bg-color"]: z.string(),
  ["bg-img"]: z.string().optional(),
  ["comfy-menu-bg"]: z.string(),
  ["comfy-input-bg"]: z.string(),
  ["input-text"]: z.string(),
  ["descrip-text"]: z.string(),
  ["drag-text"]: z.string(),
  ["error-text"]: z.string(),
  ["border-color"]: z.string(),
  ["tr-even-bg-color"]: z.string(),
  ["tr-odd-bg-color"]: z.string(),
  ["content-bg"]: z.string(),
  ["content-fg"]: z.string(),
  ["content-hover-bg"]: z.string(),
  ["content-hover-fg"]: z.string()
});
const colorsSchema = z.object({
  node_slot: nodeSlotSchema,
  litegraph_base: litegraphBaseSchema,
  comfy_base: comfyBaseSchema
}).passthrough();
const paletteSchema = z.object({
  id: z.string(),
  name: z.string(),
  colors: colorsSchema
});
const colorPalettesSchema = z.record(paletteSchema);
var LinkReleaseTriggerMode = /* @__PURE__ */ ((LinkReleaseTriggerMode2) => {
  LinkReleaseTriggerMode2["ALWAYS"] = "always";
  LinkReleaseTriggerMode2["HOLD_SHIFT"] = "hold shift";
  LinkReleaseTriggerMode2["NOT_HOLD_SHIFT"] = "NOT hold shift";
  return LinkReleaseTriggerMode2;
})(LinkReleaseTriggerMode || {});
var LinkReleaseTriggerAction = /* @__PURE__ */ ((LinkReleaseTriggerAction2) => {
  LinkReleaseTriggerAction2["CONTEXT_MENU"] = "context menu";
  LinkReleaseTriggerAction2["SEARCH_BOX"] = "search box";
  LinkReleaseTriggerAction2["NO_ACTION"] = "no action";
  return LinkReleaseTriggerAction2;
})(LinkReleaseTriggerAction || {});
var NodeSourceType = /* @__PURE__ */ ((NodeSourceType2) => {
  NodeSourceType2["Core"] = "core";
  NodeSourceType2["CustomNodes"] = "custom_nodes";
  NodeSourceType2["Unknown"] = "unknown";
  return NodeSourceType2;
})(NodeSourceType || {});
const UNKNOWN_NODE_SOURCE = {
  type: "unknown",
  className: "comfy-unknown",
  displayText: "Unknown",
  badgeText: "?"
};
const shortenNodeName = /* @__PURE__ */ __name((name) => {
  return name.replace(/^(ComfyUI-|ComfyUI_|Comfy-|Comfy_)/, "").replace(/(-ComfyUI|_ComfyUI|-Comfy|_Comfy)$/, "");
}, "shortenNodeName");
const getNodeSource = /* @__PURE__ */ __name((python_module) => {
  if (!python_module) {
    return UNKNOWN_NODE_SOURCE;
  }
  const modules = python_module.split(".");
  if (["nodes", "comfy_extras"].includes(modules[0])) {
    return {
      type: "core",
      className: "comfy-core",
      displayText: "Comfy Core",
      badgeText: ""
    };
  } else if (modules[0] === "custom_nodes") {
    const displayName = shortenNodeName(modules[1]);
    return {
      type: "custom_nodes",
      className: "comfy-custom-nodes",
      displayText: displayName,
      badgeText: displayName
    };
  } else {
    return UNKNOWN_NODE_SOURCE;
  }
}, "getNodeSource");
var NodeBadgeMode = /* @__PURE__ */ ((NodeBadgeMode2) => {
  NodeBadgeMode2["None"] = "None";
  NodeBadgeMode2["ShowAll"] = "Show all";
  NodeBadgeMode2["HideBuiltIn"] = "Hide built-in";
  return NodeBadgeMode2;
})(NodeBadgeMode || {});
const zKeyCombo = z.object({
  key: z.string(),
  ctrl: z.boolean().optional(),
  alt: z.boolean().optional(),
  shift: z.boolean().optional(),
  meta: z.boolean().optional()
});
const zKeybinding = z.object({
  commandId: z.string(),
  combo: zKeyCombo,
  // Optional target element CSS selector to limit keybinding to.
  // Note: Currently only used to distinguish between global keybindings
  // and litegraph canvas keybindings.
  // Do NOT use this field in extensions as it has no effect.
  targetSelector: z.string().optional()
});
const zNodeType = z.string();
const zQueueIndex = z.number();
const zPromptId = z.string();
const zResultItem = z.object({
  filename: z.string().optional(),
  subfolder: z.string().optional(),
  type: z.string().optional()
});
const zOutputs = z.object({
  audio: z.array(zResultItem).optional(),
  images: z.array(zResultItem).optional()
}).passthrough();
const zStatusWsMessageStatus = z.object({
  exec_info: z.object({
    queue_remaining: z.number().int()
  })
});
const zStatusWsMessage = z.object({
  status: zStatusWsMessageStatus.nullable().optional()
});
const zProgressWsMessage = z.object({
  value: z.number().int(),
  max: z.number().int(),
  prompt_id: zPromptId,
  node: zNodeId
});
const zExecutingWsMessage = z.object({
  node: zNodeId,
  display_node: zNodeId,
  prompt_id: zPromptId
});
const zExecutedWsMessage = zExecutingWsMessage.extend({
  output: zOutputs,
  merge: z.boolean().optional()
});
const zExecutionWsMessageBase = z.object({
  prompt_id: zPromptId,
  timestamp: z.number().int()
});
const zExecutionStartWsMessage = zExecutionWsMessageBase;
const zExecutionSuccessWsMessage = zExecutionWsMessageBase;
const zExecutionCachedWsMessage = zExecutionWsMessageBase.extend({
  nodes: z.array(zNodeId)
});
const zExecutionInterruptedWsMessage = zExecutionWsMessageBase.extend({
  node_id: zNodeId,
  node_type: zNodeType,
  executed: z.array(zNodeId)
});
const zExecutionErrorWsMessage = zExecutionWsMessageBase.extend({
  node_id: zNodeId,
  node_type: zNodeType,
  executed: z.array(zNodeId),
  exception_message: z.string(),
  exception_type: z.string(),
  traceback: z.array(z.string()),
  current_inputs: z.any(),
  current_outputs: z.any()
});
const zTerminalSize = z.object({
  cols: z.number(),
  row: z.number()
});
const zLogEntry = z.object({
  t: z.string(),
  m: z.string()
});
const zLogsWsMessage = z.object({
  size: zTerminalSize.optional(),
  entries: z.array(zLogEntry)
});
const zLogRawResponse = z.object({
  size: zTerminalSize,
  entries: z.array(zLogEntry)
});
const zPromptInputItem = z.object({
  inputs: z.record(z.string(), z.any()),
  class_type: zNodeType
});
const zPromptInputs = z.record(zPromptInputItem);
const zExtraPngInfo = z.object({
  workflow: zComfyWorkflow
}).passthrough();
const zExtraData = z.object({
  /** extra_pnginfo can be missing is backend execution gets a validation error. */
  extra_pnginfo: zExtraPngInfo.optional(),
  client_id: z.string()
});
const zOutputsToExecute = z.array(zNodeId);
const zExecutionStartMessage = z.tuple([
  z.literal("execution_start"),
  zExecutionStartWsMessage
]);
const zExecutionSuccessMessage = z.tuple([
  z.literal("execution_success"),
  zExecutionSuccessWsMessage
]);
const zExecutionCachedMessage = z.tuple([
  z.literal("execution_cached"),
  zExecutionCachedWsMessage
]);
const zExecutionInterruptedMessage = z.tuple([
  z.literal("execution_interrupted"),
  zExecutionInterruptedWsMessage
]);
const zExecutionErrorMessage = z.tuple([
  z.literal("execution_error"),
  zExecutionErrorWsMessage
]);
const zStatusMessage = z.union([
  zExecutionStartMessage,
  zExecutionSuccessMessage,
  zExecutionCachedMessage,
  zExecutionInterruptedMessage,
  zExecutionErrorMessage
]);
const zStatus = z.object({
  status_str: z.enum(["success", "error"]),
  completed: z.boolean(),
  messages: z.array(zStatusMessage)
});
const zTaskPrompt = z.tuple([
  zQueueIndex,
  zPromptId,
  zPromptInputs,
  zExtraData,
  zOutputsToExecute
]);
const zRunningTaskItem = z.object({
  taskType: z.literal("Running"),
  prompt: zTaskPrompt,
  // @Deprecated
  remove: z.object({
    name: z.literal("Cancel"),
    cb: z.function()
  })
});
const zPendingTaskItem = z.object({
  taskType: z.literal("Pending"),
  prompt: zTaskPrompt
});
const zTaskOutput = z.record(zNodeId, zOutputs);
const zHistoryTaskItem = z.object({
  taskType: z.literal("History"),
  prompt: zTaskPrompt,
  status: zStatus.optional(),
  outputs: zTaskOutput
});
const zTaskItem = z.union([
  zRunningTaskItem,
  zPendingTaskItem,
  zHistoryTaskItem
]);
const zTaskType = z.union([
  z.literal("Running"),
  z.literal("Pending"),
  z.literal("History")
]);
function validateTaskItem(taskItem) {
  const result = zTaskItem.safeParse(taskItem);
  if (!result.success) {
    const zodError = fromZodError(result.error);
    console.warn(
      `Invalid TaskItem: ${JSON.stringify(taskItem)}
${zodError.message}`
    );
  }
  return result;
}
__name(validateTaskItem, "validateTaskItem");
function inputSpec(spec, allowUpcast = true) {
  const [inputType, inputSpec2] = spec;
  const upcastTypes = allowUpcast ? [inputType.transform((type) => [type, {}])] : [];
  return z.union([
    z.tuple([inputType, inputSpec2]),
    z.tuple([inputType]).transform(([type]) => [type, {}]),
    ...upcastTypes
  ]);
}
__name(inputSpec, "inputSpec");
const zBaseInputSpecValue = z.object({
  default: z.any().optional(),
  defaultInput: z.boolean().optional(),
  forceInput: z.boolean().optional(),
  lazy: z.boolean().optional(),
  rawLink: z.boolean().optional(),
  tooltip: z.string().optional(),
  hidden: z.boolean().optional(),
  advanced: z.boolean().optional()
}).passthrough();
const zIntInputSpec = inputSpec([
  z.literal("INT"),
  zBaseInputSpecValue.extend({
    min: z.number().optional(),
    max: z.number().optional(),
    step: z.number().optional(),
    // Note: Many node authors are using INT to pass list of INT.
    // TODO: Add list of ints type.
    default: z.union([z.number(), z.array(z.number())]).optional()
  })
]);
const zFloatInputSpec = inputSpec([
  z.literal("FLOAT"),
  zBaseInputSpecValue.extend({
    min: z.number().optional(),
    max: z.number().optional(),
    step: z.number().optional(),
    round: z.union([z.number(), z.literal(false)]).optional(),
    // Note: Many node authors are using FLOAT to pass list of FLOAT.
    // TODO: Add list of floats type.
    default: z.union([z.number(), z.array(z.number())]).optional()
  })
]);
const zBooleanInputSpec = inputSpec([
  z.literal("BOOLEAN"),
  zBaseInputSpecValue.extend({
    label_on: z.string().optional(),
    label_off: z.string().optional(),
    default: z.boolean().optional()
  })
]);
const zStringInputSpec = inputSpec([
  z.literal("STRING"),
  zBaseInputSpecValue.extend({
    default: z.string().optional(),
    multiline: z.boolean().optional(),
    dynamicPrompts: z.boolean().optional(),
    // Multiline-only fields
    defaultVal: z.string().optional(),
    placeholder: z.string().optional()
  })
]);
const zComboInputSpec = inputSpec(
  [
    z.array(z.any()),
    zBaseInputSpecValue.extend({
      control_after_generate: z.boolean().optional(),
      image_upload: z.boolean().optional()
    })
  ],
  /* allowUpcast=*/
  false
);
const excludedLiterals = /* @__PURE__ */ new Set(["INT", "FLOAT", "BOOLEAN", "STRING", "COMBO"]);
const zCustomInputSpec = inputSpec([
  z.string().refine((value3) => !excludedLiterals.has(value3)),
  zBaseInputSpecValue
]);
const zInputSpec = z.union([
  zIntInputSpec,
  zFloatInputSpec,
  zBooleanInputSpec,
  zStringInputSpec,
  zComboInputSpec,
  zCustomInputSpec
]);
const zComfyInputsSpec = z.object({
  required: z.record(zInputSpec).optional(),
  optional: z.record(zInputSpec).optional(),
  // Frontend repo is not using it, but some custom nodes are using the
  // hidden field to pass various values.
  hidden: z.record(z.any()).optional()
});
const zComfyNodeDataType = z.string();
const zComfyComboOutput = z.array(z.any());
const zComfyOutputTypesSpec = z.array(
  z.union([zComfyNodeDataType, zComfyComboOutput])
);
const zComfyNodeDef = z.object({
  input: zComfyInputsSpec.optional(),
  output: zComfyOutputTypesSpec.optional(),
  output_is_list: z.array(z.boolean()).optional(),
  output_name: z.array(z.string()).optional(),
  output_tooltips: z.array(z.string()).optional(),
  name: z.string(),
  display_name: z.string(),
  description: z.string(),
  category: z.string(),
  output_node: z.boolean(),
  python_module: z.string(),
  deprecated: z.boolean().optional(),
  experimental: z.boolean().optional()
});
function validateComfyNodeDef(data22, onError = console.warn) {
  const result = zComfyNodeDef.safeParse(data22);
  if (!result.success) {
    const zodError = fromZodError(result.error);
    onError(
      `Invalid ComfyNodeDef: ${JSON.stringify(data22)}
${zodError.message}`
    );
    return null;
  }
  return result.data;
}
__name(validateComfyNodeDef, "validateComfyNodeDef");
const zEmbeddingsResponse = z.array(z.string());
const zExtensionsResponse = z.array(z.string());
const zPromptResponse = z.object({
  node_errors: z.array(z.string()).optional(),
  prompt_id: z.string().optional(),
  exec_info: z.object({
    queue_remaining: z.number().optional()
  }).optional()
});
const zDeviceStats = z.object({
  name: z.string(),
  type: z.string(),
  index: z.number(),
  vram_total: z.number(),
  vram_free: z.number(),
  torch_vram_total: z.number(),
  torch_vram_free: z.number()
});
const zSystemStats = z.object({
  system: z.object({
    os: z.string(),
    python_version: z.string(),
    embedded_python: z.boolean(),
    comfyui_version: z.string(),
    pytorch_version: z.string(),
    argv: z.array(z.string()),
    ram_total: z.number(),
    ram_free: z.number()
  }),
  devices: z.array(zDeviceStats)
});
const zUser = z.object({
  storage: z.enum(["server", "browser"]),
  migrated: z.boolean(),
  users: z.record(z.string(), z.unknown())
});
const zUserData = z.array(z.array(z.string(), z.string()));
const zUserDataFullInfo = z.object({
  path: z.string(),
  size: z.number(),
  modified: z.number()
});
const zBookmarkCustomization = z.object({
  icon: z.string().optional(),
  color: z.string().optional()
});
const zLinkReleaseTriggerAction = z.enum(
  Object.values(LinkReleaseTriggerAction)
);
const zNodeBadgeMode = z.enum(
  Object.values(NodeBadgeMode)
);
const zSettings = z.record(z.any()).and(
  z.object({
    "Comfy.ColorPalette": z.string(),
    "Comfy.CustomColorPalettes": colorPalettesSchema,
    "Comfy.ConfirmClear": z.boolean(),
    "Comfy.DevMode": z.boolean(),
    "Comfy.Workflow.ShowMissingNodesWarning": z.boolean(),
    "Comfy.Workflow.ShowMissingModelsWarning": z.boolean(),
    "Comfy.DisableFloatRounding": z.boolean(),
    "Comfy.DisableSliders": z.boolean(),
    "Comfy.DOMClippingEnabled": z.boolean(),
    "Comfy.EditAttention.Delta": z.number(),
    "Comfy.EnableTooltips": z.boolean(),
    "Comfy.EnableWorkflowViewRestore": z.boolean(),
    "Comfy.FloatRoundingPrecision": z.number(),
    "Comfy.Graph.CanvasInfo": z.boolean(),
    "Comfy.Graph.ZoomSpeed": z.number(),
    "Comfy.Group.DoubleClickTitleToEdit": z.boolean(),
    "Comfy.GroupSelectedNodes.Padding": z.number(),
    "Comfy.InvertMenuScrolling": z.boolean(),
    "Comfy.Locale": z.string(),
    "Comfy.Logging.Enabled": z.boolean(),
    "Comfy.NodeLibrary.Bookmarks": z.array(z.string()),
    "Comfy.NodeLibrary.Bookmarks.V2": z.array(z.string()),
    "Comfy.NodeLibrary.BookmarksCustomization": z.record(
      z.string(),
      zBookmarkCustomization
    ),
    "Comfy.NodeInputConversionSubmenus": z.boolean(),
    "Comfy.NodeSearchBoxImpl.LinkReleaseTrigger": z.enum([
      "always",
      "hold shift",
      "NOT hold shift"
    ]),
    "Comfy.LinkRelease.Action": zLinkReleaseTriggerAction,
    "Comfy.LinkRelease.ActionShift": zLinkReleaseTriggerAction,
    "Comfy.NodeSearchBoxImpl.NodePreview": z.boolean(),
    "Comfy.NodeSearchBoxImpl": z.enum(["default", "simple"]),
    "Comfy.NodeSearchBoxImpl.ShowCategory": z.boolean(),
    "Comfy.NodeSearchBoxImpl.ShowIdName": z.boolean(),
    "Comfy.NodeSuggestions.number": z.number(),
    "Comfy.Node.ShowDeprecated": z.boolean(),
    "Comfy.Node.ShowExperimental": z.boolean(),
    "Comfy.PreviewFormat": z.string(),
    "Comfy.PromptFilename": z.boolean(),
    "Comfy.Sidebar.Location": z.enum(["left", "right"]),
    "Comfy.Sidebar.Size": z.enum(["small", "normal"]),
    "Comfy.SwitchUser": z.any(),
    "Comfy.SnapToGrid.GridSize": z.number(),
    "Comfy.TextareaWidget.FontSize": z.number(),
    "Comfy.TextareaWidget.Spellcheck": z.boolean(),
    "Comfy.UseNewMenu": z.enum(["Disabled", "Top", "Bottom"]),
    "Comfy.TreeExplorer.ItemPadding": z.number(),
    "Comfy.Validation.Workflows": z.boolean(),
    "Comfy.Workflow.SortNodeIdOnSave": z.boolean(),
    "Comfy.Queue.ImageFit": z.enum(["contain", "cover"]),
    "Comfy.Workflow.WorkflowTabsPosition": z.enum(["Sidebar", "Topbar"]),
    "Comfy.Node.DoubleClickTitleToEdit": z.boolean(),
    "Comfy.Window.UnloadConfirmation": z.boolean(),
    "Comfy.NodeBadge.NodeSourceBadgeMode": zNodeBadgeMode,
    "Comfy.NodeBadge.NodeIdBadgeMode": zNodeBadgeMode,
    "Comfy.NodeBadge.NodeLifeCycleBadgeMode": zNodeBadgeMode,
    "Comfy.QueueButton.BatchCountLimit": z.number(),
    "Comfy.Keybinding.UnsetBindings": z.array(zKeybinding),
    "Comfy.Keybinding.NewBindings": z.array(zKeybinding),
    "Comfy.Extension.Disabled": z.array(z.string()),
    "Comfy.Settings.ExtensionPanel": z.boolean(),
    "Comfy.LinkRenderMode": z.number(),
    "Comfy.Node.AutoSnapLinkToSlot": z.boolean(),
    "Comfy.Node.SnapHighlightsNode": z.boolean()
  }).optional()
);
"use strict";
function bind$2(fn, thisArg) {
  return /* @__PURE__ */ __name(function wrap() {
    return fn.apply(thisArg, arguments);
  }, "wrap");
}
__name(bind$2, "bind$2");
"use strict";
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString$2.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = /* @__PURE__ */ __name((type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
}, "kindOfTest");
const typeOfTest = /* @__PURE__ */ __name((type) => (thing) => typeof thing === type, "typeOfTest");
const { isArray: isArray$4 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
__name(isBuffer, "isBuffer");
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
__name(isArrayBufferView, "isArrayBufferView");
const isString$4 = typeOfTest("string");
const isFunction$2 = typeOfTest("function");
const isNumber$3 = typeOfTest("number");
const isObject$5 = /* @__PURE__ */ __name((thing) => thing !== null && typeof thing === "object", "isObject$5");
const isBoolean$2 = /* @__PURE__ */ __name((thing) => thing === true || thing === false, "isBoolean$2");
const isPlainObject$1 = /* @__PURE__ */ __name((val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}, "isPlainObject$1");
const isDate$2 = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = /* @__PURE__ */ __name((val) => isObject$5(val) && isFunction$2(val.pipe), "isStream");
const isFormData = /* @__PURE__ */ __name((thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
}, "isFormData");
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = /* @__PURE__ */ __name((str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), "trim");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$4(obj)) {
    for (i2 = 0, l = obj.length; i2 < l; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
__name(forEach, "forEach");
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i2 = keys2.length;
  let _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
__name(findKey, "findKey");
const _global$1 = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = /* @__PURE__ */ __name((context) => !isUndefined(context) && context !== _global$1, "isContextDefined");
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = /* @__PURE__ */ __name((val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject$1(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray$4(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }, "assignValue");
  for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
__name(merge$1, "merge$1");
const extend = /* @__PURE__ */ __name((a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$2(val)) {
      a[key] = bind$2(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
}, "extend");
const stripBOM = /* @__PURE__ */ __name((content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
}, "stripBOM");
const inherits = /* @__PURE__ */ __name((constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}, "inherits");
const toFlatObject = /* @__PURE__ */ __name((sourceObj, destObj, filter4, propFilter) => {
  let props;
  let i2;
  let prop2;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop2 = props[i2];
      if ((!propFilter || propFilter(prop2, sourceObj, destObj)) && !merged[prop2]) {
        destObj[prop2] = sourceObj[prop2];
        merged[prop2] = true;
      }
    }
    sourceObj = filter4 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter4 || filter4(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}, "toFlatObject");
const endsWith = /* @__PURE__ */ __name((str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
}, "endsWith");
const toArray = /* @__PURE__ */ __name((thing) => {
  if (!thing) return null;
  if (isArray$4(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber$3(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
}, "toArray");
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = /* @__PURE__ */ __name((obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}, "forEachEntry");
const matchAll = /* @__PURE__ */ __name((regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
}, "matchAll");
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = /* @__PURE__ */ __name((str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    /* @__PURE__ */ __name(function replacer2(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }, "replacer")
  );
}, "toCamelCase");
const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop2) => hasOwnProperty2.call(obj, prop2))(Object.prototype);
const isRegExp$1 = kindOfTest("RegExp");
const reduceDescriptors = /* @__PURE__ */ __name((obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
}, "reduceDescriptors");
const freezeMethods = /* @__PURE__ */ __name((obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value3 = obj[name];
    if (!isFunction$2(value3)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
}, "freezeMethods");
const toObjectSet = /* @__PURE__ */ __name((arrayOrString, delimiter) => {
  const obj = {};
  const define = /* @__PURE__ */ __name((arr) => {
    arr.forEach((value3) => {
      obj[value3] = true;
    });
  }, "define");
  isArray$4(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
}, "toObjectSet");
const noop$2 = /* @__PURE__ */ __name(() => {
}, "noop$2");
const toFiniteNumber = /* @__PURE__ */ __name((value3, defaultValue) => {
  return value3 != null && Number.isFinite(value3 = +value3) ? value3 : defaultValue;
}, "toFiniteNumber");
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = /* @__PURE__ */ __name((size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
}, "generateString");
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
__name(isSpecCompliantForm, "isSpecCompliantForm");
const toJSONObject = /* @__PURE__ */ __name((obj) => {
  const stack2 = new Array(10);
  const visit = /* @__PURE__ */ __name((source, i2) => {
    if (isObject$5(source)) {
      if (stack2.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack2[i2] = source;
        const target = isArray$4(source) ? [] : {};
        forEach(source, (value3, key) => {
          const reducedValue = visit(value3, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack2[i2] = void 0;
        return target;
      }
    }
    return source;
  }, "visit");
  return visit(obj, 0);
}, "toJSONObject");
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = /* @__PURE__ */ __name((thing) => thing && (isObject$5(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch), "isThenable");
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global$1.addEventListener("message", ({ source, data: data22 }) => {
      if (source === _global$1 && data22 === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global$1.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$2(_global$1.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global$1) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$1 = {
  isArray: isArray$4,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$4,
  isNumber: isNumber$3,
  isBoolean: isBoolean$2,
  isObject: isObject$5,
  isPlainObject: isPlainObject$1,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate: isDate$2,
  isFile,
  isBlob,
  isRegExp: isRegExp$1,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$1,
  hasOwnProp: hasOwnProperty$1,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global$1,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
"use strict";
function AxiosError$1(message2, code2, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request && (this.request = request);
  response && (this.response = response);
}
__name(AxiosError$1, "AxiosError$1");
utils$1.inherits(AxiosError$1, Error, {
  toJSON: /* @__PURE__ */ __name(function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }, "toJSON")
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code2, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, /* @__PURE__ */ __name(function filter4(obj) {
    return obj !== Error.prototype;
  }, "filter"), (prop2) => {
    return prop2 !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error.message, code2, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
"use strict";
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
__name(isVisitable, "isVisitable");
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
__name(removeBrackets, "removeBrackets");
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(/* @__PURE__ */ __name(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }, "each")).join(dots ? "." : "");
}
__name(renderKey, "renderKey");
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
__name(isFlatArray, "isFlatArray");
const predicates = utils$1.toFlatObject(utils$1, {}, null, /* @__PURE__ */ __name(function filter2(prop2) {
  return /^is[A-Z]/.test(prop2);
}, "filter"));
function toFormData$1(obj, formData, options3) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (httpAdapter || FormData)();
  options3 = utils$1.toFlatObject(options3, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, /* @__PURE__ */ __name(function defined(option3, source) {
    return !utils$1.isUndefined(source[option3]);
  }, "defined"));
  const metaTokens = options3.metaTokens;
  const visitor = options3.visitor || defaultVisitor;
  const dots = options3.dots;
  const indexes = options3.indexes;
  const _Blob = options3.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value3) {
    if (value3 === null) return "";
    if (utils$1.isDate(value3)) {
      return value3.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value3)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value3) || utils$1.isTypedArray(value3)) {
      return useBlob && typeof Blob === "function" ? new Blob([value3]) : Buffer.from(value3);
    }
    return value3;
  }
  __name(convertValue, "convertValue");
  function defaultVisitor(value3, key, path) {
    let arr = value3;
    if (value3 && !path && typeof value3 === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value3 = JSON.stringify(value3);
      } else if (utils$1.isArray(value3) && isFlatArray(value3) || (utils$1.isFileList(value3) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value3))) {
        key = removeBrackets(key);
        arr.forEach(/* @__PURE__ */ __name(function each(el, index2) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        }, "each"));
        return false;
      }
    }
    if (isVisitable(value3)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value3));
    return false;
  }
  __name(defaultVisitor, "defaultVisitor");
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value3, path) {
    if (utils$1.isUndefined(value3)) return;
    if (stack2.indexOf(value3) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack2.push(value3);
    utils$1.forEach(value3, /* @__PURE__ */ __name(function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    }, "each"));
    stack2.pop();
  }
  __name(build, "build");
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
__name(toFormData$1, "toFormData$1");
"use strict";
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, /* @__PURE__ */ __name(function replacer2(match) {
    return charMap[match];
  }, "replacer"));
}
__name(encode$1, "encode$1");
function AxiosURLSearchParams(params, options3) {
  this._pairs = [];
  params && toFormData$1(params, this, options3);
}
__name(AxiosURLSearchParams, "AxiosURLSearchParams");
const prototype = AxiosURLSearchParams.prototype;
prototype.append = /* @__PURE__ */ __name(function append(name, value3) {
  this._pairs.push([name, value3]);
}, "append");
prototype.toString = /* @__PURE__ */ __name(function toString2(encoder) {
  const _encode = encoder ? function(value3) {
    return encoder.call(this, value3, encode$1);
  } : encode$1;
  return this._pairs.map(/* @__PURE__ */ __name(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "each"), "").join("&");
}, "toString");
"use strict";
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
__name(encode, "encode");
function buildURL(url, params, options3) {
  if (!params) {
    return url;
  }
  const _encode = options3 && options3.encode || encode;
  const serializeFn = options3 && options3.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options3);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options3).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
__name(buildURL, "buildURL");
"use strict";
class InterceptorManager {
  static {
    __name(this, "InterceptorManager");
  }
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options3) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options3 ? options3.synchronous : false,
      runWhen: options3 ? options3.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id3) {
    if (this.handlers[id3]) {
      this.handlers[id3] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, /* @__PURE__ */ __name(function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    }, "forEachHandler"));
  }
}
"use strict";
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
"use strict";
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
"use strict";
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
"use strict";
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
"use strict";
function toURLEncodedForm(data22, options3) {
  return toFormData$1(data22, new platform.classes.URLSearchParams(), Object.assign({
    visitor: /* @__PURE__ */ __name(function(value3, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value3)) {
        this.append(key, value3.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }, "visitor")
  }, options3));
}
__name(toURLEncodedForm, "toURLEncodedForm");
"use strict";
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
__name(parsePropPath, "parsePropPath");
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i2;
  const len = keys2.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys2[i2];
    obj[key] = arr[key];
  }
  return obj;
}
__name(arrayToObject, "arrayToObject");
function formDataToJSON(formData) {
  function buildPath(path, value3, target, index2) {
    let name = path[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value3];
      } else {
        target[name] = value3;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value3, target[name], index2);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  __name(buildPath, "buildPath");
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value3) => {
      buildPath(parsePropPath(name), value3, obj, 0);
    });
    return obj;
  }
  return null;
}
__name(formDataToJSON, "formDataToJSON");
"use strict";
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
__name(stringifySafely, "stringifySafely");
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [/* @__PURE__ */ __name(function transformRequest(data22, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data22);
    if (isObjectPayload && utils$1.isHTMLForm(data22)) {
      data22 = new FormData(data22);
    }
    const isFormData2 = utils$1.isFormData(data22);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data22)) : data22;
    }
    if (utils$1.isArrayBuffer(data22) || utils$1.isBuffer(data22) || utils$1.isStream(data22) || utils$1.isFile(data22) || utils$1.isBlob(data22) || utils$1.isReadableStream(data22)) {
      return data22;
    }
    if (utils$1.isArrayBufferView(data22)) {
      return data22.buffer;
    }
    if (utils$1.isURLSearchParams(data22)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data22.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data22, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data22)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data22 } : data22,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data22);
    }
    return data22;
  }, "transformRequest")],
  transformResponse: [/* @__PURE__ */ __name(function transformResponse(data22) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data22) || utils$1.isReadableStream(data22)) {
      return data22;
    }
    if (data22 && utils$1.isString(data22) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data22);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data22;
  }, "transformResponse")],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: /* @__PURE__ */ __name(function validateStatus(status) {
    return status >= 200 && status < 300;
  }, "validateStatus"),
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
"use strict";
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = /* @__PURE__ */ __name((rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(/* @__PURE__ */ __name(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  }, "parser"));
  return parsed;
}, "parseHeaders");
"use strict";
const $internals = Symbol("internals");
function normalizeHeader(header2) {
  return header2 && String(header2).trim().toLowerCase();
}
__name(normalizeHeader, "normalizeHeader");
function normalizeValue(value3) {
  if (value3 === false || value3 == null) {
    return value3;
  }
  return utils$1.isArray(value3) ? value3.map(normalizeValue) : String(value3);
}
__name(normalizeValue, "normalizeValue");
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
__name(parseTokens, "parseTokens");
const isValidHeaderName = /* @__PURE__ */ __name((str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim()), "isValidHeaderName");
function matchHeaderValue(context, value3, header2, filter4, isHeaderNameFilter) {
  if (utils$1.isFunction(filter4)) {
    return filter4.call(this, value3, header2);
  }
  if (isHeaderNameFilter) {
    value3 = header2;
  }
  if (!utils$1.isString(value3)) return;
  if (utils$1.isString(filter4)) {
    return value3.indexOf(filter4) !== -1;
  }
  if (utils$1.isRegExp(filter4)) {
    return filter4.test(value3);
  }
}
__name(matchHeaderValue, "matchHeaderValue");
function formatHeader(header2) {
  return header2.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
__name(formatHeader, "formatHeader");
function buildAccessors(obj, header2) {
  const accessorName = utils$1.toCamelCase(" " + header2);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: /* @__PURE__ */ __name(function(arg1, arg2, arg3) {
        return this[methodName].call(this, header2, arg1, arg2, arg3);
      }, "value"),
      configurable: true
    });
  });
}
__name(buildAccessors, "buildAccessors");
let AxiosHeaders$1 = class AxiosHeaders2 {
  static {
    __name(this, "AxiosHeaders");
  }
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header2, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    __name(setHeader, "setHeader");
    const setHeaders = /* @__PURE__ */ __name((headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite)), "setHeaders");
    if (utils$1.isPlainObject(header2) || header2 instanceof this.constructor) {
      setHeaders(header2, valueOrRewrite);
    } else if (utils$1.isString(header2) && (header2 = header2.trim()) && !isValidHeaderName(header2)) {
      setHeaders(parseHeaders(header2), valueOrRewrite);
    } else if (utils$1.isHeaders(header2)) {
      for (const [key, value3] of header2.entries()) {
        setHeader(value3, key, rewrite);
      }
    } else {
      header2 != null && setHeader(valueOrRewrite, header2, rewrite);
    }
    return this;
  }
  get(header2, parser) {
    header2 = normalizeHeader(header2);
    if (header2) {
      const key = utils$1.findKey(this, header2);
      if (key) {
        const value3 = this[key];
        if (!parser) {
          return value3;
        }
        if (parser === true) {
          return parseTokens(value3);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value3, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value3);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header2, matcher) {
    header2 = normalizeHeader(header2);
    if (header2) {
      const key = utils$1.findKey(this, header2);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header2, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    __name(deleteHeader, "deleteHeader");
    if (utils$1.isArray(header2)) {
      header2.forEach(deleteHeader);
    } else {
      deleteHeader(header2);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i2 = keys2.length;
    let deleted = false;
    while (i2--) {
      const key = keys2[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value3, header2) => {
      const key = utils$1.findKey(headers, header2);
      if (key) {
        self2[key] = normalizeValue(value3);
        delete self2[header2];
        return;
      }
      const normalized = format2 ? formatHeader(header2) : String(header2).trim();
      if (normalized !== header2) {
        delete self2[header2];
      }
      self2[normalized] = normalizeValue(value3);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value3, header2) => {
      value3 != null && value3 !== false && (obj[header2] = asStrings && utils$1.isArray(value3) ? value3.join(", ") : value3);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header2, value3]) => header2 + ": " + value3).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header2) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    __name(defineAccessor, "defineAccessor");
    utils$1.isArray(header2) ? header2.forEach(defineAccessor) : defineAccessor(header2);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value: value3 }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: /* @__PURE__ */ __name(() => value3, "get"),
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$1);
"use strict";
function transformData(fns, response) {
  const config2 = this || defaults$1;
  const context = response || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data22 = context.data;
  utils$1.forEach(fns, /* @__PURE__ */ __name(function transform2(fn) {
    data22 = fn.call(config2, data22, headers.normalize(), response ? response.status : void 0);
  }, "transform"));
  headers.normalize();
  return data22;
}
__name(transformData, "transformData");
"use strict";
function isCancel$1(value3) {
  return !!(value3 && value3.__CANCEL__);
}
__name(isCancel$1, "isCancel$1");
"use strict";
function CanceledError$1(message2, config2, request) {
  AxiosError$1.call(this, message2 == null ? "canceled" : message2, AxiosError$1.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
__name(CanceledError$1, "CanceledError$1");
utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
"use strict";
function settle(resolve2, reject2, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject2(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
__name(settle, "settle");
"use strict";
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
__name(parseProtocol, "parseProtocol");
"use strict";
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return /* @__PURE__ */ __name(function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  }, "push");
}
__name(speedometer, "speedometer");
function throttle(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke2 = /* @__PURE__ */ __name((args, now2 = Date.now()) => {
    timestamp2 = now2;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  }, "invoke");
  const throttled = /* @__PURE__ */ __name((...args) => {
    const now2 = Date.now();
    const passed = now2 - timestamp2;
    if (passed >= threshold) {
      invoke2(args, now2);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke2(lastArgs);
        }, threshold - passed);
      }
    }
  }, "throttled");
  const flush = /* @__PURE__ */ __name(() => lastArgs && invoke2(lastArgs), "flush");
  return [throttled, flush];
}
__name(throttle, "throttle");
const progressEventReducer = /* @__PURE__ */ __name((listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data22 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data22);
  }, freq);
}, "progressEventReducer");
const progressEventDecorator = /* @__PURE__ */ __name((total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}, "progressEventDecorator");
const asyncDecorator = /* @__PURE__ */ __name((fn) => (...args) => utils$1.asap(() => fn(...args)), "asyncDecorator");
"use strict";
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (/* @__PURE__ */ __name(function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    __name(resolveURL, "resolveURL");
    originURL = resolveURL(window.location.href);
    return /* @__PURE__ */ __name(function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    }, "isURLSameOrigin");
  }, "standardBrowserEnv"))()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  (/* @__PURE__ */ __name(function nonStandardBrowserEnv() {
    return /* @__PURE__ */ __name(function isURLSameOrigin2() {
      return true;
    }, "isURLSameOrigin");
  }, "nonStandardBrowserEnv"))()
);
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value3, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value3)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
"use strict";
function isAbsoluteURL$1(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
__name(isAbsoluteURL$1, "isAbsoluteURL$1");
"use strict";
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
__name(combineURLs, "combineURLs");
"use strict";
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL$1(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
__name(buildFullPath, "buildFullPath");
"use strict";
const headersToObject$1 = /* @__PURE__ */ __name((thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing, "headersToObject$1");
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  __name(getMergedValue, "getMergedValue");
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  __name(mergeDeepProperties, "mergeDeepProperties");
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  __name(valueFromConfig2, "valueFromConfig2");
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  __name(defaultToConfig2, "defaultToConfig2");
  function mergeDirectKeys(a, b, prop2) {
    if (prop2 in config2) {
      return getMergedValue(a, b);
    } else if (prop2 in config1) {
      return getMergedValue(void 0, a);
    }
  }
  __name(mergeDirectKeys, "mergeDirectKeys");
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: /* @__PURE__ */ __name((a, b) => mergeDeepProperties(headersToObject$1(a), headersToObject$1(b), true), "headers")
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), /* @__PURE__ */ __name(function computeConfigValue(prop2) {
    const merge2 = mergeMap[prop2] || mergeDeepProperties;
    const configValue = merge2(config1[prop2], config2[prop2], prop2);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop2] = configValue);
  }, "computeConfigValue"));
  return config3;
}
__name(mergeConfig$1, "mergeConfig$1");
const resolveConfig = /* @__PURE__ */ __name((config2) => {
  const newConfig = mergeConfig$1({}, config2);
  let { data: data22, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data22)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
}, "resolveConfig");
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(/* @__PURE__ */ __name(function dispatchXhrRequest(resolve2, reject2) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    __name(done, "done");
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(/* @__PURE__ */ __name(function _resolve(value3) {
        resolve2(value3);
        done();
      }, "_resolve"), /* @__PURE__ */ __name(function _reject(err) {
        reject2(err);
        done();
      }, "_reject"), response);
      request = null;
    }
    __name(onloadend, "onloadend");
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = /* @__PURE__ */ __name(function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      }, "handleLoad");
    }
    request.onabort = /* @__PURE__ */ __name(function handleAbort() {
      if (!request) {
        return;
      }
      reject2(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request));
      request = null;
    }, "handleAbort");
    request.onerror = /* @__PURE__ */ __name(function handleError2() {
      reject2(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request));
      request = null;
    }, "handleError");
    request.ontimeout = /* @__PURE__ */ __name(function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject2(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    }, "handleTimeout");
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), /* @__PURE__ */ __name(function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      }, "setRequestHeader"));
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = /* @__PURE__ */ __name((cancel) => {
        if (!request) {
          return;
        }
        reject2(!cancel || cancel.type ? new CanceledError$1(null, config2, request) : cancel);
        request.abort();
        request = null;
      }, "onCanceled");
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject2(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  }, "dispatchXhrRequest"));
};
const composeSignals = /* @__PURE__ */ __name((signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = /* @__PURE__ */ __name(function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
    }
  }, "onabort");
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
  }, timeout);
  const unsubscribe = /* @__PURE__ */ __name(() => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  }, "unsubscribe");
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
}, "composeSignals");
const streamChunk = /* @__PURE__ */ __name(function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos2 = 0;
  let end;
  while (pos2 < len) {
    end = pos2 + chunkSize;
    yield chunk.slice(pos2, end);
    pos2 = end;
  }
}, "streamChunk");
const readBytes = /* @__PURE__ */ __name(async function* (iterable, chunkSize, encode2) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
  }
}, "readBytes");
const trackStream = /* @__PURE__ */ __name((stream, chunkSize, onProgress, onFinish, encode2) => {
  const iterator = readBytes(stream, chunkSize, encode2);
  let bytes = 0;
  let done;
  let _onFinish = /* @__PURE__ */ __name((e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }, "_onFinish");
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value: value3 } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value3.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value3));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
}, "trackStream");
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = /* @__PURE__ */ __name((fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
}, "test");
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config2) => {
      throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
const getBodyLength = /* @__PURE__ */ __name(async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}, "getBodyLength");
const resolveBodyLength = /* @__PURE__ */ __name(async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
}, "resolveBodyLength");
const fetchAdapter = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data: data22,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = /* @__PURE__ */ __name(() => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  }, "onFinish");
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data22)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data22,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data22) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data22 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data22,
      duplex: "half",
      credentials: withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options3 = {};
      ["status", "statusText", "headers"].forEach((prop2) => {
        options3[prop2] = response[prop2];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          isStreamResponse && onFinish();
        }, encodeText),
        options3
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve2, reject2) => {
      settle(resolve2, reject2, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError$1.from(err, err && err.code, config2, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value3) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value: value3 });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value: value3 });
  }
});
const renderReason = /* @__PURE__ */ __name((reason) => `- ${reason}`, "renderReason");
const isResolvedHandle = /* @__PURE__ */ __name((adapter2) => utils$1.isFunction(adapter2) || adapter2 === null || adapter2 === false, "isResolvedHandle");
const adapters = {
  getAdapter: /* @__PURE__ */ __name((adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      let id3;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter2 = knownAdapters[(id3 = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id3}'`);
        }
      }
      if (adapter2) {
        break;
      }
      rejectedReasons[id3 || "#" + i2] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id3, state]) => `adapter ${id3} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  }, "getAdapter"),
  adapters: knownAdapters
};
"use strict";
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError$1(null, config2);
  }
}
__name(throwIfCancellationRequested, "throwIfCancellationRequested");
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter2(config2).then(/* @__PURE__ */ __name(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, "onAdapterResolution"), /* @__PURE__ */ __name(function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  }, "onAdapterRejection"));
}
__name(dispatchRequest, "dispatchRequest");
const VERSION$3 = "1.7.4";
"use strict";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = /* @__PURE__ */ __name(function validator3(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  }, "validator");
});
const deprecatedWarnings = {};
validators$1.transitional = /* @__PURE__ */ __name(function transitional(validator3, version2, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$3 + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  __name(formatMessage, "formatMessage");
  return (value3, opt, opts) => {
    if (validator3 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator3 ? validator3(value3, opt, opts) : true;
  };
}, "transitional");
function assertOptions(options3, schema, allowUnknown) {
  if (typeof options3 !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options3);
  let i2 = keys2.length;
  while (i2-- > 0) {
    const opt = keys2[i2];
    const validator3 = schema[opt];
    if (validator3) {
      const value3 = options3[opt];
      const result = value3 === void 0 || validator3(value3, opt, options3);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
__name(assertOptions, "assertOptions");
const validator = {
  assertOptions,
  validators: validators$1
};
"use strict";
const validators = validator.validators;
let Axios$1 = class Axios2 {
  static {
    __name(this, "Axios");
  }
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack2;
          } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack2;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig$1(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(/* @__PURE__ */ __name(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    }, "unshiftRequestInterceptors"));
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(/* @__PURE__ */ __name(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    }, "pushResponseInterceptors"));
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig$1(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], /* @__PURE__ */ __name(function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
}, "forEachMethodNoData"));
utils$1.forEach(["post", "put", "patch"], /* @__PURE__ */ __name(function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return /* @__PURE__ */ __name(function httpMethod(url, data22, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data22
      }));
    }, "httpMethod");
  }
  __name(generateHTTPMethod, "generateHTTPMethod");
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
}, "forEachMethodWithData"));
"use strict";
let CancelToken$1 = class CancelToken2 {
  static {
    __name(this, "CancelToken");
  }
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(/* @__PURE__ */ __name(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    }, "promiseExecutor"));
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = /* @__PURE__ */ __name(function reject2() {
        token.unsubscribe(_resolve);
      }, "reject");
      return promise;
    };
    executor(/* @__PURE__ */ __name(function cancel(message2, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message2, config2, request);
      resolvePromise(token.reason);
    }, "cancel"));
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken2(/* @__PURE__ */ __name(function executor(c) {
      cancel = c;
    }, "executor"));
    return {
      token,
      cancel
    };
  }
};
"use strict";
function spread$1(callback) {
  return /* @__PURE__ */ __name(function wrap(arr) {
    return callback.apply(null, arr);
  }, "wrap");
}
__name(spread$1, "spread$1");
"use strict";
function isAxiosError$1(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
__name(isAxiosError$1, "isAxiosError$1");
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value3]) => {
  HttpStatusCode$1[value3] = key;
});
"use strict";
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind$2(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = /* @__PURE__ */ __name(function create3(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  }, "create");
  return instance;
}
__name(createInstance, "createInstance");
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$3;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = /* @__PURE__ */ __name(function all2(promises) {
  return Promise.all(promises);
}, "all");
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken,
  VERSION: VERSION$2,
  all,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
class ComfyApi extends EventTarget {
  static {
    __name(this, "ComfyApi");
  }
  #registered = /* @__PURE__ */ new Set();
  api_host;
  api_base;
  /**
   * The client id from the initial session storage.
   */
  initialClientId;
  /**
   * The current client id from websocket status updates.
   */
  clientId;
  user;
  socket = null;
  reportedUnknownMessageTypes = /* @__PURE__ */ new Set();
  constructor() {
    super();
    this.user = "";
    this.api_host = location.host;
    this.api_base = location.pathname.split("/").slice(0, -1).join("/");
    console.log("Running on", this.api_host);
    this.initialClientId = sessionStorage.getItem("clientId");
  }
  internalURL(route) {
    return this.api_base + "/internal" + route;
  }
  apiURL(route) {
    return this.api_base + "/api" + route;
  }
  fileURL(route) {
    return this.api_base + route;
  }
  fetchApi(route, options3) {
    if (!options3) {
      options3 = {};
    }
    if (!options3.headers) {
      options3.headers = {};
    }
    if (!options3.cache) {
      options3.cache = "no-cache";
    }
    if (Array.isArray(options3.headers)) {
      options3.headers.push(["Comfy-User", this.user]);
    } else if (options3.headers instanceof Headers) {
      options3.headers.set("Comfy-User", this.user);
    } else {
      options3.headers["Comfy-User"] = this.user;
    }
    return fetch(this.apiURL(route), options3);
  }
  addEventListener(type, callback, options3) {
    super.addEventListener(type, callback, options3);
    this.#registered.add(type);
  }
  /**
   * Poll status  for colab and other things that don't support websockets.
   */
  #pollQueue() {
    setInterval(async () => {
      try {
        const resp = await this.fetchApi("/prompt");
        const status = await resp.json();
        this.dispatchEvent(new CustomEvent("status", { detail: status }));
      } catch (error) {
        this.dispatchEvent(new CustomEvent("status", { detail: null }));
      }
    }, 1e3);
  }
  /**
   * Creates and connects a WebSocket for realtime updates
   * @param {boolean} isReconnect If the socket is connection is a reconnect attempt
   */
  #createSocket(isReconnect) {
    if (this.socket) {
      return;
    }
    let opened = false;
    let existingSession = window.name;
    if (existingSession) {
      existingSession = "?clientId=" + existingSession;
    }
    this.socket = new WebSocket(
      `ws${window.location.protocol === "https:" ? "s" : ""}://${this.api_host}${this.api_base}/ws${existingSession}`
    );
    this.socket.binaryType = "arraybuffer";
    this.socket.addEventListener("open", () => {
      opened = true;
      if (isReconnect) {
        this.dispatchEvent(new CustomEvent("reconnected"));
      }
    });
    this.socket.addEventListener("error", () => {
      if (this.socket) this.socket.close();
      if (!isReconnect && !opened) {
        this.#pollQueue();
      }
    });
    this.socket.addEventListener("close", () => {
      setTimeout(() => {
        this.socket = null;
        this.#createSocket(true);
      }, 300);
      if (opened) {
        this.dispatchEvent(new CustomEvent("status", { detail: null }));
        this.dispatchEvent(new CustomEvent("reconnecting"));
      }
    });
    this.socket.addEventListener("message", (event2) => {
      try {
        if (event2.data instanceof ArrayBuffer) {
          const view = new DataView(event2.data);
          const eventType = view.getUint32(0);
          const buffer2 = event2.data.slice(4);
          switch (eventType) {
            case 1:
              const view2 = new DataView(event2.data);
              const imageType = view2.getUint32(0);
              let imageMime;
              switch (imageType) {
                case 1:
                default:
                  imageMime = "image/jpeg";
                  break;
                case 2:
                  imageMime = "image/png";
              }
              const imageBlob = new Blob([buffer2.slice(4)], {
                type: imageMime
              });
              this.dispatchEvent(
                new CustomEvent("b_preview", { detail: imageBlob })
              );
              break;
            default:
              throw new Error(
                `Unknown binary websocket message of type ${eventType}`
              );
          }
        } else {
          const msg = JSON.parse(event2.data);
          switch (msg.type) {
            case "status":
              if (msg.data.sid) {
                const clientId = msg.data.sid;
                this.clientId = clientId;
                window.name = clientId;
                sessionStorage.setItem("clientId", clientId);
              }
              this.dispatchEvent(
                new CustomEvent("status", { detail: msg.data.status })
              );
              break;
            case "executing":
              this.dispatchEvent(
                new CustomEvent("executing", {
                  detail: msg.data.display_node || msg.data.node
                })
              );
              break;
            case "progress":
            case "executed":
            case "execution_start":
            case "execution_success":
            case "execution_error":
            case "execution_cached":
            case "logs":
              this.dispatchEvent(
                new CustomEvent(msg.type, { detail: msg.data })
              );
              break;
            default:
              if (this.#registered.has(msg.type)) {
                this.dispatchEvent(
                  new CustomEvent(msg.type, { detail: msg.data })
                );
              } else if (!this.reportedUnknownMessageTypes.has(msg.type)) {
                this.reportedUnknownMessageTypes.add(msg.type);
                throw new Error(`Unknown message type ${msg.type}`);
              }
          }
        }
      } catch (error) {
        console.warn("Unhandled message:", event2.data, error);
      }
    });
  }
  /**
   * Initialises sockets and realtime updates
   */
  init() {
    this.#createSocket();
  }
  /**
   * Gets a list of extension urls
   */
  async getExtensions() {
    const resp = await this.fetchApi("/extensions", { cache: "no-store" });
    return await resp.json();
  }
  /**
   * Gets a list of embedding names
   */
  async getEmbeddings() {
    const resp = await this.fetchApi("/embeddings", { cache: "no-store" });
    return await resp.json();
  }
  /**
   * Loads node object definitions for the graph
   * @returns The node definitions
   */
  async getNodeDefs({ validate = false } = {}) {
    const resp = await this.fetchApi("/object_info", { cache: "no-store" });
    const objectInfoUnsafe = await resp.json();
    if (!validate) {
      return objectInfoUnsafe;
    }
    const objectInfo = {};
    for (const key in objectInfoUnsafe) {
      const validatedDef = validateComfyNodeDef(
        objectInfoUnsafe[key],
        /* onError=*/
        (errorMessage) => {
          console.warn(
            `Skipping invalid node definition: ${key}. See debug log for more information.`
          );
          console.debug(errorMessage);
        }
      );
      if (validatedDef !== null) {
        objectInfo[key] = validatedDef;
      }
    }
    return objectInfo;
  }
  /**
   *
   * @param {number} number The index at which to queue the prompt, passing -1 will insert the prompt at the front of the queue
   * @param {object} prompt The prompt data to queue
   */
  async queuePrompt(number2, {
    output,
    workflow
  }) {
    const body = {
      client_id: this.clientId ?? "",
      // TODO: Unify clientId access
      prompt: output,
      extra_data: { extra_pnginfo: { workflow } }
    };
    if (number2 === -1) {
      body.front = true;
    } else if (number2 != 0) {
      body.number = number2;
    }
    const res = await this.fetchApi("/prompt", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if (res.status !== 200) {
      throw {
        response: await res.json()
      };
    }
    return await res.json();
  }
  /**
   * Gets a list of model folder keys (eg ['checkpoints', 'loras', ...])
   * @returns The list of model folder keys
   */
  async getModelFolders() {
    const res = await this.fetchApi(`/models`);
    if (res.status === 404) {
      return [];
    }
    const folderBlacklist = ["configs", "custom_nodes"];
    return (await res.json()).filter(
      (folder) => !folderBlacklist.includes(folder)
    );
  }
  /**
   * Gets a list of models in the specified folder
   * @param {string} folder The folder to list models from, such as 'checkpoints'
   * @returns The list of model filenames within the specified folder
   */
  async getModels(folder) {
    const res = await this.fetchApi(`/models/${folder}`);
    if (res.status === 404) {
      return [];
    }
    return await res.json();
  }
  /**
   * Gets the metadata for a model
   * @param {string} folder The folder containing the model
   * @param {string} model The model to get metadata for
   * @returns The metadata for the model
   */
  async viewMetadata(folder, model) {
    const res = await this.fetchApi(
      `/view_metadata/${folder}?filename=${encodeURIComponent(model)}`
    );
    const rawResponse = await res.text();
    if (!rawResponse) {
      return null;
    }
    try {
      return JSON.parse(rawResponse);
    } catch (error) {
      console.error(
        "Error viewing metadata",
        res.status,
        res.statusText,
        rawResponse,
        error
      );
      return null;
    }
  }
  /**
   * Loads a list of items (queue or history)
   * @param {string} type The type of items to load, queue or history
   * @returns The items of the specified type grouped by their status
   */
  async getItems(type) {
    if (type === "queue") {
      return this.getQueue();
    }
    return this.getHistory();
  }
  /**
   * Gets the current state of the queue
   * @returns The currently running and queued items
   */
  async getQueue() {
    try {
      const res = await this.fetchApi("/queue");
      const data22 = await res.json();
      return {
        // Running action uses a different endpoint for cancelling
        Running: data22.queue_running.map((prompt) => ({
          taskType: "Running",
          prompt,
          remove: { name: "Cancel", cb: /* @__PURE__ */ __name(() => api.interrupt(), "cb") }
        })),
        Pending: data22.queue_pending.map((prompt) => ({
          taskType: "Pending",
          prompt
        }))
      };
    } catch (error) {
      console.error(error);
      return { Running: [], Pending: [] };
    }
  }
  /**
   * Gets the prompt execution history
   * @returns Prompt history including node outputs
   */
  async getHistory(max_items = 200) {
    try {
      const res = await this.fetchApi(`/history?max_items=${max_items}`);
      const json = await res.json();
      return {
        History: Object.values(json).map((item2) => ({
          ...item2,
          taskType: "History"
        }))
      };
    } catch (error) {
      console.error(error);
      return { History: [] };
    }
  }
  /**
   * Gets system & device stats
   * @returns System stats such as python version, OS, per device info
   */
  async getSystemStats() {
    const res = await this.fetchApi("/system_stats");
    return await res.json();
  }
  /**
   * Sends a POST request to the API
   * @param {*} type The endpoint to post to
   * @param {*} body Optional POST data
   */
  async #postItem(type, body) {
    try {
      await this.fetchApi("/" + type, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: body ? JSON.stringify(body) : void 0
      });
    } catch (error) {
      console.error(error);
    }
  }
  /**
   * Deletes an item from the specified list
   * @param {string} type The type of item to delete, queue or history
   * @param {number} id The id of the item to delete
   */
  async deleteItem(type, id3) {
    await this.#postItem(type, { delete: [id3] });
  }
  /**
   * Clears the specified list
   * @param {string} type The type of list to clear, queue or history
   */
  async clearItems(type) {
    await this.#postItem(type, { clear: true });
  }
  /**
   * Interrupts the execution of the running prompt
   */
  async interrupt() {
    await this.#postItem("interrupt", null);
  }
  /**
   * Gets user configuration data and where data should be stored
   */
  async getUserConfig() {
    return (await this.fetchApi("/users")).json();
  }
  /**
   * Creates a new user
   * @param { string } username
   * @returns The fetch response
   */
  createUser(username) {
    return this.fetchApi("/users", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ username })
    });
  }
  /**
   * Gets all setting values for the current user
   * @returns { Promise<string, unknown> } A dictionary of id -> value
   */
  async getSettings() {
    return (await this.fetchApi("/settings")).json();
  }
  /**
   * Gets a setting for the current user
   * @param { string } id The id of the setting to fetch
   * @returns { Promise<unknown> } The setting value
   */
  async getSetting(id3) {
    return (await this.fetchApi(`/settings/${encodeURIComponent(id3)}`)).json();
  }
  /**
   * Stores a dictionary of settings for the current user
   */
  async storeSettings(settings) {
    return this.fetchApi(`/settings`, {
      method: "POST",
      body: JSON.stringify(settings)
    });
  }
  /**
   * Stores a setting for the current user
   */
  async storeSetting(id3, value3) {
    return this.fetchApi(`/settings/${encodeURIComponent(id3)}`, {
      method: "POST",
      body: JSON.stringify(value3)
    });
  }
  /**
   * Gets a user data file for the current user
   */
  async getUserData(file, options3) {
    return this.fetchApi(`/userdata/${encodeURIComponent(file)}`, options3);
  }
  /**
   * Stores a user data file for the current user
   * @param { string } file The name of the userdata file to save
   * @param { unknown } data The data to save to the file
   * @param { RequestInit & { stringify?: boolean, throwOnError?: boolean } } [options]
   * @returns { Promise<Response> }
   */
  async storeUserData(file, data22, options3 = {
    overwrite: true,
    stringify: true,
    throwOnError: true,
    full_info: false
  }) {
    const resp = await this.fetchApi(
      `/userdata/${encodeURIComponent(file)}?overwrite=${options3.overwrite}&full_info=${options3.full_info}`,
      {
        method: "POST",
        body: options3?.stringify ? JSON.stringify(data22) : data22,
        ...options3
      }
    );
    if (resp.status !== 200 && options3.throwOnError !== false) {
      throw new Error(
        `Error storing user data file '${file}': ${resp.status} ${(await resp).statusText}`
      );
    }
    return resp;
  }
  /**
   * Deletes a user data file for the current user
   * @param { string } file The name of the userdata file to delete
   */
  async deleteUserData(file) {
    const resp = await this.fetchApi(`/userdata/${encodeURIComponent(file)}`, {
      method: "DELETE"
    });
    return resp;
  }
  /**
   * Move a user data file for the current user
   * @param { string } source The userdata file to move
   * @param { string } dest The destination for the file
   */
  async moveUserData(source, dest, options3 = { overwrite: false }) {
    const resp = await this.fetchApi(
      `/userdata/${encodeURIComponent(source)}/move/${encodeURIComponent(dest)}?overwrite=${options3?.overwrite}`,
      {
        method: "POST"
      }
    );
    return resp;
  }
  /**
   * @deprecated Use `listUserDataFullInfo` instead.
   */
  async listUserData(dir, recurse, split) {
    const resp = await this.fetchApi(
      `/userdata?${new URLSearchParams({
        recurse: recurse ? "true" : "false",
        dir,
        split: split ? "true" : "false"
      })}`
    );
    if (resp.status === 404) return [];
    if (resp.status !== 200) {
      throw new Error(
        `Error getting user data list '${dir}': ${resp.status} ${resp.statusText}`
      );
    }
    return resp.json();
  }
  async listUserDataFullInfo(dir) {
    const resp = await this.fetchApi(
      `/userdata?dir=${encodeURIComponent(dir)}&recurse=true&split=false&full_info=true`
    );
    if (resp.status === 404) return [];
    if (resp.status !== 200) {
      throw new Error(
        `Error getting user data list '${dir}': ${resp.status} ${resp.statusText}`
      );
    }
    return resp.json();
  }
  async getLogs() {
    return (await axios.get(this.internalURL("/logs"))).data;
  }
  async getRawLogs() {
    return (await axios.get(this.internalURL("/logs/raw"))).data;
  }
  async subscribeLogs(enabled) {
    return await axios.patch(this.internalURL("/logs/subscribe"), {
      enabled,
      clientId: this.clientId
    });
  }
  async getFolderPaths() {
    return (await axios.get(this.internalURL("/folder_paths"))).data;
  }
}
const api = new ComfyApi();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.api = window.comfyAPI.api || {};
window.comfyAPI.api.api = api;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
function getDefaultExportFromNamespaceIfPresent(n) {
  return n && Object.prototype.hasOwnProperty.call(n, "default") ? n["default"] : n;
}
__name(getDefaultExportFromNamespaceIfPresent, "getDefaultExportFromNamespaceIfPresent");
function getDefaultExportFromNamespaceIfNotNamed(n) {
  return n && Object.prototype.hasOwnProperty.call(n, "default") && Object.keys(n).length === 1 ? n["default"] : n;
}
__name(getDefaultExportFromNamespaceIfNotNamed, "getDefaultExportFromNamespaceIfNotNamed");
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = /* @__PURE__ */ __name(function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    }, "a");
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return n[k];
      }, "get")
    });
  });
  return a;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;
(function(module, exports) {
  ;
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root23 = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply2, "apply");
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value3 = array[index2];
        setter(accumulator, value3, iteratee(value3), array);
      }
      return accumulator;
    }
    __name(arrayAggregator, "arrayAggregator");
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEach, "arrayEach");
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEachRight, "arrayEachRight");
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    __name(arrayEvery, "arrayEvery");
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value3 = array[index2];
        if (predicate(value3, index2, array)) {
          result[resIndex++] = value3;
        }
      }
      return result;
    }
    __name(arrayFilter, "arrayFilter");
    function arrayIncludes(array, value3) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value3, 0) > -1;
    }
    __name(arrayIncludes, "arrayIncludes");
    function arrayIncludesWith(array, value3, comparator2) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator2(value3, array[index2])) {
          return true;
        }
      }
      return false;
    }
    __name(arrayIncludesWith, "arrayIncludesWith");
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function arrayPush(array, values2) {
      var index2 = -1, length = values2.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values2[index2];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    __name(arrayReduceRight, "arrayReduceRight");
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    __name(asciiToArray, "asciiToArray");
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    __name(asciiWords, "asciiWords");
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value3, key, collection2) {
        if (predicate(value3, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    __name(baseFindKey, "baseFindKey");
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    function baseIndexOf(array, value3, fromIndex) {
      return value3 === value3 ? strictIndexOf(array, value3, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    __name(baseIndexOf, "baseIndexOf");
    function baseIndexOfWith(array, value3, fromIndex, comparator2) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator2(array[index2], value3)) {
          return index2;
        }
      }
      return -1;
    }
    __name(baseIndexOfWith, "baseIndexOfWith");
    function baseIsNaN(value3) {
      return value3 !== value3;
    }
    __name(baseIsNaN, "baseIsNaN");
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    __name(baseMean, "baseMean");
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    __name(baseProperty, "baseProperty");
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    __name(basePropertyOf, "basePropertyOf");
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value3, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value3) : iteratee(accumulator, value3, index2, collection2);
      });
      return accumulator;
    }
    __name(baseReduce, "baseReduce");
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    __name(baseSortBy, "baseSortBy");
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    __name(baseSum, "baseSum");
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    __name(baseToPairs, "baseToPairs");
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    __name(baseTrim, "baseTrim");
    function baseUnary(func) {
      return function(value3) {
        return func(value3);
      };
    }
    __name(baseUnary, "baseUnary");
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    __name(baseValues, "baseValues");
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    __name(cacheHas, "cacheHas");
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    __name(charsStartIndex, "charsStartIndex");
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    __name(charsEndIndex, "charsEndIndex");
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    __name(countHolders, "countHolders");
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    __name(escapeStringChar, "escapeStringChar");
    function getValue2(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    __name(getValue2, "getValue");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    __name(hasUnicode, "hasUnicode");
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    __name(hasUnicodeWord, "hasUnicodeWord");
    function iteratorToArray(iterator) {
      var data22, result = [];
      while (!(data22 = iterator.next()).done) {
        result.push(data22.value);
      }
      return result;
    }
    __name(iteratorToArray, "iteratorToArray");
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value3, key) {
        result[++index2] = [key, value3];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    __name(overArg, "overArg");
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value3 = array[index2];
        if (value3 === placeholder || value3 === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    __name(replaceHolders, "replaceHolders");
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value3) {
        result[++index2] = value3;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value3) {
        result[++index2] = [value3, value3];
      });
      return result;
    }
    __name(setToPairs, "setToPairs");
    function strictIndexOf(array, value3, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value3) {
          return index2;
        }
      }
      return -1;
    }
    __name(strictIndexOf, "strictIndexOf");
    function strictLastIndexOf(array, value3, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value3) {
          return index2;
        }
      }
      return index2;
    }
    __name(strictLastIndexOf, "strictLastIndexOf");
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    __name(stringSize, "stringSize");
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    __name(stringToArray, "stringToArray");
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    __name(trimmedEndIndex, "trimmedEndIndex");
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    __name(unicodeSize, "unicodeSize");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    __name(unicodeToArray, "unicodeToArray");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    __name(unicodeWords, "unicodeWords");
    var runInContext = /* @__PURE__ */ __name(function runInContext2(context) {
      context = context == null ? root23 : _2.defaults(root23.Object(), context, _2.pick(root23, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root23._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root23.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root23.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root23.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value3) {
        if (isObjectLike2(value3) && !isArray2(value3) && !(value3 instanceof LazyWrapper)) {
          if (value3 instanceof LodashWrapper) {
            return value3;
          }
          if (hasOwnProperty2.call(value3, "__wrapped__")) {
            return wrapperClone(value3);
          }
        }
        return new LodashWrapper(value3);
      }
      __name(lodash2, "lodash");
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        __name(object, "object");
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      __name(baseLodash, "baseLodash");
      function LodashWrapper(value3, chainAll) {
        this.__wrapped__ = value3;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      __name(LodashWrapper, "LodashWrapper");
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value3) {
        this.__wrapped__ = value3;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      __name(LazyWrapper, "LazyWrapper");
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      __name(lazyClone, "lazyClone");
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      __name(lazyReverse, "lazyReverse");
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value3 = array[index2];
            while (++iterIndex < iterLength) {
              var data22 = iteratees[iterIndex], iteratee2 = data22.iteratee, type = data22.type, computed2 = iteratee2(value3);
              if (type == LAZY_MAP_FLAG) {
                value3 = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value3;
          }
        return result2;
      }
      __name(lazyValue, "lazyValue");
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(Hash, "Hash");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      __name(hashClear, "hashClear");
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      __name(hashDelete, "hashDelete");
      function hashGet(key) {
        var data22 = this.__data__;
        if (nativeCreate) {
          var result2 = data22[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data22, key) ? data22[key] : undefined$1;
      }
      __name(hashGet, "hashGet");
      function hashHas(key) {
        var data22 = this.__data__;
        return nativeCreate ? data22[key] !== undefined$1 : hasOwnProperty2.call(data22, key);
      }
      __name(hashHas, "hashHas");
      function hashSet(key, value3) {
        var data22 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data22[key] = nativeCreate && value3 === undefined$1 ? HASH_UNDEFINED : value3;
        return this;
      }
      __name(hashSet, "hashSet");
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(ListCache, "ListCache");
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      __name(listCacheClear, "listCacheClear");
      function listCacheDelete(key) {
        var data22 = this.__data__, index2 = assocIndexOf(data22, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data22.length - 1;
        if (index2 == lastIndex) {
          data22.pop();
        } else {
          splice.call(data22, index2, 1);
        }
        --this.size;
        return true;
      }
      __name(listCacheDelete, "listCacheDelete");
      function listCacheGet(key) {
        var data22 = this.__data__, index2 = assocIndexOf(data22, key);
        return index2 < 0 ? undefined$1 : data22[index2][1];
      }
      __name(listCacheGet, "listCacheGet");
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      __name(listCacheHas, "listCacheHas");
      function listCacheSet(key, value3) {
        var data22 = this.__data__, index2 = assocIndexOf(data22, key);
        if (index2 < 0) {
          ++this.size;
          data22.push([key, value3]);
        } else {
          data22[index2][1] = value3;
        }
        return this;
      }
      __name(listCacheSet, "listCacheSet");
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(MapCache, "MapCache");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      __name(mapCacheClear, "mapCacheClear");
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      __name(mapCacheDelete, "mapCacheDelete");
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      __name(mapCacheGet, "mapCacheGet");
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      __name(mapCacheHas, "mapCacheHas");
      function mapCacheSet(key, value3) {
        var data22 = getMapData(this, key), size3 = data22.size;
        data22.set(key, value3);
        this.size += data22.size == size3 ? 0 : 1;
        return this;
      }
      __name(mapCacheSet, "mapCacheSet");
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values3) {
        var index2 = -1, length = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values3[index2]);
        }
      }
      __name(SetCache, "SetCache");
      function setCacheAdd(value3) {
        this.__data__.set(value3, HASH_UNDEFINED);
        return this;
      }
      __name(setCacheAdd, "setCacheAdd");
      function setCacheHas(value3) {
        return this.__data__.has(value3);
      }
      __name(setCacheHas, "setCacheHas");
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data22 = this.__data__ = new ListCache(entries);
        this.size = data22.size;
      }
      __name(Stack, "Stack");
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      __name(stackClear, "stackClear");
      function stackDelete(key) {
        var data22 = this.__data__, result2 = data22["delete"](key);
        this.size = data22.size;
        return result2;
      }
      __name(stackDelete, "stackDelete");
      function stackGet(key) {
        return this.__data__.get(key);
      }
      __name(stackGet, "stackGet");
      function stackHas(key) {
        return this.__data__.has(key);
      }
      __name(stackHas, "stackHas");
      function stackSet(key, value3) {
        var data22 = this.__data__;
        if (data22 instanceof ListCache) {
          var pairs = data22.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value3]);
            this.size = ++data22.size;
            return this;
          }
          data22 = this.__data__ = new MapCache(pairs);
        }
        data22.set(key, value3);
        this.size = data22.size;
        return this;
      }
      __name(stackSet, "stackSet");
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value3, inherited) {
        var isArr = isArray2(value3), isArg = !isArr && isArguments(value3), isBuff = !isArr && !isArg && isBuffer2(value3), isType = !isArr && !isArg && !isBuff && isTypedArray2(value3), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value3.length, String2) : [], length = result2.length;
        for (var key in value3) {
          if ((inherited || hasOwnProperty2.call(value3, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      __name(arrayLikeKeys, "arrayLikeKeys");
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      __name(arraySample, "arraySample");
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      __name(arraySampleSize, "arraySampleSize");
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      __name(arrayShuffle, "arrayShuffle");
      function assignMergeValue(object, key, value3) {
        if (value3 !== undefined$1 && !eq(object[key], value3) || value3 === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value3);
        }
      }
      __name(assignMergeValue, "assignMergeValue");
      function assignValue(object, key, value3) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value3)) || value3 === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value3);
        }
      }
      __name(assignValue, "assignValue");
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      __name(assocIndexOf, "assocIndexOf");
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value3, key, collection2) {
          setter(accumulator, value3, iteratee2(value3), collection2);
        });
        return accumulator;
      }
      __name(baseAggregator, "baseAggregator");
      function baseAssign(object, source) {
        return object && copyObject(source, keys2(source), object);
      }
      __name(baseAssign, "baseAssign");
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      __name(baseAssignIn, "baseAssignIn");
      function baseAssignValue(object, key, value3) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value3,
            "writable": true
          });
        } else {
          object[key] = value3;
        }
      }
      __name(baseAssignValue, "baseAssignValue");
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
        }
        return result2;
      }
      __name(baseAt, "baseAt");
      function baseClamp(number2, lower, upper) {
        if (number2 === number2) {
          if (upper !== undefined$1) {
            number2 = number2 <= upper ? number2 : upper;
          }
          if (lower !== undefined$1) {
            number2 = number2 >= lower ? number2 : lower;
          }
        }
        return number2;
      }
      __name(baseClamp, "baseClamp");
      function baseClone(value3, bitmask, customizer, key, object, stack2) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value3, key, object, stack2) : customizer(value3);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value3)) {
          return value3;
        }
        var isArr = isArray2(value3);
        if (isArr) {
          result2 = initCloneArray(value3);
          if (!isDeep) {
            return copyArray(value3, result2);
          }
        } else {
          var tag = getTag2(value3), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer2(value3)) {
            return cloneBuffer(value3, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value3);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value3, baseAssignIn(result2, value3)) : copySymbols(value3, baseAssign(result2, value3));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value3 : {};
            }
            result2 = initCloneByTag(value3, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack());
        var stacked = stack2.get(value3);
        if (stacked) {
          return stacked;
        }
        stack2.set(value3, result2);
        if (isSet2(value3)) {
          value3.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value3, stack2));
          });
        } else if (isMap2(value3)) {
          value3.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value3, stack2));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value3);
        arrayEach(props || value3, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value3[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value3, stack2));
        });
        return result2;
      }
      __name(baseClone, "baseClone");
      function baseConforms(source) {
        var props = keys2(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      __name(baseConforms, "baseConforms");
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value3 = object[key];
          if (value3 === undefined$1 && !(key in object) || !predicate(value3)) {
            return false;
          }
        }
        return true;
      }
      __name(baseConformsTo, "baseConformsTo");
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      __name(baseDelay, "baseDelay");
      function baseDifference(array, values3, iteratee2, comparator2) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values3 = arrayMap(values3, baseUnary(iteratee2));
        }
        if (comparator2) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values3 = new SetCache(values3);
        }
        outer:
          while (++index2 < length) {
            var value3 = array[index2], computed2 = iteratee2 == null ? value3 : iteratee2(value3);
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value3);
            } else if (!includes2(values3, computed2, comparator2)) {
              result2.push(value3);
            }
          }
        return result2;
      }
      __name(baseDifference, "baseDifference");
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value3, index2, collection2) {
          result2 = !!predicate(value3, index2, collection2);
          return result2;
        });
        return result2;
      }
      __name(baseEvery, "baseEvery");
      function baseExtremum(array, iteratee2, comparator2) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value3 = array[index2], current = iteratee2(value3);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator2(current, computed2))) {
            var computed2 = current, result2 = value3;
          }
        }
        return result2;
      }
      __name(baseExtremum, "baseExtremum");
      function baseFill(array, value3, start2, end) {
        var length = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start2 > end ? 0 : toLength(end);
        while (start2 < end) {
          array[start2++] = value3;
        }
        return array;
      }
      __name(baseFill, "baseFill");
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value3, index2, collection2) {
          if (predicate(value3, index2, collection2)) {
            result2.push(value3);
          }
        });
        return result2;
      }
      __name(baseFilter, "baseFilter");
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value3 = array[index2];
          if (depth > 0 && predicate(value3)) {
            if (depth > 1) {
              baseFlatten(value3, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value3);
            }
          } else if (!isStrict) {
            result2[result2.length] = value3;
          }
        }
        return result2;
      }
      __name(baseFlatten, "baseFlatten");
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      __name(baseForOwn, "baseForOwn");
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      __name(baseForOwnRight, "baseForOwnRight");
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      __name(baseFunctions, "baseFunctions");
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      __name(baseGet, "baseGet");
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      __name(baseGetAllKeys, "baseGetAllKeys");
      function baseGetTag(value3) {
        if (value3 == null) {
          return value3 === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value3) ? getRawTag(value3) : objectToString2(value3);
      }
      __name(baseGetTag, "baseGetTag");
      function baseGt(value3, other) {
        return value3 > other;
      }
      __name(baseGt, "baseGt");
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      __name(baseHas, "baseHas");
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      __name(baseHasIn, "baseHasIn");
      function baseInRange(number2, start2, end) {
        return number2 >= nativeMin(start2, end) && number2 < nativeMax(start2, end);
      }
      __name(baseInRange, "baseInRange");
      function baseIntersection(arrays, iteratee2, comparator2) {
        var includes2 = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator2 && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen2 = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (!(seen2 ? cacheHas(seen2, computed2) : includes2(result2, computed2, comparator2))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator2))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            }
          }
        return result2;
      }
      __name(baseIntersection, "baseIntersection");
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value3, key, object2) {
          setter(accumulator, iteratee2(value3), key, object2);
        });
        return accumulator;
      }
      __name(baseInverter, "baseInverter");
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply2(func, object, args);
      }
      __name(baseInvoke, "baseInvoke");
      function baseIsArguments(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == argsTag;
      }
      __name(baseIsArguments, "baseIsArguments");
      function baseIsArrayBuffer(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == arrayBufferTag;
      }
      __name(baseIsArrayBuffer, "baseIsArrayBuffer");
      function baseIsDate(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == dateTag;
      }
      __name(baseIsDate, "baseIsDate");
      function baseIsEqual(value3, other, bitmask, customizer, stack2) {
        if (value3 === other) {
          return true;
        }
        if (value3 == null || other == null || !isObjectLike2(value3) && !isObjectLike2(other)) {
          return value3 !== value3 && other !== other;
        }
        return baseIsEqualDeep(value3, other, bitmask, customizer, baseIsEqual, stack2);
      }
      __name(baseIsEqual, "baseIsEqual");
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      __name(baseIsEqualDeep, "baseIsEqualDeep");
      function baseIsMap(value3) {
        return isObjectLike2(value3) && getTag2(value3) == mapTag;
      }
      __name(baseIsMap, "baseIsMap");
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data22 = matchData[index2];
          if (noCustomizer && data22[2] ? data22[1] !== object[data22[0]] : !(data22[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data22 = matchData[index2];
          var key = data22[0], objValue = object[key], srcValue = data22[1];
          if (noCustomizer && data22[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack2);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      __name(baseIsMatch, "baseIsMatch");
      function baseIsNative(value3) {
        if (!isObject2(value3) || isMasked(value3)) {
          return false;
        }
        var pattern = isFunction2(value3) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value3));
      }
      __name(baseIsNative, "baseIsNative");
      function baseIsRegExp(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == regexpTag;
      }
      __name(baseIsRegExp, "baseIsRegExp");
      function baseIsSet(value3) {
        return isObjectLike2(value3) && getTag2(value3) == setTag;
      }
      __name(baseIsSet, "baseIsSet");
      function baseIsTypedArray(value3) {
        return isObjectLike2(value3) && isLength(value3.length) && !!typedArrayTags[baseGetTag(value3)];
      }
      __name(baseIsTypedArray, "baseIsTypedArray");
      function baseIteratee(value3) {
        if (typeof value3 == "function") {
          return value3;
        }
        if (value3 == null) {
          return identity2;
        }
        if (typeof value3 == "object") {
          return isArray2(value3) ? baseMatchesProperty(value3[0], value3[1]) : baseMatches(value3);
        }
        return property(value3);
      }
      __name(baseIteratee, "baseIteratee");
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      __name(baseKeys, "baseKeys");
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      __name(baseKeysIn, "baseKeysIn");
      function baseLt(value3, other) {
        return value3 < other;
      }
      __name(baseLt, "baseLt");
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value3, key, collection2) {
          result2[++index2] = iteratee2(value3, key, collection2);
        });
        return result2;
      }
      __name(baseMap, "baseMap");
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      __name(baseMatches, "baseMatches");
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      __name(baseMatchesProperty, "baseMatchesProperty");
      function baseMerge(object, source, srcIndex, customizer, stack2) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack2 || (stack2 = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      __name(baseMerge, "baseMerge");
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      __name(baseMergeDeep, "baseMergeDeep");
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      __name(baseNth, "baseNth");
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value3) {
                return baseGet(value3, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value3, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value3);
          });
          return { "criteria": criteria, "index": ++index2, "value": value3 };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      __name(baseOrderBy, "baseOrderBy");
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value3, path) {
          return hasIn(object, path);
        });
      }
      __name(basePick, "basePick");
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value3 = baseGet(object, path);
          if (predicate(value3, path)) {
            baseSet(result2, castPath(path, object), value3);
          }
        }
        return result2;
      }
      __name(basePickBy, "basePickBy");
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      __name(basePropertyDeep, "basePropertyDeep");
      function basePullAll(array, values3, iteratee2, comparator2) {
        var indexOf2 = comparator2 ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values3.length, seen2 = array;
        if (array === values3) {
          values3 = copyArray(values3);
        }
        if (iteratee2) {
          seen2 = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value3 = values3[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
          while ((fromIndex = indexOf2(seen2, computed2, fromIndex, comparator2)) > -1) {
            if (seen2 !== array) {
              splice.call(seen2, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      __name(basePullAll, "basePullAll");
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      __name(basePullAt, "basePullAt");
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      __name(baseRandom, "baseRandom");
      function baseRange(start2, end, step2, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start2) / (step2 || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start2;
          start2 += step2;
        }
        return result2;
      }
      __name(baseRange, "baseRange");
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      __name(baseRepeat, "baseRepeat");
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity2), func + "");
      }
      __name(baseRest, "baseRest");
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      __name(baseSample, "baseSample");
      function baseSampleSize(collection, n) {
        var array = values2(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      __name(baseSampleSize, "baseSampleSize");
      function baseSet(object, path, value3, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value3;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      __name(baseSet, "baseSet");
      var baseSetData = !metaMap ? identity2 : function(func, data22) {
        metaMap.set(func, data22);
        return func;
      };
      var baseSetToString = !defineProperty ? identity2 : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      __name(baseShuffle, "baseShuffle");
      function baseSlice(array, start2, end) {
        var index2 = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start2 > end ? 0 : end - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start2];
        }
        return result2;
      }
      __name(baseSlice, "baseSlice");
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value3, index2, collection2) {
          result2 = predicate(value3, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      __name(baseSome, "baseSome");
      function baseSortedIndex(array, value3, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value3 == "number" && value3 === value3 && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value3 : computed2 < value3)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value3, identity2, retHighest);
      }
      __name(baseSortedIndex, "baseSortedIndex");
      function baseSortedIndexBy(array, value3, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value3 = iteratee2(value3);
        var valIsNaN = value3 !== value3, valIsNull = value3 === null, valIsSymbol = isSymbol2(value3), valIsUndefined = value3 === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value3 : computed2 < value3;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      __name(baseSortedIndexBy, "baseSortedIndexBy");
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
          if (!index2 || !eq(computed2, seen2)) {
            var seen2 = computed2;
            result2[resIndex++] = value3 === 0 ? 0 : value3;
          }
        }
        return result2;
      }
      __name(baseSortedUniq, "baseSortedUniq");
      function baseToNumber(value3) {
        if (typeof value3 == "number") {
          return value3;
        }
        if (isSymbol2(value3)) {
          return NAN;
        }
        return +value3;
      }
      __name(baseToNumber, "baseToNumber");
      function baseToString2(value3) {
        if (typeof value3 == "string") {
          return value3;
        }
        if (isArray2(value3)) {
          return arrayMap(value3, baseToString2) + "";
        }
        if (isSymbol2(value3)) {
          return symbolToString ? symbolToString.call(value3) : "";
        }
        var result2 = value3 + "";
        return result2 == "0" && 1 / value3 == -INFINITY2 ? "-0" : result2;
      }
      __name(baseToString2, "baseToString");
      function baseUniq(array, iteratee2, comparator2) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen2 = result2;
        if (comparator2) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen2 = new SetCache();
        } else {
          seen2 = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            } else if (!includes2(seen2, computed2, comparator2)) {
              if (seen2 !== result2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            }
          }
        return result2;
      }
      __name(baseUniq, "baseUniq");
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      __name(baseUnset, "baseUnset");
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      __name(baseUpdate, "baseUpdate");
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      __name(baseWhile, "baseWhile");
      function baseWrapperValue(value3, actions) {
        var result2 = value3;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      __name(baseWrapperValue, "baseWrapperValue");
      function baseXor(arrays, iteratee2, comparator2) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator2);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator2);
      }
      __name(baseXor, "baseXor");
      function baseZipObject(props, values3, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values3.length, result2 = {};
        while (++index2 < length) {
          var value3 = index2 < valsLength ? values3[index2] : undefined$1;
          assignFunc(result2, props[index2], value3);
        }
        return result2;
      }
      __name(baseZipObject, "baseZipObject");
      function castArrayLikeObject(value3) {
        return isArrayLikeObject(value3) ? value3 : [];
      }
      __name(castArrayLikeObject, "castArrayLikeObject");
      function castFunction(value3) {
        return typeof value3 == "function" ? value3 : identity2;
      }
      __name(castFunction, "castFunction");
      function castPath(value3, object) {
        if (isArray2(value3)) {
          return value3;
        }
        return isKey(value3, object) ? [value3] : stringToPath(toString3(value3));
      }
      __name(castPath, "castPath");
      var castRest = baseRest;
      function castSlice(array, start2, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start2 && end >= length ? array : baseSlice(array, start2, end);
      }
      __name(castSlice, "castSlice");
      var clearTimeout2 = ctxClearTimeout || function(id3) {
        return root23.clearTimeout(id3);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      __name(cloneBuffer, "cloneBuffer");
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      __name(cloneArrayBuffer, "cloneArrayBuffer");
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      __name(cloneDataView, "cloneDataView");
      function cloneRegExp2(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      __name(cloneRegExp2, "cloneRegExp");
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      __name(cloneSymbol, "cloneSymbol");
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      __name(cloneTypedArray, "cloneTypedArray");
      function compareAscending(value3, other) {
        if (value3 !== other) {
          var valIsDefined = value3 !== undefined$1, valIsNull = value3 === null, valIsReflexive = value3 === value3, valIsSymbol = isSymbol2(value3);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value3 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value3 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      __name(compareAscending, "compareAscending");
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      __name(compareMultiple, "compareMultiple");
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      __name(composeArgs, "composeArgs");
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      __name(composeArgsRight, "composeArgsRight");
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      __name(copyArray, "copyArray");
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      __name(copyObject, "copyObject");
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      __name(copySymbols, "copySymbols");
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      __name(copySymbolsIn, "copySymbolsIn");
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      __name(createAggregator, "createAggregator");
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      __name(createAssigner, "createAssigner");
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      __name(createBaseEach, "createBaseEach");
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      __name(createBaseFor, "createBaseFor");
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root23 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        __name(wrapper, "wrapper");
        return wrapper;
      }
      __name(createBind, "createBind");
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString3(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      __name(createCaseFirst, "createCaseFirst");
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      __name(createCompounder, "createCompounder");
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      __name(createCtor, "createCtor");
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn = this && this !== root23 && this instanceof wrapper ? Ctor : func;
          return apply2(fn, this, args);
        }
        __name(wrapper, "wrapper");
        return wrapper;
      }
      __name(createCurry, "createCurry");
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = /* @__PURE__ */ __name(function(key) {
              return iteratee2(iterable[key], key, iterable);
            }, "predicate");
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      __name(createFind, "createFind");
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data22 = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data22 && isLaziable(data22[0]) && data22[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data22[4].length && data22[9] == 1) {
              wrapper = wrapper[getFuncName(data22[0])].apply(wrapper, data22[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value3 = args[0];
            if (wrapper && args.length == 1 && isArray2(value3)) {
              return wrapper.plant(value3).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value3;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      __name(createFlow, "createFlow");
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root23 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        __name(wrapper, "wrapper");
        return wrapper;
      }
      __name(createHybrid, "createHybrid");
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      __name(createInverter, "createInverter");
      function createMathOperation(operator, defaultValue) {
        return function(value3, other) {
          var result2;
          if (value3 === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value3 !== undefined$1) {
            result2 = value3;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value3 == "string" || typeof other == "string") {
              value3 = baseToString2(value3);
              other = baseToString2(other);
            } else {
              value3 = baseToNumber(value3);
              other = baseToNumber(other);
            }
            result2 = operator(value3, other);
          }
          return result2;
        };
      }
      __name(createMathOperation, "createMathOperation");
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args);
            });
          });
        });
      }
      __name(createOver, "createOver");
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      __name(createPadding, "createPadding");
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root23 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn, isBind ? thisArg : this, args);
        }
        __name(wrapper, "wrapper");
        return wrapper;
      }
      __name(createPartial, "createPartial");
      function createRange(fromRight) {
        return function(start2, end, step2) {
          if (step2 && typeof step2 != "number" && isIterateeCall(start2, end, step2)) {
            end = step2 = undefined$1;
          }
          start2 = toFinite(start2);
          if (end === undefined$1) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          step2 = step2 === undefined$1 ? start2 < end ? 1 : -1 : toFinite(step2);
          return baseRange(start2, end, step2, fromRight);
        };
      }
      __name(createRange, "createRange");
      function createRelationalOperation(operator) {
        return function(value3, other) {
          if (!(typeof value3 == "string" && typeof other == "string")) {
            value3 = toNumber2(value3);
            other = toNumber2(other);
          }
          return operator(value3, other);
        };
      }
      __name(createRelationalOperation, "createRelationalOperation");
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      __name(createRecurry, "createRecurry");
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber2(number2);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString3(number2) + "e").split("e"), value3 = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString3(value3) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      __name(createRound, "createRound");
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values3) {
        return new Set2(values3);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag2(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      __name(createToPairs, "createToPairs");
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data22 = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data22) {
          mergeData(newData, data22);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data22 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      __name(createWrap, "createWrap");
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      __name(customDefaultsAssignIn, "customDefaultsAssignIn");
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack2.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2);
          stack2["delete"](srcValue);
        }
        return objValue;
      }
      __name(customDefaultsMerge, "customDefaultsMerge");
      function customOmitClone(value3) {
        return isPlainObject2(value3) ? undefined$1 : value3;
      }
      __name(customOmitClone, "customOmitClone");
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack2.set(array, other);
        stack2.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen2.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result2 = false;
            break;
          }
        }
        stack2["delete"](array);
        stack2["delete"](other);
        return result2;
      }
      __name(equalArrays, "equalArrays");
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack2.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      __name(equalByTag, "equalByTag");
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result2;
      }
      __name(equalObjects, "equalObjects");
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      __name(flatRest, "flatRest");
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      __name(getAllKeys, "getAllKeys");
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      __name(getAllKeysIn, "getAllKeysIn");
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data22 = array[length], otherFunc = data22.func;
          if (otherFunc == null || otherFunc == func) {
            return data22.name;
          }
        }
        return result2;
      }
      __name(getFuncName, "getFuncName");
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      __name(getHolder, "getHolder");
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      __name(getIteratee, "getIteratee");
      function getMapData(map3, key) {
        var data22 = map3.__data__;
        return isKeyable(key) ? data22[typeof key == "string" ? "string" : "hash"] : data22.map;
      }
      __name(getMapData, "getMapData");
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value3 = object[key];
          result2[length] = [key, value3, isStrictComparable(value3)];
        }
        return result2;
      }
      __name(getMatchData, "getMatchData");
      function getNative(object, key) {
        var value3 = getValue2(object, key);
        return baseIsNative(value3) ? value3 : undefined$1;
      }
      __name(getNative, "getNative");
      function getRawTag(value3) {
        var isOwn = hasOwnProperty2.call(value3, symToStringTag), tag = value3[symToStringTag];
        try {
          value3[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value3);
        if (unmasked) {
          if (isOwn) {
            value3[symToStringTag] = tag;
          } else {
            delete value3[symToStringTag];
          }
        }
        return result2;
      }
      __name(getRawTag, "getRawTag");
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag2 = baseGetTag;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
        getTag2 = /* @__PURE__ */ __name(function(value3) {
          var result2 = baseGetTag(value3), Ctor = result2 == objectTag ? value3.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        }, "getTag");
      }
      function getView(start2, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data22 = transforms[index2], size3 = data22.size;
          switch (data22.type) {
            case "drop":
              start2 += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin(end, start2 + size3);
              break;
            case "takeRight":
              start2 = nativeMax(start2, end - size3);
              break;
          }
        }
        return { "start": start2, "end": end };
      }
      __name(getView, "getView");
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      __name(getWrapDetails, "getWrapDetails");
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      __name(hasPath, "hasPath");
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      __name(initCloneArray, "initCloneArray");
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      __name(initCloneObject, "initCloneObject");
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp2(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      __name(initCloneByTag, "initCloneByTag");
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      __name(insertWrapDetails, "insertWrapDetails");
      function isFlattenable(value3) {
        return isArray2(value3) || isArguments(value3) || !!(spreadableSymbol && value3 && value3[spreadableSymbol]);
      }
      __name(isFlattenable, "isFlattenable");
      function isIndex(value3, length) {
        var type = typeof value3;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value3)) && (value3 > -1 && value3 % 1 == 0 && value3 < length);
      }
      __name(isIndex, "isIndex");
      function isIterateeCall(value3, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value3);
        }
        return false;
      }
      __name(isIterateeCall, "isIterateeCall");
      function isKey(value3, object) {
        if (isArray2(value3)) {
          return false;
        }
        var type = typeof value3;
        if (type == "number" || type == "symbol" || type == "boolean" || value3 == null || isSymbol2(value3)) {
          return true;
        }
        return reIsPlainProp.test(value3) || !reIsDeepProp.test(value3) || object != null && value3 in Object2(object);
      }
      __name(isKey, "isKey");
      function isKeyable(value3) {
        var type = typeof value3;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value3 !== "__proto__" : value3 === null;
      }
      __name(isKeyable, "isKeyable");
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data22 = getData(other);
        return !!data22 && func === data22[0];
      }
      __name(isLaziable, "isLaziable");
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      __name(isMasked, "isMasked");
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value3) {
        var Ctor = value3 && value3.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value3 === proto;
      }
      __name(isPrototype, "isPrototype");
      function isStrictComparable(value3) {
        return value3 === value3 && !isObject2(value3);
      }
      __name(isStrictComparable, "isStrictComparable");
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      __name(matchesStrictComparable, "matchesStrictComparable");
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      __name(memoizeCapped, "memoizeCapped");
      function mergeData(data22, source) {
        var bitmask = data22[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data22[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data22;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data22[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value3 = source[3];
        if (value3) {
          var partials = data22[3];
          data22[3] = partials ? composeArgs(partials, value3, source[4]) : value3;
          data22[4] = partials ? replaceHolders(data22[3], PLACEHOLDER) : source[4];
        }
        value3 = source[5];
        if (value3) {
          partials = data22[5];
          data22[5] = partials ? composeArgsRight(partials, value3, source[6]) : value3;
          data22[6] = partials ? replaceHolders(data22[5], PLACEHOLDER) : source[6];
        }
        value3 = source[7];
        if (value3) {
          data22[7] = value3;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data22[8] = data22[8] == null ? source[8] : nativeMin(data22[8], source[8]);
        }
        if (data22[9] == null) {
          data22[9] = source[9];
        }
        data22[0] = source[0];
        data22[1] = newBitmask;
        return data22;
      }
      __name(mergeData, "mergeData");
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      __name(nativeKeysIn, "nativeKeysIn");
      function objectToString2(value3) {
        return nativeObjectToString.call(value3);
      }
      __name(objectToString2, "objectToString");
      function overRest(func, start2, transform3) {
        start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform3(array);
          return apply2(func, this, otherArgs);
        };
      }
      __name(overRest, "overRest");
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      __name(parent, "parent");
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      __name(reorder, "reorder");
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      __name(safeGet, "safeGet");
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root23.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      __name(setWrapToString, "setWrapToString");
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      __name(shortOut, "shortOut");
      function shuffleSelf(array, size3) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size3 = size3 === undefined$1 ? length : size3;
        while (++index2 < size3) {
          var rand2 = baseRandom(index2, lastIndex), value3 = array[rand2];
          array[rand2] = array[index2];
          array[index2] = value3;
        }
        array.length = size3;
        return array;
      }
      __name(shuffleSelf, "shuffleSelf");
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
        });
        return result2;
      });
      function toKey(value3) {
        if (typeof value3 == "string" || isSymbol2(value3)) {
          return value3;
        }
        var result2 = value3 + "";
        return result2 == "0" && 1 / value3 == -INFINITY2 ? "-0" : result2;
      }
      __name(toKey, "toKey");
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      __name(toSource, "toSource");
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value3 = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value3)) {
            details.push(value3);
          }
        });
        return details.sort();
      }
      __name(updateWrapDetails, "updateWrapDetails");
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      __name(wrapperClone, "wrapperClone");
      function chunk(array, size3, guard) {
        if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined$1) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger(size3), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size3);
        }
        return result2;
      }
      __name(chunk, "chunk");
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value3 = array[index2];
          if (value3) {
            result2[resIndex++] = value3;
          }
        }
        return result2;
      }
      __name(compact, "compact");
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      __name(concat, "concat");
      var difference = baseRest(function(array, values3) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values3) {
        var iteratee2 = last(values3);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values3) {
        var comparator2 = last(values3);
        if (isArrayLikeObject(comparator2)) {
          comparator2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined$1, comparator2) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      __name(drop, "drop");
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      __name(dropRight, "dropRight");
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      __name(dropRightWhile, "dropRightWhile");
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      __name(dropWhile, "dropWhile");
      function fill(array, value3, start2, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array, value3, start2)) {
          start2 = 0;
          end = length;
        }
        return baseFill(array, value3, start2, end);
      }
      __name(fill, "fill");
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      __name(findIndex, "findIndex");
      function findLastIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      __name(findLastIndex2, "findLastIndex");
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      __name(flatten, "flatten");
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY2) : [];
      }
      __name(flattenDeep, "flattenDeep");
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      __name(flattenDepth, "flattenDepth");
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      __name(fromPairs, "fromPairs");
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      __name(head, "head");
      function indexOf(array, value3, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value3, index2);
      }
      __name(indexOf, "indexOf");
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      __name(initial, "initial");
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        if (comparator2) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator2) : [];
      });
      function join2(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      __name(join2, "join");
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      __name(last, "last");
      function lastIndexOf(array, value3, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value3 === value3 ? strictLastIndexOf(array, value3, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      __name(lastIndexOf, "lastIndexOf");
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      __name(nth, "nth");
      var pull = baseRest(pullAll);
      function pullAll(array, values3) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
      }
      __name(pullAll, "pullAll");
      function pullAllBy(array, values3, iteratee2) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
      }
      __name(pullAllBy, "pullAllBy");
      function pullAllWith(array, values3, comparator2) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined$1, comparator2) : array;
      }
      __name(pullAllWith, "pullAllWith");
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove4(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value3 = array[index2];
          if (predicate(value3, index2, array)) {
            result2.push(value3);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      __name(remove4, "remove");
      function reverse2(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      __name(reverse2, "reverse");
      function slice(array, start2, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
          start2 = 0;
          end = length;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start2, end);
      }
      __name(slice, "slice");
      function sortedIndex(array, value3) {
        return baseSortedIndex(array, value3);
      }
      __name(sortedIndex, "sortedIndex");
      function sortedIndexBy(array, value3, iteratee2) {
        return baseSortedIndexBy(array, value3, getIteratee(iteratee2, 2));
      }
      __name(sortedIndexBy, "sortedIndexBy");
      function sortedIndexOf(array, value3) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value3);
          if (index2 < length && eq(array[index2], value3)) {
            return index2;
          }
        }
        return -1;
      }
      __name(sortedIndexOf, "sortedIndexOf");
      function sortedLastIndex(array, value3) {
        return baseSortedIndex(array, value3, true);
      }
      __name(sortedLastIndex, "sortedLastIndex");
      function sortedLastIndexBy(array, value3, iteratee2) {
        return baseSortedIndexBy(array, value3, getIteratee(iteratee2, 2), true);
      }
      __name(sortedLastIndexBy, "sortedLastIndexBy");
      function sortedLastIndexOf(array, value3) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value3, true) - 1;
          if (eq(array[index2], value3)) {
            return index2;
          }
        }
        return -1;
      }
      __name(sortedLastIndexOf, "sortedLastIndexOf");
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      __name(sortedUniq, "sortedUniq");
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      __name(sortedUniqBy, "sortedUniqBy");
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      __name(tail, "tail");
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      __name(take, "take");
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      __name(takeRight, "takeRight");
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      __name(takeRightWhile, "takeRightWhile");
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      __name(takeWhile, "takeWhile");
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator2);
      });
      function uniq2(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      __name(uniq2, "uniq");
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      __name(uniqBy, "uniqBy");
      function uniqWith(array, comparator2) {
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator2) : [];
      }
      __name(uniqWith, "uniqWith");
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      __name(unzip, "unzip");
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply2(iteratee2, undefined$1, group);
        });
      }
      __name(unzipWith, "unzipWith");
      var without = baseRest(function(array, values3) {
        return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator2);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values3) {
        return baseZipObject(props || [], values3 || [], assignValue);
      }
      __name(zipObject, "zipObject");
      function zipObjectDeep(props, values3) {
        return baseZipObject(props || [], values3 || [], baseSet);
      }
      __name(zipObjectDeep, "zipObjectDeep");
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value3) {
        var result2 = lodash2(value3);
        result2.__chain__ = true;
        return result2;
      }
      __name(chain, "chain");
      function tap(value3, interceptor) {
        interceptor(value3);
        return value3;
      }
      __name(tap, "tap");
      function thru(value3, interceptor) {
        return interceptor(value3);
      }
      __name(thru, "thru");
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value3 = this.__wrapped__, interceptor = /* @__PURE__ */ __name(function(object) {
          return baseAt(object, paths);
        }, "interceptor");
        if (length > 1 || this.__actions__.length || !(value3 instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value3 = value3.slice(start2, +start2 + (length ? 1 : 0));
        value3.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value3, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      __name(wrapperChain, "wrapperChain");
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      __name(wrapperCommit, "wrapperCommit");
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value3 = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value3 };
      }
      __name(wrapperNext, "wrapperNext");
      function wrapperToIterator() {
        return this;
      }
      __name(wrapperToIterator, "wrapperToIterator");
      function wrapperPlant(value3) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value3;
        return result2;
      }
      __name(wrapperPlant, "wrapperPlant");
      function wrapperReverse() {
        var value3 = this.__wrapped__;
        if (value3 instanceof LazyWrapper) {
          var wrapped = value3;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse2],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse2);
      }
      __name(wrapperReverse, "wrapperReverse");
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      __name(wrapperValue, "wrapperValue");
      var countBy = createAggregator(function(result2, value3, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      __name(every, "every");
      function filter4(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      __name(filter4, "filter");
      var find2 = createFind(findIndex);
      var findLast2 = createFind(findLastIndex2);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      __name(flatMap, "flatMap");
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY2);
      }
      __name(flatMapDeep, "flatMapDeep");
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      __name(flatMapDepth, "flatMapDepth");
      function forEach2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(forEach2, "forEach");
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(forEachRight, "forEachRight");
      var groupBy = createAggregator(function(result2, value3, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value3);
        } else {
          baseAssignValue(result2, key, [value3]);
        }
      });
      function includes(collection, value3, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value3, fromIndex) > -1 : !!length && baseIndexOf(collection, value3, fromIndex) > -1;
      }
      __name(includes, "includes");
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value3) {
          result2[++index2] = isFunc ? apply2(path, value3, args) : baseInvoke(value3, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value3, key) {
        baseAssignValue(result2, key, value3);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      __name(map2, "map");
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      __name(orderBy, "orderBy");
      var partition = createAggregator(function(result2, value3, key) {
        result2[key ? 0 : 1].push(value3);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      __name(reduce, "reduce");
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      __name(reduceRight, "reduceRight");
      function reject2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      __name(reject2, "reject");
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      __name(sample, "sample");
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      __name(sampleSize, "sampleSize");
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      __name(shuffle, "shuffle");
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      __name(size2, "size");
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      __name(some, "some");
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root23.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      __name(after, "after");
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      __name(ary, "ary");
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      __name(before, "before");
      var bind3 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind3));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      __name(curry, "curry");
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      __name(curryRight, "curryRight");
      function debounce(func, wait, options3) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options3)) {
          leading = !!options3.leading;
          maxing = "maxWait" in options3;
          maxWait = maxing ? nativeMax(toNumber2(options3.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options3 ? !!options3.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        __name(invokeFunc, "invokeFunc");
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        __name(leadingEdge, "leadingEdge");
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        __name(remainingWait, "remainingWait");
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        __name(shouldInvoke, "shouldInvoke");
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        __name(timerExpired, "timerExpired");
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        __name(trailingEdge, "trailingEdge");
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        __name(cancel, "cancel");
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        __name(flush, "flush");
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        __name(debounced, "debounced");
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      __name(debounce, "debounce");
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      __name(flip, "flip");
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = /* @__PURE__ */ __name(function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        }, "memoized");
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      __name(memoize, "memoize");
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      __name(negate, "negate");
      function once2(func) {
        return before(2, func);
      }
      __name(once2, "once");
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply2(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      __name(rest, "rest");
      function spread2(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
        return baseRest(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply2(func, this, otherArgs);
        });
      }
      __name(spread2, "spread");
      function throttle2(func, wait, options3) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options3)) {
          leading = "leading" in options3 ? !!options3.leading : leading;
          trailing = "trailing" in options3 ? !!options3.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      __name(throttle2, "throttle");
      function unary(func) {
        return ary(func, 1);
      }
      __name(unary, "unary");
      function wrap(value3, wrapper) {
        return partial(castFunction(wrapper), value3);
      }
      __name(wrap, "wrap");
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value3 = arguments[0];
        return isArray2(value3) ? value3 : [value3];
      }
      __name(castArray, "castArray");
      function clone2(value3) {
        return baseClone(value3, CLONE_SYMBOLS_FLAG);
      }
      __name(clone2, "clone");
      function cloneWith(value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value3, CLONE_SYMBOLS_FLAG, customizer);
      }
      __name(cloneWith, "cloneWith");
      function cloneDeep(value3) {
        return baseClone(value3, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      __name(cloneDeep, "cloneDeep");
      function cloneDeepWith(value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value3, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      __name(cloneDeepWith, "cloneDeepWith");
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys2(source));
      }
      __name(conformsTo, "conformsTo");
      function eq(value3, other) {
        return value3 === other || value3 !== value3 && other !== other;
      }
      __name(eq, "eq");
      var gt2 = createRelationalOperation(baseGt);
      var gte2 = createRelationalOperation(function(value3, other) {
        return value3 >= other;
      });
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value3) {
        return isObjectLike2(value3) && hasOwnProperty2.call(value3, "callee") && !propertyIsEnumerable.call(value3, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value3) {
        return value3 != null && isLength(value3.length) && !isFunction2(value3);
      }
      __name(isArrayLike, "isArrayLike");
      function isArrayLikeObject(value3) {
        return isObjectLike2(value3) && isArrayLike(value3);
      }
      __name(isArrayLikeObject, "isArrayLikeObject");
      function isBoolean2(value3) {
        return value3 === true || value3 === false || isObjectLike2(value3) && baseGetTag(value3) == boolTag;
      }
      __name(isBoolean2, "isBoolean");
      var isBuffer2 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value3) {
        return isObjectLike2(value3) && value3.nodeType === 1 && !isPlainObject2(value3);
      }
      __name(isElement2, "isElement");
      function isEmpty2(value3) {
        if (value3 == null) {
          return true;
        }
        if (isArrayLike(value3) && (isArray2(value3) || typeof value3 == "string" || typeof value3.splice == "function" || isBuffer2(value3) || isTypedArray2(value3) || isArguments(value3))) {
          return !value3.length;
        }
        var tag = getTag2(value3);
        if (tag == mapTag || tag == setTag) {
          return !value3.size;
        }
        if (isPrototype(value3)) {
          return !baseKeys(value3).length;
        }
        for (var key in value3) {
          if (hasOwnProperty2.call(value3, key)) {
            return false;
          }
        }
        return true;
      }
      __name(isEmpty2, "isEmpty");
      function isEqual(value3, other) {
        return baseIsEqual(value3, other);
      }
      __name(isEqual, "isEqual");
      function isEqualWith(value3, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value3, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value3, other, undefined$1, customizer) : !!result2;
      }
      __name(isEqualWith, "isEqualWith");
      function isError(value3) {
        if (!isObjectLike2(value3)) {
          return false;
        }
        var tag = baseGetTag(value3);
        return tag == errorTag || tag == domExcTag || typeof value3.message == "string" && typeof value3.name == "string" && !isPlainObject2(value3);
      }
      __name(isError, "isError");
      function isFinite2(value3) {
        return typeof value3 == "number" && nativeIsFinite(value3);
      }
      __name(isFinite2, "isFinite");
      function isFunction2(value3) {
        if (!isObject2(value3)) {
          return false;
        }
        var tag = baseGetTag(value3);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      __name(isFunction2, "isFunction");
      function isInteger(value3) {
        return typeof value3 == "number" && value3 == toInteger(value3);
      }
      __name(isInteger, "isInteger");
      function isLength(value3) {
        return typeof value3 == "number" && value3 > -1 && value3 % 1 == 0 && value3 <= MAX_SAFE_INTEGER;
      }
      __name(isLength, "isLength");
      function isObject2(value3) {
        var type = typeof value3;
        return value3 != null && (type == "object" || type == "function");
      }
      __name(isObject2, "isObject");
      function isObjectLike2(value3) {
        return value3 != null && typeof value3 == "object";
      }
      __name(isObjectLike2, "isObjectLike");
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      __name(isMatch, "isMatch");
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      __name(isMatchWith, "isMatchWith");
      function isNaN2(value3) {
        return isNumber2(value3) && value3 != +value3;
      }
      __name(isNaN2, "isNaN");
      function isNative(value3) {
        if (isMaskable(value3)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value3);
      }
      __name(isNative, "isNative");
      function isNull(value3) {
        return value3 === null;
      }
      __name(isNull, "isNull");
      function isNil(value3) {
        return value3 == null;
      }
      __name(isNil, "isNil");
      function isNumber2(value3) {
        return typeof value3 == "number" || isObjectLike2(value3) && baseGetTag(value3) == numberTag;
      }
      __name(isNumber2, "isNumber");
      function isPlainObject2(value3) {
        if (!isObjectLike2(value3) || baseGetTag(value3) != objectTag) {
          return false;
        }
        var proto = getPrototype(value3);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      __name(isPlainObject2, "isPlainObject");
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value3) {
        return isInteger(value3) && value3 >= -MAX_SAFE_INTEGER && value3 <= MAX_SAFE_INTEGER;
      }
      __name(isSafeInteger, "isSafeInteger");
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value3) {
        return typeof value3 == "string" || !isArray2(value3) && isObjectLike2(value3) && baseGetTag(value3) == stringTag;
      }
      __name(isString2, "isString");
      function isSymbol2(value3) {
        return typeof value3 == "symbol" || isObjectLike2(value3) && baseGetTag(value3) == symbolTag;
      }
      __name(isSymbol2, "isSymbol");
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value3) {
        return value3 === undefined$1;
      }
      __name(isUndefined2, "isUndefined");
      function isWeakMap(value3) {
        return isObjectLike2(value3) && getTag2(value3) == weakMapTag;
      }
      __name(isWeakMap, "isWeakMap");
      function isWeakSet(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == weakSetTag;
      }
      __name(isWeakSet, "isWeakSet");
      var lt2 = createRelationalOperation(baseLt);
      var lte2 = createRelationalOperation(function(value3, other) {
        return value3 <= other;
      });
      function toArray2(value3) {
        if (!value3) {
          return [];
        }
        if (isArrayLike(value3)) {
          return isString2(value3) ? stringToArray(value3) : copyArray(value3);
        }
        if (symIterator && value3[symIterator]) {
          return iteratorToArray(value3[symIterator]());
        }
        var tag = getTag2(value3), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
        return func(value3);
      }
      __name(toArray2, "toArray");
      function toFinite(value3) {
        if (!value3) {
          return value3 === 0 ? value3 : 0;
        }
        value3 = toNumber2(value3);
        if (value3 === INFINITY2 || value3 === -INFINITY2) {
          var sign = value3 < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value3 === value3 ? value3 : 0;
      }
      __name(toFinite, "toFinite");
      function toInteger(value3) {
        var result2 = toFinite(value3), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      __name(toInteger, "toInteger");
      function toLength(value3) {
        return value3 ? baseClamp(toInteger(value3), 0, MAX_ARRAY_LENGTH) : 0;
      }
      __name(toLength, "toLength");
      function toNumber2(value3) {
        if (typeof value3 == "number") {
          return value3;
        }
        if (isSymbol2(value3)) {
          return NAN;
        }
        if (isObject2(value3)) {
          var other = typeof value3.valueOf == "function" ? value3.valueOf() : value3;
          value3 = isObject2(other) ? other + "" : other;
        }
        if (typeof value3 != "string") {
          return value3 === 0 ? value3 : +value3;
        }
        value3 = baseTrim(value3);
        var isBinary = reIsBinary.test(value3);
        return isBinary || reIsOctal.test(value3) ? freeParseInt(value3.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value3) ? NAN : +value3;
      }
      __name(toNumber2, "toNumber");
      function toPlainObject(value3) {
        return copyObject(value3, keysIn(value3));
      }
      __name(toPlainObject, "toPlainObject");
      function toSafeInteger(value3) {
        return value3 ? baseClamp(toInteger(value3), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value3 === 0 ? value3 : 0;
      }
      __name(toSafeInteger, "toSafeInteger");
      function toString3(value3) {
        return value3 == null ? "" : baseToString2(value3);
      }
      __name(toString3, "toString");
      var assign2 = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys2(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create3(prototype2, properties) {
        var result2 = baseCreate(prototype2);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      __name(create3, "create");
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value3 = object[key];
            if (value3 === undefined$1 || eq(value3, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply2(mergeWith, undefined$1, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      __name(findKey2, "findKey");
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      __name(findLastKey, "findLastKey");
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      __name(forIn, "forIn");
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      __name(forInRight, "forInRight");
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      __name(forOwn, "forOwn");
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      __name(forOwnRight, "forOwnRight");
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      __name(functions, "functions");
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      __name(functionsIn, "functionsIn");
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      __name(get2, "get");
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      __name(has2, "has");
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      __name(hasIn, "hasIn");
      var invert = createInverter(function(result2, value3, key) {
        if (value3 != null && typeof value3.toString != "function") {
          value3 = nativeObjectToString.call(value3);
        }
        result2[value3] = key;
      }, constant(identity2));
      var invertBy = createInverter(function(result2, value3, key) {
        if (value3 != null && typeof value3.toString != "function") {
          value3 = nativeObjectToString.call(value3);
        }
        if (hasOwnProperty2.call(result2, value3)) {
          result2[value3].push(key);
        } else {
          result2[value3] = [key];
        }
      }, getIteratee);
      var invoke2 = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      __name(keys2, "keys");
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      __name(keysIn, "keysIn");
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value3, key, object2) {
          baseAssignValue(result2, iteratee2(value3, key, object2), value3);
        });
        return result2;
      }
      __name(mapKeys, "mapKeys");
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value3, key, object2) {
          baseAssignValue(result2, key, iteratee2(value3, key, object2));
        });
        return result2;
      }
      __name(mapValues, "mapValues");
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      __name(omitBy, "omitBy");
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop2) {
          return [prop2];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value3, path) {
          return predicate(value3, path[0]);
        });
      }
      __name(pickBy, "pickBy");
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value3 = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value3 === undefined$1) {
            index2 = length;
            value3 = defaultValue;
          }
          object = isFunction2(value3) ? value3.call(object) : value3;
        }
        return object;
      }
      __name(result, "result");
      function set2(object, path, value3) {
        return object == null ? object : baseSet(object, path, value3);
      }
      __name(set2, "set");
      function setWith(object, path, value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value3, customizer);
      }
      __name(setWith, "setWith");
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value3, index2, object2) {
          return iteratee2(accumulator, value3, index2, object2);
        });
        return accumulator;
      }
      __name(transform2, "transform");
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      __name(unset, "unset");
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      __name(update, "update");
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      __name(updateWith, "updateWith");
      function values2(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      __name(values2, "values");
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      __name(valuesIn, "valuesIn");
      function clamp2(number2, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number2), lower, upper);
      }
      __name(clamp2, "clamp");
      function inRange(number2, start2, end) {
        start2 = toFinite(start2);
        if (end === undefined$1) {
          end = start2;
          start2 = 0;
        } else {
          end = toFinite(end);
        }
        number2 = toNumber2(number2);
        return baseInRange(number2, start2, end);
      }
      __name(inRange, "inRange");
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand2 = nativeRandom();
          return nativeMin(lower + rand2 * (upper - lower + freeParseFloat("1e-" + ((rand2 + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      __name(random, "random");
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string) {
        return upperFirst(toString3(string).toLowerCase());
      }
      __name(capitalize2, "capitalize");
      function deburr(string) {
        string = toString3(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      __name(deburr, "deburr");
      function endsWith3(string, target, position2) {
        string = toString3(string);
        target = baseToString2(target);
        var length = string.length;
        position2 = position2 === undefined$1 ? length : baseClamp(toInteger(position2), 0, length);
        var end = position2;
        position2 -= target.length;
        return position2 >= 0 && string.slice(position2, end) == target;
      }
      __name(endsWith3, "endsWith");
      function escape2(string) {
        string = toString3(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      __name(escape2, "escape");
      function escapeRegExp2(string) {
        string = toString3(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      __name(escapeRegExp2, "escapeRegExp");
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      __name(pad, "pad");
      function padEnd(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      __name(padEnd, "padEnd");
      function padStart(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      __name(padStart, "padStart");
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
      }
      __name(parseInt2, "parseInt");
      function repeat3(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString3(string), n);
      }
      __name(repeat3, "repeat");
      function replace() {
        var args = arguments, string = toString3(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      __name(replace, "replace");
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString3(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString2(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      __name(split, "split");
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith2(string, target, position2) {
        string = toString3(string);
        position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string.length);
        target = baseToString2(target);
        return string.slice(position2, position2 + target.length) == target;
      }
      __name(startsWith2, "startsWith");
      function template(string, options3, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options3, guard)) {
          options3 = undefined$1;
        }
        string = toString3(string);
        options3 = assignInWith({}, options3, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options3.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options3.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options3.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options3.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options3, "sourceURL") ? (options3.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options3, "variable") && options3.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      __name(template, "template");
      function toLower(value3) {
        return toString3(value3).toLowerCase();
      }
      __name(toLower, "toLower");
      function toUpper(value3) {
        return toString3(value3).toUpperCase();
      }
      __name(toUpper, "toUpper");
      function trim2(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end).join("");
      }
      __name(trim2, "trim");
      function trimEnd(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      __name(trimEnd, "trimEnd");
      function trimStart(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      __name(trimStart, "trimStart");
      function truncate(string, options3) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options3)) {
          var separator = "separator" in options3 ? options3.separator : separator;
          length = "length" in options3 ? toInteger(options3.length) : length;
          omission = "omission" in options3 ? baseToString2(options3.omission) : omission;
        }
        string = toString3(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString2(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      __name(truncate, "truncate");
      function unescape2(string) {
        string = toString3(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      __name(unescape2, "unescape");
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString3(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      __name(words, "words");
      var attempt = baseRest(function(func, args) {
        try {
          return apply2(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll2 = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind3(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply2(pair[0], this, args)) {
              return apply2(pair[1], this, args);
            }
          }
        });
      }
      __name(cond, "cond");
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      __name(conforms, "conforms");
      function constant(value3) {
        return function() {
          return value3;
        };
      }
      __name(constant, "constant");
      function defaultTo(value3, defaultValue) {
        return value3 == null || value3 !== value3 ? defaultValue : value3;
      }
      __name(defaultTo, "defaultTo");
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value3) {
        return value3;
      }
      __name(identity2, "identity");
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      __name(iteratee, "iteratee");
      function matches2(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      __name(matches2, "matches");
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      __name(matchesProperty, "matchesProperty");
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options3) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options3 == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options3 = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options3) && "chain" in options3) || !!options3.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      __name(mixin, "mixin");
      function noConflict() {
        if (root23._ === this) {
          root23._ = oldDash;
        }
        return this;
      }
      __name(noConflict, "noConflict");
      function noop2() {
      }
      __name(noop2, "noop");
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      __name(nthArg, "nthArg");
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      __name(property, "property");
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      __name(propertyOf, "propertyOf");
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      __name(stubArray, "stubArray");
      function stubFalse() {
        return false;
      }
      __name(stubFalse, "stubFalse");
      function stubObject() {
        return {};
      }
      __name(stubObject, "stubObject");
      function stubString() {
        return "";
      }
      __name(stubString, "stubString");
      function stubTrue() {
        return true;
      }
      __name(stubTrue, "stubTrue");
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      __name(times, "times");
      function toPath(value3) {
        if (isArray2(value3)) {
          return arrayMap(value3, toKey);
        }
        return isSymbol2(value3) ? [value3] : copyArray(stringToPath(toString3(value3)));
      }
      __name(toPath, "toPath");
      function uniqueId(prefix2) {
        var id3 = ++idCounter;
        return toString3(prefix2) + id3;
      }
      __name(uniqueId, "uniqueId");
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
      }
      __name(max, "max");
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      __name(maxBy, "maxBy");
      function mean(array) {
        return baseMean(array, identity2);
      }
      __name(mean, "mean");
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      __name(meanBy, "meanBy");
      function min(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
      }
      __name(min, "min");
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      __name(minBy, "minBy");
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      __name(sum, "sum");
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      __name(sumBy, "sumBy");
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind3;
      lodash2.bindAll = bindAll2;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create3;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter4;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once2;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject2;
      lodash2.remove = remove4;
      lodash2.rest = rest;
      lodash2.reverse = reverse2;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq2;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values2;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith3;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp2;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast2;
      lodash2.findLastIndex = findLastIndex2;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach2;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte2;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke2;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join2;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte2;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat3;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith2;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString3;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach2;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value3) {
          return baseInvoke(value3, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value3 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value3 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value3);
          var interceptor = /* @__PURE__ */ __name(function(value4) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value4], args));
            return isTaker && chainAll ? result3[0] : result3;
          }, "interceptor");
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value3 = onlyLazy ? value3 : new LazyWrapper(this);
            var result2 = func.apply(value3, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value3 = this.value();
            return func.apply(isArray2(value3) ? value3 : [], args);
          }
          return this[chainName](function(value4) {
            return func.apply(isArray2(value4) ? value4 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    }, "runInContext");
    var _2 = runInContext();
    if (typeof undefined$1 == "function" && typeof undefined$1.amd == "object" && undefined$1.amd) {
      root23._ = _2;
      undefined$1(function() {
        return _2;
      });
    } else if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root23._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash$1, lodash$1.exports);
var lodashExports = lodash$1.exports;
const _ = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
var TaskItemDisplayStatus = /* @__PURE__ */ ((TaskItemDisplayStatus2) => {
  TaskItemDisplayStatus2["Running"] = "Running";
  TaskItemDisplayStatus2["Pending"] = "Pending";
  TaskItemDisplayStatus2["Completed"] = "Completed";
  TaskItemDisplayStatus2["Failed"] = "Failed";
  TaskItemDisplayStatus2["Cancelled"] = "Cancelled";
  return TaskItemDisplayStatus2;
})(TaskItemDisplayStatus || {});
class ResultItemImpl {
  static {
    __name(this, "ResultItemImpl");
  }
  filename;
  subfolder;
  type;
  nodeId;
  // 'audio' | 'images' | ...
  mediaType;
  // VHS output specific fields
  format;
  frame_rate;
  constructor(obj) {
    this.filename = obj.filename ?? "";
    this.subfolder = obj.subfolder ?? "";
    this.type = obj.type ?? "";
    this.nodeId = obj.nodeId;
    this.mediaType = obj.mediaType;
    this.format = obj.format;
    this.frame_rate = obj.frame_rate;
  }
  get urlParams() {
    const params = new URLSearchParams();
    params.set("filename", this.filename);
    params.set("type", this.type);
    params.set("subfolder", this.subfolder);
    if (this.format) {
      params.set("format", this.format);
    }
    if (this.frame_rate) {
      params.set("frame_rate", this.frame_rate.toString());
    }
    return params;
  }
  /**
   * VHS advanced preview URL. `/viewvideo` endpoint is provided by VHS node.
   *
   * `/viewvideo` always returns a webm file.
   */
  get vhsAdvancedPreviewUrl() {
    return api.apiURL("/viewvideo?" + this.urlParams);
  }
  get url() {
    return api.apiURL("/view?" + this.urlParams);
  }
  get urlWithTimestamp() {
    return `${this.url}&t=${+/* @__PURE__ */ new Date()}`;
  }
  get isVhsFormat() {
    return !!this.format && !!this.frame_rate;
  }
  get htmlVideoType() {
    const defaultType = void 0;
    if (!this.isVhsFormat) {
      return defaultType;
    }
    if (this.format?.endsWith("webm")) {
      return "video/webm";
    }
    if (this.format?.endsWith("mp4")) {
      return "video/mp4";
    }
    return defaultType;
  }
  get isVideo() {
    return !this.isImage && !!this.format?.startsWith("video/");
  }
  get isGif() {
    return this.filename.endsWith(".gif");
  }
  get isWebp() {
    return this.filename.endsWith(".webp");
  }
  get isImage() {
    return this.mediaType === "images" || this.isGif || this.isWebp;
  }
  get supportsPreview() {
    return this.isImage || this.isVideo;
  }
}
class TaskItemImpl {
  static {
    __name(this, "TaskItemImpl");
  }
  taskType;
  prompt;
  status;
  outputs;
  flatOutputs;
  constructor(taskType, prompt, status, outputs, flatOutputs) {
    this.taskType = taskType;
    this.prompt = prompt;
    this.status = status;
    this.outputs = outputs ?? {};
    this.flatOutputs = flatOutputs ?? this.calculateFlatOutputs();
  }
  calculateFlatOutputs() {
    if (!this.outputs) {
      return [];
    }
    return Object.entries(this.outputs).flatMap(
      ([nodeId, nodeOutputs]) => Object.entries(nodeOutputs).flatMap(
        ([mediaType, items2]) => items2.map(
          (item2) => new ResultItemImpl({
            ...item2,
            nodeId,
            mediaType
          })
        )
      )
    );
  }
  get previewOutput() {
    return this.flatOutputs.find(
      // Prefer saved media files over the temp previews
      (output) => output.type === "output" && output.supportsPreview
    ) ?? this.flatOutputs.find((output) => output.supportsPreview);
  }
  get apiTaskType() {
    switch (this.taskType) {
      case "Running":
      case "Pending":
        return "queue";
      case "History":
        return "history";
    }
  }
  get key() {
    return this.promptId + this.displayStatus;
  }
  get queueIndex() {
    return this.prompt[0];
  }
  get promptId() {
    return this.prompt[1];
  }
  get promptInputs() {
    return this.prompt[2];
  }
  get extraData() {
    return this.prompt[3];
  }
  get outputsToExecute() {
    return this.prompt[4];
  }
  get extraPngInfo() {
    return this.extraData.extra_pnginfo;
  }
  get clientId() {
    return this.extraData.client_id;
  }
  get workflow() {
    return this.extraPngInfo?.workflow;
  }
  get messages() {
    return this.status?.messages || [];
  }
  get interrupted() {
    return _.some(
      this.messages,
      (message2) => message2[0] === "execution_interrupted"
    );
  }
  get isHistory() {
    return this.taskType === "History";
  }
  get isRunning() {
    return this.taskType === "Running";
  }
  get displayStatus() {
    switch (this.taskType) {
      case "Running":
        return "Running";
      case "Pending":
        return "Pending";
      case "History":
        if (this.interrupted) return "Cancelled";
        switch (this.status.status_str) {
          case "success":
            return "Completed";
          case "error":
            return "Failed";
        }
    }
  }
  get executionStartTimestamp() {
    const message2 = this.messages.find(
      (message22) => message22[0] === "execution_start"
    );
    return message2 ? message2[1].timestamp : void 0;
  }
  get executionEndTimestamp() {
    const messages2 = this.messages.filter(
      (message2) => [
        "execution_success",
        "execution_interrupted",
        "execution_error"
      ].includes(message2[0])
    );
    if (!messages2.length) {
      return void 0;
    }
    return _.max(messages2.map((message2) => message2[1].timestamp));
  }
  get executionTime() {
    if (!this.executionStartTimestamp || !this.executionEndTimestamp) {
      return void 0;
    }
    return this.executionEndTimestamp - this.executionStartTimestamp;
  }
  get executionTimeInSeconds() {
    return this.executionTime !== void 0 ? this.executionTime / 1e3 : void 0;
  }
  async loadWorkflow(app2) {
    if (!this.workflow) {
      return;
    }
    await app2.loadGraphData(toRaw(this.workflow));
    if (this.outputs) {
      app2.nodeOutputs = toRaw(this.outputs);
    }
  }
  flatten() {
    if (this.displayStatus !== "Completed") {
      return [this];
    }
    return this.flatOutputs.map(
      (output, i2) => new TaskItemImpl(
        this.taskType,
        [
          this.queueIndex,
          `${this.promptId}-${i2}`,
          this.promptInputs,
          this.extraData,
          this.outputsToExecute
        ],
        this.status,
        {
          [output.nodeId]: {
            [output.mediaType]: [output]
          }
        },
        [output]
      )
    );
  }
}
const useQueueStore = /* @__PURE__ */ defineStore("queue", () => {
  const runningTasks = ref([]);
  const pendingTasks = ref([]);
  const historyTasks = ref([]);
  const maxHistoryItems = ref(64);
  const isLoading = ref(false);
  const tasks = computed(
    () => [
      ...pendingTasks.value,
      ...runningTasks.value,
      ...historyTasks.value
    ]
  );
  const flatTasks = computed(
    () => tasks.value.flatMap((task) => task.flatten())
  );
  const lastHistoryQueueIndex = computed(
    () => historyTasks.value.length ? historyTasks.value[0].queueIndex : -1
  );
  const hasPendingTasks = computed(() => pendingTasks.value.length > 0);
  const update = /* @__PURE__ */ __name(async () => {
    isLoading.value = true;
    try {
      const [queue2, history2] = await Promise.all([
        api.getQueue(),
        api.getHistory(maxHistoryItems.value)
      ]);
      const toClassAll = /* @__PURE__ */ __name((tasks2) => tasks2.map(
        (task) => new TaskItemImpl(
          task.taskType,
          task.prompt,
          // status and outputs only exist on history tasks
          "status" in task ? task.status : void 0,
          "outputs" in task ? task.outputs : void 0
        )
      ).sort((a, b) => b.queueIndex - a.queueIndex), "toClassAll");
      runningTasks.value = toClassAll(queue2.Running);
      pendingTasks.value = toClassAll(queue2.Pending);
      const allIndex = new Set(
        history2.History.map((item2) => item2.prompt[0])
      );
      const newHistoryItems = toClassAll(
        history2.History.filter(
          (item2) => item2.prompt[0] > lastHistoryQueueIndex.value
        )
      );
      const existingHistoryItems = historyTasks.value.filter(
        (item2) => allIndex.has(item2.queueIndex)
      );
      historyTasks.value = [...newHistoryItems, ...existingHistoryItems].slice(0, maxHistoryItems.value).sort((a, b) => b.queueIndex - a.queueIndex);
    } finally {
      isLoading.value = false;
    }
  }, "update");
  const clear2 = /* @__PURE__ */ __name(async (targets = ["queue", "history"]) => {
    if (targets.length === 0) {
      return;
    }
    await Promise.all(targets.map((type) => api.clearItems(type)));
    await update();
  }, "clear");
  const deleteTask = /* @__PURE__ */ __name(async (task) => {
    await api.deleteItem(task.apiTaskType, task.promptId);
    await update();
  }, "deleteTask");
  return {
    runningTasks,
    pendingTasks,
    historyTasks,
    maxHistoryItems,
    isLoading,
    tasks,
    flatTasks,
    lastHistoryQueueIndex,
    hasPendingTasks,
    update,
    clear: clear2,
    delete: deleteTask
  };
});
const useQueuePendingTaskCountStore = /* @__PURE__ */ defineStore(
  "queuePendingTaskCount",
  {
    state: /* @__PURE__ */ __name(() => ({
      count: 0
    }), "state"),
    actions: {
      update(e) {
        this.count = e.detail?.exec_info?.queue_remaining || 0;
      }
    }
  }
);
const useQueueSettingsStore = /* @__PURE__ */ defineStore("queueSettingsStore", {
  state: /* @__PURE__ */ __name(() => ({
    mode: "disabled",
    batchCount: 1
  }), "state")
});
const scriptRel = "modulepreload";
const assetsURL = /* @__PURE__ */ __name(function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
}, "assetsURL");
const seen = {};
const __vitePreload = /* @__PURE__ */ __name(function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i2 = links.length - 1; i2 >= 0; i2--) {
            const link2 = links[i2];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  __name(handlePreloadError, "handlePreloadError");
  return promise.then((res) => {
    for (const item2 of res || []) {
      if (item2.status !== "rejected") continue;
      handlePreloadError(item2.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
}, "preload");
let ComfyDialog$1 = class ComfyDialog2 extends EventTarget {
  static {
    __name(this, "ComfyDialog");
  }
  element;
  textElement;
  #buttons;
  constructor(type = "div", buttons = null) {
    super();
    this.#buttons = buttons;
    this.element = $el(type + ".comfy-modal", { parent: document.body }, [
      $el("div.comfy-modal-content", [
        $el("p", { $: /* @__PURE__ */ __name((p2) => this.textElement = p2, "$") }),
        ...this.createButtons()
      ])
    ]);
  }
  createButtons() {
    return this.#buttons ?? [
      $el("button", {
        type: "button",
        textContent: "Close",
        onclick: /* @__PURE__ */ __name(() => this.close(), "onclick")
      })
    ];
  }
  close() {
    this.element.style.display = "none";
  }
  show(html) {
    if (typeof html === "string") {
      this.textElement.innerHTML = html;
    } else {
      this.textElement.replaceChildren(
        ...html instanceof Array ? html : [html]
      );
    }
    this.element.style.display = "flex";
  }
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.dialog = window.comfyAPI.dialog || {};
window.comfyAPI.dialog.ComfyDialog = ComfyDialog$1;
function toggleSwitch(name, items2, e) {
  const onChange4 = e?.onChange;
  let selectedIndex;
  let elements;
  function updateSelected(index2) {
    if (selectedIndex != null) {
      elements[selectedIndex].classList.remove("comfy-toggle-selected");
    }
    onChange4?.({
      item: items2[index2],
      prev: selectedIndex == null ? void 0 : items2[selectedIndex]
    });
    selectedIndex = index2;
    elements[selectedIndex].classList.add("comfy-toggle-selected");
  }
  __name(updateSelected, "updateSelected");
  elements = items2.map((item2, i2) => {
    if (typeof item2 === "string") item2 = { text: item2 };
    if (!item2.value) item2.value = item2.text;
    const toggle4 = $el(
      "label",
      {
        textContent: item2.text,
        title: item2.tooltip ?? ""
      },
      $el("input", {
        name,
        type: "radio",
        value: item2.value ?? item2.text,
        checked: item2.selected,
        onchange: /* @__PURE__ */ __name(() => {
          updateSelected(i2);
        }, "onchange")
      })
    );
    if (item2.selected) {
      updateSelected(i2);
    }
    return toggle4;
  });
  const container = $el("div.comfy-toggle-switch", elements);
  if (selectedIndex == null) {
    elements[0].children[0].checked = true;
    updateSelected(0);
  }
  return container;
}
__name(toggleSwitch, "toggleSwitch");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.toggleSwitch = window.comfyAPI.toggleSwitch || {};
window.comfyAPI.toggleSwitch.toggleSwitch = toggleSwitch;
function buildTree(items2, key) {
  const root23 = {
    key: "root",
    label: "root",
    children: []
  };
  const map2 = {
    root: root23
  };
  for (const item2 of items2) {
    const keys2 = key(item2);
    let parent = root23;
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const k = keys2[i2];
      if (k === "" && i2 === keys2.length - 1) break;
      const id3 = parent.key + "/" + k;
      if (!map2[id3]) {
        const node3 = {
          key: id3,
          label: k,
          leaf: false,
          children: []
        };
        map2[id3] = node3;
        parent.children?.push(node3);
      }
      parent = map2[id3];
    }
    parent.leaf = keys2[keys2.length - 1] !== "";
    parent.data = item2;
  }
  return root23;
}
__name(buildTree, "buildTree");
function flattenTree(tree) {
  const result = [];
  const stack2 = [tree];
  while (stack2.length) {
    const node3 = stack2.pop();
    if (node3.leaf && node3.data) result.push(node3.data);
    stack2.push(...node3.children || []);
  }
  return result;
}
__name(flattenTree, "flattenTree");
function sortedTree(node3, {
  groupLeaf = false
} = {}) {
  const newNode = {
    ...node3
  };
  if (node3.children) {
    if (groupLeaf) {
      const folders = node3.children.filter((child) => !child.leaf);
      const files = node3.children.filter((child) => child.leaf);
      const sortedFolders = folders.sort(
        (a, b) => (a.label ?? "").localeCompare(b.label ?? "")
      );
      const sortedFiles = files.sort(
        (a, b) => (a.label ?? "").localeCompare(b.label ?? "")
      );
      newNode.children = [
        ...sortedFolders.map(
          (folder) => sortedTree(folder, { groupLeaf: true })
        ),
        ...sortedFiles
      ];
    } else {
      const sortedChildren = [...node3.children].sort(
        (a, b) => (a.label ?? "").localeCompare(b.label ?? "")
      );
      newNode.children = [
        ...sortedChildren.map(
          (child) => sortedTree(child, { groupLeaf: false })
        )
      ];
    }
  }
  return newNode;
}
__name(sortedTree, "sortedTree");
const findNodeByKey = /* @__PURE__ */ __name((root23, key) => {
  if (root23.key === key) {
    return root23;
  }
  if (!root23.children) {
    return null;
  }
  for (const child of root23.children) {
    const result = findNodeByKey(child, key);
    if (result) {
      return result;
    }
  }
  return null;
}, "findNodeByKey");
class LLink {
  static {
    __name(this, "LLink");
  }
  /** Link ID */
  id;
  parentId;
  type;
  /** Output node ID */
  origin_id;
  /** Output slot index */
  origin_slot;
  /** Input node ID */
  target_id;
  /** Input slot index */
  target_slot;
  data;
  _data;
  /** Centre point of the link, calculated during render only - can be inaccurate */
  _pos;
  /** @todo Clean up - never implemented in comfy. */
  _last_time;
  /** The last canvas 2D path that was used to render this link */
  path;
  /** @inheritdoc */
  _centreAngle;
  #color;
  /** Custom colour for this link only */
  get color() {
    return this.#color;
  }
  set color(value3) {
    this.#color = value3 === "" ? null : value3;
  }
  constructor(id3, type, origin_id, origin_slot, target_id, target_slot, parentId) {
    this.id = id3;
    this.type = type;
    this.origin_id = origin_id;
    this.origin_slot = origin_slot;
    this.target_id = target_id;
    this.target_slot = target_slot;
    this.parentId = parentId;
    this._data = null;
    this._pos = new Float32Array(2);
  }
  /** @deprecated Use {@link LLink.create} */
  static createFromArray(data22) {
    return new LLink(data22[0], data22[5], data22[1], data22[2], data22[3], data22[4]);
  }
  /**
   * LLink static factory: creates a new LLink from the provided data.
   * @param data Serialised LLink data to create the link from
   * @returns A new LLink
   */
  static create(data22) {
    return new LLink(data22.id, data22.type, data22.origin_id, data22.origin_slot, data22.target_id, data22.target_slot, data22.parentId);
  }
  /**
   * Gets all reroutes from the output slot to this segment.  If this segment is a reroute, it will be the last element.
   * @returns An ordered array of all reroutes from the node output to this reroute or the reroute before it.  Otherwise, an empty array.
   */
  static getReroutes(network, linkSegment) {
    return network.reroutes.get(linkSegment.parentId)?.getReroutes() ?? [];
  }
  /**
   * Finds the reroute in the chain after the provided reroute ID.
   * @param network The network this link belongs to
   * @param linkSegment The starting point of the search (input side).  Typically the LLink object itself, but can be any link segment.
   * @param rerouteId The matching reroute will have this set as its {@link parentId}.
   * @returns The reroute that was found, `undefined` if no reroute was found, or `null` if an infinite loop was detected.
   */
  static findNextReroute(network, linkSegment, rerouteId) {
    return network.reroutes.get(linkSegment.parentId)?.findNextReroute(rerouteId);
  }
  configure(o) {
    if (Array.isArray(o)) {
      this.id = o[0];
      this.origin_id = o[1];
      this.origin_slot = o[2];
      this.target_id = o[3];
      this.target_slot = o[4];
      this.type = o[5];
    } else {
      this.id = o.id;
      this.type = o.type;
      this.origin_id = o.origin_id;
      this.origin_slot = o.origin_slot;
      this.target_id = o.target_id;
      this.target_slot = o.target_slot;
      this.parentId = o.parentId;
    }
  }
  /**
   * Disconnects a link and removes it from the graph, cleaning up any reroutes that are no longer used
   * @param network The container (LGraph) where reroutes should be updated
   * @param keepReroutes If `true`, reroutes will not be garbage collected.
   */
  disconnect(network, keepReroutes) {
    const reroutes = LLink.getReroutes(network, this);
    for (const reroute of reroutes) {
      reroute.linkIds.delete(this.id);
      if (!keepReroutes && !reroute.linkIds.size) network.reroutes.delete(reroute.id);
    }
    network.links.delete(this.id);
  }
  /**
   * @deprecated Prefer {@link LLink.asSerialisable} (returns an object, not an array)
   * @returns An array representing this LLink
   */
  serialize() {
    return [
      this.id,
      this.origin_id,
      this.origin_slot,
      this.target_id,
      this.target_slot,
      this.type
    ];
  }
  asSerialisable() {
    const copy = {
      id: this.id,
      origin_id: this.origin_id,
      origin_slot: this.origin_slot,
      target_id: this.target_id,
      target_slot: this.target_slot,
      type: this.type
    };
    if (this.parentId) copy.parentId = this.parentId;
    return copy;
  }
}
var NodeSlotType = /* @__PURE__ */ ((NodeSlotType2) => {
  NodeSlotType2[NodeSlotType2["INPUT"] = 1] = "INPUT";
  NodeSlotType2[NodeSlotType2["OUTPUT"] = 2] = "OUTPUT";
  return NodeSlotType2;
})(NodeSlotType || {});
var RenderShape = /* @__PURE__ */ ((RenderShape2) => {
  RenderShape2[RenderShape2["BOX"] = 1] = "BOX";
  RenderShape2[RenderShape2["ROUND"] = 2] = "ROUND";
  RenderShape2[RenderShape2["CIRCLE"] = 3] = "CIRCLE";
  RenderShape2[RenderShape2["CARD"] = 4] = "CARD";
  RenderShape2[RenderShape2["ARROW"] = 5] = "ARROW";
  RenderShape2[RenderShape2["GRID"] = 6] = "GRID";
  RenderShape2[RenderShape2["HollowCircle"] = 7] = "HollowCircle";
  return RenderShape2;
})(RenderShape || {});
var LinkDirection = /* @__PURE__ */ ((LinkDirection2) => {
  LinkDirection2[LinkDirection2["NONE"] = 0] = "NONE";
  LinkDirection2[LinkDirection2["UP"] = 1] = "UP";
  LinkDirection2[LinkDirection2["DOWN"] = 2] = "DOWN";
  LinkDirection2[LinkDirection2["LEFT"] = 3] = "LEFT";
  LinkDirection2[LinkDirection2["RIGHT"] = 4] = "RIGHT";
  LinkDirection2[LinkDirection2["CENTER"] = 5] = "CENTER";
  return LinkDirection2;
})(LinkDirection || {});
var LinkRenderType = /* @__PURE__ */ ((LinkRenderType2) => {
  LinkRenderType2[LinkRenderType2["HIDDEN_LINK"] = -1] = "HIDDEN_LINK";
  LinkRenderType2[LinkRenderType2["STRAIGHT_LINK"] = 0] = "STRAIGHT_LINK";
  LinkRenderType2[LinkRenderType2["LINEAR_LINK"] = 1] = "LINEAR_LINK";
  LinkRenderType2[LinkRenderType2["SPLINE_LINK"] = 2] = "SPLINE_LINK";
  return LinkRenderType2;
})(LinkRenderType || {});
var LinkMarkerShape = /* @__PURE__ */ ((LinkMarkerShape2) => {
  LinkMarkerShape2[LinkMarkerShape2["None"] = 0] = "None";
  LinkMarkerShape2[LinkMarkerShape2["Circle"] = 1] = "Circle";
  LinkMarkerShape2[LinkMarkerShape2["Arrow"] = 2] = "Arrow";
  return LinkMarkerShape2;
})(LinkMarkerShape || {});
var TitleMode = /* @__PURE__ */ ((TitleMode2) => {
  TitleMode2[TitleMode2["NORMAL_TITLE"] = 0] = "NORMAL_TITLE";
  TitleMode2[TitleMode2["NO_TITLE"] = 1] = "NO_TITLE";
  TitleMode2[TitleMode2["TRANSPARENT_TITLE"] = 2] = "TRANSPARENT_TITLE";
  TitleMode2[TitleMode2["AUTOHIDE_TITLE"] = 3] = "AUTOHIDE_TITLE";
  return TitleMode2;
})(TitleMode || {});
var LGraphEventMode = /* @__PURE__ */ ((LGraphEventMode2) => {
  LGraphEventMode2[LGraphEventMode2["ALWAYS"] = 0] = "ALWAYS";
  LGraphEventMode2[LGraphEventMode2["ON_EVENT"] = 1] = "ON_EVENT";
  LGraphEventMode2[LGraphEventMode2["NEVER"] = 2] = "NEVER";
  LGraphEventMode2[LGraphEventMode2["ON_TRIGGER"] = 3] = "ON_TRIGGER";
  LGraphEventMode2[LGraphEventMode2["BYPASS"] = 4] = "BYPASS";
  return LGraphEventMode2;
})(LGraphEventMode || {});
var EaseFunction = /* @__PURE__ */ ((EaseFunction2) => {
  EaseFunction2["LINEAR"] = "linear";
  EaseFunction2["EASE_IN_QUAD"] = "easeInQuad";
  EaseFunction2["EASE_OUT_QUAD"] = "easeOutQuad";
  EaseFunction2["EASE_IN_OUT_QUAD"] = "easeInOutQuad";
  return EaseFunction2;
})(EaseFunction || {});
function distance(a, b) {
  return Math.sqrt(
    (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])
  );
}
__name(distance, "distance");
function isPointInRectangle(point, rect) {
  return rect[0] <= point[0] && rect[0] + rect[2] > point[0] && rect[1] <= point[1] && rect[1] + rect[3] > point[1];
}
__name(isPointInRectangle, "isPointInRectangle");
function isXyInRectangle(x2, y2, rect) {
  return rect[0] <= x2 && rect[0] + rect[2] > x2 && rect[1] <= y2 && rect[1] + rect[3] > y2;
}
__name(isXyInRectangle, "isXyInRectangle");
function isInsideRectangle(x2, y2, left, top, width2, height) {
  return left < x2 && left + width2 > x2 && top < y2 && top + height > y2;
}
__name(isInsideRectangle, "isInsideRectangle");
function isSortaInsideOctagon(x2, y2, radius) {
  const sum = Math.min(radius, Math.abs(x2)) + Math.min(radius, Math.abs(y2));
  return sum < radius * 0.75;
}
__name(isSortaInsideOctagon, "isSortaInsideOctagon");
function overlapBounding(a, b) {
  const aRight = a[0] + a[2];
  const aBottom = a[1] + a[3];
  const bRight = b[0] + b[2];
  const bBottom = b[1] + b[3];
  return a[0] > bRight || a[1] > bBottom || aRight < b[0] || aBottom < b[1] ? false : true;
}
__name(overlapBounding, "overlapBounding");
function containsCentre(a, b) {
  const centreX = b[0] + b[2] * 0.5;
  const centreY = b[1] + b[3] * 0.5;
  return isXyInRectangle(centreX, centreY, a);
}
__name(containsCentre, "containsCentre");
function containsRect(a, b) {
  const aRight = a[0] + a[2];
  const aBottom = a[1] + a[3];
  const bRight = b[0] + b[2];
  const bBottom = b[1] + b[3];
  const identical = a[0] === b[0] && a[1] === b[1] && aRight === bRight && aBottom === bBottom;
  return !identical && a[0] <= b[0] && a[1] <= b[1] && aRight >= bRight && aBottom >= bBottom;
}
__name(containsRect, "containsRect");
function findPointOnCurve(out, a, b, controlA, controlB, t = 0.5) {
  const iT = 1 - t;
  const c1 = iT * iT * iT;
  const c2 = 3 * (iT * iT) * t;
  const c3 = 3 * iT * (t * t);
  const c4 = t * t * t;
  out[0] = c1 * a[0] + c2 * controlA[0] + c3 * controlB[0] + c4 * b[0];
  out[1] = c1 * a[1] + c2 * controlA[1] + c3 * controlB[1] + c4 * b[1];
}
__name(findPointOnCurve, "findPointOnCurve");
function createBounds(objects, padding = 10) {
  const bounds = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
  for (const obj of objects) {
    const rect = obj.boundingRect;
    bounds[0] = Math.min(bounds[0], rect[0]);
    bounds[1] = Math.min(bounds[1], rect[1]);
    bounds[2] = Math.max(bounds[2], rect[0] + rect[2]);
    bounds[3] = Math.max(bounds[3], rect[1] + rect[3]);
  }
  if (!bounds.every((x2) => isFinite(x2))) return null;
  return [
    bounds[0] - padding,
    bounds[1] - padding,
    bounds[2] - bounds[0] + 2 * padding,
    bounds[3] - bounds[1] + 2 * padding
  ];
}
__name(createBounds, "createBounds");
class Reroute {
  static {
    __name(this, "Reroute");
  }
  /**
   * Initialises a new link reroute object.
   * @param id Unique identifier for this reroute
   * @param network The network of links this reroute belongs to.  Internally converted to a WeakRef.
   * @param pos Position in graph coordinates
   * @param linkIds Link IDs ({@link LLink.id}) of all links that use this reroute
   */
  constructor(id3, network, pos2, parentId, linkIds) {
    this.id = id3;
    this.#network = new WeakRef(network);
    this.update(parentId, pos2, linkIds);
    this.linkIds ??= /* @__PURE__ */ new Set();
  }
  static radius = 10;
  #malloc = new Float32Array(8);
  /** The network this reroute belongs to.  Contains all valid links and reroutes. */
  #network;
  #parentId;
  /** @inheritdoc */
  get parentId() {
    return this.#parentId;
  }
  /** Ignores attempts to create an infinite loop. @inheritdoc */
  set parentId(value3) {
    if (value3 === this.id) return;
    if (this.getReroutes() === null) return;
    this.#parentId = value3;
  }
  #pos = this.#malloc.subarray(0, 2);
  /** @inheritdoc */
  get pos() {
    return this.#pos;
  }
  set pos(value3) {
    if (!(value3?.length >= 2)) throw new TypeError("Reroute.pos is an x,y point, and expects an indexable with at least two values.");
    this.#pos[0] = value3[0];
    this.#pos[1] = value3[1];
  }
  /** @inheritdoc */
  get boundingRect() {
    const { radius } = Reroute;
    const [x2, y2] = this.#pos;
    return [x2 - radius, y2 - radius, 2 * radius, 2 * radius];
  }
  /** @inheritdoc */
  selected;
  /** The ID ({@link LLink.id}) of every link using this reroute */
  linkIds;
  /** The averaged angle of every link through this reroute. */
  otherAngle = 0;
  /** Cached cos */
  cos = 0;
  sin = 0;
  /** Bezier curve control point for the "target" (input) side of the link */
  controlPoint = this.#malloc.subarray(4, 6);
  /** @inheritdoc */
  path;
  /** @inheritdoc */
  _centreAngle;
  /** @inheritdoc */
  _pos = this.#malloc.subarray(6, 8);
  /**
   * Used to ensure reroute angles are only executed once per frame. 
   * @todo Calculate on change instead.
   */
  #lastRenderTime = -Infinity;
  #buffer = this.#malloc.subarray(2, 4);
  /** @inheritdoc */
  get origin_id() {
    return this.#network.deref()?.links.get(this.linkIds.values().next().value)?.origin_id;
  }
  /** @inheritdoc */
  get origin_slot() {
    return this.#network.deref()?.links.get(this.linkIds.values().next().value)?.origin_slot;
  }
  /**
   * Applies a new parentId to the reroute, and optinoally a new position and linkId.
   * Primarily used for deserialisation.
   * @param parentId The ID of the reroute prior to this reroute, or `undefined` if it is the first reroute connected to a nodes output
   * @param pos The position of this reroute
   * @param linkIds All link IDs that pass through this reroute
   */
  update(parentId, pos2, linkIds) {
    this.parentId = parentId;
    if (pos2) this.pos = pos2;
    if (linkIds) this.linkIds = new Set(linkIds);
  }
  /**
   * Validates the linkIds this reroute has.  Removes broken links.
   * @param links Collection of valid links
   * @returns true if any links remain after validation
   */
  validateLinks(links) {
    const { linkIds } = this;
    for (const linkId of linkIds) {
      if (!links.get(linkId)) linkIds.delete(linkId);
    }
    return linkIds.size > 0;
  }
  /**
   * Retrieves an ordered array of all reroutes from the node output.
   * @param visited Internal.  A set of reroutes that this function has already visited whilst recursing up the chain.
   * @returns An ordered array of all reroutes from the node output to this reroute, inclusive.
   * `null` if an infinite loop is detected.
   * `undefined` if the reroute chain or {@link LinkNetwork} are invalid.
   */
  getReroutes(visited = /* @__PURE__ */ new Set()) {
    if (this.#parentId === void 0) return [this];
    if (visited.has(this)) return null;
    visited.add(this);
    const parent = this.#network.deref()?.reroutes.get(this.#parentId);
    if (!parent) {
      this.#parentId = void 0;
      return [this];
    }
    const reroutes = parent.getReroutes(visited);
    reroutes?.push(this);
    return reroutes;
  }
  /**
   * Internal.  Called by {@link LLink.findNextReroute}.  Not intended for use by itself.
   * @param withParentId The rerouteId to look for
   * @param visited A set of reroutes that have already been visited
   * @returns The reroute that was found, `undefined` if no reroute was found, or `null` if an infinite loop was detected.
   */
  findNextReroute(withParentId, visited = /* @__PURE__ */ new Set()) {
    if (this.#parentId === withParentId) return this;
    if (visited.has(this)) return null;
    visited.add(this);
    return this.#network.deref()?.reroutes.get(this.#parentId)?.findNextReroute(withParentId, visited);
  }
  /** @inheritdoc */
  move(deltaX, deltaY) {
    this.#pos[0] += deltaX;
    this.#pos[1] += deltaY;
  }
  calculateAngle(lastRenderTime, network, linkStart) {
    if (!(lastRenderTime > this.#lastRenderTime)) return;
    this.#lastRenderTime = lastRenderTime;
    const { links } = network;
    const { linkIds, id: id3 } = this;
    const angles = [];
    let sum = 0;
    for (const linkId of linkIds) {
      const link = links.get(linkId);
      if (!link) continue;
      const pos2 = LLink.findNextReroute(network, link, id3)?.pos ?? network.getNodeById(link.target_id)?.getConnectionPos(true, link.target_slot, this.#buffer);
      if (!pos2) continue;
      const angle = Math.atan2(pos2[1] - this.#pos[1], pos2[0] - this.#pos[0]);
      angles.push(angle);
      sum += angle;
    }
    if (!angles.length) return;
    sum /= angles.length;
    const originToReroute = Math.atan2(this.#pos[1] - linkStart[1], this.#pos[0] - linkStart[0]);
    let diff2 = (originToReroute - sum) * 0.5;
    if (Math.abs(diff2) > Math.PI * 0.5) diff2 += Math.PI;
    const dist2 = Math.min(80, distance(linkStart, this.#pos) * 0.25);
    const originDiff = originToReroute - diff2;
    const cos = Math.cos(originDiff);
    const sin = Math.sin(originDiff);
    this.otherAngle = originDiff;
    this.cos = cos;
    this.sin = sin;
    this.controlPoint[0] = dist2 * -cos;
    this.controlPoint[1] = dist2 * -sin;
    return;
  }
  /**
   * Renders the reroute on the canvas.
   * @param ctx Canvas context to draw on
   * @param colour Reroute colour (typically link colour)
   * 
   * @remarks Leaves {@link ctx}.fillStyle, strokeStyle, and lineWidth dirty (perf.).
   */
  draw(ctx, colour) {
    const { pos: pos2 } = this;
    ctx.fillStyle = colour;
    ctx.beginPath();
    ctx.arc(pos2[0], pos2[1], Reroute.radius, 0, 2 * Math.PI);
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgb(0,0,0,0.5)";
    ctx.stroke();
    ctx.fillStyle = "#ffffff55";
    ctx.strokeStyle = "rgb(0,0,0,0.3)";
    ctx.beginPath();
    ctx.arc(pos2[0], pos2[1], 8, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    if (this.selected) {
      ctx.strokeStyle = "#fff";
      ctx.beginPath();
      ctx.arc(pos2[0], pos2[1], 12, 0, 2 * Math.PI);
      ctx.stroke();
    }
  }
  /** @inheritdoc */
  asSerialisable() {
    return {
      id: this.id,
      parentId: this.parentId,
      pos: [this.pos[0], this.pos[1]],
      linkIds: [...this.linkIds]
    };
  }
}
var BadgePosition = /* @__PURE__ */ ((BadgePosition2) => {
  BadgePosition2["TopLeft"] = "top-left";
  BadgePosition2["TopRight"] = "top-right";
  return BadgePosition2;
})(BadgePosition || {});
class LGraphBadge {
  static {
    __name(this, "LGraphBadge");
  }
  text;
  fgColor;
  bgColor;
  fontSize;
  padding;
  height;
  cornerRadius;
  constructor({
    text,
    fgColor = "white",
    bgColor = "#0F1F0F",
    fontSize = 12,
    padding = 6,
    height = 20,
    cornerRadius = 5
  }) {
    this.text = text;
    this.fgColor = fgColor;
    this.bgColor = bgColor;
    this.fontSize = fontSize;
    this.padding = padding;
    this.height = height;
    this.cornerRadius = cornerRadius;
  }
  get visible() {
    return this.text.length > 0;
  }
  getWidth(ctx) {
    if (!this.visible) return 0;
    ctx.save();
    ctx.font = `${this.fontSize}px sans-serif`;
    const textWidth = ctx.measureText(this.text).width;
    ctx.restore();
    return textWidth + this.padding * 2;
  }
  draw(ctx, x2, y2) {
    if (!this.visible) return;
    ctx.save();
    ctx.font = `${this.fontSize}px sans-serif`;
    const badgeWidth = this.getWidth(ctx);
    const badgeX = 0;
    ctx.fillStyle = this.bgColor;
    ctx.beginPath();
    if (ctx.roundRect) {
      ctx.roundRect(x2 + badgeX, y2, badgeWidth, this.height, this.cornerRadius);
    } else {
      ctx.rect(x2 + badgeX, y2, badgeWidth, this.height);
    }
    ctx.fill();
    ctx.fillStyle = this.fgColor;
    ctx.fillText(
      this.text,
      x2 + badgeX + this.padding,
      y2 + this.height - this.padding
    );
    ctx.restore();
  }
}
class LGraphNode {
  static {
    __name(this, "LGraphNode");
  }
  // Static properties used by dynamic child classes
  static title;
  static MAX_CONSOLE;
  static type;
  static category;
  static supported_extensions;
  static filter;
  static skip_list;
  /** Default setting for {@link LGraphNode.connectInputToOutput}. @see {@link INodeFlags.keepAllLinksOnBypass} */
  static keepAllLinksOnBypass = false;
  title;
  graph = null;
  id;
  type = null;
  inputs = [];
  outputs = [];
  // Not used
  connections = [];
  properties = {};
  properties_info = [];
  flags = {};
  widgets;
  locked;
  // Execution order, automatically computed during run
  order;
  mode;
  last_serialization;
  serialize_widgets;
  color;
  bgcolor;
  boxcolor;
  exec_version;
  action_call;
  execute_triggered;
  action_triggered;
  widgets_up;
  widgets_start_y;
  lostFocusAt;
  gotFocusAt;
  badges = [];
  badgePosition = BadgePosition.TopLeft;
  _collapsed_width;
  horizontal;
  console;
  _level;
  _shape;
  subgraph;
  skip_subgraph_button;
  mouseOver;
  redraw_on_mouse;
  // Appears unused
  optional_inputs;
  // Appears unused
  optional_outputs;
  resizable;
  clonable;
  _relative_id;
  clip_area;
  ignore_remove;
  has_errors;
  removable;
  block_delete;
  selected;
  showAdvanced;
  /** @inheritdoc {@link renderArea} */
  #renderArea = new Float32Array(4);
  /**
   * Rect describing the node area, including shadows and any protrusions.
   * Determines if the node is visible.  Calculated once at the start of every frame.
  */
  get renderArea() {
    return this.#renderArea;
  }
  /** @inheritdoc {@link boundingRect} */
  #boundingRect = new Float32Array(4);
  /**
   * Cached node position & area as `x, y, width, height`.  Includes changes made by {@link onBounding}, if present.
   * 
   * Determines the node hitbox and other rendering effects.  Calculated once at the start of every frame.
   */
  get boundingRect() {
    return this.#boundingRect;
  }
  /** {@link pos} and {@link size} values are backed by this {@link Rect}. */
  _posSize = new Float32Array(4);
  _pos = this._posSize.subarray(0, 2);
  _size = this._posSize.subarray(2, 4);
  get pos() {
    return this._pos;
  }
  set pos(value3) {
    if (!value3 || value3.length < 2) return;
    this._pos[0] = value3[0];
    this._pos[1] = value3[1];
  }
  get size() {
    return this._size;
  }
  set size(value3) {
    if (!value3 || value3.length < 2) return;
    this._size[0] = value3[0];
    this._size[1] = value3[1];
  }
  get shape() {
    return this._shape;
  }
  set shape(v2) {
    switch (v2) {
      case "default":
        delete this._shape;
        break;
      case "box":
        this._shape = RenderShape.BOX;
        break;
      case "round":
        this._shape = RenderShape.ROUND;
        break;
      case "circle":
        this._shape = RenderShape.CIRCLE;
        break;
      case "card":
        this._shape = RenderShape.CARD;
        break;
      default:
        this._shape = v2;
    }
  }
  get is_selected() {
    return this.selected;
  }
  set is_selected(value3) {
    this.selected = value3;
  }
  constructor(title) {
    this.id = LiteGraph.use_uuids ? LiteGraph.uuidv4() : -1;
    this.title = title || "Unnamed";
    this.size = [LiteGraph.NODE_WIDTH, 60];
    this.pos = [10, 10];
  }
  /**
   * configure a node from an object containing the serialized info
   */
  configure(info) {
    if (this.graph) {
      this.graph._version++;
    }
    for (const j in info) {
      if (j == "properties") {
        for (const k in info.properties) {
          this.properties[k] = info.properties[k];
          this.onPropertyChanged?.(k, info.properties[k]);
        }
        continue;
      }
      if (info[j] == null) {
        continue;
      } else if (typeof info[j] == "object") {
        if (this[j]?.configure) {
          this[j]?.configure(info[j]);
        } else {
          this[j] = LiteGraph.cloneObject(info[j], this[j]);
        }
      } else {
        this[j] = info[j];
      }
    }
    if (!info.title) {
      this.title = this.constructor.title;
    }
    if (this.inputs) {
      for (let i2 = 0; i2 < this.inputs.length; ++i2) {
        const input = this.inputs[i2];
        const link = this.graph ? this.graph._links.get(input.link) : null;
        this.onConnectionsChange?.(NodeSlotType.INPUT, i2, true, link, input);
        this.onInputAdded?.(input);
      }
    }
    if (this.outputs) {
      for (let i2 = 0; i2 < this.outputs.length; ++i2) {
        const output = this.outputs[i2];
        if (!output.links) {
          continue;
        }
        for (let j = 0; j < output.links.length; ++j) {
          const link = this.graph ? this.graph._links.get(output.links[j]) : null;
          this.onConnectionsChange?.(NodeSlotType.OUTPUT, i2, true, link, output);
        }
        this.onOutputAdded?.(output);
      }
    }
    if (this.widgets) {
      for (let i2 = 0; i2 < this.widgets.length; ++i2) {
        const w2 = this.widgets[i2];
        if (!w2)
          continue;
        if (w2.options?.property && this.properties[w2.options.property] != void 0)
          w2.value = JSON.parse(JSON.stringify(this.properties[w2.options.property]));
      }
      if (info.widgets_values) {
        for (let i2 = 0; i2 < info.widgets_values.length; ++i2) {
          if (this.widgets[i2]) {
            this.widgets[i2].value = info.widgets_values[i2];
          }
        }
      }
    }
    if (this.pinned) this.pin(true);
    this.onConfigure?.(info);
  }
  /**
   * serialize the content
   */
  serialize() {
    const o = {
      id: this.id,
      type: this.type,
      pos: [this.pos[0], this.pos[1]],
      size: [this.size[0], this.size[1]],
      flags: LiteGraph.cloneObject(this.flags),
      order: this.order,
      mode: this.mode,
      showAdvanced: this.showAdvanced
    };
    if (this.constructor === LGraphNode && this.last_serialization)
      return this.last_serialization;
    if (this.inputs) o.inputs = this.inputs;
    if (this.outputs) {
      for (let i2 = 0; i2 < this.outputs.length; i2++) {
        delete this.outputs[i2]._data;
      }
      o.outputs = this.outputs;
    }
    if (this.title && this.title != this.constructor.title) o.title = this.title;
    if (this.properties) o.properties = LiteGraph.cloneObject(this.properties);
    if (this.widgets && this.serialize_widgets) {
      o.widgets_values = [];
      for (let i2 = 0; i2 < this.widgets.length; ++i2) {
        if (this.widgets[i2])
          o.widgets_values[i2] = this.widgets[i2].value;
        else
          o.widgets_values[i2] = null;
      }
    }
    if (!o.type) o.type = this.constructor.type;
    if (this.color) o.color = this.color;
    if (this.bgcolor) o.bgcolor = this.bgcolor;
    if (this.boxcolor) o.boxcolor = this.boxcolor;
    if (this.shape) o.shape = this.shape;
    if (this.onSerialize?.(o)) console.warn("node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter");
    return o;
  }
  /* Creates a clone of this node */
  clone() {
    const node22 = LiteGraph.createNode(this.type);
    if (!node22) return null;
    const data22 = LiteGraph.cloneObject(this.serialize());
    if (data22.inputs) {
      for (let i2 = 0; i2 < data22.inputs.length; ++i2) {
        data22.inputs[i2].link = null;
      }
    }
    if (data22.outputs) {
      for (let i2 = 0; i2 < data22.outputs.length; ++i2) {
        if (data22.outputs[i2].links) {
          data22.outputs[i2].links.length = 0;
        }
      }
    }
    delete data22.id;
    if (LiteGraph.use_uuids) data22.id = LiteGraph.uuidv4();
    node22.configure(data22);
    return node22;
  }
  /**
   * serialize and stringify
   */
  toString() {
    return JSON.stringify(this.serialize());
  }
  /**
   * get the title string
   */
  getTitle() {
    return this.title || this.constructor.title;
  }
  /**
   * sets the value of a property
   * @param {String} name
   * @param {*} value
   */
  setProperty(name, value3) {
    this.properties ||= {};
    if (value3 === this.properties[name])
      return;
    const prev_value = this.properties[name];
    this.properties[name] = value3;
    if (this.onPropertyChanged?.(name, value3, prev_value) === false)
      this.properties[name] = prev_value;
    if (this.widgets)
      for (let i2 = 0; i2 < this.widgets.length; ++i2) {
        const w2 = this.widgets[i2];
        if (!w2)
          continue;
        if (w2.options.property == name) {
          w2.value = value3;
          break;
        }
      }
  }
  /**
   * sets the output data
   * @param {number} slot
   * @param {*} data
   */
  setOutputData(slot, data22) {
    if (!this.outputs) return;
    if (slot == -1 || slot >= this.outputs.length) return;
    const output_info = this.outputs[slot];
    if (!output_info) return;
    output_info._data = data22;
    if (this.outputs[slot].links) {
      for (let i2 = 0; i2 < this.outputs[slot].links.length; i2++) {
        const link_id = this.outputs[slot].links[i2];
        const link = this.graph._links.get(link_id);
        if (link)
          link.data = data22;
      }
    }
  }
  /**
   * sets the output data type, useful when you want to be able to overwrite the data type
   * @param {number} slot
   * @param {String} datatype
   */
  setOutputDataType(slot, type) {
    if (!this.outputs) return;
    if (slot == -1 || slot >= this.outputs.length) return;
    const output_info = this.outputs[slot];
    if (!output_info) return;
    output_info.type = type;
    if (this.outputs[slot].links) {
      for (let i2 = 0; i2 < this.outputs[slot].links.length; i2++) {
        const link_id = this.outputs[slot].links[i2];
        this.graph._links.get(link_id).type = type;
      }
    }
  }
  /**
   * Retrieves the input data (data traveling through the connection) from one slot
   * @param {number} slot
   * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
   * @return {*} data or if it is not connected returns undefined
   */
  getInputData(slot, force_update) {
    if (!this.inputs) return;
    if (slot >= this.inputs.length || this.inputs[slot].link == null) return;
    const link_id = this.inputs[slot].link;
    const link = this.graph._links.get(link_id);
    if (!link) return null;
    if (!force_update) return link.data;
    const node22 = this.graph.getNodeById(link.origin_id);
    if (!node22) return link.data;
    if (node22.updateOutputData) {
      node22.updateOutputData(link.origin_slot);
    } else {
      node22.onExecute?.();
    }
    return link.data;
  }
  /**
   * Retrieves the input data type (in case this supports multiple input types)
   * @param {number} slot
   * @return {String} datatype in string format
   */
  getInputDataType(slot) {
    if (!this.inputs) return null;
    if (slot >= this.inputs.length || this.inputs[slot].link == null) return null;
    const link_id = this.inputs[slot].link;
    const link = this.graph._links.get(link_id);
    if (!link) return null;
    const node22 = this.graph.getNodeById(link.origin_id);
    if (!node22) return link.type;
    const output_info = node22.outputs[link.origin_slot];
    return output_info ? output_info.type : null;
  }
  /**
   * Retrieves the input data from one slot using its name instead of slot number
   * @param {String} slot_name
   * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
   * @return {*} data or if it is not connected returns null
   */
  getInputDataByName(slot_name, force_update) {
    const slot = this.findInputSlot(slot_name);
    return slot == -1 ? null : this.getInputData(slot, force_update);
  }
  /**
   * tells you if there is a connection in one input slot
   * @param {number} slot
   * @return {boolean}
   */
  isInputConnected(slot) {
    if (!this.inputs) return false;
    return slot < this.inputs.length && this.inputs[slot].link != null;
  }
  /**
   * tells you info about an input connection (which node, type, etc)
   * @param {number} slot
   * @return {Object} object or null { link: id, name: string, type: string or 0 }
   */
  getInputInfo(slot) {
    return !this.inputs || !(slot < this.inputs.length) ? null : this.inputs[slot];
  }
  /**
   * Returns the link info in the connection of an input slot
   * @param {number} slot
   * @return {LLink} object or null
   */
  getInputLink(slot) {
    if (!this.inputs) return null;
    if (slot < this.inputs.length) {
      const slot_info = this.inputs[slot];
      return this.graph._links.get(slot_info.link);
    }
    return null;
  }
  /**
   * returns the node connected in the input slot
   * @param {number} slot
   * @return {LGraphNode} node or null
   */
  getInputNode(slot) {
    if (!this.inputs) return null;
    if (slot >= this.inputs.length) return null;
    const input = this.inputs[slot];
    if (!input || input.link === null) return null;
    const link_info = this.graph._links.get(input.link);
    if (!link_info) return null;
    return this.graph.getNodeById(link_info.origin_id);
  }
  /**
   * returns the value of an input with this name, otherwise checks if there is a property with that name
   * @param {string} name
   * @return {*} value
   */
  getInputOrProperty(name) {
    if (!this.inputs || !this.inputs.length) {
      return this.properties ? this.properties[name] : null;
    }
    for (let i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
      const input_info = this.inputs[i2];
      if (name == input_info.name && input_info.link != null) {
        const link = this.graph._links.get(input_info.link);
        if (link) return link.data;
      }
    }
    return this.properties[name];
  }
  /**
   * tells you the last output data that went in that slot
   * @param {number} slot
   * @return {Object}  object or null
   */
  getOutputData(slot) {
    if (!this.outputs) return null;
    if (slot >= this.outputs.length) return null;
    const info = this.outputs[slot];
    return info._data;
  }
  /**
   * tells you info about an output connection (which node, type, etc)
   * @param {number} slot
   * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }
   */
  getOutputInfo(slot) {
    return !this.outputs || !(slot < this.outputs.length) ? null : this.outputs[slot];
  }
  /**
   * tells you if there is a connection in one output slot
   * @param {number} slot
   * @return {boolean}
   */
  isOutputConnected(slot) {
    if (!this.outputs) return false;
    return slot < this.outputs.length && this.outputs[slot].links?.length > 0;
  }
  /**
   * tells you if there is any connection in the output slots
   * @return {boolean}
   */
  isAnyOutputConnected() {
    if (!this.outputs) return false;
    for (let i2 = 0; i2 < this.outputs.length; ++i2) {
      if (this.outputs[i2].links && this.outputs[i2].links.length) {
        return true;
      }
    }
    return false;
  }
  /**
   * retrieves all the nodes connected to this output slot
   * @param {number} slot
   * @return {array}
   */
  getOutputNodes(slot) {
    if (!this.outputs || this.outputs.length == 0) return null;
    if (slot >= this.outputs.length) return null;
    const output = this.outputs[slot];
    if (!output.links || output.links.length == 0) return null;
    const r = [];
    for (let i2 = 0; i2 < output.links.length; i2++) {
      const link_id = output.links[i2];
      const link = this.graph._links.get(link_id);
      if (link) {
        const target_node = this.graph.getNodeById(link.target_id);
        if (target_node) {
          r.push(target_node);
        }
      }
    }
    return r;
  }
  addOnTriggerInput() {
    const trigS = this.findInputSlot("onTrigger");
    if (trigS == -1) {
      //!trigS || 
      this.addInput("onTrigger", LiteGraph.EVENT, { optional: true, nameLocked: true });
      return this.findInputSlot("onTrigger");
    }
    return trigS;
  }
  addOnExecutedOutput() {
    const trigS = this.findOutputSlot("onExecuted");
    if (trigS == -1) {
      //!trigS || 
      this.addOutput("onExecuted", LiteGraph.ACTION, { optional: true, nameLocked: true });
      return this.findOutputSlot("onExecuted");
    }
    return trigS;
  }
  onAfterExecuteNode(param, options3) {
    const trigS = this.findOutputSlot("onExecuted");
    if (trigS != -1) {
      this.triggerSlot(trigS, param, null, options3);
    }
  }
  changeMode(modeTo) {
    switch (modeTo) {
      case LGraphEventMode.ON_EVENT:
        break;
      case LGraphEventMode.ON_TRIGGER:
        this.addOnTriggerInput();
        this.addOnExecutedOutput();
        break;
      case LGraphEventMode.NEVER:
        break;
      case LGraphEventMode.ALWAYS:
        break;
      case LiteGraph.ON_REQUEST:
        break;
      default:
        return false;
    }
    this.mode = modeTo;
    return true;
  }
  /**
   * Triggers the node code execution, place a boolean/counter to mark the node as being executed
   * @param {*} param
   * @param {*} options
   */
  doExecute(param, options3) {
    options3 = options3 || {};
    if (this.onExecute) {
      options3.action_call ||= this.id + "_exec_" + Math.floor(Math.random() * 9999);
      this.graph.nodes_executing[this.id] = true;
      this.onExecute(param, options3);
      this.graph.nodes_executing[this.id] = false;
      this.exec_version = this.graph.iteration;
      if (options3?.action_call) {
        this.action_call = options3.action_call;
        this.graph.nodes_executedAction[this.id] = options3.action_call;
      }
    }
    this.execute_triggered = 2;
    this.onAfterExecuteNode?.(param, options3);
  }
  /**
   * Triggers an action, wrapped by logics to control execution flow
   * @param {String} action name
   * @param {*} param
   */
  actionDo(action, param, options3) {
    options3 = options3 || {};
    if (this.onAction) {
      options3.action_call ||= this.id + "_" + (action ? action : "action") + "_" + Math.floor(Math.random() * 9999);
      this.graph.nodes_actioning[this.id] = action ? action : "actioning";
      this.onAction(action, param, options3);
      this.graph.nodes_actioning[this.id] = false;
      if (options3?.action_call) {
        this.action_call = options3.action_call;
        this.graph.nodes_executedAction[this.id] = options3.action_call;
      }
    }
    this.action_triggered = 2;
    this.onAfterExecuteNode?.(param, options3);
  }
  /**
   * Triggers an event in this node, this will trigger any output with the same name
   * @param {String} event name ( "on_play", ... ) if action is equivalent to false then the event is send to all
   * @param {*} param
   */
  trigger(action, param, options3) {
    if (!this.outputs || !this.outputs.length) {
      return;
    }
    if (this.graph)
      this.graph._last_trigger_time = LiteGraph.getTime();
    for (let i2 = 0; i2 < this.outputs.length; ++i2) {
      const output = this.outputs[i2];
      if (!output || output.type !== LiteGraph.EVENT || action && output.name != action)
        continue;
      this.triggerSlot(i2, param, null, options3);
    }
  }
  /**
   * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes
   * @param {Number} slot the index of the output slot
   * @param {*} param
   * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
   */
  triggerSlot(slot, param, link_id, options3) {
    options3 = options3 || {};
    if (!this.outputs) return;
    if (slot == null) {
      console.error("slot must be a number");
      return;
    }
    if (typeof slot !== "number")
      console.warn("slot must be a number, use node.trigger('name') if you want to use a string");
    const output = this.outputs[slot];
    if (!output) return;
    const links = output.links;
    if (!links || !links.length) return;
    if (this.graph)
      this.graph._last_trigger_time = LiteGraph.getTime();
    for (let k = 0; k < links.length; ++k) {
      const id3 = links[k];
      if (link_id != null && link_id != id3) continue;
      const link_info = this.graph._links.get(id3);
      if (!link_info) continue;
      link_info._last_time = LiteGraph.getTime();
      const node22 = this.graph.getNodeById(link_info.target_id);
      if (!node22) continue;
      if (node22.mode === LGraphEventMode.ON_TRIGGER) {
        if (!options3.action_call) options3.action_call = this.id + "_trigg_" + Math.floor(Math.random() * 9999);
        node22.doExecute?.(param, options3);
      } else if (node22.onAction) {
        if (!options3.action_call) options3.action_call = this.id + "_act_" + Math.floor(Math.random() * 9999);
        const target_connection = node22.inputs[link_info.target_slot];
        node22.actionDo(target_connection.name, param, options3);
      }
    }
  }
  /**
   * clears the trigger slot animation
   * @param {Number} slot the index of the output slot
   * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
   */
  clearTriggeredSlot(slot, link_id) {
    if (!this.outputs) return;
    const output = this.outputs[slot];
    if (!output) return;
    const links = output.links;
    if (!links || !links.length) return;
    for (let k = 0; k < links.length; ++k) {
      const id3 = links[k];
      if (link_id != null && link_id != id3) continue;
      const link_info = this.graph._links.get(id3);
      if (!link_info) continue;
      link_info._last_time = 0;
    }
  }
  /**
   * changes node size and triggers callback
   * @param {vec2} size
   */
  setSize(size2) {
    this.size = size2;
    this.onResize?.(this.size);
  }
  /**
   * add a new property to this node
   * @param {string} name
   * @param {*} default_value
   * @param {string} type string defining the output type ("vec3","number",...)
   * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)
   */
  addProperty(name, default_value, type, extra_info) {
    const o = { name, type, default_value };
    if (extra_info) {
      for (const i2 in extra_info) {
        o[i2] = extra_info[i2];
      }
    }
    this.properties_info ||= [];
    this.properties_info.push(o);
    this.properties ||= {};
    this.properties[name] = default_value;
    return o;
  }
  /**
   * add a new output slot to use in this node
   * @param {string} name
   * @param {string} type string defining the output type ("vec3","number",...)
   * @param {Object} extra_info this can be used to have special properties of an output (label, special color, position, etc)
   */
  addOutput(name, type, extra_info) {
    const output = { name, type, links: null };
    if (extra_info) {
      for (const i2 in extra_info) {
        output[i2] = extra_info[i2];
      }
    }
    this.outputs ||= [];
    this.outputs.push(output);
    this.onOutputAdded?.(output);
    if (LiteGraph.auto_load_slot_types) LiteGraph.registerNodeAndSlotType(this, type, true);
    this.setSize(this.computeSize());
    this.setDirtyCanvas(true, true);
    return output;
  }
  /**
   * add a new output slot to use in this node
   * @param {Array} array of triplets like [[name,type,extra_info],[...]]
   */
  addOutputs(array) {
    for (let i2 = 0; i2 < array.length; ++i2) {
      const info = array[i2];
      const o = { name: info[0], type: info[1], links: null };
      if (array[2]) {
        for (const j in info[2]) {
          o[j] = info[2][j];
        }
      }
      this.outputs ||= [];
      this.outputs.push(o);
      this.onOutputAdded?.(o);
      if (LiteGraph.auto_load_slot_types) LiteGraph.registerNodeAndSlotType(this, info[1], true);
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(true, true);
  }
  /**
   * remove an existing output slot
   * @param {number} slot
   */
  removeOutput(slot) {
    this.disconnectOutput(slot);
    this.outputs.splice(slot, 1);
    for (let i2 = slot; i2 < this.outputs.length; ++i2) {
      if (!this.outputs[i2] || !this.outputs[i2].links)
        continue;
      const links = this.outputs[i2].links;
      for (let j = 0; j < links.length; ++j) {
        const link = this.graph._links.get(links[j]);
        if (!link) continue;
        link.origin_slot -= 1;
      }
    }
    this.setSize(this.computeSize());
    this.onOutputRemoved?.(slot);
    this.setDirtyCanvas(true, true);
  }
  /**
   * add a new input slot to use in this node
   * @param {string} name
   * @param {string} type string defining the input type ("vec3","number",...), it its a generic one use 0
   * @param {Object} extra_info this can be used to have special properties of an input (label, color, position, etc)
   */
  addInput(name, type, extra_info) {
    type = type || 0;
    const input = { name, type, link: null };
    if (extra_info) {
      for (const i2 in extra_info) {
        input[i2] = extra_info[i2];
      }
    }
    this.inputs ||= [];
    this.inputs.push(input);
    this.setSize(this.computeSize());
    this.onInputAdded?.(input);
    LiteGraph.registerNodeAndSlotType(this, type);
    this.setDirtyCanvas(true, true);
    return input;
  }
  /**
   * add several new input slots in this node
   * @param {Array} array of triplets like [[name,type,extra_info],[...]]
   */
  addInputs(array) {
    for (let i2 = 0; i2 < array.length; ++i2) {
      const info = array[i2];
      const o = { name: info[0], type: info[1], link: null };
      if (array[2]) {
        for (const j in info[2]) {
          o[j] = info[2][j];
        }
      }
      this.inputs ||= [];
      this.inputs.push(o);
      this.onInputAdded?.(o);
      LiteGraph.registerNodeAndSlotType(this, info[1]);
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(true, true);
  }
  /**
   * remove an existing input slot
   * @param {number} slot
   */
  removeInput(slot) {
    this.disconnectInput(slot);
    const slot_info = this.inputs.splice(slot, 1);
    for (let i2 = slot; i2 < this.inputs.length; ++i2) {
      if (!this.inputs[i2]) continue;
      const link = this.graph._links.get(this.inputs[i2].link);
      if (!link) continue;
      link.target_slot -= 1;
    }
    this.setSize(this.computeSize());
    this.onInputRemoved?.(slot, slot_info[0]);
    this.setDirtyCanvas(true, true);
  }
  /**
   * add an special connection to this node (used for special kinds of graphs)
   * @param {string} name
   * @param {string} type string defining the input type ("vec3","number",...)
   * @param {[x,y]} pos position of the connection inside the node
   * @param {string} direction if is input or output
   */
  addConnection(name, type, pos2, direction) {
    const o = {
      name,
      type,
      pos: pos2,
      direction,
      links: null
    };
    this.connections.push(o);
    return o;
  }
  /**
   * computes the minimum size of a node according to its inputs and output slots
   * @param out
   * @return the total size
   */
  computeSize(out) {
    const ctorSize = this.constructor.size;
    if (ctorSize) return [ctorSize[0], ctorSize[1]];
    let rows = Math.max(
      this.inputs ? this.inputs.length : 1,
      this.outputs ? this.outputs.length : 1
    );
    const size2 = out || new Float32Array([0, 0]);
    rows = Math.max(rows, 1);
    const font_size = LiteGraph.NODE_TEXT_SIZE;
    const title_width = compute_text_size(this.title);
    let input_width = 0;
    let output_width = 0;
    if (this.inputs) {
      for (let i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
        const input = this.inputs[i2];
        const text = input.label || input.name || "";
        const text_width = compute_text_size(text);
        if (input_width < text_width)
          input_width = text_width;
      }
    }
    if (this.outputs) {
      for (let i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
        const output = this.outputs[i2];
        const text = output.label || output.name || "";
        const text_width = compute_text_size(text);
        if (output_width < text_width)
          output_width = text_width;
      }
    }
    size2[0] = Math.max(input_width + output_width + 10, title_width);
    size2[0] = Math.max(size2[0], LiteGraph.NODE_WIDTH);
    if (this.widgets?.length)
      size2[0] = Math.max(size2[0], LiteGraph.NODE_WIDTH * 1.5);
    size2[1] = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT;
    let widgets_height = 0;
    if (this.widgets?.length) {
      for (let i2 = 0, l = this.widgets.length; i2 < l; ++i2) {
        const widget = this.widgets[i2];
        if (widget.hidden || widget.advanced && !this.showAdvanced) continue;
        widgets_height += widget.computeSize ? widget.computeSize(size2[0])[1] + 4 : LiteGraph.NODE_WIDGET_HEIGHT + 4;
      }
      widgets_height += 8;
    }
    if (this.widgets_up)
      size2[1] = Math.max(size2[1], widgets_height);
    else if (this.widgets_start_y != null)
      size2[1] = Math.max(size2[1], widgets_height + this.widgets_start_y);
    else
      size2[1] += widgets_height;
    function compute_text_size(text) {
      return text ? font_size * text.length * 0.6 : 0;
    }
    __name(compute_text_size, "compute_text_size");
    if (this.constructor.min_height && size2[1] < this.constructor.min_height) {
      size2[1] = this.constructor.min_height;
    }
    size2[1] += 6;
    return size2;
  }
  inResizeCorner(canvasX, canvasY) {
    const rows = this.outputs ? this.outputs.length : 1;
    const outputs_offset = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT;
    return isInsideRectangle(
      canvasX,
      canvasY,
      this.pos[0] + this.size[0] - 15,
      this.pos[1] + Math.max(this.size[1] - 15, outputs_offset),
      20,
      20
    );
  }
  /**
   * returns all the info available about a property of this node.
   *
   * @param {String} property name of the property
   * @return {Object} the object with all the available info
   */
  getPropertyInfo(property) {
    let info = null;
    if (this.properties_info) {
      for (let i2 = 0; i2 < this.properties_info.length; ++i2) {
        if (this.properties_info[i2].name == property) {
          info = this.properties_info[i2];
          break;
        }
      }
    }
    if (this.constructor["@" + property])
      info = this.constructor["@" + property];
    if (this.constructor.widgets_info?.[property])
      info = this.constructor.widgets_info[property];
    if (!info && this.onGetPropertyInfo) {
      info = this.onGetPropertyInfo(property);
    }
    info ||= {};
    info.type ||= typeof this.properties[property];
    if (info.widget == "combo")
      info.type = "enum";
    return info;
  }
  /**
   * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties
   *
   * @param {String} type the widget type (could be "number","string","combo"
   * @param {String} name the text to show on the widget
   * @param {String} value the default value
   * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)
   * @param {Object} options the object that contains special properties of this widget
   * @return {Object} the created widget object
   */
  addWidget(type, name, value3, callback, options3) {
    this.widgets ||= [];
    if (!options3 && callback && typeof callback === "object") {
      options3 = callback;
      callback = null;
    }
    if (options3 && typeof options3 === "string")
      options3 = { property: options3 };
    if (callback && typeof callback === "string") {
      options3 ||= {};
      options3.property = callback;
      callback = null;
    }
    if (callback && typeof callback !== "function") {
      console.warn("addWidget: callback must be a function");
      callback = null;
    }
    const w2 = {
      // @ts-expect-error Type check or just assert?
      type: type.toLowerCase(),
      name,
      value: value3,
      callback,
      options: options3 || {}
    };
    if (w2.options.y !== void 0) {
      w2.y = w2.options.y;
    }
    if (!callback && !w2.options.callback && !w2.options.property) {
      console.warn("LiteGraph addWidget(...) without a callback or property assigned");
    }
    if (type == "combo" && !w2.options.values) {
      throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
    }
    this.widgets.push(w2);
    this.setSize(this.computeSize());
    return w2;
  }
  addCustomWidget(custom_widget) {
    this.widgets ||= [];
    this.widgets.push(custom_widget);
    return custom_widget;
  }
  move(deltaX, deltaY) {
    if (this.pinned) return;
    this.pos[0] += deltaX;
    this.pos[1] += deltaY;
  }
  /**
   * Internal method to measure the node for rendering.  Prefer {@link boundingRect} where possible.
   * 
   * Populates {@link out} with the results in graph space.
   * Adjusts for title and collapsed status, but does not call {@link onBounding}.
   * @param out `x, y, width, height` are written to this array.
   * @param pad Expands the area by this amount on each side.  Default: 0
   */
  measure(out, pad = 0) {
    const titleMode = this.constructor.title_mode;
    const renderTitle = titleMode != TitleMode.TRANSPARENT_TITLE && titleMode != TitleMode.NO_TITLE;
    const titleHeight = renderTitle ? LiteGraph.NODE_TITLE_HEIGHT : 0;
    out[0] = this.pos[0] - pad;
    out[1] = this.pos[1] + -titleHeight - pad;
    if (!this.flags?.collapsed) {
      out[2] = this.size[0] + 2 * pad;
      out[3] = this.size[1] + titleHeight + 2 * pad;
    } else {
      out[2] = (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + 2 * pad;
      out[3] = LiteGraph.NODE_TITLE_HEIGHT + 2 * pad;
    }
  }
  /**
   * returns the bounding of the object, used for rendering purposes
   * @param out {Float32Array[4]?} [optional] a place to store the output, to free garbage
   * @param includeExternal {boolean?} [optional] set to true to include the shadow and connection points in the bounding calculation
   * @return {Float32Array[4]} the bounding box in format of [topleft_cornerx, topleft_cornery, width, height]
   */
  getBounding(out, includeExternal) {
    out ||= new Float32Array(4);
    const rect = includeExternal ? this.renderArea : this.boundingRect;
    out[0] = rect[0];
    out[1] = rect[1];
    out[2] = rect[2];
    out[3] = rect[3];
    return out;
  }
  /**
   * Calculates the render area of this node, populating both {@link boundingRect} and {@link renderArea}.
   * Called automatically at the start of every frame.
   */
  updateArea() {
    const bounds = this.#boundingRect;
    this.measure(bounds);
    this.onBounding?.(bounds);
    const renderArea = this.#renderArea;
    renderArea.set(bounds);
    renderArea[0] -= 4;
    renderArea[1] -= 4;
    renderArea[2] += 6 + 4;
    renderArea[3] += 5 + 4;
  }
  /**
   * checks if a point is inside the shape of a node
   * @param {number} x
   * @param {number} y
   * @return {boolean}
   */
  isPointInside(x2, y2) {
    return isXyInRectangle(x2, y2, this.boundingRect);
  }
  /**
   * Checks if the provided point is inside this node's collapse button area.
   * @param x X co-ordinate to check
   * @param y Y co-ordinate to check
   * @returns true if the x,y point is in the collapse button area, otherwise false
   */
  isPointInCollapse(x2, y2) {
    const squareLength = LiteGraph.NODE_TITLE_HEIGHT;
    return isInsideRectangle(x2, y2, this.pos[0], this.pos[1] - squareLength, squareLength, squareLength);
  }
  /**
   * checks if a point is inside a node slot, and returns info about which slot
   * @param x
   * @param y
   * @returns if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }
   */
  getSlotInPosition(x2, y2) {
    const link_pos = new Float32Array(2);
    if (this.inputs) {
      for (let i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
        const input = this.inputs[i2];
        this.getConnectionPos(true, i2, link_pos);
        if (isInsideRectangle(x2, y2, link_pos[0] - 10, link_pos[1] - 5, 20, 10)) {
          return { input, slot: i2, link_pos };
        }
      }
    }
    if (this.outputs) {
      for (let i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
        const output = this.outputs[i2];
        this.getConnectionPos(false, i2, link_pos);
        if (isInsideRectangle(x2, y2, link_pos[0] - 10, link_pos[1] - 5, 20, 10)) {
          return { output, slot: i2, link_pos };
        }
      }
    }
    return null;
  }
  findInputSlot(name, returnObj = false) {
    if (!this.inputs) return -1;
    for (let i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
      if (name == this.inputs[i2].name) {
        return !returnObj ? i2 : this.inputs[i2];
      }
    }
    return -1;
  }
  findOutputSlot(name, returnObj = false) {
    if (!this.outputs) return -1;
    for (let i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
      if (name == this.outputs[i2].name) {
        return !returnObj ? i2 : this.outputs[i2];
      }
    }
    return -1;
  }
  findInputSlotFree(optsIn) {
    return this.#findFreeSlot(this.inputs, optsIn);
  }
  findOutputSlotFree(optsIn) {
    return this.#findFreeSlot(this.outputs, optsIn);
  }
  /**
   * Finds the next free slot
   * @param slots The slots to search, i.e. this.inputs or this.outputs
   * @param options Options
   */
  #findFreeSlot(slots, options3) {
    const defaults2 = {
      returnObj: false,
      typesNotAccepted: []
    };
    const opts = Object.assign(defaults2, options3 || {});
    const length = slots?.length;
    if (!(length > 0)) return -1;
    for (let i2 = 0; i2 < length; ++i2) {
      const slot = slots[i2];
      if (!slot || slot.link || slot.links?.length) continue;
      if (opts.typesNotAccepted?.includes?.(slot.type)) continue;
      return !opts.returnObj ? i2 : slot;
    }
    return -1;
  }
  findInputSlotByType(type, returnObj, preferFreeSlot, doNotUseOccupied) {
    return this.#findSlotByType(this.inputs, type, returnObj, preferFreeSlot, doNotUseOccupied);
  }
  findOutputSlotByType(type, returnObj, preferFreeSlot, doNotUseOccupied) {
    return this.#findSlotByType(this.outputs, type, returnObj, preferFreeSlot, doNotUseOccupied);
  }
  findSlotByType(input, type, returnObj, preferFreeSlot, doNotUseOccupied) {
    return input ? this.#findSlotByType(this.inputs, type, returnObj, preferFreeSlot, doNotUseOccupied) : this.#findSlotByType(this.outputs, type, returnObj, preferFreeSlot, doNotUseOccupied);
  }
  /**
   * Finds a matching slot from those provided, returning the slot itself or its index in {@link slots}.
   * @param slots Slots to search (this.inputs or this.outputs)
   * @param type Type of slot to look for
   * @param returnObj If true, returns the slot itself.  Otherwise, the index.
   * @param preferFreeSlot Prefer a free slot, but if none are found, fall back to an occupied slot.
   * @param doNotUseOccupied Do not fall back to occupied slots.
   * @see {findSlotByType}
   * @see {findOutputSlotByType}
   * @see {findInputSlotByType}
   * @returns If a match is found, the slot if returnObj is true, otherwise the index.  If no matches are found, -1
   */
  #findSlotByType(slots, type, returnObj, preferFreeSlot, doNotUseOccupied) {
    const length = slots?.length;
    if (!length) return -1;
    if (type == "" || type == "*") type = 0;
    const sourceTypes = String(type).toLowerCase().split(",");
    let occupiedSlot = null;
    for (let i2 = 0; i2 < length; ++i2) {
      const slot = slots[i2];
      const destTypes = slot.type == "0" || slot.type == "*" ? ["0"] : String(slot.type).toLowerCase().split(",");
      for (const sourceType of sourceTypes) {
        const source = sourceType == "_event_" ? LiteGraph.EVENT : sourceType;
        for (const destType of destTypes) {
          const dest = destType == "_event_" ? LiteGraph.EVENT : destType;
          if (source == dest || source === "*" || dest === "*") {
            if (preferFreeSlot && (slot.links?.length || slot.link != null)) {
              occupiedSlot ??= returnObj ? slot : i2;
              continue;
            }
            return returnObj ? slot : i2;
          }
        }
      }
    }
    return doNotUseOccupied ? -1 : occupiedSlot ?? -1;
  }
  /**
   * Determines the slot index to connect to when attempting to connect by type.
   * 
   * @param findInputs If true, searches for an input.  Otherwise, an output.
   * @param node The node at the other end of the connection.
   * @param slotType The type of slot at the other end of the connection.
   * @param options Search restrictions to adhere to.
   * @see {connectByType}
   * @see {connectByTypeOutput}
   */
  findConnectByTypeSlot(findInputs, node22, slotType, options3) {
    if (options3 && typeof options3 === "object") {
      if ("firstFreeIfInputGeneralInCase" in options3) options3.wildcardToTyped = !!options3.firstFreeIfInputGeneralInCase;
      if ("firstFreeIfOutputGeneralInCase" in options3) options3.wildcardToTyped = !!options3.firstFreeIfOutputGeneralInCase;
      if ("generalTypeInCase" in options3) options3.typedToWildcard = !!options3.generalTypeInCase;
    }
    const optsDef = {
      createEventInCase: true,
      wildcardToTyped: true,
      typedToWildcard: true
    };
    const opts = Object.assign(optsDef, options3);
    if (node22 && typeof node22 === "number") {
      node22 = this.graph.getNodeById(node22);
    }
    const slot = node22.findSlotByType(findInputs, slotType, false, true);
    if (slot >= 0 && slot !== null) return slot;
    if (opts.createEventInCase && slotType == LiteGraph.EVENT) {
      if (findInputs) return -1;
      if (LiteGraph.do_add_triggers_slots) return node22.addOnExecutedOutput();
    }
    if (opts.typedToWildcard) {
      const generalSlot = node22.findSlotByType(findInputs, 0, false, true, true);
      if (generalSlot >= 0) return generalSlot;
    }
    if (opts.wildcardToTyped && (slotType == 0 || slotType == "*" || slotType == "")) {
      const opt = { typesNotAccepted: [LiteGraph.EVENT] };
      const nonEventSlot = findInputs ? node22.findInputSlotFree(opt) : node22.findOutputSlotFree(opt);
      if (nonEventSlot >= 0) return nonEventSlot;
    }
    return null;
  }
  /**
   * connect this node output to the input of another node BY TYPE
   * @param {number} slot (could be the number of the slot or the string with the name of the slot)
   * @param {LGraphNode} target_node the target node
   * @param {string} target_slotType the input slot type of the target node
   * @return {Object} the link_info is created, otherwise null
   */
  connectByType(slot, target_node, target_slotType, optsIn) {
    const slotIndex = this.findConnectByTypeSlot(true, target_node, target_slotType, optsIn);
    if (slotIndex !== null) return this.connect(slot, target_node, slotIndex, optsIn?.afterRerouteId);
    console.debug("[connectByType]: no way to connect type: ", target_slotType, " to node: ", target_node);
    return null;
  }
  /**
   * connect this node input to the output of another node BY TYPE
   * @method connectByType
   * @param {number | string} slot (could be the number of the slot or the string with the name of the slot)
   * @param {LGraphNode} source_node the target node
   * @param {string} source_slotType the output slot type of the target node
   * @return {Object} the link_info is created, otherwise null
   */
  connectByTypeOutput(slot, source_node, source_slotType, optsIn) {
    if (typeof optsIn === "object") {
      if ("firstFreeIfInputGeneralInCase" in optsIn) optsIn.wildcardToTyped = !!optsIn.firstFreeIfInputGeneralInCase;
      if ("generalTypeInCase" in optsIn) optsIn.typedToWildcard = !!optsIn.generalTypeInCase;
    }
    const slotIndex = this.findConnectByTypeSlot(false, source_node, source_slotType, optsIn);
    if (slotIndex !== null) return source_node.connect(slotIndex, this, slot, optsIn?.afterRerouteId);
    console.debug("[connectByType]: no way to connect type: ", source_slotType, " to node: ", source_node);
    return null;
  }
  /**
   * Connect an output of this node to an input of another node
   * @param {number | string} slot (could be the number of the slot or the string with the name of the slot)
   * @param {LGraphNode} target_node the target node
   * @param {number | string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)
   * @return {Object} the link_info is created, otherwise null
   */
  connect(slot, target_node, target_slot, afterRerouteId) {
    let targetIndex;
    const graph = this.graph;
    if (!graph) {
      console.log("Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.");
      return null;
    }
    if (typeof slot === "string") {
      slot = this.findOutputSlot(slot);
      if (slot == -1) {
        if (LiteGraph.debug) console.log("Connect: Error, no slot of name " + slot);
        return null;
      }
    } else if (!this.outputs || slot >= this.outputs.length) {
      if (LiteGraph.debug) console.log("Connect: Error, slot number not found");
      return null;
    }
    if (target_node && typeof target_node === "number") {
      target_node = graph.getNodeById(target_node);
    }
    if (!target_node) throw "target node is null";
    if (target_node == this) return null;
    if (typeof target_slot === "string") {
      targetIndex = target_node.findInputSlot(target_slot);
      if (targetIndex == -1) {
        if (LiteGraph.debug) console.log("Connect: Error, no slot of name " + targetIndex);
        return null;
      }
    } else if (target_slot === LiteGraph.EVENT) {
      if (LiteGraph.do_add_triggers_slots) {
        target_node.changeMode(LGraphEventMode.ON_TRIGGER);
        targetIndex = target_node.findInputSlot("onTrigger");
      } else {
        return null;
      }
    } else if (typeof target_slot === "number") {
      targetIndex = target_slot;
    } else {
      targetIndex = 0;
    }
    if (target_node.onBeforeConnectInput) {
      const requestedIndex = target_node.onBeforeConnectInput(targetIndex, target_slot);
      targetIndex = typeof requestedIndex === "number" ? requestedIndex : null;
    }
    if (targetIndex === null || !target_node.inputs || targetIndex >= target_node.inputs.length) {
      if (LiteGraph.debug) console.log("Connect: Error, slot number not found");
      return null;
    }
    let changed = false;
    const input = target_node.inputs[targetIndex];
    let link_info = null;
    const output = this.outputs[slot];
    if (!this.outputs[slot]) return null;
    if (!LiteGraph.isValidConnection(output.type, input.type)) {
      this.setDirtyCanvas(false, true);
      if (changed) graph.connectionChange(this, link_info);
      return null;
    }
    if (target_node.onConnectInput?.(targetIndex, output.type, output, this, slot) === false)
      return null;
    if (this.onConnectOutput?.(slot, input.type, input, target_node, targetIndex) === false)
      return null;
    if (target_node.inputs[targetIndex]?.link != null) {
      graph.beforeChange();
      target_node.disconnectInput(targetIndex, true);
      changed = true;
    }
    if (output.links?.length) {
      if (output.type === LiteGraph.EVENT && !LiteGraph.allow_multi_output_for_events) {
        graph.beforeChange();
        this.disconnectOutput(slot, false, { doProcessChange: false });
        changed = true;
      }
    }
    const nextId = ++graph.state.lastLinkId;
    link_info = new LLink(
      nextId,
      input.type || output.type,
      this.id,
      slot,
      target_node.id,
      targetIndex,
      afterRerouteId
    );
    graph._links.set(link_info.id, link_info);
    output.links ??= [];
    output.links.push(link_info.id);
    target_node.inputs[targetIndex].link = link_info.id;
    LLink.getReroutes(graph, link_info).forEach((x2) => x2?.linkIds.add(nextId));
    graph._version++;
    this.onConnectionsChange?.(
      NodeSlotType.OUTPUT,
      slot,
      true,
      link_info,
      output
    );
    target_node.onConnectionsChange?.(
      NodeSlotType.INPUT,
      targetIndex,
      true,
      link_info,
      input
    );
    graph.onNodeConnectionChange?.(
      NodeSlotType.INPUT,
      target_node,
      targetIndex,
      this,
      slot
    );
    graph.onNodeConnectionChange?.(
      NodeSlotType.OUTPUT,
      this,
      slot,
      target_node,
      targetIndex
    );
    this.setDirtyCanvas(false, true);
    graph.afterChange();
    graph.connectionChange(this);
    return link_info;
  }
  /**
   * disconnect one output to an specific node
   * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
   * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]
   * @return {boolean} if it was disconnected successfully
   */
  disconnectOutput(slot, target_node) {
    if (typeof slot === "string") {
      slot = this.findOutputSlot(slot);
      if (slot == -1) {
        if (LiteGraph.debug) console.log("Connect: Error, no slot of name " + slot);
        return false;
      }
    } else if (!this.outputs || slot >= this.outputs.length) {
      if (LiteGraph.debug) console.log("Connect: Error, slot number not found");
      return false;
    }
    const output = this.outputs[slot];
    if (!output || !output.links || output.links.length == 0)
      return false;
    const graph = this.graph;
    if (target_node) {
      if (typeof target_node === "number")
        target_node = graph.getNodeById(target_node);
      if (!target_node)
        throw "Target Node not found";
      for (let i2 = 0, l = output.links.length; i2 < l; i2++) {
        const link_id = output.links[i2];
        const link_info = graph._links.get(link_id);
        if (link_info.target_id == target_node.id) {
          output.links.splice(i2, 1);
          const input = target_node.inputs[link_info.target_slot];
          input.link = null;
          graph._links.delete(link_id);
          graph._version++;
          target_node.onConnectionsChange?.(
            NodeSlotType.INPUT,
            link_info.target_slot,
            false,
            link_info,
            input
          );
          this.onConnectionsChange?.(
            NodeSlotType.OUTPUT,
            slot,
            false,
            link_info,
            output
          );
          graph.onNodeConnectionChange?.(NodeSlotType.OUTPUT, this, slot);
          graph.onNodeConnectionChange?.(NodeSlotType.INPUT, target_node, link_info.target_slot);
          break;
        }
      }
    } else {
      for (let i2 = 0, l = output.links.length; i2 < l; i2++) {
        const link_id = output.links[i2];
        const link_info = graph._links.get(link_id);
        if (!link_info) continue;
        target_node = graph.getNodeById(link_info.target_id);
        graph._version++;
        if (target_node) {
          const input = target_node.inputs[link_info.target_slot];
          input.link = null;
          target_node.onConnectionsChange?.(
            NodeSlotType.INPUT,
            link_info.target_slot,
            false,
            link_info,
            input
          );
        }
        graph._links.delete(link_id);
        this.onConnectionsChange?.(
          NodeSlotType.OUTPUT,
          slot,
          false,
          link_info,
          output
        );
        graph.onNodeConnectionChange?.(NodeSlotType.OUTPUT, this, slot);
        graph.onNodeConnectionChange?.(NodeSlotType.INPUT, target_node, link_info.target_slot);
      }
      output.links = null;
    }
    this.setDirtyCanvas(false, true);
    graph.connectionChange(this);
    return true;
  }
  /**
   * Disconnect one input
   * @param slot Input slot index, or the name of the slot
   * @param keepReroutes If `true`, reroutes will not be garbage collected.
   * @return true if disconnected successfully or already disconnected, otherwise false
   */
  disconnectInput(slot, keepReroutes) {
    if (typeof slot === "string") {
      slot = this.findInputSlot(slot);
      if (slot == -1) {
        if (LiteGraph.debug) console.log("Connect: Error, no slot of name " + slot);
        return false;
      }
    } else if (!this.inputs || slot >= this.inputs.length) {
      if (LiteGraph.debug) {
        console.log("Connect: Error, slot number not found");
      }
      return false;
    }
    const input = this.inputs[slot];
    if (!input) return false;
    const link_id = this.inputs[slot].link;
    if (link_id != null) {
      this.inputs[slot].link = null;
      const link_info = this.graph._links.get(link_id);
      if (link_info) {
        const target_node = this.graph.getNodeById(link_info.origin_id);
        if (!target_node) return false;
        const output = target_node.outputs[link_info.origin_slot];
        if (!(output?.links?.length > 0)) return false;
        let i2 = 0;
        for (const l = output.links.length; i2 < l; i2++) {
          if (output.links[i2] == link_id) {
            output.links.splice(i2, 1);
            break;
          }
        }
        link_info.disconnect(this.graph, keepReroutes);
        if (this.graph) this.graph._version++;
        this.onConnectionsChange?.(
          NodeSlotType.INPUT,
          slot,
          false,
          link_info,
          input
        );
        target_node.onConnectionsChange?.(
          NodeSlotType.OUTPUT,
          i2,
          false,
          link_info,
          output
        );
        this.graph?.onNodeConnectionChange?.(NodeSlotType.OUTPUT, target_node, i2);
        this.graph?.onNodeConnectionChange?.(NodeSlotType.INPUT, this, slot);
      }
    }
    this.setDirtyCanvas(false, true);
    this.graph?.connectionChange(this);
    return true;
  }
  /**
   * returns the center of a connection point in canvas coords
   * @param {boolean} is_input true if if a input slot, false if it is an output
   * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
   * @param {vec2} out [optional] a place to store the output, to free garbage
   * @return {[x,y]} the position
   **/
  getConnectionPos(is_input, slot_number, out) {
    out ||= new Float32Array(2);
    const num_slots = is_input ? this.inputs?.length ?? 0 : this.outputs?.length ?? 0;
    const offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5;
    if (this.flags.collapsed) {
      const w2 = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;
      if (this.horizontal) {
        out[0] = this.pos[0] + w2 * 0.5;
        out[1] = is_input ? this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT : this.pos[1];
      } else {
        out[0] = is_input ? this.pos[0] : this.pos[0] + w2;
        out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5;
      }
      return out;
    }
    if (is_input && slot_number == -1) {
      out[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
      out[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
      return out;
    }
    if (is_input && num_slots > slot_number && this.inputs[slot_number].pos) {
      out[0] = this.pos[0] + this.inputs[slot_number].pos[0];
      out[1] = this.pos[1] + this.inputs[slot_number].pos[1];
      return out;
    } else if (!is_input && num_slots > slot_number && this.outputs[slot_number].pos) {
      out[0] = this.pos[0] + this.outputs[slot_number].pos[0];
      out[1] = this.pos[1] + this.outputs[slot_number].pos[1];
      return out;
    }
    if (this.horizontal) {
      out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);
      out[1] = is_input ? this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT : this.pos[1] + this.size[1];
      return out;
    }
    out[0] = is_input ? this.pos[0] + offset : this.pos[0] + this.size[0] + 1 - offset;
    out[1] = this.pos[1] + (slot_number + 0.7) * LiteGraph.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);
    return out;
  }
  /* Force align to grid */
  alignToGrid() {
    this.pos[0] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE);
    this.pos[1] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);
  }
  /* Console output */
  trace(msg) {
    this.console ||= [];
    this.console.push(msg);
    if (this.console.length > LGraphNode.MAX_CONSOLE)
      this.console.shift();
    this.graph.onNodeTrace?.(this, msg);
  }
  /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */
  setDirtyCanvas(dirty_foreground, dirty_background) {
    this.graph?.canvasAction((c) => c.setDirty(dirty_foreground, dirty_background));
  }
  loadImage(url) {
    const img = new Image();
    img.src = LiteGraph.node_images_path + url;
    img.ready = false;
    const that2 = this;
    img.onload = function() {
      this.ready = true;
      that2.setDirtyCanvas(true);
    };
    return img;
  }
  /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */
  captureInput(v2) {
    if (!this.graph || !this.graph.list_of_graphcanvas)
      return;
    const list = this.graph.list_of_graphcanvas;
    for (let i2 = 0; i2 < list.length; ++i2) {
      const c = list[i2];
      if (!v2 && c.node_capturing_input != this)
        continue;
      c.node_capturing_input = v2 ? this : null;
    }
  }
  get collapsed() {
    return !!this.flags.collapsed;
  }
  get collapsible() {
    return !this.pinned && this.constructor.collapsable !== false;
  }
  /**
   * Toggle node collapse (makes it smaller on the canvas)
   **/
  collapse(force) {
    if (!this.collapsible && !force) return;
    this.graph._version++;
    this.flags.collapsed = !this.flags.collapsed;
    this.setDirtyCanvas(true, true);
  }
  /**
   * Toggles advanced mode of the node, showing advanced widgets
   */
  toggleAdvanced() {
    if (!this.widgets?.some((w2) => w2.advanced)) return;
    this.graph._version++;
    this.showAdvanced = !this.showAdvanced;
    const prefSize = this.computeSize();
    if (this.size[0] < prefSize[0] || this.size[1] < prefSize[1]) {
      this.setSize([Math.max(this.size[0], prefSize[0]), Math.max(this.size[1], prefSize[1])]);
    }
    this.setDirtyCanvas(true, true);
  }
  get pinned() {
    return !!this.flags.pinned;
  }
  /**
   * Prevents the node being accidentally moved or resized by mouse interaction.
   * Toggles pinned state if no value is provided.
   **/
  pin(v2) {
    this.graph._version++;
    this.flags.pinned = v2 === void 0 ? !this.flags.pinned : v2;
    this.resizable = !this.pinned;
    if (!this.pinned)
      delete this.flags.pinned;
  }
  unpin() {
    this.pin(false);
  }
  localToScreen(x2, y2, dragAndScale) {
    return [
      (x2 + this.pos[0]) * dragAndScale.scale + dragAndScale.offset[0],
      (y2 + this.pos[1]) * dragAndScale.scale + dragAndScale.offset[1]
    ];
  }
  get width() {
    return this.collapsed ? this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH : this.size[0];
  }
  get height() {
    return this.collapsed ? LiteGraph.NODE_COLLAPSED_HEIGHT : this.size[1];
  }
  drawBadges(ctx, { gap = 2 } = {}) {
    const badgeInstances = this.badges.map((badge) => badge instanceof LGraphBadge ? badge : badge());
    const isLeftAligned = this.badgePosition === BadgePosition.TopLeft;
    let currentX = isLeftAligned ? 0 : this.width - badgeInstances.reduce((acc, badge) => acc + badge.getWidth(ctx) + gap, 0);
    const y2 = -(LiteGraph.NODE_TITLE_HEIGHT + gap);
    for (const badge of badgeInstances) {
      badge.draw(ctx, currentX, y2 - badge.height);
      currentX += badge.getWidth(ctx) + gap;
    }
  }
  /**
   * Attempts to gracefully bypass this node in all of its connections by reconnecting all links.
   * 
   * Each input is checked against each output.  This is done on a matching index basis, i.e. input 3 -> output 3.
   * If there are any input links remaining, and {@link flags}.{@link INodeFlags.keepAllLinksOnBypass keepAllLinksOnBypass} is `true`,
   * each input will check for outputs that match, and take the first one that matches
   * `true`: Try the index matching first, then every input to every output.
   * `false`: Only matches indexes, e.g. input 3 to output 3.
   * 
   * If {@link flags}.{@link INodeFlags.keepAllLinksOnBypass keepAllLinksOnBypass} is `undefined`, it will fall back to
   * the static {@link keepAllLinksOnBypass}.
   *
   * @returns `true` if any new links were established, otherwise `false`.
   * @todo Decision: Change API to return array of new links instead?
   */
  connectInputToOutput() {
    const { inputs, outputs, graph } = this;
    if (!inputs || !outputs) return;
    const { _links } = graph;
    let madeAnyConnections = false;
    for (const [index2, input] of inputs.entries()) {
      const output = outputs[index2];
      if (!output || !LiteGraph.isValidConnection(input.type, output.type)) continue;
      const inLink = _links.get(input.link);
      const inNode = graph.getNodeById(inLink?.origin_id);
      if (!inNode) continue;
      bypassAllLinks(output, inNode, inLink);
    }
    if (!(this.flags.keepAllLinksOnBypass ?? LGraphNode.keepAllLinksOnBypass)) return madeAnyConnections;
    for (const input of inputs) {
      const inLink = _links.get(input.link);
      const inNode = graph.getNodeById(inLink?.origin_id);
      if (!inNode) continue;
      for (const output of outputs) {
        if (!LiteGraph.isValidConnection(input.type, output.type)) continue;
        bypassAllLinks(output, inNode, inLink);
        break;
      }
    }
    return madeAnyConnections;
    function bypassAllLinks(output, inNode, inLink) {
      const outLinks = output.links?.map((x2) => _links.get(x2)).filter((x2) => !!x2);
      if (!outLinks?.length) return;
      for (const outLink of outLinks) {
        const outNode = graph.getNodeById(outLink.target_id);
        if (!outNode) return;
        const result = inNode.connect(inLink.origin_slot, outNode, outLink.target_slot, inLink.parentId);
        madeAnyConnections ||= !!result;
      }
    }
    __name(bypassAllLinks, "bypassAllLinks");
  }
}
class LGraphGroup {
  static {
    __name(this, "LGraphGroup");
  }
  static minWidth = 140;
  static minHeight = 80;
  static resizeLength = 10;
  static padding = 4;
  static defaultColour = "#335";
  id;
  color;
  title;
  font;
  font_size = LiteGraph.DEFAULT_GROUP_FONT || 24;
  _bounding = new Float32Array([10, 10, LGraphGroup.minWidth, LGraphGroup.minHeight]);
  _pos = this._bounding.subarray(0, 2);
  _size = this._bounding.subarray(2, 4);
  /** @deprecated See {@link _children} */
  _nodes = [];
  _children = /* @__PURE__ */ new Set();
  graph = null;
  flags = {};
  selected;
  constructor(title, id3) {
    this.id = id3 ?? -1;
    this.title = title || "Group";
    this.color = LGraphCanvas.node_colors.pale_blue ? LGraphCanvas.node_colors.pale_blue.groupcolor : "#AAA";
  }
  /** Position of the group, as x,y co-ordinates in graph space */
  get pos() {
    return this._pos;
  }
  set pos(v2) {
    if (!v2 || v2.length < 2) return;
    this._pos[0] = v2[0];
    this._pos[1] = v2[1];
  }
  /** Size of the group, as width,height in graph units */
  get size() {
    return this._size;
  }
  set size(v2) {
    if (!v2 || v2.length < 2) return;
    this._size[0] = Math.max(LGraphGroup.minWidth, v2[0]);
    this._size[1] = Math.max(LGraphGroup.minHeight, v2[1]);
  }
  get boundingRect() {
    return this._bounding;
  }
  get nodes() {
    return this._nodes;
  }
  get titleHeight() {
    return this.font_size * 1.4;
  }
  get children() {
    return this._children;
  }
  get pinned() {
    return !!this.flags.pinned;
  }
  /**
   * Prevents the group being accidentally moved or resized by mouse interaction.
   * Toggles pinned state if no value is provided.
   **/
  pin(value3) {
    const newState = value3 === void 0 ? !this.pinned : value3;
    if (newState) this.flags.pinned = true;
    else delete this.flags.pinned;
  }
  unpin() {
    this.pin(false);
  }
  configure(o) {
    this.id = o.id;
    this.title = o.title;
    this._bounding.set(o.bounding);
    this.color = o.color;
    this.flags = o.flags || this.flags;
    if (o.font_size) this.font_size = o.font_size;
  }
  serialize() {
    const b = this._bounding;
    return {
      id: this.id,
      title: this.title,
      bounding: [...b],
      color: this.color,
      font_size: this.font_size,
      flags: this.flags
    };
  }
  /**
   * Draws the group on the canvas
   * @param {LGraphCanvas} graphCanvas
   * @param {CanvasRenderingContext2D} ctx
   */
  draw(graphCanvas, ctx) {
    const { padding, resizeLength, defaultColour } = LGraphGroup;
    const font_size = this.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
    const [x2, y2] = this._pos;
    const [width2, height] = this._size;
    ctx.globalAlpha = 0.25 * graphCanvas.editor_alpha;
    ctx.fillStyle = this.color || defaultColour;
    ctx.strokeStyle = this.color || defaultColour;
    ctx.beginPath();
    ctx.rect(x2 + 0.5, y2 + 0.5, width2, font_size * 1.4);
    ctx.fill();
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.color;
    ctx.beginPath();
    ctx.rect(x2 + 0.5, y2 + 0.5, width2, height);
    ctx.fill();
    ctx.globalAlpha = graphCanvas.editor_alpha;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2 + width2, y2 + height);
    ctx.lineTo(x2 + width2 - resizeLength, y2 + height);
    ctx.lineTo(x2 + width2, y2 + height - resizeLength);
    ctx.fill();
    ctx.font = font_size + "px Arial";
    ctx.textAlign = "left";
    ctx.fillText(this.title + (this.pinned ? "" : ""), x2 + padding, y2 + font_size);
    if (LiteGraph.highlight_selected_group && this.selected) {
      graphCanvas.drawSelectionBounding(ctx, this._bounding, {
        shape: RenderShape.BOX,
        title_height: this.titleHeight,
        title_mode: TitleMode.NORMAL_TITLE,
        fgcolor: this.color,
        padding
      });
    }
  }
  resize(width2, height) {
    if (this.pinned) return false;
    this._size[0] = Math.max(LGraphGroup.minWidth, width2);
    this._size[1] = Math.max(LGraphGroup.minHeight, height);
    return true;
  }
  move(deltaX, deltaY, skipChildren = false) {
    if (this.pinned) return;
    this._pos[0] += deltaX;
    this._pos[1] += deltaY;
    if (skipChildren === true) return;
    for (const item2 of this._children) {
      item2.move(deltaX, deltaY);
    }
  }
  recomputeInsideNodes() {
    const { nodes, reroutes, groups } = this.graph;
    const children = this._children;
    this._nodes.length = 0;
    children.clear();
    for (const node22 of nodes) {
      if (containsCentre(this._bounding, node22.boundingRect)) {
        this._nodes.push(node22);
        children.add(node22);
      }
    }
    for (const reroute of reroutes.values()) {
      if (isPointInRectangle(reroute.pos, this._bounding))
        children.add(reroute);
    }
    for (const group of groups) {
      if (containsRect(this._bounding, group._bounding))
        children.add(group);
    }
    groups.sort((a, b) => {
      if (a === this) {
        return children.has(b) ? -1 : 0;
      } else if (b === this) {
        return children.has(a) ? 1 : 0;
      }
    });
  }
  /**
   * Resizes and moves the group to neatly fit all given {@link objects}.
   * @param objects All objects that should be inside the group
   * @param padding Value in graph units to add to all sides of the group.  Default: 10
   */
  resizeTo(objects, padding = 10) {
    const boundingBox = createBounds(objects, padding);
    if (boundingBox === null) return;
    this.pos[0] = boundingBox[0];
    this.pos[1] = boundingBox[1] - this.titleHeight;
    this.size[0] = boundingBox[2];
    this.size[1] = boundingBox[3] + this.titleHeight;
  }
  /**
   * Add nodes to the group and adjust the group's position and size accordingly
   * @param {LGraphNode[]} nodes - The nodes to add to the group
   * @param {number} [padding=10] - The padding around the group
   * @returns {void}
   */
  addNodes(nodes, padding = 10) {
    if (!this._nodes && nodes.length === 0) return;
    this.resizeTo([...this.children, ...this._nodes, ...nodes], padding);
  }
  getMenuOptions() {
    return [
      {
        content: this.pinned ? "Unpin" : "Pin",
        callback: /* @__PURE__ */ __name(() => {
          if (this.pinned) this.unpin();
          else this.pin();
          this.setDirtyCanvas(false, true);
        }, "callback")
      },
      null,
      { content: "Title", callback: LGraphCanvas.onShowPropertyEditor },
      {
        content: "Color",
        has_submenu: true,
        callback: LGraphCanvas.onMenuNodeColors
      },
      {
        content: "Font size",
        property: "font_size",
        type: "Number",
        callback: LGraphCanvas.onShowPropertyEditor
      },
      null,
      { content: "Remove", callback: LGraphCanvas.onMenuNodeRemove }
    ];
  }
  isPointInTitlebar(x2, y2) {
    const b = this._bounding;
    return isInsideRectangle(x2, y2, b[0], b[1], b[2], this.titleHeight);
  }
  isInResize(x2, y2) {
    const b = this.boundingRect;
    const right = b[0] + b[2];
    const bottom = b[1] + b[3];
    return x2 < right && y2 < bottom && x2 - right + (y2 - bottom) > -LGraphGroup.resizeLength;
  }
  isPointInside = LGraphNode.prototype.isPointInside;
  setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas;
}
var SlotType = /* @__PURE__ */ ((SlotType2) => {
  SlotType2["Array"] = "array";
  SlotType2[SlotType2["Event"] = -1] = "Event";
  return SlotType2;
})(SlotType || {});
var SlotShape = ((SlotShape2) => {
  SlotShape2[SlotShape2["Box"] = RenderShape.BOX] = "Box";
  SlotShape2[SlotShape2["Arrow"] = RenderShape.ARROW] = "Arrow";
  SlotShape2[SlotShape2["Grid"] = RenderShape.GRID] = "Grid";
  SlotShape2[SlotShape2["Circle"] = RenderShape.CIRCLE] = "Circle";
  SlotShape2[SlotShape2["HollowCircle"] = RenderShape.HollowCircle] = "HollowCircle";
  return SlotShape2;
})(SlotShape || {});
var SlotDirection = ((SlotDirection2) => {
  SlotDirection2[SlotDirection2["Up"] = LinkDirection.UP] = "Up";
  SlotDirection2[SlotDirection2["Right"] = LinkDirection.RIGHT] = "Right";
  SlotDirection2[SlotDirection2["Down"] = LinkDirection.DOWN] = "Down";
  SlotDirection2[SlotDirection2["Left"] = LinkDirection.LEFT] = "Left";
  return SlotDirection2;
})(SlotDirection || {});
var LabelPosition = /* @__PURE__ */ ((LabelPosition2) => {
  LabelPosition2["Left"] = "left";
  LabelPosition2["Right"] = "right";
  return LabelPosition2;
})(LabelPosition || {});
function drawSlot(ctx, slot, pos2, {
  label_color = "#AAA",
  label_position = "right",
  horizontal: horizontal2 = false,
  low_quality = false,
  render_text = true,
  do_stroke = false,
  highlight = false
} = {}) {
  const originalFillStyle = ctx.fillStyle;
  const originalStrokeStyle = ctx.strokeStyle;
  const originalLineWidth = ctx.lineWidth;
  const slot_type = slot.type;
  const slot_shape = slot_type === "array" ? SlotShape.Grid : slot.shape;
  ctx.beginPath();
  let doStroke = do_stroke;
  let doFill = true;
  if (slot_type === -1 || slot_shape === SlotShape.Box) {
    if (horizontal2) {
      ctx.rect(pos2[0] - 5 + 0.5, pos2[1] - 8 + 0.5, 10, 14);
    } else {
      ctx.rect(pos2[0] - 6 + 0.5, pos2[1] - 5 + 0.5, 14, 10);
    }
  } else if (slot_shape === SlotShape.Arrow) {
    ctx.moveTo(pos2[0] + 8, pos2[1] + 0.5);
    ctx.lineTo(pos2[0] - 4, pos2[1] + 6 + 0.5);
    ctx.lineTo(pos2[0] - 4, pos2[1] - 6 + 0.5);
    ctx.closePath();
  } else if (slot_shape === SlotShape.Grid) {
    const gridSize = 3;
    const cellSize = 2;
    const spacing = 3;
    for (let x2 = 0; x2 < gridSize; x2++) {
      for (let y2 = 0; y2 < gridSize; y2++) {
        ctx.rect(
          pos2[0] - 4 + x2 * spacing,
          pos2[1] - 4 + y2 * spacing,
          cellSize,
          cellSize
        );
      }
    }
    doStroke = false;
  } else {
    if (low_quality) {
      ctx.rect(pos2[0] - 4, pos2[1] - 4, 8, 8);
    } else {
      let radius;
      if (slot_shape === SlotShape.HollowCircle) {
        doFill = false;
        doStroke = true;
        ctx.lineWidth = 3;
        ctx.strokeStyle = ctx.fillStyle;
        radius = highlight ? 4 : 3;
      } else {
        radius = highlight ? 5 : 4;
      }
      ctx.arc(pos2[0], pos2[1], radius, 0, Math.PI * 2);
    }
  }
  if (doFill) ctx.fill();
  if (!low_quality && doStroke) ctx.stroke();
  if (render_text) {
    const text = slot.label != null ? slot.label : slot.name;
    if (text) {
      ctx.fillStyle = label_color;
      if (label_position === "right") {
        if (horizontal2 || slot.dir == LinkDirection.UP) {
          ctx.fillText(text, pos2[0], pos2[1] - 10);
        } else {
          ctx.fillText(text, pos2[0] + 10, pos2[1] + 5);
        }
      } else {
        if (horizontal2 || slot.dir == LinkDirection.DOWN) {
          ctx.fillText(text, pos2[0], pos2[1] - 8);
        } else {
          ctx.fillText(text, pos2[0] - 10, pos2[1] + 5);
        }
      }
    }
  }
  ctx.fillStyle = originalFillStyle;
  ctx.strokeStyle = originalStrokeStyle;
  ctx.lineWidth = originalLineWidth;
}
__name(drawSlot, "drawSlot");
class DragAndScale {
  static {
    __name(this, "DragAndScale");
  }
  /** Maximum scale (zoom in) */
  max_scale;
  /** Minimum scale (zoom out) */
  min_scale;
  offset;
  scale;
  enabled;
  last_mouse;
  element;
  visible_area;
  _binded_mouse_callback;
  dragging;
  viewport;
  constructor(element, skip_events) {
    this.offset = new Float32Array([0, 0]);
    this.scale = 1;
    this.max_scale = 10;
    this.min_scale = 0.1;
    this.onredraw = null;
    this.enabled = true;
    this.last_mouse = [0, 0];
    this.element = null;
    this.visible_area = new Float32Array(4);
    if (element) {
      this.element = element;
      if (!skip_events) {
        this.bindEvents(element);
      }
    }
  }
  /** @deprecated Has not been kept up to date */
  bindEvents(element) {
    this.last_mouse = new Float32Array(2);
    this._binded_mouse_callback = this.onMouse.bind(this);
    LiteGraph.pointerListenerAdd(element, "down", this._binded_mouse_callback);
    LiteGraph.pointerListenerAdd(element, "move", this._binded_mouse_callback);
    LiteGraph.pointerListenerAdd(element, "up", this._binded_mouse_callback);
    element.addEventListener(
      "mousewheel",
      this._binded_mouse_callback,
      false
    );
    element.addEventListener("wheel", this._binded_mouse_callback, false);
  }
  computeVisibleArea(viewport) {
    if (!this.element) {
      this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;
      return;
    }
    let width2 = this.element.width;
    let height = this.element.height;
    let startx = -this.offset[0];
    let starty = -this.offset[1];
    if (viewport) {
      startx += viewport[0] / this.scale;
      starty += viewport[1] / this.scale;
      width2 = viewport[2];
      height = viewport[3];
    }
    const endx = startx + width2 / this.scale;
    const endy = starty + height / this.scale;
    this.visible_area[0] = startx;
    this.visible_area[1] = starty;
    this.visible_area[2] = endx - startx;
    this.visible_area[3] = endy - starty;
  }
  /** @deprecated Has not been kept up to date */
  onMouse(e) {
    if (!this.enabled) {
      return;
    }
    const canvas = this.element;
    const rect = canvas.getBoundingClientRect();
    const x2 = e.clientX - rect.left;
    const y2 = e.clientY - rect.top;
    e.canvasx = x2;
    e.canvasy = y2;
    e.dragging = this.dragging;
    const is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
    let ignore = false;
    if (this.onmouse) {
      ignore = this.onmouse(e);
    }
    if (e.type == LiteGraph.pointerevents_method + "down" && is_inside) {
      this.dragging = true;
      LiteGraph.pointerListenerRemove(canvas, "move", this._binded_mouse_callback);
      LiteGraph.pointerListenerAdd(document, "move", this._binded_mouse_callback);
      LiteGraph.pointerListenerAdd(document, "up", this._binded_mouse_callback);
    } else if (e.type == LiteGraph.pointerevents_method + "move") {
      if (!ignore) {
        const deltax = x2 - this.last_mouse[0];
        const deltay = y2 - this.last_mouse[1];
        if (this.dragging) {
          this.mouseDrag(deltax, deltay);
        }
      }
    } else if (e.type == LiteGraph.pointerevents_method + "up") {
      this.dragging = false;
      LiteGraph.pointerListenerRemove(document, "move", this._binded_mouse_callback);
      LiteGraph.pointerListenerRemove(document, "up", this._binded_mouse_callback);
      LiteGraph.pointerListenerAdd(canvas, "move", this._binded_mouse_callback);
    } else if (is_inside && (e.type == "mousewheel" || e.type == "wheel" || e.type == "DOMMouseScroll")) {
      e.eventType = "mousewheel";
      if (e.type == "wheel") e.wheel = -e.deltaY;
      else e.wheel = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;
      e.delta = e.wheelDelta ? e.wheelDelta / 40 : e.deltaY ? -e.deltaY / 3 : 0;
      this.changeDeltaScale(1 + e.delta * 0.05);
    }
    this.last_mouse[0] = x2;
    this.last_mouse[1] = y2;
    if (is_inside) {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  }
  toCanvasContext(ctx) {
    ctx.scale(this.scale, this.scale);
    ctx.translate(this.offset[0], this.offset[1]);
  }
  convertOffsetToCanvas(pos2) {
    return [
      (pos2[0] + this.offset[0]) * this.scale,
      (pos2[1] + this.offset[1]) * this.scale
    ];
  }
  convertCanvasToOffset(pos2, out) {
    out = out || [0, 0];
    out[0] = pos2[0] / this.scale - this.offset[0];
    out[1] = pos2[1] / this.scale - this.offset[1];
    return out;
  }
  /** @deprecated Has not been kept up to date */
  mouseDrag(x2, y2) {
    this.offset[0] += x2 / this.scale;
    this.offset[1] += y2 / this.scale;
    this.onredraw?.(this);
  }
  changeScale(value3, zooming_center) {
    if (value3 < this.min_scale) {
      value3 = this.min_scale;
    } else if (value3 > this.max_scale) {
      value3 = this.max_scale;
    }
    if (value3 == this.scale) return;
    if (!this.element) return;
    const rect = this.element.getBoundingClientRect();
    if (!rect) return;
    zooming_center = zooming_center || [
      rect.width * 0.5,
      rect.height * 0.5
    ];
    const center = this.convertCanvasToOffset(zooming_center);
    this.scale = value3;
    if (Math.abs(this.scale - 1) < 0.01) this.scale = 1;
    const new_center = this.convertCanvasToOffset(zooming_center);
    const delta_offset = [
      new_center[0] - center[0],
      new_center[1] - center[1]
    ];
    this.offset[0] += delta_offset[0];
    this.offset[1] += delta_offset[1];
    this.onredraw?.(this);
  }
  changeDeltaScale(value3, zooming_center) {
    this.changeScale(this.scale * value3, zooming_center);
  }
  reset() {
    this.scale = 1;
    this.offset[0] = 0;
    this.offset[1] = 0;
  }
}
function stringOrNull(value3) {
  return value3 == null ? null : String(value3);
}
__name(stringOrNull, "stringOrNull");
function stringOrEmpty(value3) {
  return value3 == null ? "" : String(value3);
}
__name(stringOrEmpty, "stringOrEmpty");
function getBoundaryNodes(nodes) {
  const valid = nodes?.find((x2) => x2);
  if (!valid) return null;
  let top = valid;
  let right = valid;
  let bottom = valid;
  let left = valid;
  for (const node22 of nodes) {
    if (!node22) continue;
    const [x2, y2] = node22.pos;
    const [width2, height] = node22.size;
    if (y2 < top.pos[1]) top = node22;
    if (x2 + width2 > right.pos[0] + right.size[0]) right = node22;
    if (y2 + height > bottom.pos[1] + bottom.size[1]) bottom = node22;
    if (x2 < left.pos[0]) left = node22;
  }
  return {
    top,
    right,
    bottom,
    left
  };
}
__name(getBoundaryNodes, "getBoundaryNodes");
function distributeNodes(nodes, horizontal2) {
  const nodeCount = nodes?.length;
  if (!(nodeCount > 1)) return;
  const index2 = horizontal2 ? 0 : 1;
  let total = 0;
  let highest = -Infinity;
  for (const node22 of nodes) {
    total += node22.size[index2];
    const high = node22.pos[index2] + node22.size[index2];
    if (high > highest) highest = high;
  }
  const sorted = [...nodes].sort((a, b) => a.pos[index2] - b.pos[index2]);
  const lowest = sorted[0].pos[index2];
  const gap = (highest - lowest - total) / (nodeCount - 1);
  let startAt = lowest;
  for (let i2 = 0; i2 < nodeCount; i2++) {
    const node22 = sorted[i2];
    node22.pos[index2] = startAt + gap * i2;
    startAt += node22.size[index2];
  }
}
__name(distributeNodes, "distributeNodes");
function alignNodes(nodes, direction, align_to) {
  if (!nodes) return;
  const boundary = align_to === void 0 ? getBoundaryNodes(nodes) : {
    top: align_to,
    right: align_to,
    bottom: align_to,
    left: align_to
  };
  if (boundary === null) return;
  for (const node22 of nodes) {
    switch (direction) {
      case "right":
        node22.pos[0] = boundary.right.pos[0] + boundary.right.size[0] - node22.size[0];
        break;
      case "left":
        node22.pos[0] = boundary.left.pos[0];
        break;
      case "top":
        node22.pos[1] = boundary.top.pos[1];
        break;
      case "bottom":
        node22.pos[1] = boundary.bottom.pos[1] + boundary.bottom.size[1] - node22.size[1];
        break;
    }
  }
}
__name(alignNodes, "alignNodes");
function getAllNestedItems(items2) {
  const allItems = /* @__PURE__ */ new Set();
  items2?.forEach((x2) => addRecursively(x2, allItems));
  return allItems;
  function addRecursively(item2, flatSet) {
    if (flatSet.has(item2)) return;
    flatSet.add(item2);
    item2.children?.forEach((x2) => addRecursively(x2, flatSet));
  }
  __name(addRecursively, "addRecursively");
}
__name(getAllNestedItems, "getAllNestedItems");
class LGraphCanvas {
  static {
    __name(this, "LGraphCanvas");
  }
  /* Interaction */
  static #temp = new Float32Array(4);
  static #temp_vec2 = new Float32Array(2);
  static #tmp_area = new Float32Array(4);
  static #margin_area = new Float32Array(4);
  static #link_bounding = new Float32Array(4);
  static #tempA = new Float32Array(2);
  static #tempB = new Float32Array(2);
  static #lTempA = new Float32Array(2);
  static #lTempB = new Float32Array(2);
  static #lTempC = new Float32Array(2);
  static DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";
  /** Initialised from LiteGraphGlobal static block to avoid circular dependency. */
  static link_type_colors;
  static gradients = {};
  //cache of gradients
  static search_limit = -1;
  static node_colors = {
    red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" },
    brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" },
    green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" },
    blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" },
    pale_blue: {
      color: "#2a363b",
      bgcolor: "#3f5159",
      groupcolor: "#3f789e"
    },
    cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" },
    purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" },
    yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" },
    black: { color: "#222", bgcolor: "#000", groupcolor: "#444" }
  };
  /**
   * The state of this canvas, e.g. whether it is being dragged, or read-only.
   * 
   * Implemented as a POCO that can be proxied without side-effects.
   */
  state = {
    draggingItems: false,
    draggingCanvas: false,
    readOnly: false
  };
  /** @inheritdoc {@link LGraphCanvasState.draggingCanvas} */
  get dragging_canvas() {
    return this.state.draggingCanvas;
  }
  set dragging_canvas(value3) {
    this.state.draggingCanvas = value3;
  }
  // Whether the canvas was previously being dragged prior to pressing space key.
  // null if space key is not pressed.
  _previously_dragging_canvas = null;
  /** @inheritdoc {@link LGraphCanvasState.readOnly} */
  get read_only() {
    return this.state.readOnly;
  }
  set read_only(value3) {
    this.state.readOnly = value3;
  }
  get isDragging() {
    return this.state.draggingItems;
  }
  set isDragging(value3) {
    this.state.draggingItems = value3;
  }
  get title_text_font() {
    return `${LiteGraph.NODE_TEXT_SIZE}px Arial`;
  }
  get inner_text_font() {
    return `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px Arial`;
  }
  options;
  background_image;
  ds;
  zoom_modify_alpha;
  zoom_speed;
  node_title_color;
  default_link_color;
  default_connection_color;
  default_connection_color_byType;
  default_connection_color_byTypeOff;
  highquality_render;
  use_gradients;
  editor_alpha;
  pause_rendering;
  clear_background;
  clear_background_color;
  render_only_selected;
  live_mode;
  show_info;
  allow_dragcanvas;
  allow_dragnodes;
  allow_interaction;
  multi_select;
  allow_searchbox;
  allow_reconnect_links;
  align_to_grid;
  drag_mode;
  dragging_rectangle;
  filter;
  set_canvas_dirty_on_mouse_event;
  always_render_background;
  render_shadows;
  render_canvas_border;
  render_connections_shadows;
  render_connections_border;
  render_curved_connections;
  render_connection_arrows;
  render_collapsed_slots;
  render_execution_order;
  render_title_colored;
  render_link_tooltip;
  /** Controls whether reroutes are rendered at all. */
  reroutesEnabled = false;
  /** Shape of the markers shown at the midpoint of links.  Default: Circle */
  linkMarkerShape = LinkMarkerShape.Circle;
  links_render_mode;
  /** mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle */
  mouse;
  /** mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle */
  graph_mouse;
  /** @deprecated LEGACY: REMOVE THIS, USE {@link graph_mouse} INSTEAD */
  canvas_mouse;
  /** to personalize the search box */
  onSearchBox;
  onSearchBoxSelection;
  onMouse;
  /** to render background objects (behind nodes and connections) in the canvas affected by transform */
  onDrawBackground;
  /** to render foreground objects (above nodes and connections) in the canvas affected by transform */
  onDrawForeground;
  connections_width;
  round_radius;
  /** The current node being drawn by {@link drawNode}.  This should NOT be used to determine the currently selected node.  See {@link selectedItems} */
  current_node;
  /** used for widgets */
  node_widget;
  over_link_center;
  last_mouse_position;
  visible_area;
  /** Contains all links and reroutes that were rendered.  Repopulated every render cycle. */
  renderedPaths = /* @__PURE__ */ new Set();
  visible_links;
  connecting_links;
  viewport;
  autoresize;
  static active_canvas;
  frame = 0;
  last_draw_time = 0;
  render_time = 0;
  fps = 0;
  /** @deprecated See {@link LGraphCanvas.selectedItems} */
  selected_nodes = {};
  /** All selected nodes, groups, and reroutes */
  selectedItems = /* @__PURE__ */ new Set();
  /** The group currently being resized. */
  resizingGroup = null;
  /** @deprecated See {@link LGraphCanvas.selectedItems} */
  selected_group = null;
  visible_nodes = [];
  node_dragged;
  node_over;
  node_capturing_input;
  highlighted_links = {};
  link_over_widget;
  link_over_widget_type;
  dirty_canvas = true;
  dirty_bgcanvas = true;
  /** A map of nodes that require selective-redraw */
  dirty_nodes = /* @__PURE__ */ new Map();
  dirty_area;
  /** @deprecated Unused */
  node_in_panel;
  last_mouse = [0, 0];
  last_mouseclick = 0;
  pointer_is_down = false;
  pointer_is_double = false;
  graph;
  _graph_stack = null;
  canvas;
  bgcanvas;
  ctx;
  _events_binded;
  /** @deprecated WebGL */
  gl;
  bgctx;
  is_rendering;
  /** @deprecated Panels */
  block_click;
  /** @deprecated Panels */
  last_click_position;
  resizing_node;
  /** @deprecated See {@link LGraphCanvas.resizingGroup} */
  selected_group_resizing;
  last_mouse_dragging;
  onMouseDown;
  _highlight_pos;
  _highlight_input;
  // TODO: Check if panels are used
  /** @deprecated Panels */
  node_panel;
  /** @deprecated Panels */
  options_panel;
  onDropItem;
  _bg_img;
  _pattern;
  _pattern_img;
  // TODO: This looks like another panel thing
  prompt_box;
  search_box;
  /** @deprecated Panels */
  SELECTED_NODE;
  /** @deprecated Panels */
  NODEPANEL_IS_OPEN;
  static active_node;
  onClear;
  /** called after moving a node */
  onNodeMoved;
  /** called if the selection changes */
  onSelectionChange;
  /** called when rendering a tooltip */
  onDrawLinkTooltip;
  /** to render foreground objects not affected by transform (for GUIs) */
  onDrawOverlay;
  onRenderBackground;
  onNodeDblClicked;
  onShowNodePanel;
  onNodeSelected;
  onNodeDeselected;
  onRender;
  /** Implement this function to allow conversion of widget types to input types, e.g. number -> INT or FLOAT for widget link validation checks */
  getWidgetLinkType;
  /**
   * Creates a new instance of LGraphCanvas.
   * @param canvas The canvas HTML element (or its id) to use, or null / undefined to leave blank.
   * @param graph The graph that owns this canvas.
   * @param options 
   */
  constructor(canvas, graph, options3) {
    options3 ||= {};
    this.options = options3;
    this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;
    this.ds = new DragAndScale();
    this.zoom_modify_alpha = true;
    this.zoom_speed = 1.1;
    this.node_title_color = LiteGraph.NODE_TITLE_COLOR;
    this.default_link_color = LiteGraph.LINK_COLOR;
    this.default_connection_color = {
      input_off: "#778",
      input_on: "#7F7",
      //"#BBD"
      output_off: "#778",
      output_on: "#7F7"
      //"#BBD"
    };
    this.default_connection_color_byType = {
      /*number: "#7F7",
      string: "#77F",
      boolean: "#F77",*/
    };
    this.default_connection_color_byTypeOff = {
      /*number: "#474",
      string: "#447",
      boolean: "#744",*/
    };
    this.highquality_render = true;
    this.use_gradients = false;
    this.editor_alpha = 1;
    this.pause_rendering = false;
    this.clear_background = true;
    this.clear_background_color = "#222";
    this.render_only_selected = true;
    this.live_mode = false;
    this.show_info = true;
    this.allow_dragcanvas = true;
    this.allow_dragnodes = true;
    this.allow_interaction = true;
    this.multi_select = false;
    this.allow_searchbox = true;
    this.allow_reconnect_links = true;
    this.align_to_grid = false;
    this.drag_mode = false;
    this.dragging_rectangle = null;
    this.filter = null;
    this.set_canvas_dirty_on_mouse_event = true;
    this.always_render_background = false;
    this.render_shadows = true;
    this.render_canvas_border = true;
    this.render_connections_shadows = false;
    this.render_connections_border = true;
    this.render_curved_connections = false;
    this.render_connection_arrows = false;
    this.render_collapsed_slots = true;
    this.render_execution_order = false;
    this.render_title_colored = true;
    this.render_link_tooltip = true;
    this.links_render_mode = LinkRenderType.SPLINE_LINK;
    this.mouse = [0, 0];
    this.graph_mouse = [0, 0];
    this.canvas_mouse = this.graph_mouse;
    this.onSearchBox = null;
    this.onSearchBoxSelection = null;
    this.onMouse = null;
    this.onDrawBackground = null;
    this.onDrawForeground = null;
    this.onDrawOverlay = null;
    this.onDrawLinkTooltip = null;
    this.onNodeMoved = null;
    this.onSelectionChange = null;
    this.onConnectingChange = null;
    this.onBeforeChange = null;
    this.onAfterChange = null;
    this.connections_width = 3;
    this.round_radius = 8;
    this.current_node = null;
    this.node_widget = null;
    this.over_link_center = null;
    this.last_mouse_position = [0, 0];
    this.visible_area = this.ds.visible_area;
    this.visible_links = [];
    this.connecting_links = null;
    this.viewport = options3.viewport || null;
    graph?.attachCanvas(this);
    this.setCanvas(canvas, options3.skip_events);
    this.clear();
    if (!options3.skip_render) {
      this.startRendering();
    }
    this.autoresize = options3.autoresize;
  }
  static getFileExtension(url) {
    const question = url.indexOf("?");
    if (question !== -1) url = url.substring(0, question);
    const point = url.lastIndexOf(".");
    return point === -1 ? "" : url.substring(point + 1).toLowerCase();
  }
  static onGroupAdd(info, entry, mouse_event) {
    const canvas = LGraphCanvas.active_canvas;
    const group = new LiteGraph.LGraphGroup();
    group.pos = canvas.convertEventToCanvasOffset(mouse_event);
    canvas.graph.add(group);
  }
  /**
   * @deprecated Functionality moved to {@link getBoundaryNodes}.  The new function returns null on failure, instead of an object with all null properties.
   * Determines the furthest nodes in each direction
   * @param {Dictionary<LGraphNode>} nodes the nodes to from which boundary nodes will be extracted
   * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}
   */
  static getBoundaryNodes(nodes) {
    const _nodes = Array.isArray(nodes) ? nodes : Object.values(nodes);
    return getBoundaryNodes(_nodes) ?? {
      top: null,
      right: null,
      bottom: null,
      left: null
    };
  }
  /**
   * @deprecated Functionality moved to {@link alignNodes}.  The new function does not set dirty canvas.
   * @param {Dictionary<LGraphNode>} nodes a list of nodes
   * @param {"top"|"bottom"|"left"|"right"} direction Direction to align the nodes
   * @param {LGraphNode?} align_to Node to align to (if null, align to the furthest node in the given direction)
   */
  static alignNodes(nodes, direction, align_to) {
    alignNodes(Object.values(nodes), direction, align_to);
    LGraphCanvas.active_canvas.setDirty(true, true);
  }
  static onNodeAlign(value3, options3, event2, prev_menu, node22) {
    new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
      event: event2,
      callback: inner_clicked,
      parentMenu: prev_menu
    });
    function inner_clicked(value22) {
      alignNodes(Object.values(LGraphCanvas.active_canvas.selected_nodes), value22.toLowerCase(), node22);
      LGraphCanvas.active_canvas.setDirty(true, true);
    }
    __name(inner_clicked, "inner_clicked");
  }
  static onGroupAlign(value3, options3, event2, prev_menu) {
    new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
      event: event2,
      callback: inner_clicked,
      parentMenu: prev_menu
    });
    function inner_clicked(value22) {
      alignNodes(Object.values(LGraphCanvas.active_canvas.selected_nodes), value22.toLowerCase());
      LGraphCanvas.active_canvas.setDirty(true, true);
    }
    __name(inner_clicked, "inner_clicked");
  }
  static createDistributeMenu(value3, options3, event2, prev_menu, node22) {
    new LiteGraph.ContextMenu(["Vertically", "Horizontally"], {
      event: event2,
      callback: inner_clicked,
      parentMenu: prev_menu
    });
    function inner_clicked(value22) {
      const canvas = LGraphCanvas.active_canvas;
      distributeNodes(Object.values(canvas.selected_nodes), value22 === "Horizontally");
      canvas.setDirty(true, true);
    }
    __name(inner_clicked, "inner_clicked");
  }
  static onMenuAdd(node22, options3, e, prev_menu, callback) {
    const canvas = LGraphCanvas.active_canvas;
    const ref_window2 = canvas.getCanvasWindow();
    const graph = canvas.graph;
    if (!graph)
      return;
    function inner_onMenuAdded(base_category, prev_menu2) {
      const categories = LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function(category) {
        return category.startsWith(base_category);
      });
      const entries = [];
      categories.map(function(category) {
        if (!category)
          return;
        const base_category_regex = new RegExp("^(" + base_category + ")");
        const category_name = category.replace(base_category_regex, "").split("/")[0];
        const category_path = base_category === "" ? category_name + "/" : base_category + category_name + "/";
        let name = category_name;
        if (name.indexOf("::") != -1)
          name = name.split("::")[1];
        const index2 = entries.findIndex(function(entry) {
          return entry.value === category_path;
        });
        if (index2 === -1) {
          entries.push({
            value: category_path,
            content: name,
            has_submenu: true,
            callback: /* @__PURE__ */ __name(function(value3, event2, mouseEvent, contextMenu) {
              inner_onMenuAdded(value3.value, contextMenu);
            }, "callback")
          });
        }
      });
      const nodes = LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);
      nodes.map(function(node3) {
        if (node3.skip_list)
          return;
        const entry = {
          value: node3.type,
          content: node3.title,
          has_submenu: false,
          callback: /* @__PURE__ */ __name(function(value3, event2, mouseEvent, contextMenu) {
            const first_event = contextMenu.getFirstEvent();
            canvas.graph.beforeChange();
            const node4 = LiteGraph.createNode(value3.value);
            if (node4) {
              node4.pos = canvas.convertEventToCanvasOffset(first_event);
              canvas.graph.add(node4);
            }
            callback?.(node4);
            canvas.graph.afterChange();
          }, "callback")
        };
        entries.push(entry);
      });
      new LiteGraph.ContextMenu(entries, { event: e, parentMenu: prev_menu2 }, ref_window2);
    }
    __name(inner_onMenuAdded, "inner_onMenuAdded");
    inner_onMenuAdded("", prev_menu);
    return false;
  }
  static onMenuCollapseAll() {
  }
  static onMenuNodeEdit() {
  }
  /** @param options Parameter is never used */
  static showMenuNodeOptionalInputs(v2, options3, e, prev_menu, node22) {
    if (!node22) return;
    const that2 = this;
    const canvas = LGraphCanvas.active_canvas;
    const ref_window2 = canvas.getCanvasWindow();
    options3 = node22.onGetInputs ? node22.onGetInputs() : node22.optional_inputs;
    let entries = [];
    if (options3) {
      for (let i2 = 0; i2 < options3.length; i2++) {
        const entry = options3[i2];
        if (!entry) {
          entries.push(null);
          continue;
        }
        let label5 = entry[0];
        entry[2] ||= {};
        if (entry[2].label) {
          label5 = entry[2].label;
        }
        entry[2].removable = true;
        const data22 = { content: label5, value: entry };
        if (entry[1] == LiteGraph.ACTION) {
          data22.className = "event";
        }
        entries.push(data22);
      }
    }
    const retEntries = node22.onMenuNodeInputs?.(entries);
    if (retEntries) entries = retEntries;
    if (!entries.length) {
      console.log("no input entries");
      return;
    }
    new LiteGraph.ContextMenu(
      entries,
      {
        event: e,
        callback: inner_clicked,
        parentMenu: prev_menu,
        node: node22
      },
      // @ts-expect-error Unused param
      ref_window2
    );
    function inner_clicked(v3, e2, prev2) {
      if (!node22) return;
      v3.callback?.call(that2, node22, v3, e2, prev2);
      if (!v3.value) return;
      node22.graph.beforeChange();
      node22.addInput(v3.value[0], v3.value[1], v3.value[2]);
      node22.onNodeInputAdd?.(v3.value);
      canvas.setDirty(true, true);
      node22.graph.afterChange();
    }
    __name(inner_clicked, "inner_clicked");
    return false;
  }
  /** @param options Parameter is never used */
  static showMenuNodeOptionalOutputs(v2, options3, e, prev_menu, node22) {
    if (!node22) return;
    const that2 = this;
    const canvas = LGraphCanvas.active_canvas;
    const ref_window2 = canvas.getCanvasWindow();
    options3 = node22.onGetOutputs ? node22.onGetOutputs() : node22.optional_outputs;
    let entries = [];
    if (options3) {
      for (let i2 = 0; i2 < options3.length; i2++) {
        const entry = options3[i2];
        if (!entry) {
          entries.push(null);
          continue;
        }
        if (node22.flags && node22.flags.skip_repeated_outputs && node22.findOutputSlot(entry[0]) != -1) {
          continue;
        }
        let label5 = entry[0];
        entry[2] ||= {};
        if (entry[2].label) {
          label5 = entry[2].label;
        }
        entry[2].removable = true;
        const data22 = { content: label5, value: entry };
        if (entry[1] == LiteGraph.EVENT) {
          data22.className = "event";
        }
        entries.push(data22);
      }
    }
    if (this.onMenuNodeOutputs) entries = this.onMenuNodeOutputs(entries);
    if (LiteGraph.do_add_triggers_slots) {
      if (node22.findOutputSlot("onExecuted") == -1) {
        entries.push({ content: "On Executed", value: ["onExecuted", LiteGraph.EVENT, { nameLocked: true }], className: "event" });
      }
    }
    const retEntries = node22.onMenuNodeOutputs?.(entries);
    if (retEntries) entries = retEntries;
    if (!entries.length) return;
    new LiteGraph.ContextMenu(
      entries,
      {
        event: e,
        callback: inner_clicked,
        parentMenu: prev_menu,
        node: node22
      },
      // @ts-expect-error Unused
      ref_window2
    );
    function inner_clicked(v3, e2, prev2) {
      if (!node22) return;
      if (v3.callback) v3.callback.call(that2, node22, v3, e2, prev2);
      if (!v3.value) return;
      const value3 = v3.value[1];
      if (value3 && (typeof value3 === "object" || Array.isArray(value3))) {
        const entries2 = [];
        for (const i2 in value3) {
          entries2.push({ content: i2, value: value3[i2] });
        }
        new LiteGraph.ContextMenu(entries2, {
          event: e2,
          callback: inner_clicked,
          parentMenu: prev_menu,
          node: node22
        });
        return false;
      }
      const graph = node22.graph;
      graph.beforeChange();
      node22.addOutput(v3.value[0], v3.value[1], v3.value[2]);
      node22.onNodeOutputAdd?.(v3.value);
      canvas.setDirty(true, true);
      graph.afterChange();
    }
    __name(inner_clicked, "inner_clicked");
    return false;
  }
  /** @param value Parameter is never used */
  static onShowMenuNodeProperties(value3, options3, e, prev_menu, node22) {
    if (!node22 || !node22.properties) return;
    const canvas = LGraphCanvas.active_canvas;
    const ref_window2 = canvas.getCanvasWindow();
    const entries = [];
    for (const i2 in node22.properties) {
      value3 = node22.properties[i2] !== void 0 ? node22.properties[i2] : " ";
      if (typeof value3 == "object")
        value3 = JSON.stringify(value3);
      const info = node22.getPropertyInfo(i2);
      if (info.type == "enum" || info.type == "combo")
        value3 = LGraphCanvas.getPropertyPrintableValue(value3, info.values);
      value3 = LGraphCanvas.decodeHTML(stringOrNull(value3));
      entries.push({
        content: "<span class='property_name'>" + (info.label || i2) + "</span><span class='property_value'>" + value3 + "</span>",
        value: i2
      });
    }
    if (!entries.length) {
      return;
    }
    new LiteGraph.ContextMenu(
      entries,
      {
        event: e,
        callback: inner_clicked,
        parentMenu: prev_menu,
        allow_html: true,
        node: node22
      },
      // @ts-expect-error Unused
      ref_window2
    );
    function inner_clicked(v2) {
      if (!node22) return;
      const rect = this.getBoundingClientRect();
      canvas.showEditPropertyValue(node22, v2.value, {
        position: [rect.left, rect.top]
      });
    }
    __name(inner_clicked, "inner_clicked");
    return false;
  }
  static decodeHTML(str) {
    const e = document.createElement("div");
    e.innerText = str;
    return e.innerHTML;
  }
  static onMenuResizeNode(value3, options3, e, menu, node22) {
    if (!node22) return;
    const fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
      node3.size = node3.computeSize();
      node3.onResize?.(node3.size);
    }, "fApplyMultiNode");
    const canvas = LGraphCanvas.active_canvas;
    if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22);
    } else {
      for (const i2 in canvas.selected_nodes) {
        fApplyMultiNode(canvas.selected_nodes[i2]);
      }
    }
    canvas.setDirty(true, true);
  }
  // TODO refactor :: this is used fot title but not for properties!
  static onShowPropertyEditor(item2, options3, e, menu, node22) {
    const property = item2.property || "title";
    const value3 = node22[property];
    const dialog = document.createElement("div");
    dialog.is_modified = false;
    dialog.className = "graphdialog";
    dialog.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
    dialog.close = function() {
      dialog.parentNode?.removeChild(dialog);
    };
    const title = dialog.querySelector(".name");
    title.innerText = property;
    const input = dialog.querySelector(".value");
    if (input) {
      input.value = value3;
      input.addEventListener("blur", function() {
        this.focus();
      });
      input.addEventListener("keydown", function(e2) {
        dialog.is_modified = true;
        if (e2.keyCode == 27) {
          dialog.close();
        } else if (e2.keyCode == 13) {
          inner();
        } else if (e2.keyCode != 13 && e2.target.localName != "textarea") {
          return;
        }
        e2.preventDefault();
        e2.stopPropagation();
      });
    }
    const canvas = LGraphCanvas.active_canvas;
    const canvasEl = canvas.canvas;
    const rect = canvasEl.getBoundingClientRect();
    let offsetx = -20;
    let offsety = -20;
    if (rect) {
      offsetx -= rect.left;
      offsety -= rect.top;
    }
    if (e) {
      dialog.style.left = e.clientX + offsetx + "px";
      dialog.style.top = e.clientY + offsety + "px";
    } else {
      dialog.style.left = canvasEl.width * 0.5 + offsetx + "px";
      dialog.style.top = canvasEl.height * 0.5 + offsety + "px";
    }
    const button = dialog.querySelector("button");
    button.addEventListener("click", inner);
    canvasEl.parentNode.appendChild(dialog);
    input?.focus();
    let dialogCloseTimer = null;
    dialog.addEventListener("mouseleave", function() {
      if (LiteGraph.dialog_close_on_mouse_leave) {
        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
          dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
      }
    });
    dialog.addEventListener("mouseenter", function() {
      if (LiteGraph.dialog_close_on_mouse_leave) {
        if (dialogCloseTimer) clearTimeout(dialogCloseTimer);
      }
    });
    function inner() {
      if (input) setValue2(input.value);
    }
    __name(inner, "inner");
    function setValue2(value22) {
      if (item2.type == "Number") {
        value22 = Number(value22);
      } else if (item2.type == "Boolean") {
        value22 = Boolean(value22);
      }
      node22[property] = value22;
      dialog.parentNode?.removeChild(dialog);
      canvas.setDirty(true, true);
    }
    __name(setValue2, "setValue");
  }
  static getPropertyPrintableValue(value3, values2) {
    if (!values2)
      return String(value3);
    if (Array.isArray(values2)) {
      return String(value3);
    }
    if (typeof values2 === "object") {
      let desc_value = "";
      for (const k in values2) {
        if (values2[k] != value3)
          continue;
        desc_value = k;
        break;
      }
      return String(value3) + " (" + desc_value + ")";
    }
  }
  static onMenuNodeCollapse(value3, options3, e, menu, node22) {
    node22.graph.beforeChange(
      /*?*/
    );
    const fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
      node3.collapse();
    }, "fApplyMultiNode");
    const graphcanvas = LGraphCanvas.active_canvas;
    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22);
    } else {
      for (const i2 in graphcanvas.selected_nodes) {
        fApplyMultiNode(graphcanvas.selected_nodes[i2]);
      }
    }
    node22.graph.afterChange(
      /*?*/
    );
  }
  static onMenuToggleAdvanced(value3, options3, e, menu, node22) {
    node22.graph.beforeChange(
      /*?*/
    );
    const fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
      node3.toggleAdvanced();
    }, "fApplyMultiNode");
    const graphcanvas = LGraphCanvas.active_canvas;
    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22);
    } else {
      for (const i2 in graphcanvas.selected_nodes) {
        fApplyMultiNode(graphcanvas.selected_nodes[i2]);
      }
    }
    node22.graph.afterChange(
      /*?*/
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static onMenuNodePin(value3, options3, e, menu, node22) {
  }
  static onMenuNodeMode(value3, options3, e, menu, node22) {
    new LiteGraph.ContextMenu(
      LiteGraph.NODE_MODES,
      { event: e, callback: inner_clicked, parentMenu: menu, node: node22 }
    );
    function inner_clicked(v2) {
      if (!node22) return;
      const kV = Object.values(LiteGraph.NODE_MODES).indexOf(v2);
      const fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
        if (kV >= 0 && LiteGraph.NODE_MODES[kV])
          node3.changeMode(kV);
        else {
          console.warn("unexpected mode: " + v2);
          node3.changeMode(LGraphEventMode.ALWAYS);
        }
      }, "fApplyMultiNode");
      const graphcanvas = LGraphCanvas.active_canvas;
      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
        fApplyMultiNode(node22);
      } else {
        for (const i2 in graphcanvas.selected_nodes) {
          fApplyMultiNode(graphcanvas.selected_nodes[i2]);
        }
      }
    }
    __name(inner_clicked, "inner_clicked");
    return false;
  }
  /** @param value Parameter is never used */
  static onMenuNodeColors(value3, options3, e, menu, node22) {
    if (!node22) throw "no node for color";
    const values2 = [];
    values2.push({
      value: null,
      content: "<span style='display: block; padding-left: 4px;'>No color</span>"
    });
    for (const i2 in LGraphCanvas.node_colors) {
      const color = LGraphCanvas.node_colors[i2];
      value3 = {
        value: i2,
        content: "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + color.color + "; background-color:" + color.bgcolor + "'>" + i2 + "</span>"
      };
      values2.push(value3);
    }
    new LiteGraph.ContextMenu(values2, {
      event: e,
      callback: inner_clicked,
      parentMenu: menu,
      node: node22
    });
    function inner_clicked(v2) {
      if (!node22) return;
      const color = v2.value ? LGraphCanvas.node_colors[v2.value] : null;
      const fApplyColor = /* @__PURE__ */ __name(function(node3) {
        if (color) {
          if (node3 instanceof LGraphGroup) {
            node3.color = color.groupcolor;
          } else {
            node3.color = color.color;
            node3.bgcolor = color.bgcolor;
          }
        } else {
          delete node3.color;
          delete node3.bgcolor;
        }
      }, "fApplyColor");
      const canvas = LGraphCanvas.active_canvas;
      if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {
        fApplyColor(node22);
      } else {
        for (const i2 in canvas.selected_nodes) {
          fApplyColor(canvas.selected_nodes[i2]);
        }
      }
      canvas.setDirty(true, true);
    }
    __name(inner_clicked, "inner_clicked");
    return false;
  }
  static onMenuNodeShapes(value3, options3, e, menu, node22) {
    if (!node22) throw "no node passed";
    new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {
      event: e,
      callback: inner_clicked,
      parentMenu: menu,
      node: node22
    });
    function inner_clicked(v2) {
      if (!node22) return;
      node22.graph.beforeChange(
        /*?*/
      );
      const fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
        node3.shape = v2;
      }, "fApplyMultiNode");
      const canvas = LGraphCanvas.active_canvas;
      if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {
        fApplyMultiNode(node22);
      } else {
        for (const i2 in canvas.selected_nodes) {
          fApplyMultiNode(canvas.selected_nodes[i2]);
        }
      }
      node22.graph.afterChange(
        /*?*/
      );
      canvas.setDirty(true);
    }
    __name(inner_clicked, "inner_clicked");
    return false;
  }
  static onMenuNodeRemove(value3, options3, e, menu, node22) {
    if (!node22) throw "no node passed";
    const graph = node22.graph;
    graph.beforeChange();
    const fApplyMultiNode = /* @__PURE__ */ __name(function(node3) {
      if (node3.removable === false) return;
      graph.remove(node3);
    }, "fApplyMultiNode");
    const canvas = LGraphCanvas.active_canvas;
    if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22);
    } else {
      for (const i2 in canvas.selected_nodes) {
        fApplyMultiNode(canvas.selected_nodes[i2]);
      }
    }
    graph.afterChange();
    canvas.setDirty(true, true);
  }
  static onMenuNodeToSubgraph(value3, options3, e, menu, node22) {
    const graph = node22.graph;
    const canvas = LGraphCanvas.active_canvas;
    if (!canvas) return;
    let nodes_list = Object.values(canvas.selected_nodes || {});
    if (!nodes_list.length)
      nodes_list = [node22];
    const subgraph_node = LiteGraph.createNode("graph/subgraph");
    subgraph_node.pos = node22.pos.concat();
    graph.add(subgraph_node);
    subgraph_node.buildFromNodes(nodes_list);
    canvas.deselectAll();
    canvas.setDirty(true, true);
  }
  static onMenuNodeClone(value3, options3, e, menu, node22) {
    const graph = node22.graph;
    graph.beforeChange();
    const newSelected = /* @__PURE__ */ new Set();
    const fApplyMultiNode = /* @__PURE__ */ __name(function(node3, newNodes) {
      if (node3.clonable === false) return;
      const newnode = node3.clone();
      if (!newnode) return;
      newnode.pos = [node3.pos[0] + 5, node3.pos[1] + 5];
      node3.graph.add(newnode);
      newNodes.add(newnode);
    }, "fApplyMultiNode");
    const canvas = LGraphCanvas.active_canvas;
    if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22, newSelected);
    } else {
      for (const i2 in canvas.selected_nodes) {
        fApplyMultiNode(canvas.selected_nodes[i2], newSelected);
      }
    }
    if (newSelected.size) {
      canvas.selectNodes([...newSelected]);
    }
    graph.afterChange();
    canvas.setDirty(true, true);
  }
  /**
   * clears all the data inside
   *
   */
  clear() {
    this.frame = 0;
    this.last_draw_time = 0;
    this.render_time = 0;
    this.fps = 0;
    this.dragging_rectangle = null;
    this.selected_nodes = {};
    this.selected_group = null;
    this.visible_nodes = [];
    this.node_dragged = null;
    this.node_over = null;
    this.node_capturing_input = null;
    this.connecting_links = null;
    this.highlighted_links = {};
    this.dragging_canvas = false;
    this.#dirty();
    this.dirty_area = null;
    this.node_in_panel = null;
    this.node_widget = null;
    this.last_mouse = [0, 0];
    this.last_mouseclick = 0;
    this.pointer_is_down = false;
    this.pointer_is_double = false;
    this.visible_area.set([0, 0, 0, 0]);
    this.onClear?.();
  }
  /**
   * assigns a graph, you can reassign graphs to the same canvas
   *
   * @param {LGraph} graph
   */
  setGraph(graph, skip_clear) {
    if (this.graph == graph) return;
    if (!skip_clear) this.clear();
    if (!graph && this.graph) {
      this.graph.detachCanvas(this);
      return;
    }
    graph.attachCanvas(this);
    this._graph_stack &&= null;
    this.setDirty(true, true);
  }
  /**
   * returns the top level graph (in case there are subgraphs open on the canvas)
   *
   * @return {LGraph} graph
   */
  getTopGraph() {
    return this._graph_stack.length ? this._graph_stack[0] : this.graph;
  }
  /**
   * opens a graph contained inside a node in the current graph
   *
   * @param {LGraph} graph
   */
  openSubgraph(graph) {
    if (!graph) throw "graph cannot be null";
    if (this.graph == graph) throw "graph cannot be the same";
    this.clear();
    if (this.graph) {
      this._graph_stack ||= [];
      this._graph_stack.push(this.graph);
    }
    graph.attachCanvas(this);
    this.checkPanels();
    this.setDirty(true, true);
  }
  /**
   * closes a subgraph contained inside a node
   *
   * @param {LGraph} assigns a graph
   */
  closeSubgraph() {
    if (!this._graph_stack || this._graph_stack.length == 0) return;
    const subgraph_node = this.graph._subgraph_node;
    const graph = this._graph_stack.pop();
    this.selected_nodes = {};
    this.highlighted_links = {};
    graph.attachCanvas(this);
    this.setDirty(true, true);
    if (subgraph_node) {
      this.centerOnNode(subgraph_node);
      this.selectNodes([subgraph_node]);
    }
    this.ds.offset = [0, 0];
    this.ds.scale = 1;
  }
  /**
   * returns the visually active graph (in case there are more in the stack)
   * @return {LGraph} the active graph
   */
  getCurrentGraph() {
    return this.graph;
  }
  /**
   * Finds the canvas if required, throwing on failure.
   * @param canvas Canvas element, or its element ID
   * @returns The canvas element
   * @throws If {@link canvas} is an element ID that does not belong to a valid HTML canvas element
   */
  #validateCanvas(canvas) {
    if (typeof canvas === "string") {
      const el = document.getElementById(canvas);
      if (!(el instanceof HTMLCanvasElement)) throw "Error validating LiteGraph canvas: Canvas element not found";
      return el;
    }
    return canvas;
  }
  /**
   * Sets the current HTML canvas element.
   * Calls bindEvents to add input event listeners, and (re)creates the background canvas.
   *
   * @param canvas The canvas element to assign, or its HTML element ID.  If null or undefined, the current reference is cleared.
   * @param skip_events If true, events on the previous canvas will not be removed.  Has no effect on the first invocation.
   */
  setCanvas(canvas, skip_events) {
    const element = this.#validateCanvas(canvas);
    if (element === this.canvas) return;
    if (!element && this.canvas && !skip_events) this.unbindEvents();
    this.canvas = element;
    this.ds.element = element;
    if (!element) return;
    element.className += " lgraphcanvas";
    element.data = this;
    element.tabindex = "1";
    this.bgcanvas = null;
    if (!this.bgcanvas) {
      this.bgcanvas = document.createElement("canvas");
      this.bgcanvas.width = this.canvas.width;
      this.bgcanvas.height = this.canvas.height;
    }
    if (element.getContext == null) {
      if (element.localName != "canvas") {
        throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + element.localName;
      }
      throw "This browser doesn't support Canvas";
    }
    const ctx = this.ctx = element.getContext("2d");
    if (ctx == null) {
      if (!element.webgl_enabled) {
        console.warn(
          "This canvas seems to be WebGL, enabling WebGL renderer"
        );
      }
      this.enableWebGL();
    }
    if (!skip_events) this.bindEvents();
  }
  /** Captures an event and prevents default - returns false. */
  _doNothing(e) {
    e.preventDefault();
    return false;
  }
  /** Captures an event and prevents default - returns true. */
  _doReturnTrue(e) {
    e.preventDefault();
    return true;
  }
  /**
   * binds mouse, keyboard, touch and drag events to the canvas
   **/
  bindEvents() {
    if (this._events_binded) {
      console.warn("LGraphCanvas: events already binded");
      return;
    }
    const canvas = this.canvas;
    const ref_window2 = this.getCanvasWindow();
    const document2 = ref_window2.document;
    this._mousedown_callback = this.processMouseDown.bind(this);
    this._mousewheel_callback = this.processMouseWheel.bind(this);
    this._mousemove_callback = this.processMouseMove.bind(this);
    this._mouseup_callback = this.processMouseUp.bind(this);
    this._mouseout_callback = this.processMouseOut.bind(this);
    LiteGraph.pointerListenerAdd(canvas, "down", this._mousedown_callback, true);
    canvas.addEventListener("mousewheel", this._mousewheel_callback, false);
    LiteGraph.pointerListenerAdd(canvas, "up", this._mouseup_callback, true);
    LiteGraph.pointerListenerAdd(canvas, "move", this._mousemove_callback);
    canvas.addEventListener("pointerout", this._mouseout_callback);
    canvas.addEventListener("contextmenu", this._doNothing);
    canvas.addEventListener(
      "DOMMouseScroll",
      this._mousewheel_callback,
      false
    );
    this._key_callback = this.processKey.bind(this);
    canvas.addEventListener("keydown", this._key_callback, true);
    document2.addEventListener("keyup", this._key_callback, true);
    this._ondrop_callback = this.processDrop.bind(this);
    canvas.addEventListener("dragover", this._doNothing, false);
    canvas.addEventListener("dragend", this._doNothing, false);
    canvas.addEventListener("drop", this._ondrop_callback, false);
    canvas.addEventListener("dragenter", this._doReturnTrue, false);
    this._events_binded = true;
  }
  /**
   * unbinds mouse events from the canvas
   **/
  unbindEvents() {
    if (!this._events_binded) {
      console.warn("LGraphCanvas: no events binded");
      return;
    }
    const ref_window2 = this.getCanvasWindow();
    const document2 = ref_window2.document;
    this.canvas.removeEventListener("pointerout", this._mouseout_callback);
    LiteGraph.pointerListenerRemove(this.canvas, "move", this._mousemove_callback);
    LiteGraph.pointerListenerRemove(this.canvas, "up", this._mouseup_callback);
    LiteGraph.pointerListenerRemove(this.canvas, "down", this._mousedown_callback);
    this.canvas.removeEventListener(
      "mousewheel",
      this._mousewheel_callback
    );
    this.canvas.removeEventListener(
      "DOMMouseScroll",
      this._mousewheel_callback
    );
    this.canvas.removeEventListener("keydown", this._key_callback);
    document2.removeEventListener("keyup", this._key_callback);
    this.canvas.removeEventListener("contextmenu", this._doNothing);
    this.canvas.removeEventListener("drop", this._ondrop_callback);
    this.canvas.removeEventListener("dragenter", this._doReturnTrue);
    this._mousedown_callback = null;
    this._mousewheel_callback = null;
    this._key_callback = null;
    this._ondrop_callback = null;
    this._events_binded = false;
  }
  /**
   * this function allows to render the canvas using WebGL instead of Canvas2D
   * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL
   **/
  enableWebGL() {
    if (typeof GL === "undefined") {
      throw "litegl.js must be included to use a WebGL canvas";
    }
    if (typeof enableWebGLCanvas === "undefined") {
      throw "webglCanvas.js must be included to use this feature";
    }
    this.gl = this.ctx = enableWebGLCanvas(this.canvas);
    this.ctx.webgl = true;
    this.bgcanvas = this.canvas;
    this.bgctx = this.gl;
    this.canvas.webgl_enabled = true;
  }
  /**
   * marks as dirty the canvas, this way it will be rendered again
   *
   * @class LGraphCanvas
   * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)
   * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)
   */
  setDirty(fgcanvas, bgcanvas) {
    if (fgcanvas) this.dirty_canvas = true;
    if (bgcanvas) this.dirty_bgcanvas = true;
  }
  /** Marks the entire canvas as dirty. */
  #dirty() {
    this.dirty_canvas = true;
    this.dirty_bgcanvas = true;
  }
  /**
   * Used to attach the canvas in a popup
   *
   * @return {window} returns the window where the canvas is attached (the DOM root node)
   */
  getCanvasWindow() {
    if (!this.canvas) return window;
    const doc2 = this.canvas.ownerDocument;
    return doc2.defaultView || doc2.parentWindow;
  }
  /**
   * starts rendering the content of the canvas when needed
   *
   */
  startRendering() {
    if (this.is_rendering) return;
    this.is_rendering = true;
    renderFrame.call(this);
    function renderFrame() {
      if (!this.pause_rendering) {
        this.draw();
      }
      const window2 = this.getCanvasWindow();
      if (this.is_rendering) {
        window2.requestAnimationFrame(renderFrame.bind(this));
      }
    }
    __name(renderFrame, "renderFrame");
  }
  /**
   * stops rendering the content of the canvas (to save resources)
   *
   */
  stopRendering() {
    this.is_rendering = false;
  }
  /* LiteGraphCanvas input */
  //used to block future mouse events (because of im gui)
  blockClick() {
    this.block_click = true;
    this.last_mouseclick = 0;
  }
  /**
   * Gets the widget at the current cursor position
   * @param node Optional node to check for widgets under cursor
   * @returns The widget located at the current cursor position or null
   */
  getWidgetAtCursor(node22) {
    node22 ??= this.node_over;
    if (!node22.widgets) return null;
    const graphPos = this.graph_mouse;
    const x2 = graphPos[0] - node22.pos[0];
    const y2 = graphPos[1] - node22.pos[1];
    for (const widget of node22.widgets) {
      if (widget.hidden || widget.advanced && !node22.showAdvanced) continue;
      let widgetWidth, widgetHeight;
      if (widget.computeSize) {
        [widgetWidth, widgetHeight] = widget.computeSize(node22.size[0]);
      } else {
        widgetWidth = widget.width || node22.size[0];
        widgetHeight = LiteGraph.NODE_WIDGET_HEIGHT;
      }
      if (widget.last_y !== void 0 && x2 >= 6 && x2 <= widgetWidth - 12 && y2 >= widget.last_y && y2 <= widget.last_y + widgetHeight) {
        return widget;
      }
    }
    return null;
  }
  /**
   * Clears highlight and mouse-over information from nodes that should not have it.
   * 
   * Intended to be called when the pointer moves away from a node.
   * @param {LGraphNode} node The node that the mouse is now over
   * @param {MouseEvent} e MouseEvent that is triggering this
   */
  updateMouseOverNodes(node22, e) {
    const nodes = this.graph._nodes;
    const l = nodes.length;
    for (let i2 = 0; i2 < l; ++i2) {
      if (nodes[i2].mouseOver && node22 != nodes[i2]) {
        nodes[i2].mouseOver = null;
        this._highlight_input = null;
        this._highlight_pos = null;
        this.link_over_widget = null;
        nodes[i2].lostFocusAt = LiteGraph.getTime();
        this.node_over?.onMouseLeave?.(e);
        this.node_over = null;
        this.dirty_canvas = true;
      }
    }
  }
  processMouseDown(e) {
    if (this.set_canvas_dirty_on_mouse_event)
      this.dirty_canvas = true;
    const { graph } = this;
    if (!graph) return;
    this.adjustMouseEvent(e);
    const ref_window2 = this.getCanvasWindow();
    LGraphCanvas.active_canvas = this;
    const x2 = e.clientX;
    const y2 = e.clientY;
    this.ds.viewport = this.viewport;
    const is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
    if (!this.options.skip_events) {
      LiteGraph.pointerListenerRemove(this.canvas, "move", this._mousemove_callback);
      LiteGraph.pointerListenerAdd(ref_window2.document, "move", this._mousemove_callback, true);
      LiteGraph.pointerListenerAdd(ref_window2.document, "up", this._mouseup_callback, true);
    }
    if (!is_inside) return;
    let node22 = graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);
    let skip_action = false;
    const now2 = LiteGraph.getTime();
    const is_double_click = now2 - this.last_mouseclick < 300;
    this.mouse[0] = x2;
    this.mouse[1] = y2;
    this.graph_mouse[0] = e.canvasX;
    this.graph_mouse[1] = e.canvasY;
    this.last_click_position = [this.mouse[0], this.mouse[1]];
    this.pointer_is_double = this.pointer_is_down && e.isPrimary;
    this.pointer_is_down = true;
    this.canvas.focus();
    LiteGraph.closeAllContextMenus(ref_window2);
    if (this.onMouse?.(e) == true) return;
    if (e.which == 1 && !this.pointer_is_double) {
      if ((e.metaKey || e.ctrlKey) && !e.altKey) {
        const dragRect = new Float32Array(4);
        dragRect[0] = e.canvasX;
        dragRect[1] = e.canvasY;
        dragRect[2] = 1;
        dragRect[3] = 1;
        this.dragging_rectangle = dragRect;
        skip_action = true;
      }
      if (LiteGraph.alt_drag_do_clone_nodes && e.altKey && !e.ctrlKey && node22 && this.allow_interaction && !skip_action && !this.read_only) {
        const node_data = node22.clone()?.serialize();
        const cloned = LiteGraph.createNode(node_data.type);
        if (cloned) {
          cloned.configure(node_data);
          cloned.pos[0] += 5;
          cloned.pos[1] += 5;
          graph.add(cloned, false);
          node22 = cloned;
          skip_action = true;
          if (this.allow_dragnodes) {
            graph.beforeChange();
            this.node_dragged = node22;
            this.isDragging = true;
          }
          this.processSelect(node22, e);
        }
      }
      let clicking_canvas_bg = false;
      if (node22 && (this.allow_interaction || node22.flags.allow_interaction) && !skip_action && !this.read_only) {
        if (!this.live_mode && !node22.flags.pinned) {
          this.bringToFront(node22);
        }
        if (this.allow_interaction && !this.connecting_links && !node22.flags.collapsed && !this.live_mode) {
          if (!skip_action && node22.resizable !== false && node22.inResizeCorner(e.canvasX, e.canvasY)) {
            graph.beforeChange();
            this.resizing_node = node22;
            this.canvas.style.cursor = "se-resize";
            skip_action = true;
          } else {
            if (node22.outputs) {
              for (let i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
                const output = node22.outputs[i2];
                const link_pos = node22.getConnectionPos(false, i2);
                if (isInsideRectangle(
                  e.canvasX,
                  e.canvasY,
                  link_pos[0] - 15,
                  link_pos[1] - 10,
                  30,
                  20
                )) {
                  if (e.shiftKey) {
                    if (output.links?.length > 0) {
                      this.connecting_links = [];
                      for (const linkId of output.links) {
                        const link = graph._links.get(linkId);
                        const slot = link.target_slot;
                        const linked_node = graph._nodes_by_id[link.target_id];
                        const input = linked_node.inputs[slot];
                        const pos2 = linked_node.getConnectionPos(true, slot);
                        this.connecting_links.push({
                          node: linked_node,
                          slot,
                          input,
                          output: null,
                          pos: pos2,
                          direction: node22.horizontal !== true ? LinkDirection.RIGHT : LinkDirection.CENTER
                        });
                      }
                      skip_action = true;
                      break;
                    }
                  }
                  output.slot_index = i2;
                  this.connecting_links = [
                    {
                      node: node22,
                      slot: i2,
                      input: null,
                      output,
                      pos: link_pos
                    }
                  ];
                  if (LiteGraph.shift_click_do_break_link_from) {
                    if (e.shiftKey) {
                      node22.disconnectOutput(i2);
                    }
                  } else if (LiteGraph.ctrl_alt_click_do_break_link) {
                    if (e.ctrlKey && e.altKey && !e.shiftKey) {
                      node22.disconnectOutput(i2);
                    }
                  }
                  if (is_double_click) {
                    node22.onOutputDblClick?.(i2, e);
                  } else {
                    node22.onOutputClick?.(i2, e);
                  }
                  skip_action = true;
                  break;
                }
              }
            }
            if (node22.inputs) {
              for (let i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
                const input = node22.inputs[i2];
                const link_pos = node22.getConnectionPos(true, i2);
                if (isInsideRectangle(
                  e.canvasX,
                  e.canvasY,
                  link_pos[0] - 15,
                  link_pos[1] - 10,
                  30,
                  20
                )) {
                  if (is_double_click) {
                    node22.onInputDblClick?.(i2, e);
                  } else {
                    node22.onInputClick?.(i2, e);
                  }
                  if (input.link !== null) {
                    const link_info = graph._links.get(input.link);
                    const slot = link_info.origin_slot;
                    const linked_node = graph._nodes_by_id[link_info.origin_id];
                    if (LiteGraph.click_do_break_link_to || LiteGraph.ctrl_alt_click_do_break_link && e.ctrlKey && e.altKey && !e.shiftKey) {
                      node22.disconnectInput(i2);
                    } else if (e.shiftKey) {
                      this.connecting_links = [{
                        node: linked_node,
                        slot,
                        output: linked_node.outputs[slot],
                        pos: linked_node.getConnectionPos(false, slot)
                      }];
                      this.dirty_bgcanvas = true;
                      skip_action = true;
                    } else if (this.allow_reconnect_links) {
                      if (!LiteGraph.click_do_break_link_to) {
                        node22.disconnectInput(i2);
                      }
                      this.connecting_links = [
                        {
                          node: linked_node,
                          slot,
                          input: null,
                          output: linked_node.outputs[slot],
                          pos: linked_node.getConnectionPos(false, slot)
                        }
                      ];
                      this.dirty_bgcanvas = true;
                      skip_action = true;
                    } else ;
                  }
                  if (!skip_action) {
                    this.connecting_links = [
                      {
                        node: node22,
                        slot: i2,
                        input,
                        output: null,
                        pos: link_pos
                      }
                    ];
                    this.dirty_bgcanvas = true;
                    skip_action = true;
                  }
                  break;
                }
              }
            }
          }
        }
        if (!skip_action) {
          let block_drag_node = node22?.pinned ? true : false;
          const pos2 = [e.canvasX - node22.pos[0], e.canvasY - node22.pos[1]];
          const widget = this.processNodeWidgets(node22, this.graph_mouse, e);
          if (widget) {
            block_drag_node = true;
            this.node_widget = [node22, widget];
          }
          if (this.allow_interaction && is_double_click && this.selectedItems.has(node22)) {
            if (pos2[1] < 0) {
              node22.onNodeTitleDblClick?.(e, pos2, this);
            }
            node22.onDblClick?.(e, pos2, this);
            this.processNodeDblClicked(node22);
            block_drag_node = true;
          }
          if (node22.onMouseDown?.(e, pos2, this)) {
            block_drag_node = true;
          } else {
            if (node22.subgraph && !node22.skip_subgraph_button) {
              if (!node22.flags.collapsed && pos2[0] > node22.size[0] - LiteGraph.NODE_TITLE_HEIGHT && pos2[1] < 0) {
                const that2 = this;
                setTimeout(function() {
                  that2.openSubgraph(node22.subgraph);
                }, 10);
              }
            }
            if (this.live_mode) {
              clicking_canvas_bg = true;
              block_drag_node = true;
            }
          }
          if (!block_drag_node) {
            if (this.allow_dragnodes) {
              graph.beforeChange();
              this.node_dragged = node22;
              this.isDragging = true;
            }
            if (!(e.shiftKey && !e.ctrlKey && !e.altKey) || !node22.selected) {
              this.processSelect(node22, e);
            }
          } else if (!node22.selected) {
            this.processSelect(node22, e);
          }
          this.dirty_canvas = true;
        }
      } else {
        if (this.reroutesEnabled && !skip_action && !this.read_only) {
          const reroute = graph.getRerouteOnPos(e.canvasX, e.canvasY);
          if (reroute) {
            this.processSelect(reroute, e);
            if (e.shiftKey) {
              const link = graph._links.get(reroute.linkIds.values().next().value);
              const outputNode = graph.getNodeById(link.origin_id);
              const slot = link.origin_slot;
              this.connecting_links = [{
                node: outputNode,
                slot,
                input: null,
                output: outputNode.outputs[slot],
                pos: outputNode.getConnectionPos(false, slot),
                afterRerouteId: reroute.id
              }];
            } else {
              this.isDragging = true;
            }
            skip_action = true;
          }
        }
        if (!skip_action) {
          if (!this.read_only) {
            const lineWidth = this.ctx.lineWidth;
            this.ctx.lineWidth = this.connections_width + 7;
            for (const linkSegment of this.renderedPaths) {
              const centre = linkSegment._pos;
              if (!centre) continue;
              if (isInsideRectangle(e.canvasX, e.canvasY, centre[0] - 4, centre[1] - 4, 8, 8)) {
                this.showLinkMenu(linkSegment, e);
                this.over_link_center = null;
                break;
              }
              if ((e.shiftKey || e.altKey) && linkSegment.path && this.ctx.isPointInStroke(linkSegment.path, e.canvasX, e.canvasY)) {
                if (e.shiftKey && !e.altKey) {
                  const slot = linkSegment.origin_slot;
                  const originNode = graph._nodes_by_id[linkSegment.origin_id];
                  const connecting = {
                    node: originNode,
                    slot,
                    output: originNode.outputs[slot],
                    pos: originNode.getConnectionPos(false, slot)
                  };
                  this.connecting_links = [connecting];
                  if (this.reroutesEnabled && linkSegment.parentId) connecting.afterRerouteId = linkSegment.parentId;
                  skip_action = true;
                  break;
                } else if (this.reroutesEnabled && e.altKey && !e.shiftKey) {
                  const newReroute = graph.createReroute([e.canvasX, e.canvasY], linkSegment);
                  this.processSelect(newReroute, e);
                  this.isDragging = true;
                  skip_action = true;
                  break;
                }
              }
            }
            this.ctx.lineWidth = lineWidth;
          }
          const group = graph.getGroupOnPos(e.canvasX, e.canvasY);
          this.selected_group = group;
          if (group && !this.read_only) {
            if (e.ctrlKey) {
              this.dragging_rectangle = null;
            }
            if (group.isInResize(e.canvasX, e.canvasY)) {
              this.resizingGroup = group;
            } else {
              const f = group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
              const headerHeight = f * 1.4;
              if (isInsideRectangle(e.canvasX, e.canvasY, group.pos[0], group.pos[1], group.size[0], headerHeight)) {
                group.recomputeInsideNodes();
                this.processSelect(group, e, true);
                this.isDragging = true;
                skip_action = true;
              }
            }
            if (is_double_click) {
              this.emitEvent({
                subType: "group-double-click",
                originalEvent: e,
                group
              });
            }
          } else if (is_double_click && !this.read_only) {
            if (this.allow_searchbox) {
              this.showSearchBox(e);
              e.preventDefault();
              e.stopPropagation();
            }
            this.emitEvent({
              subType: "empty-double-click",
              originalEvent: e
            });
          }
          clicking_canvas_bg = true;
        }
      }
      if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {
        this.dragging_canvas = true;
      }
    } else if (e.which == 2) {
      if (LiteGraph.middle_click_slot_add_default_node) {
        if (node22 && this.allow_interaction && !skip_action && !this.read_only) {
          if (!this.connecting_links && !node22.flags.collapsed && !this.live_mode) {
            let mClikSlot = false;
            let mClikSlot_index = false;
            let mClikSlot_isOut = false;
            if (node22.outputs) {
              for (let i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
                const output = node22.outputs[i2];
                const link_pos = node22.getConnectionPos(false, i2);
                if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {
                  mClikSlot = output;
                  mClikSlot_index = i2;
                  mClikSlot_isOut = true;
                  break;
                }
              }
            }
            if (node22.inputs) {
              for (let i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
                const input = node22.inputs[i2];
                const link_pos = node22.getConnectionPos(true, i2);
                if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {
                  mClikSlot = input;
                  mClikSlot_index = i2;
                  mClikSlot_isOut = false;
                  break;
                }
              }
            }
            if (mClikSlot && mClikSlot_index !== false) {
              const alphaPosY = 0.5 - (mClikSlot_index + 1) / (mClikSlot_isOut ? node22.outputs.length : node22.inputs.length);
              const node_bounding = node22.getBounding();
              const posRef = [
                !mClikSlot_isOut ? node_bounding[0] : node_bounding[0] + node_bounding[2],
                e.canvasY - 80
              ];
              this.createDefaultNodeForSlot({
                nodeFrom: !mClikSlot_isOut ? null : node22,
                slotFrom: !mClikSlot_isOut ? null : mClikSlot_index,
                nodeTo: !mClikSlot_isOut ? node22 : null,
                slotTo: !mClikSlot_isOut ? mClikSlot_index : null,
                position: posRef,
                nodeType: "AUTO",
                posAdd: [!mClikSlot_isOut ? -30 : 30, -alphaPosY * 130],
                posSizeFix: [!mClikSlot_isOut ? -1 : 0, 0]
              });
              skip_action = true;
            }
          }
        }
      }
      if (!skip_action && this.allow_dragcanvas) {
        this.dragging_canvas = true;
      }
    } else if (e.which == 3 || this.pointer_is_double) {
      if (this.allow_interaction && !skip_action && !this.read_only) {
        if (node22) {
          this.processSelect(node22, e, true);
        }
        this.processContextMenu(node22, e);
      }
    }
    this.last_mouse = [x2, y2];
    this.last_mouseclick = LiteGraph.getTime();
    this.last_mouse_dragging = true;
    graph.change();
    if (!ref_window2.document.activeElement || ref_window2.document.activeElement.nodeName.toLowerCase() != "input" && ref_window2.document.activeElement.nodeName.toLowerCase() != "textarea") {
      e.preventDefault();
    }
    e.stopPropagation();
    this.onMouseDown?.(e);
    return false;
  }
  /**
   * Called when a mouse move event has to be processed
   **/
  processMouseMove(e) {
    if (this.autoresize) this.resize();
    if (this.set_canvas_dirty_on_mouse_event)
      this.dirty_canvas = true;
    if (!this.graph) return;
    LGraphCanvas.active_canvas = this;
    this.adjustMouseEvent(e);
    const mouse = [e.clientX, e.clientY];
    this.mouse[0] = mouse[0];
    this.mouse[1] = mouse[1];
    const delta2 = [
      mouse[0] - this.last_mouse[0],
      mouse[1] - this.last_mouse[1]
    ];
    this.last_mouse = mouse;
    this.graph_mouse[0] = e.canvasX;
    this.graph_mouse[1] = e.canvasY;
    if (this.block_click) {
      e.preventDefault();
      return false;
    }
    e.dragging = this.last_mouse_dragging;
    if (this.node_widget) {
      this.processNodeWidgets(
        this.node_widget[0],
        this.graph_mouse,
        e,
        this.node_widget[1]
      );
      this.dirty_canvas = true;
    }
    const node22 = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);
    const { resizingGroup } = this;
    if (this.dragging_rectangle) {
      this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];
      this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];
      this.dirty_canvas = true;
    } else if (resizingGroup && !this.read_only) {
      const resized = resizingGroup.resize(
        e.canvasX - resizingGroup.pos[0],
        e.canvasY - resizingGroup.pos[1]
      );
      if (resized) this.dirty_bgcanvas = true;
    } else if (this.dragging_canvas) {
      this.ds.offset[0] += delta2[0] / this.ds.scale;
      this.ds.offset[1] += delta2[1] / this.ds.scale;
      this.#dirty();
    } else if ((this.allow_interaction || node22 && node22.flags.allow_interaction) && !this.read_only) {
      if (this.connecting_links) this.dirty_canvas = true;
      this.updateMouseOverNodes(node22, e);
      if (node22) {
        if (node22.redraw_on_mouse)
          this.dirty_canvas = true;
        const pos2 = [0, 0];
        const inputId = this.isOverNodeInput(node22, e.canvasX, e.canvasY, pos2);
        const outputId = this.isOverNodeOutput(node22, e.canvasX, e.canvasY, pos2);
        const overWidget = this.getWidgetAtCursor(node22);
        if (!node22.mouseOver) {
          node22.mouseOver = {
            inputId: null,
            outputId: null,
            overWidget: null
          };
          this.node_over = node22;
          this.dirty_canvas = true;
          node22.onMouseEnter?.(e);
        }
        node22.onMouseMove?.(e, [e.canvasX - node22.pos[0], e.canvasY - node22.pos[1]], this);
        if (node22.mouseOver.inputId !== inputId || node22.mouseOver.outputId !== outputId || node22.mouseOver.overWidget !== overWidget) {
          node22.mouseOver.inputId = inputId;
          node22.mouseOver.outputId = outputId;
          node22.mouseOver.overWidget = overWidget;
          if (this.connecting_links) {
            const firstLink = this.connecting_links[0];
            let highlightPos = null;
            let highlightInput = null;
            let linkOverWidget = null;
            if (firstLink.node === node22) ;
            else if (firstLink.output) {
              if (inputId === -1 && outputId === -1) {
                if (this.getWidgetLinkType && overWidget) {
                  const widgetLinkType = this.getWidgetLinkType(overWidget, node22);
                  if (widgetLinkType && LiteGraph.isValidConnection(firstLink.output.type, widgetLinkType)) {
                    if (firstLink.node.isValidWidgetLink?.(firstLink.output.slot_index, node22, overWidget) !== false) {
                      linkOverWidget = overWidget;
                      this.link_over_widget_type = widgetLinkType;
                    }
                  }
                }
                if (!linkOverWidget) {
                  const targetSlotId = firstLink.node.findConnectByTypeSlot(true, node22, firstLink.output.type);
                  if (targetSlotId !== null && targetSlotId >= 0) {
                    node22.getConnectionPos(true, targetSlotId, pos2);
                    highlightPos = pos2;
                    highlightInput = node22.inputs[targetSlotId];
                  }
                }
              } else {
                if (inputId != -1 && node22.inputs[inputId] && LiteGraph.isValidConnection(firstLink.output.type, node22.inputs[inputId].type)) {
                  highlightPos = pos2;
                  highlightInput = node22.inputs[inputId];
                }
              }
            } else if (firstLink.input) {
              if (inputId === -1 && outputId === -1) {
                const targetSlotId = firstLink.node.findConnectByTypeSlot(false, node22, firstLink.input.type);
                if (targetSlotId !== null && targetSlotId >= 0) {
                  node22.getConnectionPos(false, targetSlotId, pos2);
                  highlightPos = pos2;
                }
              } else {
                if (outputId != -1 && node22.outputs[outputId] && LiteGraph.isValidConnection(firstLink.input.type, node22.outputs[outputId].type)) {
                  highlightPos = pos2;
                }
              }
            }
            this._highlight_pos = highlightPos;
            this._highlight_input = highlightInput;
            this.link_over_widget = linkOverWidget;
          }
          this.dirty_canvas = true;
        }
        if (this.canvas) {
          this.canvas.style.cursor = node22.inResizeCorner(e.canvasX, e.canvasY) ? "se-resize" : "crosshair";
        }
      } else {
        const segment = this.#getLinkCentreOnPos(e);
        if (this.over_link_center !== segment) {
          this.over_link_center = segment;
          this.dirty_bgcanvas = true;
        }
        if (this.canvas) {
          this.canvas.style.cursor = "";
        }
      }
      if (this.node_capturing_input && this.node_capturing_input != node22) {
        this.node_capturing_input.onMouseMove?.(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);
      }
      if (this.isDragging && !this.live_mode) {
        const selected2 = this.selectedItems;
        const allItems = e.ctrlKey ? selected2 : getAllNestedItems(selected2);
        const deltaX = delta2[0] / this.ds.scale;
        const deltaY = delta2[1] / this.ds.scale;
        for (const item2 of allItems) {
          if (!item2.pinned) item2.move(deltaX, deltaY, true);
        }
        this.#dirty();
      }
      if (this.resizing_node && !this.live_mode) {
        const desired_size = [e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1]];
        const min_size = this.resizing_node.computeSize();
        desired_size[0] = Math.max(min_size[0], desired_size[0]);
        desired_size[1] = Math.max(min_size[1], desired_size[1]);
        this.resizing_node.setSize(desired_size);
        this.canvas.style.cursor = "se-resize";
        this.#dirty();
      }
    }
    e.preventDefault();
    return false;
  }
  /**
   * Called when a mouse up event has to be processed
   **/
  processMouseUp(e) {
    if (e.isPrimary === false) return false;
    if (!this.graph) return;
    const window2 = this.getCanvasWindow();
    const document2 = window2.document;
    LGraphCanvas.active_canvas = this;
    if (!this.options.skip_events) {
      LiteGraph.pointerListenerRemove(document2, "move", this._mousemove_callback, true);
      LiteGraph.pointerListenerAdd(this.canvas, "move", this._mousemove_callback, true);
      LiteGraph.pointerListenerRemove(document2, "up", this._mouseup_callback, true);
    }
    this.adjustMouseEvent(e);
    const now2 = LiteGraph.getTime();
    e.click_time = now2 - this.last_mouseclick;
    this.last_mouse_dragging = false;
    this.last_click_position = null;
    this.block_click &&= false;
    if (e.which == 1) {
      this.resizingGroup = null;
      if (this.node_widget) {
        this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);
      }
      this.node_widget = null;
      this.selected_group = null;
      this.isDragging = false;
      const node22 = this.graph.getNodeOnPos(
        e.canvasX,
        e.canvasY,
        this.visible_nodes
      );
      const dragRect = this.dragging_rectangle;
      if (dragRect) {
        if (this.graph) {
          const nodes = this.graph._nodes;
          const node_bounding = new Float32Array(4);
          const w2 = Math.abs(dragRect[2]);
          const h2 = Math.abs(dragRect[3]);
          const startx = dragRect[2] < 0 ? dragRect[0] - w2 : dragRect[0];
          const starty = dragRect[3] < 0 ? dragRect[1] - h2 : dragRect[1];
          dragRect[0] = startx;
          dragRect[1] = starty;
          dragRect[2] = w2;
          dragRect[3] = h2;
          if (!node22 || w2 > 10 && h2 > 10) {
            const to_select = [];
            for (const nodeX of nodes) {
              nodeX.getBounding(node_bounding);
              if (!overlapBounding(dragRect, node_bounding)) continue;
              to_select.push(nodeX);
            }
            if (to_select.length) this.selectNodes(to_select, e.shiftKey);
            const groups = this.graph.groups;
            for (const group of groups) {
              if (!containsRect(dragRect, group._bounding)) continue;
              this.selectedItems.add(group);
              group.recomputeInsideNodes();
              group.selected = true;
            }
            if (this.reroutesEnabled) {
              for (const reroute of this.graph.reroutes.values()) {
                if (!isPointInRectangle(reroute.pos, dragRect)) continue;
                this.selectedItems.add(reroute);
                reroute.selected = true;
              }
            }
          } else {
            this.selectNodes([node22], e.shiftKey || e.ctrlKey || e.metaKey);
          }
        }
        this.dragging_rectangle = null;
      } else if (this.connecting_links) {
        if (node22) {
          for (const link of this.connecting_links) {
            this.#dirty();
            if (link.output) {
              const slot = this.isOverNodeInput(
                node22,
                e.canvasX,
                e.canvasY
              );
              if (slot != -1) {
                link.node.connect(link.slot, node22, slot, link.afterRerouteId);
              } else if (this.link_over_widget) {
                this.emitEvent({
                  subType: "connectingWidgetLink",
                  link,
                  node: node22,
                  widget: this.link_over_widget
                });
                this.link_over_widget = null;
              } else {
                link.node.connectByType(link.slot, node22, link.output.type, { afterRerouteId: link.afterRerouteId });
              }
            } else if (link.input) {
              const slot = this.isOverNodeOutput(
                node22,
                e.canvasX,
                e.canvasY
              );
              if (slot != -1) {
                node22.connect(slot, link.node, link.slot, link.afterRerouteId);
              } else {
                link.node.connectByTypeOutput(link.slot, node22, link.input.type, { afterRerouteId: link.afterRerouteId });
              }
            }
          }
        } else {
          const firstLink = this.connecting_links[0];
          const linkReleaseContext = firstLink.output ? {
            node_from: firstLink.node,
            slot_from: firstLink.output,
            type_filter_in: firstLink.output.type
          } : {
            node_to: firstLink.node,
            slot_from: firstLink.input,
            type_filter_out: firstLink.input.type
          };
          const linkReleaseContextExtended = {
            links: this.connecting_links
          };
          this.emitEvent({
            subType: "empty-release",
            originalEvent: e,
            linkReleaseContext: linkReleaseContextExtended
          });
          if (LiteGraph.release_link_on_empty_shows_menu) {
            if (e.shiftKey) {
              if (this.allow_searchbox) {
                this.showSearchBox(e, linkReleaseContext);
              }
            } else {
              if (firstLink.output) {
                this.showConnectionMenu({ nodeFrom: firstLink.node, slotFrom: firstLink.output, e });
              } else if (firstLink.input) {
                this.showConnectionMenu({ nodeTo: firstLink.node, slotTo: firstLink.input, e });
              }
            }
          }
        }
      } else if (this.resizing_node) {
        this.#dirty();
        this.graph.afterChange(this.resizing_node);
        this.resizing_node = null;
      } else if (this.node_dragged) {
        const { node_dragged } = this;
        if (e.click_time < 300 && node_dragged?.isPointInCollapse(e.canvasX, e.canvasY)) {
          node_dragged.collapse();
        }
        this.#dirty();
        node_dragged.pos[0] = Math.round(node_dragged.pos[0]);
        node_dragged.pos[1] = Math.round(node_dragged.pos[1]);
        if (this.graph.config.align_to_grid || this.align_to_grid) {
          node_dragged.alignToGrid();
        }
        this.onNodeMoved?.(node_dragged);
        this.graph.afterChange(node_dragged);
        this.node_dragged = null;
      } else {
        if (!node22 && e.click_time < 300 && !this.graph.getGroupTitlebarOnPos(e.canvasX, e.canvasY) && (!this.reroutesEnabled || !this.graph.getRerouteOnPos(e.canvasX, e.canvasY))) {
          this.processSelect(null, e);
        }
        this.dirty_canvas = true;
        this.dragging_canvas = false;
        this.node_over?.onMouseUp?.(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);
        this.node_capturing_input?.onMouseUp?.(e, [
          e.canvasX - this.node_capturing_input.pos[0],
          e.canvasY - this.node_capturing_input.pos[1]
        ]);
      }
      this.connecting_links = null;
    } else if (e.which == 2) {
      this.dirty_canvas = true;
      this.dragging_canvas = false;
    } else if (e.which == 3) {
      this.dirty_canvas = true;
      this.dragging_canvas = false;
    }
    this.pointer_is_down = false;
    this.pointer_is_double = false;
    this.graph.change();
    e.stopPropagation();
    e.preventDefault();
    return false;
  }
  /**
   * Called when the mouse moves off the canvas.  Clears all node hover states.
   * @param e
   */
  processMouseOut(e) {
    this.updateMouseOverNodes(null, e);
  }
  /**
   * Called when a mouse wheel event has to be processed
   **/
  processMouseWheel(e) {
    if (!this.graph || !this.allow_dragcanvas) return;
    const delta2 = e.wheelDeltaY ?? e.detail * -60;
    this.adjustMouseEvent(e);
    const pos2 = [e.clientX, e.clientY];
    if (this.viewport && !isPointInRectangle(pos2, this.viewport)) return;
    let scale = this.ds.scale;
    if (delta2 > 0) scale *= this.zoom_speed;
    else if (delta2 < 0) scale *= 1 / this.zoom_speed;
    this.ds.changeScale(scale, [e.clientX, e.clientY]);
    this.graph.change();
    e.preventDefault();
    return false;
  }
  /**
   * returns the INDEX if a position (in graph space) is on top of a node input slot
   **/
  isOverNodeInput(node22, canvasx, canvasy, slot_pos) {
    if (node22.inputs) {
      for (let i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
        const input = node22.inputs[i2];
        const link_pos = node22.getConnectionPos(true, i2);
        let is_inside = false;
        if (node22.horizontal) {
          is_inside = isInsideRectangle(
            canvasx,
            canvasy,
            link_pos[0] - 5,
            link_pos[1] - 10,
            10,
            20
          );
        } else {
          const width2 = 20 + ((input.label?.length ?? input.name?.length) || 3) * 7;
          is_inside = isInsideRectangle(
            canvasx,
            canvasy,
            link_pos[0] - 10,
            link_pos[1] - 10,
            width2,
            20
          );
        }
        if (is_inside) {
          if (slot_pos) {
            slot_pos[0] = link_pos[0];
            slot_pos[1] = link_pos[1];
          }
          return i2;
        }
      }
    }
    return -1;
  }
  /**
   * returns the INDEX if a position (in graph space) is on top of a node output slot
   **/
  isOverNodeOutput(node22, canvasx, canvasy, slot_pos) {
    if (node22.outputs) {
      for (let i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
        const link_pos = node22.getConnectionPos(false, i2);
        let is_inside = false;
        if (node22.horizontal) {
          is_inside = isInsideRectangle(
            canvasx,
            canvasy,
            link_pos[0] - 5,
            link_pos[1] - 10,
            10,
            20
          );
        } else {
          is_inside = isInsideRectangle(
            canvasx,
            canvasy,
            link_pos[0] - 10,
            link_pos[1] - 10,
            40,
            20
          );
        }
        if (is_inside) {
          if (slot_pos) {
            slot_pos[0] = link_pos[0];
            slot_pos[1] = link_pos[1];
          }
          return i2;
        }
      }
    }
    return -1;
  }
  /**
   * process a key event
   **/
  processKey(e) {
    if (!this.graph) return;
    let block_default = false;
    if (e.target.localName == "input") return;
    if (e.type == "keydown") {
      if (e.keyCode == 32) {
        this.read_only = true;
        if (this._previously_dragging_canvas === null) {
          this._previously_dragging_canvas = this.dragging_canvas;
        }
        this.dragging_canvas = this.pointer_is_down;
        block_default = true;
      } else if (e.keyCode == 27) {
        this.node_panel?.close();
        this.options_panel?.close();
        block_default = true;
      } else if (e.keyCode == 65 && e.ctrlKey) {
        this.selectItems();
        block_default = true;
      } else if (e.keyCode === 67 && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
        if (this.selected_nodes) {
          this.copyToClipboard();
          block_default = true;
        }
      } else if (e.keyCode === 86 && (e.metaKey || e.ctrlKey)) {
        this.pasteFromClipboard(e.shiftKey);
      } else if (e.keyCode == 46 || e.keyCode == 8) {
        if (e.target.localName != "input" && e.target.localName != "textarea") {
          this.deleteSelected();
          block_default = true;
        }
      }
      if (this.selected_nodes) {
        for (const i2 in this.selected_nodes) {
          this.selected_nodes[i2].onKeyDown?.(e);
        }
      }
    } else if (e.type == "keyup") {
      if (e.keyCode == 32) {
        this.read_only = false;
        this.dragging_canvas = this._previously_dragging_canvas ?? false;
        this._previously_dragging_canvas = null;
      }
      if (this.selected_nodes) {
        for (const i2 in this.selected_nodes) {
          this.selected_nodes[i2].onKeyUp?.(e);
        }
      }
    }
    this.graph.change();
    if (block_default) {
      e.preventDefault();
      e.stopImmediatePropagation();
      return false;
    }
  }
  copyToClipboard(nodes) {
    const clipboard_info = {
      nodes: [],
      links: []
    };
    let index2 = 0;
    const selected_nodes_array = [];
    if (!nodes) nodes = this.selected_nodes;
    for (const i2 in nodes) {
      const node22 = nodes[i2];
      if (node22.clonable === false) continue;
      node22._relative_id = index2;
      selected_nodes_array.push(node22);
      index2 += 1;
    }
    for (let i2 = 0; i2 < selected_nodes_array.length; ++i2) {
      const node22 = selected_nodes_array[i2];
      const cloned = node22.clone();
      if (!cloned) {
        console.warn("node type not found: " + node22.type);
        continue;
      }
      clipboard_info.nodes.push(cloned.serialize());
      if (node22.inputs?.length) {
        for (let j = 0; j < node22.inputs.length; ++j) {
          const input = node22.inputs[j];
          if (!input || input.link == null) continue;
          const link_info = this.graph._links.get(input.link);
          if (!link_info) continue;
          const target_node = this.graph.getNodeById(link_info.origin_id);
          if (!target_node) continue;
          clipboard_info.links.push([
            target_node._relative_id,
            link_info.origin_slot,
            //j,
            node22._relative_id,
            link_info.target_slot,
            target_node.id
          ]);
        }
      }
    }
    localStorage.setItem(
      "litegrapheditor_clipboard",
      JSON.stringify(clipboard_info)
    );
  }
  emitEvent(detail) {
    this.canvas.dispatchEvent(new CustomEvent(
      "litegraph:canvas",
      {
        bubbles: true,
        detail
      }
    ));
  }
  /** @todo Refactor to where it belongs - e.g. Deleting / creating nodes is not actually canvas event. */
  emitBeforeChange() {
    this.emitEvent({
      subType: "before-change"
    });
  }
  /** @todo See {@link emitBeforeChange} */
  emitAfterChange() {
    this.emitEvent({
      subType: "after-change"
    });
  }
  _pasteFromClipboard(isConnectUnselected = false) {
    if (!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) return;
    const data22 = localStorage.getItem("litegrapheditor_clipboard");
    if (!data22) return;
    this.graph.beforeChange();
    const clipboard_info = JSON.parse(data22);
    let posMin = false;
    let posMinIndexes = false;
    for (let i2 = 0; i2 < clipboard_info.nodes.length; ++i2) {
      if (posMin) {
        if (posMin[0] > clipboard_info.nodes[i2].pos[0]) {
          posMin[0] = clipboard_info.nodes[i2].pos[0];
          posMinIndexes[0] = i2;
        }
        if (posMin[1] > clipboard_info.nodes[i2].pos[1]) {
          posMin[1] = clipboard_info.nodes[i2].pos[1];
          posMinIndexes[1] = i2;
        }
      } else {
        posMin = [clipboard_info.nodes[i2].pos[0], clipboard_info.nodes[i2].pos[1]];
        posMinIndexes = [i2, i2];
      }
    }
    const nodes = [];
    for (let i2 = 0; i2 < clipboard_info.nodes.length; ++i2) {
      const node_data = clipboard_info.nodes[i2];
      const node22 = LiteGraph.createNode(node_data.type);
      if (node22) {
        node22.configure(node_data);
        node22.pos[0] += this.graph_mouse[0] - posMin[0];
        node22.pos[1] += this.graph_mouse[1] - posMin[1];
        this.graph.add(node22, true);
        nodes.push(node22);
      }
    }
    for (let i2 = 0; i2 < clipboard_info.links.length; ++i2) {
      const link_info = clipboard_info.links[i2];
      let origin_node = void 0;
      const origin_node_relative_id = link_info[0];
      if (origin_node_relative_id != null) {
        origin_node = nodes[origin_node_relative_id];
      } else if (LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {
        const origin_node_id = link_info[4];
        if (origin_node_id) {
          origin_node = this.graph.getNodeById(origin_node_id);
        }
      }
      const target_node = nodes[link_info[2]];
      if (origin_node && target_node)
        origin_node.connect(link_info[1], target_node, link_info[3]);
      else
        console.warn("Warning, nodes missing on pasting");
    }
    this.selectNodes(nodes);
    this.graph.afterChange();
  }
  pasteFromClipboard(isConnectUnselected = false) {
    this.emitBeforeChange();
    try {
      this._pasteFromClipboard(isConnectUnselected);
    } finally {
      this.emitAfterChange();
    }
  }
  /**
   * process a item drop event on top the canvas
   **/
  processDrop(e) {
    e.preventDefault();
    this.adjustMouseEvent(e);
    const x2 = e.clientX;
    const y2 = e.clientY;
    const is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
    if (!is_inside) return;
    const pos2 = [e.canvasX, e.canvasY];
    const node22 = this.graph ? this.graph.getNodeOnPos(pos2[0], pos2[1]) : null;
    if (!node22) {
      const r = this.onDropItem?.(e);
      if (!r) this.checkDropItem(e);
      return;
    }
    if (node22.onDropFile || node22.onDropData) {
      const files = e.dataTransfer.files;
      if (files && files.length) {
        for (let i2 = 0; i2 < files.length; i2++) {
          const file = e.dataTransfer.files[0];
          const filename = file.name;
          node22.onDropFile?.(file);
          if (node22.onDropData) {
            const reader = new FileReader();
            reader.onload = function(event2) {
              const data22 = event2.target.result;
              node22.onDropData(data22, filename, file);
            };
            const type = file.type.split("/")[0];
            if (type == "text" || type == "") {
              reader.readAsText(file);
            } else if (type == "image") {
              reader.readAsDataURL(file);
            } else {
              reader.readAsArrayBuffer(file);
            }
          }
        }
      }
    }
    if (node22.onDropItem?.(e)) return true;
    return this.onDropItem ? this.onDropItem(e) : false;
  }
  //called if the graph doesn't have a default drop item behaviour
  checkDropItem(e) {
    if (!e.dataTransfer.files.length) return;
    const file = e.dataTransfer.files[0];
    const ext = LGraphCanvas.getFileExtension(file.name).toLowerCase();
    const nodetype = LiteGraph.node_types_by_file_extension[ext];
    if (!nodetype) return;
    this.graph.beforeChange();
    const node22 = LiteGraph.createNode(nodetype.type);
    node22.pos = [e.canvasX, e.canvasY];
    this.graph.add(node22);
    node22.onDropFile?.(file);
    this.graph.afterChange();
  }
  processNodeDblClicked(n) {
    this.onShowNodePanel?.(n);
    this.onNodeDblClicked?.(n);
    this.setDirty(true);
  }
  /**
   * Determines whether to select or deselect an item that has received a pointer event.  Will deselect other nodes if 
   * @param item Canvas item to select/deselect
   * @param e The MouseEvent to handle
   * @param sticky Prevents deselecting individual nodes (as used by aux/right-click)
   * @remarks
   * Accessibility: anyone using {@link mutli_select} always deselects when clicking empty space.
   */
  processSelect(item2, e, sticky = false) {
    const addModifier = e?.shiftKey;
    const subtractModifier = e != null && (e.metaKey || e.ctrlKey);
    const eitherModifier = addModifier || subtractModifier;
    const modifySelection = eitherModifier || this.multi_select;
    if (!item2) {
      if (!eitherModifier || this.multi_select) this.deselectAll();
    } else if (!item2.selected || !this.selectedItems.has(item2)) {
      if (!modifySelection) this.deselectAll(item2);
      this.select(item2);
    } else if (modifySelection && !sticky) {
      this.deselect(item2);
    } else if (!sticky) {
      this.deselectAll(item2);
    } else {
      return;
    }
    this.onSelectionChange?.(this.selected_nodes);
    this.setDirty(true);
  }
  /**
   * Selects a {@link Positionable} item.
   * @param item The canvas item to add to the selection.
   */
  select(item2) {
    if (item2.selected && this.selectedItems.has(item2)) return;
    item2.selected = true;
    this.selectedItems.add(item2);
    if (!(item2 instanceof LGraphNode)) return;
    item2.onSelected?.();
    this.selected_nodes[item2.id] = item2;
    this.onNodeSelected?.(item2);
    item2.inputs?.forEach((input) => this.highlighted_links[input.link] = true);
    item2.outputs?.flatMap((x2) => x2.links).forEach((id3) => this.highlighted_links[id3] = true);
  }
  /**
   * Deselects a {@link Positionable} item.
   * @param item The canvas item to remove from the selection.
   */
  deselect(item2) {
    if (!item2.selected && !this.selectedItems.has(item2)) return;
    item2.selected = false;
    this.selectedItems.delete(item2);
    if (!(item2 instanceof LGraphNode)) return;
    item2.onDeselected?.();
    delete this.selected_nodes[item2.id];
    this.onNodeDeselected?.(item2);
    item2.inputs?.forEach((input) => delete this.highlighted_links[input.link]);
    item2.outputs?.flatMap((x2) => x2.links).forEach((id3) => delete this.highlighted_links[id3]);
  }
  /** @deprecated See {@link LGraphCanvas.processSelect} */
  processNodeSelected(item2, e) {
    this.processSelect(item2, e, e && (e.shiftKey || e.metaKey || e.ctrlKey || this.multi_select));
  }
  /** @deprecated See {@link LGraphCanvas.select} */
  selectNode(node22, add_to_current_selection) {
    if (node22 == null) {
      this.deselectAll();
    } else {
      this.selectNodes([node22], add_to_current_selection);
    }
  }
  /**
   * @returns All items on the canvas that can be selected
   */
  get positionableItems() {
    return [...this.graph._nodes, ...this.graph._groups, ...this.graph.reroutes.values()];
  }
  /**
   * Selects several items.
   * @param items Items to select - if falsy, all items on the canvas will be selected
   * @param add_to_current_selection If set, the items will be added to the current selection instead of replacing it
   */
  selectItems(items2, add_to_current_selection) {
    const itemsToSelect = items2 ?? this.positionableItems;
    if (!add_to_current_selection) this.deselectAll();
    for (const item2 of itemsToSelect) this.select(item2);
    this.onSelectionChange?.(this.selected_nodes);
    this.setDirty(true);
  }
  /**
   * selects several nodes (or adds them to the current selection)
   * @deprecated See {@link LGraphCanvas.selectItems}
   **/
  selectNodes(nodes, add_to_current_selection) {
    this.selectItems(nodes, add_to_current_selection);
  }
  /** @deprecated See {@link LGraphCanvas.deselect} */
  deselectNode(node22) {
    this.deselect(node22);
  }
  /**
   * Deselects all items on the canvas.
   * @param keepSelected If set, this item will not be removed from the selection.
   */
  deselectAll(keepSelected) {
    if (!this.graph) return;
    const selected2 = this.selectedItems;
    let wasSelected;
    for (const sel of selected2) {
      if (sel === keepSelected) {
        wasSelected = sel;
        continue;
      }
      sel.onDeselected?.();
      sel.selected = false;
    }
    selected2.clear();
    if (wasSelected) selected2.add(wasSelected);
    this.setDirty(true);
    const oldNode = keepSelected?.id == null ? null : this.selected_nodes[keepSelected.id];
    this.selected_nodes = {};
    this.current_node = null;
    this.highlighted_links = {};
    if (keepSelected instanceof LGraphNode) {
      if (oldNode) this.selected_nodes[oldNode.id] = oldNode;
      keepSelected.inputs?.forEach((input) => this.highlighted_links[input.link] = true);
      keepSelected.outputs?.flatMap((x2) => x2.links).forEach((id3) => this.highlighted_links[id3] = true);
    }
    this.onSelectionChange?.(this.selected_nodes);
  }
  /** @deprecated See {@link LGraphCanvas.deselectAll} */
  deselectAllNodes() {
    this.deselectAll();
  }
  /**
   * Deletes all selected items from the graph.
   * 
   * @todo Refactor deletion task to LGraph.  Selection is a canvas property, delete is a graph action.
   */
  deleteSelected() {
    const { graph } = this;
    this.emitBeforeChange();
    graph.beforeChange();
    for (const item2 of this.selectedItems) {
      if (item2 instanceof LGraphNode) {
        const node22 = item2;
        if (node22.block_delete) continue;
        node22.connectInputToOutput();
        graph.remove(node22);
        this.onNodeDeselected?.(node22);
      } else if (item2 instanceof LGraphGroup) {
        graph.remove(item2);
      } else if (item2 instanceof Reroute) {
        graph.removeReroute(item2.id);
      }
    }
    this.selectedItems.clear();
    this.selected_nodes = {};
    this.selectedItems.clear();
    this.current_node = null;
    this.highlighted_links = {};
    this.setDirty(true);
    graph.afterChange();
    this.emitAfterChange();
  }
  /**
   * deletes all nodes in the current selection from the graph
   * @deprecated See {@link LGraphCanvas.deleteSelected}
   **/
  deleteSelectedNodes() {
    this.deleteSelected();
  }
  /**
   * centers the camera on a given node
   **/
  centerOnNode(node22) {
    const dpi = window?.devicePixelRatio || 1;
    this.ds.offset[0] = -node22.pos[0] - node22.size[0] * 0.5 + this.canvas.width * 0.5 / (this.ds.scale * dpi);
    this.ds.offset[1] = -node22.pos[1] - node22.size[1] * 0.5 + this.canvas.height * 0.5 / (this.ds.scale * dpi);
    this.setDirty(true, true);
  }
  /**
   * adds some useful properties to a mouse event, like the position in graph coordinates
   **/
  adjustMouseEvent(e) {
    let clientX_rel = e.clientX;
    let clientY_rel = e.clientY;
    if (this.canvas) {
      const b = this.canvas.getBoundingClientRect();
      clientX_rel -= b.left;
      clientY_rel -= b.top;
    }
    if (e.deltaX === void 0) e.deltaX = clientX_rel - this.last_mouse_position[0];
    if (e.deltaY === void 0) e.deltaY = clientY_rel - this.last_mouse_position[1];
    this.last_mouse_position[0] = clientX_rel;
    this.last_mouse_position[1] = clientY_rel;
    e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0];
    e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1];
  }
  /**
   * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom
   **/
  setZoom(value3, zooming_center) {
    this.ds.changeScale(value3, zooming_center);
    this.#dirty();
  }
  /**
   * converts a coordinate from graph coordinates to canvas2D coordinates
   **/
  convertOffsetToCanvas(pos2, out) {
    return this.ds.convertOffsetToCanvas(pos2, out);
  }
  /**
   * converts a coordinate from Canvas2D coordinates to graph space
   **/
  convertCanvasToOffset(pos2, out) {
    return this.ds.convertCanvasToOffset(pos2, out);
  }
  //converts event coordinates from canvas2D to graph coordinates
  convertEventToCanvasOffset(e) {
    const rect = this.canvas.getBoundingClientRect();
    return this.convertCanvasToOffset([
      e.clientX - rect.left,
      e.clientY - rect.top
    ]);
  }
  /**
   * brings a node to front (above all other nodes)
   **/
  bringToFront(node22) {
    const i2 = this.graph._nodes.indexOf(node22);
    if (i2 == -1) return;
    this.graph._nodes.splice(i2, 1);
    this.graph._nodes.push(node22);
  }
  /**
   * sends a node to the back (below all other nodes)
   **/
  sendToBack(node22) {
    const i2 = this.graph._nodes.indexOf(node22);
    if (i2 == -1) return;
    this.graph._nodes.splice(i2, 1);
    this.graph._nodes.unshift(node22);
  }
  /**
   * Determines which nodes are visible and populates {@link out} with the results.
   * @param nodes The list of nodes to check - if falsy, all nodes in the graph will be checked
   * @param out Array to write visible nodes into - if falsy, a new array is created instead
   * @returns {LGraphNode[]} Array passed ({@link out}), or a new array containing all visible nodes
   */
  computeVisibleNodes(nodes, out) {
    const visible_nodes = out || [];
    visible_nodes.length = 0;
    const _nodes = nodes || this.graph._nodes;
    for (const node22 of _nodes) {
      if (this.live_mode && !node22.onDrawBackground && !node22.onDrawForeground) continue;
      node22.updateArea();
      if (!overlapBounding(this.visible_area, node22.renderArea)) continue;
      visible_nodes.push(node22);
    }
    return visible_nodes;
  }
  /**
   * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)
   **/
  draw(force_canvas, force_bgcanvas) {
    if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) return;
    const now2 = LiteGraph.getTime();
    this.render_time = (now2 - this.last_draw_time) * 1e-3;
    this.last_draw_time = now2;
    if (this.graph) this.ds.computeVisibleArea(this.viewport);
    if (this.dirty_canvas || force_canvas)
      this.computeVisibleNodes(null, this.visible_nodes);
    if (this.dirty_bgcanvas || force_bgcanvas || this.always_render_background || this.graph?._last_trigger_time && now2 - this.graph._last_trigger_time < 1e3) {
      this.drawBackCanvas();
    }
    if (this.dirty_canvas || force_canvas) this.drawFrontCanvas();
    this.fps = this.render_time ? 1 / this.render_time : 0;
    this.frame++;
  }
  /**
   * draws the front canvas (the one containing all the nodes)
   **/
  drawFrontCanvas() {
    this.dirty_canvas = false;
    if (!this.ctx) {
      this.ctx = this.bgcanvas.getContext("2d");
    }
    const ctx = this.ctx;
    if (!ctx) return;
    const canvas = this.canvas;
    if (ctx.start2D && !this.viewport) {
      ctx.start2D();
      ctx.restore();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    const area = this.viewport || this.dirty_area;
    if (area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area[0], area[1], area[2], area[3]);
      ctx.clip();
    }
    if (this.clear_background) {
      if (area)
        ctx.clearRect(area[0], area[1], area[2], area[3]);
      else
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    if (this.bgcanvas == this.canvas) {
      this.drawBackCanvas();
    } else {
      const scale = window.devicePixelRatio;
      ctx.drawImage(this.bgcanvas, 0, 0, this.bgcanvas.width / scale, this.bgcanvas.height / scale);
    }
    this.onRender?.(canvas, ctx);
    if (this.show_info) {
      this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0);
    }
    if (this.graph) {
      ctx.save();
      this.ds.toCanvasContext(ctx);
      const visible_nodes = this.visible_nodes;
      for (let i2 = 0; i2 < visible_nodes.length; ++i2) {
        const node22 = visible_nodes[i2];
        ctx.save();
        ctx.translate(node22.pos[0], node22.pos[1]);
        this.drawNode(node22, ctx);
        ctx.restore();
      }
      if (this.render_execution_order) {
        this.drawExecutionOrder(ctx);
      }
      if (this.graph.config.links_ontop) {
        if (!this.live_mode) {
          this.drawConnections(ctx);
        }
      }
      if (this.connecting_links?.length) {
        for (const link of this.connecting_links) {
          ctx.lineWidth = this.connections_width;
          let link_color = null;
          const connInOrOut = link.output || link.input;
          const connType = connInOrOut?.type;
          let connDir = connInOrOut?.dir;
          if (connDir == null) {
            if (link.output)
              connDir = link.node.horizontal ? LinkDirection.DOWN : LinkDirection.RIGHT;
            else
              connDir = link.node.horizontal ? LinkDirection.UP : LinkDirection.LEFT;
          }
          const connShape = connInOrOut?.shape;
          switch (connType) {
            case LiteGraph.EVENT:
              link_color = LiteGraph.EVENT_LINK_COLOR;
              break;
            default:
              link_color = LiteGraph.CONNECTING_LINK_COLOR;
          }
          const pos2 = this.graph.reroutes.get(link.afterRerouteId)?.pos ?? link.pos;
          const highlightPos = this.#getHighlightPosition();
          this.renderLink(
            ctx,
            pos2,
            highlightPos,
            null,
            false,
            null,
            link_color,
            connDir,
            link.direction ?? LinkDirection.CENTER
          );
          ctx.beginPath();
          if (connType === LiteGraph.EVENT || connShape === RenderShape.BOX) {
            ctx.rect(
              pos2[0] - 6 + 0.5,
              pos2[1] - 5 + 0.5,
              14,
              10
            );
            ctx.fill();
            ctx.beginPath();
            ctx.rect(
              this.graph_mouse[0] - 6 + 0.5,
              this.graph_mouse[1] - 5 + 0.5,
              14,
              10
            );
          } else if (connShape === RenderShape.ARROW) {
            ctx.moveTo(pos2[0] + 8, pos2[1] + 0.5);
            ctx.lineTo(pos2[0] - 4, pos2[1] + 6 + 0.5);
            ctx.lineTo(pos2[0] - 4, pos2[1] - 6 + 0.5);
            ctx.closePath();
          } else {
            ctx.arc(
              pos2[0],
              pos2[1],
              4,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.beginPath();
            ctx.arc(
              this.graph_mouse[0],
              this.graph_mouse[1],
              4,
              0,
              Math.PI * 2
            );
          }
          ctx.fill();
          this.#renderSnapHighlight(ctx, highlightPos);
        }
      }
      if (this.dragging_rectangle) {
        ctx.strokeStyle = "#FFF";
        ctx.strokeRect(
          this.dragging_rectangle[0],
          this.dragging_rectangle[1],
          this.dragging_rectangle[2],
          this.dragging_rectangle[3]
        );
      }
      if (this.over_link_center && this.render_link_tooltip)
        this.drawLinkTooltip(ctx, this.over_link_center);
      else
        this.onDrawLinkTooltip?.(ctx, null);
      this.onDrawForeground?.(ctx, this.visible_area);
      ctx.restore();
    }
    if (this._graph_stack?.length) {
      this.drawSubgraphPanel(ctx);
    }
    this.onDrawOverlay?.(ctx);
    if (area) ctx.restore();
    if (ctx.finish2D) ctx.finish2D();
  }
  /** @returns If the pointer is over a link centre marker, the link segment it belongs to.  Otherwise, `undefined`.  */
  #getLinkCentreOnPos(e) {
    for (const linkSegment of this.renderedPaths) {
      const centre = linkSegment._pos;
      if (!centre) continue;
      if (isInsideRectangle(e.canvasX, e.canvasY, centre[0] - 4, centre[1] - 4, 8, 8)) {
        return linkSegment;
      }
    }
  }
  /** Get the target snap / highlight point in graph space */
  #getHighlightPosition() {
    return LiteGraph.snaps_for_comfy ? this._highlight_pos ?? this.graph_mouse : this.graph_mouse;
  }
  /**
   * Renders indicators showing where a link will connect if released.
   * Partial border over target node and a highlight over the slot itself.
   * @param ctx Canvas 2D context
   */
  #renderSnapHighlight(ctx, highlightPos) {
    if (!this._highlight_pos) return;
    ctx.fillStyle = "#ffcc00";
    ctx.beginPath();
    const shape = this._highlight_input?.shape;
    if (shape === RenderShape.ARROW) {
      ctx.moveTo(highlightPos[0] + 8, highlightPos[1] + 0.5);
      ctx.lineTo(highlightPos[0] - 4, highlightPos[1] + 6 + 0.5);
      ctx.lineTo(highlightPos[0] - 4, highlightPos[1] - 6 + 0.5);
      ctx.closePath();
    } else {
      ctx.arc(
        highlightPos[0],
        highlightPos[1],
        6,
        0,
        Math.PI * 2
      );
    }
    ctx.fill();
    if (!LiteGraph.snap_highlights_node) return;
    const node22 = this.node_over;
    if (!(node22 && this.connecting_links?.[0])) return;
    const { strokeStyle, lineWidth } = ctx;
    const area = node22.boundingRect;
    const gap = 3;
    const radius = this.round_radius + gap;
    const x2 = area[0] - gap;
    const y2 = area[1] - gap;
    const width2 = area[2] + gap * 2;
    const height = area[3] + gap * 2;
    ctx.beginPath();
    ctx.roundRect(x2, y2, width2, height, radius);
    const start2 = this.connecting_links[0].output === null ? 0 : 1;
    const inverter = start2 ? -1 : 1;
    const hx = highlightPos[0];
    const hy = highlightPos[1];
    const gRadius = width2 < height ? width2 : width2 * Math.max(height / width2, 0.5);
    const gradient = ctx.createRadialGradient(hx, hy, 0, hx, hy, gRadius);
    gradient.addColorStop(1, "#00000000");
    gradient.addColorStop(0, "#ffcc00aa");
    const linearGradient = ctx.createLinearGradient(x2, y2, x2 + width2, y2);
    linearGradient.addColorStop(0.5, "#00000000");
    linearGradient.addColorStop(start2 + 0.67 * inverter, "#ddeeff33");
    linearGradient.addColorStop(start2 + inverter, "#ffcc0055");
    ctx.setLineDash([radius, radius * 1e-3]);
    ctx.lineWidth = 1;
    ctx.strokeStyle = linearGradient;
    ctx.stroke();
    ctx.strokeStyle = gradient;
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = strokeStyle;
  }
  /**
   * draws the panel in the corner that shows subgraph properties
   **/
  drawSubgraphPanel(ctx) {
    const subgraph = this.graph;
    const subnode = subgraph._subgraph_node;
    if (!subnode) {
      console.warn("subgraph without subnode");
      return;
    }
    this.drawSubgraphPanelLeft(subgraph, subnode, ctx);
    this.drawSubgraphPanelRight(subgraph, subnode, ctx);
  }
  drawSubgraphPanelLeft(subgraph, subnode, ctx) {
    const num = subnode.inputs ? subnode.inputs.length : 0;
    const w2 = 200;
    const h2 = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);
    ctx.fillStyle = "#111";
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.roundRect(10, 10, w2, (num + 1) * h2 + 50, [8]);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#888";
    ctx.font = "14px Arial";
    ctx.textAlign = "left";
    ctx.fillText("Graph Inputs", 20, 34);
    if (this.drawButton(w2 - 20, 20, 20, 20, "X", "#151515")) {
      this.closeSubgraph();
      return;
    }
    let y2 = 50;
    ctx.font = "14px Arial";
    if (subnode.inputs)
      for (let i2 = 0; i2 < subnode.inputs.length; ++i2) {
        const input = subnode.inputs[i2];
        if (input.not_subgraph_input) continue;
        if (this.drawButton(20, y2 + 2, w2 - 20, h2 - 2)) {
          const type = subnode.constructor.input_node_type || "graph/input";
          this.graph.beforeChange();
          const newnode = LiteGraph.createNode(type);
          if (newnode) {
            subgraph.add(newnode);
            this.block_click = false;
            this.last_click_position = null;
            this.selectNodes([newnode]);
            this.node_dragged = newnode;
            this.dragging_canvas = false;
            newnode.setProperty("name", input.name);
            newnode.setProperty("type", input.type);
            this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
            this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
            this.graph.afterChange();
          } else
            console.error("graph input node not found:", type);
        }
        ctx.fillStyle = "#9C9";
        ctx.beginPath();
        ctx.arc(w2 - 16, y2 + h2 * 0.5, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = "#AAA";
        ctx.fillText(input.name, 30, y2 + h2 * 0.75);
        ctx.fillStyle = "#777";
        ctx.fillText(input.type, 130, y2 + h2 * 0.75);
        y2 += h2;
      }
    if (this.drawButton(20, y2 + 2, w2 - 20, h2 - 2, "+", "#151515", "#222")) {
      this.showSubgraphPropertiesDialog(subnode);
    }
  }
  drawSubgraphPanelRight(subgraph, subnode, ctx) {
    const num = subnode.outputs ? subnode.outputs.length : 0;
    const canvas_w = this.bgcanvas.width;
    const w2 = 200;
    const h2 = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);
    ctx.fillStyle = "#111";
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.roundRect(canvas_w - w2 - 10, 10, w2, (num + 1) * h2 + 50, [8]);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#888";
    ctx.font = "14px Arial";
    ctx.textAlign = "left";
    const title_text = "Graph Outputs";
    const tw = ctx.measureText(title_text).width;
    ctx.fillText(title_text, canvas_w - tw - 20, 34);
    if (this.drawButton(canvas_w - w2, 20, 20, 20, "X", "#151515")) {
      this.closeSubgraph();
      return;
    }
    let y2 = 50;
    ctx.font = "14px Arial";
    if (subnode.outputs)
      for (let i2 = 0; i2 < subnode.outputs.length; ++i2) {
        const output = subnode.outputs[i2];
        if (output.not_subgraph_input) continue;
        if (this.drawButton(canvas_w - w2, y2 + 2, w2 - 20, h2 - 2)) {
          const type = subnode.constructor.output_node_type || "graph/output";
          this.graph.beforeChange();
          const newnode = LiteGraph.createNode(type);
          if (newnode) {
            subgraph.add(newnode);
            this.block_click = false;
            this.last_click_position = null;
            this.selectNodes([newnode]);
            this.node_dragged = newnode;
            this.dragging_canvas = false;
            newnode.setProperty("name", output.name);
            newnode.setProperty("type", output.type);
            this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
            this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
            this.graph.afterChange();
          } else
            console.error("graph input node not found:", type);
        }
        ctx.fillStyle = "#9C9";
        ctx.beginPath();
        ctx.arc(canvas_w - w2 + 16, y2 + h2 * 0.5, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = "#AAA";
        ctx.fillText(output.name, canvas_w - w2 + 30, y2 + h2 * 0.75);
        ctx.fillStyle = "#777";
        ctx.fillText(output.type, canvas_w - w2 + 130, y2 + h2 * 0.75);
        y2 += h2;
      }
    if (this.drawButton(canvas_w - w2, y2 + 2, w2 - 20, h2 - 2, "+", "#151515", "#222")) {
      this.showSubgraphPropertiesDialogRight(subnode);
    }
  }
  //Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm
  drawButton(x2, y2, w2, h2, text, bgcolor, hovercolor, textcolor) {
    const ctx = this.ctx;
    bgcolor = bgcolor || LiteGraph.NODE_DEFAULT_COLOR;
    hovercolor = hovercolor || "#555";
    textcolor = textcolor || LiteGraph.NODE_TEXT_COLOR;
    let pos2 = this.ds.convertOffsetToCanvas(this.graph_mouse);
    const hover = LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
    pos2 = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null;
    if (pos2) {
      const rect = this.canvas.getBoundingClientRect();
      pos2[0] -= rect.left;
      pos2[1] -= rect.top;
    }
    const clicked = pos2 && LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
    ctx.fillStyle = hover ? hovercolor : bgcolor;
    if (clicked) ctx.fillStyle = "#AAA";
    ctx.beginPath();
    ctx.roundRect(x2, y2, w2, h2, [4]);
    ctx.fill();
    if (text != null) {
      if (text.constructor == String) {
        ctx.fillStyle = textcolor;
        ctx.textAlign = "center";
        ctx.font = (h2 * 0.65 | 0) + "px Arial";
        ctx.fillText(text, x2 + w2 * 0.5, y2 + h2 * 0.75);
        ctx.textAlign = "left";
      }
    }
    const was_clicked = clicked && !this.block_click;
    if (clicked) this.blockClick();
    return was_clicked;
  }
  isAreaClicked(x2, y2, w2, h2, hold_click) {
    const clickPos = this.last_click_position;
    const clicked = clickPos && LiteGraph.isInsideRectangle(clickPos[0], clickPos[1], x2, y2, w2, h2);
    const was_clicked = clicked && !this.block_click;
    if (clicked && hold_click) this.blockClick();
    return was_clicked;
  }
  /**
   * draws some useful stats in the corner of the canvas
   **/
  renderInfo(ctx, x2, y2) {
    x2 = x2 || 10;
    y2 = y2 || this.canvas.offsetHeight - 80;
    ctx.save();
    ctx.translate(x2, y2);
    ctx.font = "10px Arial";
    ctx.fillStyle = "#888";
    ctx.textAlign = "left";
    if (this.graph) {
      ctx.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13 * 1);
      ctx.fillText("I: " + this.graph.iteration, 5, 13 * 2);
      ctx.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 13 * 3);
      ctx.fillText("V: " + this.graph._version, 5, 13 * 4);
      ctx.fillText("FPS:" + this.fps.toFixed(2), 5, 13 * 5);
    } else {
      ctx.fillText("No graph selected", 5, 13 * 1);
    }
    ctx.restore();
  }
  /**
   * draws the back canvas (the one containing the background and the connections)
   **/
  drawBackCanvas() {
    const canvas = this.bgcanvas;
    if (canvas.width != this.canvas.width || canvas.height != this.canvas.height) {
      canvas.width = this.canvas.width;
      canvas.height = this.canvas.height;
    }
    if (!this.bgctx) {
      this.bgctx = this.bgcanvas.getContext("2d");
    }
    const ctx = this.bgctx;
    if (ctx.start) ctx.start();
    const viewport = this.viewport || [0, 0, ctx.canvas.width, ctx.canvas.height];
    if (this.clear_background) {
      ctx.clearRect(viewport[0], viewport[1], viewport[2], viewport[3]);
    }
    if (this._graph_stack?.length) {
      ctx.save();
      const subgraph_node = this.graph._subgraph_node;
      ctx.strokeStyle = subgraph_node.bgcolor;
      ctx.lineWidth = 10;
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      ctx.lineWidth = 1;
      ctx.font = "40px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = subgraph_node.bgcolor || "#AAA";
      let title = "";
      for (let i2 = 1; i2 < this._graph_stack.length; ++i2) {
        title += this._graph_stack[i2]._subgraph_node.getTitle() + " >> ";
      }
      ctx.fillText(
        title + subgraph_node.getTitle(),
        canvas.width * 0.5,
        40
      );
      ctx.restore();
    }
    const bg_already_painted = this.onRenderBackground ? this.onRenderBackground(canvas, ctx) : false;
    if (!this.viewport) {
      const scale = window.devicePixelRatio;
      ctx.restore();
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
    }
    this.visible_links.length = 0;
    if (this.graph) {
      ctx.save();
      this.ds.toCanvasContext(ctx);
      if (this.ds.scale < 1.5 && !bg_already_painted && this.clear_background_color) {
        ctx.fillStyle = this.clear_background_color;
        ctx.fillRect(
          this.visible_area[0],
          this.visible_area[1],
          this.visible_area[2],
          this.visible_area[3]
        );
      }
      if (this.background_image && this.ds.scale > 0.5 && !bg_already_painted) {
        if (this.zoom_modify_alpha) {
          ctx.globalAlpha = (1 - 0.5 / this.ds.scale) * this.editor_alpha;
        } else {
          ctx.globalAlpha = this.editor_alpha;
        }
        ctx.imageSmoothingEnabled = false;
        if (!this._bg_img || this._bg_img.name != this.background_image) {
          this._bg_img = new Image();
          this._bg_img.name = this.background_image;
          this._bg_img.src = this.background_image;
          const that2 = this;
          this._bg_img.onload = function() {
            that2.draw(true, true);
          };
        }
        let pattern = this._pattern;
        if (pattern == null && this._bg_img.width > 0) {
          pattern = ctx.createPattern(this._bg_img, "repeat");
          this._pattern_img = this._bg_img;
          this._pattern = pattern;
        }
        if (pattern) {
          ctx.fillStyle = pattern;
          ctx.fillRect(
            this.visible_area[0],
            this.visible_area[1],
            this.visible_area[2],
            this.visible_area[3]
          );
          ctx.fillStyle = "transparent";
        }
        ctx.globalAlpha = 1;
        ctx.imageSmoothingEnabled = true;
      }
      if (this.graph._groups.length && !this.live_mode) {
        this.drawGroups(canvas, ctx);
      }
      this.onDrawBackground?.(ctx, this.visible_area);
      if (this.render_canvas_border) {
        ctx.strokeStyle = "#235";
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
      }
      if (this.render_connections_shadows) {
        ctx.shadowColor = "#000";
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 6;
      } else {
        ctx.shadowColor = "rgba(0,0,0,0)";
      }
      if (!this.live_mode) {
        this.drawConnections(ctx);
      }
      ctx.shadowColor = "rgba(0,0,0,0)";
      ctx.restore();
    }
    ctx.finish?.();
    this.dirty_bgcanvas = false;
    this.dirty_canvas = true;
  }
  /**
   * draws the given node inside the canvas
   **/
  drawNode(node22, ctx) {
    this.current_node = node22;
    const color = node22.color || node22.constructor.color || LiteGraph.NODE_DEFAULT_COLOR;
    let bgcolor = node22.bgcolor || node22.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;
    const low_quality = this.ds.scale < 0.6;
    if (this.live_mode) {
      if (!node22.flags.collapsed) {
        ctx.shadowColor = "transparent";
        node22.onDrawForeground?.(ctx, this, this.canvas);
      }
      return;
    }
    const editor_alpha = this.editor_alpha;
    ctx.globalAlpha = editor_alpha;
    if (this.render_shadows && !low_quality) {
      ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
      ctx.shadowOffsetX = 2 * this.ds.scale;
      ctx.shadowOffsetY = 2 * this.ds.scale;
      ctx.shadowBlur = 3 * this.ds.scale;
    } else {
      ctx.shadowColor = "transparent";
    }
    if (node22.flags.collapsed && node22.onDrawCollapsed?.(ctx, this) == true)
      return;
    const shape = node22._shape || RenderShape.BOX;
    const size2 = LGraphCanvas.#temp_vec2;
    LGraphCanvas.#temp_vec2.set(node22.size);
    const horizontal2 = node22.horizontal;
    if (node22.flags.collapsed) {
      ctx.font = this.inner_text_font;
      const title = node22.getTitle ? node22.getTitle() : node22.title;
      if (title != null) {
        node22._collapsed_width = Math.min(
          node22.size[0],
          ctx.measureText(title).width + LiteGraph.NODE_TITLE_HEIGHT * 2
        );
        size2[0] = node22._collapsed_width;
        size2[1] = 0;
      }
    }
    if (node22.clip_area) {
      ctx.save();
      ctx.beginPath();
      if (shape == RenderShape.BOX) {
        ctx.rect(0, 0, size2[0], size2[1]);
      } else if (shape == RenderShape.ROUND) {
        ctx.roundRect(0, 0, size2[0], size2[1], [10]);
      } else if (shape == RenderShape.CIRCLE) {
        ctx.arc(
          size2[0] * 0.5,
          size2[1] * 0.5,
          size2[0] * 0.5,
          0,
          Math.PI * 2
        );
      }
      ctx.clip();
    }
    if (node22.has_errors) {
      bgcolor = "red";
    }
    this.drawNodeShape(
      node22,
      ctx,
      size2,
      color,
      bgcolor,
      node22.selected
    );
    if (!low_quality) {
      node22.drawBadges(ctx);
    }
    ctx.shadowColor = "transparent";
    node22.onDrawForeground?.(ctx, this, this.canvas);
    ctx.textAlign = horizontal2 ? "center" : "left";
    ctx.font = this.inner_text_font;
    const render_text = !low_quality;
    const highlightColour = LiteGraph.NODE_TEXT_HIGHLIGHT_COLOR ?? LiteGraph.NODE_SELECTED_TITLE_COLOR ?? LiteGraph.NODE_TEXT_COLOR;
    const out_slot = this.connecting_links?.[0]?.output;
    const in_slot = this.connecting_links?.[0]?.input;
    ctx.lineWidth = 1;
    let max_y = 0;
    const slot_pos = new Float32Array(2);
    if (!node22.flags.collapsed) {
      if (node22.inputs) {
        for (let i2 = 0; i2 < node22.inputs.length; i2++) {
          const slot = node22.inputs[i2];
          const slot_type = slot.type;
          const isValid2 = !this.connecting_links || out_slot && LiteGraph.isValidConnection(slot.type, out_slot.type);
          const highlight = isValid2 && node22.mouseOver?.inputId === i2;
          const label_color = highlight ? highlightColour : LiteGraph.NODE_TEXT_COLOR;
          ctx.globalAlpha = isValid2 ? editor_alpha : 0.4 * editor_alpha;
          ctx.fillStyle = slot.link != null ? slot.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_on : slot.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_off;
          const pos2 = node22.getConnectionPos(true, i2, slot_pos);
          pos2[0] -= node22.pos[0];
          pos2[1] -= node22.pos[1];
          if (max_y < pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
            max_y = pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
          }
          drawSlot(ctx, slot, pos2, {
            horizontal: horizontal2,
            low_quality,
            render_text,
            label_color,
            label_position: LabelPosition.Right,
            // Input slot is not stroked.
            do_stroke: false,
            highlight
          });
        }
      }
      ctx.textAlign = horizontal2 ? "center" : "right";
      ctx.strokeStyle = "black";
      if (node22.outputs) {
        for (let i2 = 0; i2 < node22.outputs.length; i2++) {
          const slot = node22.outputs[i2];
          const slot_type = slot.type;
          const isValid2 = !this.connecting_links || in_slot && LiteGraph.isValidConnection(slot_type, in_slot.type);
          const highlight = isValid2 && node22.mouseOver?.outputId === i2;
          const label_color = highlight ? highlightColour : LiteGraph.NODE_TEXT_COLOR;
          ctx.globalAlpha = isValid2 ? editor_alpha : 0.4 * editor_alpha;
          const pos2 = node22.getConnectionPos(false, i2, slot_pos);
          pos2[0] -= node22.pos[0];
          pos2[1] -= node22.pos[1];
          if (max_y < pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
            max_y = pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
          }
          ctx.fillStyle = slot.links && slot.links.length ? slot.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.output_on : slot.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.output_off;
          drawSlot(ctx, slot, pos2, {
            horizontal: horizontal2,
            low_quality,
            render_text,
            label_color,
            label_position: LabelPosition.Left,
            do_stroke: true,
            highlight
          });
        }
      }
      ctx.textAlign = "left";
      ctx.globalAlpha = 1;
      if (node22.widgets) {
        let widgets_y = max_y;
        if (horizontal2 || node22.widgets_up) {
          widgets_y = 2;
        }
        if (node22.widgets_start_y != null)
          widgets_y = node22.widgets_start_y;
        this.drawNodeWidgets(
          node22,
          widgets_y,
          ctx,
          this.node_widget && this.node_widget[0] == node22 ? this.node_widget[1] : null
        );
      }
    } else if (this.render_collapsed_slots) {
      let input_slot = null;
      let output_slot = null;
      let slot;
      if (node22.inputs) {
        for (let i2 = 0; i2 < node22.inputs.length; i2++) {
          slot = node22.inputs[i2];
          if (slot.link == null) {
            continue;
          }
          input_slot = slot;
          break;
        }
      }
      if (node22.outputs) {
        for (let i2 = 0; i2 < node22.outputs.length; i2++) {
          slot = node22.outputs[i2];
          if (!slot.links || !slot.links.length) {
            continue;
          }
          output_slot = slot;
        }
      }
      if (input_slot) {
        let x2 = 0;
        let y2 = LiteGraph.NODE_TITLE_HEIGHT * -0.5;
        if (horizontal2) {
          x2 = node22._collapsed_width * 0.5;
          y2 = -LiteGraph.NODE_TITLE_HEIGHT;
        }
        ctx.fillStyle = "#686";
        ctx.beginPath();
        if (slot.type === LiteGraph.EVENT || slot.shape === RenderShape.BOX) {
          ctx.rect(x2 - 7 + 0.5, y2 - 4, 14, 8);
        } else if (slot.shape === RenderShape.ARROW) {
          ctx.moveTo(x2 + 8, y2);
          ctx.lineTo(x2 + -4, y2 - 4);
          ctx.lineTo(x2 + -4, y2 + 4);
          ctx.closePath();
        } else {
          ctx.arc(x2, y2, 4, 0, Math.PI * 2);
        }
        ctx.fill();
      }
      if (output_slot) {
        let x2 = node22._collapsed_width;
        let y2 = LiteGraph.NODE_TITLE_HEIGHT * -0.5;
        if (horizontal2) {
          x2 = node22._collapsed_width * 0.5;
          y2 = 0;
        }
        ctx.fillStyle = "#686";
        ctx.strokeStyle = "black";
        ctx.beginPath();
        if (slot.type === LiteGraph.EVENT || slot.shape === RenderShape.BOX) {
          ctx.rect(x2 - 7 + 0.5, y2 - 4, 14, 8);
        } else if (slot.shape === RenderShape.ARROW) {
          ctx.moveTo(x2 + 6, y2);
          ctx.lineTo(x2 - 6, y2 - 4);
          ctx.lineTo(x2 - 6, y2 + 4);
          ctx.closePath();
        } else {
          ctx.arc(x2, y2, 4, 0, Math.PI * 2);
        }
        ctx.fill();
      }
    }
    if (node22.clip_area) {
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }
  /**
   * Draws the link mouseover effect and tooltip.
   * @param ctx Canvas 2D context to draw on
   * @param link The link to render the mouseover effect for
   * @remarks
   * Called against {@link LGraphCanvas.over_link_center}.
   * @todo Split tooltip from hover, so it can be drawn / eased separately
   */
  drawLinkTooltip(ctx, link) {
    const pos2 = link._pos;
    ctx.fillStyle = "black";
    ctx.beginPath();
    if (this.linkMarkerShape === LinkMarkerShape.Arrow) {
      const transform2 = ctx.getTransform();
      ctx.translate(pos2[0], pos2[1]);
      if (Number.isFinite(link._centreAngle)) ctx.rotate(link._centreAngle);
      ctx.moveTo(-2, -3);
      ctx.lineTo(4, 0);
      ctx.lineTo(-2, 3);
      ctx.setTransform(transform2);
    } else if (this.linkMarkerShape == null || this.linkMarkerShape === LinkMarkerShape.Circle) {
      ctx.arc(pos2[0], pos2[1], 3, 0, Math.PI * 2);
    }
    ctx.fill();
    const data22 = link.data;
    if (data22 == null) return;
    if (this.onDrawLinkTooltip?.(ctx, link, this) == true)
      return;
    let text = null;
    if (typeof data22 === "number")
      text = data22.toFixed(2);
    else if (typeof data22 === "string")
      text = '"' + data22 + '"';
    else if (typeof data22 === "boolean")
      text = String(data22);
    else if (data22.toToolTip)
      text = data22.toToolTip();
    else
      text = "[" + data22.constructor.name + "]";
    if (text == null) return;
    text = text.substring(0, 30);
    ctx.font = "14px Courier New";
    const info = ctx.measureText(text);
    const w2 = info.width + 20;
    const h2 = 24;
    ctx.shadowColor = "black";
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.shadowBlur = 3;
    ctx.fillStyle = "#454";
    ctx.beginPath();
    ctx.roundRect(pos2[0] - w2 * 0.5, pos2[1] - 15 - h2, w2, h2, [3]);
    ctx.moveTo(pos2[0] - 10, pos2[1] - 15);
    ctx.lineTo(pos2[0] + 10, pos2[1] - 15);
    ctx.lineTo(pos2[0], pos2[1] - 5);
    ctx.fill();
    ctx.shadowColor = "transparent";
    ctx.textAlign = "center";
    ctx.fillStyle = "#CEC";
    ctx.fillText(text, pos2[0], pos2[1] - 15 - h2 * 0.3);
  }
  /**
   * Draws the shape of the given node on the canvas
   * @param node The node to draw
   * @param ctx 2D canvas rendering context used to draw
   * @param size Size of the background to draw, in graph units.  Differs from node size if collapsed, etc.
   * @param fgcolor Foreground colour - used for text
   * @param bgcolor Background colour of the node
   * @param selected Whether to render the node as selected.  Likely to be removed in future, as current usage is simply the selected property of the node.
   * @param mouse_over Deprecated
   */
  drawNodeShape(node22, ctx, size2, fgcolor, bgcolor, selected2) {
    ctx.strokeStyle = fgcolor;
    ctx.fillStyle = bgcolor;
    const title_height = LiteGraph.NODE_TITLE_HEIGHT;
    const low_quality = this.ds.scale < 0.5;
    const shape = node22._shape || node22.constructor.shape || RenderShape.ROUND;
    const title_mode = node22.constructor.title_mode;
    const render_title = title_mode == TitleMode.TRANSPARENT_TITLE || title_mode == TitleMode.NO_TITLE ? false : true;
    const area = LGraphCanvas.#tmp_area;
    node22.measure(area);
    area[0] -= node22.pos[0];
    area[1] -= node22.pos[1];
    const old_alpha = ctx.globalAlpha;
    {
      ctx.beginPath();
      if (shape == RenderShape.BOX || low_quality) {
        ctx.fillRect(area[0], area[1], area[2], area[3]);
      } else if (shape == RenderShape.ROUND || shape == RenderShape.CARD) {
        ctx.roundRect(
          area[0],
          area[1],
          area[2],
          area[3],
          shape == RenderShape.CARD ? [this.round_radius, this.round_radius, 0, 0] : [this.round_radius]
        );
      } else if (shape == RenderShape.CIRCLE) {
        ctx.arc(
          size2[0] * 0.5,
          size2[1] * 0.5,
          size2[0] * 0.5,
          0,
          Math.PI * 2
        );
      }
      ctx.fill();
      if (!node22.flags.collapsed && render_title) {
        ctx.shadowColor = "transparent";
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(0, -1, area[2], 2);
      }
    }
    ctx.shadowColor = "transparent";
    node22.onDrawBackground?.(ctx, this, this.canvas, this.graph_mouse);
    if (render_title || title_mode == TitleMode.TRANSPARENT_TITLE) {
      if (node22.onDrawTitleBar) {
        node22.onDrawTitleBar(ctx, title_height, size2, this.ds.scale, fgcolor);
      } else if (title_mode != TitleMode.TRANSPARENT_TITLE && (node22.constructor.title_color || this.render_title_colored)) {
        const title_color = node22.constructor.title_color || fgcolor;
        if (node22.flags.collapsed) {
          ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
        }
        if (this.use_gradients) {
          let grad = LGraphCanvas.gradients[title_color];
          if (!grad) {
            grad = LGraphCanvas.gradients[title_color] = ctx.createLinearGradient(0, 0, 400, 0);
            grad.addColorStop(0, title_color);
            grad.addColorStop(1, "#000");
          }
          ctx.fillStyle = grad;
        } else {
          ctx.fillStyle = title_color;
        }
        ctx.beginPath();
        if (shape == RenderShape.BOX || low_quality) {
          ctx.rect(0, -title_height, size2[0], title_height);
        } else if (shape == RenderShape.ROUND || shape == RenderShape.CARD) {
          ctx.roundRect(
            0,
            -title_height,
            size2[0],
            title_height,
            node22.flags.collapsed ? [this.round_radius] : [this.round_radius, this.round_radius, 0, 0]
          );
        }
        ctx.fill();
        ctx.shadowColor = "transparent";
      }
      let colState = false;
      if (LiteGraph.node_box_coloured_by_mode) {
        if (LiteGraph.NODE_MODES_COLORS[node22.mode]) {
          colState = LiteGraph.NODE_MODES_COLORS[node22.mode];
        }
      }
      if (LiteGraph.node_box_coloured_when_on) {
        colState = node22.action_triggered ? "#FFF" : node22.execute_triggered ? "#AAA" : colState;
      }
      const box_size = 10;
      if (node22.onDrawTitleBox) {
        node22.onDrawTitleBox(ctx, title_height, size2, this.ds.scale);
      } else if (shape == RenderShape.ROUND || shape == RenderShape.CIRCLE || shape == RenderShape.CARD) {
        if (low_quality) {
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(
            title_height * 0.5,
            title_height * -0.5,
            box_size * 0.5 + 1,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        ctx.fillStyle = node22.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;
        if (low_quality)
          ctx.fillRect(title_height * 0.5 - box_size * 0.5, title_height * -0.5 - box_size * 0.5, box_size, box_size);
        else {
          ctx.beginPath();
          ctx.arc(
            title_height * 0.5,
            title_height * -0.5,
            box_size * 0.5,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      } else {
        if (low_quality) {
          ctx.fillStyle = "black";
          ctx.fillRect(
            (title_height - box_size) * 0.5 - 1,
            (title_height + box_size) * -0.5 - 1,
            box_size + 2,
            box_size + 2
          );
        }
        ctx.fillStyle = node22.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;
        ctx.fillRect(
          (title_height - box_size) * 0.5,
          (title_height + box_size) * -0.5,
          box_size,
          box_size
        );
      }
      ctx.globalAlpha = old_alpha;
      if (node22.onDrawTitleText) {
        node22.onDrawTitleText(
          ctx,
          title_height,
          size2,
          this.ds.scale,
          this.title_text_font,
          selected2
        );
      }
      if (!low_quality) {
        ctx.font = this.title_text_font;
        const title = String(node22.getTitle()) + (node22.pinned ? "" : "");
        if (title) {
          if (selected2) {
            ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR;
          } else {
            ctx.fillStyle = node22.constructor.title_text_color || this.node_title_color;
          }
          if (node22.flags.collapsed) {
            ctx.textAlign = "left";
            ctx.fillText(
              title.substr(0, 20),
              //avoid urls too long
              title_height,
              // + measure.width * 0.5,
              LiteGraph.NODE_TITLE_TEXT_Y - title_height
            );
            ctx.textAlign = "left";
          } else {
            ctx.textAlign = "left";
            ctx.fillText(
              title,
              title_height,
              LiteGraph.NODE_TITLE_TEXT_Y - title_height
            );
          }
        }
      }
      if (!node22.flags.collapsed && node22.subgraph && !node22.skip_subgraph_button) {
        const w2 = LiteGraph.NODE_TITLE_HEIGHT;
        const x2 = node22.size[0] - w2;
        const over = LiteGraph.isInsideRectangle(this.graph_mouse[0] - node22.pos[0], this.graph_mouse[1] - node22.pos[1], x2 + 2, -w2 + 2, w2 - 4, w2 - 4);
        ctx.fillStyle = over ? "#888" : "#555";
        if (shape == RenderShape.BOX || low_quality) {
          ctx.fillRect(x2 + 2, -w2 + 2, w2 - 4, w2 - 4);
        } else {
          ctx.beginPath();
          ctx.roundRect(x2 + 2, -w2 + 2, w2 - 4, w2 - 4, [4]);
          ctx.fill();
        }
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(x2 + w2 * 0.2, -w2 * 0.6);
        ctx.lineTo(x2 + w2 * 0.8, -w2 * 0.6);
        ctx.lineTo(x2 + w2 * 0.5, -w2 * 0.3);
        ctx.fill();
      }
      node22.onDrawTitle?.(ctx);
    }
    if (selected2) {
      node22.onBounding?.(area);
      this.drawSelectionBounding(
        ctx,
        area,
        {
          shape,
          title_height,
          title_mode,
          fgcolor,
          collapsed: node22.flags?.collapsed
        }
      );
    }
    if (node22.execute_triggered > 0) node22.execute_triggered--;
    if (node22.action_triggered > 0) node22.action_triggered--;
  }
  /**
   * Draws the selection bounding of an area.
   * @param {CanvasRenderingContext2D} ctx
   * @param {Vector4} area
   * @param {{
   *   shape: LiteGraph.Shape,
   *   title_height: number,
   *   title_mode: LiteGraph.TitleMode,
   *   fgcolor: string,
   *   padding: number,
   * }} options
   */
  drawSelectionBounding(ctx, area, {
    shape = RenderShape.BOX,
    title_height = LiteGraph.NODE_TITLE_HEIGHT,
    title_mode = TitleMode.NORMAL_TITLE,
    fgcolor = LiteGraph.NODE_BOX_OUTLINE_COLOR,
    padding = 6,
    collapsed = false
  } = {}) {
    if (title_mode === TitleMode.TRANSPARENT_TITLE) {
      area[1] -= title_height;
      area[3] += title_height;
    }
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    const [x2, y2, width2, height] = area;
    switch (shape) {
      case RenderShape.BOX: {
        ctx.rect(x2 - padding, y2 - padding, width2 + 2 * padding, height + 2 * padding);
        break;
      }
      case RenderShape.ROUND:
      case RenderShape.CARD: {
        const radius = this.round_radius * 2;
        const isCollapsed = shape === RenderShape.CARD && collapsed;
        const cornerRadii = isCollapsed || shape === RenderShape.ROUND ? [radius] : [radius, 2, radius, 2];
        ctx.roundRect(x2 - padding, y2 - padding, width2 + 2 * padding, height + 2 * padding, cornerRadii);
        break;
      }
      case RenderShape.CIRCLE: {
        const centerX = x2 + width2 / 2;
        const centerY = y2 + height / 2;
        const radius = Math.max(width2, height) / 2 + padding;
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        break;
      }
    }
    ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR;
    ctx.stroke();
    ctx.strokeStyle = fgcolor;
    ctx.globalAlpha = 1;
  }
  drawConnections(ctx) {
    const rendered = this.renderedPaths;
    rendered.clear();
    const now2 = LiteGraph.getTime();
    const visible_area = this.visible_area;
    LGraphCanvas.#margin_area[0] = visible_area[0] - 20;
    LGraphCanvas.#margin_area[1] = visible_area[1] - 20;
    LGraphCanvas.#margin_area[2] = visible_area[2] + 40;
    LGraphCanvas.#margin_area[3] = visible_area[3] + 40;
    ctx.lineWidth = this.connections_width;
    ctx.fillStyle = "#AAA";
    ctx.strokeStyle = "#AAA";
    ctx.globalAlpha = this.editor_alpha;
    const nodes = this.graph._nodes;
    for (let n = 0, l = nodes.length; n < l; ++n) {
      const node22 = nodes[n];
      if (!node22.inputs || !node22.inputs.length) continue;
      for (let i2 = 0; i2 < node22.inputs.length; ++i2) {
        const input = node22.inputs[i2];
        if (!input || input.link == null) continue;
        const link_id = input.link;
        const link = this.graph._links.get(link_id);
        if (!link) continue;
        const start_node = this.graph.getNodeById(link.origin_id);
        if (start_node == null) continue;
        const outputId = link.origin_slot;
        const start_node_slotpos = outputId == -1 ? [start_node.pos[0] + 10, start_node.pos[1] + 10] : start_node.getConnectionPos(false, outputId, LGraphCanvas.#tempA);
        const end_node_slotpos = node22.getConnectionPos(true, i2, LGraphCanvas.#tempB);
        const reroutes = this.reroutesEnabled ? LLink.getReroutes(this.graph, link) : [];
        const points = [start_node_slotpos, ...reroutes.map((x2) => x2.pos), end_node_slotpos];
        const pointsX = points.map((x2) => x2[0]);
        const pointsY = points.map((x2) => x2[1]);
        LGraphCanvas.#link_bounding[0] = Math.min(...pointsX);
        LGraphCanvas.#link_bounding[1] = Math.min(...pointsY);
        LGraphCanvas.#link_bounding[2] = Math.max(...pointsX) - LGraphCanvas.#link_bounding[0];
        LGraphCanvas.#link_bounding[3] = Math.max(...pointsY) - LGraphCanvas.#link_bounding[1];
        if (!overlapBounding(LGraphCanvas.#link_bounding, LGraphCanvas.#margin_area))
          continue;
        const start_slot = start_node.outputs[outputId];
        const end_slot = node22.inputs[i2];
        if (!start_slot || !end_slot)
          continue;
        const start_dir = start_slot.dir || (start_node.horizontal ? LinkDirection.DOWN : LinkDirection.RIGHT);
        const end_dir = end_slot.dir || (node22.horizontal ? LinkDirection.UP : LinkDirection.LEFT);
        if (reroutes.length) {
          let startControl;
          const l2 = reroutes.length;
          for (let j = 0; j < l2; j++) {
            const reroute = reroutes[j];
            if (!rendered.has(reroute)) {
              rendered.add(reroute);
              const prevReroute = this.graph.reroutes.get(reroute.parentId);
              const startPos = prevReroute?.pos ?? start_node_slotpos;
              reroute.calculateAngle(this.last_draw_time, this.graph, startPos);
              this.renderLink(
                ctx,
                startPos,
                reroute.pos,
                link,
                false,
                0,
                null,
                start_dir,
                end_dir,
                {
                  startControl,
                  endControl: reroute.controlPoint,
                  reroute
                }
              );
            }
            const nextPos = reroutes[j + 1]?.pos ?? end_node_slotpos;
            const dist2 = Math.min(80, distance(reroute.pos, nextPos) * 0.25);
            startControl = [dist2 * reroute.cos, dist2 * reroute.sin];
          }
          this.renderLink(
            ctx,
            points.at(-2),
            points.at(-1),
            link,
            false,
            0,
            null,
            start_dir,
            end_dir,
            { startControl }
          );
          const defaultColor = LGraphCanvas.link_type_colors[link.type] || this.default_link_color;
          for (const reroute of reroutes) {
            reroute.draw(ctx, link.color || defaultColor);
          }
        } else {
          this.renderLink(
            ctx,
            start_node_slotpos,
            end_node_slotpos,
            link,
            false,
            0,
            null,
            start_dir,
            end_dir
          );
        }
        rendered.add(link);
        if (link && link._last_time && now2 - link._last_time < 1e3) {
          const f = 2 - (now2 - link._last_time) * 2e-3;
          const tmp = ctx.globalAlpha;
          ctx.globalAlpha = tmp * f;
          this.renderLink(
            ctx,
            start_node_slotpos,
            end_node_slotpos,
            link,
            true,
            f,
            "white",
            start_dir,
            end_dir
          );
          ctx.globalAlpha = tmp;
        }
      }
    }
    ctx.globalAlpha = 1;
  }
  /**
   * draws a link between two points
   * @param ctx Canvas 2D rendering context
   * @param {vec2} a start pos
   * @param {vec2} b end pos
   * @param {Object} link the link object with all the link info
   * @param {boolean} skip_border ignore the shadow of the link
   * @param {boolean} flow show flow animation (for events)
   * @param {string} color the color for the link
   * @param {LinkDirection} start_dir the direction enum
   * @param {LinkDirection} end_dir the direction enum
   * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)
   */
  renderLink(ctx, a, b, link, skip_border, flow, color, start_dir, end_dir, {
    startControl,
    endControl,
    reroute,
    num_sublines = 1
  } = {}) {
    if (link) this.visible_links.push(link);
    const linkColour = link != null && this.highlighted_links[link.id] ? "#FFF" : color || link?.color || LGraphCanvas.link_type_colors[link.type] || this.default_link_color;
    const startDir = start_dir || LinkDirection.RIGHT;
    const endDir = end_dir || LinkDirection.LEFT;
    const dist2 = this.links_render_mode == LinkRenderType.SPLINE_LINK && (!endControl || !startControl) ? distance(a, b) : null;
    if (this.render_connections_border && this.ds.scale > 0.6) {
      ctx.lineWidth = this.connections_width + 4;
    }
    ctx.lineJoin = "round";
    num_sublines ||= 1;
    if (num_sublines > 1) ctx.lineWidth = 0.5;
    const path = new Path2D();
    const linkSegment = reroute ?? link;
    if (linkSegment) linkSegment.path = path;
    const innerA = LGraphCanvas.#lTempA;
    const innerB = LGraphCanvas.#lTempB;
    const pos2 = linkSegment?._pos ?? [0, 0];
    for (let i2 = 0; i2 < num_sublines; i2 += 1) {
      const offsety = (i2 - (num_sublines - 1) * 0.5) * 5;
      innerA[0] = a[0];
      innerA[1] = a[1];
      innerB[0] = b[0];
      innerB[1] = b[1];
      if (this.links_render_mode == LinkRenderType.SPLINE_LINK) {
        if (endControl) {
          innerB[0] = b[0] + endControl[0];
          innerB[1] = b[1] + endControl[1];
        } else {
          this.#addSplineOffset(innerB, endDir, dist2);
        }
        if (startControl) {
          innerA[0] = a[0] + startControl[0];
          innerA[1] = a[1] + startControl[1];
        } else {
          this.#addSplineOffset(innerA, startDir, dist2);
        }
        path.moveTo(a[0], a[1] + offsety);
        path.bezierCurveTo(
          innerA[0],
          innerA[1] + offsety,
          innerB[0],
          innerB[1] + offsety,
          b[0],
          b[1] + offsety
        );
        findPointOnCurve(pos2, a, b, innerA, innerB, 0.5);
        if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {
          const justPastCentre = LGraphCanvas.#lTempC;
          findPointOnCurve(justPastCentre, a, b, innerA, innerB, 0.51);
          linkSegment._centreAngle = Math.atan2(justPastCentre[1] - pos2[1], justPastCentre[0] - pos2[0]);
        }
      } else if (this.links_render_mode == LinkRenderType.LINEAR_LINK) {
        const l = 15;
        switch (startDir) {
          case LinkDirection.LEFT:
            innerA[0] += -l;
            break;
          case LinkDirection.RIGHT:
            innerA[0] += l;
            break;
          case LinkDirection.UP:
            innerA[1] += -l;
            break;
          case LinkDirection.DOWN:
            innerA[1] += l;
            break;
        }
        switch (endDir) {
          case LinkDirection.LEFT:
            innerB[0] += -l;
            break;
          case LinkDirection.RIGHT:
            innerB[0] += l;
            break;
          case LinkDirection.UP:
            innerB[1] += -l;
            break;
          case LinkDirection.DOWN:
            innerB[1] += l;
            break;
        }
        path.moveTo(a[0], a[1] + offsety);
        path.lineTo(innerA[0], innerA[1] + offsety);
        path.lineTo(innerB[0], innerB[1] + offsety);
        path.lineTo(b[0], b[1] + offsety);
        pos2[0] = (innerA[0] + innerB[0]) * 0.5;
        pos2[1] = (innerA[1] + innerB[1]) * 0.5;
        if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {
          linkSegment._centreAngle = Math.atan2(innerB[1] - innerA[1], innerB[0] - innerA[0]);
        }
      } else if (this.links_render_mode == LinkRenderType.STRAIGHT_LINK) {
        if (startDir == LinkDirection.RIGHT) {
          innerA[0] += 10;
        } else {
          innerA[1] += 10;
        }
        if (endDir == LinkDirection.LEFT) {
          innerB[0] -= 10;
        } else {
          innerB[1] -= 10;
        }
        const midX = (innerA[0] + innerB[0]) * 0.5;
        path.moveTo(a[0], a[1]);
        path.lineTo(innerA[0], innerA[1]);
        path.lineTo(midX, innerA[1]);
        path.lineTo(midX, innerB[1]);
        path.lineTo(innerB[0], innerB[1]);
        path.lineTo(b[0], b[1]);
        pos2[0] = midX;
        pos2[1] = (innerA[1] + innerB[1]) * 0.5;
        if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {
          const diff2 = innerB[1] - innerA[1];
          if (Math.abs(diff2) < 4) linkSegment._centreAngle = 0;
          else if (diff2 > 0) linkSegment._centreAngle = Math.PI * 0.5;
          else linkSegment._centreAngle = -(Math.PI * 0.5);
        }
      } else {
        return;
      }
    }
    if (this.render_connections_border && this.ds.scale > 0.6 && !skip_border) {
      ctx.strokeStyle = "rgba(0,0,0,0.5)";
      ctx.stroke(path);
    }
    ctx.lineWidth = this.connections_width;
    ctx.fillStyle = ctx.strokeStyle = linkColour;
    ctx.stroke(path);
    if (this.ds.scale >= 0.6 && this.highquality_render && linkSegment && // TODO: Re-assess this usage - likely a workaround that linkSegment truthy check resolves
    endDir != LinkDirection.CENTER) {
      if (this.render_connection_arrows) {
        const posA = this.computeConnectionPoint(
          a,
          b,
          0.25,
          startDir,
          endDir
        );
        const posB = this.computeConnectionPoint(
          a,
          b,
          0.26,
          startDir,
          endDir
        );
        const posC = this.computeConnectionPoint(
          a,
          b,
          0.75,
          startDir,
          endDir
        );
        const posD = this.computeConnectionPoint(
          a,
          b,
          0.76,
          startDir,
          endDir
        );
        let angleA = 0;
        let angleB = 0;
        if (this.render_curved_connections) {
          angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);
          angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);
        } else {
          angleB = angleA = b[1] > a[1] ? 0 : Math.PI;
        }
        const transform2 = ctx.getTransform();
        ctx.translate(posA[0], posA[1]);
        ctx.rotate(angleA);
        ctx.beginPath();
        ctx.moveTo(-5, -3);
        ctx.lineTo(0, 7);
        ctx.lineTo(5, -3);
        ctx.fill();
        ctx.setTransform(transform2);
        ctx.translate(posC[0], posC[1]);
        ctx.rotate(angleB);
        ctx.beginPath();
        ctx.moveTo(-5, -3);
        ctx.lineTo(0, 7);
        ctx.lineTo(5, -3);
        ctx.fill();
        ctx.setTransform(transform2);
      }
      ctx.beginPath();
      if (this.linkMarkerShape === LinkMarkerShape.Arrow) {
        const transform2 = ctx.getTransform();
        ctx.translate(pos2[0], pos2[1]);
        ctx.rotate(linkSegment._centreAngle);
        ctx.moveTo(-3.2, -5);
        ctx.lineTo(7, 0);
        ctx.lineTo(-3.2, 5);
        ctx.fill();
        ctx.setTransform(transform2);
      } else if (this.linkMarkerShape == null || this.linkMarkerShape === LinkMarkerShape.Circle) {
        ctx.arc(pos2[0], pos2[1], 5, 0, Math.PI * 2);
      }
      ctx.fill();
    }
    if (flow) {
      ctx.fillStyle = linkColour;
      for (let i2 = 0; i2 < 5; ++i2) {
        const f = (LiteGraph.getTime() * 1e-3 + i2 * 0.2) % 1;
        const flowPos = this.computeConnectionPoint(
          a,
          b,
          f,
          startDir,
          endDir
        );
        ctx.beginPath();
        ctx.arc(flowPos[0], flowPos[1], 5, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
  }
  /**
   * Finds a point along a spline represented by a to b, with spline endpoint directions dictacted by start_dir and end_dir.
   * @param a Start point
   * @param b End point
   * @param t Time: distance between points (e.g 0.25 is 25% along the line)
   * @param start_dir Spline start direction
   * @param end_dir Spline end direction
   * @returns The point at {@link t} distance along the spline a-b.
   */
  computeConnectionPoint(a, b, t, start_dir, end_dir) {
    start_dir ||= LinkDirection.RIGHT;
    end_dir ||= LinkDirection.LEFT;
    const dist2 = distance(a, b);
    const pa = [a[0], a[1]];
    const pb = [b[0], b[1]];
    this.#addSplineOffset(pa, start_dir, dist2);
    this.#addSplineOffset(pb, end_dir, dist2);
    const c1 = (1 - t) * (1 - t) * (1 - t);
    const c2 = 3 * ((1 - t) * (1 - t)) * t;
    const c3 = 3 * (1 - t) * (t * t);
    const c4 = t * t * t;
    const x2 = c1 * a[0] + c2 * pa[0] + c3 * pb[0] + c4 * b[0];
    const y2 = c1 * a[1] + c2 * pa[1] + c3 * pb[1] + c4 * b[1];
    return [x2, y2];
  }
  /**
   * Modifies an existing point, adding a single-axis offset.
   * @param point The point to add the offset to
   * @param direction The direction to add the offset in
   * @param dist Distance to offset
   * @param factor Distance is mulitplied by this value.  Default: 0.25
   */
  #addSplineOffset(point, direction, dist2, factor = 0.25) {
    switch (direction) {
      case LinkDirection.LEFT:
        point[0] += dist2 * -factor;
        break;
      case LinkDirection.RIGHT:
        point[0] += dist2 * factor;
        break;
      case LinkDirection.UP:
        point[1] += dist2 * -factor;
        break;
      case LinkDirection.DOWN:
        point[1] += dist2 * factor;
        break;
    }
  }
  drawExecutionOrder(ctx) {
    ctx.shadowColor = "transparent";
    ctx.globalAlpha = 0.25;
    ctx.textAlign = "center";
    ctx.strokeStyle = "white";
    ctx.globalAlpha = 0.75;
    const visible_nodes = this.visible_nodes;
    for (let i2 = 0; i2 < visible_nodes.length; ++i2) {
      const node22 = visible_nodes[i2];
      ctx.fillStyle = "black";
      ctx.fillRect(
        node22.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,
        node22.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,
        LiteGraph.NODE_TITLE_HEIGHT,
        LiteGraph.NODE_TITLE_HEIGHT
      );
      if (node22.order == 0) {
        ctx.strokeRect(
          node22.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
          node22.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
          LiteGraph.NODE_TITLE_HEIGHT,
          LiteGraph.NODE_TITLE_HEIGHT
        );
      }
      ctx.fillStyle = "#FFF";
      ctx.fillText(
        stringOrEmpty(node22.order),
        node22.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,
        node22.pos[1] - 6
      );
    }
    ctx.globalAlpha = 1;
  }
  /**
   * draws the widgets stored inside a node
   **/
  drawNodeWidgets(node22, posY, ctx, active_widget2) {
    if (!node22.widgets || !node22.widgets.length) return 0;
    const width2 = node22.size[0];
    const widgets = node22.widgets;
    posY += 2;
    const H = LiteGraph.NODE_WIDGET_HEIGHT;
    const show_text = this.ds.scale > 0.5;
    ctx.save();
    ctx.globalAlpha = this.editor_alpha;
    const outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;
    const background_color = LiteGraph.WIDGET_BGCOLOR;
    const text_color = LiteGraph.WIDGET_TEXT_COLOR;
    const secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;
    const margin = 15;
    for (let i2 = 0; i2 < widgets.length; ++i2) {
      const w2 = widgets[i2];
      if (w2.hidden || w2.advanced && !node22.showAdvanced) continue;
      const y2 = w2.y || posY;
      if (w2 === this.link_over_widget) {
        ctx.fillStyle = this.default_connection_color_byType[this.link_over_widget_type] || this.default_connection_color.input_on;
        drawSlot(ctx, {}, [10, y2 + 10], {});
      }
      w2.last_y = y2;
      ctx.strokeStyle = outline_color;
      ctx.fillStyle = "#222";
      ctx.textAlign = "left";
      if (w2.disabled)
        ctx.globalAlpha *= 0.5;
      const widget_width2 = w2.width || width2;
      switch (w2.type) {
        case "button":
          ctx.fillStyle = background_color;
          if (w2.clicked) {
            ctx.fillStyle = "#AAA";
            w2.clicked = false;
            this.dirty_canvas = true;
          }
          ctx.fillRect(margin, y2, widget_width2 - margin * 2, H);
          if (show_text && !w2.disabled)
            ctx.strokeRect(margin, y2, widget_width2 - margin * 2, H);
          if (show_text) {
            ctx.textAlign = "center";
            ctx.fillStyle = text_color;
            ctx.fillText(w2.label || w2.name, widget_width2 * 0.5, y2 + H * 0.7);
          }
          break;
        case "toggle":
          ctx.textAlign = "left";
          ctx.strokeStyle = outline_color;
          ctx.fillStyle = background_color;
          ctx.beginPath();
          if (show_text)
            ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
          else
            ctx.rect(margin, y2, widget_width2 - margin * 2, H);
          ctx.fill();
          if (show_text && !w2.disabled)
            ctx.stroke();
          ctx.fillStyle = w2.value ? "#89A" : "#333";
          ctx.beginPath();
          ctx.arc(widget_width2 - margin * 2, y2 + H * 0.5, H * 0.36, 0, Math.PI * 2);
          ctx.fill();
          if (show_text) {
            ctx.fillStyle = secondary_text_color;
            const label5 = w2.label || w2.name;
            if (label5 != null) {
              ctx.fillText(label5, margin * 2, y2 + H * 0.7);
            }
            ctx.fillStyle = w2.value ? text_color : secondary_text_color;
            ctx.textAlign = "right";
            ctx.fillText(
              w2.value ? w2.options.on || "true" : w2.options.off || "false",
              widget_width2 - 40,
              y2 + H * 0.7
            );
          }
          break;
        case "slider": {
          ctx.fillStyle = background_color;
          ctx.fillRect(margin, y2, widget_width2 - margin * 2, H);
          const range2 = w2.options.max - w2.options.min;
          let nvalue = (w2.value - w2.options.min) / range2;
          if (nvalue < 0) nvalue = 0;
          if (nvalue > 1) nvalue = 1;
          ctx.fillStyle = w2.options.hasOwnProperty("slider_color") ? w2.options.slider_color : active_widget2 == w2 ? "#89A" : "#678";
          ctx.fillRect(margin, y2, nvalue * (widget_width2 - margin * 2), H);
          if (show_text && !w2.disabled)
            ctx.strokeRect(margin, y2, widget_width2 - margin * 2, H);
          if (w2.marker) {
            let marker_nvalue = (w2.marker - w2.options.min) / range2;
            if (marker_nvalue < 0) marker_nvalue = 0;
            if (marker_nvalue > 1) marker_nvalue = 1;
            ctx.fillStyle = w2.options.hasOwnProperty("marker_color") ? w2.options.marker_color : "#AA9";
            ctx.fillRect(margin + marker_nvalue * (widget_width2 - margin * 2), y2, 2, H);
          }
          if (show_text) {
            ctx.textAlign = "center";
            ctx.fillStyle = text_color;
            ctx.fillText(
              w2.label || w2.name + "  " + Number(w2.value).toFixed(
                w2.options.precision != null ? w2.options.precision : 3
              ),
              widget_width2 * 0.5,
              y2 + H * 0.7
            );
          }
          break;
        }
        case "number":
        case "combo":
          ctx.textAlign = "left";
          ctx.strokeStyle = outline_color;
          ctx.fillStyle = background_color;
          ctx.beginPath();
          if (show_text)
            ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
          else
            ctx.rect(margin, y2, widget_width2 - margin * 2, H);
          ctx.fill();
          if (show_text) {
            if (!w2.disabled)
              ctx.stroke();
            ctx.fillStyle = text_color;
            if (!w2.disabled) {
              ctx.beginPath();
              ctx.moveTo(margin + 16, y2 + 5);
              ctx.lineTo(margin + 6, y2 + H * 0.5);
              ctx.lineTo(margin + 16, y2 + H - 5);
              ctx.fill();
              ctx.beginPath();
              ctx.moveTo(widget_width2 - margin - 16, y2 + 5);
              ctx.lineTo(widget_width2 - margin - 6, y2 + H * 0.5);
              ctx.lineTo(widget_width2 - margin - 16, y2 + H - 5);
              ctx.fill();
            }
            ctx.fillStyle = secondary_text_color;
            ctx.fillText(w2.label || w2.name, margin * 2 + 5, y2 + H * 0.7);
            ctx.fillStyle = text_color;
            ctx.textAlign = "right";
            if (w2.type == "number") {
              ctx.fillText(
                Number(w2.value).toFixed(
                  w2.options.precision !== void 0 ? w2.options.precision : 3
                ),
                widget_width2 - margin * 2 - 20,
                y2 + H * 0.7
              );
            } else {
              let v2 = typeof w2.value === "number" ? String(w2.value) : w2.value;
              if (w2.options.values) {
                let values2 = w2.options.values;
                if (typeof values2 === "function")
                  values2 = values2();
                if (values2 && !Array.isArray(values2))
                  v2 = values2[w2.value];
              }
              const labelWidth = ctx.measureText(w2.label || w2.name).width + margin * 2;
              const inputWidth = widget_width2 - margin * 4;
              const availableWidth = inputWidth - labelWidth;
              const textWidth = ctx.measureText(v2).width;
              if (textWidth > availableWidth) {
                const ELLIPSIS = "";
                const ellipsisWidth = ctx.measureText(ELLIPSIS).width;
                const charWidthAvg = ctx.measureText("a").width;
                if (availableWidth <= ellipsisWidth) {
                  v2 = "";
                } else {
                  v2 = `${v2}`;
                  const overflowWidth = textWidth + ellipsisWidth - availableWidth;
                  if (overflowWidth + charWidthAvg * 3 > availableWidth) {
                    const preciseRange = availableWidth + charWidthAvg * 3;
                    const preTruncateCt = Math.floor((preciseRange - ellipsisWidth) / charWidthAvg);
                    v2 = v2.substr(0, preTruncateCt);
                  }
                  while (ctx.measureText(v2).width + ellipsisWidth > availableWidth) {
                    v2 = v2.substr(0, v2.length - 1);
                  }
                  v2 += ELLIPSIS;
                }
              }
              ctx.fillText(
                v2,
                widget_width2 - margin * 2 - 20,
                y2 + H * 0.7
              );
            }
          }
          break;
        case "string":
        case "text":
          ctx.textAlign = "left";
          ctx.strokeStyle = outline_color;
          ctx.fillStyle = background_color;
          ctx.beginPath();
          if (show_text)
            ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
          else
            ctx.rect(margin, y2, widget_width2 - margin * 2, H);
          ctx.fill();
          if (show_text) {
            if (!w2.disabled)
              ctx.stroke();
            ctx.save();
            ctx.beginPath();
            ctx.rect(margin, y2, widget_width2 - margin * 2, H);
            ctx.clip();
            ctx.fillStyle = secondary_text_color;
            const label5 = w2.label || w2.name;
            if (label5 != null)
              ctx.fillText(label5, margin * 2, y2 + H * 0.7);
            ctx.fillStyle = text_color;
            ctx.textAlign = "right";
            ctx.fillText(String(w2.value).substr(0, 30), widget_width2 - margin * 2, y2 + H * 0.7);
            ctx.restore();
          }
          break;
        default:
          w2.draw?.(ctx, node22, widget_width2, y2, H);
          break;
      }
      posY += (w2.computeSize ? w2.computeSize(widget_width2)[1] : H) + 4;
      ctx.globalAlpha = this.editor_alpha;
    }
    ctx.restore();
    ctx.textAlign = "left";
  }
  /**
   * process an event on widgets
   **/
  processNodeWidgets(node, pos, event, active_widget) {
    if (!node.widgets || !node.widgets.length || !this.allow_interaction && !node.flags.allow_interaction) {
      return null;
    }
    const x = pos[0] - node.pos[0];
    const y = pos[1] - node.pos[1];
    const width = node.size[0];
    const that = this;
    const ref_window = this.getCanvasWindow();
    let values;
    let values_list;
    for (let i = 0; i < node.widgets.length; ++i) {
      const w = node.widgets[i];
      if (!w || w.disabled || w.hidden || w.advanced && !node.showAdvanced)
        continue;
      const widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT;
      const widget_width = w.width || width;
      if (w != active_widget && (x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === void 0))
        continue;
      const old_value = w.value;
      switch (w.type) {
        case "button": {
          if (event.type === LiteGraph.pointerevents_method + "down") {
            if (w.callback) {
              setTimeout(function() {
                w.callback(w, that, node, pos, event);
              }, 20);
            }
            w.clicked = true;
            this.dirty_canvas = true;
          }
          break;
        }
        case "slider": {
          const nvalue = clamp$1((x - 15) / (widget_width - 30), 0, 1);
          if (w.options.read_only) break;
          w.value = w.options.min + (w.options.max - w.options.min) * nvalue;
          if (old_value != w.value) {
            setTimeout(function() {
              inner_value_change(w, w.value);
            }, 20);
          }
          this.dirty_canvas = true;
          break;
        }
        case "number":
        case "combo": {
          let delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
          const allow_scroll = delta && (x > -3 && x < widget_width + 3) ? false : true;
          if (allow_scroll && event.type == LiteGraph.pointerevents_method + "move" && w.type == "number") {
            if (event.deltaX)
              w.value += event.deltaX * 0.1 * (w.options.step || 1);
            if (w.options.min != null && w.value < w.options.min) {
              w.value = w.options.min;
            }
            if (w.options.max != null && w.value > w.options.max) {
              w.value = w.options.max;
            }
          } else if (event.type == LiteGraph.pointerevents_method + "down") {
            values = w.options.values;
            if (typeof values === "function") {
              values = w.options.values(w, node);
            }
            values_list = null;
            if (w.type != "number")
              values_list = Array.isArray(values) ? values : Object.keys(values);
            delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
            if (w.type == "number") {
              w.value += delta * 0.1 * (w.options.step || 1);
              if (w.options.min != null && w.value < w.options.min) {
                w.value = w.options.min;
              }
              if (w.options.max != null && w.value > w.options.max) {
                w.value = w.options.max;
              }
            } else if (delta) {
              let index2 = -1;
              this.last_mouseclick = 0;
              index2 = typeof values === "object" ? values_list.indexOf(String(w.value)) + delta : values_list.indexOf(w.value) + delta;
              if (index2 >= values_list.length) index2 = values_list.length - 1;
              if (index2 < 0) index2 = 0;
              w.value = Array.isArray(values) ? values[index2] : index2;
            } else {
              let inner_clicked = /* @__PURE__ */ __name(function(v2) {
                if (values != values_list)
                  v2 = text_values.indexOf(v2);
                this.value = v2;
                inner_value_change(this, v2);
                that.dirty_canvas = true;
                return false;
              }, "inner_clicked");
              const text_values = values != values_list ? Object.values(values) : values;
              new LiteGraph.ContextMenu(
                text_values,
                {
                  scale: Math.max(1, this.ds.scale),
                  event,
                  className: "dark",
                  callback: inner_clicked.bind(w)
                },
                // @ts-expect-error Not impl - harmless
                ref_window
              );
            }
          } else if (event.type == LiteGraph.pointerevents_method + "up" && w.type == "number") {
            delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
            if (event.click_time < 200 && delta == 0) {
              this.prompt(
                "Value",
                w.value,
                function(v) {
                  if (/^[0-9+\-*/()\s]+|\d+\.\d+$/.test(v)) {
                    try {
                      v = eval(v);
                    } catch {
                    }
                  }
                  this.value = Number(v);
                  inner_value_change(this, this.value);
                }.bind(w),
                event
              );
            }
          }
          if (old_value != w.value)
            setTimeout(
              function() {
                inner_value_change(this, this.value);
              }.bind(w),
              20
            );
          this.dirty_canvas = true;
          break;
        }
        case "toggle":
          if (event.type == LiteGraph.pointerevents_method + "down") {
            w.value = !w.value;
            setTimeout(function() {
              inner_value_change(w, w.value);
            }, 20);
          }
          break;
        case "string":
        case "text":
          if (event.type == LiteGraph.pointerevents_method + "down") {
            this.prompt(
              "Value",
              w.value,
              function(v2) {
                inner_value_change(this, v2);
              }.bind(w),
              event,
              w.options ? w.options.multiline : false
            );
          }
          break;
        default:
          if (w.mouse) this.dirty_canvas = w.mouse(event, [x, y], node);
          break;
      }
      if (old_value != w.value) {
        node.onWidgetChanged?.(w.name, w.value, old_value, w);
        node.graph._version++;
      }
      return w;
    }
    function inner_value_change(widget, value3) {
      const v2 = widget.type === "number" ? Number(value3) : value3;
      widget.value = v2;
      if (widget.options?.property && node.properties[widget.options.property] !== void 0) {
        node.setProperty(widget.options.property, v2);
      }
      widget.callback?.(widget.value, that, node, pos, event);
    }
    __name(inner_value_change, "inner_value_change");
    return null;
  }
  /**
   * draws every group area in the background
   **/
  drawGroups(canvas, ctx) {
    if (!this.graph) return;
    const groups = this.graph._groups;
    ctx.save();
    ctx.globalAlpha = 0.5 * this.editor_alpha;
    for (let i2 = 0; i2 < groups.length; ++i2) {
      const group = groups[i2];
      if (!overlapBounding(this.visible_area, group._bounding)) {
        continue;
      }
      group.draw(this, ctx);
    }
    ctx.restore();
  }
  adjustNodesSize() {
    const nodes = this.graph._nodes;
    for (let i2 = 0; i2 < nodes.length; ++i2) {
      nodes[i2].size = nodes[i2].computeSize();
    }
    this.setDirty(true, true);
  }
  /**
   * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode
   * @todo Remove or rewrite
   **/
  resize(width2, height) {
    if (!width2 && !height) {
      const parent = this.canvas.parentElement;
      width2 = parent.offsetWidth;
      height = parent.offsetHeight;
    }
    if (this.canvas.width == width2 && this.canvas.height == height)
      return;
    this.canvas.width = width2;
    this.canvas.height = height;
    this.bgcanvas.width = this.canvas.width;
    this.bgcanvas.height = this.canvas.height;
    this.setDirty(true, true);
  }
  /**
   * switches to live mode (node shapes are not rendered, only the content)
   * this feature was designed when graphs where meant to create user interfaces
   **/
  switchLiveMode(transition) {
    if (!transition) {
      this.live_mode = !this.live_mode;
      this.#dirty();
      return;
    }
    const self2 = this;
    const delta2 = this.live_mode ? 1.1 : 0.9;
    if (this.live_mode) {
      this.live_mode = false;
      this.editor_alpha = 0.1;
    }
    const t = setInterval(function() {
      self2.editor_alpha *= delta2;
      self2.dirty_canvas = true;
      self2.dirty_bgcanvas = true;
      if (delta2 < 1 && self2.editor_alpha < 0.01) {
        clearInterval(t);
        if (delta2 < 1) self2.live_mode = true;
      }
      if (delta2 > 1 && self2.editor_alpha > 0.99) {
        clearInterval(t);
        self2.editor_alpha = 1;
      }
    }, 1);
  }
  onNodeSelectionChange() {
  }
  /**
   * Determines the furthest nodes in each direction for the currently selected nodes
   * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}
   */
  boundaryNodesForSelection() {
    return LGraphCanvas.getBoundaryNodes(this.selected_nodes);
  }
  showLinkMenu(segment, e) {
    const { graph } = this;
    const node_left = graph.getNodeById(segment.origin_id);
    const fromType = node_left?.outputs?.[segment.origin_slot]?.type ?? "*";
    const options3 = ["Add Node", null, "Delete", null];
    if (this.reroutesEnabled) options3.splice(1, 0, "Add Reroute");
    const title = "data" in segment && segment.data != null ? segment.data.constructor.name : null;
    const menu = new LiteGraph.ContextMenu(options3, {
      event: e,
      title,
      callback: inner_clicked.bind(this)
    });
    function inner_clicked(v2, options22, e2) {
      switch (v2) {
        case "Add Node":
          LGraphCanvas.onMenuAdd(null, null, e2, menu, function(node22) {
            if (!node22.inputs?.length || !node22.outputs?.length) return;
            const options32 = this.reroutesEnabled ? { afterRerouteId: segment.parentId } : void 0;
            if (node_left.connectByType(segment.origin_slot, node22, fromType, options32)) {
              node22.pos[0] -= node22.size[0] * 0.5;
            }
          });
          break;
        case "Add Reroute": {
          this.adjustMouseEvent(e2);
          graph.createReroute([e2.canvasX, e2.canvasY], segment);
          this.setDirty(false, true);
          break;
        }
        case "Delete":
          graph.removeLink(segment.id);
          break;
      }
    }
    __name(inner_clicked, "inner_clicked");
    return false;
  }
  createDefaultNodeForSlot(optPass) {
    const opts = Object.assign({
      nodeFrom: null,
      slotFrom: null,
      nodeTo: null,
      slotTo: null,
      position: [0, 0],
      nodeType: null,
      posAdd: [0, 0],
      posSizeFix: [0, 0]
    }, optPass || {});
    const { afterRerouteId } = opts;
    const isFrom = opts.nodeFrom && opts.slotFrom !== null;
    const isTo = !isFrom && opts.nodeTo && opts.slotTo !== null;
    if (!isFrom && !isTo) {
      console.warn("No data passed to createDefaultNodeForSlot " + opts.nodeFrom + " " + opts.slotFrom + " " + opts.nodeTo + " " + opts.slotTo);
      return false;
    }
    if (!opts.nodeType) {
      console.warn("No type to createDefaultNodeForSlot");
      return false;
    }
    const nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;
    let slotX = isFrom ? opts.slotFrom : opts.slotTo;
    let iSlotConn = false;
    switch (typeof slotX) {
      case "string":
        iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);
        slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
        break;
      case "object":
        iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);
        break;
      case "number":
        iSlotConn = slotX;
        slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
        break;
      case "undefined":
      default:
        console.warn("Cant get slot information " + slotX);
        return false;
    }
    const fromSlotType = slotX.type == LiteGraph.EVENT ? "_event_" : slotX.type;
    const slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
    if (slotTypesDefault?.[fromSlotType]) {
      let nodeNewType = false;
      if (typeof slotTypesDefault[fromSlotType] == "object") {
        for (const typeX in slotTypesDefault[fromSlotType]) {
          if (opts.nodeType == slotTypesDefault[fromSlotType][typeX] || opts.nodeType == "AUTO") {
            nodeNewType = slotTypesDefault[fromSlotType][typeX];
            break;
          }
        }
      } else if (opts.nodeType == slotTypesDefault[fromSlotType] || opts.nodeType == "AUTO") {
        nodeNewType = slotTypesDefault[fromSlotType];
      }
      if (nodeNewType) {
        let nodeNewOpts = false;
        if (typeof nodeNewType == "object" && nodeNewType.node) {
          nodeNewOpts = nodeNewType;
          nodeNewType = nodeNewType.node;
        }
        const newNode = LiteGraph.createNode(nodeNewType);
        if (newNode) {
          if (nodeNewOpts) {
            if (nodeNewOpts.properties) {
              for (const i2 in nodeNewOpts.properties) {
                newNode.addProperty(i2, nodeNewOpts.properties[i2]);
              }
            }
            if (nodeNewOpts.inputs) {
              newNode.inputs = [];
              for (const i2 in nodeNewOpts.inputs) {
                newNode.addOutput(
                  nodeNewOpts.inputs[i2][0],
                  nodeNewOpts.inputs[i2][1]
                );
              }
            }
            if (nodeNewOpts.outputs) {
              newNode.outputs = [];
              for (const i2 in nodeNewOpts.outputs) {
                newNode.addOutput(
                  nodeNewOpts.outputs[i2][0],
                  nodeNewOpts.outputs[i2][1]
                );
              }
            }
            if (nodeNewOpts.title) {
              newNode.title = nodeNewOpts.title;
            }
            if (nodeNewOpts.json) {
              newNode.configure(nodeNewOpts.json);
            }
          }
          this.graph.add(newNode);
          newNode.pos = [
            opts.position[0] + opts.posAdd[0] + (opts.posSizeFix[0] ? opts.posSizeFix[0] * newNode.size[0] : 0),
            opts.position[1] + opts.posAdd[1] + (opts.posSizeFix[1] ? opts.posSizeFix[1] * newNode.size[1] : 0)
          ];
          if (isFrom) {
            opts.nodeFrom.connectByType(iSlotConn, newNode, fromSlotType, { afterRerouteId });
          } else {
            opts.nodeTo.connectByTypeOutput(iSlotConn, newNode, fromSlotType, { afterRerouteId });
          }
          return true;
        }
        console.log("failed creating " + nodeNewType);
      }
    }
    return false;
  }
  showConnectionMenu(optPass) {
    const opts = Object.assign({
      nodeFrom: null,
      slotFrom: null,
      nodeTo: null,
      slotTo: null,
      e: null,
      allow_searchbox: this.allow_searchbox,
      showSearchBox: this.showSearchBox
    }, optPass || {});
    const that2 = this;
    const { afterRerouteId } = opts;
    const isFrom = opts.nodeFrom && opts.slotFrom;
    const isTo = !isFrom && opts.nodeTo && opts.slotTo;
    if (!isFrom && !isTo) {
      console.warn("No data passed to showConnectionMenu");
      return;
    }
    const nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;
    let slotX = isFrom ? opts.slotFrom : opts.slotTo;
    let iSlotConn;
    switch (typeof slotX) {
      case "string":
        iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);
        slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
        break;
      case "object":
        iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);
        break;
      case "number":
        iSlotConn = slotX;
        slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
        break;
      default:
        console.warn("Cant get slot information " + slotX);
        return;
    }
    const options3 = ["Add Node", null];
    if (opts.allow_searchbox) {
      options3.push("Search");
      options3.push(null);
    }
    const fromSlotType = slotX.type == LiteGraph.EVENT ? "_event_" : slotX.type;
    const slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
    if (slotTypesDefault?.[fromSlotType]) {
      if (typeof slotTypesDefault[fromSlotType] == "object") {
        for (const typeX in slotTypesDefault[fromSlotType]) {
          options3.push(slotTypesDefault[fromSlotType][typeX]);
        }
      } else {
        options3.push(slotTypesDefault[fromSlotType]);
      }
    }
    const menu = new LiteGraph.ContextMenu(options3, {
      event: opts.e,
      title: (slotX && slotX.name != "" ? slotX.name + (fromSlotType ? " | " : "") : "") + (slotX && fromSlotType ? fromSlotType : ""),
      callback: inner_clicked
    });
    function inner_clicked(v2, options22, e) {
      switch (v2) {
        case "Add Node":
          LGraphCanvas.onMenuAdd(null, null, e, menu, function(node22) {
            if (isFrom) {
              opts.nodeFrom.connectByType(iSlotConn, node22, fromSlotType, { afterRerouteId });
            } else {
              opts.nodeTo.connectByTypeOutput(iSlotConn, node22, fromSlotType, { afterRerouteId });
            }
          });
          break;
        case "Search":
          if (isFrom) {
            opts.showSearchBox(e, { node_from: opts.nodeFrom, slot_from: slotX, type_filter_in: fromSlotType });
          } else {
            opts.showSearchBox(e, { node_to: opts.nodeTo, slot_from: slotX, type_filter_out: fromSlotType });
          }
          break;
        default: {
          that2.createDefaultNodeForSlot(Object.assign(opts, {
            position: [opts.e.canvasX, opts.e.canvasY],
            nodeType: v2,
            afterRerouteId
          }));
          break;
        }
      }
    }
    __name(inner_clicked, "inner_clicked");
  }
  // refactor: there are different dialogs, some uses createDialog some dont
  prompt(title, value3, callback, event2, multiline) {
    const that2 = this;
    title = title || "";
    const dialog = document.createElement("div");
    dialog.is_modified = false;
    dialog.className = "graphdialog rounded";
    dialog.innerHTML = multiline ? "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>" : "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
    dialog.close = function() {
      that2.prompt_box = null;
      if (dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
      }
    };
    const graphcanvas = LGraphCanvas.active_canvas;
    const canvas = graphcanvas.canvas;
    canvas.parentNode.appendChild(dialog);
    if (this.ds.scale > 1) dialog.style.transform = "scale(" + this.ds.scale + ")";
    let dialogCloseTimer = null;
    let prevent_timeout = 0;
    LiteGraph.pointerListenerAdd(dialog, "leave", function() {
      if (prevent_timeout)
        return;
      if (LiteGraph.dialog_close_on_mouse_leave) {
        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
          dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
      }
    });
    LiteGraph.pointerListenerAdd(dialog, "enter", function() {
      if (LiteGraph.dialog_close_on_mouse_leave && dialogCloseTimer)
        clearTimeout(dialogCloseTimer);
    });
    const selInDia = dialog.querySelectorAll("select");
    if (selInDia) {
      for (const selIn of selInDia) {
        selIn.addEventListener("click", function() {
          prevent_timeout++;
        });
        selIn.addEventListener("blur", function() {
          prevent_timeout = 0;
        });
        selIn.addEventListener("change", function() {
          prevent_timeout = -1;
        });
      }
    }
    this.prompt_box?.close();
    this.prompt_box = dialog;
    const name_element = dialog.querySelector(".name");
    name_element.innerText = title;
    const value_element = dialog.querySelector(".value");
    value_element.value = value3;
    value_element.select();
    const input = value_element;
    input.addEventListener("keydown", function(e) {
      dialog.is_modified = true;
      if (e.keyCode == 27) {
        dialog.close();
      } else if (e.keyCode == 13 && e.target.localName != "textarea") {
        if (callback) {
          callback(this.value);
        }
        dialog.close();
      } else {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
    });
    const button = dialog.querySelector("button");
    button.addEventListener("click", function() {
      callback?.(input.value);
      that2.setDirty(true);
      dialog.close();
    });
    const rect = canvas.getBoundingClientRect();
    let offsetx = -20;
    let offsety = -20;
    if (rect) {
      offsetx -= rect.left;
      offsety -= rect.top;
    }
    if (event2) {
      dialog.style.left = event2.clientX + offsetx + "px";
      dialog.style.top = event2.clientY + offsety + "px";
    } else {
      dialog.style.left = canvas.width * 0.5 + offsetx + "px";
      dialog.style.top = canvas.height * 0.5 + offsety + "px";
    }
    setTimeout(function() {
      input.focus();
      const clickTime = Date.now();
      function handleOutsideClick(e) {
        if (e.target === canvas && Date.now() - clickTime > 256) {
          dialog.close();
          canvas.parentNode.removeEventListener("click", handleOutsideClick);
          canvas.parentNode.removeEventListener("touchend", handleOutsideClick);
        }
      }
      __name(handleOutsideClick, "handleOutsideClick");
      canvas.parentNode.addEventListener("click", handleOutsideClick);
      canvas.parentNode.addEventListener("touchend", handleOutsideClick);
    }, 10);
    return dialog;
  }
  showSearchBox(event2, options3) {
    const def_options = {
      slot_from: null,
      node_from: null,
      node_to: null,
      do_type_filter: LiteGraph.search_filter_enabled,
      // @ts-expect-error
      type_filter_in: false,
      type_filter_out: false,
      show_general_if_none_on_typefilter: true,
      show_general_after_typefiltered: true,
      hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave,
      show_all_if_empty: true,
      show_all_on_open: LiteGraph.search_show_all_on_open
    };
    options3 = Object.assign(def_options, options3 || {});
    const that2 = this;
    const graphcanvas = LGraphCanvas.active_canvas;
    const canvas = graphcanvas.canvas;
    const root_document = canvas.ownerDocument || document;
    const dialog = document.createElement("div");
    dialog.className = "litegraph litesearchbox graphdialog rounded";
    dialog.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>";
    if (options3.do_type_filter) {
      dialog.innerHTML += "<select class='slot_in_type_filter'><option value=''></option></select>";
      dialog.innerHTML += "<select class='slot_out_type_filter'><option value=''></option></select>";
    }
    dialog.innerHTML += "<div class='helper'></div>";
    if (root_document.fullscreenElement)
      root_document.fullscreenElement.appendChild(dialog);
    else {
      root_document.body.appendChild(dialog);
      root_document.body.style.overflow = "hidden";
    }
    let selIn;
    let selOut;
    if (options3.do_type_filter) {
      selIn = dialog.querySelector(".slot_in_type_filter");
      selOut = dialog.querySelector(".slot_out_type_filter");
    }
    dialog.close = function() {
      that2.search_box = null;
      this.blur();
      canvas.focus();
      root_document.body.style.overflow = "";
      setTimeout(function() {
        that2.canvas.focus();
      }, 20);
      dialog.parentNode?.removeChild(dialog);
    };
    if (this.ds.scale > 1) {
      dialog.style.transform = "scale(" + this.ds.scale + ")";
    }
    if (options3.hide_on_mouse_leave) {
      let prevent_timeout = false;
      let timeout_close = null;
      LiteGraph.pointerListenerAdd(dialog, "enter", function() {
        if (timeout_close) {
          clearTimeout(timeout_close);
          timeout_close = null;
        }
      });
      LiteGraph.pointerListenerAdd(dialog, "leave", function() {
        if (prevent_timeout)
          return;
        timeout_close = setTimeout(function() {
          dialog.close();
        }, typeof options3.hide_on_mouse_leave === "number" ? options3.hide_on_mouse_leave : 500);
      });
      if (options3.do_type_filter) {
        selIn.addEventListener("click", function() {
          prevent_timeout++;
        });
        selIn.addEventListener("blur", function() {
          prevent_timeout = 0;
        });
        selIn.addEventListener("change", function() {
          prevent_timeout = -1;
        });
        selOut.addEventListener("click", function() {
          prevent_timeout++;
        });
        selOut.addEventListener("blur", function() {
          prevent_timeout = 0;
        });
        selOut.addEventListener("change", function() {
          prevent_timeout = -1;
        });
      }
    }
    that2.search_box?.close();
    that2.search_box = dialog;
    const helper = dialog.querySelector(".helper");
    let first = null;
    let timeout = null;
    let selected2 = null;
    const input = dialog.querySelector("input");
    if (input) {
      input.addEventListener("blur", function() {
        this.focus();
      });
      input.addEventListener("keydown", function(e) {
        if (e.keyCode == 38) {
          changeSelection(false);
        } else if (e.keyCode == 40) {
          changeSelection(true);
        } else if (e.keyCode == 27) {
          dialog.close();
        } else if (e.keyCode == 13) {
          if (selected2) {
            select(unescape(selected2.dataset["type"]));
          } else if (first) {
            select(first);
          } else {
            dialog.close();
          }
        } else {
          if (timeout) {
            clearInterval(timeout);
          }
          timeout = setTimeout(refreshHelper, 10);
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        return true;
      });
    }
    if (options3.do_type_filter) {
      if (selIn) {
        const aSlots = LiteGraph.slot_types_in;
        const nSlots = aSlots.length;
        if (options3.type_filter_in == LiteGraph.EVENT || options3.type_filter_in == LiteGraph.ACTION)
          options3.type_filter_in = "_event_";
        for (let iK = 0; iK < nSlots; iK++) {
          const opt = document.createElement("option");
          opt.value = aSlots[iK];
          opt.innerHTML = aSlots[iK];
          selIn.appendChild(opt);
          if (options3.type_filter_in !== false && (options3.type_filter_in + "").toLowerCase() == (aSlots[iK] + "").toLowerCase()) {
            opt.selected = true;
          }
        }
        selIn.addEventListener("change", function() {
          refreshHelper();
        });
      }
      if (selOut) {
        const aSlots = LiteGraph.slot_types_out;
        const nSlots = aSlots.length;
        if (options3.type_filter_out == LiteGraph.EVENT || options3.type_filter_out == LiteGraph.ACTION)
          options3.type_filter_out = "_event_";
        for (let iK = 0; iK < nSlots; iK++) {
          const opt = document.createElement("option");
          opt.value = aSlots[iK];
          opt.innerHTML = aSlots[iK];
          selOut.appendChild(opt);
          if (options3.type_filter_out !== false && (options3.type_filter_out + "").toLowerCase() == (aSlots[iK] + "").toLowerCase())
            opt.selected = true;
        }
        selOut.addEventListener("change", function() {
          refreshHelper();
        });
      }
    }
    const rect = canvas.getBoundingClientRect();
    const left = (event2 ? event2.clientX : rect.left + rect.width * 0.5) - 80;
    const top = (event2 ? event2.clientY : rect.top + rect.height * 0.5) - 20;
    dialog.style.left = left + "px";
    dialog.style.top = top + "px";
    if (event2.layerY > rect.height - 200)
      helper.style.maxHeight = rect.height - event2.layerY - 20 + "px";
    requestAnimationFrame(function() {
      input.focus();
    });
    if (options3.show_all_on_open) refreshHelper();
    function select(name) {
      if (name) {
        if (that2.onSearchBoxSelection) {
          that2.onSearchBoxSelection(name, event2, graphcanvas);
        } else {
          const extra = LiteGraph.searchbox_extras[name.toLowerCase()];
          if (extra)
            name = extra.type;
          graphcanvas.graph.beforeChange();
          const node22 = LiteGraph.createNode(name);
          if (node22) {
            node22.pos = graphcanvas.convertEventToCanvasOffset(
              event2
            );
            graphcanvas.graph.add(node22, false);
          }
          if (extra?.data) {
            if (extra.data.properties) {
              for (const i2 in extra.data.properties) {
                node22.addProperty(i2, extra.data.properties[i2]);
              }
            }
            if (extra.data.inputs) {
              node22.inputs = [];
              for (const i2 in extra.data.inputs) {
                node22.addOutput(
                  extra.data.inputs[i2][0],
                  extra.data.inputs[i2][1]
                );
              }
            }
            if (extra.data.outputs) {
              node22.outputs = [];
              for (const i2 in extra.data.outputs) {
                node22.addOutput(
                  extra.data.outputs[i2][0],
                  extra.data.outputs[i2][1]
                );
              }
            }
            if (extra.data.title) {
              node22.title = extra.data.title;
            }
            if (extra.data.json) {
              node22.configure(extra.data.json);
            }
          }
          if (options3.node_from) {
            let iS = false;
            switch (typeof options3.slot_from) {
              case "string":
                iS = options3.node_from.findOutputSlot(options3.slot_from);
                break;
              case "object":
                iS = options3.slot_from.name ? options3.node_from.findOutputSlot(options3.slot_from.name) : -1;
                if (iS == -1 && typeof options3.slot_from.slot_index !== "undefined") iS = options3.slot_from.slot_index;
                break;
              case "number":
                iS = options3.slot_from;
                break;
              default:
                iS = 0;
            }
            if (typeof options3.node_from.outputs[iS] !== "undefined") {
              if (iS !== false && iS > -1) {
                options3.node_from.connectByType(iS, node22, options3.node_from.outputs[iS].type);
              }
            }
          }
          if (options3.node_to) {
            let iS = false;
            switch (typeof options3.slot_from) {
              case "string":
                iS = options3.node_to.findInputSlot(options3.slot_from);
                break;
              case "object":
                iS = options3.slot_from.name ? options3.node_to.findInputSlot(options3.slot_from.name) : -1;
                if (iS == -1 && typeof options3.slot_from.slot_index !== "undefined") iS = options3.slot_from.slot_index;
                break;
              case "number":
                iS = options3.slot_from;
                break;
              default:
                iS = 0;
            }
            if (typeof options3.node_to.inputs[iS] !== "undefined") {
              if (iS !== false && iS > -1) {
                options3.node_to.connectByTypeOutput(iS, node22, options3.node_to.inputs[iS].type);
              }
            }
          }
          graphcanvas.graph.afterChange();
        }
      }
      dialog.close();
    }
    __name(select, "select");
    function changeSelection(forward) {
      const prev2 = selected2;
      if (!selected2) {
        selected2 = forward ? helper.childNodes[0] : helper.childNodes[helper.childNodes.length];
      } else {
        selected2.classList.remove("selected");
        selected2 = forward ? selected2.nextSibling : selected2.previousSibling;
        selected2 ||= prev2;
      }
      if (!selected2) return;
      selected2.classList.add("selected");
      selected2.scrollIntoView({ block: "end", behavior: "smooth" });
    }
    __name(changeSelection, "changeSelection");
    function refreshHelper() {
      timeout = null;
      let str = input.value;
      first = null;
      helper.innerHTML = "";
      if (!str && !options3.show_all_if_empty) return;
      if (that2.onSearchBox) {
        const list = that2.onSearchBox(helper, str, graphcanvas);
        if (list) {
          for (let i2 = 0; i2 < list.length; ++i2) {
            addResult(list[i2]);
          }
        }
      } else {
        let inner_test_filter = /* @__PURE__ */ __name(function(type, optsIn) {
          optsIn = optsIn || {};
          const optsDef = {
            skipFilter: false,
            inTypeOverride: false,
            outTypeOverride: false
          };
          const opts = Object.assign(optsDef, optsIn);
          const ctor = LiteGraph.registered_node_types[type];
          if (filter4 && ctor.filter != filter4)
            return false;
          if ((!options3.show_all_if_empty || str) && type.toLowerCase().indexOf(str) === -1 && (!ctor.title || ctor.title.toLowerCase().indexOf(str) === -1))
            return false;
          if (options3.do_type_filter && !opts.skipFilter) {
            const sType = type;
            let sV = opts.inTypeOverride !== false ? opts.inTypeOverride : sIn.value;
            if (sIn && sV && LiteGraph.registered_slot_in_types[sV]?.nodes) {
              const doesInc = LiteGraph.registered_slot_in_types[sV].nodes.includes(sType);
              if (doesInc === false) return false;
            }
            sV = sOut.value;
            if (opts.outTypeOverride !== false) sV = opts.outTypeOverride;
            if (sOut && sV && LiteGraph.registered_slot_out_types[sV]?.nodes) {
              const doesInc = LiteGraph.registered_slot_out_types[sV].nodes.includes(sType);
              if (doesInc === false) return false;
            }
          }
          return true;
        }, "inner_test_filter");
        let c = 0;
        str = str.toLowerCase();
        const filter4 = graphcanvas.filter || graphcanvas.graph.filter;
        let sIn = false;
        let sOut = false;
        if (options3.do_type_filter && that2.search_box) {
          sIn = that2.search_box.querySelector(".slot_in_type_filter");
          sOut = that2.search_box.querySelector(".slot_out_type_filter");
        }
        for (const i2 in LiteGraph.searchbox_extras) {
          const extra = LiteGraph.searchbox_extras[i2];
          if ((!options3.show_all_if_empty || str) && extra.desc.toLowerCase().indexOf(str) === -1)
            continue;
          const ctor = LiteGraph.registered_node_types[extra.type];
          if (ctor && ctor.filter != filter4)
            continue;
          if (!inner_test_filter(extra.type))
            continue;
          addResult(extra.desc, "searchbox_extra");
          if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {
            break;
          }
        }
        let filtered = null;
        if (Array.prototype.filter) {
          const keys2 = Object.keys(LiteGraph.registered_node_types);
          filtered = keys2.filter(inner_test_filter);
        } else {
          filtered = [];
          for (const i2 in LiteGraph.registered_node_types) {
            if (inner_test_filter(i2))
              filtered.push(i2);
          }
        }
        for (let i2 = 0; i2 < filtered.length; i2++) {
          addResult(filtered[i2]);
          if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)
            break;
        }
        if (options3.show_general_after_typefiltered && (sIn.value || sOut.value)) {
          filtered_extra = [];
          for (const i2 in LiteGraph.registered_node_types) {
            if (inner_test_filter(i2, { inTypeOverride: sIn && sIn.value ? "*" : false, outTypeOverride: sOut && sOut.value ? "*" : false }))
              filtered_extra.push(i2);
          }
          for (let i2 = 0; i2 < filtered_extra.length; i2++) {
            addResult(filtered_extra[i2], "generic_type");
            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)
              break;
          }
        }
        if ((sIn.value || sOut.value) && (helper.childNodes.length == 0 && options3.show_general_if_none_on_typefilter)) {
          filtered_extra = [];
          for (const i2 in LiteGraph.registered_node_types) {
            if (inner_test_filter(i2, { skipFilter: true }))
              filtered_extra.push(i2);
          }
          for (let i2 = 0; i2 < filtered_extra.length; i2++) {
            addResult(filtered_extra[i2], "not_in_filter");
            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)
              break;
          }
        }
      }
      function addResult(type, className) {
        const help = document.createElement("div");
        first ||= type;
        const nodeType = LiteGraph.registered_node_types[type];
        if (nodeType?.title) {
          help.innerText = nodeType?.title;
          const typeEl = document.createElement("span");
          typeEl.className = "litegraph lite-search-item-type";
          typeEl.textContent = type;
          help.append(typeEl);
        } else {
          help.innerText = type;
        }
        help.dataset["type"] = escape(type);
        help.className = "litegraph lite-search-item";
        if (className) {
          help.className += " " + className;
        }
        help.addEventListener("click", function() {
          select(unescape(this.dataset["type"]));
        });
        helper.appendChild(help);
      }
      __name(addResult, "addResult");
    }
    __name(refreshHelper, "refreshHelper");
    return dialog;
  }
  showEditPropertyValue(node22, property, options3) {
    if (!node22 || node22.properties[property] === void 0) return;
    options3 = options3 || {};
    const info = node22.getPropertyInfo(property);
    const type = info.type;
    let input_html = "";
    if (type == "string" || type == "number" || type == "array" || type == "object") {
      input_html = "<input autofocus type='text' class='value'/>";
    } else if ((type == "enum" || type == "combo") && info.values) {
      input_html = "<select autofocus type='text' class='value'>";
      for (const i2 in info.values) {
        const v2 = Array.isArray(info.values) ? info.values[i2] : i2;
        input_html += "<option value='" + v2 + "' " + (v2 == node22.properties[property] ? "selected" : "") + ">" + info.values[i2] + "</option>";
      }
      input_html += "</select>";
    } else if (type == "boolean" || type == "toggle") {
      input_html = "<input autofocus type='checkbox' class='value' " + (node22.properties[property] ? "checked" : "") + "/>";
    } else {
      console.warn("unknown type: " + type);
      return;
    }
    const dialog = this.createDialog(
      "<span class='name'>" + (info.label || property) + "</span>" + input_html + "<button>OK</button>",
      options3
    );
    let input;
    if ((type == "enum" || type == "combo") && info.values) {
      input = dialog.querySelector("select");
      input.addEventListener("change", function(e) {
        dialog.modified();
        setValue2(e.target?.value);
      });
    } else if (type == "boolean" || type == "toggle") {
      input = dialog.querySelector("input");
      input?.addEventListener("click", function() {
        dialog.modified();
        setValue2(!!input.checked);
      });
    } else {
      input = dialog.querySelector("input");
      if (input) {
        input.addEventListener("blur", function() {
          this.focus();
        });
        let v2 = node22.properties[property] !== void 0 ? node22.properties[property] : "";
        if (type !== "string") {
          v2 = JSON.stringify(v2);
        }
        input.value = v2;
        input.addEventListener("keydown", function(e) {
          if (e.keyCode == 27) {
            dialog.close();
          } else if (e.keyCode == 13) {
            inner();
          } else if (e.keyCode != 13) {
            dialog.modified();
            return;
          }
          e.preventDefault();
          e.stopPropagation();
        });
      }
    }
    input?.focus();
    const button = dialog.querySelector("button");
    button.addEventListener("click", inner);
    function inner() {
      setValue2(input.value);
    }
    __name(inner, "inner");
    function setValue2(value3) {
      if (info?.values && typeof info.values === "object" && info.values[value3] != void 0)
        value3 = info.values[value3];
      if (typeof node22.properties[property] == "number") {
        value3 = Number(value3);
      }
      if (type == "array" || type == "object") {
        value3 = JSON.parse(value3);
      }
      node22.properties[property] = value3;
      if (node22.graph) {
        node22.graph._version++;
      }
      node22.onPropertyChanged?.(property, value3);
      options3.onclose?.();
      dialog.close();
      this.setDirty(true, true);
    }
    __name(setValue2, "setValue");
    return dialog;
  }
  // TODO refactor, theer are different dialog, some uses createDialog, some dont
  createDialog(html, options3) {
    const def_options = { checkForInput: false, closeOnLeave: true, closeOnLeave_checkModified: true };
    options3 = Object.assign(def_options, options3 || {});
    const dialog = document.createElement("div");
    dialog.className = "graphdialog";
    dialog.innerHTML = html;
    dialog.is_modified = false;
    const rect = this.canvas.getBoundingClientRect();
    let offsetx = -20;
    let offsety = -20;
    if (rect) {
      offsetx -= rect.left;
      offsety -= rect.top;
    }
    if (options3.position) {
      offsetx += options3.position[0];
      offsety += options3.position[1];
    } else if (options3.event) {
      offsetx += options3.event.clientX;
      offsety += options3.event.clientY;
    } else {
      offsetx += this.canvas.width * 0.5;
      offsety += this.canvas.height * 0.5;
    }
    dialog.style.left = offsetx + "px";
    dialog.style.top = offsety + "px";
    this.canvas.parentNode.appendChild(dialog);
    if (options3.checkForInput) {
      const aI = dialog.querySelectorAll("input");
      aI?.forEach(function(iX) {
        iX.addEventListener("keydown", function(e) {
          dialog.modified();
          if (e.keyCode == 27) {
            dialog.close();
          } else if (e.keyCode != 13) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
        });
        iX.focus();
      });
    }
    dialog.modified = function() {
      dialog.is_modified = true;
    };
    dialog.close = function() {
      dialog.parentNode?.removeChild(dialog);
    };
    let dialogCloseTimer = null;
    let prevent_timeout = 0;
    dialog.addEventListener("mouseleave", function() {
      if (prevent_timeout)
        return;
      if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
        dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
    });
    dialog.addEventListener("mouseenter", function() {
      if (options3.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) {
        if (dialogCloseTimer) clearTimeout(dialogCloseTimer);
      }
    });
    const selInDia = dialog.querySelectorAll("select");
    selInDia?.forEach(function(selIn) {
      selIn.addEventListener("click", function() {
        prevent_timeout++;
      });
      selIn.addEventListener("blur", function() {
        prevent_timeout = 0;
      });
      selIn.addEventListener("change", function() {
        prevent_timeout = -1;
      });
    });
    return dialog;
  }
  createPanel(title, options3) {
    options3 = options3 || {};
    const ref_window2 = options3.window || window;
    const root23 = document.createElement("div");
    root23.className = "litegraph dialog";
    root23.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>";
    root23.header = root23.querySelector(".dialog-header");
    if (options3.width)
      root23.style.width = options3.width + (typeof options3.width === "number" ? "px" : "");
    if (options3.height)
      root23.style.height = options3.height + (typeof options3.height === "number" ? "px" : "");
    if (options3.closable) {
      const close4 = document.createElement("span");
      close4.innerHTML = "&#10005;";
      close4.classList.add("close");
      close4.addEventListener("click", function() {
        root23.close();
      });
      root23.header.appendChild(close4);
    }
    root23.title_element = root23.querySelector(".dialog-title");
    root23.title_element.innerText = title;
    root23.content = root23.querySelector(".dialog-content");
    root23.alt_content = root23.querySelector(".dialog-alt-content");
    root23.footer = root23.querySelector(".dialog-footer");
    root23.close = function() {
      if (typeof root23.onClose == "function") root23.onClose();
      root23.parentNode?.removeChild(root23);
      this.parentNode?.removeChild(this);
    };
    root23.toggleAltContent = function(force) {
      let vTo;
      let vAlt;
      if (typeof force != "undefined") {
        vTo = force ? "block" : "none";
        vAlt = force ? "none" : "block";
      } else {
        vTo = root23.alt_content.style.display != "block" ? "block" : "none";
        vAlt = root23.alt_content.style.display != "block" ? "none" : "block";
      }
      root23.alt_content.style.display = vTo;
      root23.content.style.display = vAlt;
    };
    root23.toggleFooterVisibility = function(force) {
      let vTo;
      if (typeof force != "undefined") {
        vTo = force ? "block" : "none";
      } else {
        vTo = root23.footer.style.display != "block" ? "block" : "none";
      }
      root23.footer.style.display = vTo;
    };
    root23.clear = function() {
      this.content.innerHTML = "";
    };
    root23.addHTML = function(code2, classname, on_footer) {
      const elem = document.createElement("div");
      if (classname)
        elem.className = classname;
      elem.innerHTML = code2;
      if (on_footer)
        root23.footer.appendChild(elem);
      else
        root23.content.appendChild(elem);
      return elem;
    };
    root23.addButton = function(name, callback, options22) {
      const elem = document.createElement("button");
      elem.innerText = name;
      elem.options = options22;
      elem.classList.add("btn");
      elem.addEventListener("click", callback);
      root23.footer.appendChild(elem);
      return elem;
    };
    root23.addSeparator = function() {
      const elem = document.createElement("div");
      elem.className = "separator";
      root23.content.appendChild(elem);
    };
    root23.addWidget = function(type, name, value3, options22, callback) {
      options22 = options22 || {};
      let str_value = String(value3);
      type = type.toLowerCase();
      if (type == "number")
        str_value = value3.toFixed(3);
      const elem = document.createElement("div");
      elem.className = "property";
      elem.innerHTML = "<span class='property_name'></span><span class='property_value'></span>";
      elem.querySelector(".property_name").innerText = options22.label || name;
      const value_element = elem.querySelector(".property_value");
      value_element.innerText = str_value;
      elem.dataset["property"] = name;
      elem.dataset["type"] = options22.type || type;
      elem.options = options22;
      elem.value = value3;
      if (type == "code")
        elem.addEventListener("click", function() {
          root23.inner_showCodePad(this.dataset["property"]);
        });
      else if (type == "boolean") {
        elem.classList.add("boolean");
        if (value3)
          elem.classList.add("bool-on");
        elem.addEventListener("click", function() {
          const propname = this.dataset["property"];
          this.value = !this.value;
          this.classList.toggle("bool-on");
          this.querySelector(".property_value").innerText = this.value ? "true" : "false";
          innerChange(propname, this.value);
        });
      } else if (type == "string" || type == "number") {
        value_element.setAttribute("contenteditable", true);
        value_element.addEventListener("keydown", function(e) {
          if (e.code == "Enter" && (type != "string" || !e.shiftKey)) {
            e.preventDefault();
            this.blur();
          }
        });
        value_element.addEventListener("blur", function() {
          let v2 = this.innerText;
          const propname = this.parentNode.dataset["property"];
          const proptype = this.parentNode.dataset["type"];
          if (proptype == "number")
            v2 = Number(v2);
          innerChange(propname, v2);
        });
      } else if (type == "enum" || type == "combo") {
        const str_value2 = LGraphCanvas.getPropertyPrintableValue(value3, options22.values);
        value_element.innerText = str_value2;
        value_element.addEventListener("click", function(event2) {
          const values2 = options22.values || [];
          const propname = this.parentNode.dataset["property"];
          const elem_that = this;
          new LiteGraph.ContextMenu(
            values2,
            {
              event: event2,
              className: "dark",
              callback: inner_clicked
            },
            // @ts-expect-error
            ref_window2
          );
          function inner_clicked(v2) {
            elem_that.innerText = v2;
            innerChange(propname, v2);
            return false;
          }
          __name(inner_clicked, "inner_clicked");
        });
      }
      root23.content.appendChild(elem);
      function innerChange(name2, value22) {
        options22.callback?.(name2, value22, options22);
        callback?.(name2, value22, options22);
      }
      __name(innerChange, "innerChange");
      return elem;
    };
    if (root23.onOpen && typeof root23.onOpen == "function") root23.onOpen();
    return root23;
  }
  closePanels() {
    document.querySelector("#node-panel")?.close();
    document.querySelector("#option-panel")?.close();
  }
  showShowNodePanel(node22) {
    this.SELECTED_NODE = node22;
    this.closePanels();
    const ref_window2 = this.getCanvasWindow();
    const graphcanvas = this;
    const panel2 = this.createPanel(node22.title || "", {
      closable: true,
      window: ref_window2,
      onOpen: /* @__PURE__ */ __name(function() {
        graphcanvas.NODEPANEL_IS_OPEN = true;
      }, "onOpen"),
      onClose: /* @__PURE__ */ __name(function() {
        graphcanvas.NODEPANEL_IS_OPEN = false;
        graphcanvas.node_panel = null;
      }, "onClose")
    });
    graphcanvas.node_panel = panel2;
    panel2.id = "node-panel";
    panel2.node = node22;
    panel2.classList.add("settings");
    function inner_refresh() {
      panel2.content.innerHTML = "";
      panel2.addHTML(`<span class='node_type'>${node22.type}</span><span class='node_desc'>${node22.constructor.desc || ""}</span><span class='separator'></span>`);
      panel2.addHTML("<h3>Properties</h3>");
      const fUpdate = /* @__PURE__ */ __name(function(name, value3) {
        graphcanvas.graph.beforeChange(node22);
        switch (name) {
          case "Title":
            node22.title = value3;
            break;
          case "Mode": {
            const kV = Object.values(LiteGraph.NODE_MODES).indexOf(value3);
            if (kV >= 0 && LiteGraph.NODE_MODES[kV]) {
              node22.changeMode(kV);
            } else {
              console.warn("unexpected mode: " + value3);
            }
            break;
          }
          case "Color":
            if (LGraphCanvas.node_colors[value3]) {
              node22.color = LGraphCanvas.node_colors[value3].color;
              node22.bgcolor = LGraphCanvas.node_colors[value3].bgcolor;
            } else {
              console.warn("unexpected color: " + value3);
            }
            break;
          default:
            node22.setProperty(name, value3);
            break;
        }
        graphcanvas.graph.afterChange();
        graphcanvas.dirty_canvas = true;
      }, "fUpdate");
      panel2.addWidget("string", "Title", node22.title, {}, fUpdate);
      panel2.addWidget("combo", "Mode", LiteGraph.NODE_MODES[node22.mode], { values: LiteGraph.NODE_MODES }, fUpdate);
      const nodeCol = node22.color !== void 0 ? Object.keys(LGraphCanvas.node_colors).filter(function(nK) {
        return LGraphCanvas.node_colors[nK].color == node22.color;
      }) : "";
      panel2.addWidget("combo", "Color", nodeCol, { values: Object.keys(LGraphCanvas.node_colors) }, fUpdate);
      for (const pName in node22.properties) {
        const value3 = node22.properties[pName];
        const info = node22.getPropertyInfo(pName);
        if (node22.onAddPropertyToPanel?.(pName, panel2))
          continue;
        panel2.addWidget(info.widget || info.type, pName, value3, info, fUpdate);
      }
      panel2.addSeparator();
      node22.onShowCustomPanelInfo?.(panel2);
      panel2.footer.innerHTML = "";
      panel2.addButton("Delete", function() {
        if (node22.block_delete)
          return;
        node22.graph.remove(node22);
        panel2.close();
      }).classList.add("delete");
    }
    __name(inner_refresh, "inner_refresh");
    panel2.inner_showCodePad = function(propname) {
      panel2.classList.remove("settings");
      panel2.classList.add("centered");
      panel2.alt_content.innerHTML = "<textarea class='code'></textarea>";
      const textarea = panel2.alt_content.querySelector("textarea");
      const fDoneWith = /* @__PURE__ */ __name(function() {
        panel2.toggleAltContent(false);
        panel2.toggleFooterVisibility(true);
        textarea.parentNode.removeChild(textarea);
        panel2.classList.add("settings");
        panel2.classList.remove("centered");
        inner_refresh();
      }, "fDoneWith");
      textarea.value = node22.properties[propname];
      textarea.addEventListener("keydown", function(e) {
        if (e.code == "Enter" && e.ctrlKey) {
          node22.setProperty(propname, textarea.value);
          fDoneWith();
        }
      });
      panel2.toggleAltContent(true);
      panel2.toggleFooterVisibility(false);
      textarea.style.height = "calc(100% - 40px)";
      const assign2 = panel2.addButton("Assign", function() {
        node22.setProperty(propname, textarea.value);
        fDoneWith();
      });
      panel2.alt_content.appendChild(assign2);
      const button = panel2.addButton("Close", fDoneWith);
      button.style.float = "right";
      panel2.alt_content.appendChild(button);
    };
    inner_refresh();
    this.canvas.parentNode.appendChild(panel2);
  }
  showSubgraphPropertiesDialog(node22) {
    console.log("showing subgraph properties dialog");
    const old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
    old_panel?.close();
    const panel2 = this.createPanel("Subgraph Inputs", { closable: true, width: 500 });
    panel2.node = node22;
    panel2.classList.add("subgraph_dialog");
    function inner_refresh() {
      panel2.clear();
      if (node22.inputs)
        for (let i2 = 0; i2 < node22.inputs.length; ++i2) {
          const input = node22.inputs[i2];
          if (input.not_subgraph_input)
            continue;
          const html2 = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
          const elem2 = panel2.addHTML(html2, "subgraph_property");
          elem2.dataset["name"] = input.name;
          elem2.dataset["slot"] = i2;
          elem2.querySelector(".name").innerText = input.name;
          elem2.querySelector(".type").innerText = input.type;
          elem2.querySelector("button").addEventListener("click", function() {
            node22.removeInput(Number(this.parentNode.dataset["slot"]));
            inner_refresh();
          });
        }
    }
    __name(inner_refresh, "inner_refresh");
    const html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
    const elem = panel2.addHTML(html, "subgraph_property extra", true);
    elem.querySelector("button").addEventListener("click", function() {
      const elem2 = this.parentNode;
      const name = elem2.querySelector(".name").value;
      const type = elem2.querySelector(".type").value;
      if (!name || node22.findInputSlot(name) != -1)
        return;
      node22.addInput(name, type);
      elem2.querySelector(".name").value = "";
      elem2.querySelector(".type").value = "";
      inner_refresh();
    });
    inner_refresh();
    this.canvas.parentNode.appendChild(panel2);
    return panel2;
  }
  showSubgraphPropertiesDialogRight(node22) {
    const old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
    old_panel?.close();
    const panel2 = this.createPanel("Subgraph Outputs", { closable: true, width: 500 });
    panel2.node = node22;
    panel2.classList.add("subgraph_dialog");
    function inner_refresh() {
      panel2.clear();
      if (node22.outputs)
        for (let i2 = 0; i2 < node22.outputs.length; ++i2) {
          const input = node22.outputs[i2];
          if (input.not_subgraph_output)
            continue;
          const html2 = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
          const elem2 = panel2.addHTML(html2, "subgraph_property");
          elem2.dataset["name"] = input.name;
          elem2.dataset["slot"] = i2;
          elem2.querySelector(".name").innerText = input.name;
          elem2.querySelector(".type").innerText = input.type;
          elem2.querySelector("button").addEventListener("click", function() {
            node22.removeOutput(Number(this.parentNode.dataset["slot"]));
            inner_refresh();
          });
        }
    }
    __name(inner_refresh, "inner_refresh");
    const html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
    const elem = panel2.addHTML(html, "subgraph_property extra", true);
    elem.querySelector(".name").addEventListener("keydown", function(e) {
      if (e.keyCode == 13) addOutput.apply(this);
    });
    elem.querySelector("button").addEventListener("click", function() {
      addOutput.apply(this);
    });
    function addOutput() {
      const elem2 = this.parentNode;
      const name = elem2.querySelector(".name").value;
      const type = elem2.querySelector(".type").value;
      if (!name || node22.findOutputSlot(name) != -1)
        return;
      node22.addOutput(name, type);
      elem2.querySelector(".name").value = "";
      elem2.querySelector(".type").value = "";
      inner_refresh();
    }
    __name(addOutput, "addOutput");
    inner_refresh();
    this.canvas.parentNode.appendChild(panel2);
    return panel2;
  }
  checkPanels() {
    if (!this.canvas) return;
    const panels = this.canvas.parentNode.querySelectorAll(".litegraph.dialog");
    for (let i2 = 0; i2 < panels.length; ++i2) {
      const panel2 = panels[i2];
      if (!panel2.node) continue;
      if (!panel2.node.graph || panel2.graph != this.graph) panel2.close();
    }
  }
  getCanvasMenuOptions() {
    let options3 = null;
    if (this.getMenuOptions) {
      options3 = this.getMenuOptions();
    } else {
      options3 = [
        {
          content: "Add Node",
          has_submenu: true,
          // @ts-expect-error Might be broken?  Or just param overlap
          callback: LGraphCanvas.onMenuAdd
        },
        { content: "Add Group", callback: LGraphCanvas.onGroupAdd }
        //{ content: "Arrange", callback: that.graph.arrange },
        //{content:"Collapse All", callback: LGraphCanvas.onMenuCollapseAll }
      ];
      if (Object.keys(this.selected_nodes).length > 1) {
        options3.push({
          content: "Align",
          has_submenu: true,
          callback: LGraphCanvas.onGroupAlign
        });
      }
      if (this._graph_stack && this._graph_stack.length > 0) {
        options3.push(null, {
          content: "Close subgraph",
          callback: this.closeSubgraph.bind(this)
        });
      }
    }
    const extra = this.getExtraMenuOptions?.(this, options3);
    return extra ? options3.concat(extra) : options3;
  }
  //called by processContextMenu to extract the menu list
  getNodeMenuOptions(node22) {
    let options3 = null;
    if (node22.getMenuOptions) {
      options3 = node22.getMenuOptions(this);
    } else {
      options3 = [
        {
          content: "Inputs",
          has_submenu: true,
          disabled: true,
          callback: LGraphCanvas.showMenuNodeOptionalInputs
        },
        {
          content: "Outputs",
          has_submenu: true,
          disabled: true,
          callback: LGraphCanvas.showMenuNodeOptionalOutputs
        },
        null,
        {
          content: "Properties",
          has_submenu: true,
          callback: LGraphCanvas.onShowMenuNodeProperties
        },
        {
          content: "Properties Panel",
          callback: /* @__PURE__ */ __name(function(item2, options22, e, menu, node3) {
            LGraphCanvas.active_canvas.showShowNodePanel(node3);
          }, "callback")
        },
        null,
        {
          content: "Title",
          callback: LGraphCanvas.onShowPropertyEditor
        },
        {
          content: "Mode",
          has_submenu: true,
          callback: LGraphCanvas.onMenuNodeMode
        }
      ];
      if (node22.resizable !== false) {
        options3.push({
          content: "Resize",
          callback: LGraphCanvas.onMenuResizeNode
        });
      }
      if (node22.collapsible) {
        options3.push({
          content: node22.collapsed ? "Expand" : "Collapse",
          callback: LGraphCanvas.onMenuNodeCollapse
        });
      }
      if (node22.widgets?.some((w2) => w2.advanced)) {
        options3.push({
          content: node22.showAdvanced ? "Hide Advanced" : "Show Advanced",
          callback: LGraphCanvas.onMenuToggleAdvanced
        });
      }
      options3.push(
        {
          content: node22.pinned ? "Unpin" : "Pin",
          callback: /* @__PURE__ */ __name((...args) => {
            LGraphCanvas.onMenuNodePin(...args);
            for (const i2 in this.selected_nodes) {
              const node3 = this.selected_nodes[i2];
              node3.pin();
            }
            this.setDirty(true, true);
          }, "callback")
        },
        {
          content: "Colors",
          has_submenu: true,
          callback: LGraphCanvas.onMenuNodeColors
        },
        {
          content: "Shapes",
          has_submenu: true,
          callback: LGraphCanvas.onMenuNodeShapes
        },
        null
      );
    }
    const inputs = node22.onGetInputs?.();
    if (inputs?.length)
      options3[0].disabled = false;
    const outputs = node22.onGetOutputs?.();
    if (outputs?.length)
      options3[1].disabled = false;
    const extra = node22.getExtraMenuOptions?.(this, options3);
    if (extra) {
      extra.push(null);
      options3 = extra.concat(options3);
    }
    if (node22.clonable !== false) {
      options3.push({
        content: "Clone",
        callback: LGraphCanvas.onMenuNodeClone
      });
    }
    if (Object.keys(this.selected_nodes).length > 1) {
      options3.push({
        content: "Align Selected To",
        has_submenu: true,
        callback: LGraphCanvas.onNodeAlign
      });
      options3.push({
        content: "Distribute Nodes",
        has_submenu: true,
        callback: LGraphCanvas.createDistributeMenu
      });
    }
    options3.push(null, {
      content: "Remove",
      disabled: !(node22.removable !== false && !node22.block_delete),
      callback: LGraphCanvas.onMenuNodeRemove
    });
    node22.graph?.onGetNodeMenuOptions?.(options3, node22);
    return options3;
  }
  getGroupMenuOptions(group) {
    console.warn("LGraphCanvas.getGroupMenuOptions is deprecated, use LGraphGroup.getMenuOptions instead");
    return group.getMenuOptions();
  }
  processContextMenu(node22, event2) {
    const that2 = this;
    const canvas = LGraphCanvas.active_canvas;
    const ref_window2 = canvas.getCanvasWindow();
    let menu_info = null;
    const options3 = {
      event: event2,
      callback: inner_option_clicked,
      extra: node22
    };
    if (node22) options3.title = node22.type;
    let slot = null;
    if (node22) {
      slot = node22.getSlotInPosition(event2.canvasX, event2.canvasY);
      LGraphCanvas.active_node = node22;
    }
    if (slot) {
      menu_info = [];
      if (node22.getSlotMenuOptions) {
        menu_info = node22.getSlotMenuOptions(slot);
      } else {
        if (slot?.output?.links?.length)
          menu_info.push({ content: "Disconnect Links", slot });
        const _slot = slot.input || slot.output;
        if (_slot.removable) {
          menu_info.push(
            _slot.locked ? "Cannot remove" : { content: "Remove Slot", slot }
          );
        }
        if (!_slot.nameLocked)
          menu_info.push({ content: "Rename Slot", slot });
      }
      options3.title = (slot.input ? slot.input.type : slot.output.type) || "*";
      if (slot.input && slot.input.type == LiteGraph.ACTION)
        options3.title = "Action";
      if (slot.output && slot.output.type == LiteGraph.EVENT)
        options3.title = "Event";
    } else if (node22) {
      menu_info = this.getNodeMenuOptions(node22);
    } else {
      menu_info = this.getCanvasMenuOptions();
      if (this.reroutesEnabled) {
        const reroute = this.graph.getRerouteOnPos(event2.canvasX, event2.canvasY);
        if (reroute) {
          menu_info.unshift({
            content: "Delete Reroute",
            callback: /* @__PURE__ */ __name(() => this.graph.removeReroute(reroute.id), "callback")
          }, null);
        }
      }
      const group = this.graph.getGroupOnPos(
        event2.canvasX,
        event2.canvasY
      );
      if (group) {
        menu_info.push(null, {
          content: "Edit Group",
          has_submenu: true,
          submenu: {
            title: "Group",
            extra: group,
            options: group.getMenuOptions()
          }
        });
      }
    }
    if (!menu_info)
      return;
    new LiteGraph.ContextMenu(menu_info, options3, ref_window2);
    function inner_option_clicked(v2, options22) {
      if (!v2) return;
      if (v2.content == "Remove Slot") {
        const info = v2.slot;
        node22.graph.beforeChange();
        if (info.input) {
          node22.removeInput(info.slot);
        } else if (info.output) {
          node22.removeOutput(info.slot);
        }
        node22.graph.afterChange();
        return;
      } else if (v2.content == "Disconnect Links") {
        const info = v2.slot;
        node22.graph.beforeChange();
        if (info.output) {
          node22.disconnectOutput(info.slot);
        } else if (info.input) {
          node22.disconnectInput(info.slot);
        }
        node22.graph.afterChange();
        return;
      } else if (v2.content == "Rename Slot") {
        const info = v2.slot;
        const slot_info = info.input ? node22.getInputInfo(info.slot) : node22.getOutputInfo(info.slot);
        const dialog = that2.createDialog(
          "<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>",
          options22
        );
        const input = dialog.querySelector("input");
        if (input && slot_info) {
          input.value = slot_info.label || "";
        }
        const inner = /* @__PURE__ */ __name(function() {
          node22.graph.beforeChange();
          if (input.value) {
            if (slot_info) {
              slot_info.label = input.value;
            }
            that2.setDirty(true);
          }
          dialog.close();
          node22.graph.afterChange();
        }, "inner");
        dialog.querySelector("button").addEventListener("click", inner);
        input.addEventListener("keydown", function(e) {
          dialog.is_modified = true;
          if (e.keyCode == 27) {
            dialog.close();
          } else if (e.keyCode == 13) {
            inner();
          } else if (e.keyCode != 13 && e.target.localName != "textarea") {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
        });
        input.focus();
      }
    }
    __name(inner_option_clicked, "inner_option_clicked");
  }
  /**
   * Starts an animation to fit the view around the specified selection of nodes.
   * @param bounds The bounds to animate the view to, defined by a rectangle.
   * @param animationParameters Various parameters for the camera movement animation.
   */
  animateToBounds(bounds, {
    duration = 350,
    zoom = 0.75,
    easing = EaseFunction.EASE_IN_OUT_QUAD
  } = {}) {
    const easeFunctions = {
      linear: /* @__PURE__ */ __name((t) => t, "linear"),
      easeInQuad: /* @__PURE__ */ __name((t) => t * t, "easeInQuad"),
      easeOutQuad: /* @__PURE__ */ __name((t) => t * (2 - t), "easeOutQuad"),
      easeInOutQuad: /* @__PURE__ */ __name((t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t, "easeInOutQuad")
    };
    const easeFunction = easeFunctions[easing] ?? easeFunctions.linear;
    let animationId = null;
    const startTimestamp = performance.now();
    const startX = this.ds.offset[0];
    const startY = this.ds.offset[1];
    const startScale = this.ds.scale;
    const cw = this.canvas.width / window.devicePixelRatio;
    const ch = this.canvas.height / window.devicePixelRatio;
    let targetScale = startScale;
    let targetX = startX;
    let targetY = startY;
    if (zoom > 0) {
      const targetScaleX = zoom * cw / Math.max(bounds[2], 300);
      const targetScaleY = zoom * ch / Math.max(bounds[3], 300);
      targetScale = Math.min(targetScaleX, targetScaleY, this.ds.max_scale);
    }
    targetX = -bounds[0] - bounds[2] * 0.5 + cw * 0.5 / targetScale;
    targetY = -bounds[1] - bounds[3] * 0.5 + ch * 0.5 / targetScale;
    const animate = /* @__PURE__ */ __name((timestamp2) => {
      const elapsed = timestamp2 - startTimestamp;
      const progress = Math.min(elapsed / duration, 1);
      const easedProgress = easeFunction(progress);
      this.ds.offset[0] = startX + (targetX - startX) * easedProgress;
      this.ds.offset[1] = startY + (targetY - startY) * easedProgress;
      if (zoom > 0) {
        this.ds.scale = startScale + (targetScale - startScale) * easedProgress;
      }
      this.setDirty(true, true);
      if (progress < 1) {
        animationId = requestAnimationFrame(animate);
      } else {
        cancelAnimationFrame(animationId);
      }
    }, "animate");
    animationId = requestAnimationFrame(animate);
  }
  /**
   * Fits the view to the selected nodes with animation.
   * If nothing is selected, the view is fitted around all items in the graph.
   */
  fitViewToSelectionAnimated(options3 = {}) {
    const items2 = this.selectedItems.size ? Array.from(this.selectedItems) : this.positionableItems;
    this.animateToBounds(createBounds(items2), options3);
  }
}
class MapProxyHandler {
  static {
    __name(this, "MapProxyHandler");
  }
  getOwnPropertyDescriptor(target, p2) {
    const value3 = this.get(target, p2);
    if (value3) return {
      configurable: true,
      enumerable: true,
      value: value3
    };
  }
  has(target, p2) {
    if (typeof p2 === "symbol") return false;
    const int = parseInt(p2, 10);
    return target.has(!isNaN(int) ? int : p2);
  }
  ownKeys(target) {
    return [...target.keys()].map((x2) => String(x2));
  }
  get(target, p2) {
    if (p2 in target) return Reflect.get(target, p2, target);
    if (typeof p2 === "symbol") return;
    const int = parseInt(p2, 10);
    return target.get(!isNaN(int) ? int : p2);
  }
  set(target, p2, newValue) {
    if (typeof p2 === "symbol") return false;
    const int = parseInt(p2, 10);
    target.set(!isNaN(int) ? int : p2, newValue);
    return true;
  }
  deleteProperty(target, p2) {
    return target.delete(p2);
  }
  static bindAllMethods(map2) {
    map2.clear = map2.clear.bind(map2);
    map2.delete = map2.delete.bind(map2);
    map2.forEach = map2.forEach.bind(map2);
    map2.get = map2.get.bind(map2);
    map2.has = map2.has.bind(map2);
    map2.set = map2.set.bind(map2);
    map2.entries = map2.entries.bind(map2);
    map2.keys = map2.keys.bind(map2);
    map2.values = map2.values.bind(map2);
  }
}
let LGraph$1 = class LGraph2 {
  static {
    __name(this, "LGraph");
  }
  static serialisedSchemaVersion = 1;
  //default supported types
  static supported_types = ["number", "string", "boolean"];
  static STATUS_STOPPED = 1;
  static STATUS_RUNNING = 2;
  _version;
  /** The backing store for links.  Keys are wrapped in String() */
  _links = /* @__PURE__ */ new Map();
  /**
   * Indexed property access is deprecated.
   * Backwards compatibility with a Proxy has been added, but will eventually be removed.
   * 
   * Use {@link Map} methods:
   * ```
   * const linkId = 123
   * const link = graph.links.get(linkId)
   * // Deprecated: const link = graph.links[linkId]
   * ```
   */
  links;
  list_of_graphcanvas;
  status;
  state;
  _nodes;
  _nodes_by_id;
  _nodes_in_order;
  _nodes_executable;
  _groups;
  iteration;
  globaltime;
  runningtime;
  fixedtime;
  fixedtime_lapse;
  elapsed_time;
  last_update_time;
  starttime;
  catch_errors;
  execution_timer_id;
  errors_in_execution;
  execution_time;
  _last_trigger_time;
  filter;
  _subgraph_node;
  /** Must contain serialisable values, e.g. primitive types */
  config;
  vars;
  nodes_executing;
  nodes_actioning;
  nodes_executedAction;
  extra;
  inputs;
  outputs;
  #reroutes = /* @__PURE__ */ new Map();
  /** All reroutes in this graph. */
  get reroutes() {
    return this.#reroutes;
  }
  set reroutes(value3) {
    if (!value3) throw new TypeError("Attempted to set LGraph.reroutes to a falsy value.");
    const reroutes = this.#reroutes;
    if (value3.size === 0) {
      reroutes.clear();
      return;
    }
    for (const rerouteId of reroutes.keys()) {
      if (!value3.has(rerouteId)) reroutes.delete(rerouteId);
    }
    for (const [id3, reroute] of value3) {
      reroutes.set(id3, reroute);
    }
  }
  /** @deprecated See {@link state}.{@link LGraphState.lastNodeId lastNodeId} */
  get last_node_id() {
    return this.state.lastNodeId;
  }
  set last_node_id(value3) {
    this.state.lastNodeId = value3;
  }
  /** @deprecated See {@link state}.{@link LGraphState.lastLinkId lastLinkId} */
  get last_link_id() {
    return this.state.lastLinkId;
  }
  set last_link_id(value3) {
    this.state.lastLinkId = value3;
  }
  _input_nodes;
  /**
   * See {@link LGraph}
   * @param o data from previous serialization [optional]
   */
  constructor(o) {
    if (LiteGraph.debug) console.log("Graph created");
    const links = this._links;
    MapProxyHandler.bindAllMethods(links);
    const handler6 = new MapProxyHandler();
    this.links = new Proxy(links, handler6);
    this.list_of_graphcanvas = null;
    this.clear();
    if (o) this.configure(o);
  }
  // TODO: Remove
  //used to know which types of connections support this graph (some graphs do not allow certain types)
  getSupportedTypes() {
    return this.supported_types || LGraph2.supported_types;
  }
  /**
   * Removes all nodes from this graph
   */
  clear() {
    this.stop();
    this.status = LGraph2.STATUS_STOPPED;
    this.state = {
      lastGroupId: 0,
      lastNodeId: 0,
      lastLinkId: 0,
      lastRerouteId: 0
    };
    this._version = -1;
    if (this._nodes) {
      for (let i2 = 0; i2 < this._nodes.length; ++i2) {
        this._nodes[i2].onRemoved?.();
      }
    }
    this._nodes = [];
    this._nodes_by_id = {};
    this._nodes_in_order = [];
    this._nodes_executable = null;
    this._links.clear();
    this.reroutes.clear();
    this._groups = [];
    this.iteration = 0;
    this.config = {};
    this.vars = {};
    this.extra = {};
    this.globaltime = 0;
    this.runningtime = 0;
    this.fixedtime = 0;
    this.fixedtime_lapse = 0.01;
    this.elapsed_time = 0.01;
    this.last_update_time = 0;
    this.starttime = 0;
    this.catch_errors = true;
    this.nodes_executing = [];
    this.nodes_actioning = [];
    this.nodes_executedAction = [];
    this.inputs = {};
    this.outputs = {};
    this.change();
    this.canvasAction((c) => c.clear());
  }
  get nodes() {
    return this._nodes;
  }
  get groups() {
    return this._groups;
  }
  /**
   * Attach Canvas to this graph
   * @param {GraphCanvas} graph_canvas
   */
  attachCanvas(graphcanvas) {
    if (graphcanvas.constructor != LGraphCanvas)
      throw "attachCanvas expects a LGraphCanvas instance";
    if (graphcanvas.graph != this)
      graphcanvas.graph?.detachCanvas(graphcanvas);
    graphcanvas.graph = this;
    this.list_of_graphcanvas ||= [];
    this.list_of_graphcanvas.push(graphcanvas);
  }
  /**
   * Detach Canvas from this graph
   * @param {GraphCanvas} graph_canvas
   */
  detachCanvas(graphcanvas) {
    if (!this.list_of_graphcanvas) return;
    const pos2 = this.list_of_graphcanvas.indexOf(graphcanvas);
    if (pos2 == -1) return;
    graphcanvas.graph = null;
    this.list_of_graphcanvas.splice(pos2, 1);
  }
  /**
   * Starts running this graph every interval milliseconds.
   * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate
   */
  start(interval) {
    if (this.status == LGraph2.STATUS_RUNNING) return;
    this.status = LGraph2.STATUS_RUNNING;
    this.onPlayEvent?.();
    this.sendEventToAllNodes("onStart");
    this.starttime = LiteGraph.getTime();
    this.last_update_time = this.starttime;
    interval ||= 0;
    const that2 = this;
    if (interval == 0 && typeof window != "undefined" && window.requestAnimationFrame) {
      let on_frame = /* @__PURE__ */ __name(function() {
        if (that2.execution_timer_id != -1) return;
        window.requestAnimationFrame(on_frame);
        that2.onBeforeStep?.();
        that2.runStep(1, !that2.catch_errors);
        that2.onAfterStep?.();
      }, "on_frame");
      this.execution_timer_id = -1;
      on_frame();
    } else {
      this.execution_timer_id = setInterval(function() {
        that2.onBeforeStep?.();
        that2.runStep(1, !that2.catch_errors);
        that2.onAfterStep?.();
      }, interval);
    }
  }
  /**
   * Stops the execution loop of the graph
   */
  stop() {
    if (this.status == LGraph2.STATUS_STOPPED) return;
    this.status = LGraph2.STATUS_STOPPED;
    this.onStopEvent?.();
    if (this.execution_timer_id != null) {
      if (this.execution_timer_id != -1) {
        clearInterval(this.execution_timer_id);
      }
      this.execution_timer_id = null;
    }
    this.sendEventToAllNodes("onStop");
  }
  /**
   * Run N steps (cycles) of the graph
   * @param {number} num number of steps to run, default is 1
   * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors
   * @param {number} limit max number of nodes to execute (used to execute from start to a node)
   */
  runStep(num, do_not_catch_errors, limit) {
    num = num || 1;
    const start2 = LiteGraph.getTime();
    this.globaltime = 1e-3 * (start2 - this.starttime);
    const nodes = this._nodes_executable ? this._nodes_executable : this._nodes;
    if (!nodes) return;
    limit = limit || nodes.length;
    if (do_not_catch_errors) {
      for (let i2 = 0; i2 < num; i2++) {
        for (let j = 0; j < limit; ++j) {
          const node22 = nodes[j];
          if (node22.mode == LGraphEventMode.ALWAYS && node22.onExecute) {
            node22.doExecute?.();
          }
        }
        this.fixedtime += this.fixedtime_lapse;
        this.onExecuteStep?.();
      }
      this.onAfterExecute?.();
    } else {
      try {
        for (let i2 = 0; i2 < num; i2++) {
          for (let j = 0; j < limit; ++j) {
            const node22 = nodes[j];
            if (node22.mode == LGraphEventMode.ALWAYS) {
              node22.onExecute?.();
            }
          }
          this.fixedtime += this.fixedtime_lapse;
          this.onExecuteStep?.();
        }
        this.onAfterExecute?.();
        this.errors_in_execution = false;
      } catch (err) {
        this.errors_in_execution = true;
        if (LiteGraph.throw_errors) throw err;
        if (LiteGraph.debug) console.log("Error during execution: " + err);
        this.stop();
      }
    }
    const now2 = LiteGraph.getTime();
    let elapsed = now2 - start2;
    if (elapsed == 0) elapsed = 1;
    this.execution_time = 1e-3 * elapsed;
    this.globaltime += 1e-3 * elapsed;
    this.iteration += 1;
    this.elapsed_time = (now2 - this.last_update_time) * 1e-3;
    this.last_update_time = now2;
    this.nodes_executing = [];
    this.nodes_actioning = [];
    this.nodes_executedAction = [];
  }
  /**
   * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than
   * nodes with only inputs.
   */
  updateExecutionOrder() {
    this._nodes_in_order = this.computeExecutionOrder(false);
    this._nodes_executable = [];
    for (let i2 = 0; i2 < this._nodes_in_order.length; ++i2) {
      if (this._nodes_in_order[i2].onExecute) {
        this._nodes_executable.push(this._nodes_in_order[i2]);
      }
    }
  }
  //This is more internal, it computes the executable nodes in order and returns it
  computeExecutionOrder(only_onExecute, set_level) {
    const L = [];
    const S = [];
    const M = {};
    const visited_links = {};
    const remaining_links = {};
    for (let i2 = 0, l2 = this._nodes.length; i2 < l2; ++i2) {
      const node22 = this._nodes[i2];
      if (only_onExecute && !node22.onExecute) {
        continue;
      }
      M[node22.id] = node22;
      let num = 0;
      if (node22.inputs) {
        for (let j = 0, l22 = node22.inputs.length; j < l22; j++) {
          if (node22.inputs[j]?.link != null) {
            num += 1;
          }
        }
      }
      if (num == 0) {
        S.push(node22);
        if (set_level) node22._level = 1;
      } else {
        if (set_level) node22._level = 0;
        remaining_links[node22.id] = num;
      }
    }
    while (true) {
      const node22 = S.shift();
      if (node22 === void 0) break;
      L.push(node22);
      delete M[node22.id];
      if (!node22.outputs) continue;
      for (let i2 = 0; i2 < node22.outputs.length; i2++) {
        const output = node22.outputs[i2];
        if (output?.links == null || output.links.length == 0)
          continue;
        for (let j = 0; j < output.links.length; j++) {
          const link_id = output.links[j];
          const link = this._links.get(link_id);
          if (!link) continue;
          if (visited_links[link.id]) continue;
          const target_node = this.getNodeById(link.target_id);
          if (target_node == null) {
            visited_links[link.id] = true;
            continue;
          }
          if (set_level && (!target_node._level || target_node._level <= node22._level)) {
            target_node._level = node22._level + 1;
          }
          visited_links[link.id] = true;
          remaining_links[target_node.id] -= 1;
          if (remaining_links[target_node.id] == 0) S.push(target_node);
        }
      }
    }
    for (const i2 in M) {
      L.push(M[i2]);
    }
    if (L.length != this._nodes.length && LiteGraph.debug)
      console.warn("something went wrong, nodes missing");
    L.length;
    function setOrder(nodes) {
      const l2 = nodes.length;
      for (let i2 = 0; i2 < l2; ++i2) {
        nodes[i2].order = i2;
      }
    }
    __name(setOrder, "setOrder");
    setOrder(L);
    L.sort(function(A, B) {
      const Ap = A.constructor.priority || A.priority || 0;
      const Bp = B.constructor.priority || B.priority || 0;
      return Ap == Bp ? A.order - B.order : Ap - Bp;
    });
    setOrder(L);
    return L;
  }
  /**
   * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.
   * It doesn't include the node itself
   * @return {Array} an array with all the LGraphNodes that affect this node, in order of execution
   */
  getAncestors(node22) {
    const ancestors = [];
    const pending = [node22];
    const visited = {};
    while (pending.length) {
      const current = pending.shift();
      if (!current?.inputs) continue;
      if (!visited[current.id] && current != node22) {
        visited[current.id] = true;
        ancestors.push(current);
      }
      for (let i2 = 0; i2 < current.inputs.length; ++i2) {
        const input = current.getInputNode(i2);
        if (input && ancestors.indexOf(input) == -1) {
          pending.push(input);
        }
      }
    }
    ancestors.sort(function(a, b) {
      return a.order - b.order;
    });
    return ancestors;
  }
  /**
   * Positions every node in a more readable manner
   */
  arrange(margin, layout) {
    margin = margin || 100;
    const nodes = this.computeExecutionOrder(false, true);
    const columns = [];
    for (let i2 = 0; i2 < nodes.length; ++i2) {
      const node22 = nodes[i2];
      const col = node22._level || 1;
      columns[col] ||= [];
      columns[col].push(node22);
    }
    let x2 = margin;
    for (let i2 = 0; i2 < columns.length; ++i2) {
      const column = columns[i2];
      if (!column) continue;
      let max_size = 100;
      let y2 = margin + LiteGraph.NODE_TITLE_HEIGHT;
      for (let j = 0; j < column.length; ++j) {
        const node22 = column[j];
        node22.pos[0] = layout == LiteGraph.VERTICAL_LAYOUT ? y2 : x2;
        node22.pos[1] = layout == LiteGraph.VERTICAL_LAYOUT ? x2 : y2;
        const max_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 1 : 0;
        if (node22.size[max_size_index] > max_size) {
          max_size = node22.size[max_size_index];
        }
        const node_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 0 : 1;
        y2 += node22.size[node_size_index] + margin + LiteGraph.NODE_TITLE_HEIGHT;
      }
      x2 += max_size + margin;
    }
    this.setDirtyCanvas(true, true);
  }
  /**
   * Returns the amount of time the graph has been running in milliseconds
   * @return {number} number of milliseconds the graph has been running
   */
  getTime() {
    return this.globaltime;
  }
  /**
   * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant
   * @return {number} number of milliseconds the graph has been running
   */
  getFixedTime() {
    return this.fixedtime;
  }
  /**
   * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct
   * if the nodes are using graphical actions
   * @return {number} number of milliseconds it took the last cycle
   */
  getElapsedTime() {
    return this.elapsed_time;
  }
  /**
   * Sends an event to all the nodes, useful to trigger stuff
   * @param {String} eventname the name of the event (function to be called)
   * @param {Array} params parameters in array format
   */
  sendEventToAllNodes(eventname, params, mode2) {
    mode2 = mode2 || LGraphEventMode.ALWAYS;
    const nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;
    if (!nodes) return;
    for (let j = 0, l = nodes.length; j < l; ++j) {
      const node22 = nodes[j];
      if (node22.constructor === LiteGraph.Subgraph && eventname != "onExecute") {
        if (node22.mode == mode2) {
          node22.sendEventToAllNodes(eventname, params, mode2);
        }
        continue;
      }
      if (!node22[eventname] || node22.mode != mode2) continue;
      if (params === void 0) {
        node22[eventname]();
      } else if (params && params.constructor === Array) {
        node22[eventname].apply(node22, params);
      } else {
        node22[eventname](params);
      }
    }
  }
  /**
   * Runs an action on every canvas registered to this graph.
   * @param action Action to run for every canvas
   */
  canvasAction(action) {
    this.list_of_graphcanvas?.forEach(action);
  }
  /** @deprecated See {@link LGraph.canvasAction} */
  sendActionToCanvas(action, params) {
    if (!this.list_of_graphcanvas) return;
    for (let i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
      const c = this.list_of_graphcanvas[i2];
      c[action]?.apply(c, params);
    }
  }
  /**
   * Adds a new node instance to this graph
   * @param {LGraphNode} node the instance of the node
   */
  add(node22, skip_compute_order) {
    if (!node22) return;
    const { state } = this;
    if (node22 instanceof LGraphGroup) {
      if (node22.id == null || node22.id === -1) node22.id = ++state.lastGroupId;
      if (node22.id > state.lastGroupId) state.lastGroupId = node22.id;
      this._groups.push(node22);
      this.setDirtyCanvas(true);
      this.change();
      node22.graph = this;
      this._version++;
      return;
    }
    if (node22.id != -1 && this._nodes_by_id[node22.id] != null) {
      console.warn(
        "LiteGraph: there is already a node with this ID, changing it"
      );
      node22.id = LiteGraph.use_uuids ? LiteGraph.uuidv4() : ++state.lastNodeId;
    }
    if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {
      throw "LiteGraph: max number of nodes in a graph reached";
    }
    if (LiteGraph.use_uuids) {
      if (node22.id == null || node22.id == -1)
        node22.id = LiteGraph.uuidv4();
    } else {
      if (node22.id == null || node22.id == -1) {
        node22.id = ++state.lastNodeId;
      } else if (typeof node22.id === "number" && state.lastNodeId < node22.id) {
        state.lastNodeId = node22.id;
      }
    }
    node22.graph = this;
    this._version++;
    this._nodes.push(node22);
    this._nodes_by_id[node22.id] = node22;
    node22.onAdded?.(this);
    if (this.config.align_to_grid) node22.alignToGrid();
    if (!skip_compute_order) this.updateExecutionOrder();
    this.onNodeAdded?.(node22);
    this.setDirtyCanvas(true);
    this.change();
    return node22;
  }
  /**
   * Removes a node from the graph
   * @param {LGraphNode} node the instance of the node
   */
  remove(node22) {
    if (node22 instanceof LGraphGroup) {
      const index2 = this._groups.indexOf(node22);
      if (index2 != -1) {
        this._groups.splice(index2, 1);
      }
      node22.graph = null;
      this._version++;
      this.setDirtyCanvas(true, true);
      this.change();
      return;
    }
    if (this._nodes_by_id[node22.id] == null) return;
    if (node22.ignore_remove) return;
    this.beforeChange();
    if (node22.inputs) {
      for (let i2 = 0; i2 < node22.inputs.length; i2++) {
        const slot = node22.inputs[i2];
        if (slot.link != null)
          node22.disconnectInput(i2);
      }
    }
    if (node22.outputs) {
      for (let i2 = 0; i2 < node22.outputs.length; i2++) {
        const slot = node22.outputs[i2];
        if (slot.links?.length)
          node22.disconnectOutput(i2);
      }
    }
    node22.onRemoved?.();
    node22.graph = null;
    this._version++;
    if (this.list_of_graphcanvas) {
      for (let i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
        const canvas = this.list_of_graphcanvas[i2];
        if (canvas.selected_nodes[node22.id])
          delete canvas.selected_nodes[node22.id];
        if (canvas.node_dragged == node22)
          canvas.node_dragged = null;
      }
    }
    const pos2 = this._nodes.indexOf(node22);
    if (pos2 != -1) this._nodes.splice(pos2, 1);
    delete this._nodes_by_id[node22.id];
    this.onNodeRemoved?.(node22);
    this.canvasAction((c) => c.checkPanels());
    this.setDirtyCanvas(true, true);
    this.afterChange();
    this.change();
    this.updateExecutionOrder();
  }
  /**
   * Returns a node by its id.
   * @param {Number} id
   */
  getNodeById(id3) {
    return id3 != null ? this._nodes_by_id[id3] : null;
  }
  /**
   * Returns a list of nodes that matches a class
   * @param {Class} classObject the class itself (not an string)
   * @return {Array} a list with all the nodes of this type
   */
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  findNodesByClass(classObject, result) {
    result = result || [];
    result.length = 0;
    for (let i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
      if (this._nodes[i2].constructor === classObject)
        result.push(this._nodes[i2]);
    }
    return result;
  }
  /**
   * Returns a list of nodes that matches a type
   * @param {String} type the name of the node type
   * @return {Array} a list with all the nodes of this type
   */
  findNodesByType(type, result) {
    const matchType = type.toLowerCase();
    result = result || [];
    result.length = 0;
    for (let i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
      if (this._nodes[i2].type?.toLowerCase() == matchType)
        result.push(this._nodes[i2]);
    }
    return result;
  }
  /**
   * Returns the first node that matches a name in its title
   * @param {String} name the name of the node to search
   * @return {Node} the node or null
   */
  findNodeByTitle(title) {
    for (let i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
      if (this._nodes[i2].title == title)
        return this._nodes[i2];
    }
    return null;
  }
  /**
   * Returns a list of nodes that matches a name
   * @param {String} name the name of the node to search
   * @return {Array} a list with all the nodes with this name
   */
  findNodesByTitle(title) {
    const result = [];
    for (let i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
      if (this._nodes[i2].title == title)
        result.push(this._nodes[i2]);
    }
    return result;
  }
  /**
   * Returns the top-most node in this position of the canvas
   * @param {number} x the x coordinate in canvas space
   * @param {number} y the y coordinate in canvas space
   * @param {Array} nodeList a list with all the nodes to search from, by default is all the nodes in the graph
   * @return {LGraphNode} the node at this position or null
   */
  getNodeOnPos(x2, y2, nodeList) {
    const nodes = nodeList || this._nodes;
    let i2 = nodes.length;
    while (--i2 >= 0) {
      const node22 = nodes[i2];
      if (node22.isPointInside(x2, y2)) return node22;
    }
    return null;
  }
  /**
   * Returns the top-most group in that position
   * @param x The x coordinate in canvas space
   * @param y The y coordinate in canvas space
   * @return The group or null
   */
  getGroupOnPos(x2, y2) {
    return this._groups.toReversed().find((g) => g.isPointInside(x2, y2));
  }
  /**
   * Returns the top-most group with a titlebar in the provided position.
   * @param x The x coordinate in canvas space
   * @param y The y coordinate in canvas space
   * @return The group or null
   */
  getGroupTitlebarOnPos(x2, y2) {
    return this._groups.toReversed().find((g) => g.isPointInTitlebar(x2, y2));
  }
  /**
   * Finds a reroute a the given graph point
   * @param x X co-ordinate in graph space
   * @param y Y co-ordinate in graph space
   * @returns The first reroute under the given co-ordinates, or undefined
   */
  getRerouteOnPos(x2, y2) {
    for (const reroute of this.reroutes.values()) {
      const pos2 = reroute.pos;
      if (isSortaInsideOctagon(x2 - pos2[0], y2 - pos2[1], 20))
        return reroute;
    }
  }
  /**
   * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution
   * this replaces the ones using the old version with the new version
   */
  checkNodeTypes() {
    for (let i2 = 0; i2 < this._nodes.length; i2++) {
      const node22 = this._nodes[i2];
      const ctor = LiteGraph.registered_node_types[node22.type];
      if (node22.constructor == ctor) continue;
      console.log("node being replaced by newer version: " + node22.type);
      const newnode = LiteGraph.createNode(node22.type);
      this._nodes[i2] = newnode;
      newnode.configure(node22.serialize());
      newnode.graph = this;
      this._nodes_by_id[newnode.id] = newnode;
      if (node22.inputs) newnode.inputs = node22.inputs.concat();
      if (node22.outputs) newnode.outputs = node22.outputs.concat();
    }
    this.updateExecutionOrder();
  }
  // ********** GLOBALS *****************
  onAction(action, param, options3) {
    this._input_nodes = this.findNodesByClass(
      // @ts-expect-error Never impl.
      LiteGraph.GraphInput,
      this._input_nodes
    );
    for (let i2 = 0; i2 < this._input_nodes.length; ++i2) {
      const node22 = this._input_nodes[i2];
      if (node22.properties.name != action) continue;
      node22.actionDo(action, param, options3);
      break;
    }
  }
  trigger(action, param) {
    this.onTrigger?.(action, param);
  }
  /**
   * Tell this graph it has a global graph input of this type
   * @param {String} name
   * @param {String} type
   * @param {*} value [optional]
   */
  addInput(name, type, value3) {
    const input = this.inputs[name];
    if (input) return;
    this.beforeChange();
    this.inputs[name] = { name, type, value: value3 };
    this._version++;
    this.afterChange();
    this.onInputAdded?.(name, type);
    this.onInputsOutputsChange?.();
  }
  /**
   * Assign a data to the global graph input
   * @param {String} name
   * @param {*} data
   */
  setInputData(name, data22) {
    const input = this.inputs[name];
    if (!input) return;
    input.value = data22;
  }
  /**
   * Returns the current value of a global graph input
   * @param {String} name
   * @return {*} the data
   */
  getInputData(name) {
    const input = this.inputs[name];
    return input ? input.value : null;
  }
  /**
   * Changes the name of a global graph input
   * @param {String} old_name
   * @param {String} new_name
   */
  renameInput(old_name, name) {
    if (name == old_name) return;
    if (!this.inputs[old_name]) return false;
    if (this.inputs[name]) {
      console.error("there is already one input with that name");
      return false;
    }
    this.inputs[name] = this.inputs[old_name];
    delete this.inputs[old_name];
    this._version++;
    this.onInputRenamed?.(old_name, name);
    this.onInputsOutputsChange?.();
  }
  /**
   * Changes the type of a global graph input
   * @param {String} name
   * @param {String} type
   */
  changeInputType(name, type) {
    if (!this.inputs[name]) return false;
    if (this.inputs[name].type && String(this.inputs[name].type).toLowerCase() == String(type).toLowerCase()) {
      return;
    }
    this.inputs[name].type = type;
    this._version++;
    this.onInputTypeChanged?.(name, type);
  }
  /**
   * Removes a global graph input
   * @param {String} name
   * @param {String} type
   */
  removeInput(name) {
    if (!this.inputs[name]) return false;
    delete this.inputs[name];
    this._version++;
    this.onInputRemoved?.(name);
    this.onInputsOutputsChange?.();
    return true;
  }
  /**
   * Creates a global graph output
   * @param {String} name
   * @param {String} type
   * @param {*} value
   */
  addOutput(name, type, value3) {
    this.outputs[name] = { name, type, value: value3 };
    this._version++;
    this.onOutputAdded?.(name, type);
    this.onInputsOutputsChange?.();
  }
  /**
   * Assign a data to the global output
   * @param {String} name
   * @param {String} value
   */
  setOutputData(name, value3) {
    const output = this.outputs[name];
    if (!output) return;
    output.value = value3;
  }
  /**
   * Returns the current value of a global graph output
   * @param {String} name
   * @return {*} the data
   */
  getOutputData(name) {
    const output = this.outputs[name];
    if (!output) return null;
    return output.value;
  }
  /**
   * Renames a global graph output
   * @param {String} old_name
   * @param {String} new_name
   */
  renameOutput(old_name, name) {
    if (!this.outputs[old_name]) return false;
    if (this.outputs[name]) {
      console.error("there is already one output with that name");
      return false;
    }
    this.outputs[name] = this.outputs[old_name];
    delete this.outputs[old_name];
    this._version++;
    this.onOutputRenamed?.(old_name, name);
    this.onInputsOutputsChange?.();
  }
  /**
   * Changes the type of a global graph output
   * @param {String} name
   * @param {String} type
   */
  changeOutputType(name, type) {
    if (!this.outputs[name]) return false;
    if (this.outputs[name].type && String(this.outputs[name].type).toLowerCase() == String(type).toLowerCase()) {
      return;
    }
    this.outputs[name].type = type;
    this._version++;
    this.onOutputTypeChanged?.(name, type);
  }
  /**
   * Removes a global graph output
   * @param {String} name
   */
  removeOutput(name) {
    if (!this.outputs[name]) return false;
    delete this.outputs[name];
    this._version++;
    this.onOutputRemoved?.(name);
    this.onInputsOutputsChange?.();
    return true;
  }
  /** @todo Clean up - never implemented. */
  triggerInput(name, value3) {
    const nodes = this.findNodesByTitle(name);
    for (let i2 = 0; i2 < nodes.length; ++i2) {
      nodes[i2].onTrigger(value3);
    }
  }
  /** @todo Clean up - never implemented. */
  setCallback(name, func) {
    const nodes = this.findNodesByTitle(name);
    for (let i2 = 0; i2 < nodes.length; ++i2) {
      nodes[i2].setTrigger(func);
    }
  }
  //used for undo, called before any change is made to the graph
  beforeChange(info) {
    this.onBeforeChange?.(this, info);
    this.canvasAction((c) => c.onBeforeChange?.(this));
  }
  //used to resend actions, called after any change is made to the graph
  afterChange(info) {
    this.onAfterChange?.(this, info);
    this.canvasAction((c) => c.onAfterChange?.(this));
  }
  connectionChange(node22) {
    this.updateExecutionOrder();
    this.onConnectionChange?.(node22);
    this._version++;
    this.canvasAction((c) => c.onConnectionChange?.());
  }
  /**
   * returns if the graph is in live mode
   */
  isLive() {
    if (!this.list_of_graphcanvas) return false;
    for (let i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
      const c = this.list_of_graphcanvas[i2];
      if (c.live_mode) return true;
    }
    return false;
  }
  /**
   * clears the triggered slot animation in all links (stop visual animation)
   */
  clearTriggeredSlots() {
    for (const link_info of this._links.values()) {
      if (!link_info) continue;
      if (link_info._last_time)
        link_info._last_time = 0;
    }
  }
  /* Called when something visually changed (not the graph!) */
  change() {
    if (LiteGraph.debug) {
      console.log("Graph changed");
    }
    this.canvasAction((c) => c.setDirty(true, true));
    this.on_change?.(this);
  }
  setDirtyCanvas(fg, bg) {
    this.canvasAction((c) => c.setDirty(fg, bg));
  }
  /**
   * Configures a reroute on the graph where ID is already known (probably deserialisation).
   * Creates the object if it does not exist.
   * @param id Reroute ID
   * @param pos Position in graph space
   * @param linkIds IDs of links that pass through this reroute
   */
  setReroute({ id: id3, parentId, pos: pos2, linkIds }) {
    if (id3 > this.state.lastRerouteId) this.state.lastRerouteId = id3;
    const reroute = this.reroutes.get(id3) ?? new Reroute(id3, this);
    reroute.update(parentId, pos2, linkIds);
    this.reroutes.set(id3, reroute);
    return reroute;
  }
  /**
   * Creates a new reroute and adds it to the graph.
   * @param pos Position in graph space
   * @param links The links that will use this reroute (e.g. if from an output with multiple outputs, and all will use it)
   * @param afterRerouteId If set, this reroute will be shown after the specified ID.  Otherwise, the reroute will be added as the last on the link.
   * @returns The newly created reroute - typically ignored.
   */
  createReroute(pos2, before) {
    const rerouteId = ++this.state.lastRerouteId;
    const linkIds = before instanceof Reroute ? before.linkIds : [before.id];
    const reroute = new Reroute(rerouteId, this, pos2, before.parentId, linkIds);
    this.reroutes.set(rerouteId, reroute);
    for (const linkId of linkIds) {
      const link = this._links.get(linkId);
      if (!link) continue;
      if (link.parentId === before.parentId) link.parentId = rerouteId;
      LLink.getReroutes(this, link)?.filter((x2) => x2.parentId === before.parentId).forEach((x2) => x2.parentId = rerouteId);
    }
    return reroute;
  }
  /**
   * Removes a reroute from the graph
   * @param id ID of reroute to remove
   */
  removeReroute(id3) {
    const { reroutes } = this;
    const reroute = reroutes.get(id3);
    if (!reroute) return;
    const { parentId, linkIds } = reroute;
    for (const reroute2 of reroutes.values()) {
      if (reroute2.parentId === id3) reroute2.parentId = parentId;
    }
    for (const linkId of linkIds) {
      const link = this._links.get(linkId);
      if (link && link.parentId === id3) link.parentId = parentId;
    }
    reroutes.delete(id3);
    this.setDirtyCanvas(false, true);
  }
  /**
   * Destroys a link
   * @param {Number} link_id
   */
  removeLink(link_id) {
    const link = this._links.get(link_id);
    if (!link) return;
    const node22 = this.getNodeById(link.target_id);
    node22?.disconnectInput(link.target_slot);
    link.disconnect(this);
  }
  /**
   * Creates a Object containing all the info about this graph, it can be serialized
   * @deprecated Use {@link asSerialisable}, which returns the newer schema version.
   * 
   * @return {Object} value of the node
   */
  serialize(option3) {
    const { config: config2, state, groups, nodes, reroutes, extra } = this.asSerialisable(option3);
    const linkArray = [...this._links.values()];
    const links = linkArray.map((x2) => x2.serialize());
    if (reroutes.length) {
      extra.reroutes = reroutes;
      extra.linkExtensions = linkArray.filter((x2) => x2.parentId !== void 0).map((x2) => ({ id: x2.id, parentId: x2.parentId }));
    }
    return {
      last_node_id: state.lastNodeId,
      last_link_id: state.lastLinkId,
      nodes,
      links,
      groups,
      config: config2,
      extra,
      version: LiteGraph.VERSION
    };
  }
  /**
   * Prepares a shallow copy of this object for immediate serialisation or structuredCloning.
   * The return value should be discarded immediately.
   * @param options Serialise options = currently `sortNodes: boolean`, whether to sort nodes by ID.
   * @returns A shallow copy of parts of this graph, with shallow copies of its serialisable objects.
   * Mutating the properties of the return object may result in changes to your graph.
   * It is intended for use with {@link structuredClone} or {@link JSON.stringify}.
   */
  asSerialisable(options3) {
    const { config: config2, state, extra } = this;
    const nodeList = !LiteGraph.use_uuids && options3?.sortNodes ? [...this._nodes].sort((a, b) => a.id - b.id) : this._nodes;
    const nodes = nodeList.map((node22) => node22.serialize());
    const groups = this._groups.map((x2) => x2.serialize());
    const links = [...this._links.values()].map((x2) => x2.asSerialisable());
    const reroutes = [...this.reroutes.values()].map((x2) => x2.asSerialisable());
    const data22 = {
      version: LGraph2.serialisedSchemaVersion,
      config: config2,
      state,
      groups,
      nodes,
      links,
      reroutes,
      extra
    };
    this.onSerialize?.(data22);
    return data22;
  }
  /**
   * Configure a graph from a JSON string
   * @param {String} str configure a graph from a JSON string
   * @param {Boolean} returns if there was any error parsing
   */
  configure(data22, keep_old) {
    if (!data22) return;
    if (!keep_old) this.clear();
    const { extra } = data22;
    let reroutes;
    if (data22.version === 0.4) {
      if (Array.isArray(data22.links)) {
        for (const linkData of data22.links) {
          const link = LLink.createFromArray(linkData);
          this._links.set(link.id, link);
        }
      }
      if (Array.isArray(extra?.linkExtensions)) {
        for (const linkEx of extra.linkExtensions) {
          const link = this._links.get(linkEx.id);
          if (link) link.parentId = linkEx.parentId;
        }
      }
      reroutes = extra?.reroutes;
    } else {
      if (data22.state) {
        const { state: { lastGroupId, lastLinkId, lastNodeId, lastRerouteId } } = data22;
        if (lastGroupId != null) this.state.lastGroupId = lastGroupId;
        if (lastLinkId != null) this.state.lastLinkId = lastLinkId;
        if (lastNodeId != null) this.state.lastNodeId = lastNodeId;
        if (lastRerouteId != null) this.state.lastRerouteId = lastRerouteId;
      }
      if (Array.isArray(data22.links)) {
        for (const linkData of data22.links) {
          const link = LLink.create(linkData);
          this._links.set(link.id, link);
        }
      }
      reroutes = data22.reroutes;
    }
    if (Array.isArray(reroutes)) {
      for (const rerouteData of reroutes) {
        const reroute = this.setReroute(rerouteData);
        if (!reroute.validateLinks(this._links))
          this.reroutes.delete(rerouteData.id);
      }
    }
    const nodesData = data22.nodes;
    for (const i2 in data22) {
      if (i2 == "nodes" || i2 == "groups" || i2 == "links" || i2 === "state" || i2 === "reroutes")
        continue;
      this[i2] = data22[i2];
    }
    let error = false;
    this._nodes = [];
    if (nodesData) {
      for (let i2 = 0, l = nodesData.length; i2 < l; ++i2) {
        const n_info = nodesData[i2];
        let node22 = LiteGraph.createNode(n_info.type, n_info.title);
        if (!node22) {
          if (LiteGraph.debug) console.log("Node not found or has errors: " + n_info.type);
          node22 = new LGraphNode(void 0);
          node22.last_serialization = n_info;
          node22.has_errors = true;
          error = true;
        }
        node22.id = n_info.id;
        this.add(node22, true);
      }
      for (let i2 = 0, l = nodesData.length; i2 < l; ++i2) {
        const n_info = nodesData[i2];
        const node22 = this.getNodeById(n_info.id);
        node22?.configure(n_info);
      }
    }
    this._groups.length = 0;
    if (data22.groups) {
      for (let i2 = 0; i2 < data22.groups.length; ++i2) {
        const group = new LiteGraph.LGraphGroup();
        group.configure(data22.groups[i2]);
        this.add(group);
      }
    }
    this.updateExecutionOrder();
    this.extra = data22.extra || {};
    this.onConfigure?.(data22);
    this._version++;
    this.setDirtyCanvas(true, true);
    return error;
  }
  load(url, callback) {
    const that2 = this;
    if (url instanceof Blob || url instanceof File) {
      const reader = new FileReader();
      reader.addEventListener("load", function(event2) {
        const data22 = JSON.parse(event2.target.result.toString());
        that2.configure(data22);
        callback?.();
      });
      reader.readAsText(url);
      return;
    }
    const req = new XMLHttpRequest();
    req.open("GET", url, true);
    req.send(null);
    req.onload = function() {
      if (req.status !== 200) {
        console.error("Error loading graph:", req.status, req.response);
        return;
      }
      const data22 = JSON.parse(req.response);
      that2.configure(data22);
      callback?.();
    };
    req.onerror = function(err) {
      console.error("Error loading graph:", err);
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onNodeTrace(node22, msg) {
  }
};
class ContextMenu {
  static {
    __name(this, "ContextMenu");
  }
  options;
  parentMenu;
  root;
  current_submenu;
  lock;
  // TODO: Interface for values requires functionality change - currently accepts an array of strings, functions, objects, nulls, or undefined.
  constructor(values2, options3) {
    options3 ||= {};
    this.options = options3;
    const parent = options3.parentMenu;
    if (parent) {
      if (!(parent instanceof ContextMenu)) {
        console.error("parentMenu must be of class ContextMenu, ignoring it");
        options3.parentMenu = null;
      } else {
        this.parentMenu = parent;
        this.parentMenu.lock = true;
        this.parentMenu.current_submenu = this;
      }
      if (parent.options?.className === "dark") {
        options3.className = "dark";
      }
    }
    const eventClass = options3.event ? options3.event.constructor.name : null;
    if (eventClass !== "MouseEvent" && eventClass !== "CustomEvent" && eventClass !== "PointerEvent") {
      console.error(`Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (${eventClass})`);
      options3.event = null;
    }
    const root23 = document.createElement("div");
    let classes2 = "litegraph litecontextmenu litemenubar-panel";
    if (options3.className) classes2 += " " + options3.className;
    root23.className = classes2;
    root23.style.minWidth = "100";
    root23.style.minHeight = "100";
    root23.style.pointerEvents = "none";
    setTimeout(function() {
      root23.style.pointerEvents = "auto";
    }, 100);
    LiteGraph.pointerListenerAdd(
      root23,
      "up",
      function(e) {
        e.preventDefault();
        return true;
      },
      true
    );
    root23.addEventListener(
      "contextmenu",
      function(e) {
        if (e.button != 2) return false;
        e.preventDefault();
        return false;
      },
      true
    );
    LiteGraph.pointerListenerAdd(
      root23,
      "down",
      (e) => {
        if (e.button == 2) {
          this.close();
          e.preventDefault();
          return true;
        }
      },
      true
    );
    function on_mouse_wheel(e) {
      const pos2 = parseInt(root23.style.top);
      root23.style.top = (pos2 + e.deltaY * options3.scroll_speed).toFixed() + "px";
      e.preventDefault();
      return true;
    }
    __name(on_mouse_wheel, "on_mouse_wheel");
    if (!options3.scroll_speed) {
      options3.scroll_speed = 0.1;
    }
    root23.addEventListener("wheel", on_mouse_wheel, true);
    this.root = root23;
    if (options3.title) {
      const element = document.createElement("div");
      element.className = "litemenu-title";
      element.innerHTML = options3.title;
      root23.appendChild(element);
    }
    for (let i2 = 0; i2 < values2.length; i2++) {
      const value3 = values2[i2];
      let name = Array.isArray(values2) ? value3 : String(i2);
      if (typeof name !== "string") {
        name = name != null ? name.content === void 0 ? String(name) : name.content : name;
      }
      this.addItem(name, value3, options3);
    }
    LiteGraph.pointerListenerAdd(root23, "enter", function() {
      if (root23.closing_timer) {
        clearTimeout(root23.closing_timer);
      }
    });
    const ownerDocument = (options3.event?.target).ownerDocument;
    const root_document = ownerDocument || document;
    if (root_document.fullscreenElement)
      root_document.fullscreenElement.appendChild(root23);
    else
      root_document.body.appendChild(root23);
    let left = options3.left || 0;
    let top = options3.top || 0;
    if (options3.event) {
      left = options3.event.clientX - 10;
      top = options3.event.clientY - 10;
      if (options3.title) top -= 20;
      if (parent) {
        const rect = parent.root.getBoundingClientRect();
        left = rect.left + rect.width;
      }
      const body_rect = document.body.getBoundingClientRect();
      const root_rect = root23.getBoundingClientRect();
      if (body_rect.height == 0)
        console.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }");
      if (body_rect.width && left > body_rect.width - root_rect.width - 10)
        left = body_rect.width - root_rect.width - 10;
      if (body_rect.height && top > body_rect.height - root_rect.height - 10)
        top = body_rect.height - root_rect.height - 10;
    }
    root23.style.left = left + "px";
    root23.style.top = top + "px";
    if (options3.scale)
      root23.style.transform = `scale(${options3.scale})`;
  }
  addItem(name, value3, options3) {
    options3 ||= {};
    const element = document.createElement("div");
    element.className = "litemenu-entry submenu";
    let disabled2 = false;
    if (value3 === null) {
      element.classList.add("separator");
    } else {
      if (typeof value3 === "string") {
        element.innerHTML = name;
      } else {
        element.innerHTML = value3?.title ?? name;
        if (value3.disabled) {
          disabled2 = true;
          element.classList.add("disabled");
          element.setAttribute("aria-disabled", "true");
        }
        if (value3.submenu || value3.has_submenu) {
          element.classList.add("has_submenu");
          element.setAttribute("aria-haspopup", "true");
          element.setAttribute("aria-expanded", "false");
        }
        if (value3.className)
          element.className += " " + value3.className;
      }
      element.value = value3;
      element.setAttribute("role", "menuitem");
      if (typeof value3 === "function") {
        element.dataset["value"] = name;
        element.onclick_callback = value3;
      } else {
        element.dataset["value"] = String(value3);
      }
    }
    this.root.appendChild(element);
    if (!disabled2) element.addEventListener("click", inner_onclick);
    if (!disabled2 && options3.autoopen)
      LiteGraph.pointerListenerAdd(element, "enter", inner_over);
    const setAriaExpanded = /* @__PURE__ */ __name(() => {
      const entries = this.root.querySelectorAll("div.litemenu-entry.has_submenu");
      if (entries) {
        for (let i2 = 0; i2 < entries.length; i2++) {
          entries[i2].setAttribute("aria-expanded", "false");
        }
      }
      element.setAttribute("aria-expanded", "true");
    }, "setAriaExpanded");
    function inner_over(e) {
      const value22 = this.value;
      if (!value22 || !value22.has_submenu) return;
      inner_onclick.call(this, e);
      setAriaExpanded();
    }
    __name(inner_over, "inner_over");
    const that2 = this;
    function inner_onclick(e) {
      const value22 = this.value;
      let close_parent = true;
      that2.current_submenu?.close(e);
      if (value22?.has_submenu || value22?.submenu) setAriaExpanded();
      if (options3.callback) {
        const r = options3.callback.call(
          this,
          value22,
          options3,
          e,
          that2,
          options3.node
        );
        if (r === true) close_parent = false;
      }
      if (typeof value22 === "object") {
        if (value22.callback && !options3.ignore_item_callbacks && value22.disabled !== true) {
          const r = value22.callback.call(
            this,
            value22,
            options3,
            e,
            that2,
            options3.extra
          );
          if (r === true) close_parent = false;
        }
        if (value22.submenu) {
          if (!value22.submenu.options)
            throw "ContextMenu submenu needs options";
          new that2.constructor(value22.submenu.options, {
            callback: value22.submenu.callback,
            event: e,
            parentMenu: that2,
            ignore_item_callbacks: value22.submenu.ignore_item_callbacks,
            title: value22.submenu.title,
            extra: value22.submenu.extra,
            autoopen: options3.autoopen
          });
          close_parent = false;
        }
      }
      if (close_parent && !that2.lock)
        that2.close();
    }
    __name(inner_onclick, "inner_onclick");
    return element;
  }
  close(e, ignore_parent_menu) {
    this.root.parentNode?.removeChild(this.root);
    if (this.parentMenu && !ignore_parent_menu) {
      this.parentMenu.lock = false;
      this.parentMenu.current_submenu = null;
      if (e === void 0) {
        this.parentMenu.close();
      } else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {
        ContextMenu.trigger(this.parentMenu.root, LiteGraph.pointerevents_method + "leave", e);
      }
    }
    this.current_submenu?.close(e, true);
    if (this.root.closing_timer)
      clearTimeout(this.root.closing_timer);
  }
  //this code is used to trigger events easily (used in the context menu mouseleave
  static trigger(element, event_name, params, origin2) {
    const evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(event_name, true, true, params);
    evt.srcElement = origin2;
    if (element.dispatchEvent) element.dispatchEvent(evt);
    else if (element.__events) element.__events.dispatchEvent(evt);
    return evt;
  }
  //returns the top most menu
  getTopMenu() {
    return this.options.parentMenu ? this.options.parentMenu.getTopMenu() : this;
  }
  getFirstEvent() {
    return this.options.parentMenu ? this.options.parentMenu.getFirstEvent() : this.options.event;
  }
  static isCursorOverElement(event2, element) {
    const left = event2.clientX;
    const top = event2.clientY;
    const rect = element.getBoundingClientRect();
    if (!rect) return false;
    if (top > rect.top && top < rect.top + rect.height && left > rect.left && left < rect.left + rect.width) {
      return true;
    }
    return false;
  }
}
class CurveEditor {
  static {
    __name(this, "CurveEditor");
  }
  points;
  selected;
  nearest;
  size;
  must_update;
  margin;
  _nearest;
  constructor(points) {
    this.points = points;
    this.selected = -1;
    this.nearest = -1;
    this.size = null;
    this.must_update = true;
    this.margin = 5;
  }
  static sampleCurve(f, points) {
    if (!points)
      return;
    for (let i2 = 0; i2 < points.length - 1; ++i2) {
      const p2 = points[i2];
      const pn = points[i2 + 1];
      if (pn[0] < f)
        continue;
      const r = pn[0] - p2[0];
      if (Math.abs(r) < 1e-5)
        return p2[1];
      const local_f = (f - p2[0]) / r;
      return p2[1] * (1 - local_f) + pn[1] * local_f;
    }
    return 0;
  }
  draw(ctx, size2, graphcanvas, background_color, line_color, inactive = false) {
    const points = this.points;
    if (!points)
      return;
    this.size = size2;
    const w2 = size2[0] - this.margin * 2;
    const h2 = size2[1] - this.margin * 2;
    line_color = line_color || "#666";
    ctx.save();
    ctx.translate(this.margin, this.margin);
    if (background_color) {
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, w2, h2);
      ctx.fillStyle = "#222";
      ctx.fillRect(w2 * 0.5, 0, 1, h2);
      ctx.strokeStyle = "#333";
      ctx.strokeRect(0, 0, w2, h2);
    }
    ctx.strokeStyle = line_color;
    if (inactive)
      ctx.globalAlpha = 0.5;
    ctx.beginPath();
    for (let i2 = 0; i2 < points.length; ++i2) {
      const p2 = points[i2];
      ctx.lineTo(p2[0] * w2, (1 - p2[1]) * h2);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
    if (!inactive)
      for (let i2 = 0; i2 < points.length; ++i2) {
        const p2 = points[i2];
        ctx.fillStyle = this.selected == i2 ? "#FFF" : this.nearest == i2 ? "#DDD" : "#AAA";
        ctx.beginPath();
        ctx.arc(p2[0] * w2, (1 - p2[1]) * h2, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    ctx.restore();
  }
  //localpos is mouse in curve editor space
  onMouseDown(localpos, graphcanvas) {
    const points = this.points;
    if (!points)
      return;
    if (localpos[1] < 0)
      return;
    const w2 = this.size[0] - this.margin * 2;
    const h2 = this.size[1] - this.margin * 2;
    const x2 = localpos[0] - this.margin;
    const y2 = localpos[1] - this.margin;
    const pos2 = [x2, y2];
    const max_dist = 30 / graphcanvas.ds.scale;
    this.selected = this.getCloserPoint(pos2, max_dist);
    if (this.selected == -1) {
      const point = [x2 / w2, 1 - y2 / h2];
      points.push(point);
      points.sort(function(a, b) {
        return a[0] - b[0];
      });
      this.selected = points.indexOf(point);
      this.must_update = true;
    }
    if (this.selected != -1)
      return true;
  }
  onMouseMove(localpos, graphcanvas) {
    const points = this.points;
    if (!points)
      return;
    const s = this.selected;
    if (s < 0)
      return;
    const x2 = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2);
    const y2 = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2);
    const curvepos = [localpos[0] - this.margin, localpos[1] - this.margin];
    const max_dist = 30 / graphcanvas.ds.scale;
    this._nearest = this.getCloserPoint(curvepos, max_dist);
    const point = points[s];
    if (point) {
      const is_edge_point = s == 0 || s == points.length - 1;
      if (!is_edge_point && (localpos[0] < -10 || localpos[0] > this.size[0] + 10 || localpos[1] < -10 || localpos[1] > this.size[1] + 10)) {
        points.splice(s, 1);
        this.selected = -1;
        return;
      }
      if (!is_edge_point)
        point[0] = clamp$1(x2, 0, 1);
      else
        point[0] = s == 0 ? 0 : 1;
      point[1] = 1 - clamp$1(y2, 0, 1);
      points.sort(function(a, b) {
        return a[0] - b[0];
      });
      this.selected = points.indexOf(point);
      this.must_update = true;
    }
  }
  // Former params: localpos, graphcanvas
  onMouseUp() {
    this.selected = -1;
    return false;
  }
  getCloserPoint(pos2, max_dist) {
    const points = this.points;
    if (!points)
      return -1;
    max_dist = max_dist || 30;
    const w2 = this.size[0] - this.margin * 2;
    const h2 = this.size[1] - this.margin * 2;
    const num = points.length;
    const p2 = [0, 0];
    let min_dist = 1e6;
    let closest = -1;
    for (let i2 = 0; i2 < num; ++i2) {
      const p3 = points[i2];
      p2[0] = p3[0] * w2;
      p2[1] = (1 - p3[1]) * h2;
      const dist2 = distance(pos2, p2);
      if (dist2 > min_dist || dist2 > max_dist)
        continue;
      closest = i2;
      min_dist = dist2;
    }
    return closest;
  }
}
class LiteGraphGlobal {
  static {
    __name(this, "LiteGraphGlobal");
  }
  // Enums
  SlotShape = SlotShape;
  SlotDirection = SlotDirection;
  SlotType = SlotType;
  LabelPosition = LabelPosition;
  /** Used in serialised graphs at one point. */
  VERSION = 0.4;
  CANVAS_GRID_SIZE = 10;
  NODE_TITLE_HEIGHT = 30;
  NODE_TITLE_TEXT_Y = 20;
  NODE_SLOT_HEIGHT = 20;
  NODE_WIDGET_HEIGHT = 20;
  NODE_WIDTH = 140;
  NODE_MIN_WIDTH = 50;
  NODE_COLLAPSED_RADIUS = 10;
  NODE_COLLAPSED_WIDTH = 80;
  NODE_TITLE_COLOR = "#999";
  NODE_SELECTED_TITLE_COLOR = "#FFF";
  NODE_TEXT_SIZE = 14;
  NODE_TEXT_COLOR = "#AAA";
  NODE_TEXT_HIGHLIGHT_COLOR = "#EEE";
  NODE_SUBTEXT_SIZE = 12;
  NODE_DEFAULT_COLOR = "#333";
  NODE_DEFAULT_BGCOLOR = "#353535";
  NODE_DEFAULT_BOXCOLOR = "#666";
  NODE_DEFAULT_SHAPE = "box";
  NODE_BOX_OUTLINE_COLOR = "#FFF";
  DEFAULT_SHADOW_COLOR = "rgba(0,0,0,0.5)";
  DEFAULT_GROUP_FONT = 24;
  DEFAULT_GROUP_FONT_SIZE;
  WIDGET_BGCOLOR = "#222";
  WIDGET_OUTLINE_COLOR = "#666";
  WIDGET_TEXT_COLOR = "#DDD";
  WIDGET_SECONDARY_TEXT_COLOR = "#999";
  LINK_COLOR = "#9A9";
  // TODO: This is a workaround until LGraphCanvas.link_type_colors is no longer static.
  static DEFAULT_EVENT_LINK_COLOR = "#A86";
  EVENT_LINK_COLOR = "#A86";
  CONNECTING_LINK_COLOR = "#AFA";
  MAX_NUMBER_OF_NODES = 1e4;
  //avoid infinite loops
  DEFAULT_POSITION = [100, 100];
  //default node position
  VALID_SHAPES = ["default", "box", "round", "card"];
  //,"circle"
  //shapes are used for nodes but also for slots
  BOX_SHAPE = RenderShape.BOX;
  ROUND_SHAPE = RenderShape.ROUND;
  CIRCLE_SHAPE = RenderShape.CIRCLE;
  CARD_SHAPE = RenderShape.CARD;
  ARROW_SHAPE = RenderShape.ARROW;
  GRID_SHAPE = RenderShape.GRID;
  // intended for slot arrays
  //enums
  INPUT = NodeSlotType.INPUT;
  OUTPUT = NodeSlotType.OUTPUT;
  // TODO: -1 can lead to ambiguity in JS; these should be updated to a more explicit constant or Symbol.
  EVENT = -1;
  //for outputs
  ACTION = -1;
  //for inputs
  NODE_MODES = ["Always", "On Event", "Never", "On Trigger"];
  // helper, will add "On Request" and more in the future
  NODE_MODES_COLORS = ["#666", "#422", "#333", "#224", "#626"];
  // use with node_box_coloured_by_mode
  ALWAYS = LGraphEventMode.ALWAYS;
  ON_EVENT = LGraphEventMode.ON_EVENT;
  NEVER = LGraphEventMode.NEVER;
  ON_TRIGGER = LGraphEventMode.ON_TRIGGER;
  UP = LinkDirection.UP;
  DOWN = LinkDirection.DOWN;
  LEFT = LinkDirection.LEFT;
  RIGHT = LinkDirection.RIGHT;
  CENTER = LinkDirection.CENTER;
  LINK_RENDER_MODES = ["Straight", "Linear", "Spline"];
  // helper
  HIDDEN_LINK = LinkRenderType.HIDDEN_LINK;
  STRAIGHT_LINK = LinkRenderType.STRAIGHT_LINK;
  LINEAR_LINK = LinkRenderType.LINEAR_LINK;
  SPLINE_LINK = LinkRenderType.SPLINE_LINK;
  NORMAL_TITLE = TitleMode.NORMAL_TITLE;
  NO_TITLE = TitleMode.NO_TITLE;
  TRANSPARENT_TITLE = TitleMode.TRANSPARENT_TITLE;
  AUTOHIDE_TITLE = TitleMode.AUTOHIDE_TITLE;
  VERTICAL_LAYOUT = "vertical";
  // arrange nodes vertically
  proxy = null;
  //used to redirect calls
  node_images_path = "";
  debug = false;
  catch_exceptions = true;
  throw_errors = true;
  allow_scripts = false;
  //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits
  registered_node_types = {};
  //nodetypes by string
  node_types_by_file_extension = {};
  //used for dropping files in the canvas
  Nodes = {};
  //node types by classname
  Globals = {};
  //used to store vars between graphs
  searchbox_extras = {};
  //used to add extra features to the search box
  auto_sort_node_types = false;
  // [true!] If set to true, will automatically sort node types / categories in the context menus
  node_box_coloured_when_on = false;
  // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback
  node_box_coloured_by_mode = false;
  // [true!] nodebox based on node mode, visual feedback
  dialog_close_on_mouse_leave = false;
  // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false
  dialog_close_on_mouse_leave_delay = 500;
  shift_click_do_break_link_from = false;
  // [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys
  click_do_break_link_to = false;
  // [false!]prefer false, way too easy to break links
  ctrl_alt_click_do_break_link = true;
  // [true!] who accidentally ctrl-alt-clicks on an in/output? nobody! that's who!
  snaps_for_comfy = true;
  // [true!] snaps links when dragging connections over valid targets
  snap_highlights_node = true;
  // [true!] renders a partial border to highlight when a dragged link is snapped to a node
  search_hide_on_mouse_leave = true;
  // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false
  search_filter_enabled = false;
  // [true!] enable filtering slots type in the search widget, !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]
  search_show_all_on_open = true;
  // [true!] opens the results list when opening the search widget
  auto_load_slot_types = false;
  // [if want false, use true, run, get vars values to be statically set, than disable] nodes types and nodeclass association with node types need to be calculated, if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]
  // set these values if not using auto_load_slot_types
  registered_slot_in_types = {};
  // slot types for nodeclass
  registered_slot_out_types = {};
  // slot types for nodeclass
  slot_types_in = [];
  // slot types IN
  slot_types_out = [];
  // slot types OUT
  slot_types_default_in = {};
  // specify for each IN slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search
  slot_types_default_out = {};
  // specify for each OUT slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search
  alt_drag_do_clone_nodes = false;
  // [true!] very handy, ALT click to clone and drag the new node
  do_add_triggers_slots = false;
  // [true!] will create and connect event slots when using action/events connections, !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this
  allow_multi_output_for_events = true;
  // [false!] being events, it is strongly reccomended to use them sequentially, one by one
  middle_click_slot_add_default_node = false;
  //[true!] allows to create and connect a ndoe clicking with the third button (wheel)
  release_link_on_empty_shows_menu = false;
  //[true!] dragging a link to empty space will open a menu, add from list, search or defaults
  pointerevents_method = "pointer";
  // "mouse"|"pointer" use mouse for retrocompatibility issues? (none found @ now)
  // TODO implement pointercancel, gotpointercapture, lostpointercapture, (pointerover, pointerout if necessary)
  ctrl_shift_v_paste_connect_unselected_outputs = true;
  //[true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected with the inputs of the newly pasted nodes
  // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.
  // use this if you must have node IDs that are unique across all graphs and subgraphs.
  use_uuids = false;
  // Whether to highlight the bounding box of selected groups
  highlight_selected_group = true;
  // TODO: Remove legacy accessors
  LGraph = LGraph$1;
  LLink = LLink;
  LGraphNode = LGraphNode;
  LGraphGroup = LGraphGroup;
  DragAndScale = DragAndScale;
  LGraphCanvas = LGraphCanvas;
  ContextMenu = ContextMenu;
  CurveEditor = CurveEditor;
  static {
    LGraphCanvas.link_type_colors = {
      "-1": LiteGraphGlobal.DEFAULT_EVENT_LINK_COLOR,
      number: "#AAA",
      node: "#DCA"
    };
  }
  constructor() {
    if (typeof performance != "undefined") {
      this.getTime = performance.now.bind(performance);
    } else if (typeof Date != "undefined" && Date.now) {
      this.getTime = Date.now.bind(Date);
    } else if (typeof process != "undefined") {
      this.getTime = function() {
        const t = process.hrtime();
        return t[0] * 1e-3 + t[1] * 1e-6;
      };
    } else {
      this.getTime = function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
    }
  }
  /**
   * Register a node class so it can be listed when the user wants to create a new one
   * @param {String} type name of the node and path
   * @param {Class} base_class class containing the structure of a node
   */
  registerNodeType(type, base_class) {
    if (!base_class.prototype)
      throw "Cannot register a simple object, it must be a class with a prototype";
    base_class.type = type;
    if (this.debug) console.log("Node registered: " + type);
    const classname = base_class.name;
    const pos2 = type.lastIndexOf("/");
    base_class.category = type.substring(0, pos2);
    base_class.title ||= classname;
    for (const i2 in LGraphNode.prototype) {
      base_class.prototype[i2] ||= LGraphNode.prototype[i2];
    }
    const prev2 = this.registered_node_types[type];
    if (prev2) {
      console.log("replacing node type: " + type);
    }
    if (!Object.prototype.hasOwnProperty.call(base_class.prototype, "shape")) {
      Object.defineProperty(base_class.prototype, "shape", {
        set(v2) {
          switch (v2) {
            case "default":
              delete this._shape;
              break;
            case "box":
              this._shape = RenderShape.BOX;
              break;
            case "round":
              this._shape = RenderShape.ROUND;
              break;
            case "circle":
              this._shape = RenderShape.CIRCLE;
              break;
            case "card":
              this._shape = RenderShape.CARD;
              break;
            default:
              this._shape = v2;
          }
        },
        get() {
          return this._shape;
        },
        enumerable: true,
        configurable: true
      });
      if (base_class.supported_extensions) {
        for (const i2 in base_class.supported_extensions) {
          const ext = base_class.supported_extensions[i2];
          if (ext && typeof ext === "string") {
            this.node_types_by_file_extension[ext.toLowerCase()] = base_class;
          }
        }
      }
    }
    this.registered_node_types[type] = base_class;
    if (base_class.constructor.name) this.Nodes[classname] = base_class;
    this.onNodeTypeRegistered?.(type, base_class);
    if (prev2) this.onNodeTypeReplaced?.(type, base_class, prev2);
    if (base_class.prototype.onPropertyChange)
      console.warn(`LiteGraph node class ${type} has onPropertyChange method, it must be called onPropertyChanged with d at the end`);
    if (this.auto_load_slot_types) new base_class(base_class.title || "tmpnode");
  }
  /**
   * removes a node type from the system
   * @param {String|Object} type name of the node or the node constructor itself
   */
  unregisterNodeType(type) {
    const base_class = typeof type === "string" ? this.registered_node_types[type] : type;
    if (!base_class) throw "node type not found: " + type;
    delete this.registered_node_types[base_class.type];
    const name = base_class.constructor.name;
    if (name) delete this.Nodes[name];
  }
  /**
   * Save a slot type and his node
   * @param {String|Object} type name of the node or the node constructor itself
   * @param {String} slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..
   */
  registerNodeAndSlotType(type, slot_type, out) {
    out ||= false;
    const base_class = typeof type === "string" && this.registered_node_types[type] !== "anonymous" ? this.registered_node_types[type] : type;
    const class_type = base_class.constructor.type;
    let allTypes = [];
    if (typeof slot_type === "string") {
      allTypes = slot_type.split(",");
    } else if (slot_type == this.EVENT || slot_type == this.ACTION) {
      allTypes = ["_event_"];
    } else {
      allTypes = ["*"];
    }
    for (let i2 = 0; i2 < allTypes.length; ++i2) {
      let slotType = allTypes[i2];
      if (slotType === "") slotType = "*";
      const registerTo = out ? "registered_slot_out_types" : "registered_slot_in_types";
      if (this[registerTo][slotType] === void 0)
        this[registerTo][slotType] = { nodes: [] };
      if (!this[registerTo][slotType].nodes.includes(class_type))
        this[registerTo][slotType].nodes.push(class_type);
      const types = out ? this.slot_types_out : this.slot_types_in;
      if (!types.includes(slotType.toLowerCase())) {
        types.push(slotType.toLowerCase());
        types.sort();
      }
    }
  }
  /**
   * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.
   * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.
   * @param {String} name node name with namespace (p.e.: 'math/sum')
   * @param {Function} func
   * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type
   * @param {String} return_type [optional] string with the return type, otherwise it will be generic
   * @param {Object} properties [optional] properties to be configurable
   */
  wrapFunctionAsNode(name, func, param_types, return_type, properties) {
    const params = Array(func.length);
    let code2 = "";
    const names = this.getParameterNames(func);
    for (let i2 = 0; i2 < names.length; ++i2) {
      code2 += `this.addInput('${names[i2]}',${param_types && param_types[i2] ? `'${param_types[i2]}'` : "0"});
`;
    }
    code2 += `this.addOutput('out',${return_type ? `'${return_type}'` : 0});
`;
    if (properties) code2 += `this.properties = ${JSON.stringify(properties)};
`;
    const classobj = Function(code2);
    classobj.title = name.split("/").pop();
    classobj.desc = "Generated from " + func.name;
    classobj.prototype.onExecute = /* @__PURE__ */ __name(function onExecute() {
      for (let i2 = 0; i2 < params.length; ++i2) {
        params[i2] = this.getInputData(i2);
      }
      const r = func.apply(this, params);
      this.setOutputData(0, r);
    }, "onExecute");
    this.registerNodeType(name, classobj);
  }
  /**
   * Removes all previously registered node's types
   */
  clearRegisteredTypes() {
    this.registered_node_types = {};
    this.node_types_by_file_extension = {};
    this.Nodes = {};
    this.searchbox_extras = {};
  }
  /**
   * Adds this method to all nodetypes, existing and to be created
   * (You can add it to LGraphNode.prototype but then existing node types wont have it)
   * @param {Function} func
   */
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  addNodeMethod(name, func) {
    LGraphNode.prototype[name] = func;
    for (const i2 in this.registered_node_types) {
      const type = this.registered_node_types[i2];
      if (type.prototype[name]) type.prototype["_" + name] = type.prototype[name];
      type.prototype[name] = func;
    }
  }
  /**
   * Create a node of a given type with a name. The node is not attached to any graph yet.
   * @param {String} type full name of the node class. p.e. "math/sin"
   * @param {String} name a name to distinguish from other nodes
   * @param {Object} options to set options
   */
  createNode(type, title, options3) {
    const base_class = this.registered_node_types[type];
    if (!base_class) {
      if (this.debug) console.log(`GraphNode type "${type}" not registered.`);
      return null;
    }
    title = title || base_class.title || type;
    let node22 = null;
    if (this.catch_exceptions) {
      try {
        node22 = new base_class(title);
      } catch (err) {
        console.error(err);
        return null;
      }
    } else {
      node22 = new base_class(title);
    }
    node22.type = type;
    if (!node22.title && title) node22.title = title;
    node22.properties ||= {};
    node22.properties_info ||= [];
    node22.flags ||= {};
    node22.size ||= node22.computeSize();
    node22.pos ||= this.DEFAULT_POSITION.concat();
    node22.mode ||= LGraphEventMode.ALWAYS;
    if (options3) {
      for (const i2 in options3) {
        node22[i2] = options3[i2];
      }
    }
    node22.onNodeCreated?.();
    return node22;
  }
  /**
   * Returns a registered node type with a given name
   * @param {String} type full name of the node class. p.e. "math/sin"
   * @return {Class} the node class
   */
  getNodeType(type) {
    return this.registered_node_types[type];
  }
  /**
   * Returns a list of node types matching one category
   * @param {String} category category name
   * @return {Array} array with all the node classes
   */
  getNodeTypesInCategory(category, filter4) {
    const r = [];
    for (const i2 in this.registered_node_types) {
      const type = this.registered_node_types[i2];
      if (type.filter != filter4) continue;
      if (category == "") {
        if (type.category == null) r.push(type);
      } else if (type.category == category) {
        r.push(type);
      }
    }
    if (this.auto_sort_node_types) {
      r.sort(function(a, b) {
        return a.title.localeCompare(b.title);
      });
    }
    return r;
  }
  /**
   * Returns a list with all the node type categories
   * @param {String} filter only nodes with ctor.filter equal can be shown
   * @return {Array} array with all the names of the categories
   */
  getNodeTypesCategories(filter4) {
    const categories = { "": 1 };
    for (const i2 in this.registered_node_types) {
      const type = this.registered_node_types[i2];
      if (type.category && !type.skip_list) {
        if (type.filter != filter4)
          continue;
        categories[type.category] = 1;
      }
    }
    const result = [];
    for (const i2 in categories) {
      result.push(i2);
    }
    return this.auto_sort_node_types ? result.sort() : result;
  }
  //debug purposes: reloads all the js scripts that matches a wildcard
  reloadNodes(folder_wildcard) {
    const tmp = document.getElementsByTagName("script");
    const script_files = [];
    for (let i2 = 0; i2 < tmp.length; i2++) {
      script_files.push(tmp[i2]);
    }
    const docHeadObj = document.getElementsByTagName("head")[0];
    folder_wildcard = document.location.href + folder_wildcard;
    for (let i2 = 0; i2 < script_files.length; i2++) {
      const src = script_files[i2].src;
      if (!src || src.substr(0, folder_wildcard.length) != folder_wildcard)
        continue;
      try {
        if (this.debug) console.log("Reloading: " + src);
        const dynamicScript = document.createElement("script");
        dynamicScript.type = "text/javascript";
        dynamicScript.src = src;
        docHeadObj.appendChild(dynamicScript);
        docHeadObj.removeChild(script_files[i2]);
      } catch (err) {
        if (this.throw_errors) throw err;
        if (this.debug) console.log("Error while reloading " + src);
      }
    }
    if (this.debug) console.log("Nodes reloaded");
  }
  //separated just to improve if it doesn't work
  cloneObject(obj, target) {
    if (obj == null) return null;
    const r = JSON.parse(JSON.stringify(obj));
    if (!target) return r;
    for (const i2 in r) {
      target[i2] = r[i2];
    }
    return target;
  }
  /*
   * https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670
   */
  uuidv4() {
    return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (a) => (a ^ Math.random() * 16 >> a / 4).toString(16));
  }
  /**
   * Returns if the types of two slots are compatible (taking into account wildcards, etc)
   * @param {String} type_a output
   * @param {String} type_b input
   * @return {Boolean} true if they can be connected
   */
  isValidConnection(type_a, type_b) {
    if (type_a == "" || type_a === "*") type_a = 0;
    if (type_b == "" || type_b === "*") type_b = 0;
    if (!type_a || !type_b || type_a == type_b || type_a == this.EVENT && type_b == this.ACTION)
      return true;
    type_a = String(type_a);
    type_b = String(type_b);
    type_a = type_a.toLowerCase();
    type_b = type_b.toLowerCase();
    if (type_a.indexOf(",") == -1 && type_b.indexOf(",") == -1)
      return type_a == type_b;
    const supported_types_a = type_a.split(",");
    const supported_types_b = type_b.split(",");
    for (let i2 = 0; i2 < supported_types_a.length; ++i2) {
      for (let j = 0; j < supported_types_b.length; ++j) {
        if (this.isValidConnection(supported_types_a[i2], supported_types_b[j]))
          return true;
      }
    }
    return false;
  }
  /**
   * Register a string in the search box so when the user types it it will recommend this node
   * @param {String} node_type the node recommended
   * @param {String} description text to show next to it
   * @param {Object} data it could contain info of how the node should be configured
   * @return {Boolean} true if they can be connected
   */
  registerSearchboxExtra(node_type, description, data22) {
    this.searchbox_extras[description.toLowerCase()] = {
      type: node_type,
      desc: description,
      data: data22
    };
  }
  /**
   * Wrapper to load files (from url using fetch or from file using FileReader)
   * @param {String|File|Blob} url the url of the file (or the file itself)
   * @param {String} type an string to know how to fetch it: "text","arraybuffer","json","blob"
   * @param {Function} on_complete callback(data)
   * @param {Function} on_error in case of an error
   * @return {FileReader|Promise} returns the object used to
   */
  fetchFile(url, type, on_complete, on_error) {
    if (!url) return null;
    type = type || "text";
    if (typeof url === "string") {
      if (url.substr(0, 4) == "http" && this.proxy)
        url = this.proxy + url.substr(url.indexOf(":") + 3);
      return fetch(url).then(function(response) {
        if (!response.ok)
          throw new Error("File not found");
        if (type == "arraybuffer")
          return response.arrayBuffer();
        else if (type == "text" || type == "string")
          return response.text();
        else if (type == "json")
          return response.json();
        else if (type == "blob")
          return response.blob();
      }).then(function(data22) {
        on_complete?.(data22);
      }).catch(function(error) {
        console.error("error fetching file:", url);
        on_error?.(error);
      });
    } else if (url instanceof File || url instanceof Blob) {
      const reader = new FileReader();
      reader.onload = function(e) {
        let v2 = e.target.result;
        if (type == "json")
          v2 = JSON.parse(v2);
        on_complete?.(v2);
      };
      if (type == "arraybuffer")
        return reader.readAsArrayBuffer(url);
      else if (type == "text" || type == "json")
        return reader.readAsText(url);
      else if (type == "blob")
        return reader.readAsBinaryString(url);
    }
    return null;
  }
  //used to create nodes from wrapping functions
  getParameterNames(func) {
    return (func + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean);
  }
  /* helper for interaction: pointer, touch, mouse Listeners
  used by LGraphCanvas DragAndScale ContextMenu*/
  pointerListenerAdd(oDOM, sEvIn, fCall, capture = false) {
    if (!oDOM || !oDOM.addEventListener || !sEvIn || typeof fCall !== "function") return;
    let sMethod = this.pointerevents_method;
    let sEvent = sEvIn;
    if (sMethod == "pointer" && !window.PointerEvent) {
      console.warn("sMethod=='pointer' && !window.PointerEvent");
      console.log("Converting pointer[" + sEvent + "] : down move up cancel enter TO touchstart touchmove touchend, etc ..");
      switch (sEvent) {
        case "down": {
          sMethod = "touch";
          sEvent = "start";
          break;
        }
        case "move": {
          sMethod = "touch";
          break;
        }
        case "up": {
          sMethod = "touch";
          sEvent = "end";
          break;
        }
        case "cancel": {
          sMethod = "touch";
          break;
        }
        case "enter": {
          console.log("debug: Should I send a move event?");
          break;
        }
        default: {
          console.warn("PointerEvent not available in this browser ? The event " + sEvent + " would not be called");
        }
      }
    }
    switch (sEvent) {
      case "down":
      case "up":
      case "move":
      case "over":
      case "out":
      case "enter": {
        oDOM.addEventListener(sMethod + sEvent, fCall, capture);
      }
      case "leave":
      case "cancel":
      case "gotpointercapture":
      case "lostpointercapture": {
        if (sMethod != "mouse") {
          return oDOM.addEventListener(sMethod + sEvent, fCall, capture);
        }
      }
      default:
        return oDOM.addEventListener(sEvent, fCall, capture);
    }
  }
  pointerListenerRemove(oDOM, sEvent, fCall, capture = false) {
    if (!oDOM || !oDOM.removeEventListener || !sEvent || typeof fCall !== "function") return;
    switch (sEvent) {
      case "down":
      case "up":
      case "move":
      case "over":
      case "out":
      case "enter": {
        if (this.pointerevents_method == "pointer" || this.pointerevents_method == "mouse") {
          oDOM.removeEventListener(this.pointerevents_method + sEvent, fCall, capture);
        }
      }
      case "leave":
      case "cancel":
      case "gotpointercapture":
      case "lostpointercapture": {
        if (this.pointerevents_method == "pointer") {
          return oDOM.removeEventListener(this.pointerevents_method + sEvent, fCall, capture);
        }
      }
      default:
        return oDOM.removeEventListener(sEvent, fCall, capture);
    }
  }
  getTime;
  compareObjects(a, b) {
    for (const i2 in a) {
      if (a[i2] != b[i2]) return false;
    }
    return true;
  }
  distance = distance;
  colorToString(c) {
    return "rgba(" + Math.round(c[0] * 255).toFixed() + "," + Math.round(c[1] * 255).toFixed() + "," + Math.round(c[2] * 255).toFixed() + "," + (c.length == 4 ? c[3].toFixed(2) : "1.0") + ")";
  }
  isInsideRectangle = isInsideRectangle;
  //[minx,miny,maxx,maxy]
  growBounding(bounding, x2, y2) {
    if (x2 < bounding[0]) {
      bounding[0] = x2;
    } else if (x2 > bounding[2]) {
      bounding[2] = x2;
    }
    if (y2 < bounding[1]) {
      bounding[1] = y2;
    } else if (y2 > bounding[3]) {
      bounding[3] = y2;
    }
  }
  overlapBounding = overlapBounding;
  //point inside bounding box
  isInsideBounding(p2, bb) {
    if (p2[0] < bb[0][0] || p2[1] < bb[0][1] || p2[0] > bb[1][0] || p2[1] > bb[1][1]) {
      return false;
    }
    return true;
  }
  //Convert a hex value to its decimal value - the inputted hex must be in the
  //	format of a hex triplet - the kind we use for HTML colours. The function
  //	will return an array with three values.
  hex2num(hex) {
    if (hex.charAt(0) == "#") {
      hex = hex.slice(1);
    }
    hex = hex.toUpperCase();
    const hex_alphabets = "0123456789ABCDEF";
    const value3 = new Array(3);
    let k = 0;
    let int1, int2;
    for (let i2 = 0; i2 < 6; i2 += 2) {
      int1 = hex_alphabets.indexOf(hex.charAt(i2));
      int2 = hex_alphabets.indexOf(hex.charAt(i2 + 1));
      value3[k] = int1 * 16 + int2;
      k++;
    }
    return value3;
  }
  //Give a array with three values as the argument and the function will return
  //	the corresponding hex triplet.
  num2hex(triplet) {
    const hex_alphabets = "0123456789ABCDEF";
    let hex = "#";
    let int1, int2;
    for (let i2 = 0; i2 < 3; i2++) {
      int1 = triplet[i2] / 16;
      int2 = triplet[i2] % 16;
      hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);
    }
    return hex;
  }
  closeAllContextMenus(ref_window2) {
    ref_window2 = ref_window2 || window;
    const elements = ref_window2.document.querySelectorAll(".litecontextmenu");
    if (!elements.length) return;
    const result = [];
    for (let i2 = 0; i2 < elements.length; i2++) {
      result.push(elements[i2]);
    }
    for (let i2 = 0; i2 < result.length; i2++) {
      if (result[i2].close) {
        result[i2].close();
      } else if (result[i2].parentNode) {
        result[i2].parentNode.removeChild(result[i2]);
      }
    }
  }
  extendClass(target, origin2) {
    for (const i2 in origin2) {
      if (target.hasOwnProperty(i2)) continue;
      target[i2] = origin2[i2];
    }
    if (origin2.prototype) {
      for (const i2 in origin2.prototype) {
        if (!origin2.prototype.hasOwnProperty(i2)) continue;
        if (target.prototype.hasOwnProperty(i2)) continue;
        if (origin2.prototype.__lookupGetter__(i2)) {
          target.prototype.__defineGetter__(
            i2,
            origin2.prototype.__lookupGetter__(i2)
          );
        } else {
          target.prototype[i2] = origin2.prototype[i2];
        }
        if (origin2.prototype.__lookupSetter__(i2)) {
          target.prototype.__defineSetter__(
            i2,
            origin2.prototype.__lookupSetter__(i2)
          );
        }
      }
    }
  }
}
function loadPolyfills() {
  if (typeof window != "undefined" && window.CanvasRenderingContext2D && !window.CanvasRenderingContext2D.prototype.roundRect) {
    window.CanvasRenderingContext2D.prototype.roundRect = function(x2, y2, w2, h2, radius, radius_low) {
      let top_left_radius = 0;
      let top_right_radius = 0;
      let bottom_left_radius = 0;
      let bottom_right_radius = 0;
      if (radius === 0) {
        this.rect(x2, y2, w2, h2);
        return;
      }
      if (radius_low === void 0)
        radius_low = radius;
      if (radius != null && radius.constructor === Array) {
        if (radius.length == 1)
          top_left_radius = top_right_radius = bottom_left_radius = bottom_right_radius = radius[0];
        else if (radius.length == 2) {
          top_left_radius = bottom_right_radius = radius[0];
          top_right_radius = bottom_left_radius = radius[1];
        } else if (radius.length == 4) {
          top_left_radius = radius[0];
          top_right_radius = radius[1];
          bottom_left_radius = radius[2];
          bottom_right_radius = radius[3];
        } else
          return;
      } else {
        top_left_radius = radius || 0;
        top_right_radius = radius || 0;
        bottom_left_radius = radius_low || 0;
        bottom_right_radius = radius_low || 0;
      }
      this.moveTo(x2 + top_left_radius, y2);
      this.lineTo(x2 + w2 - top_right_radius, y2);
      this.quadraticCurveTo(x2 + w2, y2, x2 + w2, y2 + top_right_radius);
      this.lineTo(x2 + w2, y2 + h2 - bottom_right_radius);
      this.quadraticCurveTo(
        x2 + w2,
        y2 + h2,
        x2 + w2 - bottom_right_radius,
        y2 + h2
      );
      this.lineTo(x2 + bottom_right_radius, y2 + h2);
      this.quadraticCurveTo(x2, y2 + h2, x2, y2 + h2 - bottom_left_radius);
      this.lineTo(x2, y2 + bottom_left_radius);
      this.quadraticCurveTo(x2, y2, x2 + top_left_radius, y2);
    };
  }
  if (typeof window != "undefined" && !window["requestAnimationFrame"]) {
    window.requestAnimationFrame = // @ts-expect-error Legacy code
    window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
      window.setTimeout(callback, 1e3 / 60);
    };
  }
}
__name(loadPolyfills, "loadPolyfills");
const LiteGraph = new LiteGraphGlobal();
function clamp$1(v2, a, b) {
  return a > v2 ? a : b < v2 ? b : v2;
}
__name(clamp$1, "clamp$1");
loadPolyfills();
const CORE_SETTINGS = [
  {
    id: "Comfy.Validation.Workflows",
    name: "Validate workflows",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.NodeSearchBoxImpl",
    category: ["Comfy", "Node Search Box", "Implementation"],
    experimental: true,
    name: "Node search box implementation",
    type: "combo",
    options: ["default", "litegraph (legacy)"],
    defaultValue: "default"
  },
  {
    id: "Comfy.NodeSearchBoxImpl.LinkReleaseTrigger",
    category: ["Comfy", "Node Search Box", "LinkReleaseTrigger"],
    name: "Trigger on link release",
    type: "hidden",
    options: Object.values(LinkReleaseTriggerMode),
    defaultValue: LinkReleaseTriggerMode.ALWAYS,
    deprecated: true
  },
  {
    id: "Comfy.LinkRelease.Action",
    name: "Action on link release (No modifier)",
    type: "combo",
    options: Object.values(LinkReleaseTriggerAction),
    defaultValue: LinkReleaseTriggerAction.CONTEXT_MENU
  },
  {
    id: "Comfy.LinkRelease.ActionShift",
    name: "Action on link release (Shift)",
    type: "combo",
    options: Object.values(LinkReleaseTriggerAction),
    defaultValue: LinkReleaseTriggerAction.SEARCH_BOX
  },
  {
    id: "Comfy.NodeSearchBoxImpl.NodePreview",
    category: ["Comfy", "Node Search Box", "NodePreview"],
    name: "Node preview",
    tooltip: "Only applies to the default implementation",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.NodeSearchBoxImpl.ShowCategory",
    category: ["Comfy", "Node Search Box", "ShowCategory"],
    name: "Show node category in search results",
    tooltip: "Only applies to the default implementation",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.NodeSearchBoxImpl.ShowIdName",
    category: ["Comfy", "Node Search Box", "ShowIdName"],
    name: "Show node id name in search results",
    tooltip: "Only applies to the default implementation",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.NodeSearchBoxImpl.ShowNodeFrequency",
    category: ["Comfy", "Node Search Box", "ShowNodeFrequency"],
    name: "Show node frequency in search results",
    tooltip: "Only applies to the default implementation",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.Sidebar.Location",
    category: ["Comfy", "Sidebar", "Location"],
    name: "Sidebar location",
    type: "combo",
    options: ["left", "right"],
    defaultValue: "left"
  },
  {
    id: "Comfy.Sidebar.Size",
    category: ["Comfy", "Sidebar", "Size"],
    name: "Sidebar size",
    type: "combo",
    options: ["normal", "small"],
    defaultValue: window.innerWidth < 1600 ? "small" : "normal"
  },
  {
    id: "Comfy.TextareaWidget.FontSize",
    category: ["Comfy", "Node Widget", "TextareaWidget", "FontSize"],
    name: "Textarea widget font size",
    type: "slider",
    defaultValue: 10,
    attrs: {
      min: 8,
      max: 24
    }
  },
  {
    id: "Comfy.TextareaWidget.Spellcheck",
    category: ["Comfy", "Node Widget", "TextareaWidget", "Spellcheck"],
    name: "Textarea widget spellcheck",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.Workflow.SortNodeIdOnSave",
    name: "Sort node IDs when saving workflow",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.Graph.CanvasInfo",
    name: "Show canvas info (fps, etc.)",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.Node.ShowDeprecated",
    name: "Show deprecated nodes in search",
    tooltip: "Deprecated nodes are hidden by default in the UI, but remain functional in existing workflows that use them.",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.Node.ShowExperimental",
    name: "Show experimental nodes in search",
    tooltip: "Experimental nodes are marked as such in the UI and may be subject to significant changes or removal in future versions. Use with caution in production workflows",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.Node.Opacity",
    name: "Node opacity",
    type: "slider",
    defaultValue: 1,
    attrs: {
      min: 0.01,
      max: 1,
      step: 0.01
    }
  },
  {
    id: "Comfy.Workflow.ShowMissingNodesWarning",
    name: "Show missing nodes warning",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.Workflow.ShowMissingModelsWarning",
    name: "Show missing models warning",
    type: "boolean",
    defaultValue: false,
    experimental: true
  },
  {
    id: "Comfy.Graph.ZoomSpeed",
    name: "Canvas zoom speed",
    type: "slider",
    defaultValue: 1.1,
    attrs: {
      min: 1.01,
      max: 2.5,
      step: 0.01
    }
  },
  // Bookmarks are stored in the settings store.
  // Bookmarks are in format of category/display_name. e.g. "conditioning/CLIPTextEncode"
  {
    id: "Comfy.NodeLibrary.Bookmarks",
    name: "Node library bookmarks with display name (deprecated)",
    type: "hidden",
    defaultValue: [],
    deprecated: true
  },
  {
    id: "Comfy.NodeLibrary.Bookmarks.V2",
    name: "Node library bookmarks v2 with unique name",
    type: "hidden",
    defaultValue: []
  },
  // Stores mapping from bookmark folder name to its customization.
  {
    id: "Comfy.NodeLibrary.BookmarksCustomization",
    name: "Node library bookmarks customization",
    type: "hidden",
    defaultValue: {}
  },
  // Hidden setting used by the queue for how to fit images
  {
    id: "Comfy.Queue.ImageFit",
    name: "Queue image fit",
    type: "hidden",
    defaultValue: "cover"
  },
  {
    id: "Comfy.GroupSelectedNodes.Padding",
    name: "Group selected nodes padding",
    type: "slider",
    defaultValue: 10,
    attrs: {
      min: 0,
      max: 100
    }
  },
  {
    id: "Comfy.Node.DoubleClickTitleToEdit",
    name: "Double click node title to edit",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.Group.DoubleClickTitleToEdit",
    name: "Double click group title to edit",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.Window.UnloadConfirmation",
    name: "Show confirmation when closing window",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.TreeExplorer.ItemPadding",
    name: "Tree explorer item padding",
    type: "slider",
    defaultValue: 2,
    attrs: {
      min: 0,
      max: 8,
      step: 1
    }
  },
  {
    id: "Comfy.ModelLibrary.AutoLoadAll",
    name: "Automatically load all model folders",
    tooltip: "If true, all folders will load as soon as you open the model library (this may cause delays while it loads). If false, root level model folders will only load once you click on them.",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.ModelLibrary.NameFormat",
    name: "What name to display in the model library tree view",
    tooltip: 'Select "filename" to render a simplified view of the raw filename (without directory or ".safetensors" extension) in the model list. Select "title" to display the configurable model metadata title.',
    type: "combo",
    options: ["filename", "title"],
    defaultValue: "title"
  },
  {
    id: "Comfy.Locale",
    name: "Locale",
    type: "combo",
    options: ["en", "zh", "ru"],
    defaultValue: navigator.language.split("-")[0] || "en"
  },
  {
    id: "Comfy.NodeBadge.NodeSourceBadgeMode",
    name: "Node source badge mode",
    type: "combo",
    options: Object.values(NodeBadgeMode),
    defaultValue: NodeBadgeMode.HideBuiltIn
  },
  {
    id: "Comfy.NodeBadge.NodeIdBadgeMode",
    name: "Node ID badge mode",
    type: "combo",
    options: [NodeBadgeMode.None, NodeBadgeMode.ShowAll],
    defaultValue: NodeBadgeMode.ShowAll
  },
  {
    id: "Comfy.NodeBadge.NodeLifeCycleBadgeMode",
    name: "Node life cycle badge mode",
    type: "combo",
    options: [NodeBadgeMode.None, NodeBadgeMode.ShowAll],
    defaultValue: NodeBadgeMode.ShowAll
  },
  {
    id: "Comfy.ConfirmClear",
    category: ["Comfy", "Workflow", "ConfirmClear"],
    name: "Require confirmation when clearing workflow",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.PromptFilename",
    category: ["Comfy", "Workflow", "PromptFilename"],
    name: "Prompt for filename when saving workflow",
    type: "boolean",
    defaultValue: true
  },
  /**
   * file format for preview
   *
   * format;quality
   *
   * ex)
   * webp;50 -> webp, quality 50
   * jpeg;80 -> rgb, jpeg, quality 80
   *
   * @type {string}
   */
  {
    id: "Comfy.PreviewFormat",
    category: ["Comfy", "Node Widget", "PreviewFormat"],
    name: "Preview image format",
    tooltip: "When displaying a preview in the image widget, convert it to a lightweight image, e.g. webp, jpeg, webp;50, etc.",
    type: "text",
    defaultValue: ""
  },
  {
    id: "Comfy.DisableSliders",
    category: ["Comfy", "Node Widget", "DisableSliders"],
    name: "Disable node widget sliders",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.DisableFloatRounding",
    category: ["Comfy", "Node Widget", "DisableFloatRounding"],
    name: "Disable default float widget rounding.",
    tooltip: "(requires page reload) Cannot disable round when round is set by the node in the backend.",
    type: "boolean",
    defaultValue: false
  },
  {
    id: "Comfy.FloatRoundingPrecision",
    category: ["Comfy", "Node Widget", "FloatRoundingPrecision"],
    name: "Float widget rounding decimal places [0 = auto].",
    tooltip: "(requires page reload)",
    type: "slider",
    attrs: {
      min: 0,
      max: 6,
      step: 1
    },
    defaultValue: 0
  },
  {
    id: "Comfy.EnableTooltips",
    category: ["Comfy", "Node", "EnableTooltips"],
    name: "Enable Tooltips",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.DevMode",
    name: "Enable dev mode options (API save, etc.)",
    type: "boolean",
    defaultValue: false,
    onChange: /* @__PURE__ */ __name((value3) => {
      const element = document.getElementById("comfy-dev-save-api-button");
      if (element) {
        element.style.display = value3 ? "flex" : "none";
      }
    }, "onChange")
  },
  {
    id: "Comfy.UseNewMenu",
    category: ["Comfy", "Menu", "UseNewMenu"],
    defaultValue: "Top",
    name: "Use new menu",
    type: "combo",
    options: ["Disabled", "Top", "Bottom"],
    migrateDeprecatedValue: /* @__PURE__ */ __name((value3) => {
      if (value3 === "Floating") {
        return "Top";
      }
      return value3;
    }, "migrateDeprecatedValue")
  },
  {
    id: "Comfy.Workflow.WorkflowTabsPosition",
    name: "Opened workflows position",
    type: "combo",
    options: ["Sidebar", "Topbar"],
    defaultValue: "Sidebar"
  },
  {
    id: "Comfy.Graph.CanvasMenu",
    name: "Show graph canvas menu",
    type: "boolean",
    defaultValue: true
  },
  {
    id: "Comfy.QueueButton.BatchCountLimit",
    name: "Batch count limit",
    tooltip: "The maximum number of tasks added to the queue at one button click",
    type: "number",
    defaultValue: 100,
    versionAdded: "1.3.5"
  },
  {
    id: "Comfy.Keybinding.UnsetBindings",
    name: "Keybindings unset by the user",
    type: "hidden",
    defaultValue: [],
    versionAdded: "1.3.7"
  },
  {
    id: "Comfy.Keybinding.NewBindings",
    name: "Keybindings set by the user",
    type: "hidden",
    defaultValue: [],
    versionAdded: "1.3.7"
  },
  {
    id: "Comfy.Extension.Disabled",
    name: "Disabled extension names",
    type: "hidden",
    defaultValue: [],
    versionAdded: "1.3.11"
  },
  {
    id: "Comfy.Settings.ExtensionPanel",
    name: "Show extension panel in settings dialog",
    type: "boolean",
    defaultValue: false,
    experimental: true,
    versionAdded: "1.3.11"
  },
  {
    id: "Comfy.Validation.NodeDefs",
    name: "Validate node definitions (slow)",
    type: "boolean",
    tooltip: "Recommended for node developers. This will validate all node definitions on startup.",
    defaultValue: false,
    versionAdded: "1.3.14"
  },
  {
    id: "Comfy.LinkRenderMode",
    category: ["Comfy", "Graph", "LinkRenderMode"],
    name: "Link Render Mode",
    defaultValue: 2,
    type: "combo",
    options: [
      { value: LiteGraph.STRAIGHT_LINK, text: "Straight" },
      { value: LiteGraph.LINEAR_LINK, text: "Linear" },
      { value: LiteGraph.SPLINE_LINK, text: "Spline" },
      { value: LiteGraph.HIDDEN_LINK, text: "Hidden" }
    ]
  },
  {
    id: "Comfy.Node.AutoSnapLinkToSlot",
    name: "Auto snap link to node slot",
    tooltip: "When dragging a link over a node, the link automatically snap to a viable input slot on the node",
    type: "boolean",
    defaultValue: true,
    versionAdded: "1.3.29"
  },
  {
    id: "Comfy.Node.SnapHighlightsNode",
    name: "Snap highlights node",
    tooltip: "When dragging a link over a node with viable input slot, highlight the node",
    type: "boolean",
    defaultValue: true,
    versionAdded: "1.3.29"
  },
  {
    id: "Comfy.Node.BypassAllLinksOnDelete",
    name: "Keep all links when deleting nodes",
    tooltip: "When deleting a node, attempt to reconnect all of its input and output links (bypassing the deleted node)",
    type: "boolean",
    defaultValue: true,
    versionAdded: "1.3.40"
  },
  {
    id: "Comfy.Node.MiddleClickRerouteNode",
    name: "Middle-click creates a new Reroute node",
    type: "boolean",
    defaultValue: true,
    versionAdded: "1.3.42"
  },
  {
    id: "Comfy.RerouteBeta",
    name: "Opt-in to the reroute beta test",
    tooltip: "Enables the new native reroutes.\n\nReroutes can be added by holding alt and dragging from a link line, or on the link menu.\n\nDisabling this option is non-destructive - reroutes are hidden.",
    experimental: true,
    type: "boolean",
    defaultValue: false,
    versionAdded: "1.3.42"
  },
  {
    id: "Comfy.Graph.LinkMarkers",
    name: "Link midpoint markers",
    defaultValue: LinkMarkerShape.Circle,
    type: "combo",
    options: [
      { value: LinkMarkerShape.None, text: "None" },
      { value: LinkMarkerShape.Circle, text: "Circle" },
      { value: LinkMarkerShape.Arrow, text: "Arrow" }
    ],
    versionAdded: "1.3.42"
  },
  {
    id: "Comfy.DOMClippingEnabled",
    category: ["Comfy", "Node", "DOMClippingEnabled"],
    name: "Enable DOM element clipping (enabling may reduce performance)",
    type: "boolean",
    defaultValue: true
  }
];
const useSettingStore = /* @__PURE__ */ defineStore("setting", () => {
  const settingValues = ref({});
  const settings = ref({});
  const settingTree = computed(() => {
    const root23 = buildTree(
      Object.values(settings.value).filter(
        (setting) => setting.type !== "hidden"
      ),
      (setting) => setting.category || setting.id.split(".")
    );
    const floatingSettings = (root23.children ?? []).filter((node3) => node3.leaf);
    if (floatingSettings.length) {
      root23.children = (root23.children ?? []).filter((node3) => !node3.leaf);
      root23.children.push({
        key: "Other",
        label: "Other",
        leaf: false,
        children: floatingSettings
      });
    }
    return root23;
  });
  function addSettings(settingsDialog) {
    for (const id3 in settingsDialog.settingsLookup) {
      const value3 = settingsDialog.getSettingValue(id3);
      settingValues.value[id3] = value3;
    }
    settings.value = settingsDialog.settingsParamLookup;
    CORE_SETTINGS.forEach((setting) => {
      settingsDialog.addSetting(setting);
    });
  }
  __name(addSettings, "addSettings");
  function loadExtensionSettings(extension) {
    extension.settings?.forEach((setting) => {
      app$1.ui.settings.addSetting(setting);
    });
  }
  __name(loadExtensionSettings, "loadExtensionSettings");
  function exists(key) {
    return settingValues.value[key] !== void 0;
  }
  __name(exists, "exists");
  async function set2(key, value3) {
    settingValues.value[key] = value3;
    await app$1.ui.settings.setSettingValueAsync(key, value3);
  }
  __name(set2, "set");
  function get2(key) {
    return settingValues.value[key] ?? app$1.ui.settings.getSettingDefaultValue(key);
  }
  __name(get2, "get");
  return {
    settingValues,
    settings,
    settingTree,
    addSettings,
    loadExtensionSettings,
    set: set2,
    get: get2,
    exists
  };
});
class ComfySettingsDialog extends ComfyDialog$1 {
  static {
    __name(this, "ComfySettingsDialog");
  }
  app;
  settingsValues;
  settingsLookup;
  settingsParamLookup;
  constructor(app2) {
    super();
    this.app = app2;
    this.settingsValues = {};
    this.settingsLookup = {};
    this.settingsParamLookup = {};
  }
  get settings() {
    return Object.values(this.settingsLookup);
  }
  tryMigrateDeprecatedValue(id3, value3) {
    if (this.app.vueAppReady) {
      const settingStore = useSettingStore();
      const setting = settingStore.settings[id3];
      if (setting?.migrateDeprecatedValue) {
        return setting.migrateDeprecatedValue(value3);
      }
    }
    return value3;
  }
  #dispatchChange(id3, value3, oldValue) {
    if (this.app.vueAppReady) {
      useSettingStore().settingValues[id3] = value3;
    }
    this.dispatchEvent(
      new CustomEvent(id3 + ".change", {
        detail: {
          value: value3,
          oldValue
        }
      })
    );
  }
  async load() {
    if (this.app.storageLocation === "browser") {
      this.settingsValues = localStorage;
    } else {
      this.settingsValues = await api.getSettings();
    }
    for (const id3 in this.settingsLookup) {
      const compatId = this.getId(id3);
      this.settingsValues[compatId] = this.tryMigrateDeprecatedValue(
        id3,
        this.settingsValues[compatId]
      );
      const value3 = this.settingsValues[compatId];
      this.settingsLookup[id3].onChange?.(value3);
      this.#dispatchChange(id3, value3);
    }
  }
  getId(id3) {
    if (this.app.storageLocation === "browser") {
      id3 = "Comfy.Settings." + id3;
    }
    return id3;
  }
  getSettingValue(id3, defaultValue) {
    let value3 = this.settingsValues[this.getId(id3)];
    if (value3 != null) {
      if (this.app.storageLocation === "browser") {
        try {
          value3 = JSON.parse(value3);
        } catch (error) {
        }
      }
    }
    return value3 ?? defaultValue;
  }
  getSettingDefaultValue(id3) {
    const param = this.settingsParamLookup[id3];
    return param?.defaultValue;
  }
  async setSettingValueAsync(id3, value3) {
    value3 = this.tryMigrateDeprecatedValue(id3, value3);
    const json = JSON.stringify(value3);
    localStorage["Comfy.Settings." + id3] = json;
    let oldValue = this.getSettingValue(id3, void 0);
    this.settingsValues[this.getId(id3)] = value3;
    if (id3 in this.settingsLookup) {
      this.settingsLookup[id3].onChange?.(value3, oldValue);
    }
    this.#dispatchChange(id3, value3, oldValue);
    await api.storeSetting(id3, value3);
  }
  setSettingValue(id3, value3) {
    this.setSettingValueAsync(id3, value3).catch((err) => {
      useToastStore().addAlert(`Error saving setting '${id3}': ${err}`);
    });
  }
  refreshSetting(id3) {
    const value3 = this.getSettingValue(id3);
    this.settingsLookup[id3].onChange?.(value3);
    this.#dispatchChange(id3, value3);
  }
  /**
   * Deprecated for external callers/extensions. Use `ComfyExtension.settings` field instead.
   * Example:
   * ```ts
   * app.registerExtension({
   *   name: 'My Extension',
   *   settings: [
   *     {
   *       id: 'My.Setting',
   *       name: 'My Setting',
   *       type: 'text',
   *       defaultValue: 'Hello, world!'
   *     }
   *   ]
   * })
   * ```
   */
  addSetting(params) {
    const { id: id3, name, type, defaultValue, onChange: onChange4 } = params;
    if (!id3) {
      throw new Error("Settings must have an ID");
    }
    if (id3 in this.settingsLookup) {
      throw new Error(`Setting ${id3} of type ${type} must have a unique ID.`);
    }
    let value3 = this.getSettingValue(id3);
    if (value3 == null) {
      if (this.app.isNewUserSession) {
        const localValue = localStorage["Comfy.Settings." + id3];
        if (localValue) {
          value3 = JSON.parse(localValue);
          this.setSettingValue(id3, value3);
        }
      }
      if (value3 == null) {
        value3 = defaultValue;
      }
    }
    onChange4?.(value3, void 0);
    this.#dispatchChange(id3, value3);
    this.settingsParamLookup[id3] = params;
    if (this.app.vueAppReady) {
      useSettingStore().settings[id3] = params;
    }
    this.settingsLookup[id3] = {
      id: id3,
      onChange: onChange4,
      name,
      render: /* @__PURE__ */ __name(() => {
        console.warn("[ComfyUI] Setting render is deprecated", id3);
      }, "render")
    };
    const self2 = this;
    return {
      get value() {
        return self2.getSettingValue(id3, defaultValue);
      },
      set value(v2) {
        self2.setSettingValue(id3, v2);
      }
    };
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.settings = window.comfyAPI.settings || {};
window.comfyAPI.settings.ComfySettingsDialog = ComfySettingsDialog;
const useDialogStore = /* @__PURE__ */ defineStore("dialog", () => {
  const isVisible2 = ref(false);
  const title = ref("");
  const headerComponent = shallowRef(null);
  const component = shallowRef(null);
  const props = ref({});
  const dialogComponentProps = ref({});
  function showDialog(options3) {
    isVisible2.value = true;
    title.value = options3.title ?? "";
    headerComponent.value = options3.headerComponent ? markRaw(options3.headerComponent) : null;
    component.value = markRaw(options3.component);
    props.value = options3.props || {};
    dialogComponentProps.value = options3.dialogComponentProps || {};
  }
  __name(showDialog, "showDialog");
  function closeDialog() {
    if (dialogComponentProps.value.onClose) {
      dialogComponentProps.value.onClose();
    }
    isVisible2.value = false;
  }
  __name(closeDialog, "closeDialog");
  return {
    isVisible: isVisible2,
    title,
    headerComponent,
    component,
    props,
    dialogComponentProps,
    showDialog,
    closeDialog
  };
});
function hasClass(element, className) {
  if (element) {
    if (element.classList) return element.classList.contains(className);
    else return new RegExp("(^| )" + className + "( |$)", "gi").test(element.className);
  }
  return false;
}
__name(hasClass, "hasClass");
function addClass(element, className) {
  if (element && className) {
    const fn = /* @__PURE__ */ __name((_className) => {
      if (!hasClass(element, _className)) {
        if (element.classList) element.classList.add(_className);
        else element.className += " " + _className;
      }
    }, "fn");
    [className].flat().filter(Boolean).forEach((_classNames) => _classNames.split(" ").forEach(fn));
  }
}
__name(addClass, "addClass");
function calculateBodyScrollbarWidth() {
  return window.innerWidth - document.documentElement.offsetWidth;
}
__name(calculateBodyScrollbarWidth, "calculateBodyScrollbarWidth");
function getCSSVariableByRegex(variableRegex) {
  for (const sheet of document == null ? void 0 : document.styleSheets) {
    try {
      for (const rule of sheet == null ? void 0 : sheet.cssRules) {
        for (const property of rule == null ? void 0 : rule.style) {
          if (variableRegex.test(property)) {
            return { name: property, value: rule.style.getPropertyValue(property).trim() };
          }
        }
      }
    } catch (e) {
    }
  }
  return null;
}
__name(getCSSVariableByRegex, "getCSSVariableByRegex");
function blockBodyScroll(className = "p-overflow-hidden") {
  const variableData = getCSSVariableByRegex(/-scrollbar-width$/);
  (variableData == null ? void 0 : variableData.name) && document.body.style.setProperty(variableData.name, calculateBodyScrollbarWidth() + "px");
  addClass(document.body, className);
}
__name(blockBodyScroll, "blockBodyScroll");
function saveAs(file) {
  if (file) {
    let link = document.createElement("a");
    if (link.download !== void 0) {
      const { name, src } = file;
      link.setAttribute("href", src);
      link.setAttribute("download", name);
      link.style.display = "none";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      return true;
    }
  }
  return false;
}
__name(saveAs, "saveAs");
function exportCSV(csv, filename) {
  let blob = new Blob([csv], {
    type: "application/csv;charset=utf-8;"
  });
  if (window.navigator.msSaveOrOpenBlob) {
    navigator.msSaveOrOpenBlob(blob, filename + ".csv");
  } else {
    const isDownloaded = saveAs({ name: filename + ".csv", src: URL.createObjectURL(blob) });
    if (!isDownloaded) {
      csv = "data:text/csv;charset=utf-8," + csv;
      window.open(encodeURI(csv));
    }
  }
}
__name(exportCSV, "exportCSV");
function removeClass(element, className) {
  if (element && className) {
    const fn = /* @__PURE__ */ __name((_className) => {
      if (element.classList) element.classList.remove(_className);
      else element.className = element.className.replace(new RegExp("(^|\\b)" + _className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    }, "fn");
    [className].flat().filter(Boolean).forEach((_classNames) => _classNames.split(" ").forEach(fn));
  }
}
__name(removeClass, "removeClass");
function unblockBodyScroll(className = "p-overflow-hidden") {
  const variableData = getCSSVariableByRegex(/-scrollbar-width$/);
  (variableData == null ? void 0 : variableData.name) && document.body.style.removeProperty(variableData.name);
  removeClass(document.body, className);
}
__name(unblockBodyScroll, "unblockBodyScroll");
function getHiddenElementDimensions(element) {
  let dimensions = { width: 0, height: 0 };
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    dimensions.width = element.offsetWidth;
    dimensions.height = element.offsetHeight;
    element.style.display = "none";
    element.style.visibility = "visible";
  }
  return dimensions;
}
__name(getHiddenElementDimensions, "getHiddenElementDimensions");
function getViewport() {
  let win = window, d = document, e = d.documentElement, g = d.getElementsByTagName("body")[0], w2 = win.innerWidth || e.clientWidth || g.clientWidth, h2 = win.innerHeight || e.clientHeight || g.clientHeight;
  return { width: w2, height: h2 };
}
__name(getViewport, "getViewport");
function getWindowScrollLeft() {
  let doc2 = document.documentElement;
  return (window.pageXOffset || doc2.scrollLeft) - (doc2.clientLeft || 0);
}
__name(getWindowScrollLeft, "getWindowScrollLeft");
function getWindowScrollTop() {
  let doc2 = document.documentElement;
  return (window.pageYOffset || doc2.scrollTop) - (doc2.clientTop || 0);
}
__name(getWindowScrollTop, "getWindowScrollTop");
function absolutePosition(element, target, gutter = true) {
  var _a, _b, _c, _d;
  if (element) {
    const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);
    const elementOuterHeight = elementDimensions.height;
    const elementOuterWidth = elementDimensions.width;
    const targetOuterHeight = target.offsetHeight;
    const targetOuterWidth = target.offsetWidth;
    const targetOffset = target.getBoundingClientRect();
    const windowScrollTop = getWindowScrollTop();
    const windowScrollLeft = getWindowScrollLeft();
    const viewport = getViewport();
    let top, left, origin2 = "top";
    if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
      top = targetOffset.top + windowScrollTop - elementOuterHeight;
      origin2 = "bottom";
      if (top < 0) {
        top = windowScrollTop;
      }
    } else {
      top = targetOuterHeight + targetOffset.top + windowScrollTop;
    }
    if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);
    else left = targetOffset.left + windowScrollLeft;
    element.style.top = top + "px";
    element.style.left = left + "px";
    element.style.transformOrigin = origin2;
    gutter && (element.style.marginTop = origin2 === "bottom" ? `calc(${(_b = (_a = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a.value) != null ? _b : "2px"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : "");
  }
}
__name(absolutePosition, "absolutePosition");
function addStyle(element, style) {
  if (element) {
    if (typeof style === "string") {
      element.style.cssText = style;
    } else {
      Object.entries(style || {}).forEach(([key, value3]) => element.style[key] = value3);
    }
  }
}
__name(addStyle, "addStyle");
function getOuterWidth(element, margin) {
  if (element instanceof HTMLElement) {
    let width2 = element.offsetWidth;
    if (margin) {
      let style = getComputedStyle(element);
      width2 += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    }
    return width2;
  }
  return 0;
}
__name(getOuterWidth, "getOuterWidth");
function relativePosition(element, target, gutter = true) {
  var _a, _b, _c, _d;
  if (element) {
    const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);
    const targetHeight = target.offsetHeight;
    const targetOffset = target.getBoundingClientRect();
    const viewport = getViewport();
    let top, left, origin2 = "top";
    if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {
      top = -1 * elementDimensions.height;
      origin2 = "bottom";
      if (targetOffset.top + top < 0) {
        top = -1 * targetOffset.top;
      }
    } else {
      top = targetHeight;
    }
    if (elementDimensions.width > viewport.width) {
      left = targetOffset.left * -1;
    } else if (targetOffset.left + elementDimensions.width > viewport.width) {
      left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;
    } else {
      left = 0;
    }
    element.style.top = top + "px";
    element.style.left = left + "px";
    element.style.transformOrigin = origin2;
    gutter && (element.style.marginTop = origin2 === "bottom" ? `calc(${(_b = (_a = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a.value) != null ? _b : "2px"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : "");
  }
}
__name(relativePosition, "relativePosition");
function alignOverlay(overlay, target, appendTo, calculateMinWidth = true) {
  if (overlay && target) {
    if (appendTo === "self") {
      relativePosition(overlay, target);
    } else {
      calculateMinWidth && (overlay.style.minWidth = getOuterWidth(target) + "px");
      absolutePosition(overlay, target);
    }
  }
}
__name(alignOverlay, "alignOverlay");
function isElement(element) {
  return typeof HTMLElement === "object" ? element instanceof HTMLElement : element && typeof element === "object" && element !== null && element.nodeType === 1 && typeof element.nodeName === "string";
}
__name(isElement, "isElement");
function toElement(element) {
  let target = element;
  if (element && typeof element === "object") {
    if (element.hasOwnProperty("current")) {
      target = element.current;
    } else if (element.hasOwnProperty("el")) {
      if (element.el.hasOwnProperty("nativeElement")) {
        target = element.el.nativeElement;
      } else {
        target = element.el;
      }
    }
  }
  return isElement(target) ? target : void 0;
}
__name(toElement, "toElement");
function appendChild(element, child) {
  const target = toElement(element);
  if (target) target.appendChild(child);
  else throw new Error("Cannot append " + child + " to " + element);
}
__name(appendChild, "appendChild");
var calculatedScrollbarHeight = void 0;
function calculateScrollbarHeight(element) {
  if (element) {
    let style = getComputedStyle(element);
    return element.offsetHeight - element.clientHeight - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth);
  } else {
    if (calculatedScrollbarHeight != null) return calculatedScrollbarHeight;
    let scrollDiv = document.createElement("div");
    addStyle(scrollDiv, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-9999px"
    });
    document.body.appendChild(scrollDiv);
    let scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;
    document.body.removeChild(scrollDiv);
    calculatedScrollbarHeight = scrollbarHeight;
    return scrollbarHeight;
  }
}
__name(calculateScrollbarHeight, "calculateScrollbarHeight");
var calculatedScrollbarWidth = void 0;
function calculateScrollbarWidth(element) {
  if (element) {
    let style = getComputedStyle(element);
    return element.offsetWidth - element.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);
  } else {
    if (calculatedScrollbarWidth != null) return calculatedScrollbarWidth;
    let scrollDiv = document.createElement("div");
    addStyle(scrollDiv, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-9999px"
    });
    document.body.appendChild(scrollDiv);
    let scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    calculatedScrollbarWidth = scrollbarWidth;
    return scrollbarWidth;
  }
}
__name(calculateScrollbarWidth, "calculateScrollbarWidth");
function clearSelection() {
  if (window.getSelection) {
    const selection = window.getSelection() || {};
    if (selection.empty) {
      selection.empty();
    } else if (selection.removeAllRanges && selection.rangeCount > 0 && selection.getRangeAt(0).getClientRects().length > 0) {
      selection.removeAllRanges();
    }
  }
}
__name(clearSelection, "clearSelection");
function setAttributes(element, attributes = {}) {
  if (isElement(element)) {
    const computedStyles = /* @__PURE__ */ __name((rule, value3) => {
      var _a, _b;
      const styles = ((_a = element == null ? void 0 : element.$attrs) == null ? void 0 : _a[rule]) ? [(_b = element == null ? void 0 : element.$attrs) == null ? void 0 : _b[rule]] : [];
      return [value3].flat().reduce((cv, v2) => {
        if (v2 !== null && v2 !== void 0) {
          const type = typeof v2;
          if (type === "string" || type === "number") {
            cv.push(v2);
          } else if (type === "object") {
            const _cv = Array.isArray(v2) ? computedStyles(rule, v2) : Object.entries(v2).map(([_k, _v]) => rule === "style" && (!!_v || _v === 0) ? `${_k.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${_v}` : !!_v ? _k : void 0);
            cv = _cv.length ? cv.concat(_cv.filter((c) => !!c)) : cv;
          }
        }
        return cv;
      }, styles);
    }, "computedStyles");
    Object.entries(attributes).forEach(([key, value3]) => {
      if (value3 !== void 0 && value3 !== null) {
        const matchedEvent = key.match(/^on(.+)/);
        if (matchedEvent) {
          element.addEventListener(matchedEvent[1].toLowerCase(), value3);
        } else if (key === "p-bind") {
          setAttributes(element, value3);
        } else {
          value3 = key === "class" ? [...new Set(computedStyles("class", value3))].join(" ").trim() : key === "style" ? computedStyles("style", value3).join(";").trim() : value3;
          (element.$attrs = element.$attrs || {}) && (element.$attrs[key] = value3);
          element.setAttribute(key, value3);
        }
      }
    });
  }
}
__name(setAttributes, "setAttributes");
function createElement(type, attributes = {}, ...children) {
  if (type) {
    const element = document.createElement(type);
    setAttributes(element, attributes);
    element.append(...children);
    return element;
  }
  return void 0;
}
__name(createElement, "createElement");
function createStyleAsString(css3, options3 = {}) {
  return css3 ? `'<style type="text/css" ${Object.entries(options3).reduce((s, [k, v2]) => s + `${k}="${v2}"`, " ")}>${css3}</style>'` : "";
}
__name(createStyleAsString, "createStyleAsString");
function createStyleTag(attributes = {}, container) {
  let element = document.createElement("style");
  setAttributes(element, attributes);
  if (!container) {
    container = document.head;
  }
  container.appendChild(element);
  return element;
}
__name(createStyleTag, "createStyleTag");
function fadeIn(element, duration) {
  if (element) {
    element.style.opacity = "0";
    let last = +/* @__PURE__ */ new Date();
    let opacity = "0";
    let tick = /* @__PURE__ */ __name(function() {
      opacity = `${+element.style.opacity + ((/* @__PURE__ */ new Date()).getTime() - last) / duration}`;
      element.style.opacity = opacity;
      last = +/* @__PURE__ */ new Date();
      if (+opacity < 1) {
        !!window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);
      }
    }, "tick");
    tick();
  }
}
__name(fadeIn, "fadeIn");
function fadeOut(element, duration) {
  if (element) {
    let opacity = 1, interval = 50, gap = interval / duration;
    let fading = setInterval(() => {
      opacity -= gap;
      if (opacity <= 0) {
        opacity = 0;
        clearInterval(fading);
      }
      element.style.opacity = opacity.toString();
    }, interval);
  }
}
__name(fadeOut, "fadeOut");
function find(element, selector) {
  return isElement(element) ? Array.from(element.querySelectorAll(selector)) : [];
}
__name(find, "find");
function findSingle(element, selector) {
  return isElement(element) ? element.matches(selector) ? element : element.querySelector(selector) : null;
}
__name(findSingle, "findSingle");
function focus(element, options3) {
  element && document.activeElement !== element && element.focus(options3);
}
__name(focus, "focus");
function getAttribute(element, name) {
  if (isElement(element)) {
    const value3 = element.getAttribute(name);
    if (!isNaN(value3)) {
      return +value3;
    }
    if (value3 === "true" || value3 === "false") {
      return value3 === "true";
    }
    return value3;
  }
  return void 0;
}
__name(getAttribute, "getAttribute");
function resolveUserAgent() {
  let ua = navigator.userAgent.toLowerCase();
  let match = /(chrome)[ ]([\w.]+)/.exec(ua) || /(webkit)[ ]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
  return {
    browser: match[1] || "",
    version: match[2] || "0"
  };
}
__name(resolveUserAgent, "resolveUserAgent");
var browser = null;
function getBrowser() {
  if (!browser) {
    browser = {};
    let matched = resolveUserAgent();
    if (matched.browser) {
      browser[matched.browser] = true;
      browser["version"] = matched.version;
    }
    if (browser["chrome"]) {
      browser["webkit"] = true;
    } else if (browser["webkit"]) {
      browser["safari"] = true;
    }
  }
  return browser;
}
__name(getBrowser, "getBrowser");
function getCursorOffset(element, prevText, nextText, currentText) {
  if (element) {
    let style = getComputedStyle(element);
    let ghostDiv = document.createElement("div");
    ghostDiv.style.position = "absolute";
    ghostDiv.style.top = "0px";
    ghostDiv.style.left = "0px";
    ghostDiv.style.visibility = "hidden";
    ghostDiv.style.pointerEvents = "none";
    ghostDiv.style.overflow = style.overflow;
    ghostDiv.style.width = style.width;
    ghostDiv.style.height = style.height;
    ghostDiv.style.padding = style.padding;
    ghostDiv.style.border = style.border;
    ghostDiv.style.overflowWrap = style.overflowWrap;
    ghostDiv.style.whiteSpace = style.whiteSpace;
    ghostDiv.style.lineHeight = style.lineHeight;
    ghostDiv.innerHTML = prevText.replace(/\r\n|\r|\n/g, "<br />");
    let ghostSpan = document.createElement("span");
    ghostSpan.textContent = currentText;
    ghostDiv.appendChild(ghostSpan);
    let text = document.createTextNode(nextText);
    ghostDiv.appendChild(text);
    document.body.appendChild(ghostDiv);
    const { offsetLeft, offsetTop, clientHeight } = ghostSpan;
    document.body.removeChild(ghostDiv);
    return {
      left: Math.abs(offsetLeft - element.scrollLeft),
      top: Math.abs(offsetTop - element.scrollTop) + clientHeight
    };
  }
  return {
    top: "auto",
    left: "auto"
  };
}
__name(getCursorOffset, "getCursorOffset");
function getFocusableElements(element, selector = "") {
  let focusableElements = find(
    element,
    `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector}`
  );
  let visibleFocusableElements = [];
  for (let focusableElement of focusableElements) {
    if (getComputedStyle(focusableElement).display != "none" && getComputedStyle(focusableElement).visibility != "hidden") visibleFocusableElements.push(focusableElement);
  }
  return visibleFocusableElements;
}
__name(getFocusableElements, "getFocusableElements");
function getFirstFocusableElement(element, selector) {
  const focusableElements = getFocusableElements(element, selector);
  return focusableElements.length > 0 ? focusableElements[0] : null;
}
__name(getFirstFocusableElement, "getFirstFocusableElement");
function getHeight(element) {
  if (element) {
    let height = element.offsetHeight;
    let style = getComputedStyle(element);
    height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    return height;
  }
  return 0;
}
__name(getHeight, "getHeight");
function getHiddenElementOuterHeight(element) {
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    let elementHeight = element.offsetHeight;
    element.style.display = "none";
    element.style.visibility = "visible";
    return elementHeight;
  }
  return 0;
}
__name(getHiddenElementOuterHeight, "getHiddenElementOuterHeight");
function getHiddenElementOuterWidth(element) {
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    let elementWidth = element.offsetWidth;
    element.style.display = "none";
    element.style.visibility = "visible";
    return elementWidth;
  }
  return 0;
}
__name(getHiddenElementOuterWidth, "getHiddenElementOuterWidth");
function getParentNode(element) {
  if (element) {
    let parent = element.parentNode;
    if (parent && parent instanceof ShadowRoot && parent.host) {
      parent = parent.host;
    }
    return parent;
  }
  return null;
}
__name(getParentNode, "getParentNode");
function getIndex(element) {
  var _a;
  if (element) {
    let children = (_a = getParentNode(element)) == null ? void 0 : _a.childNodes;
    let num = 0;
    if (children) {
      for (let i2 = 0; i2 < children.length; i2++) {
        if (children[i2] === element) return num;
        if (children[i2].nodeType === 1) num++;
      }
    }
  }
  return -1;
}
__name(getIndex, "getIndex");
function getInnerWidth(element) {
  if (element) {
    let width2 = element.offsetWidth;
    let style = getComputedStyle(element);
    width2 -= parseFloat(style.borderLeft) + parseFloat(style.borderRight);
    return width2;
  }
  return 0;
}
__name(getInnerWidth, "getInnerWidth");
function getLastFocusableElement(element, selector) {
  const focusableElements = getFocusableElements(element, selector);
  return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
}
__name(getLastFocusableElement, "getLastFocusableElement");
function getNextElementSibling(element, selector) {
  let nextElement = element.nextElementSibling;
  while (nextElement) {
    if (nextElement.matches(selector)) {
      return nextElement;
    } else {
      nextElement = nextElement.nextElementSibling;
    }
  }
  return null;
}
__name(getNextElementSibling, "getNextElementSibling");
function getNextFocusableElement(container, element, selector) {
  const focusableElements = getFocusableElements(container, selector);
  const index2 = focusableElements.length > 0 ? focusableElements.findIndex((el) => el === element) : -1;
  const nextIndex = index2 > -1 && focusableElements.length >= index2 + 1 ? index2 + 1 : -1;
  return nextIndex > -1 ? focusableElements[nextIndex] : null;
}
__name(getNextFocusableElement, "getNextFocusableElement");
function getOffset(element) {
  if (element) {
    let rect = element.getBoundingClientRect();
    return {
      top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
      left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)
    };
  }
  return {
    top: "auto",
    left: "auto"
  };
}
__name(getOffset, "getOffset");
function getOuterHeight(element, margin) {
  if (element) {
    let height = element.offsetHeight;
    if (margin) {
      let style = getComputedStyle(element);
      height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
    }
    return height;
  }
  return 0;
}
__name(getOuterHeight, "getOuterHeight");
function getParents(element, parents = []) {
  const parent = getParentNode(element);
  return parent === null ? parents : getParents(parent, parents.concat([parent]));
}
__name(getParents, "getParents");
function getPreviousElementSibling(element, selector) {
  let previousElement = element.previousElementSibling;
  while (previousElement) {
    if (previousElement.matches(selector)) {
      return previousElement;
    } else {
      previousElement = previousElement.previousElementSibling;
    }
  }
  return null;
}
__name(getPreviousElementSibling, "getPreviousElementSibling");
function getScrollableParents(element) {
  let scrollableParents = [];
  if (element) {
    let parents = getParents(element);
    const overflowRegex = /(auto|scroll)/;
    const overflowCheck = /* @__PURE__ */ __name((node3) => {
      try {
        let styleDeclaration = window["getComputedStyle"](node3, null);
        return overflowRegex.test(styleDeclaration.getPropertyValue("overflow")) || overflowRegex.test(styleDeclaration.getPropertyValue("overflowX")) || overflowRegex.test(styleDeclaration.getPropertyValue("overflowY"));
      } catch (err) {
        return false;
      }
    }, "overflowCheck");
    for (let parent of parents) {
      let scrollSelectors = parent.nodeType === 1 && parent.dataset["scrollselectors"];
      if (scrollSelectors) {
        let selectors = scrollSelectors.split(",");
        for (let selector of selectors) {
          let el = findSingle(parent, selector);
          if (el && overflowCheck(el)) {
            scrollableParents.push(el);
          }
        }
      }
      if (parent.nodeType !== 9 && overflowCheck(parent)) {
        scrollableParents.push(parent);
      }
    }
  }
  return scrollableParents;
}
__name(getScrollableParents, "getScrollableParents");
function getSelection() {
  if (window.getSelection) return window.getSelection().toString();
  else if (document.getSelection) return document.getSelection().toString();
  return void 0;
}
__name(getSelection, "getSelection");
function isExist(element) {
  return !!(element !== null && typeof element !== "undefined" && element.nodeName && getParentNode(element));
}
__name(isExist, "isExist");
function getTargetElement(target, currentElement) {
  var _a;
  if (!target) return void 0;
  switch (target) {
    case "document":
      return document;
    case "window":
      return window;
    case "@next":
      return currentElement == null ? void 0 : currentElement.nextElementSibling;
    case "@prev":
      return currentElement == null ? void 0 : currentElement.previousElementSibling;
    case "@parent":
      return currentElement == null ? void 0 : currentElement.parentElement;
    case "@grandparent":
      return (_a = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a.parentElement;
    default:
      if (typeof target === "string") {
        return document.querySelector(target);
      }
      const isFunction2 = /* @__PURE__ */ __name((obj) => !!(obj && obj.constructor && obj.call && obj.apply), "isFunction");
      const element = toElement(isFunction2(target) ? target() : target);
      return (element == null ? void 0 : element.nodeType) === 9 || isExist(element) ? element : void 0;
  }
}
__name(getTargetElement, "getTargetElement");
function getUserAgent() {
  return navigator.userAgent;
}
__name(getUserAgent, "getUserAgent");
function getWidth(element) {
  if (element) {
    let width2 = element.offsetWidth;
    let style = getComputedStyle(element);
    width2 -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    return width2;
  }
  return 0;
}
__name(getWidth, "getWidth");
function hasCSSAnimation(element) {
  if (element) {
    const style = getComputedStyle(element);
    const animationDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
    return animationDuration > 0;
  }
  return false;
}
__name(hasCSSAnimation, "hasCSSAnimation");
function hasCSSTransition(element) {
  if (element) {
    const style = getComputedStyle(element);
    const transitionDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
    return transitionDuration > 0;
  }
  return false;
}
__name(hasCSSTransition, "hasCSSTransition");
function invokeElementMethod(element, methodName, args) {
  element[methodName].apply(element, args);
}
__name(invokeElementMethod, "invokeElementMethod");
function isAndroid$1() {
  return /(android)/i.test(navigator.userAgent);
}
__name(isAndroid$1, "isAndroid$1");
function isAttributeEquals(element, name, value3) {
  return isElement(element) ? getAttribute(element, name) === value3 : false;
}
__name(isAttributeEquals, "isAttributeEquals");
function isAttributeNotEquals(element, name, value3) {
  return !isAttributeEquals(element, name, value3);
}
__name(isAttributeNotEquals, "isAttributeNotEquals");
function isClickable(element) {
  if (element) {
    const targetNode = element.nodeName;
    const parentNode = element.parentElement && element.parentElement.nodeName;
    return targetNode === "INPUT" || targetNode === "TEXTAREA" || targetNode === "BUTTON" || targetNode === "A" || parentNode === "INPUT" || parentNode === "TEXTAREA" || parentNode === "BUTTON" || parentNode === "A" || !!element.closest(".p-button, .p-checkbox, .p-radiobutton");
  }
  return false;
}
__name(isClickable, "isClickable");
function isClient$1() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
__name(isClient$1, "isClient$1");
function isFocusableElement(element, selector = "") {
  return isElement(element) ? element.matches(`button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector}`) : false;
}
__name(isFocusableElement, "isFocusableElement");
function isVisible(element) {
  return !!(element && element.offsetParent != null);
}
__name(isVisible, "isVisible");
function isHidden(element) {
  return !isVisible(element);
}
__name(isHidden, "isHidden");
function isIOS$1() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window["MSStream"];
}
__name(isIOS$1, "isIOS$1");
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
__name(isTouchDevice, "isTouchDevice");
function nestedPosition(element, level) {
  var _a;
  if (element) {
    const parentItem = element.parentElement;
    const elementOffset = getOffset(parentItem);
    const viewport = getViewport();
    const sublistWidth = element.offsetParent ? element.offsetWidth : getHiddenElementOuterWidth(element);
    const itemOuterWidth = getOuterWidth((_a = parentItem == null ? void 0 : parentItem.children) == null ? void 0 : _a[0]);
    let left = "";
    if (elementOffset.left + itemOuterWidth + sublistWidth > viewport.width - calculateScrollbarWidth()) {
      if (elementOffset.left < sublistWidth) {
        if (level % 2 === 1) {
          left = elementOffset.left ? "-" + elementOffset.left + "px" : "100%";
        } else if (level % 2 === 0) {
          left = viewport.width - sublistWidth - calculateScrollbarWidth() + "px";
        }
      } else {
        left = "-100%";
      }
    } else {
      left = "100%";
    }
    element.style.top = "0px";
    element.style.left = left;
  }
}
__name(nestedPosition, "nestedPosition");
function remove(element) {
  var _a;
  if (element) {
    if (!("remove" in Element.prototype)) (_a = element.parentNode) == null ? void 0 : _a.removeChild(element);
    else element.remove();
  }
}
__name(remove, "remove");
function removeChild(element, child) {
  const target = toElement(element);
  if (target) target.removeChild(child);
  else throw new Error("Cannot remove " + child + " from " + element);
}
__name(removeChild, "removeChild");
function removeStyleTag(element) {
  var _a;
  if (isExist(element)) {
    try {
      (_a = element.parentNode) == null ? void 0 : _a.removeChild(element);
    } catch (error) {
    }
    return null;
  }
  return element;
}
__name(removeStyleTag, "removeStyleTag");
function scrollInView(container, item2) {
  let borderTopValue = getComputedStyle(container).getPropertyValue("borderTopWidth");
  let borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
  let paddingTopValue = getComputedStyle(container).getPropertyValue("paddingTop");
  let paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
  let containerRect = container.getBoundingClientRect();
  let itemRect = item2.getBoundingClientRect();
  let offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
  let scroll = container.scrollTop;
  let elementHeight = container.clientHeight;
  let itemHeight = getOuterHeight(item2);
  if (offset < 0) {
    container.scrollTop = scroll + offset;
  } else if (offset + itemHeight > elementHeight) {
    container.scrollTop = scroll + offset - elementHeight + itemHeight;
  }
}
__name(scrollInView, "scrollInView");
function setAttribute(element, attribute = "", value3) {
  if (isElement(element) && value3 !== null && value3 !== void 0) {
    element.setAttribute(attribute, value3);
  }
}
__name(setAttribute, "setAttribute");
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = /* @__PURE__ */ __name((obj, key, value3) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3, "__defNormalProp$1");
var __spreadValues$1 = /* @__PURE__ */ __name((a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop2))
      __defNormalProp$1(a, prop2, b[prop2]);
  if (__getOwnPropSymbols$1)
    for (var prop2 of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop2))
        __defNormalProp$1(a, prop2, b[prop2]);
    }
  return a;
}, "__spreadValues$1");
function isEmpty(value3) {
  return value3 === null || value3 === void 0 || value3 === "" || Array.isArray(value3) && value3.length === 0 || !(value3 instanceof Date) && typeof value3 === "object" && Object.keys(value3).length === 0;
}
__name(isEmpty, "isEmpty");
function compare$1(value1, value22, comparator2, order = 1) {
  let result = -1;
  const emptyValue1 = isEmpty(value1);
  const emptyValue2 = isEmpty(value22);
  if (emptyValue1 && emptyValue2) result = 0;
  else if (emptyValue1) result = order;
  else if (emptyValue2) result = -order;
  else if (typeof value1 === "string" && typeof value22 === "string") result = comparator2(value1, value22);
  else result = value1 < value22 ? -1 : value1 > value22 ? 1 : 0;
  return result;
}
__name(compare$1, "compare$1");
function deepEquals(obj1, obj2) {
  if (obj1 === obj2) return true;
  if (obj1 && obj2 && typeof obj1 == "object" && typeof obj2 == "object") {
    var arrObj1 = Array.isArray(obj1), arrObj2 = Array.isArray(obj2), i2, length, key;
    if (arrObj1 && arrObj2) {
      length = obj1.length;
      if (length != obj2.length) return false;
      for (i2 = length; i2-- !== 0; ) if (!deepEquals(obj1[i2], obj2[i2])) return false;
      return true;
    }
    if (arrObj1 != arrObj2) return false;
    var dateObj1 = obj1 instanceof Date, dateObj2 = obj2 instanceof Date;
    if (dateObj1 != dateObj2) return false;
    if (dateObj1 && dateObj2) return obj1.getTime() == obj2.getTime();
    var regexpObj1 = obj1 instanceof RegExp, regexpObj2 = obj2 instanceof RegExp;
    if (regexpObj1 != regexpObj2) return false;
    if (regexpObj1 && regexpObj2) return obj1.toString() == obj2.toString();
    var keys2 = Object.keys(obj1);
    length = keys2.length;
    if (length !== Object.keys(obj2).length) return false;
    for (i2 = length; i2-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(obj2, keys2[i2])) return false;
    for (i2 = length; i2-- !== 0; ) {
      key = keys2[i2];
      if (!deepEquals(obj1[key], obj2[key])) return false;
    }
    return true;
  }
  return obj1 !== obj1 && obj2 !== obj2;
}
__name(deepEquals, "deepEquals");
function isFunction$1(value3) {
  return !!(value3 && value3.constructor && value3.call && value3.apply);
}
__name(isFunction$1, "isFunction$1");
function isNotEmpty(value3) {
  return !isEmpty(value3);
}
__name(isNotEmpty, "isNotEmpty");
function resolveFieldData(data22, field) {
  if (!data22 || !field) {
    return null;
  }
  try {
    const value3 = data22[field];
    if (isNotEmpty(value3)) return value3;
  } catch (e) {
  }
  if (Object.keys(data22).length) {
    if (isFunction$1(field)) {
      return field(data22);
    } else if (field.indexOf(".") === -1) {
      return data22[field];
    } else {
      let fields = field.split(".");
      let value3 = data22;
      for (let i2 = 0, len = fields.length; i2 < len; ++i2) {
        if (value3 == null) {
          return null;
        }
        value3 = value3[fields[i2]];
      }
      return value3;
    }
  }
  return null;
}
__name(resolveFieldData, "resolveFieldData");
function equals(obj1, obj2, field) {
  if (field) return resolveFieldData(obj1, field) === resolveFieldData(obj2, field);
  else return deepEquals(obj1, obj2);
}
__name(equals, "equals");
function contains(value3, list) {
  if (value3 != null && list && list.length) {
    for (let val of list) {
      if (equals(value3, val)) return true;
    }
  }
  return false;
}
__name(contains, "contains");
function filter(value3, fields, filterValue) {
  let filteredItems = [];
  if (value3) {
    for (let item2 of value3) {
      for (let field of fields) {
        if (String(resolveFieldData(item2, field)).toLowerCase().indexOf(filterValue.toLowerCase()) > -1) {
          filteredItems.push(item2);
          break;
        }
      }
    }
  }
  return filteredItems;
}
__name(filter, "filter");
function findIndexInList(value3, list) {
  let index2 = -1;
  if (list) {
    for (let i2 = 0; i2 < list.length; i2++) {
      if (list[i2] === value3) {
        index2 = i2;
        break;
      }
    }
  }
  return index2;
}
__name(findIndexInList, "findIndexInList");
function findLast$1(arr, callback) {
  let item2;
  if (isNotEmpty(arr)) {
    try {
      item2 = arr.findLast(callback);
    } catch (e) {
      item2 = [...arr].reverse().find(callback);
    }
  }
  return item2;
}
__name(findLast$1, "findLast$1");
function findLastIndex(arr, callback) {
  let index2 = -1;
  if (isNotEmpty(arr)) {
    try {
      index2 = arr.findLastIndex(callback);
    } catch (e) {
      index2 = arr.lastIndexOf([...arr].reverse().find(callback));
    }
  }
  return index2;
}
__name(findLastIndex, "findLastIndex");
function isObject$4(value3, empty = true) {
  return value3 instanceof Object && value3.constructor === Object && (empty || Object.keys(value3).length !== 0);
}
__name(isObject$4, "isObject$4");
function resolve(obj, ...params) {
  return isFunction$1(obj) ? obj(...params) : obj;
}
__name(resolve, "resolve");
function isString$3(value3, empty = true) {
  return typeof value3 === "string" && (empty || value3 !== "");
}
__name(isString$3, "isString$3");
function toFlatCase(str) {
  return isString$3(str) ? str.replace(/(-|_)/g, "").toLowerCase() : str;
}
__name(toFlatCase, "toFlatCase");
function getKeyValue(obj, key = "", params = {}) {
  const fKeys = toFlatCase(key).split(".");
  const fKey = fKeys.shift();
  return fKey ? isObject$4(obj) ? getKeyValue(resolve(obj[Object.keys(obj).find((k) => toFlatCase(k) === fKey) || ""], params), fKeys.join("."), params) : void 0 : resolve(obj, params);
}
__name(getKeyValue, "getKeyValue");
function insertIntoOrderedArray(item2, index2, arr, sourceArr) {
  if (arr.length > 0) {
    let injected = false;
    for (let i2 = 0; i2 < arr.length; i2++) {
      let currentItemIndex = findIndexInList(arr[i2], sourceArr);
      if (currentItemIndex > index2) {
        arr.splice(i2, 0, item2);
        injected = true;
        break;
      }
    }
    if (!injected) {
      arr.push(item2);
    }
  } else {
    arr.push(item2);
  }
}
__name(insertIntoOrderedArray, "insertIntoOrderedArray");
function isArray$3(value3, empty = true) {
  return Array.isArray(value3) && (empty || value3.length !== 0);
}
__name(isArray$3, "isArray$3");
function isDate$1(value3) {
  return value3 instanceof Date && value3.constructor === Date;
}
__name(isDate$1, "isDate$1");
function isNumber$2(value3) {
  return isNotEmpty(value3) && !isNaN(value3);
}
__name(isNumber$2, "isNumber$2");
function isPrintableCharacter(char = "") {
  return isNotEmpty(char) && char.length === 1 && !!char.match(/\S| /);
}
__name(isPrintableCharacter, "isPrintableCharacter");
function localeComparator() {
  return new Intl.Collator(void 0, { numeric: true }).compare;
}
__name(localeComparator, "localeComparator");
function matchRegex(str, regex) {
  if (regex) {
    const match = regex.test(str);
    regex.lastIndex = 0;
    return match;
  }
  return false;
}
__name(matchRegex, "matchRegex");
function mergeKeys(...args) {
  const _mergeKeys = /* @__PURE__ */ __name((target = {}, source = {}) => {
    const mergedObj = __spreadValues$1({}, target);
    Object.keys(source).forEach((key) => {
      if (isObject$4(source[key]) && key in target && isObject$4(target[key])) {
        mergedObj[key] = _mergeKeys(target[key], source[key]);
      } else {
        mergedObj[key] = source[key];
      }
    });
    return mergedObj;
  }, "_mergeKeys");
  return args.reduce((acc, obj, i2) => i2 === 0 ? obj : _mergeKeys(acc, obj), {});
}
__name(mergeKeys, "mergeKeys");
function minifyCSS(css3) {
  return css3 ? css3.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":") : css3;
}
__name(minifyCSS, "minifyCSS");
function nestedKeys(obj = {}, parentKey = "") {
  return Object.entries(obj).reduce((o, [key, value3]) => {
    const currentKey = parentKey ? `${parentKey}.${key}` : key;
    isObject$4(value3) ? o = o.concat(nestedKeys(value3, currentKey)) : o.push(currentKey);
    return o;
  }, []);
}
__name(nestedKeys, "nestedKeys");
function removeAccents(str) {
  if (str && str.search(/[\xC0-\xFF]/g) > -1) {
    str = str.replace(/[\xC0-\xC5]/g, "A").replace(/[\xC6]/g, "AE").replace(/[\xC7]/g, "C").replace(/[\xC8-\xCB]/g, "E").replace(/[\xCC-\xCF]/g, "I").replace(/[\xD0]/g, "D").replace(/[\xD1]/g, "N").replace(/[\xD2-\xD6\xD8]/g, "O").replace(/[\xD9-\xDC]/g, "U").replace(/[\xDD]/g, "Y").replace(/[\xDE]/g, "P").replace(/[\xE0-\xE5]/g, "a").replace(/[\xE6]/g, "ae").replace(/[\xE7]/g, "c").replace(/[\xE8-\xEB]/g, "e").replace(/[\xEC-\xEF]/g, "i").replace(/[\xF1]/g, "n").replace(/[\xF2-\xF6\xF8]/g, "o").replace(/[\xF9-\xFC]/g, "u").replace(/[\xFE]/g, "p").replace(/[\xFD\xFF]/g, "y");
  }
  return str;
}
__name(removeAccents, "removeAccents");
function reorderArray(value3, from, to) {
  if (value3 && from !== to) {
    if (to >= value3.length) {
      to %= value3.length;
      from %= value3.length;
    }
    value3.splice(to, 0, value3.splice(from, 1)[0]);
  }
}
__name(reorderArray, "reorderArray");
function sort(value1, value22, order = 1, comparator2, nullSortOrder = 1) {
  const result = compare$1(value1, value22, comparator2, order);
  let finalSortOrder = order;
  if (isEmpty(value1) || isEmpty(value22)) {
    finalSortOrder = nullSortOrder === 1 ? order : nullSortOrder;
  }
  return finalSortOrder * result;
}
__name(sort, "sort");
function stringify$1(value3, indent = 2, currentIndent = 0) {
  const currentIndentStr = " ".repeat(currentIndent);
  const nextIndentStr = " ".repeat(currentIndent + indent);
  if (isArray$3(value3)) {
    return "[" + value3.map((v2) => stringify$1(v2, indent, currentIndent + indent)).join(", ") + "]";
  } else if (isDate$1(value3)) {
    return value3.toISOString();
  } else if (isFunction$1(value3)) {
    return value3.toString();
  } else if (isObject$4(value3)) {
    return "{\n" + Object.entries(value3).map(([k, v2]) => `${nextIndentStr}${k}: ${stringify$1(v2, indent, currentIndent + indent)}`).join(",\n") + `
${currentIndentStr}}`;
  } else {
    return JSON.stringify(value3);
  }
}
__name(stringify$1, "stringify$1");
function toCapitalCase(str) {
  return isString$3(str, false) ? str[0].toUpperCase() + str.slice(1) : str;
}
__name(toCapitalCase, "toCapitalCase");
function toKebabCase(str) {
  return isString$3(str) ? str.replace(/(_)/g, "-").replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "-" + c.toLowerCase()).toLowerCase() : str;
}
__name(toKebabCase, "toKebabCase");
function toTokenKey$1(str) {
  return isString$3(str) ? str.replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "." + c.toLowerCase()).toLowerCase() : str;
}
__name(toTokenKey$1, "toTokenKey$1");
var FilterMatchMode = {
  STARTS_WITH: "startsWith",
  CONTAINS: "contains",
  NOT_CONTAINS: "notContains",
  ENDS_WITH: "endsWith",
  EQUALS: "equals",
  NOT_EQUALS: "notEquals",
  IN: "in",
  LESS_THAN: "lt",
  LESS_THAN_OR_EQUAL_TO: "lte",
  GREATER_THAN: "gt",
  GREATER_THAN_OR_EQUAL_TO: "gte",
  BETWEEN: "between",
  DATE_IS: "dateIs",
  DATE_IS_NOT: "dateIsNot",
  DATE_BEFORE: "dateBefore",
  DATE_AFTER: "dateAfter"
};
var FilterOperator = {
  AND: "and",
  OR: "or"
};
function _createForOfIteratorHelper$4(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$i(r)) || e) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$4, "_createForOfIteratorHelper$4");
function _unsupportedIterableToArray$i(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$i(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$i(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$i, "_unsupportedIterableToArray$i");
function _arrayLikeToArray$i(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$i, "_arrayLikeToArray$i");
var FilterService = {
  filter: /* @__PURE__ */ __name(function filter3(value3, fields, filterValue, filterMatchMode, filterLocale) {
    var filteredItems = [];
    if (!value3) {
      return filteredItems;
    }
    var _iterator = _createForOfIteratorHelper$4(value3), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item2 = _step.value;
        if (typeof item2 === "string") {
          if (this.filters[filterMatchMode](item2, filterValue, filterLocale)) {
            filteredItems.push(item2);
            continue;
          }
        } else {
          var _iterator2 = _createForOfIteratorHelper$4(fields), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var field = _step2.value;
              var fieldValue = resolveFieldData(item2, field);
              if (this.filters[filterMatchMode](fieldValue, filterValue, filterLocale)) {
                filteredItems.push(item2);
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return filteredItems;
  }, "filter"),
  filters: {
    startsWith: /* @__PURE__ */ __name(function startsWith(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.slice(0, filterValue.length) === filterValue;
    }, "startsWith"),
    contains: /* @__PURE__ */ __name(function contains2(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) !== -1;
    }, "contains"),
    notContains: /* @__PURE__ */ __name(function notContains(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) === -1;
    }, "notContains"),
    endsWith: /* @__PURE__ */ __name(function endsWith2(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue, stringValue.length - filterValue.length) !== -1;
    }, "endsWith"),
    equals: /* @__PURE__ */ __name(function equals2(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() === filter4.getTime();
      else return removeAccents(value3.toString()).toLocaleLowerCase(filterLocale) == removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
    }, "equals"),
    notEquals: /* @__PURE__ */ __name(function notEquals(value3, filter4, filterLocale) {
      if (filter4 === void 0 || filter4 === null || filter4 === "") {
        return false;
      }
      if (value3 === void 0 || value3 === null) {
        return true;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() !== filter4.getTime();
      else return removeAccents(value3.toString()).toLocaleLowerCase(filterLocale) != removeAccents(filter4.toString()).toLocaleLowerCase(filterLocale);
    }, "notEquals"),
    "in": /* @__PURE__ */ __name(function _in(value3, filter4) {
      if (filter4 === void 0 || filter4 === null || filter4.length === 0) {
        return true;
      }
      for (var i2 = 0; i2 < filter4.length; i2++) {
        if (equals(value3, filter4[i2])) {
          return true;
        }
      }
      return false;
    }, "_in"),
    between: /* @__PURE__ */ __name(function between(value3, filter4) {
      if (filter4 == null || filter4[0] == null || filter4[1] == null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime) return filter4[0].getTime() <= value3.getTime() && value3.getTime() <= filter4[1].getTime();
      else return filter4[0] <= value3 && value3 <= filter4[1];
    }, "between"),
    lt: /* @__PURE__ */ __name(function lt(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() < filter4.getTime();
      else return value3 < filter4;
    }, "lt"),
    lte: /* @__PURE__ */ __name(function lte(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() <= filter4.getTime();
      else return value3 <= filter4;
    }, "lte"),
    gt: /* @__PURE__ */ __name(function gt(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() > filter4.getTime();
      else return value3 > filter4;
    }, "gt"),
    gte: /* @__PURE__ */ __name(function gte(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter4.getTime) return value3.getTime() >= filter4.getTime();
      else return value3 >= filter4;
    }, "gte"),
    dateIs: /* @__PURE__ */ __name(function dateIs(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.toDateString() === filter4.toDateString();
    }, "dateIs"),
    dateIsNot: /* @__PURE__ */ __name(function dateIsNot(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.toDateString() !== filter4.toDateString();
    }, "dateIsNot"),
    dateBefore: /* @__PURE__ */ __name(function dateBefore(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.getTime() < filter4.getTime();
    }, "dateBefore"),
    dateAfter: /* @__PURE__ */ __name(function dateAfter(value3, filter4) {
      if (filter4 === void 0 || filter4 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.getTime() > filter4.getTime();
    }, "dateAfter")
  },
  register: /* @__PURE__ */ __name(function register2(rule, fn) {
    this.filters[rule] = fn;
  }, "register")
};
var PrimeIcons = {
  ALIGN_CENTER: "pi pi-align-center",
  ALIGN_JUSTIFY: "pi pi-align-justify",
  ALIGN_LEFT: "pi pi-align-left",
  ALIGN_RIGHT: "pi pi-align-right",
  AMAZON: "pi pi-amazon",
  ANDROID: "pi pi-android",
  ANGLE_DOUBLE_DOWN: "pi pi-angle-double-down",
  ANGLE_DOUBLE_LEFT: "pi pi-angle-double-left",
  ANGLE_DOUBLE_RIGHT: "pi pi-angle-double-right",
  ANGLE_DOUBLE_UP: "pi pi-angle-double-up",
  ANGLE_DOWN: "pi pi-angle-down",
  ANGLE_LEFT: "pi pi-angle-left",
  ANGLE_RIGHT: "pi pi-angle-right",
  ANGLE_UP: "pi pi-angle-up",
  APPLE: "pi pi-apple",
  ARROW_CIRCLE_DOWN: "pi pi-arrow-circle-down",
  ARROW_CIRCLE_LEFT: "pi pi-arrow-circle-left",
  ARROW_CIRCLE_RIGHT: "pi pi-arrow-circle-right",
  ARROW_CIRCLE_UP: "pi pi-arrow-circle-up",
  ARROW_DOWN: "pi pi-arrow-down",
  ARROW_DOWN_LEFT: "pi pi-arrow-down-left",
  ARROW_DOWN_RIGHT: "pi pi-arrow-down-right",
  ARROW_LEFT: "pi pi-arrow-left",
  ARROW_RIGHT: "pi pi-arrow-right",
  ARROW_RIGHT_ARROW_LEFT: "pi pi-arrow-right-arrow-left",
  ARROW_UP: "pi pi-arrow-up",
  ARROW_UP_LEFT: "pi pi-arrow-up-left",
  ARROW_UP_RIGHT: "pi pi-arrow-up-right",
  ARROW_H: "pi pi-arrows-h",
  ARROW_V: "pi pi-arrows-v",
  ARROW_A: "pi pi-arrows-alt",
  AT: "pi pi-at",
  BACKWARD: "pi pi-backward",
  BAN: "pi pi-ban",
  BARS: "pi pi-bars",
  BELL: "pi pi-bell",
  BITCOIN: "pi pi-bitcoin",
  BOLT: "pi pi-bolt",
  BOOK: "pi pi-book",
  BOOKMARK: "pi pi-bookmark",
  BOOKMARK_FILL: "pi pi-bookmark-fill",
  BOX: "pi pi-box",
  BRIEFCASE: "pi pi-briefcase",
  BUILDING: "pi pi-building",
  CALENDAR: "pi pi-calendar",
  CALENDAR_MINUS: "pi pi-calendar-minus",
  CALENDAR_PLUS: "pi pi-calendar-plus",
  CALENDAR_TIMES: "pi pi-calendar-times",
  CALCULATOR: "pi pi-calculator",
  CAMERA: "pi pi-camera",
  CAR: "pi pi-car",
  CARET_DOWN: "pi pi-caret-down",
  CARET_LEFT: "pi pi-caret-left",
  CARET_RIGHT: "pi pi-caret-right",
  CARET_UP: "pi pi-caret-up",
  CART_PLUS: "pi pi-cart-plus",
  CHART_BAR: "pi pi-chart-bar",
  CHART_LINE: "pi pi-chart-line",
  CHART_PIE: "pi pi-chart-pie",
  CHECK: "pi pi-check",
  CHECK_CIRCLE: "pi pi-check-circle",
  CHECK_SQUARE: "pi pi-check-square",
  CHEVRON_CIRCLE_DOWN: "pi pi-chevron-circle-down",
  CHEVRON_CIRCLE_LEFT: "pi pi-chevron-circle-left",
  CHEVRON_CIRCLE_RIGHT: "pi pi-chevron-circle-right",
  CHEVRON_CIRCLE_UP: "pi pi-chevron-circle-up",
  CHEVRON_DOWN: "pi pi-chevron-down",
  CHEVRON_LEFT: "pi pi-chevron-left",
  CHEVRON_RIGHT: "pi pi-chevron-right",
  CHEVRON_UP: "pi pi-chevron-up",
  CIRCLE: "pi pi-circle",
  CIRCLE_FILL: "pi pi-circle-fill",
  CLOCK: "pi pi-clock",
  CLONE: "pi pi-clone",
  CLOUD: "pi pi-cloud",
  CLOUD_DOWNLOAD: "pi pi-cloud-download",
  CLOUD_UPLOAD: "pi pi-cloud-upload",
  CODE: "pi pi-code",
  COG: "pi pi-cog",
  COMMENT: "pi pi-comment",
  COMMENTS: "pi pi-comments",
  COMPASS: "pi pi-compass",
  COPY: "pi pi-copy",
  CREDIT_CARD: "pi pi-credit-card",
  DATABASE: "pi pi-database",
  DELETELEFT: "pi pi-delete-left",
  DESKTOP: "pi pi-desktop",
  DIRECTIONS: "pi pi-directions",
  DIRECTIONS_ALT: "pi pi-directions-alt",
  DISCORD: "pi pi-discord",
  DOLLAR: "pi pi-dollar",
  DOWNLOAD: "pi pi-download",
  EJECT: "pi pi-eject",
  ELLIPSIS_H: "pi pi-ellipsis-h",
  ELLIPSIS_V: "pi pi-ellipsis-v",
  ENVELOPE: "pi pi-envelope",
  ERASER: "pi pi-eraser",
  EURO: "pi pi-euro",
  EXCLAMATION_CIRCLE: "pi pi-exclamation-circle",
  EXCLAMATION_TRIANGLE: "pi pi-exclamation-triangle",
  EXTERNAL_LINK: "pi pi-external-link",
  EYE: "pi pi-eye",
  EYE_SLASH: "pi pi-eye-slash",
  FACEBOOK: "pi pi-facebook",
  FAST_BACKWARD: "pi pi-fast-backward",
  FAST_FORWARD: "pi pi-fast-forward",
  FILE: "pi pi-file",
  FILE_EDIT: "pi pi-file-edit",
  FILE_EXCEL: "pi pi-file-excel",
  FILE_EXPORT: "pi pi-file-export",
  FILE_IMPORT: "pi pi-file-import",
  FILE_PDF: "pi pi-file-pdf",
  FILE_WORD: "pi pi-file-word",
  FILTER: "pi pi-filter",
  FILTER_FILL: "pi pi-filter-fill",
  FILTER_SLASH: "pi pi-filter-slash",
  FLAG: "pi pi-flag",
  FLAG_FILL: "pi pi-flag-fill",
  FOLDER: "pi pi-folder",
  FOLDER_OPEN: "pi pi-folder-open",
  FORWARD: "pi pi-forward",
  GIFT: "pi pi-gift",
  GITHUB: "pi pi-github",
  GLOBE: "pi pi-globe",
  GOOGLE: "pi pi-google",
  HASHTAG: "pi pi-hashtag",
  HEART: "pi pi-heart",
  HEART_FILL: "pi pi-heart-fill",
  HISTORY: "pi pi-history",
  HOURGLASS: "pi pi-hourglass",
  HOME: "pi pi-home",
  ID_CARD: "pi pi-id-card",
  IMAGE: "pi pi-image",
  IMAGES: "pi pi-images",
  INBOX: "pi pi-inbox",
  INFO: "pi pi-info",
  INFO_CIRCLE: "pi pi-info-circle",
  INSTAGRAM: "pi pi-instagram",
  KEY: "pi pi-key",
  LANGUAGE: "pi pi-language",
  LINK: "pi pi-link",
  LINKEDIN: "pi pi-linkedin",
  LIST: "pi pi-list",
  LOCK: "pi pi-lock",
  LOCK_OPEN: "pi pi-lock-open",
  MAP: "pi pi-map",
  MAP_MARKER: "pi pi-map-marker",
  MEGAPHONE: "pi pi-megaphone",
  MICREPHONE: "pi pi-microphone",
  MICROSOFT: "pi pi-microsoft",
  MINUS: "pi pi-minus",
  MINUS_CIRCLE: "pi pi-minus-circle",
  MOBILE: "pi pi-mobile",
  MONEY_BILL: "pi pi-money-bill",
  MOON: "pi pi-moon",
  PALETTE: "pi pi-palette",
  PAPERCLIP: "pi pi-paperclip",
  PAUSE: "pi pi-pause",
  PAYPAL: "pi pi-paypal",
  PENCIL: "pi pi-pencil",
  PERCENTAGE: "pi pi-percentage",
  PHONE: "pi pi-phone",
  PLAY: "pi pi-play",
  PLUS: "pi pi-plus",
  PLUS_CIRCLE: "pi pi-plus-circle",
  POUND: "pi pi-pound",
  POWER_OFF: "pi pi-power-off",
  PRIME: "pi pi-prime",
  PRINT: "pi pi-print",
  QRCODE: "pi pi-qrcode",
  QUESTION: "pi pi-question",
  QUESTION_CIRCLE: "pi pi-question-circle",
  REDDIT: "pi pi-reddit",
  REFRESH: "pi pi-refresh",
  REPLAY: "pi pi-replay",
  REPLY: "pi pi-reply",
  SAVE: "pi pi-save",
  SEARCH: "pi pi-search",
  SEARCH_MINUS: "pi pi-search-minus",
  SEARCH_PLUS: "pi pi-search-plus",
  SEND: "pi pi-send",
  SERVER: "pi pi-server",
  SHARE_ALT: "pi pi-share-alt",
  SHIELD: "pi pi-shield",
  SHOPPING_BAG: "pi pi-shopping-bag",
  SHOPPING_CART: "pi pi-shopping-cart",
  SIGN_IN: "pi pi-sign-in",
  SIGN_OUT: "pi pi-sign-out",
  SITEMAP: "pi pi-sitemap",
  SLACK: "pi pi-slack",
  SLIDERS_H: "pi pi-sliders-h",
  SLIDERS_V: "pi pi-sliders-v",
  SORT: "pi pi-sort",
  SORT_ALPHA_DOWN: "pi pi-sort-alpha-down",
  SORT_ALPHA_ALT_DOWN: "pi pi-sort-alpha-down-alt",
  SORT_ALPHA_UP: "pi pi-sort-alpha-up",
  SORT_ALPHA_ALT_UP: "pi pi-sort-alpha-up-alt",
  SORT_ALT: "pi pi-sort-alt",
  SORT_ALT_SLASH: "pi pi-sort-alt-slash",
  SORT_AMOUNT_DOWN: "pi pi-sort-amount-down",
  SORT_AMOUNT_DOWN_ALT: "pi pi-sort-amount-down-alt",
  SORT_AMOUNT_UP: "pi pi-sort-amount-up",
  SORT_AMOUNT_UP_ALT: "pi pi-sort-amount-up-alt",
  SORT_DOWN: "pi pi-sort-down",
  SORT_NUMERIC_DOWN: "pi pi-sort-numeric-down",
  SORT_NUMERIC_ALT_DOWN: "pi pi-sort-numeric-down-alt",
  SORT_NUMERIC_UP: "pi pi-sort-numeric-up",
  SORT_NUMERIC_ALT_UP: "pi pi-sort-numeric-up-alt",
  SORT_UP: "pi pi-sort-up",
  SPINNER: "pi pi-spinner",
  STAR: "pi pi-star",
  STAR_FILL: "pi pi-star-fill",
  STEP_BACKWARD: "pi pi-step-backward",
  STEP_BACKWARD_ALT: "pi pi-step-backward-alt",
  STEP_FORWARD: "pi pi-step-forward",
  STEP_FORWARD_ALT: "pi pi-step-forward-alt",
  STOP: "pi pi-stop",
  STOPWATCH: "pi pi-stopwatch",
  STOP_CIRCLE: "pi pi-stop-circle",
  SUN: "pi pi-sun",
  SYNC: "pi pi-sync",
  TABLE: "pi pi-table",
  TABLET: "pi pi-tablet",
  TAG: "pi pi-tag",
  TAGS: "pi pi-tags",
  TELEGRAM: "pi pi-telegram",
  TH_LARGE: "pi pi-th-large",
  THUMBS_DOWN: "pi pi-thumbs-down",
  THUMBS_DOWN_FILL: "pi pi-thumbs-down-fill",
  THUMBS_UP: "pi pi-thumbs-up",
  THUMBS_UP_FILL: "pi pi-thumbs-up-fill",
  TICKET: "pi pi-ticket",
  TIMES: "pi pi-times",
  TIMES_CIRCLE: "pi pi-times-circle",
  TRASH: "pi pi-trash",
  TRUCK: "pi pi-truck",
  TWITTER: "pi pi-twitter",
  UNDO: "pi pi-undo",
  UNLOCK: "pi pi-unlock",
  UPLOAD: "pi pi-upload",
  USER: "pi pi-user",
  USER_EDIT: "pi pi-user-edit",
  USER_MINUS: "pi pi-user-minus",
  USER_PLUS: "pi pi-user-plus",
  USERS: "pi pi-users",
  VERIFIED: "pi pi-verified",
  VIDEO: "pi pi-video",
  VIMEO: "pi pi-vimeo",
  VOLUME_DOWN: "pi pi-volume-down",
  VOLUME_OFF: "pi pi-volume-off",
  VOLUME_UP: "pi pi-volume-up",
  WALLET: "pi pi-wallet",
  WHATSAPP: "pi pi-whatsapp",
  WIFI: "pi pi-wifi",
  WINDOW_MAXIMIZE: "pi pi-window-maximize",
  WINDOW_MINIMIZE: "pi pi-window-minimize",
  WRENCH: "pi pi-wrench",
  YOUTUBE: "pi pi-youtube"
};
var ToastSeverities = {
  INFO: "info",
  WARN: "warn",
  ERROR: "error",
  SUCCESS: "success"
};
function EventBus() {
  const allHandlers = /* @__PURE__ */ new Map();
  return {
    on(type, handler6) {
      let handlers2 = allHandlers.get(type);
      if (!handlers2) handlers2 = [handler6];
      else handlers2.push(handler6);
      allHandlers.set(type, handlers2);
      return this;
    },
    off(type, handler6) {
      let handlers2 = allHandlers.get(type);
      if (handlers2) {
        handlers2.splice(handlers2.indexOf(handler6) >>> 0, 1);
      }
      return this;
    },
    emit(type, evt) {
      let handlers2 = allHandlers.get(type);
      if (handlers2) {
        handlers2.slice().map((handler6) => {
          handler6(evt);
        });
      }
    },
    clear() {
      allHandlers.clear();
    }
  };
}
__name(EventBus, "EventBus");
var lastIds = {};
function uuid(prefix2 = "pui_id_") {
  if (!lastIds.hasOwnProperty(prefix2)) {
    lastIds[prefix2] = 0;
  }
  lastIds[prefix2]++;
  return `${prefix2}${lastIds[prefix2]}`;
}
__name(uuid, "uuid");
function handler() {
  let zIndexes = [];
  const generateZIndex = /* @__PURE__ */ __name((key, autoZIndex, baseZIndex = 999) => {
    const lastZIndex = getLastZIndex(key, autoZIndex, baseZIndex);
    const newZIndex = lastZIndex.value + (lastZIndex.key === key ? 0 : baseZIndex) + 1;
    zIndexes.push({ key, value: newZIndex });
    return newZIndex;
  }, "generateZIndex");
  const revertZIndex = /* @__PURE__ */ __name((zIndex) => {
    zIndexes = zIndexes.filter((obj) => obj.value !== zIndex);
  }, "revertZIndex");
  const getCurrentZIndex = /* @__PURE__ */ __name((key, autoZIndex) => {
    return getLastZIndex(key, autoZIndex).value;
  }, "getCurrentZIndex");
  const getLastZIndex = /* @__PURE__ */ __name((key, autoZIndex, baseZIndex = 0) => {
    return [...zIndexes].reverse().find((obj) => autoZIndex ? true : obj.key === key) || { key, value: baseZIndex };
  }, "getLastZIndex");
  const getZIndex = /* @__PURE__ */ __name((element) => {
    return element ? parseInt(element.style.zIndex, 10) || 0 : 0;
  }, "getZIndex");
  return {
    get: getZIndex,
    set: /* @__PURE__ */ __name((key, element, baseZIndex) => {
      if (element) {
        element.style.zIndex = String(generateZIndex(key, true, baseZIndex));
      }
    }, "set"),
    clear: /* @__PURE__ */ __name((element) => {
      if (element) {
        revertZIndex(getZIndex(element));
        element.style.zIndex = "";
      }
    }, "clear"),
    getCurrent: /* @__PURE__ */ __name((key) => getCurrentZIndex(key, true), "getCurrent")
  };
}
__name(handler, "handler");
var ZIndex = handler();
function _typeof$1$3(o) {
  "@babel/helpers - typeof";
  return _typeof$1$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$3(o);
}
__name(_typeof$1$3, "_typeof$1$3");
function _classCallCheck$1(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck$1, "_classCallCheck$1");
function _defineProperties$1(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$1$3(o.key), o);
  }
}
__name(_defineProperties$1, "_defineProperties$1");
function _createClass$1(e, r, t) {
  return r && _defineProperties$1(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
__name(_createClass$1, "_createClass$1");
function _toPropertyKey$1$3(t) {
  var i2 = _toPrimitive$1$3(t, "string");
  return "symbol" == _typeof$1$3(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1$3, "_toPropertyKey$1$3");
function _toPrimitive$1$3(t, r) {
  if ("object" != _typeof$1$3(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r);
    if ("object" != _typeof$1$3(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
__name(_toPrimitive$1$3, "_toPrimitive$1$3");
var ConnectedOverlayScrollHandler = /* @__PURE__ */ function() {
  function ConnectedOverlayScrollHandler2(element) {
    var listener = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    };
    _classCallCheck$1(this, ConnectedOverlayScrollHandler2);
    this.element = element;
    this.listener = listener;
  }
  __name(ConnectedOverlayScrollHandler2, "ConnectedOverlayScrollHandler");
  return _createClass$1(ConnectedOverlayScrollHandler2, [{
    key: "bindScrollListener",
    value: /* @__PURE__ */ __name(function bindScrollListener6() {
      this.scrollableParents = getScrollableParents(this.element);
      for (var i2 = 0; i2 < this.scrollableParents.length; i2++) {
        this.scrollableParents[i2].addEventListener("scroll", this.listener);
      }
    }, "bindScrollListener")
  }, {
    key: "unbindScrollListener",
    value: /* @__PURE__ */ __name(function unbindScrollListener6() {
      if (this.scrollableParents) {
        for (var i2 = 0; i2 < this.scrollableParents.length; i2++) {
          this.scrollableParents[i2].removeEventListener("scroll", this.listener);
        }
      }
    }, "unbindScrollListener")
  }, {
    key: "destroy",
    value: /* @__PURE__ */ __name(function destroy() {
      this.unbindScrollListener();
      this.element = null;
      this.listener = null;
      this.scrollableParents = null;
    }, "destroy")
  }]);
}();
function _typeof$k(o) {
  "@babel/helpers - typeof";
  return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$k(o);
}
__name(_typeof$k, "_typeof$k");
function _toConsumableArray$b(r) {
  return _arrayWithoutHoles$b(r) || _iterableToArray$c(r) || _unsupportedIterableToArray$h(r) || _nonIterableSpread$b();
}
__name(_toConsumableArray$b, "_toConsumableArray$b");
function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$b, "_nonIterableSpread$b");
function _unsupportedIterableToArray$h(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$h(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$h(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$h, "_unsupportedIterableToArray$h");
function _iterableToArray$c(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$c, "_iterableToArray$c");
function _arrayWithoutHoles$b(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$h(r);
}
__name(_arrayWithoutHoles$b, "_arrayWithoutHoles$b");
function _arrayLikeToArray$h(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$h, "_arrayLikeToArray$h");
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$j(o.key), o);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
__name(_createClass, "_createClass");
function _defineProperty$k(e, r, t) {
  return (r = _toPropertyKey$j(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$k, "_defineProperty$k");
function _toPropertyKey$j(t) {
  var i2 = _toPrimitive$j(t, "string");
  return "symbol" == _typeof$k(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$j, "_toPropertyKey$j");
function _toPrimitive$j(t, r) {
  if ("object" != _typeof$k(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r);
    if ("object" != _typeof$k(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
__name(_toPrimitive$j, "_toPrimitive$j");
var _default = /* @__PURE__ */ function() {
  function _default4(_ref) {
    var init2 = _ref.init, type = _ref.type;
    _classCallCheck(this, _default4);
    _defineProperty$k(this, "helpers", void 0);
    _defineProperty$k(this, "type", void 0);
    this.helpers = new Set(init2);
    this.type = type;
  }
  __name(_default4, "_default");
  return _createClass(_default4, [{
    key: "add",
    value: /* @__PURE__ */ __name(function add2(instance) {
      this.helpers.add(instance);
    }, "add")
  }, {
    key: "update",
    value: /* @__PURE__ */ __name(function update() {
    }, "update")
  }, {
    key: "delete",
    value: /* @__PURE__ */ __name(function _delete(instance) {
      this.helpers["delete"](instance);
    }, "_delete")
  }, {
    key: "clear",
    value: /* @__PURE__ */ __name(function clear2() {
      this.helpers.clear();
    }, "clear")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function get2(parentInstance, slots) {
      var children = this._get(parentInstance, slots);
      var computed2 = children ? this._recursive(_toConsumableArray$b(this.helpers), children) : null;
      return isNotEmpty(computed2) ? computed2 : null;
    }, "get")
  }, {
    key: "_isMatched",
    value: /* @__PURE__ */ __name(function _isMatched(instance, key) {
      var _parent$vnode;
      var parent = instance === null || instance === void 0 ? void 0 : instance.parent;
      return (parent === null || parent === void 0 || (_parent$vnode = parent.vnode) === null || _parent$vnode === void 0 ? void 0 : _parent$vnode.key) === key || parent && this._isMatched(parent, key) || false;
    }, "_isMatched")
  }, {
    key: "_get",
    value: /* @__PURE__ */ __name(function _get(parentInstance, slots) {
      var _ref2, _ref2$default;
      return ((_ref2 = slots || (parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$slots)) === null || _ref2 === void 0 || (_ref2$default = _ref2["default"]) === null || _ref2$default === void 0 ? void 0 : _ref2$default.call(_ref2)) || null;
    }, "_get")
  }, {
    key: "_recursive",
    value: /* @__PURE__ */ __name(function _recursive() {
      var _this = this;
      var helpers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var children = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var components = [];
      children.forEach(function(child) {
        if (child.children instanceof Array) {
          components = components.concat(_this._recursive(components, child.children));
        } else if (child.type.name === _this.type) {
          components.push(child);
        } else if (isNotEmpty(child.key)) {
          components = components.concat(helpers.filter(function(c) {
            return _this._isMatched(c, child.key);
          }).map(function(c) {
            return c.vnode;
          }));
        }
      });
      return components;
    }, "_recursive")
  }]);
}();
function UniqueComponentId() {
  var prefix2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pv_id_";
  return uuid(prefix2);
}
__name(UniqueComponentId, "UniqueComponentId");
function getVNodeProp(vnode, prop2) {
  if (vnode) {
    var props = vnode.props;
    if (props) {
      var kebabProp = prop2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      var propName = Object.prototype.hasOwnProperty.call(props, kebabProp) ? kebabProp : prop2;
      return vnode.type["extends"].props[prop2].type === Boolean && props[propName] === "" ? true : props[propName];
    }
  }
  return null;
}
__name(getVNodeProp, "getVNodeProp");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = /* @__PURE__ */ __name((obj, key, value3) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3, "__defNormalProp");
var __spreadValues = /* @__PURE__ */ __name((a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp.call(b, prop2))
      __defNormalProp(a, prop2, b[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop2))
        __defNormalProp(a, prop2, b[prop2]);
    }
  return a;
}, "__spreadValues");
var __spreadProps = /* @__PURE__ */ __name((a, b) => __defProps(a, __getOwnPropDescs(b)), "__spreadProps");
var __objRest = /* @__PURE__ */ __name((source, exclude) => {
  var target = {};
  for (var prop2 in source)
    if (__hasOwnProp.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum.call(source, prop2))
        target[prop2] = source[prop2];
    }
  return target;
}, "__objRest");
function definePreset(...presets) {
  return mergeKeys(...presets);
}
__name(definePreset, "definePreset");
var ThemeService = EventBus();
var service_default = ThemeService;
function toTokenKey(str) {
  return isString$3(str) ? str.replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "." + c.toLowerCase()).toLowerCase() : str;
}
__name(toTokenKey, "toTokenKey");
function merge(value1, value22) {
  if (isArray$3(value1)) {
    value1.push(...value22 || []);
  } else if (isObject$4(value1)) {
    Object.assign(value1, value22);
  }
}
__name(merge, "merge");
function toValue$1(value3) {
  return isObject$4(value3) && value3.hasOwnProperty("value") && value3.hasOwnProperty("type") ? value3.value : value3;
}
__name(toValue$1, "toValue$1");
function toUnit(value3, variable = "") {
  const excludedProperties = ["opacity", "z-index", "line-height", "font-weight", "flex", "flex-grow", "flex-shrink", "order"];
  if (!excludedProperties.some((property) => variable.endsWith(property))) {
    const val = `${value3}`.trim();
    const valArr = val.split(" ");
    return valArr.map((v2) => isNumber$2(v2) ? `${v2}px` : v2).join(" ");
  }
  return value3;
}
__name(toUnit, "toUnit");
function toNormalizePrefix(prefix2) {
  return prefix2.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
}
__name(toNormalizePrefix, "toNormalizePrefix");
function toNormalizeVariable(prefix2 = "", variable = "") {
  return toNormalizePrefix(`${isString$3(prefix2, false) && isString$3(variable, false) ? `${prefix2}-` : prefix2}${variable}`);
}
__name(toNormalizeVariable, "toNormalizeVariable");
function getVariableName(prefix2 = "", variable = "") {
  return `--${toNormalizeVariable(prefix2, variable)}`;
}
__name(getVariableName, "getVariableName");
function getVariableValue(value3, variable = "", prefix2 = "", excludedKeyRegexes = [], fallback) {
  if (isString$3(value3)) {
    const regex = /{([^}]*)}/g;
    const val = value3.trim();
    if (matchRegex(val, regex)) {
      const _val = val.replaceAll(regex, (v2) => {
        const path = v2.replace(/{|}/g, "");
        const keys2 = path.split(".").filter((_v) => !excludedKeyRegexes.some((_r) => matchRegex(_v, _r)));
        return `var(${getVariableName(prefix2, toKebabCase(keys2.join("-")))}${isNotEmpty(fallback) ? `, ${fallback}` : ""})`;
      });
      const calculationRegex = /(\d+\s+[\+\-\*\/]\s+\d+)/g;
      const cleanedVarRegex = /var\([^)]+\)/g;
      return matchRegex(_val.replace(cleanedVarRegex, "0"), calculationRegex) ? `calc(${_val})` : _val;
    }
    return toUnit(val, variable);
  } else if (isNumber$2(value3)) {
    return toUnit(value3, variable);
  }
  return void 0;
}
__name(getVariableValue, "getVariableValue");
function getComputedValue(obj = {}, value3) {
  if (isString$3(value3)) {
    const regex = /{([^}]*)}/g;
    const val = value3.trim();
    return matchRegex(val, regex) ? val.replaceAll(regex, (v2) => getKeyValue(obj, v2.replace(/{|}/g, ""))) : val;
  } else if (isNumber$2(value3)) {
    return value3;
  }
  return void 0;
}
__name(getComputedValue, "getComputedValue");
function setProperty(properties, key, value3) {
  if (isString$3(key, false)) {
    properties.push(`${key}:${value3};`);
  }
}
__name(setProperty, "setProperty");
function getRule(selector, properties) {
  if (selector) {
    return `${selector}{${properties}}`;
  }
  return "";
}
__name(getRule, "getRule");
function normalizeColor(color) {
  if (color.length === 4) {
    return `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;
  }
  return color;
}
__name(normalizeColor, "normalizeColor");
function hexToRgb$1(hex) {
  var bigint = parseInt(hex.substring(1), 16);
  var r = bigint >> 16 & 255;
  var g = bigint >> 8 & 255;
  var b = bigint & 255;
  return { r, g, b };
}
__name(hexToRgb$1, "hexToRgb$1");
function rgbToHex(r, g, b) {
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
__name(rgbToHex, "rgbToHex");
var mix_default = /* @__PURE__ */ __name((color1, color2, weight) => {
  color1 = normalizeColor(color1);
  color2 = normalizeColor(color2);
  var p2 = weight / 100;
  var w2 = p2 * 2 - 1;
  var w1 = (w2 + 1) / 2;
  var w22 = 1 - w1;
  var rgb1 = hexToRgb$1(color1);
  var rgb2 = hexToRgb$1(color2);
  var r = Math.round(rgb1.r * w1 + rgb2.r * w22);
  var g = Math.round(rgb1.g * w1 + rgb2.g * w22);
  var b = Math.round(rgb1.b * w1 + rgb2.b * w22);
  return rgbToHex(r, g, b);
}, "mix_default");
var shade_default = /* @__PURE__ */ __name((color, percent) => mix_default("#000000", color, percent), "shade_default");
var tint_default = /* @__PURE__ */ __name((color, percent) => mix_default("#ffffff", color, percent), "tint_default");
var scales = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
var palette_default = /* @__PURE__ */ __name((color) => {
  if (/{([^}]*)}/g.test(color)) {
    const token = color.replace(/{|}/g, "");
    return scales.reduce((acc, scale) => (acc[scale] = `{${token}.${scale}}`, acc), {});
  }
  return typeof color === "string" ? scales.reduce((acc, scale, i2) => (acc[scale] = i2 <= 5 ? tint_default(color, (5 - i2) * 19) : shade_default(color, (i2 - 5) * 15), acc), {}) : color;
}, "palette_default");
var $dt = /* @__PURE__ */ __name((tokenPath) => {
  var _a;
  const theme38 = config_default.getTheme();
  const variable = dtwt(theme38, tokenPath, void 0, "variable");
  const name = (_a = variable.match(/--[\w-]+/g)) == null ? void 0 : _a[0];
  const value3 = dtwt(theme38, tokenPath, void 0, "value");
  return {
    name,
    variable,
    value: value3
  };
}, "$dt");
var dt = /* @__PURE__ */ __name((...args) => {
  return dtwt(config_default.getTheme(), ...args);
}, "dt");
var dtwt = /* @__PURE__ */ __name((theme38 = {}, tokenPath, fallback, type = "variable") => {
  if (tokenPath) {
    const { variable: VARIABLE, options: OPTIONS } = config_default.defaults || {};
    const { prefix: prefix2, transform: transform2 } = (theme38 == null ? void 0 : theme38.options) || OPTIONS || {};
    const regex = /{([^}]*)}/g;
    const token = matchRegex(tokenPath, regex) ? tokenPath : `{${tokenPath}}`;
    const isStrictTransform = type === "value" || transform2 === "strict";
    return isStrictTransform ? config_default.getTokenValue(tokenPath) : getVariableValue(token, void 0, prefix2, [VARIABLE.excludedKeyRegex], fallback);
  }
  return "";
}, "dtwt");
function css$2(style) {
  return resolve(style, { dt });
}
__name(css$2, "css$2");
var $t = /* @__PURE__ */ __name((theme38 = {}) => {
  let { preset: _preset, options: _options } = theme38;
  return {
    preset(value3) {
      _preset = _preset ? mergeKeys(_preset, value3) : value3;
      return this;
    },
    options(value3) {
      _options = _options ? __spreadValues(__spreadValues({}, _options), value3) : value3;
      return this;
    },
    // features
    primaryPalette(primary) {
      const { semantic } = _preset || {};
      _preset = __spreadProps(__spreadValues({}, _preset), { semantic: __spreadProps(__spreadValues({}, semantic), { primary }) });
      return this;
    },
    surfacePalette(surface) {
      var _a, _b;
      const { semantic } = _preset || {};
      const lightSurface = (surface == null ? void 0 : surface.hasOwnProperty("light")) ? surface == null ? void 0 : surface.light : surface;
      const darkSurface = (surface == null ? void 0 : surface.hasOwnProperty("dark")) ? surface == null ? void 0 : surface.dark : surface;
      const newColorScheme = {
        colorScheme: {
          light: __spreadValues(__spreadValues({}, (_a = semantic == null ? void 0 : semantic.colorScheme) == null ? void 0 : _a.light), !!lightSurface && { surface: lightSurface }),
          dark: __spreadValues(__spreadValues({}, (_b = semantic == null ? void 0 : semantic.colorScheme) == null ? void 0 : _b.dark), !!darkSurface && { surface: darkSurface })
        }
      };
      _preset = __spreadProps(__spreadValues({}, _preset), { semantic: __spreadValues(__spreadValues({}, semantic), newColorScheme) });
      return this;
    },
    // actions
    define({ useDefaultPreset = false, useDefaultOptions = false } = {}) {
      return {
        preset: useDefaultPreset ? config_default.getPreset() : _preset,
        options: useDefaultOptions ? config_default.getOptions() : _options
      };
    },
    update({ mergePresets = true, mergeOptions: mergeOptions2 = true } = {}) {
      const newTheme = {
        preset: mergePresets ? mergeKeys(config_default.getPreset(), _preset) : _preset,
        options: mergeOptions2 ? __spreadValues(__spreadValues({}, config_default.getOptions()), _options) : _options
      };
      config_default.setTheme(newTheme);
      return newTheme;
    },
    use(options3) {
      const newTheme = this.define(options3);
      config_default.setTheme(newTheme);
      return newTheme;
    }
  };
}, "$t");
function toVariables_default(theme38, options3 = {}) {
  const VARIABLE = config_default.defaults.variable;
  const { prefix: prefix2 = VARIABLE.prefix, selector = VARIABLE.selector, excludedKeyRegex = VARIABLE.excludedKeyRegex } = options3;
  const _toVariables = /* @__PURE__ */ __name((_theme, _prefix = "") => {
    return Object.entries(_theme).reduce(
      (acc, [key, value3]) => {
        const px = matchRegex(key, excludedKeyRegex) ? toNormalizeVariable(_prefix) : toNormalizeVariable(_prefix, toKebabCase(key));
        const v2 = toValue$1(value3);
        if (isObject$4(v2)) {
          const { variables: variables2, tokens: tokens2 } = _toVariables(v2, px);
          merge(acc["tokens"], tokens2);
          merge(acc["variables"], variables2);
        } else {
          acc["tokens"].push((prefix2 ? px.replace(`${prefix2}-`, "") : px).replaceAll("-", "."));
          setProperty(acc["variables"], getVariableName(px), getVariableValue(v2, px, prefix2, [excludedKeyRegex]));
        }
        return acc;
      },
      { variables: [], tokens: [] }
    );
  }, "_toVariables");
  const { variables, tokens } = _toVariables(theme38, prefix2);
  return {
    value: variables,
    tokens,
    declarations: variables.join(""),
    css: getRule(selector, variables.join(""))
  };
}
__name(toVariables_default, "toVariables_default");
var themeUtils_default = {
  regex: {
    rules: {
      class: {
        pattern: /^\.([a-zA-Z][\w-]*)$/,
        resolve(value3) {
          return { type: "class", selector: value3, matched: this.pattern.test(value3.trim()) };
        }
      },
      attr: {
        pattern: /^\[(.*)\]$/,
        resolve(value3) {
          return { type: "attr", selector: `:root${value3}`, matched: this.pattern.test(value3.trim()) };
        }
      },
      media: {
        pattern: /^@media (.*)$/,
        resolve(value3) {
          return { type: "media", selector: `${value3}{:root{[CSS]}}`, matched: this.pattern.test(value3.trim()) };
        }
      },
      system: {
        pattern: /^system$/,
        resolve(value3) {
          return { type: "system", selector: "@media (prefers-color-scheme: dark){:root{[CSS]}}", matched: this.pattern.test(value3.trim()) };
        }
      },
      custom: {
        resolve(value3) {
          return { type: "custom", selector: value3, matched: true };
        }
      }
    },
    resolve(value3) {
      const rules = Object.keys(this.rules).filter((k) => k !== "custom").map((r) => this.rules[r]);
      return [value3].flat().map((v2) => {
        var _a;
        return (_a = rules.map((r) => r.resolve(v2)).find((rr) => rr.matched)) != null ? _a : this.rules.custom.resolve(v2);
      });
    }
  },
  _toVariables(theme38, options3) {
    return toVariables_default(theme38, { prefix: options3 == null ? void 0 : options3.prefix });
  },
  getCommon({ name = "", theme: theme38 = {}, params, set: set2, defaults: defaults2 }) {
    var _c, _d, _e, _f;
    const { preset, options: options3 } = theme38;
    let primitive_css, primitive_tokens, semantic_css, semantic_tokens;
    if (isNotEmpty(preset)) {
      const { primitive, semantic } = preset;
      const _a = semantic || {}, { colorScheme } = _a, sRest = __objRest(_a, ["colorScheme"]);
      const _b = colorScheme || {}, { dark } = _b, csRest = __objRest(_b, ["dark"]);
      const prim_var = isNotEmpty(primitive) ? this._toVariables({ primitive }, options3) : {};
      const sRest_var = isNotEmpty(sRest) ? this._toVariables({ semantic: sRest }, options3) : {};
      const csRest_var = isNotEmpty(csRest) ? this._toVariables({ light: csRest }, options3) : {};
      const dark_var = isNotEmpty(dark) ? this._toVariables({ dark }, options3) : {};
      const [prim_css, prim_tokens] = [(_c = prim_var.declarations) != null ? _c : "", prim_var.tokens];
      const [sRest_css, sRest_tokens] = [(_d = sRest_var.declarations) != null ? _d : "", sRest_var.tokens || []];
      const [csRest_css, csRest_tokens] = [(_e = csRest_var.declarations) != null ? _e : "", csRest_var.tokens || []];
      const [dark_css, dark_tokens] = [(_f = dark_var.declarations) != null ? _f : "", dark_var.tokens || []];
      primitive_css = this.transformCSS(name, prim_css, "light", "variable", options3, set2, defaults2);
      primitive_tokens = prim_tokens;
      const semantic_light_css = this.transformCSS(name, `${sRest_css}${csRest_css}color-scheme:light`, "light", "variable", options3, set2, defaults2);
      const semantic_dark_css = this.transformCSS(name, `${dark_css}color-scheme:dark`, "dark", "variable", options3, set2, defaults2);
      semantic_css = `${semantic_light_css}${semantic_dark_css}`;
      semantic_tokens = [.../* @__PURE__ */ new Set([...sRest_tokens, ...csRest_tokens, ...dark_tokens])];
    }
    return {
      primitive: {
        css: primitive_css,
        tokens: primitive_tokens
      },
      semantic: {
        css: semantic_css,
        tokens: semantic_tokens
      }
    };
  },
  getPreset({ name = "", preset = {}, options: options3, params, set: set2, defaults: defaults2, selector }) {
    var _c, _d, _e;
    const _name = name.replace("-directive", "");
    const _a = preset, { colorScheme } = _a, vRest = __objRest(_a, ["colorScheme"]);
    const _b = colorScheme || {}, { dark } = _b, csRest = __objRest(_b, ["dark"]);
    const vRest_var = isNotEmpty(vRest) ? this._toVariables({ [_name]: vRest }, options3) : {};
    const csRest_var = isNotEmpty(csRest) ? this._toVariables({ [_name]: csRest }, options3) : {};
    const dark_var = isNotEmpty(dark) ? this._toVariables({ [_name]: dark }, options3) : {};
    const [vRest_css, vRest_tokens] = [(_c = vRest_var.declarations) != null ? _c : "", vRest_var.tokens || []];
    const [csRest_css, csRest_tokens] = [(_d = csRest_var.declarations) != null ? _d : "", csRest_var.tokens || []];
    const [dark_css, dark_tokens] = [(_e = dark_var.declarations) != null ? _e : "", dark_var.tokens || []];
    const tokens = [.../* @__PURE__ */ new Set([...vRest_tokens, ...csRest_tokens, ...dark_tokens])];
    const light_variable_css = this.transformCSS(_name, `${vRest_css}${csRest_css}`, "light", "variable", options3, set2, defaults2, selector);
    const dark_variable_css = this.transformCSS(_name, dark_css, "dark", "variable", options3, set2, defaults2, selector);
    return {
      css: `${light_variable_css}${dark_variable_css}`,
      tokens
    };
  },
  getPresetC({ name = "", theme: theme38 = {}, params, set: set2, defaults: defaults2 }) {
    var _a;
    const { preset, options: options3 } = theme38;
    const cPreset = (_a = preset == null ? void 0 : preset.components) == null ? void 0 : _a[name];
    return this.getPreset({ name, preset: cPreset, options: options3, params, set: set2, defaults: defaults2 });
  },
  getPresetD({ name = "", theme: theme38 = {}, params, set: set2, defaults: defaults2 }) {
    var _a;
    const dName = name.replace("-directive", "");
    const { preset, options: options3 } = theme38;
    const dPreset = (_a = preset == null ? void 0 : preset.directives) == null ? void 0 : _a[dName];
    return this.getPreset({ name: dName, preset: dPreset, options: options3, params, set: set2, defaults: defaults2 });
  },
  getColorSchemeOption(options3, defaults2) {
    var _a;
    return this.regex.resolve((_a = options3.darkModeSelector) != null ? _a : defaults2.options.darkModeSelector);
  },
  getLayerOrder(name, options3 = {}, params, defaults2) {
    const { cssLayer } = options3;
    if (cssLayer) {
      const order = resolve(cssLayer.order || "primeui", params);
      return `@layer ${order}`;
    }
    return "";
  },
  getCommonStyleSheet({ name = "", theme: theme38 = {}, params, props = {}, set: set2, defaults: defaults2 }) {
    const common = this.getCommon({ name, theme: theme38, params, set: set2, defaults: defaults2 });
    const _props = Object.entries(props).reduce((acc, [k, v2]) => acc.push(`${k}="${v2}"`) && acc, []).join(" ");
    return Object.entries(common || {}).reduce((acc, [key, value3]) => {
      if (value3 == null ? void 0 : value3.css) {
        const _css = minifyCSS(value3 == null ? void 0 : value3.css);
        const id3 = `${key}-variables`;
        acc.push(`<style type="text/css" data-primevue-style-id="${id3}" ${_props}>${_css}</style>`);
      }
      return acc;
    }, []).join("");
  },
  getStyleSheet({ name = "", theme: theme38 = {}, params, props = {}, set: set2, defaults: defaults2 }) {
    var _a;
    const options3 = { name, theme: theme38, params, set: set2, defaults: defaults2 };
    const preset_css = (_a = name.includes("-directive") ? this.getPresetD(options3) : this.getPresetC(options3)) == null ? void 0 : _a.css;
    const _props = Object.entries(props).reduce((acc, [k, v2]) => acc.push(`${k}="${v2}"`) && acc, []).join(" ");
    return preset_css ? `<style type="text/css" data-primevue-style-id="${name}-variables" ${_props}>${minifyCSS(preset_css)}</style>` : "";
  },
  createTokens(obj = {}, defaults2, parentKey = "", parentPath = "", tokens = {}) {
    Object.entries(obj).forEach(([key, value3]) => {
      const currentKey = matchRegex(key, defaults2.variable.excludedKeyRegex) ? parentKey : parentKey ? `${parentKey}.${toTokenKey$1(key)}` : toTokenKey$1(key);
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      if (isObject$4(value3)) {
        this.createTokens(value3, defaults2, currentKey, currentPath, tokens);
      } else {
        tokens[currentKey] || (tokens[currentKey] = {
          paths: [],
          computed(colorScheme, tokenPathMap = {}) {
            if (colorScheme) {
              const path = this.paths.find((p2) => p2.scheme === colorScheme) || this.paths.find((p2) => p2.scheme === "none");
              return path == null ? void 0 : path.computed(colorScheme, tokenPathMap["binding"]);
            }
            return this.paths.map((p2) => p2.computed(p2.scheme, tokenPathMap[p2.scheme]));
          }
        });
        tokens[currentKey].paths.push({
          path: currentPath,
          value: value3,
          scheme: currentPath.includes("colorScheme.light") ? "light" : currentPath.includes("colorScheme.dark") ? "dark" : "none",
          computed(colorScheme, tokenPathMap = {}) {
            const regex = /{([^}]*)}/g;
            let computedValue = value3;
            tokenPathMap["name"] = this.path;
            tokenPathMap["binding"] || (tokenPathMap["binding"] = {});
            if (matchRegex(value3, regex)) {
              const val = value3.trim();
              const _val = val.replaceAll(regex, (v2) => {
                var _a, _b;
                const path = v2.replace(/{|}/g, "");
                return (_b = (_a = tokens[path]) == null ? void 0 : _a.computed(colorScheme, tokenPathMap)) == null ? void 0 : _b.value;
              });
              const calculationRegex = /(\d+\w*\s+[\+\-\*\/]\s+\d+\w*)/g;
              const cleanedVarRegex = /var\([^)]+\)/g;
              computedValue = matchRegex(_val.replace(cleanedVarRegex, "0"), calculationRegex) ? `calc(${_val})` : _val;
            }
            isEmpty(tokenPathMap["binding"]) && delete tokenPathMap["binding"];
            return {
              colorScheme,
              path: this.path,
              paths: tokenPathMap,
              value: computedValue.includes("undefined") ? void 0 : computedValue
            };
          }
        });
      }
    });
    return tokens;
  },
  getTokenValue(tokens, path, defaults2) {
    var _a;
    const normalizePath = /* @__PURE__ */ __name((str) => {
      const strArr = str.split(".");
      return strArr.filter((s) => !matchRegex(s.toLowerCase(), defaults2.variable.excludedKeyRegex)).join(".");
    }, "normalizePath");
    const token = normalizePath(path);
    const colorScheme = path.includes("colorScheme.light") ? "light" : path.includes("colorScheme.dark") ? "dark" : void 0;
    const computedValues = [(_a = tokens[token]) == null ? void 0 : _a.computed(colorScheme)].flat().filter((computed2) => computed2);
    return computedValues.length === 1 ? computedValues[0].value : computedValues.reduce((acc = {}, computed2) => {
      const _a2 = computed2, { colorScheme: cs } = _a2, rest = __objRest(_a2, ["colorScheme"]);
      acc[cs] = rest;
      return acc;
    }, void 0);
  },
  transformCSS(name, css22, mode2, type, options3 = {}, set2, defaults2, selector) {
    if (isNotEmpty(css22)) {
      const { cssLayer } = options3;
      if (type !== "style") {
        const colorSchemeOption = this.getColorSchemeOption(options3, defaults2);
        const _css = selector ? getRule(selector, css22) : css22;
        css22 = mode2 === "dark" ? colorSchemeOption.reduce((acc, { selector: _selector }) => {
          if (isNotEmpty(_selector)) {
            acc += _selector.includes("[CSS]") ? _selector.replace("[CSS]", _css) : getRule(_selector, _css);
          }
          return acc;
        }, "") : getRule(selector != null ? selector : ":root", css22);
      }
      if (cssLayer) {
        const layerOptions = {
          name: "primeui",
          order: "primeui"
        };
        isObject$4(cssLayer) && (layerOptions.name = resolve(cssLayer.name, { name, type }));
        if (isNotEmpty(layerOptions.name)) {
          css22 = getRule(`@layer ${layerOptions.name}`, css22);
          set2 == null ? void 0 : set2.layerNames(layerOptions.name);
        }
      }
      return css22;
    }
    return "";
  }
};
var config_default = {
  defaults: {
    variable: {
      prefix: "p",
      selector: ":root",
      excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states)$/gi
    },
    options: {
      prefix: "p",
      darkModeSelector: "system",
      cssLayer: false
    }
  },
  _theme: void 0,
  _layerNames: /* @__PURE__ */ new Set(),
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  _loadingStyles: /* @__PURE__ */ new Set(),
  _tokens: {},
  update(newValues = {}) {
    const { theme: theme38 } = newValues;
    if (theme38) {
      this._theme = __spreadProps(__spreadValues({}, theme38), {
        options: __spreadValues(__spreadValues({}, this.defaults.options), theme38.options)
      });
      this._tokens = themeUtils_default.createTokens(this.preset, this.defaults);
      this.clearLoadedStyleNames();
    }
  },
  get theme() {
    return this._theme;
  },
  get preset() {
    var _a;
    return ((_a = this.theme) == null ? void 0 : _a.preset) || {};
  },
  get options() {
    var _a;
    return ((_a = this.theme) == null ? void 0 : _a.options) || {};
  },
  get tokens() {
    return this._tokens;
  },
  getTheme() {
    return this.theme;
  },
  setTheme(newValue) {
    this.update({ theme: newValue });
    service_default.emit("theme:change", newValue);
  },
  getPreset() {
    return this.preset;
  },
  setPreset(newValue) {
    this._theme = __spreadProps(__spreadValues({}, this.theme), { preset: newValue });
    this._tokens = themeUtils_default.createTokens(newValue, this.defaults);
    this.clearLoadedStyleNames();
    service_default.emit("preset:change", newValue);
    service_default.emit("theme:change", this.theme);
  },
  getOptions() {
    return this.options;
  },
  setOptions(newValue) {
    this._theme = __spreadProps(__spreadValues({}, this.theme), { options: newValue });
    this.clearLoadedStyleNames();
    service_default.emit("options:change", newValue);
    service_default.emit("theme:change", this.theme);
  },
  getLayerNames() {
    return [...this._layerNames];
  },
  setLayerNames(layerName) {
    this._layerNames.add(layerName);
  },
  getLoadedStyleNames() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  },
  setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  },
  deleteLoadedStyleName(name) {
    this._loadedStyleNames.delete(name);
  },
  clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  },
  getTokenValue(tokenPath) {
    return themeUtils_default.getTokenValue(this.tokens, tokenPath, this.defaults);
  },
  getCommon(name = "", params) {
    return themeUtils_default.getCommon({ name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  getComponent(name = "", params) {
    const options3 = { name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPresetC(options3);
  },
  getDirective(name = "", params) {
    const options3 = { name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPresetD(options3);
  },
  getCustomPreset(name = "", preset, selector, params) {
    const options3 = { name, preset, options: this.options, selector, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPreset(options3);
  },
  getLayerOrderCSS(name = "") {
    return themeUtils_default.getLayerOrder(name, this.options, { names: this.getLayerNames() }, this.defaults);
  },
  transformCSS(name = "", css22, type = "style", mode2) {
    return themeUtils_default.transformCSS(name, css22, mode2, type, this.options, { layerNames: this.setLayerNames.bind(this) }, this.defaults);
  },
  getCommonStyleSheet(name = "", params, props = {}) {
    return themeUtils_default.getCommonStyleSheet({ name, theme: this.theme, params, props, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  getStyleSheet(name, params, props = {}) {
    return themeUtils_default.getStyleSheet({ name, theme: this.theme, params, props, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  onStyleMounted(name) {
    this._loadingStyles.add(name);
  },
  onStyleUpdated(name) {
    this._loadingStyles.add(name);
  },
  onStyleLoaded(event2, { name }) {
    if (this._loadingStyles.size) {
      this._loadingStyles.delete(name);
      service_default.emit(`theme:${name}:load`, event2);
      !this._loadingStyles.size && service_default.emit("theme:load");
    }
  }
};
function updatePreset(...presets) {
  const newPreset = mergeKeys(config_default.getPreset(), ...presets);
  config_default.setPreset(newPreset);
  return newPreset;
}
__name(updatePreset, "updatePreset");
function updatePrimaryPalette(primary) {
  return $t().primaryPalette(primary).update().preset;
}
__name(updatePrimaryPalette, "updatePrimaryPalette");
function updateSurfacePalette(palette) {
  return $t().surfacePalette(palette).update().preset;
}
__name(updateSurfacePalette, "updateSurfacePalette");
function usePreset(...presets) {
  const newPreset = mergeKeys(...presets);
  config_default.setPreset(newPreset);
  return newPreset;
}
__name(usePreset, "usePreset");
function useTheme(theme38) {
  return $t(theme38).update({ mergePresets: false });
}
__name(useTheme, "useTheme");
var Base = {
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  getLoadedStyleNames: /* @__PURE__ */ __name(function getLoadedStyleNames() {
    return this._loadedStyleNames;
  }, "getLoadedStyleNames"),
  isStyleNameLoaded: /* @__PURE__ */ __name(function isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  }, "isStyleNameLoaded"),
  setLoadedStyleName: /* @__PURE__ */ __name(function setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  }, "setLoadedStyleName"),
  deleteLoadedStyleName: /* @__PURE__ */ __name(function deleteLoadedStyleName(name) {
    this._loadedStyleNames["delete"](name);
  }, "deleteLoadedStyleName"),
  clearLoadedStyleNames: /* @__PURE__ */ __name(function clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  }, "clearLoadedStyleNames")
};
function _typeof$j(o) {
  "@babel/helpers - typeof";
  return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$j(o);
}
__name(_typeof$j, "_typeof$j");
function ownKeys$j(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$j, "ownKeys$j");
function _objectSpread$j(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$j(Object(t), true).forEach(function(r2) {
      _defineProperty$j(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$j, "_objectSpread$j");
function _defineProperty$j(e, r, t) {
  return (r = _toPropertyKey$i(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$j, "_defineProperty$j");
function _toPropertyKey$i(t) {
  var i2 = _toPrimitive$i(t, "string");
  return "symbol" == _typeof$j(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$i, "_toPropertyKey$i");
function _toPrimitive$i(t, r) {
  if ("object" != _typeof$j(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$j(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$i, "_toPrimitive$i");
function tryOnMounted$1(fn) {
  var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (getCurrentInstance()) onMounted(fn);
  else if (sync) fn();
  else nextTick(fn);
}
__name(tryOnMounted$1, "tryOnMounted$1");
var _id$1 = 0;
function useStyle(css3) {
  var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var isLoaded = ref(false);
  var cssRef = ref(css3);
  var styleRef = ref(null);
  var defaultDocument2 = isClient$1() ? window.document : void 0;
  var _options$document = options3.document, document2 = _options$document === void 0 ? defaultDocument2 : _options$document, _options$immediate = options3.immediate, immediate = _options$immediate === void 0 ? true : _options$immediate, _options$manual = options3.manual, manual = _options$manual === void 0 ? false : _options$manual, _options$name = options3.name, name = _options$name === void 0 ? "style_".concat(++_id$1) : _options$name, _options$id = options3.id, id3 = _options$id === void 0 ? void 0 : _options$id, _options$media = options3.media, media = _options$media === void 0 ? void 0 : _options$media, _options$nonce = options3.nonce, nonce = _options$nonce === void 0 ? void 0 : _options$nonce, _options$first = options3.first, first = _options$first === void 0 ? false : _options$first, _options$onMounted = options3.onMounted, onStyleMounted = _options$onMounted === void 0 ? void 0 : _options$onMounted, _options$onUpdated = options3.onUpdated, onStyleUpdated = _options$onUpdated === void 0 ? void 0 : _options$onUpdated, _options$onLoad = options3.onLoad, onStyleLoaded = _options$onLoad === void 0 ? void 0 : _options$onLoad, _options$props = options3.props, props = _options$props === void 0 ? {} : _options$props;
  var stop2 = /* @__PURE__ */ __name(function stop3() {
  }, "stop");
  var load2 = /* @__PURE__ */ __name(function load3(_css) {
    var _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!document2) return;
    var _styleProps = _objectSpread$j(_objectSpread$j({}, props), _props);
    var _name = _styleProps.name || name, _id2 = _styleProps.id || id3, _nonce = _styleProps.nonce || nonce;
    styleRef.value = document2.querySelector('style[data-primevue-style-id="'.concat(_name, '"]')) || document2.getElementById(_id2) || document2.createElement("style");
    if (!styleRef.value.isConnected) {
      cssRef.value = _css || css3;
      setAttributes(styleRef.value, {
        type: "text/css",
        id: _id2,
        media,
        nonce: _nonce
      });
      first ? document2.head.prepend(styleRef.value) : document2.head.appendChild(styleRef.value);
      setAttribute(styleRef.value, "data-primevue-style-id", _name);
      setAttributes(styleRef.value, _styleProps);
      styleRef.value.onload = function(event2) {
        return onStyleLoaded === null || onStyleLoaded === void 0 ? void 0 : onStyleLoaded(event2, {
          name: _name
        });
      };
      onStyleMounted === null || onStyleMounted === void 0 || onStyleMounted(_name);
    }
    if (isLoaded.value) return;
    stop2 = watch(cssRef, function(value3) {
      styleRef.value.textContent = value3;
      onStyleUpdated === null || onStyleUpdated === void 0 || onStyleUpdated(_name);
    }, {
      immediate: true
    });
    isLoaded.value = true;
  }, "load");
  var unload = /* @__PURE__ */ __name(function unload2() {
    if (!document2 || !isLoaded.value) return;
    stop2();
    isExist(styleRef.value) && document2.head.removeChild(styleRef.value);
    isLoaded.value = false;
  }, "unload");
  if (immediate && !manual) tryOnMounted$1(load2);
  return {
    id: id3,
    name,
    el: styleRef,
    css: cssRef,
    unload,
    load: load2,
    isLoaded: readonly(isLoaded)
  };
}
__name(useStyle, "useStyle");
function _typeof$i(o) {
  "@babel/helpers - typeof";
  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$i(o);
}
__name(_typeof$i, "_typeof$i");
function _slicedToArray$4(r, e) {
  return _arrayWithHoles$4(r) || _iterableToArrayLimit$4(r, e) || _unsupportedIterableToArray$g(r, e) || _nonIterableRest$4();
}
__name(_slicedToArray$4, "_slicedToArray$4");
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$4, "_nonIterableRest$4");
function _unsupportedIterableToArray$g(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$g(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$g(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$g, "_unsupportedIterableToArray$g");
function _arrayLikeToArray$g(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$g, "_arrayLikeToArray$g");
function _iterableToArrayLimit$4(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$4, "_iterableToArrayLimit$4");
function _arrayWithHoles$4(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$4, "_arrayWithHoles$4");
function ownKeys$i(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$i, "ownKeys$i");
function _objectSpread$i(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$i(Object(t), true).forEach(function(r2) {
      _defineProperty$i(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$i, "_objectSpread$i");
function _defineProperty$i(e, r, t) {
  return (r = _toPropertyKey$h(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$i, "_defineProperty$i");
function _toPropertyKey$h(t) {
  var i2 = _toPrimitive$h(t, "string");
  return "symbol" == _typeof$i(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$h, "_toPropertyKey$h");
function _toPrimitive$h(t, r) {
  if ("object" != _typeof$i(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$i(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$h, "_toPrimitive$h");
var theme$z = /* @__PURE__ */ __name(function theme2(_ref) {
  var dt2 = _ref.dt;
  return "\n* {\n    box-sizing: border-box;\n}\n\n/* Non vue overlay animations */\n.p-connected-overlay {\n    opacity: 0;\n    transform: scaleY(0.8);\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n        opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-connected-overlay-visible {\n    opacity: 1;\n    transform: scaleY(1);\n}\n\n.p-connected-overlay-hidden {\n    opacity: 0;\n    transform: scaleY(1);\n    transition: opacity 0.1s linear;\n}\n\n/* Vue based overlay animations */\n.p-connected-overlay-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-connected-overlay-leave-to {\n    opacity: 0;\n}\n\n.p-connected-overlay-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n        opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-connected-overlay-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n/* Toggleable Content */\n.p-toggleable-content-enter-from,\n.p-toggleable-content-leave-to {\n    max-height: 0;\n}\n\n.p-toggleable-content-enter-to,\n.p-toggleable-content-leave-from {\n    max-height: 1000px;\n}\n\n.p-toggleable-content-leave-active {\n    overflow: hidden;\n    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1);\n}\n\n.p-toggleable-content-enter-active {\n    overflow: hidden;\n    transition: max-height 1s ease-in-out;\n}\n\n.p-disabled,\n.p-disabled * {\n    cursor: default;\n    pointer-events: none;\n    user-select: none;\n}\n\n.p-disabled,\n.p-component:disabled {\n    opacity: ".concat(dt2("disabled.opacity"), ";\n}\n\n.pi {\n    font-size: ").concat(dt2("icon.size"), ";\n}\n\n.p-icon {\n    width: ").concat(dt2("icon.size"), ";\n    height: ").concat(dt2("icon.size"), ";\n}\n\n.p-overlay-mask {\n    background: ").concat(dt2("mask.background"), ";\n    color: ").concat(dt2("mask.color"), ";\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.p-overlay-mask-enter {\n    animation: p-overlay-mask-enter-animation ").concat(dt2("mask.transition.duration"), " forwards;\n}\n\n.p-overlay-mask-leave {\n    animation: p-overlay-mask-leave-animation ").concat(dt2("mask.transition.duration"), " forwards;\n}\n\n@keyframes p-overlay-mask-enter-animation {\n    from {\n        background: transparent;\n    }\n    to {\n        background: ").concat(dt2("mask.background"), ";\n    }\n}\n@keyframes p-overlay-mask-leave-animation {\n    from {\n        background: ").concat(dt2("mask.background"), ";\n    }\n    to {\n        background: transparent;\n    }\n}\n");
}, "theme");
var css$1 = /* @__PURE__ */ __name(function css2(_ref2) {
  var dt2 = _ref2.dt;
  return "\n.p-hidden-accessible {\n    border: 0;\n    clip: rect(0 0 0 0);\n    height: 1px;\n    margin: -1px;\n    overflow: hidden;\n    padding: 0;\n    position: absolute;\n    width: 1px;\n}\n\n.p-hidden-accessible input,\n.p-hidden-accessible select {\n    transform: scale(0);\n}\n\n.p-overflow-hidden {\n    overflow: hidden;\n    padding-right: ".concat(dt2("scrollbar.width"), ";\n}\n");
}, "css");
var classes$B = {};
var inlineStyles$4 = {};
var BaseStyle = {
  name: "base",
  css: css$1,
  theme: theme$z,
  classes: classes$B,
  inlineStyles: inlineStyles$4,
  load: /* @__PURE__ */ __name(function load(style) {
    var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var transform2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(cs) {
      return cs;
    };
    var computedStyle = transform2(resolve(style, {
      dt
    }));
    return computedStyle ? useStyle(minifyCSS(computedStyle), _objectSpread$i({
      name: this.name
    }, options3)) : {};
  }, "load"),
  loadCSS: /* @__PURE__ */ __name(function loadCSS() {
    var options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.css, options3);
  }, "loadCSS"),
  loadTheme: /* @__PURE__ */ __name(function loadTheme() {
    var _this = this;
    var options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.theme, options3, function(computedStyle) {
      return config_default.transformCSS(options3.name || _this.name, computedStyle);
    });
  }, "loadTheme"),
  getCommonTheme: /* @__PURE__ */ __name(function getCommonTheme(params) {
    return config_default.getCommon(this.name, params);
  }, "getCommonTheme"),
  getComponentTheme: /* @__PURE__ */ __name(function getComponentTheme(params) {
    return config_default.getComponent(this.name, params);
  }, "getComponentTheme"),
  getDirectiveTheme: /* @__PURE__ */ __name(function getDirectiveTheme(params) {
    return config_default.getDirective(this.name, params);
  }, "getDirectiveTheme"),
  getPresetTheme: /* @__PURE__ */ __name(function getPresetTheme(preset, selector, params) {
    return config_default.getCustomPreset(this.name, preset, selector, params);
  }, "getPresetTheme"),
  getLayerOrderThemeCSS: /* @__PURE__ */ __name(function getLayerOrderThemeCSS() {
    return config_default.getLayerOrderCSS(this.name);
  }, "getLayerOrderThemeCSS"),
  getStyleSheet: /* @__PURE__ */ __name(function getStyleSheet() {
    var extendedCSS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.css) {
      var _css = resolve(this.css, {
        dt
      });
      var _style = minifyCSS("".concat(_css).concat(extendedCSS));
      var _props = Object.entries(props).reduce(function(acc, _ref3) {
        var _ref4 = _slicedToArray$4(_ref3, 2), k = _ref4[0], v2 = _ref4[1];
        return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      return '<style type="text/css" data-primevue-style-id="'.concat(this.name, '" ').concat(_props, ">").concat(_style, "</style>");
    }
    return "";
  }, "getStyleSheet"),
  getCommonThemeStyleSheet: /* @__PURE__ */ __name(function getCommonThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return config_default.getCommonStyleSheet(this.name, params, props);
  }, "getCommonThemeStyleSheet"),
  getThemeStyleSheet: /* @__PURE__ */ __name(function getThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var css3 = [config_default.getStyleSheet(this.name, params, props)];
    if (this.theme) {
      var name = this.name === "base" ? "global-style" : "".concat(this.name, "-style");
      var _css = resolve(this.theme, {
        dt
      });
      var _style = minifyCSS(config_default.transformCSS(name, _css));
      var _props = Object.entries(props).reduce(function(acc, _ref5) {
        var _ref6 = _slicedToArray$4(_ref5, 2), k = _ref6[0], v2 = _ref6[1];
        return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      css3.push('<style type="text/css" data-primevue-style-id="'.concat(name, '" ').concat(_props, ">").concat(_style, "</style>"));
    }
    return css3.join("");
  }, "getThemeStyleSheet"),
  extend: /* @__PURE__ */ __name(function extend2(style) {
    return _objectSpread$i(_objectSpread$i({}, this), {}, {
      css: void 0,
      theme: void 0
    }, style);
  }, "extend")
};
var BaseComponentStyle = BaseStyle.extend({
  name: "common"
});
function _typeof$h(o) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$h(o);
}
__name(_typeof$h, "_typeof$h");
function _toArray(r) {
  return _arrayWithHoles$3(r) || _iterableToArray$b(r) || _unsupportedIterableToArray$f(r) || _nonIterableRest$3();
}
__name(_toArray, "_toArray");
function _iterableToArray$b(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$b, "_iterableToArray$b");
function _slicedToArray$3(r, e) {
  return _arrayWithHoles$3(r) || _iterableToArrayLimit$3(r, e) || _unsupportedIterableToArray$f(r, e) || _nonIterableRest$3();
}
__name(_slicedToArray$3, "_slicedToArray$3");
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$3, "_nonIterableRest$3");
function _unsupportedIterableToArray$f(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$f(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$f(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$f, "_unsupportedIterableToArray$f");
function _arrayLikeToArray$f(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$f, "_arrayLikeToArray$f");
function _iterableToArrayLimit$3(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$3, "_iterableToArrayLimit$3");
function _arrayWithHoles$3(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$3, "_arrayWithHoles$3");
function ownKeys$h(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$h, "ownKeys$h");
function _objectSpread$h(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$h(Object(t), true).forEach(function(r2) {
      _defineProperty$h(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$h, "_objectSpread$h");
function _defineProperty$h(e, r, t) {
  return (r = _toPropertyKey$g(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$h, "_defineProperty$h");
function _toPropertyKey$g(t) {
  var i2 = _toPrimitive$g(t, "string");
  return "symbol" == _typeof$h(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$g, "_toPropertyKey$g");
function _toPrimitive$g(t, r) {
  if ("object" != _typeof$h(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$h(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$g, "_toPrimitive$g");
var script$Y = {
  name: "BaseComponent",
  props: {
    pt: {
      type: Object,
      "default": void 0
    },
    ptOptions: {
      type: Object,
      "default": void 0
    },
    unstyled: {
      type: Boolean,
      "default": void 0
    },
    dt: {
      type: Object,
      "default": void 0
    }
  },
  inject: {
    $parentInstance: {
      "default": void 0
    }
  },
  watch: {
    isUnstyled: {
      immediate: true,
      handler: /* @__PURE__ */ __name(function handler2(newValue) {
        if (!newValue) {
          this._loadCoreStyles();
          this._themeChangeListener(this._loadCoreStyles);
        }
      }, "handler")
    },
    dt: {
      immediate: true,
      handler: /* @__PURE__ */ __name(function handler3(newValue) {
        var _this = this;
        if (newValue) {
          this._loadScopedThemeStyles(newValue);
          this._themeChangeListener(function() {
            return _this._loadScopedThemeStyles(newValue);
          });
        } else {
          this._unloadScopedThemeStyles();
        }
      }, "handler")
    }
  },
  scopedStyleEl: void 0,
  rootEl: void 0,
  beforeCreate: /* @__PURE__ */ __name(function beforeCreate() {
    var _this$pt, _this$pt2, _this$pt3, _ref, _ref$onBeforeCreate, _this$$primevueConfig, _this$$primevue, _this$$primevue2, _this$$primevue3, _ref2, _ref2$onBeforeCreate;
    var _usept = (_this$pt = this.pt) === null || _this$pt === void 0 ? void 0 : _this$pt["_usept"];
    var originalValue = _usept ? (_this$pt2 = this.pt) === null || _this$pt2 === void 0 || (_this$pt2 = _this$pt2.originalValue) === null || _this$pt2 === void 0 ? void 0 : _this$pt2[this.$.type.name] : void 0;
    var value3 = _usept ? (_this$pt3 = this.pt) === null || _this$pt3 === void 0 || (_this$pt3 = _this$pt3.value) === null || _this$pt3 === void 0 ? void 0 : _this$pt3[this.$.type.name] : this.pt;
    (_ref = value3 || originalValue) === null || _ref === void 0 || (_ref = _ref.hooks) === null || _ref === void 0 || (_ref$onBeforeCreate = _ref["onBeforeCreate"]) === null || _ref$onBeforeCreate === void 0 || _ref$onBeforeCreate.call(_ref);
    var _useptInConfig = (_this$$primevueConfig = this.$primevueConfig) === null || _this$$primevueConfig === void 0 || (_this$$primevueConfig = _this$$primevueConfig.pt) === null || _this$$primevueConfig === void 0 ? void 0 : _this$$primevueConfig["_usept"];
    var originalValueInConfig = _useptInConfig ? (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.pt) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.originalValue : void 0;
    var valueInConfig = _useptInConfig ? (_this$$primevue2 = this.$primevue) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.config) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.pt) === null || _this$$primevue2 === void 0 ? void 0 : _this$$primevue2.value : (_this$$primevue3 = this.$primevue) === null || _this$$primevue3 === void 0 || (_this$$primevue3 = _this$$primevue3.config) === null || _this$$primevue3 === void 0 ? void 0 : _this$$primevue3.pt;
    (_ref2 = valueInConfig || originalValueInConfig) === null || _ref2 === void 0 || (_ref2 = _ref2[this.$.type.name]) === null || _ref2 === void 0 || (_ref2 = _ref2.hooks) === null || _ref2 === void 0 || (_ref2$onBeforeCreate = _ref2["onBeforeCreate"]) === null || _ref2$onBeforeCreate === void 0 || _ref2$onBeforeCreate.call(_ref2);
  }, "beforeCreate"),
  created: /* @__PURE__ */ __name(function created() {
    this._hook("onCreated");
  }, "created"),
  beforeMount: /* @__PURE__ */ __name(function beforeMount() {
    this._loadStyles();
    this._hook("onBeforeMount");
  }, "beforeMount"),
  mounted: /* @__PURE__ */ __name(function mounted() {
    this.rootEl = findSingle(this.$el, '[data-pc-name="'.concat(toFlatCase(this.$.type.name), '"]'));
    if (this.rootEl) {
      this.rootEl.setAttribute(this.$attrSelector, "");
      this.rootEl.$pc = _objectSpread$h({
        name: this.$.type.name
      }, this.$params);
    }
    this._hook("onMounted");
  }, "mounted"),
  beforeUpdate: /* @__PURE__ */ __name(function beforeUpdate() {
    this._hook("onBeforeUpdate");
  }, "beforeUpdate"),
  updated: /* @__PURE__ */ __name(function updated() {
    this._hook("onUpdated");
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount() {
    this._hook("onBeforeUnmount");
  }, "beforeUnmount"),
  unmounted: /* @__PURE__ */ __name(function unmounted() {
    this._unloadScopedThemeStyles();
    this._hook("onUnmounted");
  }, "unmounted"),
  methods: {
    _hook: /* @__PURE__ */ __name(function _hook(hookName) {
      if (!this.$options.hostName) {
        var selfHook = this._usePT(this._getPT(this.pt, this.$.type.name), this._getOptionValue, "hooks.".concat(hookName));
        var defaultHook = this._useDefaultPT(this._getOptionValue, "hooks.".concat(hookName));
        selfHook === null || selfHook === void 0 || selfHook();
        defaultHook === null || defaultHook === void 0 || defaultHook();
      }
    }, "_hook"),
    _mergeProps: /* @__PURE__ */ __name(function _mergeProps(fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return isFunction$1(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
    }, "_mergeProps"),
    _loadStyles: /* @__PURE__ */ __name(function _loadStyles() {
      var _this2 = this;
      var _load = /* @__PURE__ */ __name(function _load2() {
        if (!Base.isStyleNameLoaded("base")) {
          BaseStyle.loadCSS(_this2.$styleOptions);
          _this2._loadGlobalStyles();
          Base.setLoadedStyleName("base");
        }
        _this2._loadThemeStyles();
      }, "_load");
      _load();
      this._themeChangeListener(_load);
    }, "_loadStyles"),
    _loadCoreStyles: /* @__PURE__ */ __name(function _loadCoreStyles() {
      var _this$$style, _this$$style2;
      if (!Base.isStyleNameLoaded((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.name) && (_this$$style2 = this.$style) !== null && _this$$style2 !== void 0 && _this$$style2.name) {
        BaseComponentStyle.loadCSS(this.$styleOptions);
        this.$options.style && this.$style.loadCSS(this.$styleOptions);
        Base.setLoadedStyleName(this.$style.name);
      }
    }, "_loadCoreStyles"),
    _loadGlobalStyles: /* @__PURE__ */ __name(function _loadGlobalStyles() {
      var globalCSS = this._useGlobalPT(this._getOptionValue, "global.css", this.$params);
      isNotEmpty(globalCSS) && BaseStyle.load(globalCSS, _objectSpread$h({
        name: "global"
      }, this.$styleOptions));
    }, "_loadGlobalStyles"),
    _loadThemeStyles: /* @__PURE__ */ __name(function _loadThemeStyles() {
      var _this$$style4, _this$$style5;
      if (this.isUnstyled) return;
      if (!config_default.isStyleNameLoaded("common")) {
        var _this$$style3, _this$$style3$getComm;
        var _ref3 = ((_this$$style3 = this.$style) === null || _this$$style3 === void 0 || (_this$$style3$getComm = _this$$style3.getCommonTheme) === null || _this$$style3$getComm === void 0 ? void 0 : _this$$style3$getComm.call(_this$$style3)) || {}, primitive = _ref3.primitive, semantic = _ref3.semantic;
        BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$h({
          name: "primitive-variables"
        }, this.$styleOptions));
        BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$h({
          name: "semantic-variables"
        }, this.$styleOptions));
        BaseStyle.loadTheme(_objectSpread$h({
          name: "global-style"
        }, this.$styleOptions));
        config_default.setLoadedStyleName("common");
      }
      if (!config_default.isStyleNameLoaded((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.name) && (_this$$style5 = this.$style) !== null && _this$$style5 !== void 0 && _this$$style5.name) {
        var _this$$style6, _this$$style6$getComp, _this$$style7, _this$$style8;
        var _ref4 = ((_this$$style6 = this.$style) === null || _this$$style6 === void 0 || (_this$$style6$getComp = _this$$style6.getComponentTheme) === null || _this$$style6$getComp === void 0 ? void 0 : _this$$style6$getComp.call(_this$$style6)) || {}, css3 = _ref4.css;
        (_this$$style7 = this.$style) === null || _this$$style7 === void 0 || _this$$style7.load(css3, _objectSpread$h({
          name: "".concat(this.$style.name, "-variables")
        }, this.$styleOptions));
        (_this$$style8 = this.$style) === null || _this$$style8 === void 0 || _this$$style8.loadTheme(_objectSpread$h({
          name: "".concat(this.$style.name, "-style")
        }, this.$styleOptions));
        config_default.setLoadedStyleName(this.$style.name);
      }
      if (!config_default.isStyleNameLoaded("layer-order")) {
        var _this$$style9, _this$$style9$getLaye;
        var layerOrder = (_this$$style9 = this.$style) === null || _this$$style9 === void 0 || (_this$$style9$getLaye = _this$$style9.getLayerOrderThemeCSS) === null || _this$$style9$getLaye === void 0 ? void 0 : _this$$style9$getLaye.call(_this$$style9);
        BaseStyle.load(layerOrder, _objectSpread$h({
          name: "layer-order",
          first: true
        }, this.$styleOptions));
        config_default.setLoadedStyleName("layer-order");
      }
    }, "_loadThemeStyles"),
    _loadScopedThemeStyles: /* @__PURE__ */ __name(function _loadScopedThemeStyles(preset) {
      var _this$$style10, _this$$style10$getPre, _this$$style11;
      var _ref5 = ((_this$$style10 = this.$style) === null || _this$$style10 === void 0 || (_this$$style10$getPre = _this$$style10.getPresetTheme) === null || _this$$style10$getPre === void 0 ? void 0 : _this$$style10$getPre.call(_this$$style10, preset, "[".concat(this.$attrSelector, "]"))) || {}, css3 = _ref5.css;
      var scopedStyle = (_this$$style11 = this.$style) === null || _this$$style11 === void 0 ? void 0 : _this$$style11.load(css3, _objectSpread$h({
        name: "".concat(this.$attrSelector, "-").concat(this.$style.name)
      }, this.$styleOptions));
      this.scopedStyleEl = scopedStyle.el;
    }, "_loadScopedThemeStyles"),
    _unloadScopedThemeStyles: /* @__PURE__ */ __name(function _unloadScopedThemeStyles() {
      var _this$scopedStyleEl;
      (_this$scopedStyleEl = this.scopedStyleEl) === null || _this$scopedStyleEl === void 0 || (_this$scopedStyleEl = _this$scopedStyleEl.value) === null || _this$scopedStyleEl === void 0 || _this$scopedStyleEl.remove();
    }, "_unloadScopedThemeStyles"),
    _themeChangeListener: /* @__PURE__ */ __name(function _themeChangeListener() {
      var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
      };
      Base.clearLoadedStyleNames();
      service_default.on("theme:change", callback);
    }, "_themeChangeListener"),
    _getHostInstance: /* @__PURE__ */ __name(function _getHostInstance(instance) {
      return instance ? this.$options.hostName ? instance.$.type.name === this.$options.hostName ? instance : this._getHostInstance(instance.$parentInstance) : instance.$parentInstance : void 0;
    }, "_getHostInstance"),
    _getPropValue: /* @__PURE__ */ __name(function _getPropValue(name) {
      var _this$_getHostInstanc;
      return this[name] || ((_this$_getHostInstanc = this._getHostInstance(this)) === null || _this$_getHostInstanc === void 0 ? void 0 : _this$_getHostInstanc[name]);
    }, "_getPropValue"),
    _getOptionValue: /* @__PURE__ */ __name(function _getOptionValue(options3) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return getKeyValue(options3, key, params);
    }, "_getOptionValue"),
    _getPTValue: /* @__PURE__ */ __name(function _getPTValue() {
      var _this$$primevueConfig2;
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var searchInDefaultPT = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var searchOut = /./g.test(key) && !!params[key.split(".")[0]];
      var _ref6 = this._getPropValue("ptOptions") || ((_this$$primevueConfig2 = this.$primevueConfig) === null || _this$$primevueConfig2 === void 0 ? void 0 : _this$$primevueConfig2.ptOptions) || {}, _ref6$mergeSections = _ref6.mergeSections, mergeSections = _ref6$mergeSections === void 0 ? true : _ref6$mergeSections, _ref6$mergeProps = _ref6.mergeProps, useMergeProps = _ref6$mergeProps === void 0 ? false : _ref6$mergeProps;
      var global2 = searchInDefaultPT ? searchOut ? this._useGlobalPT(this._getPTClassValue, key, params) : this._useDefaultPT(this._getPTClassValue, key, params) : void 0;
      var self2 = searchOut ? void 0 : this._getPTSelf(obj, this._getPTClassValue, key, _objectSpread$h(_objectSpread$h({}, params), {}, {
        global: global2 || {}
      }));
      var datasets = this._getPTDatasets(key);
      return mergeSections || !mergeSections && self2 ? useMergeProps ? this._mergeProps(useMergeProps, global2, self2, datasets) : _objectSpread$h(_objectSpread$h(_objectSpread$h({}, global2), self2), datasets) : _objectSpread$h(_objectSpread$h({}, self2), datasets);
    }, "_getPTValue"),
    _getPTSelf: /* @__PURE__ */ __name(function _getPTSelf() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return mergeProps(
        this._usePT.apply(this, [this._getPT(obj, this.$name)].concat(args)),
        // Exp; <component :pt="{}"
        this._usePT.apply(this, [this.$_attrsPT].concat(args))
        // Exp; <component :pt:[passthrough_key]:[attribute]="{value}" or <component :pt:[passthrough_key]="() =>{value}"
      );
    }, "_getPTSelf"),
    _getPTDatasets: /* @__PURE__ */ __name(function _getPTDatasets() {
      var _this$pt4, _this$pt5;
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var datasetPrefix = "data-pc-";
      var isExtended = key === "root" && isNotEmpty((_this$pt4 = this.pt) === null || _this$pt4 === void 0 ? void 0 : _this$pt4["data-pc-section"]);
      return key !== "transition" && _objectSpread$h(_objectSpread$h({}, key === "root" && _objectSpread$h(_defineProperty$h({}, "".concat(datasetPrefix, "name"), toFlatCase(isExtended ? (_this$pt5 = this.pt) === null || _this$pt5 === void 0 ? void 0 : _this$pt5["data-pc-section"] : this.$.type.name)), isExtended && _defineProperty$h({}, "".concat(datasetPrefix, "extend"), toFlatCase(this.$.type.name)))), {}, _defineProperty$h({}, "".concat(datasetPrefix, "section"), toFlatCase(key)));
    }, "_getPTDatasets"),
    _getPTClassValue: /* @__PURE__ */ __name(function _getPTClassValue() {
      var value3 = this._getOptionValue.apply(this, arguments);
      return isString$3(value3) || isArray$3(value3) ? {
        "class": value3
      } : value3;
    }, "_getPTClassValue"),
    _getPT: /* @__PURE__ */ __name(function _getPT(pt) {
      var _this3 = this;
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var callback = arguments.length > 2 ? arguments[2] : void 0;
      var getValue2 = /* @__PURE__ */ __name(function getValue3(value3) {
        var _ref8;
        var checkSameKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var computedValue = callback ? callback(value3) : value3;
        var _key = toFlatCase(key);
        var _cKey = toFlatCase(_this3.$name);
        return (_ref8 = checkSameKey ? _key !== _cKey ? computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key] : void 0 : computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _ref8 !== void 0 ? _ref8 : computedValue;
      }, "getValue");
      return pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept") ? {
        _usept: pt["_usept"],
        originalValue: getValue2(pt.originalValue),
        value: getValue2(pt.value)
      } : getValue2(pt, true);
    }, "_getPT"),
    _usePT: /* @__PURE__ */ __name(function _usePT(pt, callback, key, params) {
      var fn = /* @__PURE__ */ __name(function fn2(value4) {
        return callback(value4, key, params);
      }, "fn");
      if (pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept")) {
        var _this$$primevueConfig3;
        var _ref9 = pt["_usept"] || ((_this$$primevueConfig3 = this.$primevueConfig) === null || _this$$primevueConfig3 === void 0 ? void 0 : _this$$primevueConfig3.ptOptions) || {}, _ref9$mergeSections = _ref9.mergeSections, mergeSections = _ref9$mergeSections === void 0 ? true : _ref9$mergeSections, _ref9$mergeProps = _ref9.mergeProps, useMergeProps = _ref9$mergeProps === void 0 ? false : _ref9$mergeProps;
        var originalValue = fn(pt.originalValue);
        var value3 = fn(pt.value);
        if (originalValue === void 0 && value3 === void 0) return void 0;
        else if (isString$3(value3)) return value3;
        else if (isString$3(originalValue)) return originalValue;
        return mergeSections || !mergeSections && value3 ? useMergeProps ? this._mergeProps(useMergeProps, originalValue, value3) : _objectSpread$h(_objectSpread$h({}, originalValue), value3) : value3;
      }
      return fn(pt);
    }, "_usePT"),
    _useGlobalPT: /* @__PURE__ */ __name(function _useGlobalPT(callback, key, params) {
      return this._usePT(this.globalPT, callback, key, params);
    }, "_useGlobalPT"),
    _useDefaultPT: /* @__PURE__ */ __name(function _useDefaultPT(callback, key, params) {
      return this._usePT(this.defaultPT, callback, key, params);
    }, "_useDefaultPT"),
    ptm: /* @__PURE__ */ __name(function ptm() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._getPTValue(this.pt, key, _objectSpread$h(_objectSpread$h({}, this.$params), params));
    }, "ptm"),
    ptmi: /* @__PURE__ */ __name(function ptmi() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return mergeProps(this.$_attrsWithoutPT, this.ptm(key, params));
    }, "ptmi"),
    ptmo: /* @__PURE__ */ __name(function ptmo() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this._getPTValue(obj, key, _objectSpread$h({
        instance: this
      }, params), false);
    }, "ptmo"),
    cx: /* @__PURE__ */ __name(function cx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return !this.isUnstyled ? this._getOptionValue(this.$style.classes, key, _objectSpread$h(_objectSpread$h({}, this.$params), params)) : void 0;
    }, "cx"),
    sx: /* @__PURE__ */ __name(function sx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (when) {
        var self2 = this._getOptionValue(this.$style.inlineStyles, key, _objectSpread$h(_objectSpread$h({}, this.$params), params));
        var base = this._getOptionValue(BaseComponentStyle.inlineStyles, key, _objectSpread$h(_objectSpread$h({}, this.$params), params));
        return [base, self2];
      }
      return void 0;
    }, "sx")
  },
  computed: {
    globalPT: /* @__PURE__ */ __name(function globalPT() {
      var _this$$primevueConfig4, _this4 = this;
      return this._getPT((_this$$primevueConfig4 = this.$primevueConfig) === null || _this$$primevueConfig4 === void 0 ? void 0 : _this$$primevueConfig4.pt, void 0, function(value3) {
        return resolve(value3, {
          instance: _this4
        });
      });
    }, "globalPT"),
    defaultPT: /* @__PURE__ */ __name(function defaultPT() {
      var _this$$primevueConfig5, _this5 = this;
      return this._getPT((_this$$primevueConfig5 = this.$primevueConfig) === null || _this$$primevueConfig5 === void 0 ? void 0 : _this$$primevueConfig5.pt, void 0, function(value3) {
        return _this5._getOptionValue(value3, _this5.$name, _objectSpread$h({}, _this5.$params)) || resolve(value3, _objectSpread$h({}, _this5.$params));
      });
    }, "defaultPT"),
    isUnstyled: /* @__PURE__ */ __name(function isUnstyled() {
      var _this$$primevueConfig6;
      return this.unstyled !== void 0 ? this.unstyled : (_this$$primevueConfig6 = this.$primevueConfig) === null || _this$$primevueConfig6 === void 0 ? void 0 : _this$$primevueConfig6.unstyled;
    }, "isUnstyled"),
    $theme: /* @__PURE__ */ __name(function $theme() {
      var _this$$primevueConfig7;
      return (_this$$primevueConfig7 = this.$primevueConfig) === null || _this$$primevueConfig7 === void 0 ? void 0 : _this$$primevueConfig7.theme;
    }, "$theme"),
    $style: /* @__PURE__ */ __name(function $style() {
      return _objectSpread$h(_objectSpread$h({
        classes: void 0,
        inlineStyles: void 0,
        load: /* @__PURE__ */ __name(function load2() {
        }, "load"),
        loadCSS: /* @__PURE__ */ __name(function loadCSS2() {
        }, "loadCSS"),
        loadTheme: /* @__PURE__ */ __name(function loadTheme2() {
        }, "loadTheme")
      }, (this._getHostInstance(this) || {}).$style), this.$options.style);
    }, "$style"),
    $styleOptions: /* @__PURE__ */ __name(function $styleOptions() {
      var _this$$primevueConfig8;
      return {
        nonce: (_this$$primevueConfig8 = this.$primevueConfig) === null || _this$$primevueConfig8 === void 0 || (_this$$primevueConfig8 = _this$$primevueConfig8.csp) === null || _this$$primevueConfig8 === void 0 ? void 0 : _this$$primevueConfig8.nonce
      };
    }, "$styleOptions"),
    $primevueConfig: /* @__PURE__ */ __name(function $primevueConfig() {
      var _this$$primevue4;
      return (_this$$primevue4 = this.$primevue) === null || _this$$primevue4 === void 0 ? void 0 : _this$$primevue4.config;
    }, "$primevueConfig"),
    $name: /* @__PURE__ */ __name(function $name() {
      return this.$options.hostName || this.$.type.name;
    }, "$name"),
    $params: /* @__PURE__ */ __name(function $params() {
      var parentInstance = this._getHostInstance(this) || this.$parent;
      return {
        instance: this,
        props: this.$props,
        state: this.$data,
        attrs: this.$attrs,
        parent: {
          instance: parentInstance,
          props: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$props,
          state: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$data,
          attrs: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$attrs
        }
      };
    }, "$params"),
    $_attrsPT: /* @__PURE__ */ __name(function $_attrsPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref10) {
        var _ref11 = _slicedToArray$3(_ref10, 1), key = _ref11[0];
        return key === null || key === void 0 ? void 0 : key.startsWith("pt:");
      }).reduce(function(result, _ref12) {
        var _ref13 = _slicedToArray$3(_ref12, 2), key = _ref13[0], value3 = _ref13[1];
        var _key$split = key.split(":"), _key$split2 = _toArray(_key$split), rest = _key$split2.slice(1);
        rest === null || rest === void 0 || rest.reduce(function(currentObj, nestedKey, index2, array) {
          !currentObj[nestedKey] && (currentObj[nestedKey] = index2 === array.length - 1 ? value3 : {});
          return currentObj[nestedKey];
        }, result);
        return result;
      }, {});
    }, "$_attrsPT"),
    $_attrsWithoutPT: /* @__PURE__ */ __name(function $_attrsWithoutPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref14) {
        var _ref15 = _slicedToArray$3(_ref14, 1), key = _ref15[0];
        return !(key !== null && key !== void 0 && key.startsWith("pt:"));
      }).reduce(function(acc, _ref16) {
        var _ref17 = _slicedToArray$3(_ref16, 2), key = _ref17[0], value3 = _ref17[1];
        acc[key] = value3;
        return acc;
      }, {});
    }, "$_attrsWithoutPT"),
    $attrSelector: /* @__PURE__ */ __name(function $attrSelector() {
      return UniqueComponentId("pc");
    }, "$attrSelector")
  }
};
var css = "\n.p-icon {\n    display: inline-block;\n    vertical-align: baseline;\n}\n\n.p-icon-spin {\n    -webkit-animation: p-icon-spin 2s infinite linear;\n    animation: p-icon-spin 2s infinite linear;\n}\n\n@-webkit-keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n\n@keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n";
var BaseIconStyle = BaseStyle.extend({
  name: "baseicon",
  css
});
function _typeof$g(o) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$g(o);
}
__name(_typeof$g, "_typeof$g");
function ownKeys$g(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$g, "ownKeys$g");
function _objectSpread$g(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$g(Object(t), true).forEach(function(r2) {
      _defineProperty$g(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$g, "_objectSpread$g");
function _defineProperty$g(e, r, t) {
  return (r = _toPropertyKey$f(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$g, "_defineProperty$g");
function _toPropertyKey$f(t) {
  var i2 = _toPrimitive$f(t, "string");
  return "symbol" == _typeof$g(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$f, "_toPropertyKey$f");
function _toPrimitive$f(t, r) {
  if ("object" != _typeof$g(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$g(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$f, "_toPrimitive$f");
var script$X = {
  name: "BaseIcon",
  "extends": script$Y,
  props: {
    label: {
      type: String,
      "default": void 0
    },
    spin: {
      type: Boolean,
      "default": false
    }
  },
  style: BaseIconStyle,
  provide: /* @__PURE__ */ __name(function provide2() {
    return {
      $pcIcon: this,
      $parentInstance: this
    };
  }, "provide"),
  methods: {
    pti: /* @__PURE__ */ __name(function pti() {
      var isLabelEmpty = isEmpty(this.label);
      return _objectSpread$g(_objectSpread$g({}, !this.isUnstyled && {
        "class": ["p-icon", {
          "p-icon-spin": this.spin
        }]
      }), {}, {
        role: !isLabelEmpty ? "img" : void 0,
        "aria-label": !isLabelEmpty ? this.label : void 0,
        "aria-hidden": isLabelEmpty
      });
    }, "pti")
  }
};
var script$W = {
  name: "BlankIcon",
  "extends": script$X
};
var _hoisted_1$1f = /* @__PURE__ */ createBaseVNode("rect", {
  width: "1",
  height: "1",
  fill: "currentColor",
  "fill-opacity": "0"
}, null, -1);
var _hoisted_2$X = [_hoisted_1$1f];
function render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$X, 16);
}
__name(render$V, "render$V");
script$W.render = render$V;
var script$V = {
  name: "CheckIcon",
  "extends": script$X
};
var _hoisted_1$1e = /* @__PURE__ */ createBaseVNode("path", {
  d: "M4.86199 11.5948C4.78717 11.5923 4.71366 11.5745 4.64596 11.5426C4.57826 11.5107 4.51779 11.4652 4.46827 11.4091L0.753985 7.69483C0.683167 7.64891 0.623706 7.58751 0.580092 7.51525C0.536478 7.44299 0.509851 7.36177 0.502221 7.27771C0.49459 7.19366 0.506156 7.10897 0.536046 7.03004C0.565935 6.95111 0.613367 6.88 0.674759 6.82208C0.736151 6.76416 0.8099 6.72095 0.890436 6.69571C0.970973 6.67046 1.05619 6.66385 1.13966 6.67635C1.22313 6.68886 1.30266 6.72017 1.37226 6.76792C1.44186 6.81567 1.4997 6.8786 1.54141 6.95197L4.86199 10.2503L12.6397 2.49483C12.7444 2.42694 12.8689 2.39617 12.9932 2.40745C13.1174 2.41873 13.2343 2.47141 13.3251 2.55705C13.4159 2.64268 13.4753 2.75632 13.4938 2.87973C13.5123 3.00315 13.4888 3.1292 13.4271 3.23768L5.2557 11.4091C5.20618 11.4652 5.14571 11.5107 5.07801 11.5426C5.01031 11.5745 4.9368 11.5923 4.86199 11.5948Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$W = [_hoisted_1$1e];
function render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$W, 16);
}
__name(render$U, "render$U");
script$V.render = render$U;
var script$U = {
  name: "SearchIcon",
  "extends": script$X
};
var _hoisted_1$1d = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M2.67602 11.0265C3.6661 11.688 4.83011 12.0411 6.02086 12.0411C6.81149 12.0411 7.59438 11.8854 8.32483 11.5828C8.87005 11.357 9.37808 11.0526 9.83317 10.6803L12.9769 13.8241C13.0323 13.8801 13.0983 13.9245 13.171 13.9548C13.2438 13.985 13.3219 14.0003 13.4007 14C13.4795 14.0003 13.5575 13.985 13.6303 13.9548C13.7031 13.9245 13.7691 13.8801 13.8244 13.8241C13.9367 13.7116 13.9998 13.5592 13.9998 13.4003C13.9998 13.2414 13.9367 13.089 13.8244 12.9765L10.6807 9.8328C11.053 9.37773 11.3573 8.86972 11.5831 8.32452C11.8857 7.59408 12.0414 6.81119 12.0414 6.02056C12.0414 4.8298 11.6883 3.66579 11.0268 2.67572C10.3652 1.68564 9.42494 0.913972 8.32483 0.45829C7.22472 0.00260857 6.01418 -0.116618 4.84631 0.115686C3.67844 0.34799 2.60568 0.921393 1.76369 1.76338C0.921698 2.60537 0.348296 3.67813 0.115991 4.84601C-0.116313 6.01388 0.00291375 7.22441 0.458595 8.32452C0.914277 9.42464 1.68595 10.3649 2.67602 11.0265ZM3.35565 2.0158C4.14456 1.48867 5.07206 1.20731 6.02086 1.20731C7.29317 1.20731 8.51338 1.71274 9.41304 2.6124C10.3127 3.51206 10.8181 4.73226 10.8181 6.00457C10.8181 6.95337 10.5368 7.88088 10.0096 8.66978C9.48251 9.45868 8.73328 10.0736 7.85669 10.4367C6.98011 10.7997 6.01554 10.8947 5.08496 10.7096C4.15439 10.5245 3.2996 10.0676 2.62869 9.39674C1.95778 8.72583 1.50089 7.87104 1.31579 6.94046C1.13068 6.00989 1.22568 5.04532 1.58878 4.16874C1.95187 3.29215 2.56675 2.54292 3.35565 2.0158Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$V = [_hoisted_1$1d];
function render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$V, 16);
}
__name(render$T, "render$T");
script$U.render = render$T;
var theme$y = /* @__PURE__ */ __name(function theme3(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-iconfield {\n    position: relative;\n}\n\n.p-inputicon {\n    position: absolute;\n    top: 50%;\n    margin-top: calc(-1 * (".concat(dt2("icon.size"), " / 2));\n    color: ").concat(dt2("iconfield.icon.color"), ";\n    line-height: 1;\n}\n\n.p-iconfield .p-inputicon:first-child {\n    left: ").concat(dt2("form.field.padding.x"), ";\n}\n\n.p-iconfield .p-inputicon:last-child {\n    right: ").concat(dt2("form.field.padding.x"), ";\n}\n\n.p-iconfield .p-inputtext:not(:first-child) {\n    padding-left: calc((").concat(dt2("form.field.padding.x"), " * 2) + ").concat(dt2("icon.size"), ");\n}\n\n.p-iconfield .p-inputtext:not(:last-child) {\n    padding-right: calc((").concat(dt2("form.field.padding.x"), " * 2) + ").concat(dt2("icon.size"), ");\n}\n");
}, "theme");
var classes$A = {
  root: "p-iconfield"
};
var IconFieldStyle = BaseStyle.extend({
  name: "iconfield",
  theme: theme$y,
  classes: classes$A
});
var script$1$z = {
  name: "BaseIconField",
  "extends": script$Y,
  style: IconFieldStyle,
  provide: /* @__PURE__ */ __name(function provide3() {
    return {
      $pcIconField: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$T = {
  name: "IconField",
  "extends": script$1$z,
  inheritAttrs: false
};
function render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$S, "render$S");
script$T.render = render$S;
var classes$z = {
  root: "p-inputicon"
};
var InputIconStyle = BaseStyle.extend({
  name: "inputicon",
  classes: classes$z
});
var script$1$y = {
  name: "BaseInputIcon",
  "extends": script$Y,
  style: InputIconStyle,
  props: {
    "class": null
  },
  provide: /* @__PURE__ */ __name(function provide4() {
    return {
      $pcInputIcon: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$S = {
  name: "InputIcon",
  "extends": script$1$y,
  inheritAttrs: false,
  computed: {
    containerClass: /* @__PURE__ */ __name(function containerClass() {
      return [this.cx("root"), this["class"]];
    }, "containerClass")
  }
};
function render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": $options.containerClass
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$R, "render$R");
script$S.render = render$R;
var theme$x = /* @__PURE__ */ __name(function theme4(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-inputtext {\n    font-family: inherit;\n    font-feature-settings: inherit;\n    font-size: 1rem;\n    color: ".concat(dt2("inputtext.color"), ";\n    background: ").concat(dt2("inputtext.background"), ";\n    padding: ").concat(dt2("inputtext.padding.y"), " ").concat(dt2("inputtext.padding.x"), ";\n    border: 1px solid ").concat(dt2("inputtext.border.color"), ";\n    transition: background ").concat(dt2("inputtext.transition.duration"), ", color ").concat(dt2("inputtext.transition.duration"), ", border-color ").concat(dt2("inputtext.transition.duration"), ", outline-color ").concat(dt2("inputtext.transition.duration"), ", box-shadow ").concat(dt2("inputtext.transition.duration"), ";\n    appearance: none;\n    border-radius: ").concat(dt2("inputtext.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt2("inputtext.shadow"), ";\n}\n\n.p-inputtext:enabled:hover {\n    border-color: ").concat(dt2("inputtext.hover.border.color"), ";\n}\n\n.p-inputtext:enabled:focus {\n    border-color: ").concat(dt2("inputtext.focus.border.color"), ";\n    box-shadow: ").concat(dt2("inputtext.focus.ring.shadow"), ";\n    outline: ").concat(dt2("inputtext.focus.ring.width"), " ").concat(dt2("inputtext.focus.ring.style"), " ").concat(dt2("inputtext.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("inputtext.focus.ring.offset"), ";\n}\n\n.p-inputtext.p-invalid {\n    border-color: ").concat(dt2("inputtext.invalid.border.color"), ";\n}\n\n.p-inputtext.p-variant-filled {\n    background: ").concat(dt2("inputtext.filled.background"), ";\n}\n\n.p-inputtext.p-variant-filled:enabled:focus {\n    background: ").concat(dt2("inputtext.filled.focus.background"), ";\n}\n\n.p-inputtext:disabled {\n    opacity: 1;\n    background: ").concat(dt2("inputtext.disabled.background"), ";\n    color: ").concat(dt2("inputtext.disabled.color"), ";\n}\n\n.p-inputtext::placeholder {\n    color: ").concat(dt2("inputtext.placeholder.color"), ";\n}\n\n.p-inputtext-sm {\n    font-size: ").concat(dt2("inputtext.sm.font.size"), ";\n    padding: ").concat(dt2("inputtext.sm.padding.y"), " ").concat(dt2("inputtext.sm.padding.x"), ";\n}\n\n.p-inputtext-lg {\n    font-size: ").concat(dt2("inputtext.lg.font.size"), ";\n    padding: ").concat(dt2("inputtext.lg.padding.y"), " ").concat(dt2("inputtext.lg.padding.x"), ";\n}\n\n.p-inputtext-fluid {\n    width: 100%;\n}\n");
}, "theme");
var classes$y = {
  root: /* @__PURE__ */ __name(function root(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-inputtext p-component", {
      "p-filled": instance.filled,
      "p-inputtext-sm": props.size === "small",
      "p-inputtext-lg": props.size === "large",
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled",
      "p-inputtext-fluid": instance.hasFluid
    }];
  }, "root")
};
var InputTextStyle = BaseStyle.extend({
  name: "inputtext",
  theme: theme$x,
  classes: classes$y
});
var script$1$x = {
  name: "BaseInputText",
  "extends": script$Y,
  props: {
    modelValue: null,
    size: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    fluid: {
      type: Boolean,
      "default": null
    }
  },
  style: InputTextStyle,
  provide: /* @__PURE__ */ __name(function provide5() {
    return {
      $pcInputText: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$R = {
  name: "InputText",
  "extends": script$1$x,
  inheritAttrs: false,
  emits: ["update:modelValue"],
  inject: {
    $pcFluid: {
      "default": null
    }
  },
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          filled: this.filled,
          disabled: this.$attrs.disabled || this.$attrs.disabled === ""
        }
      });
    }, "getPTOptions"),
    onInput: /* @__PURE__ */ __name(function onInput(event2) {
      this.$emit("update:modelValue", event2.target.value);
    }, "onInput")
  },
  computed: {
    filled: /* @__PURE__ */ __name(function filled() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    }, "filled"),
    hasFluid: /* @__PURE__ */ __name(function hasFluid() {
      return isEmpty(this.fluid) ? !!this.$pcFluid : this.fluid;
    }, "hasFluid")
  }
};
var _hoisted_1$1c = ["value", "aria-invalid"];
function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("input", mergeProps({
    type: "text",
    "class": _ctx.cx("root"),
    value: _ctx.modelValue,
    "aria-invalid": _ctx.invalid || void 0,
    onInput: _cache[0] || (_cache[0] = function() {
      return $options.onInput && $options.onInput.apply($options, arguments);
    })
  }, $options.getPTOptions("root")), null, 16, _hoisted_1$1c);
}
__name(render$Q, "render$Q");
script$R.render = render$Q;
var PrimeVueService = EventBus();
function _typeof$f(o) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$f(o);
}
__name(_typeof$f, "_typeof$f");
function _slicedToArray$2(r, e) {
  return _arrayWithHoles$2(r) || _iterableToArrayLimit$2(r, e) || _unsupportedIterableToArray$e(r, e) || _nonIterableRest$2();
}
__name(_slicedToArray$2, "_slicedToArray$2");
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$2, "_nonIterableRest$2");
function _unsupportedIterableToArray$e(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$e(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$e(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$e, "_unsupportedIterableToArray$e");
function _arrayLikeToArray$e(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$e, "_arrayLikeToArray$e");
function _iterableToArrayLimit$2(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$2, "_iterableToArrayLimit$2");
function _arrayWithHoles$2(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$2, "_arrayWithHoles$2");
function ownKeys$f(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$f, "ownKeys$f");
function _objectSpread$f(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$f(Object(t), true).forEach(function(r2) {
      _defineProperty$f(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$f, "_objectSpread$f");
function _defineProperty$f(e, r, t) {
  return (r = _toPropertyKey$e(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$f, "_defineProperty$f");
function _toPropertyKey$e(t) {
  var i2 = _toPrimitive$e(t, "string");
  return "symbol" == _typeof$f(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$e, "_toPropertyKey$e");
function _toPrimitive$e(t, r) {
  if ("object" != _typeof$f(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$f(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$e, "_toPrimitive$e");
var BaseDirective = {
  _getMeta: /* @__PURE__ */ __name(function _getMeta() {
    return [isObject$4(arguments.length <= 0 ? void 0 : arguments[0]) ? void 0 : arguments.length <= 0 ? void 0 : arguments[0], resolve(isObject$4(arguments.length <= 0 ? void 0 : arguments[0]) ? arguments.length <= 0 ? void 0 : arguments[0] : arguments.length <= 1 ? void 0 : arguments[1])];
  }, "_getMeta"),
  _getConfig: /* @__PURE__ */ __name(function _getConfig(binding, vnode) {
    var _ref, _binding$instance, _vnode$ctx;
    return (_ref = (binding === null || binding === void 0 || (_binding$instance = binding.instance) === null || _binding$instance === void 0 ? void 0 : _binding$instance.$primevue) || (vnode === null || vnode === void 0 || (_vnode$ctx = vnode.ctx) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.appContext) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.config) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.globalProperties) === null || _vnode$ctx === void 0 ? void 0 : _vnode$ctx.$primevue)) === null || _ref === void 0 ? void 0 : _ref.config;
  }, "_getConfig"),
  _getOptionValue: getKeyValue,
  _getPTValue: /* @__PURE__ */ __name(function _getPTValue2() {
    var _instance$binding, _instance$$primevueCo;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var obj = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    var params = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var searchInDefaultPT = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var getValue2 = /* @__PURE__ */ __name(function getValue3() {
      var value3 = BaseDirective._getOptionValue.apply(BaseDirective, arguments);
      return isString$3(value3) || isArray$3(value3) ? {
        "class": value3
      } : value3;
    }, "getValue");
    var _ref2 = ((_instance$binding = instance.binding) === null || _instance$binding === void 0 || (_instance$binding = _instance$binding.value) === null || _instance$binding === void 0 ? void 0 : _instance$binding.ptOptions) || ((_instance$$primevueCo = instance.$primevueConfig) === null || _instance$$primevueCo === void 0 ? void 0 : _instance$$primevueCo.ptOptions) || {}, _ref2$mergeSections = _ref2.mergeSections, mergeSections = _ref2$mergeSections === void 0 ? true : _ref2$mergeSections, _ref2$mergeProps = _ref2.mergeProps, useMergeProps = _ref2$mergeProps === void 0 ? false : _ref2$mergeProps;
    var global2 = searchInDefaultPT ? BaseDirective._useDefaultPT(instance, instance.defaultPT(), getValue2, key, params) : void 0;
    var self2 = BaseDirective._usePT(instance, BaseDirective._getPT(obj, instance.$name), getValue2, key, _objectSpread$f(_objectSpread$f({}, params), {}, {
      global: global2 || {}
    }));
    var datasets = BaseDirective._getPTDatasets(instance, key);
    return mergeSections || !mergeSections && self2 ? useMergeProps ? BaseDirective._mergeProps(instance, useMergeProps, global2, self2, datasets) : _objectSpread$f(_objectSpread$f(_objectSpread$f({}, global2), self2), datasets) : _objectSpread$f(_objectSpread$f({}, self2), datasets);
  }, "_getPTValue"),
  _getPTDatasets: /* @__PURE__ */ __name(function _getPTDatasets2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var datasetPrefix = "data-pc-";
    return _objectSpread$f(_objectSpread$f({}, key === "root" && _defineProperty$f({}, "".concat(datasetPrefix, "name"), toFlatCase(instance.$name))), {}, _defineProperty$f({}, "".concat(datasetPrefix, "section"), toFlatCase(key)));
  }, "_getPTDatasets"),
  _getPT: /* @__PURE__ */ __name(function _getPT2(pt) {
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var getValue2 = /* @__PURE__ */ __name(function getValue3(value3) {
      var _computedValue$_key;
      var computedValue = callback ? callback(value3) : value3;
      var _key = toFlatCase(key);
      return (_computedValue$_key = computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _computedValue$_key !== void 0 ? _computedValue$_key : computedValue;
    }, "getValue");
    return pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept") ? {
      _usept: pt["_usept"],
      originalValue: getValue2(pt.originalValue),
      value: getValue2(pt.value)
    } : getValue2(pt);
  }, "_getPT"),
  _usePT: /* @__PURE__ */ __name(function _usePT2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var pt = arguments.length > 1 ? arguments[1] : void 0;
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    var fn = /* @__PURE__ */ __name(function fn2(value4) {
      return callback(value4, key, params);
    }, "fn");
    if (pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept")) {
      var _instance$$primevueCo2;
      var _ref4 = pt["_usept"] || ((_instance$$primevueCo2 = instance.$primevueConfig) === null || _instance$$primevueCo2 === void 0 ? void 0 : _instance$$primevueCo2.ptOptions) || {}, _ref4$mergeSections = _ref4.mergeSections, mergeSections = _ref4$mergeSections === void 0 ? true : _ref4$mergeSections, _ref4$mergeProps = _ref4.mergeProps, useMergeProps = _ref4$mergeProps === void 0 ? false : _ref4$mergeProps;
      var originalValue = fn(pt.originalValue);
      var value3 = fn(pt.value);
      if (originalValue === void 0 && value3 === void 0) return void 0;
      else if (isString$3(value3)) return value3;
      else if (isString$3(originalValue)) return originalValue;
      return mergeSections || !mergeSections && value3 ? useMergeProps ? BaseDirective._mergeProps(instance, useMergeProps, originalValue, value3) : _objectSpread$f(_objectSpread$f({}, originalValue), value3) : value3;
    }
    return fn(pt);
  }, "_usePT"),
  _useDefaultPT: /* @__PURE__ */ __name(function _useDefaultPT2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaultPT2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    return BaseDirective._usePT(instance, defaultPT2, callback, key, params);
  }, "_useDefaultPT"),
  _loadStyles: /* @__PURE__ */ __name(function _loadStyles2(el, binding, vnode) {
    var _config$csp;
    var config2 = BaseDirective._getConfig(binding, vnode);
    var useStyleOptions = {
      nonce: config2 === null || config2 === void 0 || (_config$csp = config2.csp) === null || _config$csp === void 0 ? void 0 : _config$csp.nonce
    };
    BaseDirective._loadCoreStyles(el.$instance, useStyleOptions);
    BaseDirective._loadThemeStyles(el.$instance, useStyleOptions);
    BaseDirective._loadScopedThemeStyles(el.$instance, useStyleOptions);
    BaseDirective._themeChangeListener(function() {
      return BaseDirective._loadThemeStyles(el.$instance, useStyleOptions);
    });
  }, "_loadStyles"),
  _loadCoreStyles: /* @__PURE__ */ __name(function _loadCoreStyles2() {
    var _instance$$style, _instance$$style2;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (!Base.isStyleNameLoaded((_instance$$style = instance.$style) === null || _instance$$style === void 0 ? void 0 : _instance$$style.name) && (_instance$$style2 = instance.$style) !== null && _instance$$style2 !== void 0 && _instance$$style2.name) {
      var _instance$$style3;
      BaseStyle.loadCSS(useStyleOptions);
      instance.isUnstyled() && ((_instance$$style3 = instance.$style) === null || _instance$$style3 === void 0 ? void 0 : _instance$$style3.loadCSS(useStyleOptions));
      Base.setLoadedStyleName(instance.$style.name);
    }
  }, "_loadCoreStyles"),
  _loadThemeStyles: /* @__PURE__ */ __name(function _loadThemeStyles2() {
    var _instance$$style5, _instance$$style6;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (instance !== null && instance !== void 0 && instance.isUnstyled()) return;
    if (!config_default.isStyleNameLoaded("common")) {
      var _instance$$style4, _instance$$style4$get;
      var _ref5 = ((_instance$$style4 = instance.$style) === null || _instance$$style4 === void 0 || (_instance$$style4$get = _instance$$style4.getCommonTheme) === null || _instance$$style4$get === void 0 ? void 0 : _instance$$style4$get.call(_instance$$style4)) || {}, primitive = _ref5.primitive, semantic = _ref5.semantic;
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$f({
        name: "primitive-variables"
      }, useStyleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$f({
        name: "semantic-variables"
      }, useStyleOptions));
      BaseStyle.loadTheme(_objectSpread$f({
        name: "global-style"
      }, useStyleOptions));
      config_default.setLoadedStyleName("common");
    }
    if (!config_default.isStyleNameLoaded((_instance$$style5 = instance.$style) === null || _instance$$style5 === void 0 ? void 0 : _instance$$style5.name) && (_instance$$style6 = instance.$style) !== null && _instance$$style6 !== void 0 && _instance$$style6.name) {
      var _instance$$style7, _instance$$style7$get, _instance$$style8, _instance$$style9;
      var _ref6 = ((_instance$$style7 = instance.$style) === null || _instance$$style7 === void 0 || (_instance$$style7$get = _instance$$style7.getDirectiveTheme) === null || _instance$$style7$get === void 0 ? void 0 : _instance$$style7$get.call(_instance$$style7)) || {}, css3 = _ref6.css;
      (_instance$$style8 = instance.$style) === null || _instance$$style8 === void 0 || _instance$$style8.load(css3, _objectSpread$f({
        name: "".concat(instance.$style.name, "-variables")
      }, useStyleOptions));
      (_instance$$style9 = instance.$style) === null || _instance$$style9 === void 0 || _instance$$style9.loadTheme(_objectSpread$f({
        name: "".concat(instance.$style.name, "-style")
      }, useStyleOptions));
      config_default.setLoadedStyleName(instance.$style.name);
    }
    if (!config_default.isStyleNameLoaded("layer-order")) {
      var _instance$$style10, _instance$$style10$ge;
      var layerOrder = (_instance$$style10 = instance.$style) === null || _instance$$style10 === void 0 || (_instance$$style10$ge = _instance$$style10.getLayerOrderThemeCSS) === null || _instance$$style10$ge === void 0 ? void 0 : _instance$$style10$ge.call(_instance$$style10);
      BaseStyle.load(layerOrder, _objectSpread$f({
        name: "layer-order",
        first: true
      }, useStyleOptions));
      config_default.setLoadedStyleName("layer-order");
    }
  }, "_loadThemeStyles"),
  _loadScopedThemeStyles: /* @__PURE__ */ __name(function _loadScopedThemeStyles2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    var preset = instance.preset();
    if (preset && instance.$attrSelector) {
      var _instance$$style11, _instance$$style11$ge, _instance$$style12;
      var _ref7 = ((_instance$$style11 = instance.$style) === null || _instance$$style11 === void 0 || (_instance$$style11$ge = _instance$$style11.getPresetTheme) === null || _instance$$style11$ge === void 0 ? void 0 : _instance$$style11$ge.call(_instance$$style11, preset, "[".concat(instance.$attrSelector, "]"))) || {}, css3 = _ref7.css;
      var scopedStyle = (_instance$$style12 = instance.$style) === null || _instance$$style12 === void 0 ? void 0 : _instance$$style12.load(css3, _objectSpread$f({
        name: "".concat(instance.$attrSelector, "-").concat(instance.$style.name)
      }, useStyleOptions));
      instance.scopedStyleEl = scopedStyle.el;
    }
  }, "_loadScopedThemeStyles"),
  _themeChangeListener: /* @__PURE__ */ __name(function _themeChangeListener2() {
    var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    Base.clearLoadedStyleNames();
    service_default.on("theme:change", callback);
  }, "_themeChangeListener"),
  _hook: /* @__PURE__ */ __name(function _hook2(directiveName, hookName, el, binding, vnode, prevVnode) {
    var _binding$value, _config$pt;
    var name = "on".concat(toCapitalCase(hookName));
    var config2 = BaseDirective._getConfig(binding, vnode);
    var instance = el === null || el === void 0 ? void 0 : el.$instance;
    var selfHook = BaseDirective._usePT(instance, BaseDirective._getPT(binding === null || binding === void 0 || (_binding$value = binding.value) === null || _binding$value === void 0 ? void 0 : _binding$value.pt, directiveName), BaseDirective._getOptionValue, "hooks.".concat(name));
    var defaultHook = BaseDirective._useDefaultPT(instance, config2 === null || config2 === void 0 || (_config$pt = config2.pt) === null || _config$pt === void 0 || (_config$pt = _config$pt.directives) === null || _config$pt === void 0 ? void 0 : _config$pt[directiveName], BaseDirective._getOptionValue, "hooks.".concat(name));
    var options3 = {
      el,
      binding,
      vnode,
      prevVnode
    };
    selfHook === null || selfHook === void 0 || selfHook(instance, options3);
    defaultHook === null || defaultHook === void 0 || defaultHook(instance, options3);
  }, "_hook"),
  _mergeProps: /* @__PURE__ */ __name(function _mergeProps2() {
    var fn = arguments.length > 1 ? arguments[1] : void 0;
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }
    return isFunction$1(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
  }, "_mergeProps"),
  _extend: /* @__PURE__ */ __name(function _extend(name) {
    var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var handleHook = /* @__PURE__ */ __name(function handleHook2(hook, el, binding, vnode, prevVnode) {
      var _el$$instance$hook, _el$$instance9, _el$$pd;
      el._$instances = el._$instances || {};
      var config2 = BaseDirective._getConfig(binding, vnode);
      var $prevInstance = el._$instances[name] || {};
      var $options = isEmpty($prevInstance) ? _objectSpread$f(_objectSpread$f({}, options3), options3 === null || options3 === void 0 ? void 0 : options3.methods) : {};
      el._$instances[name] = _objectSpread$f(_objectSpread$f({}, $prevInstance), {}, {
        /* new instance variables to pass in directive methods */
        $name: name,
        $host: el,
        $binding: binding,
        $modifiers: binding === null || binding === void 0 ? void 0 : binding.modifiers,
        $value: binding === null || binding === void 0 ? void 0 : binding.value,
        $el: $prevInstance["$el"] || el || void 0,
        $style: _objectSpread$f({
          classes: void 0,
          inlineStyles: void 0,
          load: /* @__PURE__ */ __name(function load2() {
          }, "load"),
          loadCSS: /* @__PURE__ */ __name(function loadCSS2() {
          }, "loadCSS"),
          loadTheme: /* @__PURE__ */ __name(function loadTheme2() {
          }, "loadTheme")
        }, options3 === null || options3 === void 0 ? void 0 : options3.style),
        $primevueConfig: config2,
        $attrSelector: el.$attrSelector,
        /* computed instance variables */
        defaultPT: /* @__PURE__ */ __name(function defaultPT2() {
          return BaseDirective._getPT(config2 === null || config2 === void 0 ? void 0 : config2.pt, void 0, function(value3) {
            var _value$directives;
            return value3 === null || value3 === void 0 || (_value$directives = value3.directives) === null || _value$directives === void 0 ? void 0 : _value$directives[name];
          });
        }, "defaultPT"),
        isUnstyled: /* @__PURE__ */ __name(function isUnstyled2() {
          var _el$$instance, _el$$instance2;
          return ((_el$$instance = el.$instance) === null || _el$$instance === void 0 || (_el$$instance = _el$$instance.$binding) === null || _el$$instance === void 0 || (_el$$instance = _el$$instance.value) === null || _el$$instance === void 0 ? void 0 : _el$$instance.unstyled) !== void 0 ? (_el$$instance2 = el.$instance) === null || _el$$instance2 === void 0 || (_el$$instance2 = _el$$instance2.$binding) === null || _el$$instance2 === void 0 || (_el$$instance2 = _el$$instance2.value) === null || _el$$instance2 === void 0 ? void 0 : _el$$instance2.unstyled : config2 === null || config2 === void 0 ? void 0 : config2.unstyled;
        }, "isUnstyled"),
        theme: /* @__PURE__ */ __name(function theme38() {
          var _el$$instance3;
          return (_el$$instance3 = el.$instance) === null || _el$$instance3 === void 0 || (_el$$instance3 = _el$$instance3.$primevueConfig) === null || _el$$instance3 === void 0 ? void 0 : _el$$instance3.theme;
        }, "theme"),
        preset: /* @__PURE__ */ __name(function preset() {
          var _el$$instance4;
          return (_el$$instance4 = el.$instance) === null || _el$$instance4 === void 0 || (_el$$instance4 = _el$$instance4.$binding) === null || _el$$instance4 === void 0 || (_el$$instance4 = _el$$instance4.value) === null || _el$$instance4 === void 0 ? void 0 : _el$$instance4.dt;
        }, "preset"),
        /* instance's methods */
        ptm: /* @__PURE__ */ __name(function ptm2() {
          var _el$$instance5;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return BaseDirective._getPTValue(el.$instance, (_el$$instance5 = el.$instance) === null || _el$$instance5 === void 0 || (_el$$instance5 = _el$$instance5.$binding) === null || _el$$instance5 === void 0 || (_el$$instance5 = _el$$instance5.value) === null || _el$$instance5 === void 0 ? void 0 : _el$$instance5.pt, key, _objectSpread$f({}, params));
        }, "ptm"),
        ptmo: /* @__PURE__ */ __name(function ptmo2() {
          var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return BaseDirective._getPTValue(el.$instance, obj, key, params, false);
        }, "ptmo"),
        cx: /* @__PURE__ */ __name(function cx2() {
          var _el$$instance6, _el$$instance7;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return !((_el$$instance6 = el.$instance) !== null && _el$$instance6 !== void 0 && _el$$instance6.isUnstyled()) ? BaseDirective._getOptionValue((_el$$instance7 = el.$instance) === null || _el$$instance7 === void 0 || (_el$$instance7 = _el$$instance7.$style) === null || _el$$instance7 === void 0 ? void 0 : _el$$instance7.classes, key, _objectSpread$f({}, params)) : void 0;
        }, "cx"),
        sx: /* @__PURE__ */ __name(function sx2() {
          var _el$$instance8;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return when ? BaseDirective._getOptionValue((_el$$instance8 = el.$instance) === null || _el$$instance8 === void 0 || (_el$$instance8 = _el$$instance8.$style) === null || _el$$instance8 === void 0 ? void 0 : _el$$instance8.inlineStyles, key, _objectSpread$f({}, params)) : void 0;
        }, "sx")
      }, $options);
      el.$instance = el._$instances[name];
      (_el$$instance$hook = (_el$$instance9 = el.$instance)[hook]) === null || _el$$instance$hook === void 0 || _el$$instance$hook.call(_el$$instance9, el, binding, vnode, prevVnode);
      el["$".concat(name)] = el.$instance;
      BaseDirective._hook(name, hook, el, binding, vnode, prevVnode);
      el.$pd || (el.$pd = {});
      el.$pd[name] = _objectSpread$f(_objectSpread$f({}, (_el$$pd = el.$pd) === null || _el$$pd === void 0 ? void 0 : _el$$pd[name]), {}, {
        name,
        instance: el.$instance
      });
    }, "handleHook");
    var handleWatch = /* @__PURE__ */ __name(function handleWatch2(el) {
      var _el$$instance10, _watchers$config, _el$$instance11, _watchers$configRipp, _el$$instance12;
      var watchers = (_el$$instance10 = el.$instance) === null || _el$$instance10 === void 0 ? void 0 : _el$$instance10.watch;
      watchers === null || watchers === void 0 || (_watchers$config = watchers["config"]) === null || _watchers$config === void 0 || _watchers$config.call(el.$instance, (_el$$instance11 = el.$instance) === null || _el$$instance11 === void 0 ? void 0 : _el$$instance11.$primevueConfig);
      PrimeVueService.on("config:change", function(_ref8) {
        var _watchers$config2;
        var newValue = _ref8.newValue, oldValue = _ref8.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$config2 = watchers["config"]) === null || _watchers$config2 === void 0 ? void 0 : _watchers$config2.call(el.$instance, newValue, oldValue);
      });
      watchers === null || watchers === void 0 || (_watchers$configRipp = watchers["config.ripple"]) === null || _watchers$configRipp === void 0 || _watchers$configRipp.call(el.$instance, (_el$$instance12 = el.$instance) === null || _el$$instance12 === void 0 || (_el$$instance12 = _el$$instance12.$primevueConfig) === null || _el$$instance12 === void 0 ? void 0 : _el$$instance12.ripple);
      PrimeVueService.on("config:ripple:change", function(_ref9) {
        var _watchers$configRipp2;
        var newValue = _ref9.newValue, oldValue = _ref9.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$configRipp2 = watchers["config.ripple"]) === null || _watchers$configRipp2 === void 0 ? void 0 : _watchers$configRipp2.call(el.$instance, newValue, oldValue);
      });
    }, "handleWatch");
    return {
      created: /* @__PURE__ */ __name(function created3(el, binding, vnode, prevVnode) {
        handleHook("created", el, binding, vnode, prevVnode);
      }, "created"),
      beforeMount: /* @__PURE__ */ __name(function beforeMount4(el, binding, vnode, prevVnode) {
        el.$attrSelector = UniqueComponentId("pd");
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("beforeMount", el, binding, vnode, prevVnode);
        handleWatch(el);
      }, "beforeMount"),
      mounted: /* @__PURE__ */ __name(function mounted21(el, binding, vnode, prevVnode) {
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("mounted", el, binding, vnode, prevVnode);
      }, "mounted"),
      beforeUpdate: /* @__PURE__ */ __name(function beforeUpdate2(el, binding, vnode, prevVnode) {
        handleHook("beforeUpdate", el, binding, vnode, prevVnode);
      }, "beforeUpdate"),
      updated: /* @__PURE__ */ __name(function updated12(el, binding, vnode, prevVnode) {
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("updated", el, binding, vnode, prevVnode);
      }, "updated"),
      beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount13(el, binding, vnode, prevVnode) {
        handleHook("beforeUnmount", el, binding, vnode, prevVnode);
      }, "beforeUnmount"),
      unmounted: /* @__PURE__ */ __name(function unmounted6(el, binding, vnode, prevVnode) {
        var _el$$instance13;
        (_el$$instance13 = el.$instance) === null || _el$$instance13 === void 0 || (_el$$instance13 = _el$$instance13.scopedStyleEl) === null || _el$$instance13 === void 0 || (_el$$instance13 = _el$$instance13.value) === null || _el$$instance13 === void 0 || _el$$instance13.remove();
        handleHook("unmounted", el, binding, vnode, prevVnode);
      }, "unmounted")
    };
  }, "_extend"),
  extend: /* @__PURE__ */ __name(function extend3() {
    var _BaseDirective$_getMe = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe2 = _slicedToArray$2(_BaseDirective$_getMe, 2), name = _BaseDirective$_getMe2[0], options3 = _BaseDirective$_getMe2[1];
    return _objectSpread$f({
      extend: /* @__PURE__ */ __name(function extend4() {
        var _BaseDirective$_getMe3 = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe4 = _slicedToArray$2(_BaseDirective$_getMe3, 2), _name = _BaseDirective$_getMe4[0], _options = _BaseDirective$_getMe4[1];
        return BaseDirective.extend(_name, _objectSpread$f(_objectSpread$f(_objectSpread$f({}, options3), options3 === null || options3 === void 0 ? void 0 : options3.methods), _options));
      }, "extend")
    }, BaseDirective._extend(name, options3));
  }, "extend")
};
var theme$w = /* @__PURE__ */ __name(function theme5(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-ink {\n    display: block;\n    position: absolute;\n    background: ".concat(dt2("ripple.background"), ";\n    border-radius: 100%;\n    transform: scale(0);\n    pointer-events: none;\n}\n\n.p-ink-active {\n    animation: ripple 0.4s linear;\n}\n\n@keyframes ripple {\n    100% {\n        opacity: 0;\n        transform: scale(2.5);\n    }\n}\n");
}, "theme");
var classes$x = {
  root: "p-ink"
};
var RippleStyle = BaseStyle.extend({
  name: "ripple-directive",
  theme: theme$w,
  classes: classes$x
});
var BaseRipple = BaseDirective.extend({
  style: RippleStyle
});
function _typeof$e(o) {
  "@babel/helpers - typeof";
  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$e(o);
}
__name(_typeof$e, "_typeof$e");
function _toConsumableArray$a(r) {
  return _arrayWithoutHoles$a(r) || _iterableToArray$a(r) || _unsupportedIterableToArray$d(r) || _nonIterableSpread$a();
}
__name(_toConsumableArray$a, "_toConsumableArray$a");
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$a, "_nonIterableSpread$a");
function _unsupportedIterableToArray$d(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$d(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$d(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$d, "_unsupportedIterableToArray$d");
function _iterableToArray$a(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$a, "_iterableToArray$a");
function _arrayWithoutHoles$a(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$d(r);
}
__name(_arrayWithoutHoles$a, "_arrayWithoutHoles$a");
function _arrayLikeToArray$d(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$d, "_arrayLikeToArray$d");
function _defineProperty$e(e, r, t) {
  return (r = _toPropertyKey$d(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$e, "_defineProperty$e");
function _toPropertyKey$d(t) {
  var i2 = _toPrimitive$d(t, "string");
  return "symbol" == _typeof$e(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$d, "_toPropertyKey$d");
function _toPrimitive$d(t, r) {
  if ("object" != _typeof$e(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$e(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$d, "_toPrimitive$d");
var Ripple = BaseRipple.extend("ripple", {
  watch: {
    "config.ripple": /* @__PURE__ */ __name(function configRipple(newValue) {
      if (newValue) {
        this.createRipple(this.$host);
        this.bindEvents(this.$host);
        this.$host.setAttribute("data-pd-ripple", true);
        this.$host.style["overflow"] = "hidden";
        this.$host.style["position"] = "relative";
      } else {
        this.remove(this.$host);
        this.$host.removeAttribute("data-pd-ripple");
      }
    }, "configRipple")
  },
  unmounted: /* @__PURE__ */ __name(function unmounted2(el) {
    this.remove(el);
  }, "unmounted"),
  timeout: void 0,
  methods: {
    bindEvents: /* @__PURE__ */ __name(function bindEvents(el) {
      el.addEventListener("mousedown", this.onMouseDown.bind(this));
    }, "bindEvents"),
    unbindEvents: /* @__PURE__ */ __name(function unbindEvents(el) {
      el.removeEventListener("mousedown", this.onMouseDown.bind(this));
    }, "unbindEvents"),
    createRipple: /* @__PURE__ */ __name(function createRipple(el) {
      var ink = createElement("span", _defineProperty$e(_defineProperty$e({
        role: "presentation",
        "aria-hidden": true,
        "data-p-ink": true,
        "data-p-ink-active": false,
        "class": !this.isUnstyled() && this.cx("root"),
        onAnimationEnd: this.onAnimationEnd.bind(this)
      }, this.$attrSelector, ""), "p-bind", this.ptm("root")));
      el.appendChild(ink);
      this.$el = ink;
    }, "createRipple"),
    remove: /* @__PURE__ */ __name(function remove2(el) {
      var ink = this.getInk(el);
      if (ink) {
        this.$host.style["overflow"] = "";
        this.$host.style["position"] = "";
        this.unbindEvents(el);
        ink.removeEventListener("animationend", this.onAnimationEnd);
        ink.remove();
      }
    }, "remove"),
    onMouseDown: /* @__PURE__ */ __name(function onMouseDown(event2) {
      var _this = this;
      var target = event2.currentTarget;
      var ink = this.getInk(target);
      if (!ink || getComputedStyle(ink, null).display === "none") {
        return;
      }
      !this.isUnstyled() && removeClass(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "false");
      if (!getHeight(ink) && !getWidth(ink)) {
        var d = Math.max(getOuterWidth(target), getOuterHeight(target));
        ink.style.height = d + "px";
        ink.style.width = d + "px";
      }
      var offset = getOffset(target);
      var x2 = event2.pageX - offset.left + document.body.scrollTop - getWidth(ink) / 2;
      var y2 = event2.pageY - offset.top + document.body.scrollLeft - getHeight(ink) / 2;
      ink.style.top = y2 + "px";
      ink.style.left = x2 + "px";
      !this.isUnstyled() && addClass(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "true");
      this.timeout = setTimeout(function() {
        if (ink) {
          !_this.isUnstyled() && removeClass(ink, "p-ink-active");
          ink.setAttribute("data-p-ink-active", "false");
        }
      }, 401);
    }, "onMouseDown"),
    onAnimationEnd: /* @__PURE__ */ __name(function onAnimationEnd(event2) {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      !this.isUnstyled() && removeClass(event2.currentTarget, "p-ink-active");
      event2.currentTarget.setAttribute("data-p-ink-active", "false");
    }, "onAnimationEnd"),
    getInk: /* @__PURE__ */ __name(function getInk(el) {
      return el && el.children ? _toConsumableArray$a(el.children).find(function(child) {
        return getAttribute(child, "data-pc-name") === "ripple";
      }) : void 0;
    }, "getInk")
  }
});
var script$Q = {
  name: "SpinnerIcon",
  "extends": script$X
};
var _hoisted_1$1b = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$U = [_hoisted_1$1b];
function render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$U, 16);
}
__name(render$P, "render$P");
script$Q.render = render$P;
var theme$v = /* @__PURE__ */ __name(function theme6(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-virtualscroller {\n    position: relative;\n    overflow: auto;\n    contain: strict;\n    transform: translateZ(0);\n    will-change: scroll-position;\n    outline: 0 none;\n}\n\n.p-virtualscroller-content {\n    position: absolute;\n    top: 0;\n    left: 0;\n    min-height: 100%;\n    min-width: 100%;\n    will-change: transform;\n}\n\n.p-virtualscroller-spacer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 1px;\n    width: 1px;\n    transform-origin: 0 0;\n    pointer-events: none;\n}\n\n.p-virtualscroller-loader {\n    position: sticky;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: ".concat(dt2("virtualscroller.loader.mask.background"), ";\n    color: ").concat(dt2("virtualscroller.loader.mask.color"), ";\n}\n\n.p-virtualscroller-loader-mask {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-virtualscroller-loading-icon {\n    font-size: ").concat(dt2("virtualscroller.loader.icon.size"), ";\n    width: ").concat(dt2("virtualscroller.loader.icon.size"), ";\n    height: ").concat(dt2("virtualscroller.loader.icon.size"), ";\n}\n\n.p-virtualscroller-horizontal > .p-virtualscroller-content {\n    display: flex;\n}\n\n.p-virtualscroller-inline .p-virtualscroller-content {\n    position: static;\n}\n");
}, "theme");
var VirtualScrollerStyle = BaseStyle.extend({
  name: "virtualscroller",
  theme: theme$v
});
var script$1$w = {
  name: "BaseVirtualScroller",
  "extends": script$Y,
  props: {
    id: {
      type: String,
      "default": null
    },
    style: null,
    "class": null,
    items: {
      type: Array,
      "default": null
    },
    itemSize: {
      type: [Number, Array],
      "default": 0
    },
    scrollHeight: null,
    scrollWidth: null,
    orientation: {
      type: String,
      "default": "vertical"
    },
    numToleratedItems: {
      type: Number,
      "default": null
    },
    delay: {
      type: Number,
      "default": 0
    },
    resizeDelay: {
      type: Number,
      "default": 10
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    loaderDisabled: {
      type: Boolean,
      "default": false
    },
    columns: {
      type: Array,
      "default": null
    },
    loading: {
      type: Boolean,
      "default": false
    },
    showSpacer: {
      type: Boolean,
      "default": true
    },
    showLoader: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    inline: {
      type: Boolean,
      "default": false
    },
    step: {
      type: Number,
      "default": 0
    },
    appendOnly: {
      type: Boolean,
      "default": false
    },
    autoSize: {
      type: Boolean,
      "default": false
    }
  },
  style: VirtualScrollerStyle,
  provide: /* @__PURE__ */ __name(function provide6() {
    return {
      $pcVirtualScroller: this,
      $parentInstance: this
    };
  }, "provide"),
  beforeMount: /* @__PURE__ */ __name(function beforeMount2() {
    var _this$$primevueConfig;
    VirtualScrollerStyle.loadCSS({
      nonce: (_this$$primevueConfig = this.$primevueConfig) === null || _this$$primevueConfig === void 0 || (_this$$primevueConfig = _this$$primevueConfig.csp) === null || _this$$primevueConfig === void 0 ? void 0 : _this$$primevueConfig.nonce
    });
  }, "beforeMount")
};
function _typeof$d(o) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$d(o);
}
__name(_typeof$d, "_typeof$d");
function ownKeys$e(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$e, "ownKeys$e");
function _objectSpread$e(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$e(Object(t), true).forEach(function(r2) {
      _defineProperty$d(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$e, "_objectSpread$e");
function _defineProperty$d(e, r, t) {
  return (r = _toPropertyKey$c(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$d, "_defineProperty$d");
function _toPropertyKey$c(t) {
  var i2 = _toPrimitive$c(t, "string");
  return "symbol" == _typeof$d(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$c, "_toPropertyKey$c");
function _toPrimitive$c(t, r) {
  if ("object" != _typeof$d(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$d(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$c, "_toPrimitive$c");
var script$P = {
  name: "VirtualScroller",
  "extends": script$1$w,
  inheritAttrs: false,
  emits: ["update:numToleratedItems", "scroll", "scroll-index-change", "lazy-load"],
  data: /* @__PURE__ */ __name(function data() {
    var both = this.isBoth();
    return {
      first: both ? {
        rows: 0,
        cols: 0
      } : 0,
      last: both ? {
        rows: 0,
        cols: 0
      } : 0,
      page: both ? {
        rows: 0,
        cols: 0
      } : 0,
      numItemsInViewport: both ? {
        rows: 0,
        cols: 0
      } : 0,
      lastScrollPos: both ? {
        top: 0,
        left: 0
      } : 0,
      d_numToleratedItems: this.numToleratedItems,
      d_loading: this.loading,
      loaderArr: [],
      spacerStyle: {},
      contentStyle: {}
    };
  }, "data"),
  element: null,
  content: null,
  lastScrollPos: null,
  scrollTimeout: null,
  resizeTimeout: null,
  defaultWidth: 0,
  defaultHeight: 0,
  defaultContentWidth: 0,
  defaultContentHeight: 0,
  isRangeChanged: false,
  lazyLoadState: {},
  resizeListener: null,
  initialized: false,
  watch: {
    numToleratedItems: /* @__PURE__ */ __name(function numToleratedItems(newValue) {
      this.d_numToleratedItems = newValue;
    }, "numToleratedItems"),
    loading: /* @__PURE__ */ __name(function loading(newValue, oldValue) {
      if (this.lazy && newValue !== oldValue && newValue !== this.d_loading) {
        this.d_loading = newValue;
      }
    }, "loading"),
    items: /* @__PURE__ */ __name(function items(newValue, oldValue) {
      if (!oldValue || oldValue.length !== (newValue || []).length) {
        this.init();
        this.calculateAutoSize();
      }
    }, "items"),
    itemSize: /* @__PURE__ */ __name(function itemSize() {
      this.init();
      this.calculateAutoSize();
    }, "itemSize"),
    orientation: /* @__PURE__ */ __name(function orientation() {
      this.lastScrollPos = this.isBoth() ? {
        top: 0,
        left: 0
      } : 0;
    }, "orientation"),
    scrollHeight: /* @__PURE__ */ __name(function scrollHeight() {
      this.init();
      this.calculateAutoSize();
    }, "scrollHeight"),
    scrollWidth: /* @__PURE__ */ __name(function scrollWidth() {
      this.init();
      this.calculateAutoSize();
    }, "scrollWidth")
  },
  mounted: /* @__PURE__ */ __name(function mounted2() {
    this.viewInit();
    this.lastScrollPos = this.isBoth() ? {
      top: 0,
      left: 0
    } : 0;
    this.lazyLoadState = this.lazyLoadState || {};
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated2() {
    !this.initialized && this.viewInit();
  }, "updated"),
  unmounted: /* @__PURE__ */ __name(function unmounted3() {
    this.unbindResizeListener();
    this.initialized = false;
  }, "unmounted"),
  methods: {
    viewInit: /* @__PURE__ */ __name(function viewInit() {
      if (isVisible(this.element)) {
        this.setContentEl(this.content);
        this.init();
        this.calculateAutoSize();
        this.bindResizeListener();
        this.defaultWidth = getWidth(this.element);
        this.defaultHeight = getHeight(this.element);
        this.defaultContentWidth = getWidth(this.content);
        this.defaultContentHeight = getHeight(this.content);
        this.initialized = true;
      }
    }, "viewInit"),
    init: /* @__PURE__ */ __name(function init() {
      if (!this.disabled) {
        this.setSize();
        this.calculateOptions();
        this.setSpacerSize();
      }
    }, "init"),
    isVertical: /* @__PURE__ */ __name(function isVertical() {
      return this.orientation === "vertical";
    }, "isVertical"),
    isHorizontal: /* @__PURE__ */ __name(function isHorizontal() {
      return this.orientation === "horizontal";
    }, "isHorizontal"),
    isBoth: /* @__PURE__ */ __name(function isBoth() {
      return this.orientation === "both";
    }, "isBoth"),
    scrollTo: /* @__PURE__ */ __name(function scrollTo2(options3) {
      this.element && this.element.scrollTo(options3);
    }, "scrollTo"),
    scrollToIndex: /* @__PURE__ */ __name(function scrollToIndex(index2) {
      var _this = this;
      var behavior = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "auto";
      var both = this.isBoth();
      var horizontal2 = this.isHorizontal();
      var valid = both ? index2.every(function(i2) {
        return i2 > -1;
      }) : index2 > -1;
      if (valid) {
        var first = this.first;
        var _this$element = this.element, _this$element$scrollT = _this$element.scrollTop, scrollTop2 = _this$element$scrollT === void 0 ? 0 : _this$element$scrollT, _this$element$scrollL = _this$element.scrollLeft, scrollLeft = _this$element$scrollL === void 0 ? 0 : _this$element$scrollL;
        var _this$calculateNumIte = this.calculateNumItems(), numToleratedItems2 = _this$calculateNumIte.numToleratedItems;
        var contentPos = this.getContentPosition();
        var itemSize2 = this.itemSize;
        var calculateFirst = /* @__PURE__ */ __name(function calculateFirst2() {
          var _index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var _numT = arguments.length > 1 ? arguments[1] : void 0;
          return _index <= _numT ? 0 : _index;
        }, "calculateFirst");
        var calculateCoord = /* @__PURE__ */ __name(function calculateCoord2(_first, _size, _cpos) {
          return _first * _size + _cpos;
        }, "calculateCoord");
        var scrollTo3 = /* @__PURE__ */ __name(function scrollTo4() {
          var left = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return _this.scrollTo({
            left,
            top,
            behavior
          });
        }, "scrollTo");
        var newFirst = both ? {
          rows: 0,
          cols: 0
        } : 0;
        var isRangeChanged = false, isScrollChanged = false;
        if (both) {
          newFirst = {
            rows: calculateFirst(index2[0], numToleratedItems2[0]),
            cols: calculateFirst(index2[1], numToleratedItems2[1])
          };
          scrollTo3(calculateCoord(newFirst.cols, itemSize2[1], contentPos.left), calculateCoord(newFirst.rows, itemSize2[0], contentPos.top));
          isScrollChanged = this.lastScrollPos.top !== scrollTop2 || this.lastScrollPos.left !== scrollLeft;
          isRangeChanged = newFirst.rows !== first.rows || newFirst.cols !== first.cols;
        } else {
          newFirst = calculateFirst(index2, numToleratedItems2);
          horizontal2 ? scrollTo3(calculateCoord(newFirst, itemSize2, contentPos.left), scrollTop2) : scrollTo3(scrollLeft, calculateCoord(newFirst, itemSize2, contentPos.top));
          isScrollChanged = this.lastScrollPos !== (horizontal2 ? scrollLeft : scrollTop2);
          isRangeChanged = newFirst !== first;
        }
        this.isRangeChanged = isRangeChanged;
        isScrollChanged && (this.first = newFirst);
      }
    }, "scrollToIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView2(index2, to) {
      var _this2 = this;
      var behavior = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "auto";
      if (to) {
        var both = this.isBoth();
        var horizontal2 = this.isHorizontal();
        var valid = both ? index2.every(function(i2) {
          return i2 > -1;
        }) : index2 > -1;
        if (valid) {
          var _this$getRenderedRang = this.getRenderedRange(), first = _this$getRenderedRang.first, viewport = _this$getRenderedRang.viewport;
          var scrollTo3 = /* @__PURE__ */ __name(function scrollTo4() {
            var left = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return _this2.scrollTo({
              left,
              top,
              behavior
            });
          }, "scrollTo");
          var isToStart = to === "to-start";
          var isToEnd = to === "to-end";
          if (isToStart) {
            if (both) {
              if (viewport.first.rows - first.rows > index2[0]) {
                scrollTo3(viewport.first.cols * this.itemSize[1], (viewport.first.rows - 1) * this.itemSize[0]);
              } else if (viewport.first.cols - first.cols > index2[1]) {
                scrollTo3((viewport.first.cols - 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);
              }
            } else {
              if (viewport.first - first > index2) {
                var pos2 = (viewport.first - 1) * this.itemSize;
                horizontal2 ? scrollTo3(pos2, 0) : scrollTo3(0, pos2);
              }
            }
          } else if (isToEnd) {
            if (both) {
              if (viewport.last.rows - first.rows <= index2[0] + 1) {
                scrollTo3(viewport.first.cols * this.itemSize[1], (viewport.first.rows + 1) * this.itemSize[0]);
              } else if (viewport.last.cols - first.cols <= index2[1] + 1) {
                scrollTo3((viewport.first.cols + 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);
              }
            } else {
              if (viewport.last - first <= index2 + 1) {
                var _pos2 = (viewport.first + 1) * this.itemSize;
                horizontal2 ? scrollTo3(_pos2, 0) : scrollTo3(0, _pos2);
              }
            }
          }
        }
      } else {
        this.scrollToIndex(index2, behavior);
      }
    }, "scrollInView"),
    getRenderedRange: /* @__PURE__ */ __name(function getRenderedRange() {
      var calculateFirstInViewport = /* @__PURE__ */ __name(function calculateFirstInViewport2(_pos, _size) {
        return Math.floor(_pos / (_size || _pos));
      }, "calculateFirstInViewport");
      var firstInViewport = this.first;
      var lastInViewport = 0;
      if (this.element) {
        var both = this.isBoth();
        var horizontal2 = this.isHorizontal();
        var _this$element2 = this.element, scrollTop2 = _this$element2.scrollTop, scrollLeft = _this$element2.scrollLeft;
        if (both) {
          firstInViewport = {
            rows: calculateFirstInViewport(scrollTop2, this.itemSize[0]),
            cols: calculateFirstInViewport(scrollLeft, this.itemSize[1])
          };
          lastInViewport = {
            rows: firstInViewport.rows + this.numItemsInViewport.rows,
            cols: firstInViewport.cols + this.numItemsInViewport.cols
          };
        } else {
          var scrollPos = horizontal2 ? scrollLeft : scrollTop2;
          firstInViewport = calculateFirstInViewport(scrollPos, this.itemSize);
          lastInViewport = firstInViewport + this.numItemsInViewport;
        }
      }
      return {
        first: this.first,
        last: this.last,
        viewport: {
          first: firstInViewport,
          last: lastInViewport
        }
      };
    }, "getRenderedRange"),
    calculateNumItems: /* @__PURE__ */ __name(function calculateNumItems() {
      var both = this.isBoth();
      var horizontal2 = this.isHorizontal();
      var itemSize2 = this.itemSize;
      var contentPos = this.getContentPosition();
      var contentWidth = this.element ? this.element.offsetWidth - contentPos.left : 0;
      var contentHeight = this.element ? this.element.offsetHeight - contentPos.top : 0;
      var calculateNumItemsInViewport = /* @__PURE__ */ __name(function calculateNumItemsInViewport2(_contentSize, _itemSize) {
        return Math.ceil(_contentSize / (_itemSize || _contentSize));
      }, "calculateNumItemsInViewport");
      var calculateNumToleratedItems = /* @__PURE__ */ __name(function calculateNumToleratedItems2(_numItems) {
        return Math.ceil(_numItems / 2);
      }, "calculateNumToleratedItems");
      var numItemsInViewport = both ? {
        rows: calculateNumItemsInViewport(contentHeight, itemSize2[0]),
        cols: calculateNumItemsInViewport(contentWidth, itemSize2[1])
      } : calculateNumItemsInViewport(horizontal2 ? contentWidth : contentHeight, itemSize2);
      var numToleratedItems2 = this.d_numToleratedItems || (both ? [calculateNumToleratedItems(numItemsInViewport.rows), calculateNumToleratedItems(numItemsInViewport.cols)] : calculateNumToleratedItems(numItemsInViewport));
      return {
        numItemsInViewport,
        numToleratedItems: numToleratedItems2
      };
    }, "calculateNumItems"),
    calculateOptions: /* @__PURE__ */ __name(function calculateOptions() {
      var _this3 = this;
      var both = this.isBoth();
      var first = this.first;
      var _this$calculateNumIte2 = this.calculateNumItems(), numItemsInViewport = _this$calculateNumIte2.numItemsInViewport, numToleratedItems2 = _this$calculateNumIte2.numToleratedItems;
      var calculateLast = /* @__PURE__ */ __name(function calculateLast2(_first, _num, _numT) {
        var _isCols = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        return _this3.getLast(_first + _num + (_first < _numT ? 2 : 3) * _numT, _isCols);
      }, "calculateLast");
      var last = both ? {
        rows: calculateLast(first.rows, numItemsInViewport.rows, numToleratedItems2[0]),
        cols: calculateLast(first.cols, numItemsInViewport.cols, numToleratedItems2[1], true)
      } : calculateLast(first, numItemsInViewport, numToleratedItems2);
      this.last = last;
      this.numItemsInViewport = numItemsInViewport;
      this.d_numToleratedItems = numToleratedItems2;
      this.$emit("update:numToleratedItems", this.d_numToleratedItems);
      if (this.showLoader) {
        this.loaderArr = both ? Array.from({
          length: numItemsInViewport.rows
        }).map(function() {
          return Array.from({
            length: numItemsInViewport.cols
          });
        }) : Array.from({
          length: numItemsInViewport
        });
      }
      if (this.lazy) {
        Promise.resolve().then(function() {
          var _this3$items;
          _this3.lazyLoadState = {
            first: _this3.step ? both ? {
              rows: 0,
              cols: first.cols
            } : 0 : first,
            last: Math.min(_this3.step ? _this3.step : last, ((_this3$items = _this3.items) === null || _this3$items === void 0 ? void 0 : _this3$items.length) || 0)
          };
          _this3.$emit("lazy-load", _this3.lazyLoadState);
        });
      }
    }, "calculateOptions"),
    calculateAutoSize: /* @__PURE__ */ __name(function calculateAutoSize() {
      var _this4 = this;
      if (this.autoSize && !this.d_loading) {
        Promise.resolve().then(function() {
          if (_this4.content) {
            var both = _this4.isBoth();
            var horizontal2 = _this4.isHorizontal();
            var vertical2 = _this4.isVertical();
            _this4.content.style.minHeight = _this4.content.style.minWidth = "auto";
            _this4.content.style.position = "relative";
            _this4.element.style.contain = "none";
            var _ref = [getWidth(_this4.element), getHeight(_this4.element)], width2 = _ref[0], height = _ref[1];
            (both || horizontal2) && (_this4.element.style.width = width2 < _this4.defaultWidth ? width2 + "px" : _this4.scrollWidth || _this4.defaultWidth + "px");
            (both || vertical2) && (_this4.element.style.height = height < _this4.defaultHeight ? height + "px" : _this4.scrollHeight || _this4.defaultHeight + "px");
            _this4.content.style.minHeight = _this4.content.style.minWidth = "";
            _this4.content.style.position = "";
            _this4.element.style.contain = "";
          }
        });
      }
    }, "calculateAutoSize"),
    getLast: /* @__PURE__ */ __name(function getLast() {
      var _ref2, _this$items;
      var last = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var isCols = arguments.length > 1 ? arguments[1] : void 0;
      return this.items ? Math.min(isCols ? ((_ref2 = this.columns || this.items[0]) === null || _ref2 === void 0 ? void 0 : _ref2.length) || 0 : ((_this$items = this.items) === null || _this$items === void 0 ? void 0 : _this$items.length) || 0, last) : 0;
    }, "getLast"),
    getContentPosition: /* @__PURE__ */ __name(function getContentPosition() {
      if (this.content) {
        var style = getComputedStyle(this.content);
        var left = parseFloat(style.paddingLeft) + Math.max(parseFloat(style.left) || 0, 0);
        var right = parseFloat(style.paddingRight) + Math.max(parseFloat(style.right) || 0, 0);
        var top = parseFloat(style.paddingTop) + Math.max(parseFloat(style.top) || 0, 0);
        var bottom = parseFloat(style.paddingBottom) + Math.max(parseFloat(style.bottom) || 0, 0);
        return {
          left,
          right,
          top,
          bottom,
          x: left + right,
          y: top + bottom
        };
      }
      return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        x: 0,
        y: 0
      };
    }, "getContentPosition"),
    setSize: /* @__PURE__ */ __name(function setSize() {
      var _this5 = this;
      if (this.element) {
        var both = this.isBoth();
        var horizontal2 = this.isHorizontal();
        var parentElement = this.element.parentElement;
        var width2 = this.scrollWidth || "".concat(this.element.offsetWidth || parentElement.offsetWidth, "px");
        var height = this.scrollHeight || "".concat(this.element.offsetHeight || parentElement.offsetHeight, "px");
        var setProp = /* @__PURE__ */ __name(function setProp2(_name, _value) {
          return _this5.element.style[_name] = _value;
        }, "setProp");
        if (both || horizontal2) {
          setProp("height", height);
          setProp("width", width2);
        } else {
          setProp("height", height);
        }
      }
    }, "setSize"),
    setSpacerSize: /* @__PURE__ */ __name(function setSpacerSize() {
      var _this6 = this;
      var items2 = this.items;
      if (items2) {
        var both = this.isBoth();
        var horizontal2 = this.isHorizontal();
        var contentPos = this.getContentPosition();
        var setProp = /* @__PURE__ */ __name(function setProp2(_name, _value, _size) {
          var _cpos = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          return _this6.spacerStyle = _objectSpread$e(_objectSpread$e({}, _this6.spacerStyle), _defineProperty$d({}, "".concat(_name), (_value || []).length * _size + _cpos + "px"));
        }, "setProp");
        if (both) {
          setProp("height", items2, this.itemSize[0], contentPos.y);
          setProp("width", this.columns || items2[1], this.itemSize[1], contentPos.x);
        } else {
          horizontal2 ? setProp("width", this.columns || items2, this.itemSize, contentPos.x) : setProp("height", items2, this.itemSize, contentPos.y);
        }
      }
    }, "setSpacerSize"),
    setContentPosition: /* @__PURE__ */ __name(function setContentPosition(pos2) {
      var _this7 = this;
      if (this.content && !this.appendOnly) {
        var both = this.isBoth();
        var horizontal2 = this.isHorizontal();
        var first = pos2 ? pos2.first : this.first;
        var calculateTranslateVal = /* @__PURE__ */ __name(function calculateTranslateVal2(_first, _size) {
          return _first * _size;
        }, "calculateTranslateVal");
        var setTransform = /* @__PURE__ */ __name(function setTransform2() {
          var _x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var _y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return _this7.contentStyle = _objectSpread$e(_objectSpread$e({}, _this7.contentStyle), {
            transform: "translate3d(".concat(_x, "px, ").concat(_y, "px, 0)")
          });
        }, "setTransform");
        if (both) {
          setTransform(calculateTranslateVal(first.cols, this.itemSize[1]), calculateTranslateVal(first.rows, this.itemSize[0]));
        } else {
          var translateVal = calculateTranslateVal(first, this.itemSize);
          horizontal2 ? setTransform(translateVal, 0) : setTransform(0, translateVal);
        }
      }
    }, "setContentPosition"),
    onScrollPositionChange: /* @__PURE__ */ __name(function onScrollPositionChange(event2) {
      var _this8 = this;
      var target = event2.target;
      var both = this.isBoth();
      var horizontal2 = this.isHorizontal();
      var contentPos = this.getContentPosition();
      var calculateScrollPos = /* @__PURE__ */ __name(function calculateScrollPos2(_pos, _cpos) {
        return _pos ? _pos > _cpos ? _pos - _cpos : _pos : 0;
      }, "calculateScrollPos");
      var calculateCurrentIndex = /* @__PURE__ */ __name(function calculateCurrentIndex2(_pos, _size) {
        return Math.floor(_pos / (_size || _pos));
      }, "calculateCurrentIndex");
      var calculateTriggerIndex = /* @__PURE__ */ __name(function calculateTriggerIndex2(_currentIndex, _first, _last, _num, _numT, _isScrollDownOrRight) {
        return _currentIndex <= _numT ? _numT : _isScrollDownOrRight ? _last - _num - _numT : _first + _numT - 1;
      }, "calculateTriggerIndex");
      var calculateFirst = /* @__PURE__ */ __name(function calculateFirst2(_currentIndex, _triggerIndex, _first, _last, _num, _numT, _isScrollDownOrRight) {
        if (_currentIndex <= _numT) return 0;
        else return Math.max(0, _isScrollDownOrRight ? _currentIndex < _triggerIndex ? _first : _currentIndex - _numT : _currentIndex > _triggerIndex ? _first : _currentIndex - 2 * _numT);
      }, "calculateFirst");
      var calculateLast = /* @__PURE__ */ __name(function calculateLast2(_currentIndex, _first, _last, _num, _numT, _isCols) {
        var lastValue = _first + _num + 2 * _numT;
        if (_currentIndex >= _numT) {
          lastValue += _numT + 1;
        }
        return _this8.getLast(lastValue, _isCols);
      }, "calculateLast");
      var scrollTop2 = calculateScrollPos(target.scrollTop, contentPos.top);
      var scrollLeft = calculateScrollPos(target.scrollLeft, contentPos.left);
      var newFirst = both ? {
        rows: 0,
        cols: 0
      } : 0;
      var newLast = this.last;
      var isRangeChanged = false;
      var newScrollPos = this.lastScrollPos;
      if (both) {
        var isScrollDown = this.lastScrollPos.top <= scrollTop2;
        var isScrollRight = this.lastScrollPos.left <= scrollLeft;
        if (!this.appendOnly || this.appendOnly && (isScrollDown || isScrollRight)) {
          var currentIndex = {
            rows: calculateCurrentIndex(scrollTop2, this.itemSize[0]),
            cols: calculateCurrentIndex(scrollLeft, this.itemSize[1])
          };
          var triggerIndex = {
            rows: calculateTriggerIndex(currentIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),
            cols: calculateTriggerIndex(currentIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)
          };
          newFirst = {
            rows: calculateFirst(currentIndex.rows, triggerIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),
            cols: calculateFirst(currentIndex.cols, triggerIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)
          };
          newLast = {
            rows: calculateLast(currentIndex.rows, newFirst.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0]),
            cols: calculateLast(currentIndex.cols, newFirst.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], true)
          };
          isRangeChanged = newFirst.rows !== this.first.rows || newLast.rows !== this.last.rows || newFirst.cols !== this.first.cols || newLast.cols !== this.last.cols || this.isRangeChanged;
          newScrollPos = {
            top: scrollTop2,
            left: scrollLeft
          };
        }
      } else {
        var scrollPos = horizontal2 ? scrollLeft : scrollTop2;
        var isScrollDownOrRight = this.lastScrollPos <= scrollPos;
        if (!this.appendOnly || this.appendOnly && isScrollDownOrRight) {
          var _currentIndex2 = calculateCurrentIndex(scrollPos, this.itemSize);
          var _triggerIndex2 = calculateTriggerIndex(_currentIndex2, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);
          newFirst = calculateFirst(_currentIndex2, _triggerIndex2, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);
          newLast = calculateLast(_currentIndex2, newFirst, this.last, this.numItemsInViewport, this.d_numToleratedItems);
          isRangeChanged = newFirst !== this.first || newLast !== this.last || this.isRangeChanged;
          newScrollPos = scrollPos;
        }
      }
      return {
        first: newFirst,
        last: newLast,
        isRangeChanged,
        scrollPos: newScrollPos
      };
    }, "onScrollPositionChange"),
    onScrollChange: /* @__PURE__ */ __name(function onScrollChange(event2) {
      var _this$onScrollPositio = this.onScrollPositionChange(event2), first = _this$onScrollPositio.first, last = _this$onScrollPositio.last, isRangeChanged = _this$onScrollPositio.isRangeChanged, scrollPos = _this$onScrollPositio.scrollPos;
      if (isRangeChanged) {
        var newState = {
          first,
          last
        };
        this.setContentPosition(newState);
        this.first = first;
        this.last = last;
        this.lastScrollPos = scrollPos;
        this.$emit("scroll-index-change", newState);
        if (this.lazy && this.isPageChanged(first)) {
          var _this$items2, _this$items3;
          var lazyLoadState = {
            first: this.step ? Math.min(this.getPageByFirst(first) * this.step, (((_this$items2 = this.items) === null || _this$items2 === void 0 ? void 0 : _this$items2.length) || 0) - this.step) : first,
            last: Math.min(this.step ? (this.getPageByFirst(first) + 1) * this.step : last, ((_this$items3 = this.items) === null || _this$items3 === void 0 ? void 0 : _this$items3.length) || 0)
          };
          var isLazyStateChanged = this.lazyLoadState.first !== lazyLoadState.first || this.lazyLoadState.last !== lazyLoadState.last;
          isLazyStateChanged && this.$emit("lazy-load", lazyLoadState);
          this.lazyLoadState = lazyLoadState;
        }
      }
    }, "onScrollChange"),
    onScroll: /* @__PURE__ */ __name(function onScroll(event2) {
      var _this9 = this;
      this.$emit("scroll", event2);
      if (this.delay) {
        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }
        if (this.isPageChanged()) {
          if (!this.d_loading && this.showLoader) {
            var _this$onScrollPositio2 = this.onScrollPositionChange(event2), isRangeChanged = _this$onScrollPositio2.isRangeChanged;
            var changed = isRangeChanged || (this.step ? this.isPageChanged() : false);
            changed && (this.d_loading = true);
          }
          this.scrollTimeout = setTimeout(function() {
            _this9.onScrollChange(event2);
            if (_this9.d_loading && _this9.showLoader && (!_this9.lazy || _this9.loading === void 0)) {
              _this9.d_loading = false;
              _this9.page = _this9.getPageByFirst();
            }
          }, this.delay);
        }
      } else {
        this.onScrollChange(event2);
      }
    }, "onScroll"),
    onResize: /* @__PURE__ */ __name(function onResize() {
      var _this10 = this;
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }
      this.resizeTimeout = setTimeout(function() {
        if (isVisible(_this10.element)) {
          var both = _this10.isBoth();
          var vertical2 = _this10.isVertical();
          var horizontal2 = _this10.isHorizontal();
          var _ref3 = [getWidth(_this10.element), getHeight(_this10.element)], width2 = _ref3[0], height = _ref3[1];
          var isDiffWidth = width2 !== _this10.defaultWidth, isDiffHeight = height !== _this10.defaultHeight;
          var reinit = both ? isDiffWidth || isDiffHeight : horizontal2 ? isDiffWidth : vertical2 ? isDiffHeight : false;
          if (reinit) {
            _this10.d_numToleratedItems = _this10.numToleratedItems;
            _this10.defaultWidth = width2;
            _this10.defaultHeight = height;
            _this10.defaultContentWidth = getWidth(_this10.content);
            _this10.defaultContentHeight = getHeight(_this10.content);
            _this10.init();
          }
        }
      }, this.resizeDelay);
    }, "onResize"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = this.onResize.bind(this);
        window.addEventListener("resize", this.resizeListener);
        window.addEventListener("orientationchange", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        window.removeEventListener("orientationchange", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    getOptions: /* @__PURE__ */ __name(function getOptions(renderedIndex) {
      var count = (this.items || []).length;
      var index2 = this.isBoth() ? this.first.rows + renderedIndex : this.first + renderedIndex;
      return {
        index: index2,
        count,
        first: index2 === 0,
        last: index2 === count - 1,
        even: index2 % 2 === 0,
        odd: index2 % 2 !== 0
      };
    }, "getOptions"),
    getLoaderOptions: /* @__PURE__ */ __name(function getLoaderOptions(index2, extOptions) {
      var count = this.loaderArr.length;
      return _objectSpread$e({
        index: index2,
        count,
        first: index2 === 0,
        last: index2 === count - 1,
        even: index2 % 2 === 0,
        odd: index2 % 2 !== 0
      }, extOptions);
    }, "getLoaderOptions"),
    getPageByFirst: /* @__PURE__ */ __name(function getPageByFirst(first) {
      return Math.floor(((first !== null && first !== void 0 ? first : this.first) + this.d_numToleratedItems * 4) / (this.step || 1));
    }, "getPageByFirst"),
    isPageChanged: /* @__PURE__ */ __name(function isPageChanged(first) {
      return this.step ? this.page !== this.getPageByFirst(first !== null && first !== void 0 ? first : this.first) : true;
    }, "isPageChanged"),
    setContentEl: /* @__PURE__ */ __name(function setContentEl(el) {
      this.content = el || this.content || findSingle(this.element, '[data-pc-section="content"]');
    }, "setContentEl"),
    elementRef: /* @__PURE__ */ __name(function elementRef(el) {
      this.element = el;
    }, "elementRef"),
    contentRef: /* @__PURE__ */ __name(function contentRef(el) {
      this.content = el;
    }, "contentRef")
  },
  computed: {
    containerClass: /* @__PURE__ */ __name(function containerClass2() {
      return ["p-virtualscroller", this["class"], {
        "p-virtualscroller-inline": this.inline,
        "p-virtualscroller-both p-both-scroll": this.isBoth(),
        "p-virtualscroller-horizontal p-horizontal-scroll": this.isHorizontal()
      }];
    }, "containerClass"),
    contentClass: /* @__PURE__ */ __name(function contentClass() {
      return ["p-virtualscroller-content", {
        "p-virtualscroller-loading": this.d_loading
      }];
    }, "contentClass"),
    loaderClass: /* @__PURE__ */ __name(function loaderClass() {
      return ["p-virtualscroller-loader", {
        "p-virtualscroller-loader-mask": !this.$slots.loader
      }];
    }, "loaderClass"),
    loadedItems: /* @__PURE__ */ __name(function loadedItems() {
      var _this11 = this;
      if (this.items && !this.d_loading) {
        if (this.isBoth()) return this.items.slice(this.appendOnly ? 0 : this.first.rows, this.last.rows).map(function(item2) {
          return _this11.columns ? item2 : item2.slice(_this11.appendOnly ? 0 : _this11.first.cols, _this11.last.cols);
        });
        else if (this.isHorizontal() && this.columns) return this.items;
        else return this.items.slice(this.appendOnly ? 0 : this.first, this.last);
      }
      return [];
    }, "loadedItems"),
    loadedRows: /* @__PURE__ */ __name(function loadedRows() {
      return this.d_loading ? this.loaderDisabled ? this.loaderArr : [] : this.loadedItems;
    }, "loadedRows"),
    loadedColumns: /* @__PURE__ */ __name(function loadedColumns() {
      if (this.columns) {
        var both = this.isBoth();
        var horizontal2 = this.isHorizontal();
        if (both || horizontal2) {
          return this.d_loading && this.loaderDisabled ? both ? this.loaderArr[0] : this.loaderArr : this.columns.slice(both ? this.first.cols : this.first, both ? this.last.cols : this.last);
        }
      }
      return this.columns;
    }, "loadedColumns")
  },
  components: {
    SpinnerIcon: script$Q
  }
};
var _hoisted_1$1a = ["tabindex"];
function render$O(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  return !_ctx.disabled ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    ref: $options.elementRef,
    "class": $options.containerClass,
    tabindex: _ctx.tabindex,
    style: _ctx.style,
    onScroll: _cache[0] || (_cache[0] = function() {
      return $options.onScroll && $options.onScroll.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "content", {
    styleClass: $options.contentClass,
    items: $options.loadedItems,
    getItemOptions: $options.getOptions,
    loading: $data.d_loading,
    getLoaderOptions: $options.getLoaderOptions,
    itemSize: _ctx.itemSize,
    rows: $options.loadedRows,
    columns: $options.loadedColumns,
    contentRef: $options.contentRef,
    spacerStyle: $data.spacerStyle,
    contentStyle: $data.contentStyle,
    vertical: $options.isVertical(),
    horizontal: $options.isHorizontal(),
    both: $options.isBoth()
  }, function() {
    return [createBaseVNode("div", mergeProps({
      ref: $options.contentRef,
      "class": $options.contentClass,
      style: $data.contentStyle
    }, _ctx.ptm("content")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.loadedItems, function(item2, index2) {
      return renderSlot(_ctx.$slots, "item", {
        key: index2,
        item: item2,
        options: $options.getOptions(index2)
      });
    }), 128))], 16)];
  }), _ctx.showSpacer ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": "p-virtualscroller-spacer",
    style: $data.spacerStyle
  }, _ctx.ptm("spacer")), null, 16)) : createCommentVNode("", true), !_ctx.loaderDisabled && _ctx.showLoader && $data.d_loading ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": $options.loaderClass
  }, _ctx.ptm("loader")), [_ctx.$slots && _ctx.$slots.loader ? (openBlock(true), createElementBlock(Fragment, {
    key: 0
  }, renderList($data.loaderArr, function(_2, index2) {
    return renderSlot(_ctx.$slots, "loader", {
      key: index2,
      options: $options.getLoaderOptions(index2, $options.isBoth() && {
        numCols: _ctx.d_numItemsInViewport.cols
      })
    });
  }), 128)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "loadingicon", {}, function() {
    return [createVNode(_component_SpinnerIcon, mergeProps({
      spin: "",
      "class": "p-virtualscroller-loading-icon"
    }, _ctx.ptm("loadingIcon")), null, 16)];
  })], 16)) : createCommentVNode("", true)], 16, _hoisted_1$1a)) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [renderSlot(_ctx.$slots, "default"), renderSlot(_ctx.$slots, "content", {
    items: _ctx.items,
    rows: _ctx.items,
    columns: $options.loadedColumns
  })], 64));
}
__name(render$O, "render$O");
script$P.render = render$O;
var theme$u = /* @__PURE__ */ __name(function theme7(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-listbox {\n    background: ".concat(dt2("listbox.background"), ";\n    color: ").concat(dt2("listbox.color"), ";\n    border: 1px solid ").concat(dt2("listbox.border.color"), ";\n    border-radius: ").concat(dt2("listbox.border.radius"), ";\n    transition: background ").concat(dt2("listbox.transition.duration"), ", color ").concat(dt2("listbox.transition.duration"), ", border-color ").concat(dt2("listbox.transition.duration"), ",\n            box-shadow ").concat(dt2("listbox.transition.duration"), ", outline-color ").concat(dt2("listbox.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt2("listbox.shadow"), ";\n}\n\n.p-listbox.p-focus {\n    border-color: ").concat(dt2("listbox.focus.border.color"), ";\n    box-shadow: ").concat(dt2("listbox.focus.ring.shadow"), ";\n    outline: ").concat(dt2("listbox.focus.ring.width"), " ").concat(dt2("listbox.focus.ring.style"), " ").concat(dt2("listbox.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("listbox.focus.ring.offset"), ";\n}\n\n.p-listbox.p-disabled {\n    opacity: 1;\n    background: ").concat(dt2("listbox.disabled.background"), ";\n    color: ").concat(dt2("listbox.disabled.color"), ";\n}\n\n.p-listbox.p-disabled .p-listbox-option {\n    color: ").concat(dt2("listbox.disabled.color"), ";\n}\n\n.p-listbox.p-invalid {\n    border-color: ").concat(dt2("listbox.invalid.border.color"), ";\n}\n\n.p-listbox-header {\n    padding: ").concat(dt2("listbox.list.header.padding"), ";\n}\n\n.p-listbox-filter {\n    width: 100%;\n}\n\n.p-listbox-list-container {\n    overflow: auto;\n}\n\n.p-listbox-list {\n    list-style-type: none;\n    margin: 0;\n    padding: ").concat(dt2("listbox.list.padding"), ";\n    outline: 0 none;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt2("listbox.list.gap"), ";\n}\n\n.p-listbox-option {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    position: relative;\n    overflow: hidden;\n    padding: ").concat(dt2("listbox.option.padding"), ";\n    border: 0 none;\n    border-radius: ").concat(dt2("listbox.option.border.radius"), ";\n    color: ").concat(dt2("listbox.option.color"), ";\n    transition: background ").concat(dt2("listbox.transition.duration"), ", color ").concat(dt2("listbox.transition.duration"), ", border-color ").concat(dt2("listbox.transition.duration"), ",\n            box-shadow ").concat(dt2("listbox.transition.duration"), ", outline-color ").concat(dt2("listbox.transition.duration"), ";\n}\n\n.p-listbox-striped li:nth-child(even of .p-listbox-option) {\n    background: ").concat(dt2("listbox.option.striped.background"), ";\n}\n\n.p-listbox .p-listbox-list .p-listbox-option.p-listbox-option-selected {\n    background: ").concat(dt2("listbox.option.selected.background"), ";\n    color: ").concat(dt2("listbox.option.selected.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option.p-listbox-option-selected.p-focus {\n    background: ").concat(dt2("listbox.option.selected.focus.background"), ";\n    color: ").concat(dt2("listbox.option.selected.focus.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled).p-focus {\n    background: ").concat(dt2("listbox.option.focus.background"), ";\n    color: ").concat(dt2("listbox.option.focus.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled):hover {\n    background: ").concat(dt2("listbox.option.focus.background"), ";\n    color: ").concat(dt2("listbox.option.focus.color"), ";\n}\n\n.p-listbox-option-check-icon {\n    position: relative;\n    margin-inline-start: ").concat(dt2("listbox.checkmark.gutter.start"), ";\n    margin-inline-end: ").concat(dt2("listbox.checkmark.gutter.end"), ";\n    color: ").concat(dt2("listbox.checkmark.color"), ";\n}\n\n.p-listbox-option-group {\n    margin: 0;\n    padding: ").concat(dt2("listbox.option.group.padding"), ";\n    color: ").concat(dt2("listbox.option.group.color"), ";\n    background: ").concat(dt2("listbox.option.group.background"), ";\n    font-weight: ").concat(dt2("listbox.option.group.font.weight"), ";\n}\n\n.p-listbox-empty-message {\n    padding: ").concat(dt2("listbox.empty.message.padding"), ";\n}\n");
}, "theme");
var classes$w = {
  root: /* @__PURE__ */ __name(function root2(_ref2) {
    var props = _ref2.props;
    return ["p-listbox p-component", {
      "p-listbox-striped": props.striped,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid
    }];
  }, "root"),
  header: "p-listbox-header",
  pcFilter: "p-listbox-filter",
  listContainer: "p-listbox-list-container",
  list: "p-listbox-list",
  optionGroup: "p-listbox-option-group",
  option: /* @__PURE__ */ __name(function option(_ref3) {
    var instance = _ref3.instance, props = _ref3.props, _option = _ref3.option, index2 = _ref3.index, getItemOptions = _ref3.getItemOptions;
    return ["p-listbox-option", {
      "p-listbox-option-selected": instance.isSelected(_option) && props.highlightOnSelect,
      "p-focus": instance.focusedOptionIndex === instance.getOptionIndex(index2, getItemOptions),
      "p-disabled": instance.isOptionDisabled(_option)
    }];
  }, "option"),
  optionCheckIcon: "p-listbox-option-check-icon",
  optionBlankIcon: "p-listbox-option-blank-icon",
  emptyMessage: "p-listbox-empty-message"
};
var ListboxStyle = BaseStyle.extend({
  name: "listbox",
  theme: theme$u,
  classes: classes$w
});
var script$1$v = {
  name: "BaseListbox",
  "extends": script$Y,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: null,
    optionValue: null,
    optionDisabled: null,
    optionGroupLabel: null,
    optionGroupChildren: null,
    listStyle: null,
    scrollHeight: {
      type: String,
      "default": "14rem"
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    dataKey: null,
    multiple: {
      type: Boolean,
      "default": false
    },
    metaKeySelection: {
      type: Boolean,
      "default": false
    },
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      "default": "contains"
    },
    filterFields: {
      type: Array,
      "default": null
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    autoOptionFocus: {
      type: Boolean,
      "default": true
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    focusOnHover: {
      type: Boolean,
      "default": true
    },
    highlightOnSelect: {
      type: Boolean,
      "default": true
    },
    checkmark: {
      type: Boolean,
      "default": false
    },
    filterMessage: {
      type: String,
      "default": null
    },
    selectionMessage: {
      type: String,
      "default": null
    },
    emptySelectionMessage: {
      type: String,
      "default": null
    },
    emptyFilterMessage: {
      type: String,
      "default": null
    },
    emptyMessage: {
      type: String,
      "default": null
    },
    filterIcon: {
      type: String,
      "default": void 0
    },
    striped: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: ListboxStyle,
  provide: /* @__PURE__ */ __name(function provide7() {
    return {
      $pcListbox: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$9(r) {
  return _arrayWithoutHoles$9(r) || _iterableToArray$9(r) || _unsupportedIterableToArray$c(r) || _nonIterableSpread$9();
}
__name(_toConsumableArray$9, "_toConsumableArray$9");
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$9, "_nonIterableSpread$9");
function _unsupportedIterableToArray$c(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$c(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$c(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$c, "_unsupportedIterableToArray$c");
function _iterableToArray$9(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$9, "_iterableToArray$9");
function _arrayWithoutHoles$9(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$c(r);
}
__name(_arrayWithoutHoles$9, "_arrayWithoutHoles$9");
function _arrayLikeToArray$c(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$c, "_arrayLikeToArray$c");
var script$O = {
  name: "Listbox",
  "extends": script$1$v,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "filter", "item-dblclick", "option-dblclick"],
  list: null,
  virtualScroller: null,
  optionTouched: false,
  startRangeIndex: -1,
  searchTimeout: null,
  searchValue: "",
  data: /* @__PURE__ */ __name(function data2() {
    return {
      id: this.$attrs.id,
      filterValue: null,
      focused: false,
      focusedOptionIndex: -1
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    options: /* @__PURE__ */ __name(function options() {
      this.autoUpdateModel();
    }, "options")
  },
  mounted: /* @__PURE__ */ __name(function mounted3() {
    this.id = this.id || UniqueComponentId();
    this.autoUpdateModel();
  }, "mounted"),
  methods: {
    getOptionIndex: /* @__PURE__ */ __name(function getOptionIndex(index2, fn) {
      return this.virtualScrollerDisabled ? index2 : fn && fn(index2)["index"];
    }, "getOptionIndex"),
    getOptionLabel: /* @__PURE__ */ __name(function getOptionLabel(option3) {
      return this.optionLabel ? resolveFieldData(option3, this.optionLabel) : typeof option3 === "string" ? option3 : null;
    }, "getOptionLabel"),
    getOptionValue: /* @__PURE__ */ __name(function getOptionValue(option3) {
      return this.optionValue ? resolveFieldData(option3, this.optionValue) : option3;
    }, "getOptionValue"),
    getOptionRenderKey: /* @__PURE__ */ __name(function getOptionRenderKey(option3, index2) {
      return (this.dataKey ? resolveFieldData(option3, this.dataKey) : this.getOptionLabel(option3)) + "_" + index2;
    }, "getOptionRenderKey"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions2(option3, itemOptions, index2, key) {
      return this.ptm(key, {
        context: {
          selected: this.isSelected(option3),
          focused: this.focusedOptionIndex === this.getOptionIndex(index2, itemOptions),
          disabled: this.isOptionDisabled(option3)
        }
      });
    }, "getPTOptions"),
    isOptionDisabled: /* @__PURE__ */ __name(function isOptionDisabled(option3) {
      return this.optionDisabled ? resolveFieldData(option3, this.optionDisabled) : false;
    }, "isOptionDisabled"),
    isOptionGroup: /* @__PURE__ */ __name(function isOptionGroup(option3) {
      return this.optionGroupLabel && option3.optionGroup && option3.group;
    }, "isOptionGroup"),
    getOptionGroupLabel: /* @__PURE__ */ __name(function getOptionGroupLabel(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupLabel);
    }, "getOptionGroupLabel"),
    getOptionGroupChildren: /* @__PURE__ */ __name(function getOptionGroupChildren(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupChildren);
    }, "getOptionGroupChildren"),
    getAriaPosInset: /* @__PURE__ */ __name(function getAriaPosInset(index2) {
      var _this = this;
      return (this.optionGroupLabel ? index2 - this.visibleOptions.slice(0, index2).filter(function(option3) {
        return _this.isOptionGroup(option3);
      }).length : index2) + 1;
    }, "getAriaPosInset"),
    onFirstHiddenFocus: /* @__PURE__ */ __name(function onFirstHiddenFocus() {
      focus(this.list);
      var firstFocusableEl = getFirstFocusableElement(this.$el, ':not([data-p-hidden-focusable="true"])');
      this.$refs.lastHiddenFocusableElement.tabIndex = isElement(firstFocusableEl) ? void 0 : -1;
      this.$refs.firstHiddenFocusableElement.tabIndex = -1;
    }, "onFirstHiddenFocus"),
    onLastHiddenFocus: /* @__PURE__ */ __name(function onLastHiddenFocus(event2) {
      var relatedTarget = event2.relatedTarget;
      if (relatedTarget === this.list) {
        var firstFocusableEl = getFirstFocusableElement(this.$el, ':not([data-p-hidden-focusable="true"])');
        focus(firstFocusableEl);
        this.$refs.firstHiddenFocusableElement.tabIndex = void 0;
      } else {
        focus(this.$refs.firstHiddenFocusableElement);
      }
      this.$refs.lastHiddenFocusableElement.tabIndex = -1;
    }, "onLastHiddenFocus"),
    onFocusout: /* @__PURE__ */ __name(function onFocusout(event2) {
      if (!this.$el.contains(event2.relatedTarget) && this.$refs.lastHiddenFocusableElement && this.$refs.firstHiddenFocusableElement) {
        this.$refs.lastHiddenFocusableElement.tabIndex = this.$refs.firstHiddenFocusableElement.tabIndex = void 0;
      }
    }, "onFocusout"),
    onListFocus: /* @__PURE__ */ __name(function onListFocus(event2) {
      this.focused = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.findSelectedOptionIndex();
      this.autoUpdateModel();
      this.$emit("focus", event2);
    }, "onListFocus"),
    onListBlur: /* @__PURE__ */ __name(function onListBlur(event2) {
      this.focused = false;
      this.focusedOptionIndex = this.startRangeIndex = -1;
      this.searchValue = "";
      this.$emit("blur", event2);
    }, "onListBlur"),
    onListKeyDown: /* @__PURE__ */ __name(function onListKeyDown(event2) {
      var _this2 = this;
      var metaKey = event2.metaKey || event2.ctrlKey;
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "Home":
          this.onHomeKey(event2);
          break;
        case "End":
          this.onEndKey(event2);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.onSpaceKey(event2);
          break;
        case "Tab":
          break;
        case "ShiftLeft":
        case "ShiftRight":
          this.onShiftKey(event2);
          break;
        default:
          if (this.multiple && event2.code === "KeyA" && metaKey) {
            var value3 = this.visibleOptions.filter(function(option3) {
              return _this2.isValidOption(option3);
            }).map(function(option3) {
              return _this2.getOptionValue(option3);
            });
            this.updateModel(event2, value3);
            event2.preventDefault();
            break;
          }
          if (!metaKey && isPrintableCharacter(event2.key)) {
            this.searchOptions(event2, event2.key);
            event2.preventDefault();
          }
          break;
      }
    }, "onListKeyDown"),
    onOptionSelect: /* @__PURE__ */ __name(function onOptionSelect(event2, option3) {
      var index2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      if (this.disabled || this.isOptionDisabled(option3)) {
        return;
      }
      this.multiple ? this.onOptionSelectMultiple(event2, option3) : this.onOptionSelectSingle(event2, option3);
      this.optionTouched = false;
      index2 !== -1 && (this.focusedOptionIndex = index2);
    }, "onOptionSelect"),
    onOptionMouseDown: /* @__PURE__ */ __name(function onOptionMouseDown(event2, index2) {
      this.changeFocusedOptionIndex(event2, index2);
    }, "onOptionMouseDown"),
    onOptionMouseMove: /* @__PURE__ */ __name(function onOptionMouseMove(event2, index2) {
      if (this.focusOnHover && this.focused) {
        this.changeFocusedOptionIndex(event2, index2);
      }
    }, "onOptionMouseMove"),
    onOptionTouchEnd: /* @__PURE__ */ __name(function onOptionTouchEnd() {
      if (this.disabled) {
        return;
      }
      this.optionTouched = true;
    }, "onOptionTouchEnd"),
    onOptionDblClick: /* @__PURE__ */ __name(function onOptionDblClick(event2, item2) {
      this.$emit("item-dblclick", {
        originalEvent: event2,
        value: item2
      });
      this.$emit("option-dblclick", {
        originalEvent: event2,
        value: item2
      });
    }, "onOptionDblClick"),
    onOptionSelectSingle: /* @__PURE__ */ __name(function onOptionSelectSingle(event2, option3) {
      var selected2 = this.isSelected(option3);
      var valueChanged = false;
      var value3 = null;
      var metaSelection = this.optionTouched ? false : this.metaKeySelection;
      if (metaSelection) {
        var metaKey = event2 && (event2.metaKey || event2.ctrlKey);
        if (selected2) {
          if (metaKey) {
            value3 = null;
            valueChanged = true;
          }
        } else {
          value3 = this.getOptionValue(option3);
          valueChanged = true;
        }
      } else {
        value3 = selected2 ? null : this.getOptionValue(option3);
        valueChanged = true;
      }
      if (valueChanged) {
        this.updateModel(event2, value3);
      }
    }, "onOptionSelectSingle"),
    onOptionSelectMultiple: /* @__PURE__ */ __name(function onOptionSelectMultiple(event2, option3) {
      var selected2 = this.isSelected(option3);
      var value3 = null;
      var metaSelection = this.optionTouched ? false : this.metaKeySelection;
      if (metaSelection) {
        var metaKey = event2.metaKey || event2.ctrlKey;
        if (selected2) {
          value3 = metaKey ? this.removeOption(option3) : [this.getOptionValue(option3)];
        } else {
          value3 = metaKey ? this.modelValue || [] : [];
          value3 = [].concat(_toConsumableArray$9(value3), [this.getOptionValue(option3)]);
        }
      } else {
        value3 = selected2 ? this.removeOption(option3) : [].concat(_toConsumableArray$9(this.modelValue || []), [this.getOptionValue(option3)]);
      }
      this.updateModel(event2, value3);
    }, "onOptionSelectMultiple"),
    onOptionSelectRange: /* @__PURE__ */ __name(function onOptionSelectRange(event2) {
      var _this3 = this;
      var start2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      start2 === -1 && (start2 = this.findNearestSelectedOptionIndex(end, true));
      end === -1 && (end = this.findNearestSelectedOptionIndex(start2));
      if (start2 !== -1 && end !== -1) {
        var rangeStart = Math.min(start2, end);
        var rangeEnd = Math.max(start2, end);
        var value3 = this.visibleOptions.slice(rangeStart, rangeEnd + 1).filter(function(option3) {
          return _this3.isValidOption(option3);
        }).map(function(option3) {
          return _this3.getOptionValue(option3);
        });
        this.updateModel(event2, value3);
      }
    }, "onOptionSelectRange"),
    onFilterChange: /* @__PURE__ */ __name(function onFilterChange(event2) {
      this.$emit("filter", {
        originalEvent: event2,
        value: event2.target.value
      });
      this.focusedOptionIndex = this.startRangeIndex = -1;
    }, "onFilterChange"),
    onFilterBlur: /* @__PURE__ */ __name(function onFilterBlur() {
      this.focusedOptionIndex = this.startRangeIndex = -1;
    }, "onFilterBlur"),
    onFilterKeyDown: /* @__PURE__ */ __name(function onFilterKeyDown(event2) {
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, true);
          break;
        case "Home":
          this.onHomeKey(event2, true);
          break;
        case "End":
          this.onEndKey(event2, true);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "ShiftLeft":
        case "ShiftRight":
          this.onShiftKey(event2);
          break;
      }
    }, "onFilterKeyDown"),
    onArrowDownKey: /* @__PURE__ */ __name(function onArrowDownKey(event2) {
      var optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.findFirstFocusedOptionIndex();
      if (this.multiple && event2.shiftKey) {
        this.onOptionSelectRange(event2, this.startRangeIndex, optionIndex);
      }
      this.changeFocusedOptionIndex(event2, optionIndex);
      event2.preventDefault();
    }, "onArrowDownKey"),
    onArrowUpKey: /* @__PURE__ */ __name(function onArrowUpKey(event2) {
      var optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.findLastFocusedOptionIndex();
      if (this.multiple && event2.shiftKey) {
        this.onOptionSelectRange(event2, optionIndex, this.startRangeIndex);
      }
      this.changeFocusedOptionIndex(event2, optionIndex);
      event2.preventDefault();
    }, "onArrowUpKey"),
    onArrowLeftKey: /* @__PURE__ */ __name(function onArrowLeftKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      pressedInInputText && (this.focusedOptionIndex = -1);
    }, "onArrowLeftKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(0, event2.target.selectionStart);
        } else {
          target.setSelectionRange(0, 0);
          this.focusedOptionIndex = -1;
        }
      } else {
        var metaKey = event2.metaKey || event2.ctrlKey;
        var optionIndex = this.findFirstOptionIndex();
        if (this.multiple && event2.shiftKey && metaKey) {
          this.onOptionSelectRange(event2, optionIndex, this.startRangeIndex);
        }
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(event2.target.selectionStart, target.value.length);
        } else {
          var len = target.value.length;
          target.setSelectionRange(len, len);
          this.focusedOptionIndex = -1;
        }
      } else {
        var metaKey = event2.metaKey || event2.ctrlKey;
        var optionIndex = this.findLastOptionIndex();
        if (this.multiple && event2.shiftKey && metaKey) {
          this.onOptionSelectRange(event2, this.startRangeIndex, optionIndex);
        }
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    }, "onEndKey"),
    onPageUpKey: /* @__PURE__ */ __name(function onPageUpKey(event2) {
      this.scrollInView(0);
      event2.preventDefault();
    }, "onPageUpKey"),
    onPageDownKey: /* @__PURE__ */ __name(function onPageDownKey(event2) {
      this.scrollInView(this.visibleOptions.length - 1);
      event2.preventDefault();
    }, "onPageDownKey"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey(event2) {
      if (this.focusedOptionIndex !== -1) {
        if (this.multiple && event2.shiftKey) this.onOptionSelectRange(event2, this.focusedOptionIndex);
        else this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
      }
    }, "onEnterKey"),
    onSpaceKey: /* @__PURE__ */ __name(function onSpaceKey(event2) {
      event2.preventDefault();
      this.onEnterKey(event2);
    }, "onSpaceKey"),
    onShiftKey: /* @__PURE__ */ __name(function onShiftKey() {
      this.startRangeIndex = this.focusedOptionIndex;
    }, "onShiftKey"),
    isOptionMatched: /* @__PURE__ */ __name(function isOptionMatched(option3) {
      var _this$getOptionLabel;
      return this.isValidOption(option3) && typeof this.getOptionLabel(option3) === "string" && ((_this$getOptionLabel = this.getOptionLabel(option3)) === null || _this$getOptionLabel === void 0 ? void 0 : _this$getOptionLabel.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale)));
    }, "isOptionMatched"),
    isValidOption: /* @__PURE__ */ __name(function isValidOption(option3) {
      return isNotEmpty(option3) && !(this.isOptionDisabled(option3) || this.isOptionGroup(option3));
    }, "isValidOption"),
    isValidSelectedOption: /* @__PURE__ */ __name(function isValidSelectedOption(option3) {
      return this.isValidOption(option3) && this.isSelected(option3);
    }, "isValidSelectedOption"),
    isEquals: /* @__PURE__ */ __name(function isEquals(value1, value22) {
      return equals(value1, value22, this.equalityKey);
    }, "isEquals"),
    isSelected: /* @__PURE__ */ __name(function isSelected(option3) {
      var _this4 = this;
      var optionValue = this.getOptionValue(option3);
      if (this.multiple) return (this.modelValue || []).some(function(value3) {
        return _this4.isEquals(value3, optionValue);
      });
      else return this.isEquals(this.modelValue, optionValue);
    }, "isSelected"),
    findFirstOptionIndex: /* @__PURE__ */ __name(function findFirstOptionIndex() {
      var _this5 = this;
      return this.visibleOptions.findIndex(function(option3) {
        return _this5.isValidOption(option3);
      });
    }, "findFirstOptionIndex"),
    findLastOptionIndex: /* @__PURE__ */ __name(function findLastOptionIndex() {
      var _this6 = this;
      return findLastIndex(this.visibleOptions, function(option3) {
        return _this6.isValidOption(option3);
      });
    }, "findLastOptionIndex"),
    findNextOptionIndex: /* @__PURE__ */ __name(function findNextOptionIndex(index2) {
      var _this7 = this;
      var matchedOptionIndex = index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option3) {
        return _this7.isValidOption(option3);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : index2;
    }, "findNextOptionIndex"),
    findPrevOptionIndex: /* @__PURE__ */ __name(function findPrevOptionIndex(index2) {
      var _this8 = this;
      var matchedOptionIndex = index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option3) {
        return _this8.isValidOption(option3);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    }, "findPrevOptionIndex"),
    findSelectedOptionIndex: /* @__PURE__ */ __name(function findSelectedOptionIndex() {
      var _this9 = this;
      if (this.hasSelectedOption) {
        if (this.multiple) {
          var _loop = /* @__PURE__ */ __name(function _loop2() {
            var value3 = _this9.modelValue[index2];
            var matchedOptionIndex = _this9.visibleOptions.findIndex(function(option3) {
              return _this9.isValidSelectedOption(option3) && _this9.isEquals(value3, _this9.getOptionValue(option3));
            });
            if (matchedOptionIndex > -1) return {
              v: matchedOptionIndex
            };
          }, "_loop"), _ret;
          for (var index2 = this.modelValue.length - 1; index2 >= 0; index2--) {
            _ret = _loop();
            if (_ret) return _ret.v;
          }
        } else {
          return this.visibleOptions.findIndex(function(option3) {
            return _this9.isValidSelectedOption(option3);
          });
        }
      }
      return -1;
    }, "findSelectedOptionIndex"),
    findFirstSelectedOptionIndex: /* @__PURE__ */ __name(function findFirstSelectedOptionIndex() {
      var _this10 = this;
      return this.hasSelectedOption ? this.visibleOptions.findIndex(function(option3) {
        return _this10.isValidSelectedOption(option3);
      }) : -1;
    }, "findFirstSelectedOptionIndex"),
    findLastSelectedOptionIndex: /* @__PURE__ */ __name(function findLastSelectedOptionIndex() {
      var _this11 = this;
      return this.hasSelectedOption ? findLastIndex(this.visibleOptions, function(option3) {
        return _this11.isValidSelectedOption(option3);
      }) : -1;
    }, "findLastSelectedOptionIndex"),
    findNextSelectedOptionIndex: /* @__PURE__ */ __name(function findNextSelectedOptionIndex(index2) {
      var _this12 = this;
      var matchedOptionIndex = this.hasSelectedOption && index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option3) {
        return _this12.isValidSelectedOption(option3);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : -1;
    }, "findNextSelectedOptionIndex"),
    findPrevSelectedOptionIndex: /* @__PURE__ */ __name(function findPrevSelectedOptionIndex(index2) {
      var _this13 = this;
      var matchedOptionIndex = this.hasSelectedOption && index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option3) {
        return _this13.isValidSelectedOption(option3);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : -1;
    }, "findPrevSelectedOptionIndex"),
    findNearestSelectedOptionIndex: /* @__PURE__ */ __name(function findNearestSelectedOptionIndex(index2) {
      var firstCheckUp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var matchedOptionIndex = -1;
      if (this.hasSelectedOption) {
        if (firstCheckUp) {
          matchedOptionIndex = this.findPrevSelectedOptionIndex(index2);
          matchedOptionIndex = matchedOptionIndex === -1 ? this.findNextSelectedOptionIndex(index2) : matchedOptionIndex;
        } else {
          matchedOptionIndex = this.findNextSelectedOptionIndex(index2);
          matchedOptionIndex = matchedOptionIndex === -1 ? this.findPrevSelectedOptionIndex(index2) : matchedOptionIndex;
        }
      }
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    }, "findNearestSelectedOptionIndex"),
    findFirstFocusedOptionIndex: /* @__PURE__ */ __name(function findFirstFocusedOptionIndex() {
      var selectedIndex = this.findFirstSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    }, "findFirstFocusedOptionIndex"),
    findLastFocusedOptionIndex: /* @__PURE__ */ __name(function findLastFocusedOptionIndex() {
      var selectedIndex = this.findLastSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    }, "findLastFocusedOptionIndex"),
    searchOptions: /* @__PURE__ */ __name(function searchOptions(event2, _char) {
      var _this14 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var optionIndex = -1;
      if (isNotEmpty(this.searchValue)) {
        if (this.focusedOptionIndex !== -1) {
          optionIndex = this.visibleOptions.slice(this.focusedOptionIndex).findIndex(function(option3) {
            return _this14.isOptionMatched(option3);
          });
          optionIndex = optionIndex === -1 ? this.visibleOptions.slice(0, this.focusedOptionIndex).findIndex(function(option3) {
            return _this14.isOptionMatched(option3);
          }) : optionIndex + this.focusedOptionIndex;
        } else {
          optionIndex = this.visibleOptions.findIndex(function(option3) {
            return _this14.isOptionMatched(option3);
          });
        }
        if (optionIndex === -1 && this.focusedOptionIndex === -1) {
          optionIndex = this.findFirstFocusedOptionIndex();
        }
        if (optionIndex !== -1) {
          this.changeFocusedOptionIndex(event2, optionIndex);
        }
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this14.searchValue = "";
        _this14.searchTimeout = null;
      }, 500);
    }, "searchOptions"),
    removeOption: /* @__PURE__ */ __name(function removeOption(option3) {
      var _this15 = this;
      return this.modelValue.filter(function(val) {
        return !equals(val, _this15.getOptionValue(option3), _this15.equalityKey);
      });
    }, "removeOption"),
    changeFocusedOptionIndex: /* @__PURE__ */ __name(function changeFocusedOptionIndex(event2, index2) {
      if (this.focusedOptionIndex !== index2) {
        this.focusedOptionIndex = index2;
        this.scrollInView();
        if (this.selectOnFocus && !this.multiple) {
          this.onOptionSelect(event2, this.visibleOptions[index2]);
        }
      }
    }, "changeFocusedOptionIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView3() {
      var _this16 = this;
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var id3 = index2 !== -1 ? "".concat(_this16.id, "_").concat(index2) : _this16.focusedOptionId;
        var element = findSingle(_this16.list, 'li[id="'.concat(id3, '"]'));
        if (element) {
          element.scrollIntoView && element.scrollIntoView({
            block: "nearest",
            inline: "nearest",
            behavior: "smooth"
          });
        } else if (!_this16.virtualScrollerDisabled) {
          _this16.virtualScroller && _this16.virtualScroller.scrollToIndex(index2 !== -1 ? index2 : _this16.focusedOptionIndex);
        }
      });
    }, "scrollInView"),
    autoUpdateModel: /* @__PURE__ */ __name(function autoUpdateModel() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption && !this.multiple && this.focused) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex]);
      }
    }, "autoUpdateModel"),
    updateModel: /* @__PURE__ */ __name(function updateModel(event2, value3) {
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        originalEvent: event2,
        value: value3
      });
    }, "updateModel"),
    flatOptions: /* @__PURE__ */ __name(function flatOptions(options3) {
      var _this17 = this;
      return (options3 || []).reduce(function(result, option3, index2) {
        result.push({
          optionGroup: option3,
          group: true,
          index: index2
        });
        var optionGroupChildren = _this17.getOptionGroupChildren(option3);
        optionGroupChildren && optionGroupChildren.forEach(function(o) {
          return result.push(o);
        });
        return result;
      }, []);
    }, "flatOptions"),
    listRef: /* @__PURE__ */ __name(function listRef(el, contentRef3) {
      this.list = el;
      contentRef3 && contentRef3(el);
    }, "listRef"),
    virtualScrollerRef: /* @__PURE__ */ __name(function virtualScrollerRef(el) {
      this.virtualScroller = el;
    }, "virtualScrollerRef")
  },
  computed: {
    visibleOptions: /* @__PURE__ */ __name(function visibleOptions() {
      var options3 = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
      return this.filterValue ? FilterService.filter(options3, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale) : options3;
    }, "visibleOptions"),
    hasSelectedOption: /* @__PURE__ */ __name(function hasSelectedOption() {
      return isNotEmpty(this.modelValue);
    }, "hasSelectedOption"),
    equalityKey: /* @__PURE__ */ __name(function equalityKey() {
      return this.optionValue ? null : this.dataKey;
    }, "equalityKey"),
    searchFields: /* @__PURE__ */ __name(function searchFields() {
      return this.filterFields || [this.optionLabel];
    }, "searchFields"),
    filterResultMessageText: /* @__PURE__ */ __name(function filterResultMessageText() {
      return isNotEmpty(this.visibleOptions) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptyFilterMessageText;
    }, "filterResultMessageText"),
    filterMessageText: /* @__PURE__ */ __name(function filterMessageText() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || "";
    }, "filterMessageText"),
    emptyFilterMessageText: /* @__PURE__ */ __name(function emptyFilterMessageText() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || "";
    }, "emptyFilterMessageText"),
    emptyMessageText: /* @__PURE__ */ __name(function emptyMessageText() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || "";
    }, "emptyMessageText"),
    selectionMessageText: /* @__PURE__ */ __name(function selectionMessageText() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    }, "selectionMessageText"),
    emptySelectionMessageText: /* @__PURE__ */ __name(function emptySelectionMessageText() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    }, "emptySelectionMessageText"),
    selectedMessageText: /* @__PURE__ */ __name(function selectedMessageText() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll("{0}", this.multiple ? this.modelValue.length : "1") : this.emptySelectionMessageText;
    }, "selectedMessageText"),
    focusedOptionId: /* @__PURE__ */ __name(function focusedOptionId() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.id, "_").concat(this.focusedOptionIndex) : null;
    }, "focusedOptionId"),
    ariaSetSize: /* @__PURE__ */ __name(function ariaSetSize() {
      var _this18 = this;
      return this.visibleOptions.filter(function(option3) {
        return !_this18.isOptionGroup(option3);
      }).length;
    }, "ariaSetSize"),
    virtualScrollerDisabled: /* @__PURE__ */ __name(function virtualScrollerDisabled() {
      return !this.virtualScrollerOptions;
    }, "virtualScrollerDisabled")
  },
  directives: {
    ripple: Ripple
  },
  components: {
    InputText: script$R,
    VirtualScroller: script$P,
    InputIcon: script$S,
    IconField: script$T,
    SearchIcon: script$U,
    CheckIcon: script$V,
    BlankIcon: script$W
  }
};
var _hoisted_1$19 = ["id"];
var _hoisted_2$T = ["tabindex"];
var _hoisted_3$t = ["id", "aria-multiselectable", "aria-label", "aria-labelledby", "aria-activedescendant", "aria-disabled"];
var _hoisted_4$k = ["id"];
var _hoisted_5$e = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousedown", "onMousemove", "onDblclick", "data-p-selected", "data-p-focused", "data-p-disabled"];
var _hoisted_6$a = ["tabindex"];
function render$N(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_BlankIcon = resolveComponent("BlankIcon");
  var _component_VirtualScroller = resolveComponent("VirtualScroller");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    id: $data.id,
    "class": _ctx.cx("root"),
    onFocusout: _cache[7] || (_cache[7] = function() {
      return $options.onFocusout && $options.onFocusout.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [createBaseVNode("span", mergeProps({
    ref: "firstHiddenFocusableElement",
    role: "presentation",
    "aria-hidden": "true",
    "class": "p-hidden-accessible p-hidden-focusable",
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFirstHiddenFocus && $options.onFirstHiddenFocus.apply($options, arguments);
    })
  }, _ctx.ptm("hiddenFirstFocusableEl"), {
    "data-p-hidden-accessible": true,
    "data-p-hidden-focusable": true
  }), null, 16, _hoisted_2$T), _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
    key: 0,
    "class": normalizeClass(_ctx.cx("header"))
  }, [renderSlot(_ctx.$slots, "header", {
    value: _ctx.modelValue,
    options: $options.visibleOptions
  })], 2)) : createCommentVNode("", true), _ctx.filter ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("header")
  }, _ctx.ptm("header")), [createVNode(_component_IconField, {
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcFilterContainer")
  }, {
    "default": withCtx(function() {
      return [createVNode(_component_InputText, {
        modelValue: $data.filterValue,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = function($event) {
          return $data.filterValue = $event;
        }),
        type: "text",
        "class": normalizeClass(_ctx.cx("pcFilter")),
        placeholder: _ctx.filterPlaceholder,
        role: "searchbox",
        autocomplete: "off",
        disabled: _ctx.disabled,
        unstyled: _ctx.unstyled,
        "aria-owns": $data.id + "_list",
        "aria-activedescendant": $options.focusedOptionId,
        tabindex: !_ctx.disabled && !$data.focused ? _ctx.tabindex : -1,
        onInput: $options.onFilterChange,
        onBlur: $options.onFilterBlur,
        onKeydown: $options.onFilterKeyDown,
        pt: _ctx.ptm("pcFilter")
      }, null, 8, ["modelValue", "class", "placeholder", "disabled", "unstyled", "aria-owns", "aria-activedescendant", "tabindex", "onInput", "onBlur", "onKeydown", "pt"]), createVNode(_component_InputIcon, mergeProps({
        unstyled: _ctx.unstyled
      }, _ctx.ptm("pcFilterIconContainer")), {
        "default": withCtx(function() {
          return [renderSlot(_ctx.$slots, "filtericon", {}, function() {
            return [_ctx.filterIcon ? (openBlock(), createElementBlock("span", mergeProps({
              key: 0,
              "class": _ctx.filterIcon
            }, _ctx.ptm("filterIcon")), null, 16)) : (openBlock(), createBlock(_component_SearchIcon, normalizeProps(mergeProps({
              key: 1
            }, _ctx.ptm("filterIcon"))), null, 16))];
          })];
        }),
        _: 3
      }, 16, ["unstyled"])];
    }),
    _: 3
  }, 8, ["unstyled", "pt"]), createBaseVNode("span", mergeProps({
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenFilterResult"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.filterResultMessageText), 17)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("listContainer"),
    style: [{
      "max-height": $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
    }, _ctx.listStyle]
  }, _ctx.ptm("listContainer")), [createVNode(_component_VirtualScroller, mergeProps({
    ref: $options.virtualScrollerRef
  }, _ctx.virtualScrollerOptions, {
    items: $options.visibleOptions,
    style: [{
      height: _ctx.scrollHeight
    }, _ctx.listStyle],
    tabindex: -1,
    disabled: $options.virtualScrollerDisabled,
    pt: _ctx.ptm("virtualScroller")
  }), createSlots({
    content: withCtx(function(_ref) {
      var styleClass = _ref.styleClass, contentRef3 = _ref.contentRef, items2 = _ref.items, getItemOptions = _ref.getItemOptions, contentStyle = _ref.contentStyle, itemSize2 = _ref.itemSize;
      return [createBaseVNode("ul", mergeProps({
        ref: /* @__PURE__ */ __name(function ref2(el) {
          return $options.listRef(el, contentRef3);
        }, "ref"),
        id: $data.id + "_list",
        "class": [_ctx.cx("list"), styleClass],
        style: contentStyle,
        tabindex: -1,
        role: "listbox",
        "aria-multiselectable": _ctx.multiple,
        "aria-label": _ctx.ariaLabel,
        "aria-labelledby": _ctx.ariaLabelledby,
        "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
        "aria-disabled": _ctx.disabled,
        onFocus: _cache[3] || (_cache[3] = function() {
          return $options.onListFocus && $options.onListFocus.apply($options, arguments);
        }),
        onBlur: _cache[4] || (_cache[4] = function() {
          return $options.onListBlur && $options.onListBlur.apply($options, arguments);
        }),
        onKeydown: _cache[5] || (_cache[5] = function() {
          return $options.onListKeyDown && $options.onListKeyDown.apply($options, arguments);
        })
      }, _ctx.ptm("list")), [(openBlock(true), createElementBlock(Fragment, null, renderList(items2, function(option3, i2) {
        return openBlock(), createElementBlock(Fragment, {
          key: $options.getOptionRenderKey(option3, $options.getOptionIndex(i2, getItemOptions))
        }, [$options.isOptionGroup(option3) ? (openBlock(), createElementBlock("li", mergeProps({
          key: 0,
          id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
          style: {
            height: itemSize2 ? itemSize2 + "px" : void 0
          },
          "class": _ctx.cx("optionGroup"),
          role: "option",
          ref_for: true
        }, _ctx.ptm("optionGroup")), [renderSlot(_ctx.$slots, "optiongroup", {
          option: option3.optionGroup,
          index: $options.getOptionIndex(i2, getItemOptions)
        }, function() {
          return [createTextVNode(toDisplayString$1($options.getOptionGroupLabel(option3.optionGroup)), 1)];
        })], 16, _hoisted_4$k)) : withDirectives((openBlock(), createElementBlock("li", mergeProps({
          key: 1,
          id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
          style: {
            height: itemSize2 ? itemSize2 + "px" : void 0
          },
          "class": _ctx.cx("option", {
            option: option3,
            index: i2,
            getItemOptions
          }),
          role: "option",
          "aria-label": $options.getOptionLabel(option3),
          "aria-selected": $options.isSelected(option3),
          "aria-disabled": $options.isOptionDisabled(option3),
          "aria-setsize": $options.ariaSetSize,
          "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i2, getItemOptions)),
          onClick: /* @__PURE__ */ __name(function onClick3($event) {
            return $options.onOptionSelect($event, option3, $options.getOptionIndex(i2, getItemOptions));
          }, "onClick"),
          onMousedown: /* @__PURE__ */ __name(function onMousedown($event) {
            return $options.onOptionMouseDown($event, $options.getOptionIndex(i2, getItemOptions));
          }, "onMousedown"),
          onMousemove: /* @__PURE__ */ __name(function onMousemove($event) {
            return $options.onOptionMouseMove($event, $options.getOptionIndex(i2, getItemOptions));
          }, "onMousemove"),
          onTouchend: _cache[2] || (_cache[2] = function($event) {
            return $options.onOptionTouchEnd();
          }),
          onDblclick: /* @__PURE__ */ __name(function onDblclick($event) {
            return $options.onOptionDblClick($event, option3);
          }, "onDblclick"),
          ref_for: true
        }, $options.getPTOptions(option3, getItemOptions, i2, "option"), {
          "data-p-selected": $options.isSelected(option3),
          "data-p-focused": $data.focusedOptionIndex === $options.getOptionIndex(i2, getItemOptions),
          "data-p-disabled": $options.isOptionDisabled(option3)
        }), [_ctx.checkmark ? (openBlock(), createElementBlock(Fragment, {
          key: 0
        }, [$options.isSelected(option3) ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
          key: 0,
          "class": _ctx.cx("optionCheckIcon"),
          ref_for: true
        }, _ctx.ptm("optionCheckIcon")), null, 16, ["class"])) : (openBlock(), createBlock(_component_BlankIcon, mergeProps({
          key: 1,
          "class": _ctx.cx("optionBlankIcon"),
          ref_for: true
        }, _ctx.ptm("optionBlankIcon")), null, 16, ["class"]))], 64)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "option", {
          option: option3,
          selected: $options.isSelected(option3),
          index: $options.getOptionIndex(i2, getItemOptions)
        }, function() {
          return [createTextVNode(toDisplayString$1($options.getOptionLabel(option3)), 1)];
        })], 16, _hoisted_5$e)), [[_directive_ripple]])], 64);
      }), 128)), $data.filterValue && (!items2 || items2 && items2.length === 0) ? (openBlock(), createElementBlock("li", mergeProps({
        key: 0,
        "class": _ctx.cx("emptyMessage"),
        role: "option"
      }, _ctx.ptm("emptyMessage")), [renderSlot(_ctx.$slots, "emptyfilter", {}, function() {
        return [createTextVNode(toDisplayString$1($options.emptyFilterMessageText), 1)];
      })], 16)) : !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("li", mergeProps({
        key: 1,
        "class": _ctx.cx("emptyMessage"),
        role: "option"
      }, _ctx.ptm("emptyMessage")), [renderSlot(_ctx.$slots, "empty", {}, function() {
        return [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)];
      })], 16)) : createCommentVNode("", true)], 16, _hoisted_3$t)];
    }),
    _: 2
  }, [_ctx.$slots.loader ? {
    name: "loader",
    fn: withCtx(function(_ref2) {
      var options3 = _ref2.options;
      return [renderSlot(_ctx.$slots, "loader", {
        options: options3
      })];
    }),
    key: "0"
  } : void 0]), 1040, ["items", "style", "disabled", "pt"])], 16), renderSlot(_ctx.$slots, "footer", {
    value: _ctx.modelValue,
    options: $options.visibleOptions
  }), !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenEmptyMessage"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.emptyMessageText), 17)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenSelectedMessage"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.selectedMessageText), 17), createBaseVNode("span", mergeProps({
    ref: "lastHiddenFocusableElement",
    role: "presentation",
    "aria-hidden": "true",
    "class": "p-hidden-accessible p-hidden-focusable",
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    onFocus: _cache[6] || (_cache[6] = function() {
      return $options.onLastHiddenFocus && $options.onLastHiddenFocus.apply($options, arguments);
    })
  }, _ctx.ptm("hiddenLastFocusableEl"), {
    "data-p-hidden-accessible": true,
    "data-p-hidden-focusable": true
  }), null, 16, _hoisted_6$a)], 16, _hoisted_1$19);
}
__name(render$N, "render$N");
script$O.render = render$N;
var theme$t = /* @__PURE__ */ __name(function theme8(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-badge {\n    display: inline-flex;\n    border-radius: ".concat(dt2("badge.border.radius"), ";\n    align-items: center;\n    justify-content: center;\n    padding: ").concat(dt2("badge.padding"), ";\n    background: ").concat(dt2("badge.primary.background"), ";\n    color: ").concat(dt2("badge.primary.color"), ";\n    font-size: ").concat(dt2("badge.font.size"), ";\n    font-weight: ").concat(dt2("badge.font.weight"), ";\n    min-width: ").concat(dt2("badge.min.width"), ";\n    height: ").concat(dt2("badge.height"), ";\n}\n\n.p-badge-dot {\n    width: ").concat(dt2("badge.dot.size"), ";\n    min-width: ").concat(dt2("badge.dot.size"), ";\n    height: ").concat(dt2("badge.dot.size"), ";\n    border-radius: 50%;\n    padding: 0;\n}\n\n.p-badge-circle {\n    padding: 0;\n    border-radius: 50%;\n}\n\n.p-badge-secondary {\n    background: ").concat(dt2("badge.secondary.background"), ";\n    color: ").concat(dt2("badge.secondary.color"), ";\n}\n\n.p-badge-success {\n    background: ").concat(dt2("badge.success.background"), ";\n    color: ").concat(dt2("badge.success.color"), ";\n}\n\n.p-badge-info {\n    background: ").concat(dt2("badge.info.background"), ";\n    color: ").concat(dt2("badge.info.color"), ";\n}\n\n.p-badge-warn {\n    background: ").concat(dt2("badge.warn.background"), ";\n    color: ").concat(dt2("badge.warn.color"), ";\n}\n\n.p-badge-danger {\n    background: ").concat(dt2("badge.danger.background"), ";\n    color: ").concat(dt2("badge.danger.color"), ";\n}\n\n.p-badge-contrast {\n    background: ").concat(dt2("badge.contrast.background"), ";\n    color: ").concat(dt2("badge.contrast.color"), ";\n}\n\n.p-badge-sm {\n    font-size: ").concat(dt2("badge.sm.font.size"), ";\n    min-width: ").concat(dt2("badge.sm.min.width"), ";\n    height: ").concat(dt2("badge.sm.height"), ";\n}\n\n.p-badge-lg {\n    font-size: ").concat(dt2("badge.lg.font.size"), ";\n    min-width: ").concat(dt2("badge.lg.min.width"), ";\n    height: ").concat(dt2("badge.lg.height"), ";\n}\n\n.p-badge-xl {\n    font-size: ").concat(dt2("badge.xl.font.size"), ";\n    min-width: ").concat(dt2("badge.xl.min.width"), ";\n    height: ").concat(dt2("badge.xl.height"), ";\n}\n");
}, "theme");
var classes$v = {
  root: /* @__PURE__ */ __name(function root3(_ref2) {
    var props = _ref2.props, instance = _ref2.instance;
    return ["p-badge p-component", {
      "p-badge-circle": isNotEmpty(props.value) && String(props.value).length === 1,
      "p-badge-dot": isEmpty(props.value) && !instance.$slots["default"],
      "p-badge-sm": props.size === "small",
      "p-badge-lg": props.size === "large",
      "p-badge-xl": props.size === "xlarge",
      "p-badge-info": props.severity === "info",
      "p-badge-success": props.severity === "success",
      "p-badge-warn": props.severity === "warn",
      "p-badge-danger": props.severity === "danger",
      "p-badge-secondary": props.severity === "secondary",
      "p-badge-contrast": props.severity === "contrast"
    }];
  }, "root")
};
var BadgeStyle = BaseStyle.extend({
  name: "badge",
  theme: theme$t,
  classes: classes$v
});
var script$1$u = {
  name: "BaseBadge",
  "extends": script$Y,
  props: {
    value: {
      type: [String, Number],
      "default": null
    },
    severity: {
      type: String,
      "default": null
    },
    size: {
      type: String,
      "default": null
    }
  },
  style: BadgeStyle,
  provide: /* @__PURE__ */ __name(function provide8() {
    return {
      $pcBadge: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$N = {
  name: "Badge",
  "extends": script$1$u,
  inheritAttrs: false
};
function render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [createTextVNode(toDisplayString$1(_ctx.value), 1)];
  })], 16);
}
__name(render$M, "render$M");
script$N.render = render$M;
function _typeof$c(o) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$c(o);
}
__name(_typeof$c, "_typeof$c");
function _defineProperty$c(e, r, t) {
  return (r = _toPropertyKey$b(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$c, "_defineProperty$c");
function _toPropertyKey$b(t) {
  var i2 = _toPrimitive$b(t, "string");
  return "symbol" == _typeof$c(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$b, "_toPropertyKey$b");
function _toPrimitive$b(t, r) {
  if ("object" != _typeof$c(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$c(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$b, "_toPrimitive$b");
var theme$s = /* @__PURE__ */ __name(function theme9(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-button {\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    color: ".concat(dt2("button.primary.color"), ";\n    background: ").concat(dt2("button.primary.background"), ";\n    border: 1px solid ").concat(dt2("button.primary.border.color"), ";\n    padding: ").concat(dt2("button.padding.y"), " ").concat(dt2("button.padding.x"), ";\n    font-size: 1rem;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    transition: background ").concat(dt2("button.transition.duration"), ", color ").concat(dt2("button.transition.duration"), ", border-color ").concat(dt2("button.transition.duration"), ",\n            outline-color ").concat(dt2("button.transition.duration"), ", box-shadow ").concat(dt2("button.transition.duration"), ";\n    border-radius: ").concat(dt2("button.border.radius"), ";\n    outline-color: transparent;\n    gap: ").concat(dt2("button.gap"), ";\n}\n\n.p-button:disabled {\n    cursor: default;\n}\n\n.p-button-icon-right {\n    order: 1;\n}\n\n.p-button-icon-bottom {\n    order: 2;\n}\n\n.p-button-icon-only {\n    width: ").concat(dt2("button.icon.only.width"), ";\n    padding-left: 0;\n    padding-right: 0;\n    gap: 0;\n}\n\n.p-button-icon-only.p-button-rounded {\n    border-radius: 50%;\n    height: ").concat(dt2("button.icon.only.width"), ";\n}\n\n.p-button-icon-only .p-button-label {\n    visibility: hidden;\n    width: 0;\n}\n\n.p-button-sm {\n    font-size: ").concat(dt2("button.sm.font.size"), ";\n    padding: ").concat(dt2("button.sm.padding.y"), " ").concat(dt2("button.sm.padding.x"), ";\n}\n\n.p-button-sm .p-button-icon {\n    font-size: ").concat(dt2("button.sm.font.size"), ";\n}\n\n.p-button-lg {\n    font-size: ").concat(dt2("button.lg.font.size"), ";\n    padding: ").concat(dt2("button.lg.padding.y"), " ").concat(dt2("button.lg.padding.x"), ";\n}\n\n.p-button-lg .p-button-icon {\n    font-size: ").concat(dt2("button.lg.font.size"), ";\n}\n\n.p-button-vertical {\n    flex-direction: column;\n}\n\n.p-button-label {\n    font-weight: ").concat(dt2("button.label.font.weight"), ";\n}\n\n.p-button-fluid {\n    width: 100%;\n}\n\n.p-button-fluid.p-button-icon-only {\n    width: ").concat(dt2("button.icon.only.width"), ";\n}\n\n.p-button:not(:disabled):hover {\n    background: ").concat(dt2("button.primary.hover.background"), ";\n    border: 1px solid ").concat(dt2("button.primary.hover.border.color"), ";\n    color: ").concat(dt2("button.primary.hover.color"), ";\n}\n\n.p-button:not(:disabled):active {\n    background: ").concat(dt2("button.primary.active.background"), ";\n    border: 1px solid ").concat(dt2("button.primary.active.border.color"), ";\n    color: ").concat(dt2("button.primary.active.color"), ";\n}\n\n.p-button:focus-visible {\n    box-shadow: ").concat(dt2("button.primary.focus.ring.shadow"), ";\n    outline: ").concat(dt2("button.focus.ring.width"), " ").concat(dt2("button.focus.ring.style"), " ").concat(dt2("button.primary.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("button.focus.ring.offset"), ";\n}\n\n.p-button .p-badge {\n    min-width: ").concat(dt2("button.badge.size"), ";\n    height: ").concat(dt2("button.badge.size"), ";\n    line-height: ").concat(dt2("button.badge.size"), ";\n}\n\n.p-button-raised {\n    box-shadow: ").concat(dt2("button.raised.shadow"), ";\n}\n\n.p-button-rounded {\n    border-radius: ").concat(dt2("button.rounded.border.radius"), ";\n}\n\n.p-button-secondary {\n    background: ").concat(dt2("button.secondary.background"), ";\n    border: 1px solid ").concat(dt2("button.secondary.border.color"), ";\n    color: ").concat(dt2("button.secondary.color"), ";\n}\n\n.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt2("button.secondary.hover.background"), ";\n    border: 1px solid ").concat(dt2("button.secondary.hover.border.color"), ";\n    color: ").concat(dt2("button.secondary.hover.color"), ";\n}\n\n.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt2("button.secondary.active.background"), ";\n    border: 1px solid ").concat(dt2("button.secondary.active.border.color"), ";\n    color: ").concat(dt2("button.secondary.active.color"), ";\n}\n\n.p-button-secondary:focus-visible {\n    outline-color: ").concat(dt2("button.secondary.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("button.secondary.focus.ring.shadow"), ";\n}\n\n.p-button-success {\n    background: ").concat(dt2("button.success.background"), ";\n    border: 1px solid ").concat(dt2("button.success.border.color"), ";\n    color: ").concat(dt2("button.success.color"), ";\n}\n\n.p-button-success:not(:disabled):hover {\n    background: ").concat(dt2("button.success.hover.background"), ";\n    border: 1px solid ").concat(dt2("button.success.hover.border.color"), ";\n    color: ").concat(dt2("button.success.hover.color"), ";\n}\n\n.p-button-success:not(:disabled):active {\n    background: ").concat(dt2("button.success.active.background"), ";\n    border: 1px solid ").concat(dt2("button.success.active.border.color"), ";\n    color: ").concat(dt2("button.success.active.color"), ";\n}\n\n.p-button-success:focus-visible {\n    outline-color: ").concat(dt2("button.success.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("button.success.focus.ring.shadow"), ";\n}\n\n.p-button-info {\n    background: ").concat(dt2("button.info.background"), ";\n    border: 1px solid ").concat(dt2("button.info.border.color"), ";\n    color: ").concat(dt2("button.info.color"), ";\n}\n\n.p-button-info:not(:disabled):hover {\n    background: ").concat(dt2("button.info.hover.background"), ";\n    border: 1px solid ").concat(dt2("button.info.hover.border.color"), ";\n    color: ").concat(dt2("button.info.hover.color"), ";\n}\n\n.p-button-info:not(:disabled):active {\n    background: ").concat(dt2("button.info.active.background"), ";\n    border: 1px solid ").concat(dt2("button.info.active.border.color"), ";\n    color: ").concat(dt2("button.info.active.color"), ";\n}\n\n.p-button-info:focus-visible {\n    outline-color: ").concat(dt2("button.info.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("button.info.focus.ring.shadow"), ";\n}\n\n.p-button-warn {\n    background: ").concat(dt2("button.warn.background"), ";\n    border: 1px solid ").concat(dt2("button.warn.border.color"), ";\n    color: ").concat(dt2("button.warn.color"), ";\n}\n\n.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt2("button.warn.hover.background"), ";\n    border: 1px solid ").concat(dt2("button.warn.hover.border.color"), ";\n    color: ").concat(dt2("button.warn.hover.color"), ";\n}\n\n.p-button-warn:not(:disabled):active {\n    background: ").concat(dt2("button.warn.active.background"), ";\n    border: 1px solid ").concat(dt2("button.warn.active.border.color"), ";\n    color: ").concat(dt2("button.warn.active.color"), ";\n}\n\n.p-button-warn:focus-visible {\n    outline-color: ").concat(dt2("button.warn.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("button.warn.focus.ring.shadow"), ";\n}\n\n.p-button-help {\n    background: ").concat(dt2("button.help.background"), ";\n    border: 1px solid ").concat(dt2("button.help.border.color"), ";\n    color: ").concat(dt2("button.help.color"), ";\n}\n\n.p-button-help:not(:disabled):hover {\n    background: ").concat(dt2("button.help.hover.background"), ";\n    border: 1px solid ").concat(dt2("button.help.hover.border.color"), ";\n    color: ").concat(dt2("button.help.hover.color"), ";\n}\n\n.p-button-help:not(:disabled):active {\n    background: ").concat(dt2("button.help.active.background"), ";\n    border: 1px solid ").concat(dt2("button.help.active.border.color"), ";\n    color: ").concat(dt2("button.help.active.color"), ";\n}\n\n.p-button-help:focus-visible {\n    outline-color: ").concat(dt2("button.help.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("button.help.focus.ring.shadow"), ";\n}\n\n.p-button-danger {\n    background: ").concat(dt2("button.danger.background"), ";\n    border: 1px solid ").concat(dt2("button.danger.border.color"), ";\n    color: ").concat(dt2("button.danger.color"), ";\n}\n\n.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt2("button.danger.hover.background"), ";\n    border: 1px solid ").concat(dt2("button.danger.hover.border.color"), ";\n    color: ").concat(dt2("button.danger.hover.color"), ";\n}\n\n.p-button-danger:not(:disabled):active {\n    background: ").concat(dt2("button.danger.active.background"), ";\n    border: 1px solid ").concat(dt2("button.danger.active.border.color"), ";\n    color: ").concat(dt2("button.danger.active.color"), ";\n}\n\n.p-button-danger:focus-visible {\n    outline-color: ").concat(dt2("button.danger.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("button.danger.focus.ring.shadow"), ";\n}\n\n.p-button-contrast {\n    background: ").concat(dt2("button.contrast.background"), ";\n    border: 1px solid ").concat(dt2("button.contrast.border.color"), ";\n    color: ").concat(dt2("button.contrast.color"), ";\n}\n\n.p-button-contrast:not(:disabled):hover {\n    background: ").concat(dt2("button.contrast.hover.background"), ";\n    border: 1px solid ").concat(dt2("button.contrast.hover.border.color"), ";\n    color: ").concat(dt2("button.contrast.hover.color"), ";\n}\n\n.p-button-contrast:not(:disabled):active {\n    background: ").concat(dt2("button.contrast.active.background"), ";\n    border: 1px solid ").concat(dt2("button.contrast.active.border.color"), ";\n    color: ").concat(dt2("button.contrast.active.color"), ";\n}\n\n.p-button-contrast:focus-visible {\n    outline-color: ").concat(dt2("button.contrast.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("button.contrast.focus.ring.shadow"), ";\n}\n\n.p-button-outlined {\n    background: transparent;\n    border-color: ").concat(dt2("button.outlined.primary.border.color"), ";\n    color: ").concat(dt2("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.primary.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.primary.border.color"), ";\n    color: ").concat(dt2("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.primary.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.primary.border.color"), ";\n    color: ").concat(dt2("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary {\n    border-color: ").concat(dt2("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt2("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.secondary.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt2("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.secondary.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt2("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-success {\n    border-color: ").concat(dt2("button.outlined.success.border.color"), ";\n    color: ").concat(dt2("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-success:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.success.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.success.border.color"), ";\n    color: ").concat(dt2("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-success:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.success.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.success.border.color"), ";\n    color: ").concat(dt2("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-info {\n    border-color: ").concat(dt2("button.outlined.info.border.color"), ";\n    color: ").concat(dt2("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-info:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.info.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.info.border.color"), ";\n    color: ").concat(dt2("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-info:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.info.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.info.border.color"), ";\n    color: ").concat(dt2("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-warn {\n    border-color: ").concat(dt2("button.outlined.warn.border.color"), ";\n    color: ").concat(dt2("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.warn.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.warn.border.color"), ";\n    color: ").concat(dt2("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-warn:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.warn.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.warn.border.color"), ";\n    color: ").concat(dt2("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-help {\n    border-color: ").concat(dt2("button.outlined.help.border.color"), ";\n    color: ").concat(dt2("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-help:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.help.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.help.border.color"), ";\n    color: ").concat(dt2("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-help:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.help.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.help.border.color"), ";\n    color: ").concat(dt2("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-danger {\n    border-color: ").concat(dt2("button.outlined.danger.border.color"), ";\n    color: ").concat(dt2("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.danger.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.danger.border.color"), ";\n    color: ").concat(dt2("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-danger:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.danger.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.danger.border.color"), ";\n    color: ").concat(dt2("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-contrast {\n    border-color: ").concat(dt2("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt2("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-contrast:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.contrast.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt2("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-contrast:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.contrast.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt2("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-plain {\n    border-color: ").concat(dt2("button.outlined.plain.border.color"), ";\n    color: ").concat(dt2("button.outlined.plain.color"), ";\n}\n\n.p-button-outlined.p-button-plain:not(:disabled):hover {\n    background: ").concat(dt2("button.outlined.plain.hover.background"), ";\n    border-color: ").concat(dt2("button.outlined.plain.border.color"), ";\n    color: ").concat(dt2("button.outlined.plain.color"), ";\n}\n\n.p-button-outlined.p-button-plain:not(:disabled):active {\n    background: ").concat(dt2("button.outlined.plain.active.background"), ";\n    border-color: ").concat(dt2("button.outlined.plain.border.color"), ";\n    color: ").concat(dt2("button.outlined.plain.color"), ";\n}\n\n.p-button-text {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.text.primary.color"), ";\n}\n\n.p-button-text:not(:disabled):hover {\n    background: ").concat(dt2("button.text.primary.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.primary.color"), ";\n}\n\n.p-button-text:not(:disabled):active {\n    background: ").concat(dt2("button.text.primary.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.primary.color"), ";\n}\n\n.p-button-text.p-button-secondary {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt2("button.text.secondary.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt2("button.text.secondary.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-success {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-success:not(:disabled):hover {\n    background: ").concat(dt2("button.text.success.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-success:not(:disabled):active {\n    background: ").concat(dt2("button.text.success.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-info {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-info:not(:disabled):hover {\n    background: ").concat(dt2("button.text.info.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-info:not(:disabled):active {\n    background: ").concat(dt2("button.text.info.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-warn {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt2("button.text.warn.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-warn:not(:disabled):active {\n    background: ").concat(dt2("button.text.warn.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-help {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-help:not(:disabled):hover {\n    background: ").concat(dt2("button.text.help.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-help:not(:disabled):active {\n    background: ").concat(dt2("button.text.help.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-danger {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt2("button.text.danger.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-danger:not(:disabled):active {\n    background: ").concat(dt2("button.text.danger.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-plain {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.text.plain.color"), ";\n}\n\n.p-button-text.p-button-plain:not(:disabled):hover {\n    background: ").concat(dt2("button.text.plain.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.plain.color"), ";\n}\n\n.p-button-text.p-button-plain:not(:disabled):active {\n    background: ").concat(dt2("button.text.plain.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt2("button.text.plain.color"), ";\n}\n\n.p-button-link {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.link.color"), ";\n}\n\n.p-button-link:not(:disabled):hover {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.link.hover.color"), ";\n}\n\n.p-button-link:not(:disabled):hover .p-button-label {\n    text-decoration: underline;\n}\n\n.p-button-link:not(:disabled):active {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt2("button.link.active.color"), ";\n}\n");
}, "theme");
var classes$u = {
  root: /* @__PURE__ */ __name(function root4(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-button p-component", _defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c(_defineProperty$c({
      "p-button-icon-only": instance.hasIcon && !props.label && !props.badge,
      "p-button-vertical": (props.iconPos === "top" || props.iconPos === "bottom") && props.label,
      "p-button-loading": props.loading,
      "p-button-link": props.link
    }, "p-button-".concat(props.severity), props.severity), "p-button-raised", props.raised), "p-button-rounded", props.rounded), "p-button-text", props.text), "p-button-outlined", props.outlined), "p-button-sm", props.size === "small"), "p-button-lg", props.size === "large"), "p-button-plain", props.plain), "p-button-fluid", instance.hasFluid)];
  }, "root"),
  loadingIcon: "p-button-loading-icon",
  icon: /* @__PURE__ */ __name(function icon(_ref4) {
    var props = _ref4.props;
    return ["p-button-icon", _defineProperty$c({}, "p-button-icon-".concat(props.iconPos), props.label)];
  }, "icon"),
  label: "p-button-label"
};
var ButtonStyle = BaseStyle.extend({
  name: "button",
  theme: theme$s,
  classes: classes$u
});
var script$1$t = {
  name: "BaseButton",
  "extends": script$Y,
  props: {
    label: {
      type: String,
      "default": null
    },
    icon: {
      type: String,
      "default": null
    },
    iconPos: {
      type: String,
      "default": "left"
    },
    iconClass: {
      type: String,
      "default": null
    },
    badge: {
      type: String,
      "default": null
    },
    badgeClass: {
      type: String,
      "default": null
    },
    badgeSeverity: {
      type: String,
      "default": "secondary"
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    as: {
      type: [String, Object],
      "default": "BUTTON"
    },
    asChild: {
      type: Boolean,
      "default": false
    },
    link: {
      type: Boolean,
      "default": false
    },
    severity: {
      type: String,
      "default": null
    },
    raised: {
      type: Boolean,
      "default": false
    },
    rounded: {
      type: Boolean,
      "default": false
    },
    text: {
      type: Boolean,
      "default": false
    },
    outlined: {
      type: Boolean,
      "default": false
    },
    size: {
      type: String,
      "default": null
    },
    plain: {
      type: Boolean,
      "default": false
    },
    fluid: {
      type: Boolean,
      "default": null
    }
  },
  style: ButtonStyle,
  provide: /* @__PURE__ */ __name(function provide9() {
    return {
      $pcButton: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$M = {
  name: "Button",
  "extends": script$1$t,
  inheritAttrs: false,
  inject: {
    $pcFluid: {
      "default": null
    }
  },
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions3(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          disabled: this.disabled
        }
      });
    }, "getPTOptions")
  },
  computed: {
    disabled: /* @__PURE__ */ __name(function disabled() {
      return this.$attrs.disabled || this.$attrs.disabled === "" || this.loading;
    }, "disabled"),
    defaultAriaLabel: /* @__PURE__ */ __name(function defaultAriaLabel() {
      return this.label ? this.label + (this.badge ? " " + this.badge : "") : this.$attrs.ariaLabel;
    }, "defaultAriaLabel"),
    hasIcon: /* @__PURE__ */ __name(function hasIcon() {
      return this.icon || this.$slots.icon;
    }, "hasIcon"),
    attrs: /* @__PURE__ */ __name(function attrs() {
      return mergeProps(this.asAttrs, this.a11yAttrs, this.getPTOptions("root"));
    }, "attrs"),
    asAttrs: /* @__PURE__ */ __name(function asAttrs() {
      return this.as === "BUTTON" ? {
        type: "button",
        disabled: this.disabled
      } : void 0;
    }, "asAttrs"),
    a11yAttrs: /* @__PURE__ */ __name(function a11yAttrs() {
      return {
        "aria-label": this.defaultAriaLabel,
        "data-pc-name": "button",
        "data-p-disabled": this.disabled,
        "data-p-severity": this.severity
      };
    }, "a11yAttrs"),
    hasFluid: /* @__PURE__ */ __name(function hasFluid2() {
      return isEmpty(this.fluid) ? !!this.$pcFluid : this.fluid;
    }, "hasFluid")
  },
  components: {
    SpinnerIcon: script$Q,
    Badge: script$N
  },
  directives: {
    ripple: Ripple
  }
};
function render$L(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_Badge = resolveComponent("Badge");
  var _directive_ripple = resolveDirective("ripple");
  return !_ctx.asChild ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.as), mergeProps({
    key: 0,
    "class": _ctx.cx("root")
  }, $options.attrs), {
    "default": withCtx(function() {
      return [renderSlot(_ctx.$slots, "default", {}, function() {
        return [_ctx.loading ? renderSlot(_ctx.$slots, "loadingicon", {
          key: 0,
          "class": normalizeClass([_ctx.cx("loadingIcon"), _ctx.cx("icon")])
        }, function() {
          return [_ctx.loadingIcon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon"), _ctx.loadingIcon]
          }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
            key: 1,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon")],
            spin: ""
          }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
        }) : renderSlot(_ctx.$slots, "icon", {
          key: 1,
          "class": normalizeClass([_ctx.cx("icon")])
        }, function() {
          return [_ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("icon"), _ctx.icon, _ctx.iconClass]
          }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true)];
        }), createBaseVNode("span", mergeProps({
          "class": _ctx.cx("label")
        }, _ctx.ptm("label")), toDisplayString$1(_ctx.label || ""), 17), _ctx.badge ? (openBlock(), createBlock(_component_Badge, mergeProps({
          key: 2,
          value: _ctx.badge,
          "class": _ctx.badgeClass,
          severity: _ctx.badgeSeverity,
          unstyled: _ctx.unstyled
        }, _ctx.ptm("pcBadge")), null, 16, ["value", "class", "severity", "unstyled"])) : createCommentVNode("", true)];
      })];
    }),
    _: 3
  }, 16, ["class"])), [[_directive_ripple]]) : renderSlot(_ctx.$slots, "default", {
    key: 1,
    "class": normalizeClass(_ctx.cx("root")),
    a11yAttrs: $options.a11yAttrs
  });
}
__name(render$L, "render$L");
script$M.render = render$L;
var theme$r = /* @__PURE__ */ __name(function theme10(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-card {\n    background: ".concat(dt2("card.background"), ";\n    color: ").concat(dt2("card.color"), ";\n    box-shadow: ").concat(dt2("card.shadow"), ";\n    border-radius: ").concat(dt2("card.border.radius"), ";\n    display: flex;\n    flex-direction: column;\n}\n\n.p-card-caption {\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt2("card.caption.gap"), ";\n}\n\n.p-card-body {\n    padding: ").concat(dt2("card.body.padding"), ";\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt2("card.body.gap"), ";\n}\n\n.p-card-title {\n    font-size: ").concat(dt2("card.title.font.size"), ";\n    font-weight: ").concat(dt2("card.title.font.weight"), ";\n}\n\n.p-card-subtitle {\n    color: ").concat(dt2("card.subtitle.color"), ";\n}\n");
}, "theme");
var classes$t = {
  root: "p-card p-component",
  header: "p-card-header",
  body: "p-card-body",
  caption: "p-card-caption",
  title: "p-card-title",
  subtitle: "p-card-subtitle",
  content: "p-card-content",
  footer: "p-card-footer"
};
var CardStyle = BaseStyle.extend({
  name: "card",
  theme: theme$r,
  classes: classes$t
});
var script$1$s = {
  name: "BaseCard",
  "extends": script$Y,
  style: CardStyle,
  provide: /* @__PURE__ */ __name(function provide10() {
    return {
      $pcCard: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$L = {
  name: "Card",
  "extends": script$1$s,
  inheritAttrs: false
};
function render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.$slots.header ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("header")
  }, _ctx.ptm("header")), [renderSlot(_ctx.$slots, "header")], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("body")
  }, _ctx.ptm("body")), [_ctx.$slots.title || _ctx.$slots.subtitle ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("caption")
  }, _ctx.ptm("caption")), [_ctx.$slots.title ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("title")
  }, _ctx.ptm("title")), [renderSlot(_ctx.$slots, "title")], 16)) : createCommentVNode("", true), _ctx.$slots.subtitle ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("subtitle")
  }, _ctx.ptm("subtitle")), [renderSlot(_ctx.$slots, "subtitle")], 16)) : createCommentVNode("", true)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("content")
  }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "content")], 16), _ctx.$slots.footer ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("footer")
  }, _ctx.ptm("footer")), [renderSlot(_ctx.$slots, "footer")], 16)) : createCommentVNode("", true)], 16)], 16);
}
__name(render$K, "render$K");
script$L.render = render$K;
const _withScopeId$l = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-a1e982e0"), n = n(), popScopeId(), n), "_withScopeId$l");
const _hoisted_1$18 = { class: "flex flex-col items-center" };
const _hoisted_2$S = { class: "whitespace-pre-line text-center" };
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "NoResultsPlaceholder",
  props: {
    class: {},
    icon: {},
    title: {},
    message: {},
    buttonLabel: {}
  },
  emits: ["action"],
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["no-results-placeholder p-8 h-full", props.class])
      }, [
        createVNode(unref(script$L), null, {
          content: withCtx(() => [
            createBaseVNode("div", _hoisted_1$18, [
              createBaseVNode("i", {
                class: normalizeClass(_ctx.icon),
                style: { "font-size": "3rem", "margin-bottom": "1rem" }
              }, null, 2),
              createBaseVNode("h3", null, toDisplayString$1(_ctx.title), 1),
              createBaseVNode("p", _hoisted_2$S, toDisplayString$1(_ctx.message), 1),
              _ctx.buttonLabel ? (openBlock(), createBlock(unref(script$M), {
                key: 0,
                label: _ctx.buttonLabel,
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("action")),
                class: "p-button-text"
              }, null, 8, ["label"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        })
      ], 2);
    };
  }
});
const _export_sfc = /* @__PURE__ */ __name((sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
}, "_export_sfc");
const NoResultsPlaceholder = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__scopeId", "data-v-a1e982e0"]]);
const _withScopeId$k = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-05a7c5eb"), n = n(), popScopeId(), n), "_withScopeId$k");
const _hoisted_1$17 = { class: "flex align-items-center" };
const _hoisted_2$R = { class: "node-type" };
const _hoisted_3$s = {
  key: 0,
  class: "node-hint"
};
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "LoadWorkflowWarning",
  props: {
    missingNodeTypes: {}
  },
  setup(__props) {
    const props = __props;
    const uniqueNodes = computed(() => {
      const seenTypes = /* @__PURE__ */ new Set();
      return props.missingNodeTypes.filter((node3) => {
        const type = typeof node3 === "object" ? node3.type : node3;
        if (seenTypes.has(type)) return false;
        seenTypes.add(type);
        return true;
      }).map((node3) => {
        if (typeof node3 === "object") {
          return {
            label: node3.type,
            hint: node3.hint,
            action: node3.action
          };
        }
        return { label: node3 };
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(NoResultsPlaceholder, {
          class: "pb-0",
          icon: "pi pi-exclamation-circle",
          title: "Missing Node Types",
          message: "When loading the graph, the following node types were not found"
        }),
        createVNode(unref(script$O), {
          options: uniqueNodes.value,
          optionLabel: "label",
          scrollHeight: "100%",
          class: "comfy-missing-nodes",
          pt: {
            list: { class: "border-none" }
          }
        }, {
          option: withCtx((slotProps) => [
            createBaseVNode("div", _hoisted_1$17, [
              createBaseVNode("span", _hoisted_2$R, toDisplayString$1(slotProps.option.label), 1),
              slotProps.option.hint ? (openBlock(), createElementBlock("span", _hoisted_3$s, toDisplayString$1(slotProps.option.hint), 1)) : createCommentVNode("", true),
              slotProps.option.action ? (openBlock(), createBlock(unref(script$M), {
                key: 1,
                onClick: slotProps.option.action.callback,
                label: slotProps.option.action.text,
                size: "small",
                outlined: ""
              }, null, 8, ["onClick", "label"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 8, ["options"])
      ], 64);
    };
  }
});
const LoadWorkflowWarning = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__scopeId", "data-v-05a7c5eb"]]);
function useDownload(url, fileName) {
  const fileSize = ref(null);
  const fetchFileSize = /* @__PURE__ */ __name(async () => {
    try {
      const response = await fetch(url, { method: "HEAD" });
      if (!response.ok) throw new Error("Failed to fetch file size");
      const size2 = response.headers.get("content-length");
      if (size2) {
        return parseInt(size2);
      } else {
        console.error('"content-length" header not found');
        return null;
      }
    } catch (e) {
      console.error("Error fetching file size:", e);
      return null;
    }
  }, "fetchFileSize");
  const triggerBrowserDownload = /* @__PURE__ */ __name(() => {
    const link = document.createElement("a");
    link.href = url;
    link.download = fileName || url.split("/").pop() || "download";
    link.target = "_blank";
    link.rel = "noopener noreferrer";
    link.click();
  }, "triggerBrowserDownload");
  onMounted(async () => {
    fileSize.value = await fetchFileSize();
  });
  return {
    triggerBrowserDownload,
    fileSize
  };
}
__name(useDownload, "useDownload");
var theme$q = /* @__PURE__ */ __name(function theme11(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-progressbar {\n    position: relative;\n    overflow: hidden;\n    height: ".concat(dt2("progressbar.height"), ";\n    background: ").concat(dt2("progressbar.background"), ";\n    border-radius: ").concat(dt2("progressbar.border.radius"), ";\n}\n\n.p-progressbar-value {\n    margin: 0;\n    background: ").concat(dt2("progressbar.value.background"), ";\n}\n\n.p-progressbar-label {\n    color: ").concat(dt2("progressbar.label.color"), ";\n    font-size: ").concat(dt2("progressbar.label.font.size"), ";\n    font-weight: ").concat(dt2("progressbar.label.font.weight"), ';\n}\n\n.p-progressbar-determinate .p-progressbar-value {\n    height: 100%;\n    width: 0%;\n    position: absolute;\n    display: none;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    transition: width 1s ease-in-out;\n}\n\n.p-progressbar-determinate .p-progressbar-label {\n    display: inline-flex;\n}\n\n.p-progressbar-indeterminate .p-progressbar-value::before {\n    content: "";\n    position: absolute;\n    background: inherit;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    will-change: left, right;\n    animation: p-progressbar-indeterminate-anim 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;\n}\n\n.p-progressbar-indeterminate .p-progressbar-value::after {\n    content: "";\n    position: absolute;\n    background: inherit;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    will-change: left, right;\n    animation: p-progressbar-indeterminate-anim-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;\n    animation-delay: 1.15s;\n}\n\n@-webkit-keyframes p-progressbar-indeterminate-anim {\n    0% {\n        left: -35%;\n        right: 100%;\n    }\n    60% {\n        left: 100%;\n        right: -90%;\n    }\n    100% {\n        left: 100%;\n        right: -90%;\n    }\n}\n@keyframes p-progressbar-indeterminate-anim {\n    0% {\n        left: -35%;\n        right: 100%;\n    }\n    60% {\n        left: 100%;\n        right: -90%;\n    }\n    100% {\n        left: 100%;\n        right: -90%;\n    }\n}\n@-webkit-keyframes p-progressbar-indeterminate-anim-short {\n    0% {\n        left: -200%;\n        right: 100%;\n    }\n    60% {\n        left: 107%;\n        right: -8%;\n    }\n    100% {\n        left: 107%;\n        right: -8%;\n    }\n}\n@keyframes p-progressbar-indeterminate-anim-short {\n    0% {\n        left: -200%;\n        right: 100%;\n    }\n    60% {\n        left: 107%;\n        right: -8%;\n    }\n    100% {\n        left: 107%;\n        right: -8%;\n    }\n}\n');
}, "theme");
var classes$s = {
  root: /* @__PURE__ */ __name(function root5(_ref2) {
    var instance = _ref2.instance;
    return ["p-progressbar p-component", {
      "p-progressbar-determinate": instance.determinate,
      "p-progressbar-indeterminate": instance.indeterminate
    }];
  }, "root"),
  value: "p-progressbar-value",
  label: "p-progressbar-label"
};
var ProgressBarStyle = BaseStyle.extend({
  name: "progressbar",
  theme: theme$q,
  classes: classes$s
});
var script$1$r = {
  name: "BaseProgressBar",
  "extends": script$Y,
  props: {
    value: {
      type: Number,
      "default": null
    },
    mode: {
      type: String,
      "default": "determinate"
    },
    showValue: {
      type: Boolean,
      "default": true
    }
  },
  style: ProgressBarStyle,
  provide: /* @__PURE__ */ __name(function provide11() {
    return {
      $pcProgressBar: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$K = {
  name: "ProgressBar",
  "extends": script$1$r,
  inheritAttrs: false,
  computed: {
    progressStyle: /* @__PURE__ */ __name(function progressStyle() {
      return {
        width: this.value + "%",
        display: "flex"
      };
    }, "progressStyle"),
    indeterminate: /* @__PURE__ */ __name(function indeterminate() {
      return this.mode === "indeterminate";
    }, "indeterminate"),
    determinate: /* @__PURE__ */ __name(function determinate() {
      return this.mode === "determinate";
    }, "determinate")
  }
};
var _hoisted_1$16 = ["aria-valuenow"];
function render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    role: "progressbar",
    "class": _ctx.cx("root"),
    "aria-valuemin": "0",
    "aria-valuenow": _ctx.value,
    "aria-valuemax": "100"
  }, _ctx.ptmi("root")), [$options.determinate ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("value"),
    style: $options.progressStyle
  }, _ctx.ptm("value")), [_ctx.value != null && _ctx.value !== 0 && _ctx.showValue ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("label")
  }, _ctx.ptm("label")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [createTextVNode(toDisplayString$1(_ctx.value + "%"), 1)];
  })], 16)) : createCommentVNode("", true)], 16)) : $options.indeterminate ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("value")
  }, _ctx.ptm("value")), null, 16)) : createCommentVNode("", true)], 16, _hoisted_1$16);
}
__name(render$J, "render$J");
script$K.render = render$J;
function formatCamelCase(str) {
  const isCamelCase = /^([A-Z][a-z]*)+$/.test(str);
  if (!isCamelCase) {
    return str;
  }
  const words = str.split(/(?=[A-Z][a-z])|\d+/);
  const processedWords = words.map((word) => {
    if (word.length > 1 && word === word.toUpperCase()) {
      return word;
    }
    return word.charAt(0).toUpperCase() + word.slice(1);
  });
  return processedWords.join(" ");
}
__name(formatCamelCase, "formatCamelCase");
function appendJsonExt(path) {
  if (!path.toLowerCase().endsWith(".json")) {
    path += ".json";
  }
  return path;
}
__name(appendJsonExt, "appendJsonExt");
function trimJsonExt(path) {
  return path?.replace(/\.json$/, "");
}
__name(trimJsonExt, "trimJsonExt");
function highlightQuery(text, query) {
  if (!query) return text;
  const regex = new RegExp(`(${query})`, "gi");
  return text.replace(regex, '<span class="highlight">$1</span>');
}
__name(highlightQuery, "highlightQuery");
function formatNumberWithSuffix(num, {
  precision = 1,
  roundToInt = false
} = {}) {
  const suffixes = ["", "k", "m", "b", "t"];
  const absNum = Math.abs(num);
  if (absNum < 1e3) {
    return roundToInt ? Math.round(num).toString() : num.toFixed(precision);
  }
  const exp = Math.min(Math.floor(Math.log10(absNum) / 3), suffixes.length - 1);
  const formattedNum = (num / Math.pow(1e3, exp)).toFixed(precision);
  return `${formattedNum}${suffixes[exp]}`;
}
__name(formatNumberWithSuffix, "formatNumberWithSuffix");
function formatSize(value3) {
  if (value3 === null || value3 === void 0) {
    return "-";
  }
  const bytes = value3;
  if (bytes === 0) return "0 B";
  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB"];
  const i2 = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i2)).toFixed(2))} ${sizes[i2]}`;
}
__name(formatSize, "formatSize");
function findCommonPrefix(path1, path2) {
  const parts1 = path1.split("/");
  const parts2 = path2.split("/");
  const commonParts = [];
  for (let i2 = 0; i2 < Math.min(parts1.length, parts2.length); i2++) {
    if (parts1[i2] === parts2[i2]) {
      commonParts.push(parts1[i2]);
    } else {
      break;
    }
  }
  return commonParts.join("/");
}
__name(findCommonPrefix, "findCommonPrefix");
function getFilenameDetails(fullFilename) {
  if (fullFilename.includes(".")) {
    return {
      filename: fullFilename.split(".").slice(0, -1).join("."),
      suffix: fullFilename.split(".").pop() ?? null
    };
  } else {
    return { filename: fullFilename, suffix: null };
  }
}
__name(getFilenameDetails, "getFilenameDetails");
function getPathDetails(path) {
  const directory = path.split("/").slice(0, -1).join("/");
  const fullFilename = path.split("/").pop() ?? path;
  return { directory, fullFilename, ...getFilenameDetails(fullFilename) };
}
__name(getPathDetails, "getPathDetails");
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
let mark;
let measure;
if (false) {
  const perf2 = inBrowser && window.performance;
  if (perf2 && perf2.mark && perf2.measure && perf2.clearMarks && // @ts-ignore browser compat
  perf2.clearMeasures) {
    mark = /* @__PURE__ */ __name((tag) => {
      perf2.mark(tag);
    }, "mark");
    measure = /* @__PURE__ */ __name((name, startTag, endTag) => {
      perf2.measure(name, startTag, endTag);
      perf2.clearMarks(startTag);
      perf2.clearMarks(endTag);
    }, "measure");
  }
}
const RE_ARGS$1 = /\{([0-9a-zA-Z]+)\}/g;
function format$4(message2, ...args) {
  if (args.length === 1 && isObject$3(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message2.replace(RE_ARGS$1, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
__name(format$4, "format$4");
const makeSymbol = /* @__PURE__ */ __name((name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name), "makeSymbol");
const generateFormatCacheKey = /* @__PURE__ */ __name((locale2, key, source) => friendlyJSONstringify({ l: locale2, k: key, s: source }), "generateFormatCacheKey");
const friendlyJSONstringify = /* @__PURE__ */ __name((json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), "friendlyJSONstringify");
const isNumber$1 = /* @__PURE__ */ __name((val) => typeof val === "number" && isFinite(val), "isNumber$1");
const isDate = /* @__PURE__ */ __name((val) => toTypeString(val) === "[object Date]", "isDate");
const isRegExp = /* @__PURE__ */ __name((val) => toTypeString(val) === "[object RegExp]", "isRegExp");
const isEmptyObject = /* @__PURE__ */ __name((val) => isPlainObject(val) && Object.keys(val).length === 0, "isEmptyObject");
const assign$2 = Object.assign;
let _globalThis;
const getGlobalThis = /* @__PURE__ */ __name(() => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
}, "getGlobalThis");
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
__name(escapeHtml, "escapeHtml");
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn$2(obj, key) {
  return hasOwnProperty.call(obj, key);
}
__name(hasOwn$2, "hasOwn$2");
const isArray$2 = Array.isArray;
const isFunction = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction");
const isString$2 = /* @__PURE__ */ __name((val) => typeof val === "string", "isString$2");
const isBoolean$1 = /* @__PURE__ */ __name((val) => typeof val === "boolean", "isBoolean$1");
const isSymbol = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol");
const isObject$3 = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object", "isObject$3");
const isPromise = /* @__PURE__ */ __name((val) => {
  return isObject$3(val) && isFunction(val.then) && isFunction(val.catch);
}, "isPromise");
const objectToString = Object.prototype.toString;
const toTypeString = /* @__PURE__ */ __name((value3) => objectToString.call(value3), "toTypeString");
const isPlainObject = /* @__PURE__ */ __name((val) => {
  if (!isObject$3(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
}, "isPlainObject");
const toDisplayString = /* @__PURE__ */ __name((val) => {
  return val == null ? "" : isArray$2(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
}, "toDisplayString");
function join$1(items2, separator = "") {
  return items2.reduce((str, item2, index2) => index2 === 0 ? str + item2 : str + separator + item2, "");
}
__name(join$1, "join$1");
const RANGE = 2;
function generateCodeFrame(source, start2 = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];
  for (let i2 = 0; i2 < lines.length; i2++) {
    count += lines[i2].length + 1;
    if (count >= start2) {
      for (let j = i2 - RANGE; j <= i2 + RANGE || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        if (j === i2) {
          const pad = start2 - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad : end - start2);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i2) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
__name(generateCodeFrame, "generateCodeFrame");
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
__name(incrementer, "incrementer");
function warn$1(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
__name(warn$1, "warn$1");
const hasWarned = {};
function warnOnce(msg) {
  if (!hasWarned[msg]) {
    hasWarned[msg] = true;
    warn$1(msg);
  }
}
__name(warnOnce, "warnOnce");
function createEmitter() {
  const events2 = /* @__PURE__ */ new Map();
  const emitter = {
    events: events2,
    on(event2, handler6) {
      const handlers2 = events2.get(event2);
      const added = handlers2 && handlers2.push(handler6);
      if (!added) {
        events2.set(event2, [handler6]);
      }
    },
    off(event2, handler6) {
      const handlers2 = events2.get(event2);
      if (handlers2) {
        handlers2.splice(handlers2.indexOf(handler6) >>> 0, 1);
      }
    },
    emit(event2, payload) {
      (events2.get(event2) || []).slice().map((handler6) => handler6(payload));
      (events2.get("*") || []).slice().map((handler6) => handler6(event2, payload));
    }
  };
  return emitter;
}
__name(createEmitter, "createEmitter");
const isNotObjectOrIsArray = /* @__PURE__ */ __name((val) => !isObject$3(val) || isArray$2(val), "isNotObjectOrIsArray");
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack2 = [{ src, des }];
  while (stack2.length) {
    const { src: src2, des: des2 } = stack2.pop();
    Object.keys(src2).forEach((key) => {
      if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
        des2[key] = src2[key];
      } else {
        stack2.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
__name(deepCopy, "deepCopy");
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const LOCATION_STUB = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function createPosition(line, column, offset) {
  return { line, column, offset };
}
__name(createPosition, "createPosition");
function createLocation(start2, end, source) {
  const loc = { start: start2, end };
  if (source != null) {
    loc.source = source;
  }
  return loc;
}
__name(createLocation, "createLocation");
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$3(message2, ...args) {
  if (args.length === 1 && isObject$2(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message2.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
__name(format$3, "format$3");
const assign$1 = Object.assign;
const isString$1 = /* @__PURE__ */ __name((val) => typeof val === "string", "isString$1");
const isObject$2 = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object", "isObject$2");
function join(items2, separator = "") {
  return items2.reduce((str, item2, index2) => index2 === 0 ? str + item2 : str + separator + item2, "");
}
__name(join, "join");
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages$2 = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
  const msg = format$3(warnMessages$2[code2] || "", ...args || []);
  const message2 = { message: String(msg), code: code2 };
  if (loc) {
    message2.location = loc;
  }
  return message2;
}
__name(createCompileWarn, "createCompileWarn");
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages$2 = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options3 = {}) {
  const { domain, messages: messages2, args } = options3;
  const msg = format$3((messages2 || errorMessages$2)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
__name(createCompileError, "createCompileError");
function defaultOnError(error) {
  throw error;
}
__name(defaultOnError, "defaultOnError");
const RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
const detectHtmlTag = /* @__PURE__ */ __name((source) => RE_HTML_TAG.test(source), "detectHtmlTag");
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = /* @__PURE__ */ __name((index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF, "isCRLF");
  const isLF = /* @__PURE__ */ __name((index3) => _buf[index3] === CHAR_LF, "isLF");
  const isPS = /* @__PURE__ */ __name((index3) => _buf[index3] === CHAR_PS, "isPS");
  const isLS = /* @__PURE__ */ __name((index3) => _buf[index3] === CHAR_LS, "isLS");
  const isLineEnd = /* @__PURE__ */ __name((index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3), "isLineEnd");
  const index2 = /* @__PURE__ */ __name(() => _index, "index");
  const line = /* @__PURE__ */ __name(() => _line, "line");
  const column = /* @__PURE__ */ __name(() => _column, "column");
  const peekOffset = /* @__PURE__ */ __name(() => _peekOffset, "peekOffset");
  const charAt = /* @__PURE__ */ __name((offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset], "charAt");
  const currentChar = /* @__PURE__ */ __name(() => charAt(_index), "currentChar");
  const currentPeek = /* @__PURE__ */ __name(() => charAt(_index + _peekOffset), "currentPeek");
  function next2() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  __name(next2, "next");
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  __name(peek, "peek");
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  __name(reset, "reset");
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  __name(resetPeek, "resetPeek");
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next2();
    }
    _peekOffset = 0;
  }
  __name(skipToPeek, "skipToPeek");
  return {
    index: index2,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next: next2,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
__name(createScanner, "createScanner");
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options3 = {}) {
  const location2 = options3.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = /* @__PURE__ */ __name(() => _scnr.index(), "currentOffset");
  const currentPosition = /* @__PURE__ */ __name(() => createPosition(_scnr.line(), _scnr.column(), _scnr.index()), "currentPosition");
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = /* @__PURE__ */ __name(() => _context, "context");
  const { onError } = options3;
  function emitError(code2, pos2, offset, ...args) {
    const ctx = context();
    pos2.column += offset;
    pos2.offset += offset;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos2) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  __name(emitError, "emitError");
  function getToken(context2, type, value3) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location2) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value3 != null) {
      token.value = value3;
    }
    return token;
  }
  __name(getToken, "getToken");
  const getEndToken = /* @__PURE__ */ __name((context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  ), "getEndToken");
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  __name(eat, "eat");
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  __name(peekSpaces, "peekSpaces");
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  __name(skipSpaces, "skipSpaces");
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  __name(isIdentifierStart, "isIdentifierStart");
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  __name(isNumberStart, "isNumberStart");
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  __name(isNamedIdentifierStart, "isNamedIdentifierStart");
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  __name(isListIdentifierStart, "isListIdentifierStart");
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  __name(isLiteralStart, "isLiteralStart");
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  __name(isLinkedDotStart, "isLinkedDotStart");
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  __name(isLinkedModifierStart, "isLinkedModifierStart");
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  __name(isLinkedDelimiterStart, "isLinkedDelimiterStart");
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = /* @__PURE__ */ __name(() => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    }, "fn");
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  __name(isLinkedReferStart, "isLinkedReferStart");
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  __name(isPluralStart, "isPluralStart");
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  __name(detectModuloStart, "detectModuloStart");
  function isTextStart(scnr, reset = true) {
    const fn = /* @__PURE__ */ __name((hasSpace = false, prev2 = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev2 === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev2 === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev2 === "%" || detectModulo ? true : !(prev2 === CHAR_SP || prev2 === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    }, "fn");
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  __name(isTextStart, "isTextStart");
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  __name(takeChar, "takeChar");
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  __name(isIdentifier, "isIdentifier");
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  __name(takeIdentifierChar, "takeIdentifierChar");
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  __name(isNamedIdentifier, "isNamedIdentifier");
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  __name(takeNamedIdentifierChar, "takeNamedIdentifierChar");
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  __name(isDigit, "isDigit");
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  __name(takeDigit, "takeDigit");
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  __name(isHexDigit, "isHexDigit");
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  __name(takeHexDigit, "takeHexDigit");
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  __name(getDigits, "getDigits");
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  __name(readModulo, "readModulo");
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  __name(readText, "readText");
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  __name(readNamedIdentifier, "readNamedIdentifier");
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value3 = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value3 += `-${getDigits(scnr)}`;
    } else {
      value3 += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value3;
  }
  __name(readListIdentifier, "readListIdentifier");
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  __name(isLiteral2, "isLiteral");
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  __name(readLiteral, "readLiteral");
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  __name(readEscapeSequence, "readEscapeSequence");
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i2 = 0; i2 < digits; i2++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  __name(readUnicodeEscapeSequence, "readUnicodeEscapeSequence");
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  __name(isInvalidIdentifier, "isInvalidIdentifier");
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  __name(readInvalidIdentifier, "readInvalidIdentifier");
  function readLinkedModifier(scnr) {
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    return name;
  }
  __name(readLinkedModifier, "readLinkedModifier");
  function readLinkedRefer(scnr) {
    const fn = /* @__PURE__ */ __name((buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(buf);
      }
    }, "fn");
    return fn("");
  }
  __name(readLinkedRefer, "readLinkedRefer");
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  __name(readPlural, "readPlural");
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  __name(readTokenInPlaceholder, "readTokenInPlaceholder");
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  __name(readTokenInLinked, "readTokenInLinked");
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  __name(readToken, "readToken");
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  __name(nextToken, "nextToken");
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
__name(createTokenizer, "createTokenizer");
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
__name(fromEscapeSequence, "fromEscapeSequence");
function createParser(options3 = {}) {
  const location2 = options3.location !== false;
  const { onError, onWarn } = options3;
  function emitError(tokenzer, code2, start2, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location2 ? createLocation(start2, end) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  __name(emitError, "emitError");
  function emitWarn(tokenzer, code2, start2, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onWarn) {
      const loc = location2 ? createLocation(start2, end) : null;
      onWarn(createCompileWarn(code2, loc, args));
    }
  }
  __name(emitWarn, "emitWarn");
  function startNode(type, offset, loc) {
    const node3 = { type };
    if (location2) {
      node3.start = offset;
      node3.end = offset;
      node3.loc = { start: loc, end: loc };
    }
    return node3;
  }
  __name(startNode, "startNode");
  function endNode(node3, offset, pos2, type) {
    if (type) {
      node3.type = type;
    }
    if (location2) {
      node3.end = offset;
      if (node3.loc) {
        node3.loc.end = pos2;
      }
    }
  }
  __name(endNode, "endNode");
  function parseText(tokenizer, value3) {
    const context = tokenizer.context();
    const node3 = startNode(3, context.offset, context.startLoc);
    node3.value = value3;
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseText, "parseText");
  function parseList(tokenizer, index2) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(5, offset, loc);
    node3.index = parseInt(index2, 10);
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseList, "parseList");
  function parseNamed(tokenizer, key, modulo) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(4, offset, loc);
    node3.key = key;
    if (modulo === true) {
      node3.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseNamed, "parseNamed");
  function parseLiteral(tokenizer, value3) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(9, offset, loc);
    node3.value = value3.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseLiteral, "parseLiteral");
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node3.value = "";
      endNode(node3, offset, loc);
      return {
        nextConsumeToken: token,
        node: node3
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node3.value = token.value || "";
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: node3
    };
  }
  __name(parseLinkedModifier, "parseLinkedModifier");
  function parseLinkedKey(tokenizer, value3) {
    const context = tokenizer.context();
    const node3 = startNode(7, context.offset, context.startLoc);
    node3.value = value3;
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parseLinkedKey, "parseLinkedKey");
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  __name(parseLinked, "parseLinked");
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node3 = startNode(2, startOffset, startLoc);
    node3.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node3.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node3, endOffset, endLoc);
    return node3;
  }
  __name(parseMessage, "parseMessage");
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node3 = startNode(1, offset, loc);
    node3.cases = [];
    node3.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node3.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parsePlural, "parsePlural");
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  __name(parseResource, "parseResource");
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign$1({}, options3));
    const context = tokenizer.context();
    const node3 = startNode(0, context.offset, context.startLoc);
    if (location2 && node3.loc) {
      node3.loc.source = source;
    }
    node3.body = parseResource(tokenizer);
    if (options3.onCacheKey) {
      node3.cacheKey = options3.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  __name(parse2, "parse");
  return { parse: parse2 };
}
__name(createParser, "createParser");
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "" : name;
}
__name(getTokenCaption, "getTokenCaption");
function createTransformer(ast, options3 = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = /* @__PURE__ */ __name(() => _context, "context");
  const helper = /* @__PURE__ */ __name((name) => {
    _context.helpers.add(name);
    return name;
  }, "helper");
  return { context, helper };
}
__name(createTransformer, "createTransformer");
function traverseNodes(nodes, transformer) {
  for (let i2 = 0; i2 < nodes.length; i2++) {
    traverseNode(nodes[i2], transformer);
  }
}
__name(traverseNodes, "traverseNodes");
function traverseNode(node3, transformer) {
  switch (node3.type) {
    case 1:
      traverseNodes(node3.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node3.items, transformer);
      break;
    case 6: {
      const linked = node3;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
__name(traverseNode, "traverseNode");
function transform(ast, options3 = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
__name(transform, "transform");
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c) => optimizeMessageNode(c));
  }
  return ast;
}
__name(optimize, "optimize");
function optimizeMessageNode(message2) {
  if (message2.items.length === 1) {
    const item2 = message2.items[0];
    if (item2.type === 3 || item2.type === 9) {
      message2.static = item2.value;
      delete item2.value;
    }
  } else {
    const values2 = [];
    for (let i2 = 0; i2 < message2.items.length; i2++) {
      const item2 = message2.items[i2];
      if (!(item2.type === 3 || item2.type === 9)) {
        break;
      }
      if (item2.value == null) {
        break;
      }
      values2.push(item2.value);
    }
    if (values2.length === message2.items.length) {
      message2.static = join(values2);
      for (let i2 = 0; i2 < message2.items.length; i2++) {
        const item2 = message2.items[i2];
        if (item2.type === 3 || item2.type === 9) {
          delete item2.value;
        }
      }
    }
  }
}
__name(optimizeMessageNode, "optimizeMessageNode");
const ERROR_DOMAIN$1 = "minifier";
function minify(node3) {
  node3.t = node3.type;
  switch (node3.type) {
    case 0: {
      const resource = node3;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node3;
      const cases = plural.cases;
      for (let i2 = 0; i2 < cases.length; i2++) {
        minify(cases[i2]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message2 = node3;
      const items2 = message2.items;
      for (let i2 = 0; i2 < items2.length; i2++) {
        minify(items2[i2]);
      }
      message2.i = items2;
      delete message2.items;
      if (message2.static) {
        message2.s = message2.static;
        delete message2.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node3;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node3;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node3;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node3;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node3.type]
      });
    }
  }
  delete node3.type;
}
__name(minify, "minify");
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options3) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options3;
  const location2 = options3.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = /* @__PURE__ */ __name(() => _context, "context");
  function push(code2, node3) {
    _context.code += code2;
  }
  __name(push, "push");
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  __name(_newline, "_newline");
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  __name(indent, "indent");
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  __name(deindent, "deindent");
  function newline() {
    _newline(_context.indentLevel);
  }
  __name(newline, "newline");
  const helper = /* @__PURE__ */ __name((key) => `_${key}`, "helper");
  const needIndent = /* @__PURE__ */ __name(() => _context.needIndent, "needIndent");
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
__name(createCodeGenerator, "createCodeGenerator");
function generateLinkedNode(generator, node3) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node3.key);
  if (node3.modifier) {
    generator.push(`, `);
    generateNode(generator, node3.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
__name(generateLinkedNode, "generateLinkedNode");
function generateMessageNode(generator, node3) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node3.items.length;
  for (let i2 = 0; i2 < length; i2++) {
    generateNode(generator, node3.items[i2]);
    if (i2 === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
__name(generateMessageNode, "generateMessageNode");
function generatePluralNode(generator, node3) {
  const { helper, needIndent } = generator;
  if (node3.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node3.cases.length;
    for (let i2 = 0; i2 < length; i2++) {
      generateNode(generator, node3.cases[i2]);
      if (i2 === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
__name(generatePluralNode, "generatePluralNode");
function generateResource(generator, node3) {
  if (node3.body) {
    generateNode(generator, node3.body);
  } else {
    generator.push("null");
  }
}
__name(generateResource, "generateResource");
function generateNode(generator, node3) {
  const { helper } = generator;
  switch (node3.type) {
    case 0:
      generateResource(generator, node3);
      break;
    case 1:
      generatePluralNode(generator, node3);
      break;
    case 2:
      generateMessageNode(generator, node3);
      break;
    case 6:
      generateLinkedNode(generator, node3);
      break;
    case 8:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 7:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node3.index}))`, node3);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node3.key)}))`, node3);
      break;
    case 9:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 3:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node3.type]
      });
    }
  }
}
__name(generateNode, "generateNode");
const generate = /* @__PURE__ */ __name((ast, options3 = {}) => {
  const mode2 = isString$1(options3.mode) ? options3.mode : "normal";
  const filename = isString$1(options3.filename) ? options3.filename : "message.intl";
  const sourceMap = !!options3.sourceMap;
  const breakLineCode = options3.breakLineCode != null ? options3.breakLineCode : mode2 === "arrow" ? ";" : "\n";
  const needIndent = options3.needIndent ? options3.needIndent : mode2 !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode: mode2,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode2 === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code2, map: map2 } = generator.context();
  return {
    ast,
    code: code2,
    map: map2 ? map2.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
}, "generate");
function baseCompile$1(source, options3 = {}) {
  const assignedOptions = assign$1({}, options3);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
__name(baseCompile$1, "baseCompile$1");
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
__name(initFeatureFlags$1, "initFeatureFlags$1");
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
__name(isLiteral, "isLiteral");
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
__name(stripQuotes, "stripQuotes");
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
__name(getPathCharType, "getPathCharType");
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
__name(formatSubPath, "formatSubPath");
function parse$1(path) {
  const keys2 = [];
  let index2 = -1;
  let mode2 = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys2.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode2 = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode2 === 5 && nextChar === "'" || mode2 === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  __name(maybeUnescapeQuote, "maybeUnescapeQuote");
  while (mode2 !== null) {
    index2++;
    c = path[index2];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode2];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode2 = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode2 === 7) {
      return keys2;
    }
  }
}
__name(parse$1, "parse$1");
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$3(obj) ? obj[path] : null;
}
__name(resolveWithKeyValue, "resolveWithKeyValue");
function resolveValue(obj, path) {
  if (!isObject$3(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse$1(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i2 = 0;
  while (i2 < len) {
    const val = last[hit[i2]];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i2++;
  }
  return last;
}
__name(resolveValue, "resolveValue");
const DEFAULT_MODIFIER = /* @__PURE__ */ __name((str) => str, "DEFAULT_MODIFIER");
const DEFAULT_MESSAGE = /* @__PURE__ */ __name((ctx) => "", "DEFAULT_MESSAGE");
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = /* @__PURE__ */ __name((values2) => values2.length === 0 ? "" : join$1(values2), "DEFAULT_NORMALIZE");
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
__name(pluralDefault, "pluralDefault");
function getPluralIndex(options3) {
  const index2 = isNumber$1(options3.pluralIndex) ? options3.pluralIndex : -1;
  return options3.named && (isNumber$1(options3.named.count) || isNumber$1(options3.named.n)) ? isNumber$1(options3.named.count) ? options3.named.count : isNumber$1(options3.named.n) ? options3.named.n : index2 : index2;
}
__name(getPluralIndex, "getPluralIndex");
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
__name(normalizeNamed, "normalizeNamed");
function createMessageContext(options3 = {}) {
  const locale2 = options3.locale;
  const pluralIndex = getPluralIndex(options3);
  const pluralRule = isObject$3(options3.pluralRules) && isString$2(locale2) && isFunction(options3.pluralRules[locale2]) ? options3.pluralRules[locale2] : pluralDefault;
  const orgPluralRule = isObject$3(options3.pluralRules) && isString$2(locale2) && isFunction(options3.pluralRules[locale2]) ? pluralDefault : void 0;
  const plural = /* @__PURE__ */ __name((messages2) => {
    return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
  }, "plural");
  const _list = options3.list || [];
  const list = /* @__PURE__ */ __name((index2) => _list[index2], "list");
  const _named = options3.named || {};
  isNumber$1(options3.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = /* @__PURE__ */ __name((key) => _named[key], "named");
  function message2(key) {
    const msg = isFunction(options3.messages) ? options3.messages(key) : isObject$3(options3.messages) ? options3.messages[key] : false;
    return !msg ? options3.parent ? options3.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  __name(message2, "message");
  const _modifier = /* @__PURE__ */ __name((name) => options3.modifiers ? options3.modifiers[name] : DEFAULT_MODIFIER, "_modifier");
  const normalize = isPlainObject(options3.processor) && isFunction(options3.processor.normalize) ? options3.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options3.processor) && isFunction(options3.processor.interpolate) ? options3.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options3.processor) && isString$2(options3.processor.type) ? options3.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = /* @__PURE__ */ __name((key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$3(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$2(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$2(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$2(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message2(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray$2(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  }, "linked");
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message2,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$2({}, _list, _named)
  };
  return ctx;
}
__name(createMessageContext, "createMessageContext");
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
__name(setDevToolsHook, "setDevToolsHook");
function getDevToolsHook() {
  return devtools;
}
__name(getDevToolsHook, "getDevToolsHook");
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
__name(initI18nDevTools, "initI18nDevTools");
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
__name(createDevToolsHook, "createDevToolsHook");
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  NOT_FOUND_KEY: code$1$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const warnMessages$1 = {
  [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
  [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
  [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
  [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: `This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.`
};
function getWarnMessage$1(code2, ...args) {
  return format$4(warnMessages$1[code2], ...args);
}
__name(getWarnMessage$1, "getWarnMessage$1");
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, false ? { messages: errorMessages$1 } : void 0);
}
__name(createCoreError, "createCoreError");
const errorMessages$1 = {
  [CoreErrorCodes.INVALID_ARGUMENT]: "Invalid arguments",
  [CoreErrorCodes.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function getLocale(context, options3) {
  return options3.locale != null ? resolveLocale(options3.locale) : resolveLocale(context.locale);
}
__name(getLocale, "getLocale");
let _resolveLocale;
function resolveLocale(locale2) {
  if (isString$2(locale2)) {
    return locale2;
  } else {
    if (isFunction(locale2)) {
      if (locale2.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale2.constructor.name === "Function") {
        const resolve2 = locale2();
        if (isPromise(resolve2)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve2;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
__name(resolveLocale, "resolveLocale");
function fallbackWithSimple(ctx, fallback, start2) {
  return [.../* @__PURE__ */ new Set([
    start2,
    ...isArray$2(fallback) ? fallback : isObject$3(fallback) ? Object.keys(fallback) : isString$2(fallback) ? [fallback] : [start2]
  ])];
}
__name(fallbackWithSimple, "fallbackWithSimple");
function fallbackWithLocaleChain(ctx, fallback, start2) {
  const startLocale = isString$2(start2) ? start2 : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block2 = [start2];
    while (isArray$2(block2)) {
      block2 = appendBlockToChain(chain, block2, fallback);
    }
    const defaults2 = isArray$2(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block2 = isString$2(defaults2) ? [defaults2] : defaults2;
    if (isArray$2(block2)) {
      appendBlockToChain(chain, block2, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
__name(fallbackWithLocaleChain, "fallbackWithLocaleChain");
function appendBlockToChain(chain, block2, blocks) {
  let follow = true;
  for (let i2 = 0; i2 < block2.length && isBoolean$1(follow); i2++) {
    const locale2 = block2[i2];
    if (isString$2(locale2)) {
      follow = appendLocaleToChain(chain, block2[i2], blocks);
    }
  }
  return follow;
}
__name(appendBlockToChain, "appendBlockToChain");
function appendLocaleToChain(chain, locale2, blocks) {
  let follow;
  const tokens = locale2.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
__name(appendLocaleToChain, "appendLocaleToChain");
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale2 = target.replace(/!/g, "");
      chain.push(locale2);
      if ((isArray$2(blocks) || isPlainObject(blocks)) && blocks[locale2]) {
        follow = blocks[locale2];
      }
    }
  }
  return follow;
}
__name(appendItemToChain, "appendItemToChain");
const VERSION$1 = "9.13.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = /* @__PURE__ */ __name((str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`, "capitalize");
function getDefaultLinkedModifiers() {
  return {
    upper: /* @__PURE__ */ __name((val, type) => {
      return type === "text" && isString$2(val) ? val.toUpperCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    }, "upper"),
    lower: /* @__PURE__ */ __name((val, type) => {
      return type === "text" && isString$2(val) ? val.toLowerCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    }, "lower"),
    capitalize: /* @__PURE__ */ __name((val, type) => {
      return type === "text" && isString$2(val) ? capitalize(val) : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }, "capitalize")
  };
}
__name(getDefaultLinkedModifiers, "getDefaultLinkedModifiers");
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
__name(registerMessageCompiler, "registerMessageCompiler");
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
__name(registerMessageResolver, "registerMessageResolver");
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
__name(registerLocaleFallbacker, "registerLocaleFallbacker");
let _additionalMeta = null;
const setAdditionalMeta = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
}, "setAdditionalMeta");
const getAdditionalMeta = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta, "getAdditionalMeta");
let _fallbackContext = null;
const setFallbackContext = /* @__PURE__ */ __name((context) => {
  _fallbackContext = context;
}, "setFallbackContext");
const getFallbackContext = /* @__PURE__ */ __name(() => _fallbackContext, "getFallbackContext");
let _cid = 0;
function createCoreContext(options3 = {}) {
  const onWarn = isFunction(options3.onWarn) ? options3.onWarn : warn$1;
  const version2 = isString$2(options3.version) ? options3.version : VERSION$1;
  const locale2 = isString$2(options3.locale) || isFunction(options3.locale) ? options3.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale2) ? DEFAULT_LOCALE : locale2;
  const fallbackLocale = isArray$2(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || isString$2(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale;
  const messages2 = isPlainObject(options3.messages) ? options3.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale]: {} };
  const modifiers = assign$2({}, options3.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options3.pluralRules || {};
  const missing = isFunction(options3.missing) ? options3.missing : null;
  const missingWarn = isBoolean$1(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  const fallbackWarn = isBoolean$1(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  const fallbackFormat = !!options3.fallbackFormat;
  const unresolving = !!options3.unresolving;
  const postTranslation = isFunction(options3.postTranslation) ? options3.postTranslation : null;
  const processor = isPlainObject(options3.processor) ? options3.processor : null;
  const warnHtmlMessage = isBoolean$1(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  const escapeParameter = !!options3.escapeParameter;
  const messageCompiler = isFunction(options3.messageCompiler) ? options3.messageCompiler : _compiler;
  if (false) {
    warnOnce(getWarnMessage$1(CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  }
  const messageResolver = isFunction(options3.messageResolver) ? options3.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options3.localeFallbacker) ? options3.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$3(options3.fallbackContext) ? options3.fallbackContext : void 0;
  const internalOptions = options3;
  const __datetimeFormatters = isObject$3(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$3(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$3(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (false) {
    context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : void 0;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
__name(createCoreContext, "createCoreContext");
function isTranslateFallbackWarn(fallback, key) {
  return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
__name(isTranslateFallbackWarn, "isTranslateFallbackWarn");
function isTranslateMissingWarn(missing, key) {
  return missing instanceof RegExp ? missing.test(key) : missing;
}
__name(isTranslateMissingWarn, "isTranslateMissingWarn");
function handleMissing(context, key, locale2, missingWarn, type) {
  const { missing, onWarn } = context;
  if (false) {
    const emitter = context.__v_emitter;
    if (emitter) {
      emitter.emit("missing", {
        locale: locale2,
        key,
        type,
        groupId: `${type}:${key}`
      });
    }
  }
  if (missing !== null) {
    const ret = missing(context, locale2, key, type);
    return isString$2(ret) ? ret : key;
  } else {
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.NOT_FOUND_KEY, { key, locale: locale2 }));
    }
    return key;
  }
}
__name(handleMissing, "handleMissing");
function updateFallbackLocale(ctx, locale2, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale2);
}
__name(updateFallbackLocale, "updateFallbackLocale");
function isAlmostSameLocale(locale2, compareLocale) {
  if (locale2 === compareLocale)
    return false;
  return locale2.split("-")[0] === compareLocale.split("-")[0];
}
__name(isAlmostSameLocale, "isAlmostSameLocale");
function isImplicitFallback(targetLocale, locales) {
  const index2 = locales.indexOf(targetLocale);
  if (index2 === -1) {
    return false;
  }
  for (let i2 = index2 + 1; i2 < locales.length; i2++) {
    if (isAlmostSameLocale(targetLocale, locales[i2])) {
      return true;
    }
  }
  return false;
}
__name(isImplicitFallback, "isImplicitFallback");
function format$2(ast) {
  const msg = /* @__PURE__ */ __name((ctx) => formatParts(ctx, ast), "msg");
  return msg;
}
__name(format$2, "format$2");
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages2, c) => [
      ...messages2,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
__name(formatParts, "formatParts");
function formatMessageParts(ctx, node3) {
  const _static = node3.s || node3.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages2 = (node3.i || node3.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages2);
  }
}
__name(formatMessageParts, "formatMessageParts");
function formatMessagePart(ctx, node3) {
  const type = node3.t || node3.type;
  switch (type) {
    case 3: {
      const text = node3;
      return text.v || text.value;
    }
    case 9: {
      const literal = node3;
      return literal.v || literal.value;
    }
    case 4: {
      const named = node3;
      return ctx.interpolate(ctx.named(named.k || named.key));
    }
    case 5: {
      const list = node3;
      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
    }
    case 6: {
      const linked = node3;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      const linkedKey = node3;
      return linkedKey.v || linkedKey.value;
    }
    case 8: {
      const linkedModifier = node3;
      return linkedModifier.v || linkedModifier.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${type}`);
  }
}
__name(formatMessagePart, "formatMessagePart");
const WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;
function checkHtmlMessage(source, warnHtmlMessage) {
  if (warnHtmlMessage && detectHtmlTag(source)) {
    warn$1(format$4(WARN_MESSAGE, { source }));
  }
}
__name(checkHtmlMessage, "checkHtmlMessage");
const defaultOnCacheKey = /* @__PURE__ */ __name((message2) => message2, "defaultOnCacheKey");
let compileCache = /* @__PURE__ */ Object.create(null);
function onCompileWarn(_warn) {
  if (_warn.code === CompileWarnCodes.USE_MODULO_SYNTAX) {
    warn$1(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${_warn.message})`);
  }
}
__name(onCompileWarn, "onCompileWarn");
function clearCompileCache() {
  compileCache = /* @__PURE__ */ Object.create(null);
}
__name(clearCompileCache, "clearCompileCache");
const isMessageAST = /* @__PURE__ */ __name((val) => isObject$3(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val), "isMessageAST");
function baseCompile(message2, options3 = {}) {
  let detectError = false;
  const onError = options3.onError || defaultOnError;
  options3.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message2, options3), detectError };
}
__name(baseCompile, "baseCompile");
const compileToFunction = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (message2, context) => {
  if (!isString$2(message2)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  if (false) {
    context.onWarn = onCompileWarn;
  }
  {
    const warnHtmlMessage = isBoolean$1(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message2);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code2, detectError } = baseCompile(message2, context);
    const msg = new Function(`return ${code2}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
}, "compileToFunction");
function compile(message2, context) {
  if (false) {
    context.onWarn = onCompileWarn;
  }
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$2(message2)) {
    const warnHtmlMessage = isBoolean$1(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message2);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message2, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format$2(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    if (false) {
      warn$1(`the message that is resolve with key '${context.key}' is not supported for jit compilation`);
      return () => message2;
    }
    const cacheKey = message2.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format$2(message2);
    } else {
      return format$2(message2);
    }
  }
}
__name(compile, "compile");
const NOOP_MESSAGE_FUNCTION = /* @__PURE__ */ __name(() => "", "NOOP_MESSAGE_FUNCTION");
const isMessageFunction = /* @__PURE__ */ __name((val) => isFunction(val), "isMessageFunction");
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
  const [key, options3] = parseTranslateArgs(...args);
  const missingWarn = isBoolean$1(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean$1(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean$1(options3.escapeParameter) ? options3.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options3.resolvedMessage;
  const defaultMsgOrKey = isString$2(options3.default) || isBoolean$1(options3.default) ? !isBoolean$1(options3.default) ? options3.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale2 = getLocale(context, options3);
  escapeParameter && escapeParams(options3);
  let [formatScope, targetLocale, message2] = !resolvedMessage ? resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale2,
    messages2[locale2] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$2(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  if (false) {
    warn$1(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${key}'.`);
    return key;
  }
  let occurred = false;
  const onError = /* @__PURE__ */ __name(() => {
    occurred = true;
  }, "onError");
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message2, options3);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$2(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$2(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$2({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
__name(translate, "translate");
function escapeParams(options3) {
  if (isArray$2(options3.list)) {
    options3.list = options3.list.map((item2) => isString$2(item2) ? escapeHtml(item2) : item2);
  } else if (isObject$3(options3.named)) {
    Object.keys(options3.named).forEach((key) => {
      if (isString$2(options3.named[key])) {
        options3.named[key] = escapeHtml(options3.named[key]);
      }
    });
  }
}
__name(escapeParams, "escapeParams");
function resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale2);
  let message2 = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "translate";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    message2 = messages2[targetLocale] || {};
    let start2 = null;
    let startTag;
    let endTag;
    if (false) {
      start2 = window.performance.now();
      startTag = "intlify-message-resolve-start";
      endTag = "intlify-message-resolve-end";
      mark && mark(startTag);
    }
    if ((format2 = resolveValue2(message2, key)) === null) {
      format2 = message2[key];
    }
    if (false) {
      const end = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start2 && format2) {
        emitter.emit("message-resolve", {
          type: "message-resolve",
          key,
          message: format2,
          time: end - start2,
          groupId: `${type}:${key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message resolve", startTag, endTag);
      }
    }
    if (isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
    from = to;
  }
  return [format2, targetLocale, message2];
}
__name(resolveMessageFormat, "resolveMessageFormat");
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = /* @__PURE__ */ __name(() => format2, "msg2");
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  let start2 = null;
  let startTag;
  let endTag;
  if (false) {
    start2 = window.performance.now();
    startTag = "intlify-message-compilation-start";
    endTag = "intlify-message-compilation-end";
    mark && mark(startTag);
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  if (false) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start2) {
      emitter.emit("message-compilation", {
        type: "message-compilation",
        message: format2,
        time: end - start2,
        groupId: `${"translate"}:${key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message compilation", startTag, endTag);
    }
  }
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
__name(compileMessageFormat, "compileMessageFormat");
function evaluateMessage(context, msg, msgCtx) {
  let start2 = null;
  let startTag;
  let endTag;
  if (false) {
    start2 = window.performance.now();
    startTag = "intlify-message-evaluation-start";
    endTag = "intlify-message-evaluation-end";
    mark && mark(startTag);
  }
  const messaged = msg(msgCtx);
  if (false) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start2) {
      emitter.emit("message-evaluation", {
        type: "message-evaluation",
        value: messaged,
        time: end - start2,
        groupId: `${"translate"}:${msg.key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message evaluation", startTag, endTag);
    }
  }
  return messaged;
}
__name(evaluateMessage, "evaluateMessage");
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options3 = {};
  if (!isString$2(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber$1(arg2)) {
    options3.plural = arg2;
  } else if (isString$2(arg2)) {
    options3.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options3.named = arg2;
  } else if (isArray$2(arg2)) {
    options3.list = arg2;
  }
  if (isNumber$1(arg3)) {
    options3.plural = arg3;
  } else if (isString$2(arg3)) {
    options3.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$2(options3, arg3);
  }
  return [key, options3];
}
__name(parseTranslateArgs, "parseTranslateArgs");
function getCompileContext(context, locale2, key, source, warnHtmlMessage, onError) {
  return {
    locale: locale2,
    key,
    warnHtmlMessage,
    onError: /* @__PURE__ */ __name((err) => {
      onError && onError(err);
      if (false) {
        const _source = getSourceForCodeFrame(source);
        const message2 = `Message compilation error: ${err.message}`;
        const codeFrame = err.location && _source && generateCodeFrame(_source, err.location.start.offset, err.location.end.offset);
        const emitter = context.__v_emitter;
        if (emitter && _source) {
          emitter.emit("compile-error", {
            message: _source,
            error: err.message,
            start: err.location && err.location.start.offset,
            end: err.location && err.location.end.offset,
            groupId: `${"translate"}:${key}`
          });
        }
        console.error(codeFrame ? `${message2}
${codeFrame}` : message2);
      } else {
        throw err;
      }
    }, "onError"),
    onCacheKey: /* @__PURE__ */ __name((source2) => generateFormatCacheKey(locale2, key, source2), "onCacheKey")
  };
}
__name(getCompileContext, "getCompileContext");
function getSourceForCodeFrame(source) {
  if (isString$2(source)) {
    return source;
  } else {
    if (source.loc && source.loc.source) {
      return source.loc.source;
    }
  }
}
__name(getSourceForCodeFrame, "getSourceForCodeFrame");
function getMessageContextOptions(context, locale2, message2, options3) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = /* @__PURE__ */ __name((key) => {
    let val = resolveValue2(message2, key);
    if (val == null && fallbackContext) {
      const [, , message22] = resolveMessageFormat(fallbackContext, key, locale2, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message22, key);
    }
    if (isString$2(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = /* @__PURE__ */ __name(() => {
        occurred = true;
      }, "onError");
      const msg = compileMessageFormat(context, key, locale2, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  }, "resolveMessage");
  const ctxOptions = {
    locale: locale2,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options3.list) {
    ctxOptions.list = options3.list;
  }
  if (options3.named) {
    ctxOptions.named = options3.named;
  }
  if (isNumber$1(options3.plural)) {
    ctxOptions.pluralIndex = options3.plural;
  }
  return ctxOptions;
}
__name(getMessageContextOptions, "getMessageContextOptions");
const intlDefined = typeof Intl !== "undefined";
const Availabilities = {
  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
  numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
};
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  if (false) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_DATE));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value3, options3, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean$1(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean$1(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const part = !!options3.part;
  const locale2 = getLocale(context, options3);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale2
  );
  if (!isString$2(key) || key === "") {
    return new Intl.DateTimeFormat(locale2, overrides).format(value3);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "datetime format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to;
  }
  if (!isPlainObject(format2) || !isString$2(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id3 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id3 = `${id3}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id3);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
    __datetimeFormatters.set(id3, formatter);
  }
  return !part ? formatter.format(value3) : formatter.formatToParts(value3);
}
__name(datetime, "datetime");
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options3 = {};
  let overrides = {};
  let value3;
  if (isString$2(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value3 = new Date(dateTime);
    try {
      value3.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value3 = arg1;
  } else if (isNumber$1(arg1)) {
    value3 = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$2(arg2)) {
    options3.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options3[key] = arg2[key];
      }
    });
  }
  if (isString$2(arg3)) {
    options3.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options3.key || "", value3, options3, overrides];
}
__name(parseDateTimeArgs, "parseDateTimeArgs");
function clearDateTimeFormat(ctx, locale2, format2) {
  const context = ctx;
  for (const key in format2) {
    const id3 = `${locale2}__${key}`;
    if (!context.__datetimeFormatters.has(id3)) {
      continue;
    }
    context.__datetimeFormatters.delete(id3);
  }
}
__name(clearDateTimeFormat, "clearDateTimeFormat");
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  if (false) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value3, options3, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean$1(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean$1(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const part = !!options3.part;
  const locale2 = getLocale(context, options3);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale2
  );
  if (!isString$2(key) || key === "") {
    return new Intl.NumberFormat(locale2, overrides).format(value3);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "number format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to;
  }
  if (!isPlainObject(format2) || !isString$2(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id3 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id3 = `${id3}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id3);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
    __numberFormatters.set(id3, formatter);
  }
  return !part ? formatter.format(value3) : formatter.formatToParts(value3);
}
__name(number, "number");
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options3 = {};
  let overrides = {};
  if (!isNumber$1(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value3 = arg1;
  if (isString$2(arg2)) {
    options3.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options3[key] = arg2[key];
      }
    });
  }
  if (isString$2(arg3)) {
    options3.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options3.key || "", value3, options3, overrides];
}
__name(parseNumberArgs, "parseNumberArgs");
function clearNumberFormat(ctx, locale2, format2) {
  const context = ctx;
  for (const key in format2) {
    const id3 = `${locale2}__${key}`;
    if (!context.__numberFormatters.has(id3)) {
      continue;
    }
    context.__numberFormatters.delete(id3);
  }
}
__name(clearNumberFormat, "clearNumberFormat");
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.13.1";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
__name(initFeatureFlags, "initFeatureFlags");
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
const I18nWarnCodes = {
  FALLBACK_TO_ROOT: code$1,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
};
const warnMessages = {
  [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
  [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
  [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
  [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
  [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,
  [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`,
  [I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION]: `'allowComposition' option will be dropped in the next major version. For more information, please see  https://tinyurl.com/2p97mcze`,
  [I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: `'translateExistCompatible' option will be dropped in the next major version.`
};
function getWarnMessage(code2, ...args) {
  return format$4(warnMessages[code2], ...args);
}
__name(getWarnMessage, "getWarnMessage");
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, false ? { messages: errorMessages, args } : void 0);
}
__name(createI18nError, "createI18nError");
const errorMessages = {
  [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [I18nErrorCodes.INVALID_ARGUMENT]: "Invalid argument",
  [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [I18nErrorCodes.NOT_INSTALLED]: "Need to install with `app.use` function",
  [I18nErrorCodes.UNEXPECTED_ERROR]: "Unexpected error",
  [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
  [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
  [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
  [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define i18n option or custom block in Composition API with using local scope in Legacy API mode",
  [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
};
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const EnableEmitter = /* @__PURE__ */ makeSymbol("__enableEmitter");
const DisableEmitter = /* @__PURE__ */ makeSymbol("__disableEmitter");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
makeSymbol("__intlifyMeta");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
const __VUE_I18N_BRIDGE__ = "__VUE_I18N_BRIDGE__";
function handleFlatJson(obj) {
  if (!isObject$3(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn$2(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$3(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i2 = 0; i2 < lastIndex; i2++) {
        if (!(subKeys[i2] in currentObj)) {
          currentObj[subKeys[i2]] = {};
        }
        if (!isObject$3(currentObj[subKeys[i2]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i2]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$3(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
__name(handleFlatJson, "handleFlatJson");
function getLocaleMessages(locale2, options3) {
  const { messages: messages2, __i18n, messageResolver, flatJson } = options3;
  const ret = isPlainObject(messages2) ? messages2 : isArray$2(__i18n) ? {} : { [locale2]: {} };
  if (isArray$2(__i18n)) {
    __i18n.forEach((custom2) => {
      if ("locale" in custom2 && "resource" in custom2) {
        const { locale: locale22, resource } = custom2;
        if (locale22) {
          ret[locale22] = ret[locale22] || {};
          deepCopy(resource, ret[locale22]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$2(custom2) && deepCopy(JSON.parse(custom2), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn$2(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
__name(getLocaleMessages, "getLocaleMessages");
function getComponentOptions(instance) {
  return instance.type;
}
__name(getComponentOptions, "getComponentOptions");
function adjustI18nResources(gl, options3, componentOptions) {
  let messages2 = isObject$3(options3.messages) ? options3.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages2 = getLocaleMessages(gl.locale.value, {
      messages: messages2,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages2);
  if (locales.length) {
    locales.forEach((locale2) => {
      gl.mergeLocaleMessage(locale2, messages2[locale2]);
    });
  }
  {
    if (isObject$3(options3.datetimeFormats)) {
      const locales2 = Object.keys(options3.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale2) => {
          gl.mergeDateTimeFormat(locale2, options3.datetimeFormats[locale2]);
        });
      }
    }
    if (isObject$3(options3.numberFormats)) {
      const locales2 = Object.keys(options3.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale2) => {
          gl.mergeNumberFormat(locale2, options3.numberFormats[locale2]);
        });
      }
    }
  }
}
__name(adjustI18nResources, "adjustI18nResources");
function createTextNode(key) {
  return createVNode(Text$1, null, key, 0);
}
__name(createTextNode, "createTextNode");
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = /* @__PURE__ */ __name(() => [], "NOOP_RETURN_ARRAY");
const NOOP_RETURN_FALSE = /* @__PURE__ */ __name(() => false, "NOOP_RETURN_FALSE");
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale2, key, type) => {
    return missing(locale2, key, getCurrentInstance() || void 0, type);
  };
}
__name(defineCoreMissingHandler, "defineCoreMissingHandler");
const getMetaInfo = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
}, "getMetaInfo");
function createComposer(options3 = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options3;
  const _isGlobal = __root === void 0;
  const flatJson = options3.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options3.translateExistCompatible;
  if (false) {
    if (translateExistCompatible && true) {
      warnOnce(getWarnMessage(I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
    }
  }
  let _inheritLocale = isBoolean$1(options3.inheritLocale) ? options3.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$2(options3.locale) ? options3.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$2(options3.fallbackLocale) || isArray$2(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options3));
  const _datetimeFormats = _ref(isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean$1(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean$1(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean$1(options3.fallbackRoot) ? options3.fallbackRoot : true;
  let _fallbackFormat = !!options3.fallbackFormat;
  let _missing = isFunction(options3.missing) ? options3.missing : null;
  let _runtimeMissing = isFunction(options3.missing) ? defineCoreMissingHandler(options3.missing) : null;
  let _postTranslation = isFunction(options3.postTranslation) ? options3.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean$1(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  let _escapeParameter = !!options3.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options3.modifiers) ? options3.modifiers : {};
  let _pluralRules = options3.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = /* @__PURE__ */ __name(() => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options3.messageResolver,
      messageCompiler: options3.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    if (false) {
      ctxOptions.__v_emitter = isPlainObject(_context) ? _context.__v_emitter : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  }, "getCoreContext");
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  __name(trackReactivityValues, "trackReactivityValues");
  const locale2 = computed({
    get: /* @__PURE__ */ __name(() => _locale.value, "get"),
    set: /* @__PURE__ */ __name((val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }, "set")
  });
  const fallbackLocale = computed({
    get: /* @__PURE__ */ __name(() => _fallbackLocale.value, "get"),
    set: /* @__PURE__ */ __name((val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }, "set")
  });
  const messages2 = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  __name(getPostTranslationHandler, "getPostTranslationHandler");
  function setPostTranslationHandler(handler6) {
    _postTranslation = handler6;
    _context.postTranslation = handler6;
  }
  __name(setPostTranslationHandler, "setPostTranslationHandler");
  function getMissingHandler() {
    return _missing;
  }
  __name(getMissingHandler, "getMissingHandler");
  function setMissingHandler(handler6) {
    if (handler6 !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler6);
    }
    _missing = handler6;
    _context.missing = _runtimeMissing;
  }
  __name(setMissingHandler, "setMissingHandler");
  function isResolvedTranslateMessage(type, arg) {
    return type !== "translate" || !arg.resolvedMessage;
  }
  __name(isResolvedTranslateMessage, "isResolvedTranslateMessage");
  const wrapWithDeps = /* @__PURE__ */ __name((fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(null);
      }
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      if (false) {
        if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
          warn$1(getWarnMessage(I18nWarnCodes.FALLBACK_TO_ROOT, {
            key,
            type: warnType
          }));
        }
        if (false) {
          const { __v_emitter: emitter } = _context;
          if (emitter && _fallbackRoot) {
            emitter.emit("fallback", {
              type: warnType,
              key,
              to: "global",
              groupId: `${warnType}:${key}`
            });
          }
        }
      }
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  }, "wrapWithDeps");
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root23) => Reflect.apply(root23.t, root23, [...args]), (key) => key, (val) => isString$2(val));
  }
  __name(t, "t");
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$3(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign$2({ resolvedMessage: true }, arg3 || {})]);
  }
  __name(rt, "rt");
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root23) => Reflect.apply(root23.d, root23, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
  }
  __name(d, "d");
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root23) => Reflect.apply(root23.n, root23, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
  }
  __name(n, "n");
  function normalize(values2) {
    return values2.map((val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val) ? createTextNode(String(val)) : val);
  }
  __name(normalize, "normalize");
  const interpolate = /* @__PURE__ */ __name((val) => val, "interpolate");
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root23) => root23[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray$2(val)
    );
  }
  __name(translateVNode, "translateVNode");
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root23) => root23[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$2(val) || isArray$2(val)
    );
  }
  __name(numberParts, "numberParts");
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root23) => root23[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$2(val) || isArray$2(val)
    );
  }
  __name(datetimeParts, "datetimeParts");
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  __name(setPluralRules, "setPluralRules");
  function te(key, locale22) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$2(locale22) ? locale22 : _locale.value;
      const message2 = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message2, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$2(resolved) : resolved != null;
    }, () => [key], "translate exists", (root23) => {
      return Reflect.apply(root23.te, root23, [key, locale22]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean$1(val));
  }
  __name(te, "te");
  function resolveMessages(key) {
    let messages22 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i2 = 0; i2 < locales.length; i2++) {
      const targetLocaleMessages = _messages.value[locales[i2]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages22 = messageValue;
        break;
      }
    }
    return messages22;
  }
  __name(resolveMessages, "resolveMessages");
  function tm(key) {
    const messages22 = resolveMessages(key);
    return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
  }
  __name(tm, "tm");
  function getLocaleMessage(locale22) {
    return _messages.value[locale22] || {};
  }
  __name(getLocaleMessage, "getLocaleMessage");
  function setLocaleMessage(locale22, message2) {
    if (flatJson) {
      const _message = { [locale22]: message2 };
      for (const key in _message) {
        if (hasOwn$2(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message2 = _message[locale22];
    }
    _messages.value[locale22] = message2;
    _context.messages = _messages.value;
  }
  __name(setLocaleMessage, "setLocaleMessage");
  function mergeLocaleMessage(locale22, message2) {
    _messages.value[locale22] = _messages.value[locale22] || {};
    const _message = { [locale22]: message2 };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn$2(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message2 = _message[locale22];
    deepCopy(message2, _messages.value[locale22]);
    _context.messages = _messages.value;
  }
  __name(mergeLocaleMessage, "mergeLocaleMessage");
  function getDateTimeFormat(locale22) {
    return _datetimeFormats.value[locale22] || {};
  }
  __name(getDateTimeFormat, "getDateTimeFormat");
  function setDateTimeFormat(locale22, format2) {
    _datetimeFormats.value[locale22] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale22, format2);
  }
  __name(setDateTimeFormat, "setDateTimeFormat");
  function mergeDateTimeFormat(locale22, format2) {
    _datetimeFormats.value[locale22] = assign$2(_datetimeFormats.value[locale22] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale22, format2);
  }
  __name(mergeDateTimeFormat, "mergeDateTimeFormat");
  function getNumberFormat(locale22) {
    return _numberFormats.value[locale22] || {};
  }
  __name(getNumberFormat, "getNumberFormat");
  function setNumberFormat(locale22, format2) {
    _numberFormats.value[locale22] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale22, format2);
  }
  __name(setNumberFormat, "setNumberFormat");
  function mergeNumberFormat(locale22, format2) {
    _numberFormats.value[locale22] = assign$2(_numberFormats.value[locale22] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale22, format2);
  }
  __name(mergeNumberFormat, "mergeNumberFormat");
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale: locale2,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages: messages2,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  if (false) {
    composer[EnableEmitter] = (emitter) => {
      _context.__v_emitter = emitter;
    };
    composer[DisableEmitter] = () => {
      _context.__v_emitter = void 0;
    };
  }
  return composer;
}
__name(createComposer, "createComposer");
function convertComposerOptions(options3) {
  const locale2 = isString$2(options3.locale) ? options3.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$2(options3.fallbackLocale) || isArray$2(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : locale2;
  const missing = isFunction(options3.missing) ? options3.missing : void 0;
  const missingWarn = isBoolean$1(options3.silentTranslationWarn) || isRegExp(options3.silentTranslationWarn) ? !options3.silentTranslationWarn : true;
  const fallbackWarn = isBoolean$1(options3.silentFallbackWarn) || isRegExp(options3.silentFallbackWarn) ? !options3.silentFallbackWarn : true;
  const fallbackRoot = isBoolean$1(options3.fallbackRoot) ? options3.fallbackRoot : true;
  const fallbackFormat = !!options3.formatFallbackMessages;
  const modifiers = isPlainObject(options3.modifiers) ? options3.modifiers : {};
  const pluralizationRules = options3.pluralizationRules;
  const postTranslation = isFunction(options3.postTranslation) ? options3.postTranslation : void 0;
  const warnHtmlMessage = isString$2(options3.warnHtmlInMessage) ? options3.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options3.escapeParameterHtml;
  const inheritLocale = isBoolean$1(options3.sync) ? options3.sync : true;
  if (false) {
    warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
  }
  if (false) {
    warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  }
  let messages2 = options3.messages;
  if (isPlainObject(options3.sharedMessages)) {
    const sharedMessages = options3.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages2 = locales.reduce((messages22, locale22) => {
      const message2 = messages22[locale22] || (messages22[locale22] = {});
      assign$2(message2, sharedMessages[locale22]);
      return messages22;
    }, messages2 || {});
  }
  const { __i18n, __root, __injectWithOption } = options3;
  const datetimeFormats = options3.datetimeFormats;
  const numberFormats = options3.numberFormats;
  const flatJson = options3.flatJson;
  const translateExistCompatible = options3.translateExistCompatible;
  return {
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options3.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
__name(convertComposerOptions, "convertComposerOptions");
function createVueI18n(options3 = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options3));
    const { __extender } = options3;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler6) {
        composer.setMissingHandler(handler6);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean$1(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean$1(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean$1(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean$1(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler6) {
        composer.setPostTranslationHandler(handler6);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options22 = {};
        let list = null;
        let named = null;
        if (!isString$2(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$2(arg2)) {
          options22.locale = arg2;
        } else if (isArray$2(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray$2(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options22
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options22 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$2(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$2(arg2)) {
          options22.locale = arg2;
        } else if (isNumber$1(arg2)) {
          options22.plural = arg2;
        } else if (isArray$2(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString$2(arg3)) {
          options22.locale = arg3;
        } else if (isArray$2(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options22
        ]);
      },
      // te
      te(key, locale2) {
        return composer.te(key, locale2);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale2) {
        return composer.getLocaleMessage(locale2);
      },
      // setLocaleMessage
      setLocaleMessage(locale2, message2) {
        composer.setLocaleMessage(locale2, message2);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale2, message2) {
        composer.mergeLocaleMessage(locale2, message2);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale2) {
        return composer.getDateTimeFormat(locale2);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale2, format2) {
        composer.setDateTimeFormat(locale2, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale2, format2) {
        composer.mergeDateTimeFormat(locale2, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale2) {
        return composer.getNumberFormat(locale2);
      },
      // setNumberFormat
      setNumberFormat(locale2, format2) {
        composer.setNumberFormat(locale2, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale2, format2) {
        composer.mergeNumberFormat(locale2, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    if (false) {
      vueI18n.__enableEmitter = (emitter) => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };
      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }
    return vueI18n;
  }
}
__name(createVueI18n, "createVueI18n");
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: /* @__PURE__ */ __name((val) => val === "parent" || val === "global", "validator"),
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys2) {
  if (keys2.length === 1 && keys2[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys2.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
__name(getInterpolateArg, "getInterpolateArg");
function getFragmentableTag(tag) {
  return Fragment;
}
__name(getFragmentableTag, "getFragmentableTag");
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$2({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: /* @__PURE__ */ __name((val) => isNumber$1(val) || !isNaN(val), "validator")
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs: attrs3 } = context;
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys2 = Object.keys(slots).filter((key) => key !== "_");
      const options3 = {};
      if (props.locale) {
        options3.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options3.plural = isString$2(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys2);
      const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options3);
      const assignedAttrs = assign$2({}, attrs3);
      const tag = isString$2(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
const I18nT = Translation;
function isVNode(target) {
  return isArray$2(target) && !isString$2(target[0]);
}
__name(isVNode, "isVNode");
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs: attrs3 } = context;
  return () => {
    const options3 = { part: true };
    let overrides = {};
    if (props.locale) {
      options3.locale = props.locale;
    }
    if (isString$2(props.format)) {
      options3.key = props.format;
    } else if (isObject$3(props.format)) {
      if (isString$2(props.format.key)) {
        options3.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options22, prop2) => {
        return slotKeys.includes(prop2) ? assign$2({}, options22, { [prop2]: props.format[prop2] }) : options22;
      }, {});
    }
    const parts2 = partFormatter(...[props.value, options3, overrides]);
    let children = [options3.key];
    if (isArray$2(parts2)) {
      children = parts2.map((part, index2) => {
        const slot = slots[part.type];
        const node3 = slot ? slot({ [part.type]: part.value, index: index2, parts: parts2 }) : [part.value];
        if (isVNode(node3)) {
          node3[0].key = `${part.type}-${index2}`;
        }
        return node3;
      });
    } else if (isString$2(parts2)) {
      children = [parts2];
    }
    const assignedAttrs = assign$2({}, attrs3);
    const tag = isString$2(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
__name(renderFormatter, "renderFormatter");
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$2({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const I18nN = NumberFormat;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$2({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
const I18nD = DatetimeFormat;
function getComposer$2(i18n2, instance) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
__name(getComposer$2, "getComposer$2");
function vTDirective(i18n2) {
  const _process = /* @__PURE__ */ __name((binding) => {
    const { instance, modifiers, value: value3 } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance.$);
    if (false) {
      warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE));
    }
    const parsedValue = parseValue(value3);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  }, "_process");
  const register3 = /* @__PURE__ */ __name((el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  }, "register");
  const unregister = /* @__PURE__ */ __name((el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  }, "unregister");
  const update = /* @__PURE__ */ __name((el, { value: value3 }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value3);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  }, "update");
  const getSSRProps = /* @__PURE__ */ __name((binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  }, "getSSRProps");
  return {
    created: register3,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
__name(vTDirective, "vTDirective");
function parseValue(value3) {
  if (isString$2(value3)) {
    return { path: value3 };
  } else if (isPlainObject(value3)) {
    if (!("path" in value3)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value3;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
__name(parseValue, "parseValue");
function makeParams(value3) {
  const { path, locale: locale2, args, choice, plural } = value3;
  const options3 = {};
  const named = args || {};
  if (isString$2(locale2)) {
    options3.locale = locale2;
  }
  if (isNumber$1(choice)) {
    options3.plural = choice;
  }
  if (isNumber$1(plural)) {
    options3.plural = plural;
  }
  return [path, named, options3];
}
__name(makeParams, "makeParams");
function apply(app2, i18n2, ...options3) {
  const pluginOptions = isPlainObject(options3[0]) ? options3[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean$1(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (false) {
    warn$1(getWarnMessage(I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE, {
      name: Translation.name
    }));
  }
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
__name(apply, "apply");
const VueDevToolsLabels = {
  [
    "vue-devtools-plugin-vue-i18n"
    /* VueDevToolsIDs.PLUGIN */
  ]: "Vue I18n devtools",
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "I18n Resources",
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: "Vue I18n"
};
const VueDevToolsPlaceholders = {
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "Search for scopes ..."
};
const VueDevToolsTimelineColors = {
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: 16764185
};
const VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
let devtoolsApi;
async function enableDevTools(app2, i18n2) {
  return new Promise((resolve2, reject2) => {
    try {
      setupDevtoolsPlugin({
        id: "vue-devtools-plugin-vue-i18n",
        label: VueDevToolsLabels[
          "vue-devtools-plugin-vue-i18n"
          /* VueDevToolsIDs.PLUGIN */
        ],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
        app: app2
        // eslint-disable-line @typescript-eslint/no-explicit-any
      }, (api2) => {
        devtoolsApi = api2;
        api2.on.visitComponentTree(({ componentInstance, treeNode }) => {
          updateComponentTreeTags(componentInstance, treeNode, i18n2);
        });
        api2.on.inspectComponent(({ componentInstance, instanceData }) => {
          if (componentInstance.vnode.el && componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
            if (i18n2.mode === "legacy") {
              if (componentInstance.vnode.el.__VUE_I18N__ !== i18n2.global.__composer) {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            } else {
              inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
            }
          }
        });
        api2.addInspector({
          id: "vue-i18n-resource-inspector",
          label: VueDevToolsLabels[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ],
          icon: "language",
          treeFilterPlaceholder: VueDevToolsPlaceholders[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ]
        });
        api2.on.getInspectorTree((payload) => {
          if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
            registerScope(payload, i18n2);
          }
        });
        const roots = /* @__PURE__ */ new Map();
        api2.on.getInspectorState(async (payload) => {
          if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
            api2.unhighlightElement();
            inspectScope(payload, i18n2);
            if (payload.nodeId === "global") {
              if (!roots.has(payload.app)) {
                const [root23] = await api2.getComponentInstances(payload.app);
                roots.set(payload.app, root23);
              }
              api2.highlightElement(roots.get(payload.app));
            } else {
              const instance = getComponentInstance(payload.nodeId, i18n2);
              instance && api2.highlightElement(instance);
            }
          }
        });
        api2.on.editInspectorState((payload) => {
          if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
            editScope(payload, i18n2);
          }
        });
        api2.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: VueDevToolsLabels[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ],
          color: VueDevToolsTimelineColors[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ]
        });
        resolve2(true);
      });
    } catch (e) {
      console.error(e);
      reject2(false);
    }
  });
}
__name(enableDevTools, "enableDevTools");
function getI18nScopeLable(instance) {
  return instance.type.name || instance.type.displayName || instance.type.__file || "Anonymous";
}
__name(getI18nScopeLable, "getI18nScopeLable");
function updateComponentTreeTags(instance, treeNode, i18n2) {
  const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {
    if (instance.vnode.el.__VUE_I18N__ !== global2) {
      const tag = {
        label: `i18n (${getI18nScopeLable(instance)} Scope)`,
        textColor: 0,
        backgroundColor: 16764185
      };
      treeNode.tags.push(tag);
    }
  }
}
__name(updateComponentTreeTags, "updateComponentTreeTags");
function inspectComposer(instanceData, composer) {
  const type = VUE_I18N_COMPONENT_TYPES;
  instanceData.state.push({
    type,
    key: "locale",
    editable: true,
    value: composer.locale.value
  });
  instanceData.state.push({
    type,
    key: "availableLocales",
    editable: false,
    value: composer.availableLocales
  });
  instanceData.state.push({
    type,
    key: "fallbackLocale",
    editable: true,
    value: composer.fallbackLocale.value
  });
  instanceData.state.push({
    type,
    key: "inheritLocale",
    editable: true,
    value: composer.inheritLocale
  });
  instanceData.state.push({
    type,
    key: "messages",
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  });
  {
    instanceData.state.push({
      type,
      key: "datetimeFormats",
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: "numberFormats",
      editable: false,
      value: composer.numberFormats.value
    });
  }
}
__name(inspectComposer, "inspectComposer");
function getLocaleMessageValue(messages2) {
  const value3 = {};
  Object.keys(messages2).forEach((key) => {
    const v2 = messages2[key];
    if (isFunction(v2) && "source" in v2) {
      value3[key] = getMessageFunctionDetails(v2);
    } else if (isMessageAST(v2) && v2.loc && v2.loc.source) {
      value3[key] = v2.loc.source;
    } else if (isObject$3(v2)) {
      value3[key] = getLocaleMessageValue(v2);
    } else {
      value3[key] = v2;
    }
  });
  return value3;
}
__name(getLocaleMessageValue, "getLocaleMessageValue");
const ESC = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function escape$1(s) {
  return s.replace(/[<>"&]/g, escapeChar);
}
__name(escape$1, "escape$1");
function escapeChar(a) {
  return ESC[a] || a;
}
__name(escapeChar, "escapeChar");
function getMessageFunctionDetails(func) {
  const argString = func.source ? `("${escape$1(func.source)}")` : `(?)`;
  return {
    _custom: {
      type: "function",
      display: `<span></span> ${argString}`
    }
  };
}
__name(getMessageFunctionDetails, "getMessageFunctionDetails");
function registerScope(payload, i18n2) {
  payload.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  for (const [keyInstance, instance] of i18n2.__instances) {
    const composer = i18n2.mode === "composition" ? instance : instance.__composer;
    if (global2 === composer) {
      continue;
    }
    payload.rootNodes.push({
      id: composer.id.toString(),
      label: `${getI18nScopeLable(keyInstance)} Scope`
    });
  }
}
__name(registerScope, "registerScope");
function getComponentInstance(nodeId, i18n2) {
  let instance = null;
  if (nodeId !== "global") {
    for (const [component, composer] of i18n2.__instances.entries()) {
      if (composer.id.toString() === nodeId) {
        instance = component;
        break;
      }
    }
  }
  return instance;
}
__name(getComponentInstance, "getComponentInstance");
function getComposer$1(nodeId, i18n2) {
  if (nodeId === "global") {
    return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  } else {
    const instance = Array.from(i18n2.__instances.values()).find((item2) => item2.id.toString() === nodeId);
    if (instance) {
      return i18n2.mode === "composition" ? instance : instance.__composer;
    } else {
      return null;
    }
  }
}
__name(getComposer$1, "getComposer$1");
function inspectScope(payload, i18n2) {
  const composer = getComposer$1(payload.nodeId, i18n2);
  if (composer) {
    payload.state = makeScopeInspectState(composer);
  }
  return null;
}
__name(inspectScope, "inspectScope");
function makeScopeInspectState(composer) {
  const state = {};
  const localeType = "Locale related info";
  const localeStates = [
    {
      type: localeType,
      key: "locale",
      editable: true,
      value: composer.locale.value
    },
    {
      type: localeType,
      key: "fallbackLocale",
      editable: true,
      value: composer.fallbackLocale.value
    },
    {
      type: localeType,
      key: "availableLocales",
      editable: false,
      value: composer.availableLocales
    },
    {
      type: localeType,
      key: "inheritLocale",
      editable: true,
      value: composer.inheritLocale
    }
  ];
  state[localeType] = localeStates;
  const localeMessagesType = "Locale messages info";
  const localeMessagesStates = [
    {
      type: localeMessagesType,
      key: "messages",
      editable: false,
      value: getLocaleMessageValue(composer.messages.value)
    }
  ];
  state[localeMessagesType] = localeMessagesStates;
  {
    const datetimeFormatsType = "Datetime formats info";
    const datetimeFormatsStates = [
      {
        type: datetimeFormatsType,
        key: "datetimeFormats",
        editable: false,
        value: composer.datetimeFormats.value
      }
    ];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = "Datetime formats info";
    const numberFormatsStates = [
      {
        type: numberFormatsType,
        key: "numberFormats",
        editable: false,
        value: composer.numberFormats.value
      }
    ];
    state[numberFormatsType] = numberFormatsStates;
  }
  return state;
}
__name(makeScopeInspectState, "makeScopeInspectState");
function addTimelineEvent(event2, payload) {
  if (devtoolsApi) {
    let groupId;
    if (payload && "groupId" in payload) {
      groupId = payload.groupId;
      delete payload.groupId;
    }
    devtoolsApi.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: event2,
        groupId,
        time: Date.now(),
        meta: {},
        data: payload || {},
        logType: event2 === "compile-error" ? "error" : event2 === "fallback" || event2 === "missing" ? "warning" : "default"
      }
    });
  }
}
__name(addTimelineEvent, "addTimelineEvent");
function editScope(payload, i18n2) {
  const composer = getComposer$1(payload.nodeId, i18n2);
  if (composer) {
    const [field] = payload.path;
    if (field === "locale" && isString$2(payload.state.value)) {
      composer.locale.value = payload.state.value;
    } else if (field === "fallbackLocale" && (isString$2(payload.state.value) || isArray$2(payload.state.value) || isObject$3(payload.state.value))) {
      composer.fallbackLocale.value = payload.state.value;
    } else if (field === "inheritLocale" && isBoolean$1(payload.state.value)) {
      composer.inheritLocale = payload.state.value;
    }
  }
}
__name(editScope, "editScope");
function defineMixin(vuei18n, composer, i18n2) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options3 = this.$options;
      if (options3.i18n) {
        const optionsI18n = options3.i18n;
        if (options3.__i18n) {
          optionsI18n.__i18n = options3.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n2.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options3.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options3);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options3.__i18n,
            __injectWithOption: true,
            __extender: i18n2.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options3.__i18nGlobal) {
        adjustI18nResources(composer, options3, options3);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale2) => this.$i18n.te(key, locale2);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n2.__setInstance(instance, this.$i18n);
    },
    mounted() {
      if (false) {
        const _vueI18n = this.$i18n;
        this.$el.__VUE_I18N__ = _vueI18n.__composer;
        const emitter = this.__v_emitter = createEmitter();
        _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
        emitter.on("*", addTimelineEvent);
      }
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      if (false) {
        if (this.__v_emitter) {
          this.__v_emitter.off("*", addTimelineEvent);
          delete this.__v_emitter;
        }
        if (this.$i18n) {
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
      }
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n2.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
__name(defineMixin, "defineMixin");
function mergeToGlobal(g, options3) {
  g.locale = options3.locale || g.locale;
  g.fallbackLocale = options3.fallbackLocale || g.fallbackLocale;
  g.missing = options3.missing || g.missing;
  g.silentTranslationWarn = options3.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options3.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options3.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options3.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options3.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options3.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options3.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options3.pluralizationRules || g.pluralizationRules);
  const messages2 = getLocaleMessages(g.locale, {
    messages: options3.messages,
    __i18n: options3.__i18n
  });
  Object.keys(messages2).forEach((locale2) => g.mergeLocaleMessage(locale2, messages2[locale2]));
  if (options3.datetimeFormats) {
    Object.keys(options3.datetimeFormats).forEach((locale2) => g.mergeDateTimeFormat(locale2, options3.datetimeFormats[locale2]));
  }
  if (options3.numberFormats) {
    Object.keys(options3.numberFormats).forEach((locale2) => g.mergeNumberFormat(locale2, options3.numberFormats[locale2]));
  }
  return g;
}
__name(mergeToGlobal, "mergeToGlobal");
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options3 = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean$1(options3.legacy) ? options3.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean$1(options3.globalInjection) ? options3.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options3.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options3, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol(false ? "vue-i18n" : "");
  if (false) {
    if (__legacyMode && __allowComposition && true) {
      warn$1(getWarnMessage(I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION));
    }
  }
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  __name(__getInstance, "__getInstance");
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  __name(__setInstance, "__setInstance");
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  __name(__deleteInstance, "__deleteInstance");
  {
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options22) {
        if (false) {
          app2.__VUE_I18N__ = i18n2;
        }
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject(options22[0])) {
          const opts = options22[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app2, i18n2, ...options22);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app2.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
        if (false) {
          const ret = await enableDevTools(app2, i18n2);
          if (!ret) {
            throw createI18nError(I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
          }
          const emitter = createEmitter();
          if (__legacyMode) {
            const _vueI18n = __global;
            _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          } else {
            const _composer = __global;
            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
          }
          emitter.on("*", addTimelineEvent);
        }
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
__name(createI18n, "createI18n");
function useI18n(options3 = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options3, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n2.mode === "legacy" && !options3.__useComponent) {
      if (!i18n2.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options3);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options3, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance, options3.__useComponent);
    if (composer2 == null) {
      if (false) {
        warn$1(getWarnMessage(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
      }
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$2({}, options3);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
__name(useI18n, "useI18n");
const castToVueI18n = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (i18n2) => {
  if (!(__VUE_I18N_BRIDGE__ in i18n2)) {
    throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
  }
  return i18n2;
}, "castToVueI18n");
function createGlobal(options3, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options3)) : scope.run(() => createComposer(options3));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
__name(createGlobal, "createGlobal");
function getI18nInstance(instance) {
  {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
__name(getI18nInstance, "getI18nInstance");
function getScope(options3, componentOptions) {
  return isEmptyObject(options3) ? "__i18n" in componentOptions ? "local" : "global" : !options3.useScope ? "local" : options3.useScope;
}
__name(getScope, "getScope");
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
__name(getGlobalComposer, "getGlobalComposer");
function getComposer(i18n2, target, useComponent = false) {
  let composer = null;
  const root23 = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root23 === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
__name(getComposer, "getComposer");
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
__name(getParentComponentInstance, "getParentComponentInstance");
function setupLifeCycle(i18n2, target, composer) {
  let emitter = null;
  {
    onMounted(() => {
      if (false) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter();
        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on("*", addTimelineEvent);
      }
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      if (false) {
        emitter && emitter.off("*", addTimelineEvent);
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }
      i18n2.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
__name(setupLifeCycle, "setupLifeCycle");
function useI18nForLegacy(instance, scope, root23, options3 = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean$1(options3.inheritLocale) ? options3.inheritLocale : !isString$2(options3.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root23.locale.value : isString$2(options3.locale) ? options3.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root23.fallbackLocale.value : isString$2(options3.fallbackLocale) || isArray$2(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options3));
  const _datetimeFormats = ref(isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root23.missingWarn : isBoolean$1(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root23.fallbackWarn : isBoolean$1(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root23.fallbackRoot : isBoolean$1(options3.fallbackRoot) ? options3.fallbackRoot : true;
  const _fallbackFormat = !!options3.fallbackFormat;
  const _missing = isFunction(options3.missing) ? options3.missing : null;
  const _postTranslation = isFunction(options3.postTranslation) ? options3.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root23.warnHtmlMessage : isBoolean$1(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  const _escapeParameter = !!options3.escapeParameter;
  const _modifiers = isLocalScope ? root23.modifiers : isPlainObject(options3.modifiers) ? options3.modifiers : {};
  const _pluralRules = options3.pluralRules || isLocalScope && root23.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  __name(trackReactivityValues, "trackReactivityValues");
  const locale2 = computed({
    get: /* @__PURE__ */ __name(() => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    }, "get"),
    set: /* @__PURE__ */ __name((val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }, "set")
  });
  const fallbackLocale = computed({
    get: /* @__PURE__ */ __name(() => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    }, "get"),
    set: /* @__PURE__ */ __name((val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }, "set")
  });
  const messages2 = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  __name(getPostTranslationHandler, "getPostTranslationHandler");
  function setPostTranslationHandler(handler6) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler6);
    }
  }
  __name(setPostTranslationHandler, "setPostTranslationHandler");
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  __name(getMissingHandler, "getMissingHandler");
  function setMissingHandler(handler6) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler6);
    }
  }
  __name(setMissingHandler, "setMissingHandler");
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  __name(warpWithDeps, "warpWithDeps");
  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  __name(t, "t");
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  __name(rt, "rt");
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  __name(d, "d");
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  __name(n, "n");
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  __name(tm, "tm");
  function te(key, locale22) {
    return _composer.value ? _composer.value.te(key, locale22) : false;
  }
  __name(te, "te");
  function getLocaleMessage(locale22) {
    return _composer.value ? _composer.value.getLocaleMessage(locale22) : {};
  }
  __name(getLocaleMessage, "getLocaleMessage");
  function setLocaleMessage(locale22, message2) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale22, message2);
      _messages.value[locale22] = message2;
    }
  }
  __name(setLocaleMessage, "setLocaleMessage");
  function mergeLocaleMessage(locale22, message2) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale22, message2);
    }
  }
  __name(mergeLocaleMessage, "mergeLocaleMessage");
  function getDateTimeFormat(locale22) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale22) : {};
  }
  __name(getDateTimeFormat, "getDateTimeFormat");
  function setDateTimeFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale22, format2);
      _datetimeFormats.value[locale22] = format2;
    }
  }
  __name(setDateTimeFormat, "setDateTimeFormat");
  function mergeDateTimeFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale22, format2);
    }
  }
  __name(mergeDateTimeFormat, "mergeDateTimeFormat");
  function getNumberFormat(locale22) {
    return _composer.value ? _composer.value.getNumberFormat(locale22) : {};
  }
  __name(getNumberFormat, "getNumberFormat");
  function setNumberFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale22, format2);
      _numberFormats.value[locale22] = format2;
    }
  }
  __name(setNumberFormat, "setNumberFormat");
  function mergeNumberFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale22, format2);
    }
  }
  __name(mergeNumberFormat, "mergeNumberFormat");
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale22) => {
      composer.mergeLocaleMessage(locale22, _messages.value[locale22]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale22) => {
      composer.mergeDateTimeFormat(locale22, _datetimeFormats.value[locale22]);
    });
    Object.keys(_numberFormats.value).forEach((locale22) => {
      composer.mergeNumberFormat(locale22, _numberFormats.value[locale22]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  __name(sync, "sync");
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
__name(useI18nForLegacy, "useI18nForLegacy");
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop2) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop2);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop2, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = /* @__PURE__ */ __name(() => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  }, "dispose");
  return dispose;
}
__name(injectGlobalFields, "injectGlobalFields");
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
if (false) ;
function isElectron() {
  return "electronAPI" in window && window["electronAPI"] !== void 0;
}
__name(isElectron, "isElectron");
function electronAPI() {
  return window["electronAPI"];
}
__name(electronAPI, "electronAPI");
const useElectronDownloadStore = /* @__PURE__ */ defineStore("downloads", () => {
  const downloads = ref([]);
  const { DownloadManager } = electronAPI();
  const findByUrl = /* @__PURE__ */ __name((url) => downloads.value.find((download2) => url === download2.url), "findByUrl");
  const initialize2 = /* @__PURE__ */ __name(async () => {
    if (isElectron()) {
      const allDownloads = await DownloadManager.getAllDownloads();
      for (const download2 of allDownloads) {
        downloads.value.push(download2);
      }
      DownloadManager.onDownloadProgress((data22) => {
        if (!findByUrl(data22.url)) {
          downloads.value.push(data22);
        }
        const download2 = findByUrl(data22.url);
        if (download2) {
          download2.progress = data22.progress;
          download2.status = data22.status;
          download2.filename = data22.filename;
          download2.savePath = data22.savePath;
        }
      });
    }
  }, "initialize");
  void initialize2();
  const start2 = /* @__PURE__ */ __name(({
    url,
    savePath,
    filename
  }) => DownloadManager.startDownload(url, savePath, filename), "start");
  const pause = /* @__PURE__ */ __name((url) => DownloadManager.pauseDownload(url), "pause");
  const resume = /* @__PURE__ */ __name((url) => DownloadManager.resumeDownload(url), "resume");
  const cancel = /* @__PURE__ */ __name((url) => DownloadManager.cancelDownload(url), "cancel");
  return {
    downloads,
    start: start2,
    pause,
    resume,
    cancel,
    findByUrl,
    initialize: initialize2
  };
});
const _hoisted_1$15 = { class: "flex flex-col" };
const _hoisted_2$Q = { class: "flex flex-row items-center gap-2" };
const _hoisted_3$r = { class: "file-info" };
const _hoisted_4$j = { class: "file-details" };
const _hoisted_5$d = ["title"];
const _hoisted_6$9 = {
  key: 0,
  class: "file-error"
};
const _hoisted_7$4 = { class: "file-action" };
const _hoisted_8$3 = {
  key: 0,
  class: "flex flex-row items-center gap-2"
};
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "ElectronFileDownload",
  props: {
    url: {},
    hint: {},
    label: {},
    error: {}
  },
  setup(__props) {
    const props = __props;
    const { t } = useI18n();
    const { DownloadManager } = electronAPI();
    const label5 = computed(() => props.label || props.url.split("/").pop());
    const hint = computed(() => props.hint || props.url);
    const download2 = useDownload(props.url);
    const downloadProgress = ref(0);
    const status = ref(null);
    const fileSize = computed(
      () => download2.fileSize.value ? formatSize(download2.fileSize.value) : "?"
    );
    const electronDownloadStore = useElectronDownloadStore();
    const [savePath, filename] = props.label.split("/");
    electronDownloadStore.$subscribe((mutation, { downloads }) => {
      const download22 = downloads.find((download3) => props.url === download3.url);
      if (download22) {
        downloadProgress.value = Number((download22.progress * 100).toFixed(1));
        status.value = download22.status;
      }
    });
    const triggerDownload = /* @__PURE__ */ __name(async () => {
      await electronDownloadStore.start({
        url: props.url,
        savePath: savePath.trim(),
        filename: filename.trim()
      });
    }, "triggerDownload");
    const triggerCancelDownload = /* @__PURE__ */ __name(() => electronDownloadStore.cancel(props.url), "triggerCancelDownload");
    const triggerPauseDownload = /* @__PURE__ */ __name(() => electronDownloadStore.pause(props.url), "triggerPauseDownload");
    const triggerResumeDownload = /* @__PURE__ */ __name(() => electronDownloadStore.resume(props.url), "triggerResumeDownload");
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$15, [
        createBaseVNode("div", _hoisted_2$Q, [
          createBaseVNode("div", _hoisted_3$r, [
            createBaseVNode("div", _hoisted_4$j, [
              createBaseVNode("span", {
                class: "file-type",
                title: hint.value
              }, toDisplayString$1(label5.value), 9, _hoisted_5$d)
            ]),
            props.error ? (openBlock(), createElementBlock("div", _hoisted_6$9, toDisplayString$1(props.error), 1)) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_7$4, [
            status.value === null || status.value === "error" ? (openBlock(), createBlock(unref(script$M), {
              key: 0,
              class: "file-action-button",
              label: _ctx.$t("download") + " (" + fileSize.value + ")",
              size: "small",
              outlined: "",
              disabled: props.error,
              onClick: triggerDownload,
              icon: "pi pi-download"
            }, null, 8, ["label", "disabled"])) : createCommentVNode("", true)
          ])
        ]),
        status.value === "in_progress" || status.value === "paused" ? (openBlock(), createElementBlock("div", _hoisted_8$3, [
          createVNode(unref(script$K), {
            class: "flex-1",
            value: downloadProgress.value
          }, null, 8, ["value"]),
          status.value === "in_progress" ? withDirectives((openBlock(), createBlock(unref(script$M), {
            key: 0,
            class: "file-action-button",
            size: "small",
            outlined: "",
            disabled: props.error,
            onClick: triggerPauseDownload,
            icon: "pi pi-pause-circle"
          }, null, 8, ["disabled"])), [
            [
              _directive_tooltip,
              unref(t)("electronFileDownload.pause"),
              void 0,
              { top: true }
            ]
          ]) : createCommentVNode("", true),
          status.value === "paused" ? withDirectives((openBlock(), createBlock(unref(script$M), {
            key: 1,
            class: "file-action-button",
            size: "small",
            outlined: "",
            disabled: props.error,
            onClick: triggerResumeDownload,
            icon: "pi pi-play-circle"
          }, null, 8, ["disabled"])), [
            [
              _directive_tooltip,
              unref(t)("electronFileDownload.resume"),
              void 0,
              { top: true }
            ]
          ]) : createCommentVNode("", true),
          withDirectives(createVNode(unref(script$M), {
            class: "file-action-button",
            size: "small",
            outlined: "",
            disabled: props.error,
            onClick: triggerCancelDownload,
            icon: "pi pi-times-circle",
            severity: "danger"
          }, null, 8, ["disabled"]), [
            [
              _directive_tooltip,
              unref(t)("electronFileDownload.cancel"),
              void 0,
              { top: true }
            ]
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$14 = { class: "flex flex-row items-center gap-2" };
const _hoisted_2$P = { class: "file-info" };
const _hoisted_3$q = { class: "file-details" };
const _hoisted_4$i = ["title"];
const _hoisted_5$c = {
  key: 0,
  class: "file-error"
};
const _hoisted_6$8 = { class: "file-action" };
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "FileDownload",
  props: {
    url: {},
    hint: {},
    label: {},
    error: {}
  },
  setup(__props) {
    const props = __props;
    const label5 = computed(() => props.label || props.url.split("/").pop());
    const hint = computed(() => props.hint || props.url);
    const download2 = useDownload(props.url);
    const fileSize = computed(
      () => download2.fileSize.value ? formatSize(download2.fileSize.value) : "?"
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$14, [
        createBaseVNode("div", _hoisted_2$P, [
          createBaseVNode("div", _hoisted_3$q, [
            createBaseVNode("span", {
              class: "file-type",
              title: hint.value
            }, toDisplayString$1(label5.value), 9, _hoisted_4$i)
          ]),
          props.error ? (openBlock(), createElementBlock("div", _hoisted_5$c, toDisplayString$1(props.error), 1)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_6$8, [
          createVNode(unref(script$M), {
            class: "file-action-button",
            label: _ctx.$t("download") + " (" + fileSize.value + ")",
            size: "small",
            outlined: "",
            disabled: props.error,
            title: props.url,
            onClick: unref(download2).triggerBrowserDownload
          }, null, 8, ["label", "disabled", "title", "onClick"])
        ])
      ]);
    };
  }
});
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "MissingModelsWarning",
  props: {
    missingModels: {},
    paths: {}
  },
  setup(__props) {
    const allowedSources = [
      "https://civitai.com/",
      "https://huggingface.co/",
      "http://localhost:"
      // Included for testing usage only
    ];
    const allowedSuffixes = [".safetensors", ".sft"];
    const props = __props;
    const modelDownloads = ref({});
    const missingModels = computed(() => {
      return props.missingModels.map((model) => {
        const paths = props.paths[model.directory];
        if (model.directory_invalid || !paths) {
          return {
            label: `${model.directory} / ${model.name}`,
            url: model.url,
            error: "Invalid directory specified (does this require custom nodes?)"
          };
        }
        const downloadInfo = modelDownloads.value[model.name] ?? {
          downloading: false,
          completed: false,
          progress: 0,
          error: null,
          name: model.name,
          directory: model.directory,
          url: model.url,
          folder_path: paths[0]
        };
        modelDownloads.value[model.name] = downloadInfo;
        if (!allowedSources.some((source) => model.url.startsWith(source))) {
          return {
            label: `${model.directory} / ${model.name}`,
            url: model.url,
            error: `Download not allowed from source '${model.url}', only allowed from '${allowedSources.join("', '")}'`
          };
        }
        if (!allowedSuffixes.some((suffix2) => model.name.endsWith(suffix2))) {
          return {
            label: `${model.directory} / ${model.name}`,
            url: model.url,
            error: `Only allowed suffixes are: '${allowedSuffixes.join("', '")}'`
          };
        }
        return {
          url: model.url,
          label: `${model.directory} / ${model.name}`,
          downloading: downloadInfo.downloading,
          completed: downloadInfo.completed,
          progress: downloadInfo.progress,
          error: downloadInfo.error,
          name: model.name,
          paths,
          folderPath: downloadInfo.folder_path
        };
      });
    });
    return (_ctx, _cache) => {
      const _component_ElectronFileDownload = _sfc_main$K;
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(NoResultsPlaceholder, {
          class: "pb-0",
          icon: "pi pi-exclamation-circle",
          title: "Missing Models",
          message: "When loading the graph, the following models were not found"
        }),
        createVNode(unref(script$O), {
          options: missingModels.value,
          class: "comfy-missing-models"
        }, {
          option: withCtx(({ option: option3 }) => [
            unref(isElectron)() ? (openBlock(), createBlock(Suspense, { key: 0 }, {
              default: withCtx(() => [
                createVNode(_component_ElectronFileDownload, {
                  url: option3.url,
                  label: option3.label,
                  error: option3.error
                }, null, 8, ["url", "label", "error"])
              ]),
              _: 2
            }, 1024)) : (openBlock(), createBlock(_sfc_main$J, {
              key: 1,
              url: option3.url,
              label: option3.label,
              error: option3.error
            }, null, 8, ["url", "label", "error"]))
          ]),
          _: 1
        }, 8, ["options"])
      ], 64);
    };
  }
});
const MissingModelsWarning = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__scopeId", "data-v-8528eb79"]]);
var theme$p = /* @__PURE__ */ __name(function theme12(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-tabs {\n    display: flex;\n    flex-direction: column;\n}\n\n.p-tablist {\n    display: flex;\n    position: relative;\n}\n\n.p-tabs-scrollable > .p-tablist {\n    overflow: hidden;\n}\n\n.p-tablist-viewport {\n    overflow-x: auto;\n    overflow-y: hidden;\n    scroll-behavior: smooth;\n    scrollbar-width: none;\n    overscroll-behavior: contain auto;\n}\n\n.p-tablist-viewport::-webkit-scrollbar {\n    display: none;\n}\n\n.p-tablist-tab-list {\n    position: relative;\n    display: flex;\n    background: ".concat(dt2("tabs.tablist.background"), ";\n    border-style: solid;\n    border-color: ").concat(dt2("tabs.tablist.border.color"), ";\n    border-width: ").concat(dt2("tabs.tablist.border.width"), ";\n}\n\n.p-tablist-content {\n    flex-grow: 1;\n}\n\n.p-tablist-nav-button {\n    all: unset;\n    position: absolute !important;\n    flex-shrink: 0;\n    top: 0;\n    z-index: 2;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: ").concat(dt2("tabs.nav.button.background"), ";\n    color: ").concat(dt2("tabs.nav.button.color"), ";\n    width: ").concat(dt2("tabs.nav.button.width"), ";\n    transition: color ").concat(dt2("tabs.transition.duration"), ", outline-color ").concat(dt2("tabs.transition.duration"), ", box-shadow ").concat(dt2("tabs.transition.duration"), ";\n    box-shadow: ").concat(dt2("tabs.nav.button.shadow"), ";\n    outline-color: transparent;\n    cursor: pointer;\n}\n\n.p-tablist-nav-button:focus-visible {\n    z-index: 1;\n    box-shadow: ").concat(dt2("tabs.nav.button.focus.ring.shadow"), ";\n    outline: ").concat(dt2("tabs.nav.button.focus.ring.width"), " ").concat(dt2("tabs.nav.button.focus.ring.style"), " ").concat(dt2("tabs.nav.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("tabs.nav.button.focus.ring.offset"), ";\n}\n\n.p-tablist-nav-button:hover {\n    color: ").concat(dt2("tabs.nav.button.hover.color"), ";\n}\n\n.p-tablist-prev-button {\n    left: 0;\n}\n\n.p-tablist-next-button {\n    right: 0;\n}\n\n.p-tab {\n    flex-shrink: 0;\n    cursor: pointer;\n    user-select: none;\n    position: relative;\n    border-style: solid;\n    white-space: nowrap;\n    background: ").concat(dt2("tabs.tab.background"), ";\n    border-width: ").concat(dt2("tabs.tab.border.width"), ";\n    border-color: ").concat(dt2("tabs.tab.border.color"), ";\n    color: ").concat(dt2("tabs.tab.color"), ";\n    padding: ").concat(dt2("tabs.tab.padding"), ";\n    font-weight: ").concat(dt2("tabs.tab.font.weight"), ";\n    transition: background ").concat(dt2("tabs.transition.duration"), ", border-color ").concat(dt2("tabs.transition.duration"), ", color ").concat(dt2("tabs.transition.duration"), ", outline-color ").concat(dt2("tabs.transition.duration"), ", box-shadow ").concat(dt2("tabs.transition.duration"), ";\n    margin: ").concat(dt2("tabs.tab.margin"), ";\n    outline-color: transparent;\n}\n\n.p-tab:not(.p-disabled):focus-visible {\n    z-index: 1;\n    box-shadow: ").concat(dt2("tabs.tab.focus.ring.shadow"), ";\n    outline: ").concat(dt2("tabs.tab.focus.ring.width"), " ").concat(dt2("tabs.tab.focus.ring.style"), " ").concat(dt2("tabs.tab.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("tabs.tab.focus.ring.offset"), ";\n}\n\n.p-tab:not(.p-tab-active):not(.p-disabled):hover {\n    background: ").concat(dt2("tabs.tab.hover.background"), ";\n    border-color: ").concat(dt2("tabs.tab.hover.border.color"), ";\n    color: ").concat(dt2("tabs.tab.hover.color"), ";\n}\n\n.p-tab-active {\n    background: ").concat(dt2("tabs.tab.active.background"), ";\n    border-color: ").concat(dt2("tabs.tab.active.border.color"), ";\n    color: ").concat(dt2("tabs.tab.active.color"), ";\n}\n\n.p-tabpanels {\n    background: ").concat(dt2("tabs.tabpanel.background"), ";\n    color: ").concat(dt2("tabs.tabpanel.color"), ";\n    padding: ").concat(dt2("tabs.tabpanel.padding"), ";\n    outline: 0 none;\n}\n\n.p-tabpanel:focus-visible {\n    box-shadow: ").concat(dt2("tabs.tabpanel.focus.ring.shadow"), ";\n    outline: ").concat(dt2("tabs.tabpanel.focus.ring.width"), " ").concat(dt2("tabs.tabpanel.focus.ring.style"), " ").concat(dt2("tabs.tabpanel.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("tabs.tabpanel.focus.ring.offset"), ";\n}\n\n.p-tablist-active-bar {\n    z-index: 1;\n    display: block;\n    position: absolute;\n    bottom: ").concat(dt2("tabs.active.bar.bottom"), ";\n    height: ").concat(dt2("tabs.active.bar.height"), ";\n    background: ").concat(dt2("tabs.active.bar.background"), ";\n    transition: 250ms cubic-bezier(0.35, 0, 0.25, 1);\n}\n");
}, "theme");
var classes$r = {
  root: /* @__PURE__ */ __name(function root6(_ref2) {
    var props = _ref2.props;
    return ["p-tabs p-component", {
      "p-tabs-scrollable": props.scrollable
    }];
  }, "root")
};
var TabsStyle = BaseStyle.extend({
  name: "tabs",
  theme: theme$p,
  classes: classes$r
});
var script$1$q = {
  name: "BaseTabs",
  "extends": script$Y,
  props: {
    value: {
      type: [String, Number],
      "default": void 0
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    scrollable: {
      type: Boolean,
      "default": false
    },
    showNavigators: {
      type: Boolean,
      "default": true
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    }
  },
  style: TabsStyle,
  provide: /* @__PURE__ */ __name(function provide12() {
    return {
      $pcTabs: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$J = {
  name: "Tabs",
  "extends": script$1$q,
  inheritAttrs: false,
  emits: ["update:value"],
  data: /* @__PURE__ */ __name(function data3() {
    return {
      id: this.$attrs.id,
      d_value: this.value
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId2(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    value: /* @__PURE__ */ __name(function value(newValue) {
      this.d_value = newValue;
    }, "value")
  },
  mounted: /* @__PURE__ */ __name(function mounted4() {
    this.id = this.id || UniqueComponentId();
  }, "mounted"),
  methods: {
    updateValue: /* @__PURE__ */ __name(function updateValue(newValue) {
      if (this.d_value !== newValue) {
        this.d_value = newValue;
        this.$emit("update:value", newValue);
      }
    }, "updateValue"),
    isVertical: /* @__PURE__ */ __name(function isVertical2() {
      return this.orientation === "vertical";
    }, "isVertical")
  }
};
function render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$I, "render$I");
script$J.render = render$I;
var classes$q = {
  root: "p-tabpanels"
};
var TabPanelsStyle = BaseStyle.extend({
  name: "tabpanels",
  classes: classes$q
});
var script$1$p = {
  name: "BaseTabPanels",
  "extends": script$Y,
  props: {},
  style: TabPanelsStyle,
  provide: /* @__PURE__ */ __name(function provide13() {
    return {
      $pcTabPanels: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$I = {
  name: "TabPanels",
  "extends": script$1$p,
  inheritAttrs: false
};
function render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "presentation"
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$H, "render$H");
script$I.render = render$H;
var classes$p = {
  root: /* @__PURE__ */ __name(function root7(_ref) {
    var instance = _ref.instance;
    return ["p-tabpanel", {
      "p-tabpanel-active": instance.active
    }];
  }, "root")
};
var TabPanelStyle = BaseStyle.extend({
  name: "tabpanel",
  classes: classes$p
});
var script$1$o = {
  name: "BaseTabPanel",
  "extends": script$Y,
  props: {
    // in Tabs
    value: {
      type: [String, Number],
      "default": void 0
    },
    as: {
      type: [String, Object],
      "default": "DIV"
    },
    asChild: {
      type: Boolean,
      "default": false
    },
    // in TabView
    header: null,
    headerStyle: null,
    headerClass: null,
    headerProps: null,
    headerActionProps: null,
    contentStyle: null,
    contentClass: null,
    contentProps: null,
    disabled: Boolean
  },
  style: TabPanelStyle,
  provide: /* @__PURE__ */ __name(function provide14() {
    return {
      $pcTabPanel: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$H = {
  name: "TabPanel",
  "extends": script$1$o,
  inheritAttrs: false,
  inject: ["$pcTabs"],
  computed: {
    active: /* @__PURE__ */ __name(function active() {
      var _this$$pcTabs;
      return equals((_this$$pcTabs = this.$pcTabs) === null || _this$$pcTabs === void 0 ? void 0 : _this$$pcTabs.d_value, this.value);
    }, "active"),
    id: /* @__PURE__ */ __name(function id2() {
      var _this$$pcTabs2;
      return "".concat((_this$$pcTabs2 = this.$pcTabs) === null || _this$$pcTabs2 === void 0 ? void 0 : _this$$pcTabs2.id, "_tabpanel_").concat(this.value);
    }, "id"),
    ariaLabelledby: /* @__PURE__ */ __name(function ariaLabelledby() {
      var _this$$pcTabs3;
      return "".concat((_this$$pcTabs3 = this.$pcTabs) === null || _this$$pcTabs3 === void 0 ? void 0 : _this$$pcTabs3.id, "_tab_").concat(this.value);
    }, "ariaLabelledby"),
    attrs: /* @__PURE__ */ __name(function attrs2() {
      return mergeProps(this.a11yAttrs, this.ptmi("root", this.ptParams));
    }, "attrs"),
    a11yAttrs: /* @__PURE__ */ __name(function a11yAttrs2() {
      var _this$$pcTabs4;
      return {
        id: this.id,
        tabindex: (_this$$pcTabs4 = this.$pcTabs) === null || _this$$pcTabs4 === void 0 ? void 0 : _this$$pcTabs4.tabindex,
        role: "tabpanel",
        "aria-labelledby": this.ariaLabelledby,
        "data-pc-name": "tabpanel",
        "data-p-active": this.active
      };
    }, "a11yAttrs"),
    ptParams: /* @__PURE__ */ __name(function ptParams() {
      return {
        context: {
          active: this.active
        }
      };
    }, "ptParams")
  }
};
function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  var _$options$$pcTabs, _$options$$pcTabs2;
  return !$options.$pcTabs ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [!_ctx.asChild ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [((_$options$$pcTabs = $options.$pcTabs) !== null && _$options$$pcTabs !== void 0 && _$options$$pcTabs.lazy ? $options.active : true) ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.as), mergeProps({
    key: 0,
    "class": _ctx.cx("root")
  }, $options.attrs), {
    "default": withCtx(function() {
      return [renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
  }, 16, ["class"])), [[vShow, (_$options$$pcTabs2 = $options.$pcTabs) !== null && _$options$$pcTabs2 !== void 0 && _$options$$pcTabs2.lazy ? true : $options.active]]) : createCommentVNode("", true)], 64)) : renderSlot(_ctx.$slots, "default", {
    key: 1,
    "class": normalizeClass(_ctx.cx("root")),
    active: $options.active,
    a11yAttrs: $options.a11yAttrs
  })], 64));
}
__name(render$G, "render$G");
script$H.render = render$G;
var theme$o = /* @__PURE__ */ __name(function theme13(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-divider-horizontal {\n    display: flex;\n    width: 100%;\n    position: relative;\n    align-items: center;\n    margin: ".concat(dt2("divider.horizontal.margin"), ";\n    padding: ").concat(dt2("divider.horizontal.padding"), ';\n}\n\n.p-divider-horizontal:before {\n    position: absolute;\n    display: block;\n    top: 50%;\n    left: 0;\n    width: 100%;\n    content: "";\n    border-top: 1px solid ').concat(dt2("divider.border.color"), ";\n}\n\n.p-divider-horizontal .p-divider-content {\n    padding: ").concat(dt2("divider.horizontal.content.padding"), ";\n}\n\n.p-divider-vertical {\n    min-height: 100%;\n    margin: 0 1rem;\n    display: flex;\n    position: relative;\n    justify-content: center;\n    margin: ").concat(dt2("divider.vertical.margin"), ";\n    padding: ").concat(dt2("divider.vertical.padding"), ';\n}\n\n.p-divider-vertical:before {\n    position: absolute;\n    display: block;\n    top: 0;\n    left: 50%;\n    height: 100%;\n    content: "";\n    border-left: 1px solid ').concat(dt2("divider.border.color"), ";\n}\n\n.p-divider.p-divider-vertical .p-divider-content {\n    padding: ").concat(dt2("divider.vertical.content.padding"), ";\n}\n\n.p-divider-content {\n    z-index: 1;\n    background: ").concat(dt2("divider.content.background"), ";\n    color: ").concat(dt2("divider.content.color"), ";\n}\n\n.p-divider-solid.p-divider-horizontal:before {\n    border-top-style: solid;\n}\n\n.p-divider-solid.p-divider-vertical:before {\n    border-left-style: solid;\n}\n\n.p-divider-dashed.p-divider-horizontal:before {\n    border-top-style: dashed;\n}\n\n.p-divider-dashed.p-divider-vertical:before {\n    border-left-style: dashed;\n}\n\n.p-divider-dotted.p-divider-horizontal:before {\n    border-top-style: dotted;\n}\n\n.p-divider-dotted.p-divider-vertical:before {\n    border-left-style: dotted;\n}\n");
}, "theme");
var inlineStyles$3 = {
  root: /* @__PURE__ */ __name(function root8(_ref2) {
    var props = _ref2.props;
    return {
      justifyContent: props.layout === "horizontal" ? props.align === "center" || props.align === null ? "center" : props.align === "left" ? "flex-start" : props.align === "right" ? "flex-end" : null : null,
      alignItems: props.layout === "vertical" ? props.align === "center" || props.align === null ? "center" : props.align === "top" ? "flex-start" : props.align === "bottom" ? "flex-end" : null : null
    };
  }, "root")
};
var classes$o = {
  root: /* @__PURE__ */ __name(function root9(_ref3) {
    var props = _ref3.props;
    return ["p-divider p-component", "p-divider-" + props.layout, "p-divider-" + props.type, {
      "p-divider-left": props.layout === "horizontal" && (!props.align || props.align === "left")
    }, {
      "p-divider-center": props.layout === "horizontal" && props.align === "center"
    }, {
      "p-divider-right": props.layout === "horizontal" && props.align === "right"
    }, {
      "p-divider-top": props.layout === "vertical" && props.align === "top"
    }, {
      "p-divider-center": props.layout === "vertical" && (!props.align || props.align === "center")
    }, {
      "p-divider-bottom": props.layout === "vertical" && props.align === "bottom"
    }];
  }, "root"),
  content: "p-divider-content"
};
var DividerStyle = BaseStyle.extend({
  name: "divider",
  theme: theme$o,
  classes: classes$o,
  inlineStyles: inlineStyles$3
});
var script$1$n = {
  name: "BaseDivider",
  "extends": script$Y,
  props: {
    align: {
      type: String,
      "default": null
    },
    layout: {
      type: String,
      "default": "horizontal"
    },
    type: {
      type: String,
      "default": "solid"
    }
  },
  style: DividerStyle,
  provide: /* @__PURE__ */ __name(function provide15() {
    return {
      $pcDivider: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$G = {
  name: "Divider",
  "extends": script$1$n,
  inheritAttrs: false
};
var _hoisted_1$13 = ["aria-orientation"];
function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    style: _ctx.sx("root"),
    role: "separator",
    "aria-orientation": _ctx.layout
  }, _ctx.ptmi("root")), [_ctx.$slots["default"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("content")
  }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "default")], 16)) : createCommentVNode("", true)], 16, _hoisted_1$13);
}
__name(render$F, "render$F");
script$G.render = render$F;
var theme$n = /* @__PURE__ */ __name(function theme14(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-scrollpanel-content-container {\n    overflow: hidden;\n    width: 100%;\n    height: 100%;\n    position: relative;\n    z-index: 1;\n    float: left;\n}\n\n.p-scrollpanel-content {\n    height: calc(100% + calc(2 * ".concat(dt2("scrollpanel.bar.size"), "));\n    width: calc(100% + calc(2 * ").concat(dt2("scrollpanel.bar.size"), "));\n    padding: 0 calc(2 * ").concat(dt2("scrollpanel.bar.size"), ") calc(2 * ").concat(dt2("scrollpanel.bar.size"), ") 0;\n    position: relative;\n    overflow: auto;\n    box-sizing: border-box;\n    scrollbar-width: none;\n}\n\n.p-scrollpanel-content::-webkit-scrollbar {\n    display: none;\n}\n\n.p-scrollpanel-bar {\n    position: relative;\n    border-radius: ").concat(dt2("scrollpanel.bar.border.radius"), ";\n    z-index: 2;\n    cursor: pointer;\n    opacity: 0;\n    outline-color: transparent;\n    transition: outline-color ").concat(dt2("scrollpanel.transition.duration"), ";\n    background: ").concat(dt2("scrollpanel.bar.background"), ";\n    border: 0 none;\n    transition: outline-color ").concat(dt2("scrollpanel.transition.duration"), ", opacity ").concat(dt2("scrollpanel.transition.duration"), ";\n}\n\n.p-scrollpanel-bar:focus-visible {\n    box-shadow: ").concat(dt2("scrollpanel.bar.focus.ring.shadow"), ";\n    outline: ").concat(dt2("scrollpanel.barfocus.ring.width"), " ").concat(dt2("scrollpanel.bar.focus.ring.style"), " ").concat(dt2("scrollpanel.bar.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("scrollpanel.barfocus.ring.offset"), ";\n}\n\n.p-scrollpanel-bar-y {\n    width: ").concat(dt2("scrollpanel.bar.size"), ";\n    top: 0;\n}\n\n.p-scrollpanel-bar-x {\n    height: ").concat(dt2("scrollpanel.bar.size"), ";\n    bottom: 0;\n}\n\n.p-scrollpanel-hidden {\n    visibility: hidden;\n}\n\n.p-scrollpanel:hover .p-scrollpanel-bar,\n.p-scrollpanel:active .p-scrollpanel-bar {\n    opacity: 1;\n}\n\n.p-scrollpanel-grabbed {\n    user-select: none;\n}\n");
}, "theme");
var classes$n = {
  root: "p-scrollpanel p-component",
  contentContainer: "p-scrollpanel-content-container",
  content: "p-scrollpanel-content",
  barX: "p-scrollpanel-bar p-scrollpanel-bar-x",
  barY: "p-scrollpanel-bar p-scrollpanel-bar-y"
};
var ScrollPanelStyle = BaseStyle.extend({
  name: "scrollpanel",
  theme: theme$n,
  classes: classes$n
});
var script$1$m = {
  name: "BaseScrollPanel",
  "extends": script$Y,
  props: {
    step: {
      type: Number,
      "default": 5
    }
  },
  style: ScrollPanelStyle,
  provide: /* @__PURE__ */ __name(function provide16() {
    return {
      $pcScrollPanel: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$F = {
  name: "ScrollPanel",
  "extends": script$1$m,
  inheritAttrs: false,
  initialized: false,
  documentResizeListener: null,
  documentMouseMoveListener: null,
  documentMouseUpListener: null,
  frame: null,
  scrollXRatio: null,
  scrollYRatio: null,
  isXBarClicked: false,
  isYBarClicked: false,
  lastPageX: null,
  lastPageY: null,
  timer: null,
  outsideClickListener: null,
  data: /* @__PURE__ */ __name(function data4() {
    return {
      id: this.$attrs.id,
      orientation: "vertical",
      lastScrollTop: 0,
      lastScrollLeft: 0
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId3(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId")
  },
  mounted: /* @__PURE__ */ __name(function mounted5() {
    this.id = this.id || UniqueComponentId();
    if (this.$el.offsetParent) {
      this.initialize();
    }
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated3() {
    if (!this.initialized && this.$el.offsetParent) {
      this.initialize();
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount2() {
    this.unbindDocumentResizeListener();
    if (this.frame) {
      window.cancelAnimationFrame(this.frame);
    }
  }, "beforeUnmount"),
  methods: {
    initialize: /* @__PURE__ */ __name(function initialize() {
      this.moveBar();
      this.bindDocumentResizeListener();
      this.calculateContainerHeight();
    }, "initialize"),
    calculateContainerHeight: /* @__PURE__ */ __name(function calculateContainerHeight() {
      var containerStyles = getComputedStyle(this.$el), xBarStyles = getComputedStyle(this.$refs.xBar), pureContainerHeight = getHeight(this.$el) - parseInt(xBarStyles["height"], 10);
      if (containerStyles["max-height"] !== "none" && pureContainerHeight === 0) {
        if (this.$refs.content.offsetHeight + parseInt(xBarStyles["height"], 10) > parseInt(containerStyles["max-height"], 10)) {
          this.$el.style.height = containerStyles["max-height"];
        } else {
          this.$el.style.height = this.$refs.content.offsetHeight + parseFloat(containerStyles.paddingTop) + parseFloat(containerStyles.paddingBottom) + parseFloat(containerStyles.borderTopWidth) + parseFloat(containerStyles.borderBottomWidth) + "px";
        }
      }
    }, "calculateContainerHeight"),
    moveBar: /* @__PURE__ */ __name(function moveBar() {
      var _this = this;
      if (this.$refs.content) {
        var totalWidth = this.$refs.content.scrollWidth;
        var ownWidth = this.$refs.content.clientWidth;
        var bottom = (this.$el.clientHeight - this.$refs.xBar.clientHeight) * -1;
        this.scrollXRatio = ownWidth / totalWidth;
        var totalHeight = this.$refs.content.scrollHeight;
        var ownHeight = this.$refs.content.clientHeight;
        var right = (this.$el.clientWidth - this.$refs.yBar.clientWidth) * -1;
        this.scrollYRatio = ownHeight / totalHeight;
        this.frame = this.requestAnimationFrame(function() {
          if (_this.$refs.xBar) {
            if (_this.scrollXRatio >= 1) {
              _this.$refs.xBar.setAttribute("data-p-scrollpanel-hidden", "true");
              !_this.isUnstyled && addClass(_this.$refs.xBar, "p-scrollpanel-hidden");
            } else {
              _this.$refs.xBar.setAttribute("data-p-scrollpanel-hidden", "false");
              !_this.isUnstyled && removeClass(_this.$refs.xBar, "p-scrollpanel-hidden");
              _this.$refs.xBar.style.cssText = "width:" + Math.max(_this.scrollXRatio * 100, 10) + "%; left:" + _this.$refs.content.scrollLeft / totalWidth * 100 + "%;bottom:" + bottom + "px;";
            }
          }
          if (_this.$refs.yBar) {
            if (_this.scrollYRatio >= 1) {
              _this.$refs.yBar.setAttribute("data-p-scrollpanel-hidden", "true");
              !_this.isUnstyled && addClass(_this.$refs.yBar, "p-scrollpanel-hidden");
            } else {
              _this.$refs.yBar.setAttribute("data-p-scrollpanel-hidden", "false");
              !_this.isUnstyled && removeClass(_this.$refs.yBar, "p-scrollpanel-hidden");
              _this.$refs.yBar.style.cssText = "height:" + Math.max(_this.scrollYRatio * 100, 10) + "%; top: calc(" + _this.$refs.content.scrollTop / totalHeight * 100 + "% - " + _this.$refs.xBar.clientHeight + "px);right:" + right + "px;";
            }
          }
        });
      }
    }, "moveBar"),
    onYBarMouseDown: /* @__PURE__ */ __name(function onYBarMouseDown(e) {
      this.isYBarClicked = true;
      this.$refs.yBar.focus();
      this.lastPageY = e.pageY;
      this.$refs.yBar.setAttribute("data-p-scrollpanel-grabbed", "true");
      !this.isUnstyled && addClass(this.$refs.yBar, "p-scrollpanel-grabbed");
      document.body.setAttribute("data-p-scrollpanel-grabbed", "true");
      !this.isUnstyled && addClass(document.body, "p-scrollpanel-grabbed");
      this.bindDocumentMouseListeners();
      e.preventDefault();
    }, "onYBarMouseDown"),
    onXBarMouseDown: /* @__PURE__ */ __name(function onXBarMouseDown(e) {
      this.isXBarClicked = true;
      this.$refs.xBar.focus();
      this.lastPageX = e.pageX;
      this.$refs.yBar.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && addClass(this.$refs.xBar, "p-scrollpanel-grabbed");
      document.body.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && addClass(document.body, "p-scrollpanel-grabbed");
      this.bindDocumentMouseListeners();
      e.preventDefault();
    }, "onXBarMouseDown"),
    onScroll: /* @__PURE__ */ __name(function onScroll2(event2) {
      if (this.lastScrollLeft !== event2.target.scrollLeft) {
        this.lastScrollLeft = event2.target.scrollLeft;
        this.orientation = "horizontal";
      } else if (this.lastScrollTop !== event2.target.scrollTop) {
        this.lastScrollTop = event2.target.scrollTop;
        this.orientation = "vertical";
      }
      this.moveBar();
    }, "onScroll"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown2(event2) {
      if (this.orientation === "vertical") {
        switch (event2.code) {
          case "ArrowDown": {
            this.setTimer("scrollTop", this.step);
            event2.preventDefault();
            break;
          }
          case "ArrowUp": {
            this.setTimer("scrollTop", this.step * -1);
            event2.preventDefault();
            break;
          }
          case "ArrowLeft":
          case "ArrowRight": {
            event2.preventDefault();
            break;
          }
        }
      } else if (this.orientation === "horizontal") {
        switch (event2.code) {
          case "ArrowRight": {
            this.setTimer("scrollLeft", this.step);
            event2.preventDefault();
            break;
          }
          case "ArrowLeft": {
            this.setTimer("scrollLeft", this.step * -1);
            event2.preventDefault();
            break;
          }
          case "ArrowDown":
          case "ArrowUp": {
            event2.preventDefault();
            break;
          }
        }
      }
    }, "onKeyDown"),
    onKeyUp: /* @__PURE__ */ __name(function onKeyUp2() {
      this.clearTimer();
    }, "onKeyUp"),
    repeat: /* @__PURE__ */ __name(function repeat(bar, step2) {
      this.$refs.content[bar] += step2;
      this.moveBar();
    }, "repeat"),
    setTimer: /* @__PURE__ */ __name(function setTimer(bar, step2) {
      var _this2 = this;
      this.clearTimer();
      this.timer = setTimeout(function() {
        _this2.repeat(bar, step2);
      }, 40);
    }, "setTimer"),
    clearTimer: /* @__PURE__ */ __name(function clearTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
      }
    }, "clearTimer"),
    onDocumentMouseMove: /* @__PURE__ */ __name(function onDocumentMouseMove(e) {
      if (this.isXBarClicked) {
        this.onMouseMoveForXBar(e);
      } else if (this.isYBarClicked) {
        this.onMouseMoveForYBar(e);
      } else {
        this.onMouseMoveForXBar(e);
        this.onMouseMoveForYBar(e);
      }
    }, "onDocumentMouseMove"),
    onMouseMoveForXBar: /* @__PURE__ */ __name(function onMouseMoveForXBar(e) {
      var _this3 = this;
      var deltaX = e.pageX - this.lastPageX;
      this.lastPageX = e.pageX;
      this.frame = this.requestAnimationFrame(function() {
        _this3.$refs.content.scrollLeft += deltaX / _this3.scrollXRatio;
      });
    }, "onMouseMoveForXBar"),
    onMouseMoveForYBar: /* @__PURE__ */ __name(function onMouseMoveForYBar(e) {
      var _this4 = this;
      var deltaY = e.pageY - this.lastPageY;
      this.lastPageY = e.pageY;
      this.frame = this.requestAnimationFrame(function() {
        _this4.$refs.content.scrollTop += deltaY / _this4.scrollYRatio;
      });
    }, "onMouseMoveForYBar"),
    onFocus: /* @__PURE__ */ __name(function onFocus(event2) {
      if (this.$refs.xBar.isSameNode(event2.target)) {
        this.orientation = "horizontal";
      } else if (this.$refs.yBar.isSameNode(event2.target)) {
        this.orientation = "vertical";
      }
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur() {
      if (this.orientation === "horizontal") {
        this.orientation = "vertical";
      }
    }, "onBlur"),
    onDocumentMouseUp: /* @__PURE__ */ __name(function onDocumentMouseUp() {
      this.$refs.yBar.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && removeClass(this.$refs.yBar, "p-scrollpanel-grabbed");
      this.$refs.xBar.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && removeClass(this.$refs.xBar, "p-scrollpanel-grabbed");
      document.body.setAttribute("data-p-scrollpanel-grabbed", "false");
      !this.isUnstyled && removeClass(document.body, "p-scrollpanel-grabbed");
      this.unbindDocumentMouseListeners();
      this.isXBarClicked = false;
      this.isYBarClicked = false;
    }, "onDocumentMouseUp"),
    requestAnimationFrame: /* @__PURE__ */ __name(function requestAnimationFrame2(f) {
      var frame = window.requestAnimationFrame || this.timeoutFrame;
      return frame(f);
    }, "requestAnimationFrame"),
    refresh: /* @__PURE__ */ __name(function refresh() {
      this.moveBar();
    }, "refresh"),
    scrollTop: /* @__PURE__ */ __name(function scrollTop(_scrollTop) {
      var scrollableHeight = this.$refs.content.scrollHeight - this.$refs.content.clientHeight;
      _scrollTop = _scrollTop > scrollableHeight ? scrollableHeight : _scrollTop > 0 ? _scrollTop : 0;
      this.$refs.content.scrollTop = _scrollTop;
    }, "scrollTop"),
    timeoutFrame: /* @__PURE__ */ __name(function timeoutFrame(fn) {
      setTimeout(fn, 0);
    }, "timeoutFrame"),
    bindDocumentMouseListeners: /* @__PURE__ */ __name(function bindDocumentMouseListeners() {
      var _this5 = this;
      if (!this.documentMouseMoveListener) {
        this.documentMouseMoveListener = function(e) {
          _this5.onDocumentMouseMove(e);
        };
        document.addEventListener("mousemove", this.documentMouseMoveListener);
      }
      if (!this.documentMouseUpListener) {
        this.documentMouseUpListener = function(e) {
          _this5.onDocumentMouseUp(e);
        };
        document.addEventListener("mouseup", this.documentMouseUpListener);
      }
    }, "bindDocumentMouseListeners"),
    unbindDocumentMouseListeners: /* @__PURE__ */ __name(function unbindDocumentMouseListeners() {
      if (this.documentMouseMoveListener) {
        document.removeEventListener("mousemove", this.documentMouseMoveListener);
        this.documentMouseMoveListener = null;
      }
      if (this.documentMouseUpListener) {
        document.removeEventListener("mouseup", this.documentMouseUpListener);
        this.documentMouseUpListener = null;
      }
    }, "unbindDocumentMouseListeners"),
    bindDocumentResizeListener: /* @__PURE__ */ __name(function bindDocumentResizeListener() {
      var _this6 = this;
      if (!this.documentResizeListener) {
        this.documentResizeListener = function() {
          _this6.moveBar();
        };
        window.addEventListener("resize", this.documentResizeListener);
      }
    }, "bindDocumentResizeListener"),
    unbindDocumentResizeListener: /* @__PURE__ */ __name(function unbindDocumentResizeListener() {
      if (this.documentResizeListener) {
        window.removeEventListener("resize", this.documentResizeListener);
        this.documentResizeListener = null;
      }
    }, "unbindDocumentResizeListener")
  },
  computed: {
    contentId: /* @__PURE__ */ __name(function contentId() {
      return this.id + "_content";
    }, "contentId")
  }
};
var _hoisted_1$12 = ["id"];
var _hoisted_2$O = ["aria-controls", "aria-valuenow"];
var _hoisted_3$p = ["aria-controls", "aria-valuenow"];
function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("contentContainer")
  }, _ctx.ptm("contentContainer")), [createBaseVNode("div", mergeProps({
    ref: "content",
    id: $options.contentId,
    "class": _ctx.cx("content"),
    onScroll: _cache[0] || (_cache[0] = function() {
      return $options.onScroll && $options.onScroll.apply($options, arguments);
    }),
    onMouseenter: _cache[1] || (_cache[1] = function() {
      return $options.moveBar && $options.moveBar.apply($options, arguments);
    })
  }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "default")], 16, _hoisted_1$12)], 16), createBaseVNode("div", mergeProps({
    ref: "xBar",
    "class": _ctx.cx("barx"),
    tabindex: "0",
    role: "scrollbar",
    "aria-orientation": "horizontal",
    "aria-controls": $options.contentId,
    "aria-valuenow": $data.lastScrollLeft,
    onMousedown: _cache[2] || (_cache[2] = function() {
      return $options.onXBarMouseDown && $options.onXBarMouseDown.apply($options, arguments);
    }),
    onKeydown: _cache[3] || (_cache[3] = function($event) {
      return $options.onKeyDown($event);
    }),
    onKeyup: _cache[4] || (_cache[4] = function() {
      return $options.onKeyUp && $options.onKeyUp.apply($options, arguments);
    }),
    onFocus: _cache[5] || (_cache[5] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[6] || (_cache[6] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    })
  }, _ctx.ptm("barx"), {
    "data-pc-group-section": "bar"
  }), null, 16, _hoisted_2$O), createBaseVNode("div", mergeProps({
    ref: "yBar",
    "class": _ctx.cx("bary"),
    tabindex: "0",
    role: "scrollbar",
    "aria-orientation": "vertical",
    "aria-controls": $options.contentId,
    "aria-valuenow": $data.lastScrollTop,
    onMousedown: _cache[7] || (_cache[7] = function() {
      return $options.onYBarMouseDown && $options.onYBarMouseDown.apply($options, arguments);
    }),
    onKeydown: _cache[8] || (_cache[8] = function($event) {
      return $options.onKeyDown($event);
    }),
    onKeyup: _cache[9] || (_cache[9] = function() {
      return $options.onKeyUp && $options.onKeyUp.apply($options, arguments);
    }),
    onFocus: _cache[10] || (_cache[10] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    })
  }, _ctx.ptm("bary"), {
    "data-pc-group-section": "bar"
  }), null, 16, _hoisted_3$p)], 16);
}
__name(render$E, "render$E");
script$F.render = render$E;
var script$E = {
  name: "AngleDownIcon",
  "extends": script$X
};
var _hoisted_1$11 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M3.58659 4.5007C3.68513 4.50023 3.78277 4.51945 3.87379 4.55723C3.9648 4.59501 4.04735 4.65058 4.11659 4.7207L7.11659 7.7207L10.1166 4.7207C10.2619 4.65055 10.4259 4.62911 10.5843 4.65956C10.7427 4.69002 10.8871 4.77074 10.996 4.88976C11.1049 5.00877 11.1726 5.15973 11.1889 5.32022C11.2052 5.48072 11.1693 5.6422 11.0866 5.7807L7.58659 9.2807C7.44597 9.42115 7.25534 9.50004 7.05659 9.50004C6.85784 9.50004 6.66722 9.42115 6.52659 9.2807L3.02659 5.7807C2.88614 5.64007 2.80725 5.44945 2.80725 5.2507C2.80725 5.05195 2.88614 4.86132 3.02659 4.7207C3.09932 4.64685 3.18675 4.58911 3.28322 4.55121C3.37969 4.51331 3.48305 4.4961 3.58659 4.5007Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$N = [_hoisted_1$11];
function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$N, 16);
}
__name(render$D, "render$D");
script$E.render = render$D;
var script$D = {
  name: "AngleUpIcon",
  "extends": script$X
};
var _hoisted_1$10 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M10.4134 9.49931C10.3148 9.49977 10.2172 9.48055 10.1262 9.44278C10.0352 9.405 9.95263 9.34942 9.88338 9.27931L6.88338 6.27931L3.88338 9.27931C3.73811 9.34946 3.57409 9.3709 3.41567 9.34044C3.25724 9.30999 3.11286 9.22926 3.00395 9.11025C2.89504 8.99124 2.82741 8.84028 2.8111 8.67978C2.79478 8.51928 2.83065 8.35781 2.91338 8.21931L6.41338 4.71931C6.55401 4.57886 6.74463 4.49997 6.94338 4.49997C7.14213 4.49997 7.33276 4.57886 7.47338 4.71931L10.9734 8.21931C11.1138 8.35994 11.1927 8.55056 11.1927 8.74931C11.1927 8.94806 11.1138 9.13868 10.9734 9.27931C10.9007 9.35315 10.8132 9.41089 10.7168 9.44879C10.6203 9.48669 10.5169 9.5039 10.4134 9.49931Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$M = [_hoisted_1$10];
function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$M, 16);
}
__name(render$C, "render$C");
script$D.render = render$C;
var theme$m = /* @__PURE__ */ __name(function theme15(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-inputnumber {\n    display: inline-flex;\n    position: relative;\n}\n\n.p-inputnumber-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex: 0 0 auto;\n    cursor: pointer;\n    background: ".concat(dt2("inputnumber.button.background"), ";\n    color: ").concat(dt2("inputnumber.button.color"), ";\n    width: ").concat(dt2("inputnumber.button.width"), ";\n    transition: background ").concat(dt2("inputnumber.transition.duration"), ", color ").concat(dt2("inputnumber.transition.duration"), ", border-color ").concat(dt2("inputnumber.transition.duration"), ", outline-color ").concat(dt2("inputnumber.transition.duration"), ";\n}\n\n.p-inputnumber-button:hover {\n    background: ").concat(dt2("inputnumber.button.hover.background"), ";\n    color: ").concat(dt2("inputnumber.button.hover.color"), ";\n}\n\n.p-inputnumber-button:active {\n    background: ").concat(dt2("inputnumber.button.active.background"), ";\n    color: ").concat(dt2("inputnumber.button.active.color"), ";\n}\n\n.p-inputnumber-stacked .p-inputnumber-button {\n    position: relative;\n    border: 0 none;\n}\n\n.p-inputnumber-stacked .p-inputnumber-button-group {\n    display: flex;\n    flex-direction: column;\n    position: absolute;\n    top: 1px;\n    right: 1px;\n    height: calc(100% - 2px);\n    z-index: 1;\n}\n\n.p-inputnumber-stacked .p-inputnumber-increment-button {\n    padding: 0;\n    border-top-right-radius: calc(").concat(dt2("inputnumber.button.border.radius"), " - 1px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-decrement-button {\n    padding: 0;\n    border-bottom-right-radius: calc(").concat(dt2("inputnumber.button.border.radius"), " - 1px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-button {\n    flex: 1 1 auto;\n    border: 0 none;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button {\n    border: 1px solid ").concat(dt2("inputnumber.button.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button:hover {\n    border-color: ").concat(dt2("inputnumber.button.hover.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button:active {\n    border-color: ").concat(dt2("inputnumber.button.active.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-increment-button {\n    order: 3;\n    border-top-right-radius: ").concat(dt2("inputnumber.button.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt2("inputnumber.button.border.radius"), ";\n    border-left: 0 none;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-input {\n    order: 2;\n    border-radius: 0;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-decrement-button {\n    order: 1;\n    border-top-left-radius: ").concat(dt2("inputnumber.button.border.radius"), ";\n    border-bottom-left-radius: ").concat(dt2("inputnumber.button.border.radius"), ";\n    border-right: 0 none;\n}\n\n.p-inputnumber-vertical {\n    flex-direction: column;\n}\n\n.p-inputnumber-vertical .p-inputnumber-button {\n    border: 1px solid ").concat(dt2("inputnumber.button.border.color"), ";\n    padding: ").concat(dt2("inputnumber.button.vertical.padding"), "; 0;\n}\n\n.p-inputnumber-vertical .p-inputnumber-button:hover {\n    border-color: ").concat(dt2("inputnumber.button.hover.border.color"), ";\n}\n\n.p-inputnumber-vertical .p-inputnumber-button:active {\n    border-color: ").concat(dt2("inputnumber.button.active.border.color"), ";\n}\n\n.p-inputnumber-vertical .p-inputnumber-increment-button {\n    order: 1;\n    border-top-left-radius: ").concat(dt2("inputnumber.button.border.radius"), ";\n    border-top-right-radius: ").concat(dt2("inputnumber.button.border.radius"), ";\n    width: 100%;\n    border-bottom: 0 none;\n}\n\n.p-inputnumber-vertical .p-inputnumber-input {\n    order: 2;\n    border-radius: 0;\n    text-align: center;\n}\n\n.p-inputnumber-vertical .p-inputnumber-decrement-button {\n    order: 3;\n    border-bottom-left-radius: ").concat(dt2("inputnumber.button.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt2("inputnumber.button.border.radius"), ";\n    width: 100%;\n    border-top: 0 none;\n}\n\n.p-inputnumber-input {\n    flex: 1 1 auto;\n}\n\n.p-inputnumber-fluid {\n    width: 100%;\n}\n\n.p-inputnumber-fluid .p-inputnumber-input {\n    width: 1%;\n}\n\n.p-inputnumber-fluid.p-inputnumber-vertical .p-inputnumber-input {\n    width: 100%;\n}\n");
}, "theme");
var classes$m = {
  root: /* @__PURE__ */ __name(function root10(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-inputnumber p-component p-inputwrapper", {
      "p-inputwrapper-filled": instance.filled || props.allowEmpty === false,
      "p-inputwrapper-focus": instance.focused,
      "p-inputnumber-stacked": props.showButtons && props.buttonLayout === "stacked",
      "p-inputnumber-horizontal": props.showButtons && props.buttonLayout === "horizontal",
      "p-inputnumber-vertical": props.showButtons && props.buttonLayout === "vertical",
      "p-inputnumber-fluid": instance.hasFluid
    }];
  }, "root"),
  pcInput: "p-inputnumber-input",
  buttonGroup: "p-inputnumber-button-group",
  incrementButton: /* @__PURE__ */ __name(function incrementButton(_ref3) {
    var instance = _ref3.instance, props = _ref3.props;
    return ["p-inputnumber-button p-inputnumber-increment-button", {
      "p-disabled": props.showButtons && props.max !== null && instance.maxBoundry()
    }];
  }, "incrementButton"),
  decrementButton: /* @__PURE__ */ __name(function decrementButton(_ref4) {
    var instance = _ref4.instance, props = _ref4.props;
    return ["p-inputnumber-button p-inputnumber-decrement-button", {
      "p-disabled": props.showButtons && props.min !== null && instance.minBoundry()
    }];
  }, "decrementButton")
};
var InputNumberStyle = BaseStyle.extend({
  name: "inputnumber",
  theme: theme$m,
  classes: classes$m
});
var script$1$l = {
  name: "BaseInputNumber",
  "extends": script$Y,
  props: {
    modelValue: {
      type: Number,
      "default": null
    },
    format: {
      type: Boolean,
      "default": true
    },
    showButtons: {
      type: Boolean,
      "default": false
    },
    buttonLayout: {
      type: String,
      "default": "stacked"
    },
    incrementButtonClass: {
      type: String,
      "default": null
    },
    decrementButtonClass: {
      type: String,
      "default": null
    },
    incrementButtonIcon: {
      type: String,
      "default": void 0
    },
    incrementIcon: {
      type: String,
      "default": void 0
    },
    decrementButtonIcon: {
      type: String,
      "default": void 0
    },
    decrementIcon: {
      type: String,
      "default": void 0
    },
    locale: {
      type: String,
      "default": void 0
    },
    localeMatcher: {
      type: String,
      "default": void 0
    },
    mode: {
      type: String,
      "default": "decimal"
    },
    prefix: {
      type: String,
      "default": null
    },
    suffix: {
      type: String,
      "default": null
    },
    currency: {
      type: String,
      "default": void 0
    },
    currencyDisplay: {
      type: String,
      "default": void 0
    },
    useGrouping: {
      type: Boolean,
      "default": true
    },
    minFractionDigits: {
      type: Number,
      "default": void 0
    },
    maxFractionDigits: {
      type: Number,
      "default": void 0
    },
    roundingMode: {
      type: String,
      "default": "halfExpand",
      validator: /* @__PURE__ */ __name(function validator2(value3) {
        return ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"].includes(value3);
      }, "validator")
    },
    min: {
      type: Number,
      "default": null
    },
    max: {
      type: Number,
      "default": null
    },
    step: {
      type: Number,
      "default": 1
    },
    allowEmpty: {
      type: Boolean,
      "default": true
    },
    highlightOnFocus: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    placeholder: {
      type: String,
      "default": null
    },
    fluid: {
      type: Boolean,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: InputNumberStyle,
  provide: /* @__PURE__ */ __name(function provide17() {
    return {
      $pcInputNumber: this,
      $parentInstance: this
    };
  }, "provide")
};
function _typeof$b(o) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$b(o);
}
__name(_typeof$b, "_typeof$b");
function ownKeys$d(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$d, "ownKeys$d");
function _objectSpread$d(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$d(Object(t), true).forEach(function(r2) {
      _defineProperty$b(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$d, "_objectSpread$d");
function _defineProperty$b(e, r, t) {
  return (r = _toPropertyKey$a(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$b, "_defineProperty$b");
function _toPropertyKey$a(t) {
  var i2 = _toPrimitive$a(t, "string");
  return "symbol" == _typeof$b(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$a, "_toPropertyKey$a");
function _toPrimitive$a(t, r) {
  if ("object" != _typeof$b(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$b(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$a, "_toPrimitive$a");
function _toConsumableArray$8(r) {
  return _arrayWithoutHoles$8(r) || _iterableToArray$8(r) || _unsupportedIterableToArray$b(r) || _nonIterableSpread$8();
}
__name(_toConsumableArray$8, "_toConsumableArray$8");
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$8, "_nonIterableSpread$8");
function _unsupportedIterableToArray$b(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$b(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$b(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$b, "_unsupportedIterableToArray$b");
function _iterableToArray$8(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$8, "_iterableToArray$8");
function _arrayWithoutHoles$8(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$b(r);
}
__name(_arrayWithoutHoles$8, "_arrayWithoutHoles$8");
function _arrayLikeToArray$b(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$b, "_arrayLikeToArray$b");
var script$C = {
  name: "InputNumber",
  "extends": script$1$l,
  inheritAttrs: false,
  emits: ["update:modelValue", "input", "focus", "blur"],
  inject: {
    $pcFluid: {
      "default": null
    }
  },
  numberFormat: null,
  _numeral: null,
  _decimal: null,
  _group: null,
  _minusSign: null,
  _currency: null,
  _suffix: null,
  _prefix: null,
  _index: null,
  groupChar: "",
  isSpecialChar: null,
  prefixChar: null,
  suffixChar: null,
  timer: null,
  data: /* @__PURE__ */ __name(function data5() {
    return {
      d_modelValue: this.modelValue,
      focused: false
    };
  }, "data"),
  watch: {
    modelValue: /* @__PURE__ */ __name(function modelValue(newValue) {
      this.d_modelValue = newValue;
    }, "modelValue"),
    locale: /* @__PURE__ */ __name(function locale(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "locale"),
    localeMatcher: /* @__PURE__ */ __name(function localeMatcher(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "localeMatcher"),
    mode: /* @__PURE__ */ __name(function mode(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "mode"),
    currency: /* @__PURE__ */ __name(function currency(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "currency"),
    currencyDisplay: /* @__PURE__ */ __name(function currencyDisplay(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "currencyDisplay"),
    useGrouping: /* @__PURE__ */ __name(function useGrouping(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "useGrouping"),
    minFractionDigits: /* @__PURE__ */ __name(function minFractionDigits(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "minFractionDigits"),
    maxFractionDigits: /* @__PURE__ */ __name(function maxFractionDigits(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "maxFractionDigits"),
    suffix: /* @__PURE__ */ __name(function suffix(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "suffix"),
    prefix: /* @__PURE__ */ __name(function prefix(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }, "prefix")
  },
  created: /* @__PURE__ */ __name(function created2() {
    this.constructParser();
  }, "created"),
  methods: {
    getOptions: /* @__PURE__ */ __name(function getOptions2() {
      return {
        localeMatcher: this.localeMatcher,
        style: this.mode,
        currency: this.currency,
        currencyDisplay: this.currencyDisplay,
        useGrouping: this.useGrouping,
        minimumFractionDigits: this.minFractionDigits,
        maximumFractionDigits: this.maxFractionDigits,
        roundingMode: this.roundingMode
      };
    }, "getOptions"),
    constructParser: /* @__PURE__ */ __name(function constructParser() {
      this.numberFormat = new Intl.NumberFormat(this.locale, this.getOptions());
      var numerals = _toConsumableArray$8(new Intl.NumberFormat(this.locale, {
        useGrouping: false
      }).format(9876543210)).reverse();
      var index2 = new Map(numerals.map(function(d, i2) {
        return [d, i2];
      }));
      this._numeral = new RegExp("[".concat(numerals.join(""), "]"), "g");
      this._group = this.getGroupingExpression();
      this._minusSign = this.getMinusSignExpression();
      this._currency = this.getCurrencyExpression();
      this._decimal = this.getDecimalExpression();
      this._suffix = this.getSuffixExpression();
      this._prefix = this.getPrefixExpression();
      this._index = function(d) {
        return index2.get(d);
      };
    }, "constructParser"),
    updateConstructParser: /* @__PURE__ */ __name(function updateConstructParser(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.constructParser();
      }
    }, "updateConstructParser"),
    escapeRegExp: /* @__PURE__ */ __name(function escapeRegExp(text) {
      return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }, "escapeRegExp"),
    getDecimalExpression: /* @__PURE__ */ __name(function getDecimalExpression() {
      var formatter = new Intl.NumberFormat(this.locale, _objectSpread$d(_objectSpread$d({}, this.getOptions()), {}, {
        useGrouping: false
      }));
      return new RegExp("[".concat(formatter.format(1.1).replace(this._currency, "").trim().replace(this._numeral, ""), "]"), "g");
    }, "getDecimalExpression"),
    getGroupingExpression: /* @__PURE__ */ __name(function getGroupingExpression() {
      var formatter = new Intl.NumberFormat(this.locale, {
        useGrouping: true
      });
      this.groupChar = formatter.format(1e6).trim().replace(this._numeral, "").charAt(0);
      return new RegExp("[".concat(this.groupChar, "]"), "g");
    }, "getGroupingExpression"),
    getMinusSignExpression: /* @__PURE__ */ __name(function getMinusSignExpression() {
      var formatter = new Intl.NumberFormat(this.locale, {
        useGrouping: false
      });
      return new RegExp("[".concat(formatter.format(-1).trim().replace(this._numeral, ""), "]"), "g");
    }, "getMinusSignExpression"),
    getCurrencyExpression: /* @__PURE__ */ __name(function getCurrencyExpression() {
      if (this.currency) {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: "currency",
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          roundingMode: this.roundingMode
        });
        return new RegExp("[".concat(formatter.format(1).replace(/\s/g, "").replace(this._numeral, "").replace(this._group, ""), "]"), "g");
      }
      return new RegExp("[]", "g");
    }, "getCurrencyExpression"),
    getPrefixExpression: /* @__PURE__ */ __name(function getPrefixExpression() {
      if (this.prefix) {
        this.prefixChar = this.prefix;
      } else {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay
        });
        this.prefixChar = formatter.format(1).split("1")[0];
      }
      return new RegExp("".concat(this.escapeRegExp(this.prefixChar || "")), "g");
    }, "getPrefixExpression"),
    getSuffixExpression: /* @__PURE__ */ __name(function getSuffixExpression() {
      if (this.suffix) {
        this.suffixChar = this.suffix;
      } else {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          roundingMode: this.roundingMode
        });
        this.suffixChar = formatter.format(1).split("1")[1];
      }
      return new RegExp("".concat(this.escapeRegExp(this.suffixChar || "")), "g");
    }, "getSuffixExpression"),
    formatValue: /* @__PURE__ */ __name(function formatValue(value3) {
      if (value3 != null) {
        if (value3 === "-") {
          return value3;
        }
        if (this.format) {
          var formatter = new Intl.NumberFormat(this.locale, this.getOptions());
          var formattedValue2 = formatter.format(value3);
          if (this.prefix) {
            formattedValue2 = this.prefix + formattedValue2;
          }
          if (this.suffix) {
            formattedValue2 = formattedValue2 + this.suffix;
          }
          return formattedValue2;
        }
        return value3.toString();
      }
      return "";
    }, "formatValue"),
    parseValue: /* @__PURE__ */ __name(function parseValue2(text) {
      var filteredText = text.replace(this._suffix, "").replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "").replace(this._group, "").replace(this._minusSign, "-").replace(this._decimal, ".").replace(this._numeral, this._index);
      if (filteredText) {
        if (filteredText === "-")
          return filteredText;
        var parsedValue = +filteredText;
        return isNaN(parsedValue) ? null : parsedValue;
      }
      return null;
    }, "parseValue"),
    repeat: /* @__PURE__ */ __name(function repeat2(event2, interval, dir) {
      var _this = this;
      if (this.readonly) {
        return;
      }
      var i2 = interval || 500;
      this.clearTimer();
      this.timer = setTimeout(function() {
        _this.repeat(event2, 40, dir);
      }, i2);
      this.spin(event2, dir);
    }, "repeat"),
    spin: /* @__PURE__ */ __name(function spin(event2, dir) {
      if (this.$refs.input) {
        var step2 = this.step * dir;
        var currentValue = this.parseValue(this.$refs.input.$el.value) || 0;
        var newValue = this.validateValue(currentValue + step2);
        this.updateInput(newValue, null, "spin");
        this.updateModel(event2, newValue);
        this.handleOnInput(event2, currentValue, newValue);
      }
    }, "spin"),
    onUpButtonMouseDown: /* @__PURE__ */ __name(function onUpButtonMouseDown(event2) {
      if (!this.disabled) {
        this.$refs.input.$el.focus();
        this.repeat(event2, null, 1);
        event2.preventDefault();
      }
    }, "onUpButtonMouseDown"),
    onUpButtonMouseUp: /* @__PURE__ */ __name(function onUpButtonMouseUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onUpButtonMouseUp"),
    onUpButtonMouseLeave: /* @__PURE__ */ __name(function onUpButtonMouseLeave() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onUpButtonMouseLeave"),
    onUpButtonKeyUp: /* @__PURE__ */ __name(function onUpButtonKeyUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onUpButtonKeyUp"),
    onUpButtonKeyDown: /* @__PURE__ */ __name(function onUpButtonKeyDown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.repeat(event2, null, 1);
      }
    }, "onUpButtonKeyDown"),
    onDownButtonMouseDown: /* @__PURE__ */ __name(function onDownButtonMouseDown(event2) {
      if (!this.disabled) {
        this.$refs.input.$el.focus();
        this.repeat(event2, null, -1);
        event2.preventDefault();
      }
    }, "onDownButtonMouseDown"),
    onDownButtonMouseUp: /* @__PURE__ */ __name(function onDownButtonMouseUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onDownButtonMouseUp"),
    onDownButtonMouseLeave: /* @__PURE__ */ __name(function onDownButtonMouseLeave() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onDownButtonMouseLeave"),
    onDownButtonKeyUp: /* @__PURE__ */ __name(function onDownButtonKeyUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    }, "onDownButtonKeyUp"),
    onDownButtonKeyDown: /* @__PURE__ */ __name(function onDownButtonKeyDown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.repeat(event2, null, -1);
      }
    }, "onDownButtonKeyDown"),
    onUserInput: /* @__PURE__ */ __name(function onUserInput() {
      if (this.isSpecialChar) {
        this.$refs.input.$el.value = this.lastValue;
      }
      this.isSpecialChar = false;
    }, "onUserInput"),
    onInputKeyDown: /* @__PURE__ */ __name(function onInputKeyDown(event2) {
      if (this.readonly) {
        return;
      }
      if (event2.altKey || event2.ctrlKey || event2.metaKey) {
        this.isSpecialChar = true;
        this.lastValue = this.$refs.input.$el.value;
        return;
      }
      this.lastValue = event2.target.value;
      var selectionStart = event2.target.selectionStart;
      var selectionEnd = event2.target.selectionEnd;
      var inputValue = event2.target.value;
      var newValueStr = null;
      switch (event2.code) {
        case "ArrowUp":
          this.spin(event2, 1);
          event2.preventDefault();
          break;
        case "ArrowDown":
          this.spin(event2, -1);
          event2.preventDefault();
          break;
        case "ArrowLeft":
          if (!this.isNumeralChar(inputValue.charAt(selectionStart - 1))) {
            event2.preventDefault();
          }
          break;
        case "ArrowRight":
          if (!this.isNumeralChar(inputValue.charAt(selectionStart))) {
            event2.preventDefault();
          }
          break;
        case "Tab":
        case "Enter":
        case "NumpadEnter":
          newValueStr = this.validateValue(this.parseValue(inputValue));
          this.$refs.input.$el.value = this.formatValue(newValueStr);
          this.$refs.input.$el.setAttribute("aria-valuenow", newValueStr);
          this.updateModel(event2, newValueStr);
          break;
        case "Backspace": {
          event2.preventDefault();
          if (selectionStart === selectionEnd) {
            var deleteChar = inputValue.charAt(selectionStart - 1);
            var _this$getDecimalCharI = this.getDecimalCharIndexes(inputValue), decimalCharIndex = _this$getDecimalCharI.decimalCharIndex, decimalCharIndexWithoutPrefix = _this$getDecimalCharI.decimalCharIndexWithoutPrefix;
            if (this.isNumeralChar(deleteChar)) {
              var decimalLength = this.getDecimalLength(inputValue);
              if (this._group.test(deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue.slice(0, selectionStart - 2) + inputValue.slice(selectionStart - 1);
              } else if (this._decimal.test(deleteChar)) {
                this._decimal.lastIndex = 0;
                if (decimalLength) {
                  this.$refs.input.$el.setSelectionRange(selectionStart - 1, selectionStart - 1);
                } else {
                  newValueStr = inputValue.slice(0, selectionStart - 1) + inputValue.slice(selectionStart);
                }
              } else if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
                var insertedText = this.isDecimalMode() && (this.minFractionDigits || 0) < decimalLength ? "" : "0";
                newValueStr = inputValue.slice(0, selectionStart - 1) + insertedText + inputValue.slice(selectionStart);
              } else if (decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue.slice(0, selectionStart - 1) + "0" + inputValue.slice(selectionStart);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : "";
              } else {
                newValueStr = inputValue.slice(0, selectionStart - 1) + inputValue.slice(selectionStart);
              }
            }
            this.updateValue(event2, newValueStr, null, "delete-single");
          } else {
            newValueStr = this.deleteRange(inputValue, selectionStart, selectionEnd);
            this.updateValue(event2, newValueStr, null, "delete-range");
          }
          break;
        }
        case "Delete":
          event2.preventDefault();
          if (selectionStart === selectionEnd) {
            var _deleteChar = inputValue.charAt(selectionStart);
            var _this$getDecimalCharI2 = this.getDecimalCharIndexes(inputValue), _decimalCharIndex = _this$getDecimalCharI2.decimalCharIndex, _decimalCharIndexWithoutPrefix = _this$getDecimalCharI2.decimalCharIndexWithoutPrefix;
            if (this.isNumeralChar(_deleteChar)) {
              var _decimalLength = this.getDecimalLength(inputValue);
              if (this._group.test(_deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 2);
              } else if (this._decimal.test(_deleteChar)) {
                this._decimal.lastIndex = 0;
                if (_decimalLength) {
                  this.$refs.input.$el.setSelectionRange(selectionStart + 1, selectionStart + 1);
                } else {
                  newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 1);
                }
              } else if (_decimalCharIndex > 0 && selectionStart > _decimalCharIndex) {
                var _insertedText = this.isDecimalMode() && (this.minFractionDigits || 0) < _decimalLength ? "" : "0";
                newValueStr = inputValue.slice(0, selectionStart) + _insertedText + inputValue.slice(selectionStart + 1);
              } else if (_decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue.slice(0, selectionStart) + "0" + inputValue.slice(selectionStart + 1);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : "";
              } else {
                newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 1);
              }
            }
            this.updateValue(event2, newValueStr, null, "delete-back-single");
          } else {
            newValueStr = this.deleteRange(inputValue, selectionStart, selectionEnd);
            this.updateValue(event2, newValueStr, null, "delete-range");
          }
          break;
        case "Home":
          event2.preventDefault();
          if (isNotEmpty(this.min)) {
            this.updateModel(event2, this.min);
          }
          break;
        case "End":
          event2.preventDefault();
          if (isNotEmpty(this.max)) {
            this.updateModel(event2, this.max);
          }
          break;
      }
    }, "onInputKeyDown"),
    onInputKeyPress: /* @__PURE__ */ __name(function onInputKeyPress(event2) {
      if (this.readonly) {
        return;
      }
      var _char = event2.key;
      var isDecimalSign2 = this.isDecimalSign(_char);
      var isMinusSign2 = this.isMinusSign(_char);
      if (event2.code !== "Enter") {
        event2.preventDefault();
      }
      if (Number(_char) >= 0 && Number(_char) <= 9 || isMinusSign2 || isDecimalSign2) {
        this.insert(event2, _char, {
          isDecimalSign: isDecimalSign2,
          isMinusSign: isMinusSign2
        });
      }
    }, "onInputKeyPress"),
    onPaste: /* @__PURE__ */ __name(function onPaste(event2) {
      event2.preventDefault();
      var data22 = (event2.clipboardData || window["clipboardData"]).getData("Text");
      if (data22) {
        var filteredData = this.parseValue(data22);
        if (filteredData != null) {
          this.insert(event2, filteredData.toString());
        }
      }
    }, "onPaste"),
    allowMinusSign: /* @__PURE__ */ __name(function allowMinusSign() {
      return this.min === null || this.min < 0;
    }, "allowMinusSign"),
    isMinusSign: /* @__PURE__ */ __name(function isMinusSign(_char2) {
      if (this._minusSign.test(_char2) || _char2 === "-") {
        this._minusSign.lastIndex = 0;
        return true;
      }
      return false;
    }, "isMinusSign"),
    isDecimalSign: /* @__PURE__ */ __name(function isDecimalSign(_char3) {
      if (this._decimal.test(_char3)) {
        this._decimal.lastIndex = 0;
        return true;
      }
      return false;
    }, "isDecimalSign"),
    isDecimalMode: /* @__PURE__ */ __name(function isDecimalMode() {
      return this.mode === "decimal";
    }, "isDecimalMode"),
    getDecimalCharIndexes: /* @__PURE__ */ __name(function getDecimalCharIndexes(val) {
      var decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      var filteredVal = val.replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "");
      var decimalCharIndexWithoutPrefix = filteredVal.search(this._decimal);
      this._decimal.lastIndex = 0;
      return {
        decimalCharIndex,
        decimalCharIndexWithoutPrefix
      };
    }, "getDecimalCharIndexes"),
    getCharIndexes: /* @__PURE__ */ __name(function getCharIndexes(val) {
      var decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      var minusCharIndex = val.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      var suffixCharIndex = val.search(this._suffix);
      this._suffix.lastIndex = 0;
      var currencyCharIndex = val.search(this._currency);
      this._currency.lastIndex = 0;
      return {
        decimalCharIndex,
        minusCharIndex,
        suffixCharIndex,
        currencyCharIndex
      };
    }, "getCharIndexes"),
    insert: /* @__PURE__ */ __name(function insert(event2, text) {
      var sign = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        isDecimalSign: false,
        isMinusSign: false
      };
      var minusCharIndexOnText = text.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      if (!this.allowMinusSign() && minusCharIndexOnText !== -1) {
        return;
      }
      var selectionStart = this.$refs.input.$el.selectionStart;
      var selectionEnd = this.$refs.input.$el.selectionEnd;
      var inputValue = this.$refs.input.$el.value.trim();
      var _this$getCharIndexes = this.getCharIndexes(inputValue), decimalCharIndex = _this$getCharIndexes.decimalCharIndex, minusCharIndex = _this$getCharIndexes.minusCharIndex, suffixCharIndex = _this$getCharIndexes.suffixCharIndex, currencyCharIndex = _this$getCharIndexes.currencyCharIndex;
      var newValueStr;
      if (sign.isMinusSign) {
        if (selectionStart === 0) {
          newValueStr = inputValue;
          if (minusCharIndex === -1 || selectionEnd !== 0) {
            newValueStr = this.insertText(inputValue, text, 0, selectionEnd);
          }
          this.updateValue(event2, newValueStr, text, "insert");
        }
      } else if (sign.isDecimalSign) {
        if (decimalCharIndex > 0 && selectionStart === decimalCharIndex) {
          this.updateValue(event2, inputValue, text, "insert");
        } else if (decimalCharIndex > selectionStart && decimalCharIndex < selectionEnd) {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text, "insert");
        } else if (decimalCharIndex === -1 && this.maxFractionDigits) {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text, "insert");
        }
      } else {
        var maxFractionDigits2 = this.numberFormat.resolvedOptions().maximumFractionDigits;
        var operation = selectionStart !== selectionEnd ? "range-insert" : "insert";
        if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
          if (selectionStart + text.length - (decimalCharIndex + 1) <= maxFractionDigits2) {
            var charIndex = currencyCharIndex >= selectionStart ? currencyCharIndex - 1 : suffixCharIndex >= selectionStart ? suffixCharIndex : inputValue.length;
            newValueStr = inputValue.slice(0, selectionStart) + text + inputValue.slice(selectionStart + text.length, charIndex) + inputValue.slice(charIndex);
            this.updateValue(event2, newValueStr, text, operation);
          }
        } else {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text, operation);
        }
      }
    }, "insert"),
    insertText: /* @__PURE__ */ __name(function insertText(value3, text, start2, end) {
      var textSplit = text === "." ? text : text.split(".");
      if (textSplit.length === 2) {
        var decimalCharIndex = value3.slice(start2, end).search(this._decimal);
        this._decimal.lastIndex = 0;
        return decimalCharIndex > 0 ? value3.slice(0, start2) + this.formatValue(text) + value3.slice(end) : this.formatValue(text) || value3;
      } else if (end - start2 === value3.length) {
        return this.formatValue(text);
      } else if (start2 === 0) {
        return text + value3.slice(end);
      } else if (end === value3.length) {
        return value3.slice(0, start2) + text;
      } else {
        return value3.slice(0, start2) + text + value3.slice(end);
      }
    }, "insertText"),
    deleteRange: /* @__PURE__ */ __name(function deleteRange(value3, start2, end) {
      var newValueStr;
      if (end - start2 === value3.length) newValueStr = "";
      else if (start2 === 0) newValueStr = value3.slice(end);
      else if (end === value3.length) newValueStr = value3.slice(0, start2);
      else newValueStr = value3.slice(0, start2) + value3.slice(end);
      return newValueStr;
    }, "deleteRange"),
    initCursor: /* @__PURE__ */ __name(function initCursor() {
      var selectionStart = this.$refs.input.$el.selectionStart;
      var inputValue = this.$refs.input.$el.value;
      var valueLength = inputValue.length;
      var index2 = null;
      var prefixLength = (this.prefixChar || "").length;
      inputValue = inputValue.replace(this._prefix, "");
      selectionStart = selectionStart - prefixLength;
      var _char4 = inputValue.charAt(selectionStart);
      if (this.isNumeralChar(_char4)) {
        return selectionStart + prefixLength;
      }
      var i2 = selectionStart - 1;
      while (i2 >= 0) {
        _char4 = inputValue.charAt(i2);
        if (this.isNumeralChar(_char4)) {
          index2 = i2 + prefixLength;
          break;
        } else {
          i2--;
        }
      }
      if (index2 !== null) {
        this.$refs.input.$el.setSelectionRange(index2 + 1, index2 + 1);
      } else {
        i2 = selectionStart;
        while (i2 < valueLength) {
          _char4 = inputValue.charAt(i2);
          if (this.isNumeralChar(_char4)) {
            index2 = i2 + prefixLength;
            break;
          } else {
            i2++;
          }
        }
        if (index2 !== null) {
          this.$refs.input.$el.setSelectionRange(index2, index2);
        }
      }
      return index2 || 0;
    }, "initCursor"),
    onInputClick: /* @__PURE__ */ __name(function onInputClick() {
      var currentValue = this.$refs.input.$el.value;
      if (!this.readonly && currentValue !== getSelection()) {
        this.initCursor();
      }
    }, "onInputClick"),
    isNumeralChar: /* @__PURE__ */ __name(function isNumeralChar(_char5) {
      if (_char5.length === 1 && (this._numeral.test(_char5) || this._decimal.test(_char5) || this._group.test(_char5) || this._minusSign.test(_char5))) {
        this.resetRegex();
        return true;
      }
      return false;
    }, "isNumeralChar"),
    resetRegex: /* @__PURE__ */ __name(function resetRegex() {
      this._numeral.lastIndex = 0;
      this._decimal.lastIndex = 0;
      this._group.lastIndex = 0;
      this._minusSign.lastIndex = 0;
    }, "resetRegex"),
    updateValue: /* @__PURE__ */ __name(function updateValue2(event2, valueStr, insertedValueStr, operation) {
      var currentValue = this.$refs.input.$el.value;
      var newValue = null;
      if (valueStr != null) {
        newValue = this.parseValue(valueStr);
        newValue = !newValue && !this.allowEmpty ? 0 : newValue;
        this.updateInput(newValue, insertedValueStr, operation, valueStr);
        this.handleOnInput(event2, currentValue, newValue);
      }
    }, "updateValue"),
    handleOnInput: /* @__PURE__ */ __name(function handleOnInput(event2, currentValue, newValue) {
      if (this.isValueChanged(currentValue, newValue)) {
        this.$emit("input", {
          originalEvent: event2,
          value: newValue,
          formattedValue: currentValue
        });
      }
    }, "handleOnInput"),
    isValueChanged: /* @__PURE__ */ __name(function isValueChanged(currentValue, newValue) {
      if (newValue === null && currentValue !== null) {
        return true;
      }
      if (newValue != null) {
        var parsedCurrentValue = typeof currentValue === "string" ? this.parseValue(currentValue) : currentValue;
        return newValue !== parsedCurrentValue;
      }
      return false;
    }, "isValueChanged"),
    validateValue: /* @__PURE__ */ __name(function validateValue(value3) {
      if (value3 === "-" || value3 == null) {
        return null;
      }
      if (this.min != null && value3 < this.min) {
        return this.min;
      }
      if (this.max != null && value3 > this.max) {
        return this.max;
      }
      return value3;
    }, "validateValue"),
    updateInput: /* @__PURE__ */ __name(function updateInput(value3, insertedValueStr, operation, valueStr) {
      insertedValueStr = insertedValueStr || "";
      var inputValue = this.$refs.input.$el.value;
      var newValue = this.formatValue(value3);
      var currentLength = inputValue.length;
      if (newValue !== valueStr) {
        newValue = this.concatValues(newValue, valueStr);
      }
      if (currentLength === 0) {
        this.$refs.input.$el.value = newValue;
        this.$refs.input.$el.setSelectionRange(0, 0);
        var index2 = this.initCursor();
        var selectionEnd = index2 + insertedValueStr.length;
        this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
      } else {
        var selectionStart = this.$refs.input.$el.selectionStart;
        var _selectionEnd = this.$refs.input.$el.selectionEnd;
        this.$refs.input.$el.value = newValue;
        var newLength = newValue.length;
        if (operation === "range-insert") {
          var startValue = this.parseValue((inputValue || "").slice(0, selectionStart));
          var startValueStr = startValue !== null ? startValue.toString() : "";
          var startExpr = startValueStr.split("").join("(".concat(this.groupChar, ")?"));
          var sRegex = new RegExp(startExpr, "g");
          sRegex.test(newValue);
          var tExpr = insertedValueStr.split("").join("(".concat(this.groupChar, ")?"));
          var tRegex = new RegExp(tExpr, "g");
          tRegex.test(newValue.slice(sRegex.lastIndex));
          _selectionEnd = sRegex.lastIndex + tRegex.lastIndex;
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (newLength === currentLength) {
          if (operation === "insert" || operation === "delete-back-single") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd + 1, _selectionEnd + 1);
          } else if (operation === "delete-single") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd - 1, _selectionEnd - 1);
          } else if (operation === "delete-range" || operation === "spin") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
          }
        } else if (operation === "delete-back-single") {
          var prevChar = inputValue.charAt(_selectionEnd - 1);
          var nextChar = inputValue.charAt(_selectionEnd);
          var diff2 = currentLength - newLength;
          var isGroupChar = this._group.test(nextChar);
          if (isGroupChar && diff2 === 1) {
            _selectionEnd += 1;
          } else if (!isGroupChar && this.isNumeralChar(prevChar)) {
            _selectionEnd += -1 * diff2 + 1;
          }
          this._group.lastIndex = 0;
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (inputValue === "-" && operation === "insert") {
          this.$refs.input.$el.setSelectionRange(0, 0);
          var _index = this.initCursor();
          var _selectionEnd2 = _index + insertedValueStr.length + 1;
          this.$refs.input.$el.setSelectionRange(_selectionEnd2, _selectionEnd2);
        } else {
          _selectionEnd = _selectionEnd + (newLength - currentLength);
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        }
      }
      this.$refs.input.$el.setAttribute("aria-valuenow", value3);
    }, "updateInput"),
    concatValues: /* @__PURE__ */ __name(function concatValues(val1, val2) {
      if (val1 && val2) {
        var decimalCharIndex = val2.search(this._decimal);
        this._decimal.lastIndex = 0;
        if (this.suffixChar) {
          return decimalCharIndex !== -1 ? val1.replace(this.suffixChar, "").split(this._decimal)[0] + val2.replace(this.suffixChar, "").slice(decimalCharIndex) + this.suffixChar : val1;
        } else {
          return decimalCharIndex !== -1 ? val1.split(this._decimal)[0] + val2.slice(decimalCharIndex) : val1;
        }
      }
      return val1;
    }, "concatValues"),
    getDecimalLength: /* @__PURE__ */ __name(function getDecimalLength(value3) {
      if (value3) {
        var valueSplit = value3.split(this._decimal);
        if (valueSplit.length === 2) {
          return valueSplit[1].replace(this._suffix, "").trim().replace(/\s/g, "").replace(this._currency, "").length;
        }
      }
      return 0;
    }, "getDecimalLength"),
    updateModel: /* @__PURE__ */ __name(function updateModel2(event2, value3) {
      this.d_modelValue = value3;
      this.$emit("update:modelValue", value3);
    }, "updateModel"),
    onInputFocus: /* @__PURE__ */ __name(function onInputFocus(event2) {
      this.focused = true;
      if (!this.disabled && !this.readonly && this.$refs.input.$el.value !== getSelection() && this.highlightOnFocus) {
        event2.target.select();
      }
      this.$emit("focus", event2);
    }, "onInputFocus"),
    onInputBlur: /* @__PURE__ */ __name(function onInputBlur(event2) {
      this.focused = false;
      var input = event2.target;
      var newValue = this.validateValue(this.parseValue(input.value));
      this.$emit("blur", {
        originalEvent: event2,
        value: input.value
      });
      input.value = this.formatValue(newValue);
      input.setAttribute("aria-valuenow", newValue);
      this.updateModel(event2, newValue);
      if (!this.disabled && !this.readonly && this.highlightOnFocus) {
        clearSelection();
      }
    }, "onInputBlur"),
    clearTimer: /* @__PURE__ */ __name(function clearTimer2() {
      if (this.timer) {
        clearInterval(this.timer);
      }
    }, "clearTimer"),
    maxBoundry: /* @__PURE__ */ __name(function maxBoundry() {
      return this.d_modelValue >= this.max;
    }, "maxBoundry"),
    minBoundry: /* @__PURE__ */ __name(function minBoundry() {
      return this.d_modelValue <= this.min;
    }, "minBoundry")
  },
  computed: {
    filled: /* @__PURE__ */ __name(function filled2() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    }, "filled"),
    upButtonListeners: /* @__PURE__ */ __name(function upButtonListeners() {
      var _this2 = this;
      return {
        mousedown: /* @__PURE__ */ __name(function mousedown(event2) {
          return _this2.onUpButtonMouseDown(event2);
        }, "mousedown"),
        mouseup: /* @__PURE__ */ __name(function mouseup(event2) {
          return _this2.onUpButtonMouseUp(event2);
        }, "mouseup"),
        mouseleave: /* @__PURE__ */ __name(function mouseleave(event2) {
          return _this2.onUpButtonMouseLeave(event2);
        }, "mouseleave"),
        keydown: /* @__PURE__ */ __name(function keydown(event2) {
          return _this2.onUpButtonKeyDown(event2);
        }, "keydown"),
        keyup: /* @__PURE__ */ __name(function keyup(event2) {
          return _this2.onUpButtonKeyUp(event2);
        }, "keyup")
      };
    }, "upButtonListeners"),
    downButtonListeners: /* @__PURE__ */ __name(function downButtonListeners() {
      var _this3 = this;
      return {
        mousedown: /* @__PURE__ */ __name(function mousedown(event2) {
          return _this3.onDownButtonMouseDown(event2);
        }, "mousedown"),
        mouseup: /* @__PURE__ */ __name(function mouseup(event2) {
          return _this3.onDownButtonMouseUp(event2);
        }, "mouseup"),
        mouseleave: /* @__PURE__ */ __name(function mouseleave(event2) {
          return _this3.onDownButtonMouseLeave(event2);
        }, "mouseleave"),
        keydown: /* @__PURE__ */ __name(function keydown(event2) {
          return _this3.onDownButtonKeyDown(event2);
        }, "keydown"),
        keyup: /* @__PURE__ */ __name(function keyup(event2) {
          return _this3.onDownButtonKeyUp(event2);
        }, "keyup")
      };
    }, "downButtonListeners"),
    formattedValue: /* @__PURE__ */ __name(function formattedValue() {
      var val = !this.modelValue && !this.allowEmpty ? 0 : this.modelValue;
      return this.formatValue(val);
    }, "formattedValue"),
    getFormatter: /* @__PURE__ */ __name(function getFormatter() {
      return this.numberFormat;
    }, "getFormatter"),
    hasFluid: /* @__PURE__ */ __name(function hasFluid3() {
      return isEmpty(this.fluid) ? !!this.$pcFluid : this.fluid;
    }, "hasFluid")
  },
  components: {
    InputText: script$R,
    AngleUpIcon: script$D,
    AngleDownIcon: script$E
  }
};
var _hoisted_1$$ = ["disabled"];
var _hoisted_2$L = ["disabled"];
var _hoisted_3$o = ["disabled"];
var _hoisted_4$h = ["disabled"];
function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_InputText = resolveComponent("InputText");
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [createVNode(_component_InputText, {
    ref: "input",
    id: _ctx.inputId,
    role: "spinbutton",
    "class": normalizeClass([_ctx.cx("pcInput"), _ctx.inputClass]),
    style: normalizeStyle(_ctx.inputStyle),
    value: $options.formattedValue,
    "aria-valuemin": _ctx.min,
    "aria-valuemax": _ctx.max,
    "aria-valuenow": _ctx.modelValue,
    inputmode: _ctx.mode === "decimal" && !_ctx.minFractionDigits ? "numeric" : "decimal",
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    placeholder: _ctx.placeholder,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    invalid: _ctx.invalid,
    variant: _ctx.variant,
    onInput: $options.onUserInput,
    onKeydown: $options.onInputKeyDown,
    onKeypress: $options.onInputKeyPress,
    onPaste: $options.onPaste,
    onClick: $options.onInputClick,
    onFocus: $options.onInputFocus,
    onBlur: $options.onInputBlur,
    pt: _ctx.ptm("pcInput"),
    unstyled: _ctx.unstyled
  }, null, 8, ["id", "class", "style", "value", "aria-valuemin", "aria-valuemax", "aria-valuenow", "inputmode", "disabled", "readonly", "placeholder", "aria-labelledby", "aria-label", "invalid", "variant", "onInput", "onKeydown", "onKeypress", "onPaste", "onClick", "onFocus", "onBlur", "pt", "unstyled"]), _ctx.showButtons && _ctx.buttonLayout === "stacked" ? (openBlock(), createElementBlock("span", mergeProps({
    key: 0,
    "class": _ctx.cx("buttonGroup")
  }, _ctx.ptm("buttonGroup")), [renderSlot(_ctx.$slots, "incrementbutton", {
    listeners: $options.upButtonListeners
  }, function() {
    return [createBaseVNode("button", mergeProps({
      "class": [_ctx.cx("incrementButton"), _ctx.incrementButtonClass]
    }, toHandlers($options.upButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("incrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.incrementIcon || _ctx.incrementButtonIcon ? "span" : "AngleUpIcon"), mergeProps({
        "class": [_ctx.incrementIcon, _ctx.incrementButtonIcon]
      }, _ctx.ptm("incrementIcon"), {
        "data-pc-section": "incrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_1$$)];
  }), renderSlot(_ctx.$slots, "decrementbutton", {
    listeners: $options.downButtonListeners
  }, function() {
    return [createBaseVNode("button", mergeProps({
      "class": [_ctx.cx("decrementButton"), _ctx.decrementButtonClass]
    }, toHandlers($options.downButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("decrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.decrementIcon || _ctx.decrementButtonIcon ? "span" : "AngleDownIcon"), mergeProps({
        "class": [_ctx.decrementIcon, _ctx.decrementButtonIcon]
      }, _ctx.ptm("decrementIcon"), {
        "data-pc-section": "decrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_2$L)];
  })], 16)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "incrementbutton", {
    listeners: $options.upButtonListeners
  }, function() {
    return [_ctx.showButtons && _ctx.buttonLayout !== "stacked" ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      "class": [_ctx.cx("incrementButton"), _ctx.incrementButtonClass]
    }, toHandlers($options.upButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("incrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.incrementIcon || _ctx.incrementButtonIcon ? "span" : "AngleUpIcon"), mergeProps({
        "class": [_ctx.incrementIcon, _ctx.incrementButtonIcon]
      }, _ctx.ptm("incrementIcon"), {
        "data-pc-section": "incrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_3$o)) : createCommentVNode("", true)];
  }), renderSlot(_ctx.$slots, "decrementbutton", {
    listeners: $options.downButtonListeners
  }, function() {
    return [_ctx.showButtons && _ctx.buttonLayout !== "stacked" ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      "class": [_ctx.cx("decrementButton"), _ctx.decrementButtonClass]
    }, toHandlers($options.downButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("decrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.decrementIcon || _ctx.decrementButtonIcon ? "span" : "AngleDownIcon"), mergeProps({
        "class": [_ctx.decrementIcon, _ctx.decrementButtonIcon]
      }, _ctx.ptm("decrementIcon"), {
        "data-pc-section": "decrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_4$h)) : createCommentVNode("", true)];
  })], 16);
}
__name(render$B, "render$B");
script$C.render = render$B;
var script$B = {
  name: "ChevronDownIcon",
  "extends": script$X
};
var _hoisted_1$_ = /* @__PURE__ */ createBaseVNode("path", {
  d: "M7.01744 10.398C6.91269 10.3985 6.8089 10.378 6.71215 10.3379C6.61541 10.2977 6.52766 10.2386 6.45405 10.1641L1.13907 4.84913C1.03306 4.69404 0.985221 4.5065 1.00399 4.31958C1.02276 4.13266 1.10693 3.95838 1.24166 3.82747C1.37639 3.69655 1.55301 3.61742 1.74039 3.60402C1.92777 3.59062 2.11386 3.64382 2.26584 3.75424L7.01744 8.47394L11.769 3.75424C11.9189 3.65709 12.097 3.61306 12.2748 3.62921C12.4527 3.64535 12.6199 3.72073 12.7498 3.84328C12.8797 3.96582 12.9647 4.12842 12.9912 4.30502C13.0177 4.48162 12.9841 4.662 12.8958 4.81724L7.58083 10.1322C7.50996 10.2125 7.42344 10.2775 7.32656 10.3232C7.22968 10.3689 7.12449 10.3944 7.01744 10.398Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$K = [_hoisted_1$_];
function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$K, 16);
}
__name(render$A, "render$A");
script$B.render = render$A;
var script$A = {
  name: "TimesIcon",
  "extends": script$X
};
var _hoisted_1$Z = /* @__PURE__ */ createBaseVNode("path", {
  d: "M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$J = [_hoisted_1$Z];
function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$J, 16);
}
__name(render$z, "render$z");
script$A.render = render$z;
var OverlayEventBus = EventBus();
var script$z = {
  name: "Portal",
  props: {
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  data: /* @__PURE__ */ __name(function data6() {
    return {
      mounted: false
    };
  }, "data"),
  mounted: /* @__PURE__ */ __name(function mounted6() {
    this.mounted = isClient$1();
  }, "mounted"),
  computed: {
    inline: /* @__PURE__ */ __name(function inline() {
      return this.disabled || this.appendTo === "self";
    }, "inline")
  }
};
function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.inline ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : $data.mounted ? (openBlock(), createBlock(Teleport, {
    key: 1,
    to: $props.appendTo
  }, [renderSlot(_ctx.$slots, "default")], 8, ["to"])) : createCommentVNode("", true);
}
__name(render$y, "render$y");
script$z.render = render$y;
var theme$l = /* @__PURE__ */ __name(function theme16(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-select {\n    display: inline-flex;\n    cursor: pointer;\n    position: relative;\n    user-select: none;\n    background: ".concat(dt2("select.background"), ";\n    border: 1px solid ").concat(dt2("select.border.color"), ";\n    transition: background ").concat(dt2("select.transition.duration"), ", color ").concat(dt2("select.transition.duration"), ", border-color ").concat(dt2("select.transition.duration"), ",\n        outline-color ").concat(dt2("select.transition.duration"), ", box-shadow ").concat(dt2("select.transition.duration"), ";\n    border-radius: ").concat(dt2("select.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt2("select.shadow"), ";\n}\n\n.p-select:not(.p-disabled):hover {\n    border-color: ").concat(dt2("select.hover.border.color"), ";\n}\n\n.p-select:not(.p-disabled).p-focus {\n    border-color: ").concat(dt2("select.focus.border.color"), ";\n    box-shadow: ").concat(dt2("select.focus.ring.shadow"), ";\n    outline: ").concat(dt2("select.focus.ring.width"), " ").concat(dt2("select.focus.ring.style"), " ").concat(dt2("select.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("select.focus.ring.offset"), ";\n}\n\n.p-select.p-variant-filled {\n    background: ").concat(dt2("select.filled.background"), ";\n}\n\n.p-select.p-variant-filled.p-focus {\n    background: ").concat(dt2("select.filled.focus.background"), ";\n}\n\n.p-select.p-invalid {\n    border-color: ").concat(dt2("select.invalid.border.color"), ";\n}\n\n.p-select.p-disabled {\n    opacity: 1;\n    background: ").concat(dt2("select.disabled.background"), ";\n}\n\n.p-select-clear-icon {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n    color: ").concat(dt2("select.clear.icon.color"), ";\n    right: ").concat(dt2("select.dropdown.width"), ";\n}\n\n.p-select-dropdown {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n    background: transparent;\n    color: ").concat(dt2("select.dropdown.color"), ";\n    width: ").concat(dt2("select.dropdown.width"), ";\n    border-top-right-radius: ").concat(dt2("select.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt2("select.border.radius"), ";\n}\n\n.p-select-label {\n    display: block;\n    white-space: nowrap;\n    overflow: hidden;\n    flex: 1 1 auto;\n    width: 1%;\n    padding: ").concat(dt2("select.padding.y"), " ").concat(dt2("select.padding.x"), ";\n    text-overflow: ellipsis;\n    cursor: pointer;\n    color: ").concat(dt2("select.color"), ";\n    background: transparent;\n    border: 0 none;\n    outline: 0 none;\n}\n\n.p-select-label.p-placeholder {\n    color: ").concat(dt2("select.placeholder.color"), ";\n}\n\n.p-select:has(.p-select-clear-icon) .p-select-label {\n    padding-right: calc(1rem + ").concat(dt2("select.padding.x"), ");\n}\n\n.p-select.p-disabled .p-select-label {\n    color: ").concat(dt2("select.disabled.color"), ";\n}\n\n.p-select-label-empty {\n    overflow: hidden;\n    opacity: 0;\n}\n\ninput.p-select-label {\n    cursor: default;\n}\n\n.p-select .p-select-overlay {\n    min-width: 100%;\n}\n\n.p-select-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    background: ").concat(dt2("select.overlay.background"), ";\n    color: ").concat(dt2("select.overlay.color"), ";\n    border: 1px solid ").concat(dt2("select.overlay.border.color"), ";\n    border-radius: ").concat(dt2("select.overlay.border.radius"), ";\n    box-shadow: ").concat(dt2("select.overlay.shadow"), ";\n}\n\n.p-select-header {\n    padding: ").concat(dt2("select.list.header.padding"), ";\n}\n\n.p-select-filter {\n    width: 100%;\n}\n\n.p-select-list-container {\n    overflow: auto;\n}\n\n.p-select-option-group {\n    cursor: auto;\n    margin: 0;\n    padding: ").concat(dt2("select.option.group.padding"), ";\n    background: ").concat(dt2("select.option.group.background"), ";\n    color: ").concat(dt2("select.option.group.color"), ";\n    font-weight: ").concat(dt2("select.option.group.font.weight"), ";\n}\n\n.p-select-list {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    padding: ").concat(dt2("select.list.padding"), ";\n    gap: ").concat(dt2("select.list.gap"), ";\n    display: flex;\n    flex-direction: column;\n}\n\n.p-select-option {\n    cursor: pointer;\n    font-weight: normal;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt2("select.option.padding"), ";\n    border: 0 none;\n    color: ").concat(dt2("select.option.color"), ";\n    background: transparent;\n    transition: background ").concat(dt2("select.transition.duration"), ", color ").concat(dt2("select.transition.duration"), ", border-color ").concat(dt2("select.transition.duration"), ",\n            box-shadow ").concat(dt2("select.transition.duration"), ", outline-color ").concat(dt2("select.transition.duration"), ";\n    border-radius: ").concat(dt2("select.option.border.radius"), ";\n}\n\n.p-select-option:not(.p-select-option-selected):not(.p-disabled).p-focus {\n    background: ").concat(dt2("select.option.focus.background"), ";\n    color: ").concat(dt2("select.option.focus.color"), ";\n}\n\n.p-select-option.p-select-option-selected {\n    background: ").concat(dt2("select.option.selected.background"), ";\n    color: ").concat(dt2("select.option.selected.color"), ";\n}\n\n.p-select-option.p-select-option-selected.p-focus {\n    background: ").concat(dt2("select.option.selected.focus.background"), ";\n    color: ").concat(dt2("select.option.selected.focus.color"), ";\n}\n\n.p-select-option-check-icon {\n    position: relative;\n    margin-inline-start: ").concat(dt2("select.checkmark.gutter.start"), ";\n    margin-inline-end: ").concat(dt2("select.checkmark.gutter.end"), ";\n    color: ").concat(dt2("select.checkmark.color"), ";\n}\n\n.p-select-empty-message {\n    padding: ").concat(dt2("select.empty.message.padding"), ";\n}\n\n.p-select-fluid {\n    display: flex;\n}\n");
}, "theme");
var classes$l = {
  root: /* @__PURE__ */ __name(function root11(_ref2) {
    var instance = _ref2.instance, props = _ref2.props, state = _ref2.state;
    return ["p-select p-component p-inputwrapper", {
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled",
      "p-focus": state.focused,
      "p-inputwrapper-filled": instance.hasSelectedOption,
      "p-inputwrapper-focus": state.focused || state.overlayVisible,
      "p-select-open": state.overlayVisible,
      "p-select-fluid": instance.hasFluid
    }];
  }, "root"),
  label: /* @__PURE__ */ __name(function label(_ref3) {
    var instance = _ref3.instance, props = _ref3.props;
    return ["p-select-label", {
      "p-placeholder": !props.editable && instance.label === props.placeholder,
      "p-select-label-empty": !props.editable && !instance.$slots["value"] && (instance.label === "p-emptylabel" || instance.label.length === 0)
    }];
  }, "label"),
  clearIcon: "p-select-clear-icon",
  dropdown: "p-select-dropdown",
  loadingicon: "p-select-loading-icon",
  dropdownIcon: "p-select-dropdown-icon",
  overlay: "p-select-overlay p-component",
  header: "p-select-header",
  pcFilter: "p-select-filter",
  listContainer: "p-select-list-container",
  list: "p-select-list",
  optionGroup: "p-select-option-group",
  optionGroupLabel: "p-select-option-group-label",
  option: /* @__PURE__ */ __name(function option2(_ref4) {
    var instance = _ref4.instance, props = _ref4.props, state = _ref4.state, _option = _ref4.option, focusedOption = _ref4.focusedOption;
    return ["p-select-option", {
      "p-select-option-selected": instance.isSelected(_option) && props.highlightOnSelect,
      "p-focus": state.focusedOptionIndex === focusedOption,
      "p-disabled": instance.isOptionDisabled(_option)
    }];
  }, "option"),
  optionLabel: "p-select-option-label",
  optionCheckIcon: "p-select-option-check-icon",
  optionBlankIcon: "p-select-option-blank-icon",
  emptyMessage: "p-select-empty-message"
};
var SelectStyle = BaseStyle.extend({
  name: "select",
  theme: theme$l,
  classes: classes$l
});
var script$1$k = {
  name: "BaseSelect",
  "extends": script$Y,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: [String, Function],
    optionValue: [String, Function],
    optionDisabled: [String, Function],
    optionGroupLabel: [String, Function],
    optionGroupChildren: [String, Function],
    scrollHeight: {
      type: String,
      "default": "14rem"
    },
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      "default": "contains"
    },
    filterFields: {
      type: Array,
      "default": null
    },
    editable: Boolean,
    placeholder: {
      type: String,
      "default": null
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    dataKey: null,
    showClear: {
      type: Boolean,
      "default": false
    },
    fluid: {
      type: Boolean,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    labelId: {
      type: String,
      "default": null
    },
    labelClass: {
      type: [String, Object],
      "default": null
    },
    labelStyle: {
      type: Object,
      "default": null
    },
    panelClass: {
      type: [String, Object],
      "default": null
    },
    overlayStyle: {
      type: Object,
      "default": null
    },
    overlayClass: {
      type: [String, Object],
      "default": null
    },
    panelStyle: {
      type: Object,
      "default": null
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    loading: {
      type: Boolean,
      "default": false
    },
    clearIcon: {
      type: String,
      "default": void 0
    },
    dropdownIcon: {
      type: String,
      "default": void 0
    },
    filterIcon: {
      type: String,
      "default": void 0
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    resetFilterOnHide: {
      type: Boolean,
      "default": false
    },
    resetFilterOnClear: {
      type: Boolean,
      "default": false
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    autoOptionFocus: {
      type: Boolean,
      "default": false
    },
    autoFilterFocus: {
      type: Boolean,
      "default": false
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    focusOnHover: {
      type: Boolean,
      "default": true
    },
    highlightOnSelect: {
      type: Boolean,
      "default": true
    },
    checkmark: {
      type: Boolean,
      "default": false
    },
    filterMessage: {
      type: String,
      "default": null
    },
    selectionMessage: {
      type: String,
      "default": null
    },
    emptySelectionMessage: {
      type: String,
      "default": null
    },
    emptyFilterMessage: {
      type: String,
      "default": null
    },
    emptyMessage: {
      type: String,
      "default": null
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: SelectStyle,
  provide: /* @__PURE__ */ __name(function provide18() {
    return {
      $pcSelect: this,
      $parentInstance: this
    };
  }, "provide")
};
function _typeof$a(o) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$a(o);
}
__name(_typeof$a, "_typeof$a");
function _toConsumableArray$7(r) {
  return _arrayWithoutHoles$7(r) || _iterableToArray$7(r) || _unsupportedIterableToArray$a(r) || _nonIterableSpread$7();
}
__name(_toConsumableArray$7, "_toConsumableArray$7");
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$7, "_nonIterableSpread$7");
function _unsupportedIterableToArray$a(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$a(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$a(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$a, "_unsupportedIterableToArray$a");
function _iterableToArray$7(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$7, "_iterableToArray$7");
function _arrayWithoutHoles$7(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$a(r);
}
__name(_arrayWithoutHoles$7, "_arrayWithoutHoles$7");
function _arrayLikeToArray$a(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$a, "_arrayLikeToArray$a");
function ownKeys$c(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$c, "ownKeys$c");
function _objectSpread$c(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$c(Object(t), true).forEach(function(r2) {
      _defineProperty$a(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$c, "_objectSpread$c");
function _defineProperty$a(e, r, t) {
  return (r = _toPropertyKey$9(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$a, "_defineProperty$a");
function _toPropertyKey$9(t) {
  var i2 = _toPrimitive$9(t, "string");
  return "symbol" == _typeof$a(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$9, "_toPropertyKey$9");
function _toPrimitive$9(t, r) {
  if ("object" != _typeof$a(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$a(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$9, "_toPrimitive$9");
var script$y = {
  name: "Select",
  "extends": script$1$k,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "before-show", "before-hide", "show", "hide", "filter"],
  inject: {
    $pcFluid: {
      "default": null
    }
  },
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  labelClickListener: null,
  overlay: null,
  list: null,
  virtualScroller: null,
  searchTimeout: null,
  searchValue: null,
  isModelValueChanged: false,
  data: /* @__PURE__ */ __name(function data7() {
    return {
      id: this.$attrs.id,
      clicked: false,
      focused: false,
      focusedOptionIndex: -1,
      filterValue: null,
      overlayVisible: false
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId4(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    modelValue: /* @__PURE__ */ __name(function modelValue2() {
      this.isModelValueChanged = true;
    }, "modelValue"),
    options: /* @__PURE__ */ __name(function options2() {
      this.autoUpdateModel();
    }, "options")
  },
  mounted: /* @__PURE__ */ __name(function mounted7() {
    this.id = this.id || UniqueComponentId();
    this.autoUpdateModel();
    this.bindLabelClickListener();
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated4() {
    if (this.overlayVisible && this.isModelValueChanged) {
      this.scrollInView(this.findSelectedOptionIndex());
    }
    this.isModelValueChanged = false;
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount3() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();
    this.unbindLabelClickListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    if (this.overlay) {
      ZIndex.clear(this.overlay);
      this.overlay = null;
    }
  }, "beforeUnmount"),
  methods: {
    getOptionIndex: /* @__PURE__ */ __name(function getOptionIndex2(index2, fn) {
      return this.virtualScrollerDisabled ? index2 : fn && fn(index2)["index"];
    }, "getOptionIndex"),
    getOptionLabel: /* @__PURE__ */ __name(function getOptionLabel2(option3) {
      return this.optionLabel ? resolveFieldData(option3, this.optionLabel) : option3;
    }, "getOptionLabel"),
    getOptionValue: /* @__PURE__ */ __name(function getOptionValue2(option3) {
      return this.optionValue ? resolveFieldData(option3, this.optionValue) : option3;
    }, "getOptionValue"),
    getOptionRenderKey: /* @__PURE__ */ __name(function getOptionRenderKey2(option3, index2) {
      return (this.dataKey ? resolveFieldData(option3, this.dataKey) : this.getOptionLabel(option3)) + "_" + index2;
    }, "getOptionRenderKey"),
    getPTItemOptions: /* @__PURE__ */ __name(function getPTItemOptions(option3, itemOptions, index2, key) {
      return this.ptm(key, {
        context: {
          option: option3,
          index: index2,
          selected: this.isSelected(option3),
          focused: this.focusedOptionIndex === this.getOptionIndex(index2, itemOptions),
          disabled: this.isOptionDisabled(option3)
        }
      });
    }, "getPTItemOptions"),
    isOptionDisabled: /* @__PURE__ */ __name(function isOptionDisabled2(option3) {
      return this.optionDisabled ? resolveFieldData(option3, this.optionDisabled) : false;
    }, "isOptionDisabled"),
    isOptionGroup: /* @__PURE__ */ __name(function isOptionGroup2(option3) {
      return this.optionGroupLabel && option3.optionGroup && option3.group;
    }, "isOptionGroup"),
    getOptionGroupLabel: /* @__PURE__ */ __name(function getOptionGroupLabel2(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupLabel);
    }, "getOptionGroupLabel"),
    getOptionGroupChildren: /* @__PURE__ */ __name(function getOptionGroupChildren2(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupChildren);
    }, "getOptionGroupChildren"),
    getAriaPosInset: /* @__PURE__ */ __name(function getAriaPosInset2(index2) {
      var _this = this;
      return (this.optionGroupLabel ? index2 - this.visibleOptions.slice(0, index2).filter(function(option3) {
        return _this.isOptionGroup(option3);
      }).length : index2) + 1;
    }, "getAriaPosInset"),
    show: /* @__PURE__ */ __name(function show(isFocus) {
      this.$emit("before-show");
      this.overlayVisible = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex();
      isFocus && focus(this.$refs.focusInput);
    }, "show"),
    hide: /* @__PURE__ */ __name(function hide(isFocus) {
      var _this2 = this;
      var _hide = /* @__PURE__ */ __name(function _hide2() {
        _this2.$emit("before-hide");
        _this2.overlayVisible = false;
        _this2.clicked = false;
        _this2.focusedOptionIndex = -1;
        _this2.searchValue = "";
        _this2.resetFilterOnHide && (_this2.filterValue = null);
        isFocus && focus(_this2.$refs.focusInput);
      }, "_hide");
      setTimeout(function() {
        _hide();
      }, 0);
    }, "hide"),
    onFocus: /* @__PURE__ */ __name(function onFocus2(event2) {
      if (this.disabled) {
        return;
      }
      this.focused = true;
      if (this.overlayVisible) {
        this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex();
        this.scrollInView(this.focusedOptionIndex);
      }
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur2(event2) {
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.searchValue = "";
      this.$emit("blur", event2);
    }, "onBlur"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown3(event2) {
      if (this.disabled || isAndroid$1()) {
        event2.preventDefault();
        return;
      }
      var metaKey = event2.metaKey || event2.ctrlKey;
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2, this.editable);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, this.editable);
          break;
        case "Home":
          this.onHomeKey(event2, this.editable);
          break;
        case "End":
          this.onEndKey(event2, this.editable);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Space":
          this.onSpaceKey(event2, this.editable);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2);
          break;
        case "Backspace":
          this.onBackspaceKey(event2, this.editable);
          break;
        case "ShiftLeft":
        case "ShiftRight":
          break;
        default:
          if (!metaKey && isPrintableCharacter(event2.key)) {
            !this.overlayVisible && this.show();
            !this.editable && this.searchOptions(event2, event2.key);
          }
          break;
      }
      this.clicked = false;
    }, "onKeyDown"),
    onEditableInput: /* @__PURE__ */ __name(function onEditableInput(event2) {
      var value3 = event2.target.value;
      this.searchValue = "";
      var matched = this.searchOptions(event2, value3);
      !matched && (this.focusedOptionIndex = -1);
      this.updateModel(event2, value3);
      !this.overlayVisible && isNotEmpty(value3) && this.show();
    }, "onEditableInput"),
    onContainerClick: /* @__PURE__ */ __name(function onContainerClick(event2) {
      if (this.disabled || this.loading) {
        return;
      }
      if (event2.target.tagName === "INPUT" || event2.target.getAttribute("data-pc-section") === "clearicon" || event2.target.closest('[data-pc-section="clearicon"]')) {
        return;
      } else if (!this.overlay || !this.overlay.contains(event2.target)) {
        this.overlayVisible ? this.hide(true) : this.show(true);
      }
      this.clicked = true;
    }, "onContainerClick"),
    onClearClick: /* @__PURE__ */ __name(function onClearClick(event2) {
      this.updateModel(event2, null);
      this.resetFilterOnClear && (this.filterValue = null);
    }, "onClearClick"),
    onFirstHiddenFocus: /* @__PURE__ */ __name(function onFirstHiddenFocus2(event2) {
      var focusableEl = event2.relatedTarget === this.$refs.focusInput ? getFirstFocusableElement(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput;
      focus(focusableEl);
    }, "onFirstHiddenFocus"),
    onLastHiddenFocus: /* @__PURE__ */ __name(function onLastHiddenFocus2(event2) {
      var focusableEl = event2.relatedTarget === this.$refs.focusInput ? getLastFocusableElement(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput;
      focus(focusableEl);
    }, "onLastHiddenFocus"),
    onOptionSelect: /* @__PURE__ */ __name(function onOptionSelect2(event2, option3) {
      var isHide = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var value3 = this.getOptionValue(option3);
      this.updateModel(event2, value3);
      isHide && this.hide(true);
    }, "onOptionSelect"),
    onOptionMouseMove: /* @__PURE__ */ __name(function onOptionMouseMove2(event2, index2) {
      if (this.focusOnHover) {
        this.changeFocusedOptionIndex(event2, index2);
      }
    }, "onOptionMouseMove"),
    onFilterChange: /* @__PURE__ */ __name(function onFilterChange2(event2) {
      var value3 = event2.target.value;
      this.filterValue = value3;
      this.focusedOptionIndex = -1;
      this.$emit("filter", {
        originalEvent: event2,
        value: value3
      });
      !this.virtualScrollerDisabled && this.virtualScroller.scrollToIndex(0);
    }, "onFilterChange"),
    onFilterKeyDown: /* @__PURE__ */ __name(function onFilterKeyDown2(event2) {
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2, true);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, true);
          break;
        case "Home":
          this.onHomeKey(event2, true);
          break;
        case "End":
          this.onEndKey(event2, true);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2, true);
          break;
      }
    }, "onFilterKeyDown"),
    onFilterBlur: /* @__PURE__ */ __name(function onFilterBlur2() {
      this.focusedOptionIndex = -1;
    }, "onFilterBlur"),
    onFilterUpdated: /* @__PURE__ */ __name(function onFilterUpdated() {
      if (this.overlayVisible) {
        this.alignOverlay();
      }
    }, "onFilterUpdated"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.$el
      });
    }, "onOverlayClick"),
    onOverlayKeyDown: /* @__PURE__ */ __name(function onOverlayKeyDown(event2) {
      switch (event2.code) {
        case "Escape":
          this.onEscapeKey(event2);
          break;
      }
    }, "onOverlayKeyDown"),
    onArrowDownKey: /* @__PURE__ */ __name(function onArrowDownKey2(event2) {
      if (!this.overlayVisible) {
        this.show();
        this.editable && this.changeFocusedOptionIndex(event2, this.findSelectedOptionIndex());
      } else {
        var optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findFirstOptionIndex() : this.findFirstFocusedOptionIndex();
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    }, "onArrowDownKey"),
    onArrowUpKey: /* @__PURE__ */ __name(function onArrowUpKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (event2.altKey && !pressedInInputText) {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
        }
        this.overlayVisible && this.hide();
        event2.preventDefault();
      } else {
        var optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findLastOptionIndex() : this.findLastFocusedOptionIndex();
        this.changeFocusedOptionIndex(event2, optionIndex);
        !this.overlayVisible && this.show();
        event2.preventDefault();
      }
    }, "onArrowUpKey"),
    onArrowLeftKey: /* @__PURE__ */ __name(function onArrowLeftKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      pressedInInputText && (this.focusedOptionIndex = -1);
    }, "onArrowLeftKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(0, event2.target.selectionStart);
        } else {
          target.setSelectionRange(0, 0);
          this.focusedOptionIndex = -1;
        }
      } else {
        this.changeFocusedOptionIndex(event2, this.findFirstOptionIndex());
        !this.overlayVisible && this.show();
      }
      event2.preventDefault();
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(event2.target.selectionStart, target.value.length);
        } else {
          var len = target.value.length;
          target.setSelectionRange(len, len);
          this.focusedOptionIndex = -1;
        }
      } else {
        this.changeFocusedOptionIndex(event2, this.findLastOptionIndex());
        !this.overlayVisible && this.show();
      }
      event2.preventDefault();
    }, "onEndKey"),
    onPageUpKey: /* @__PURE__ */ __name(function onPageUpKey2(event2) {
      this.scrollInView(0);
      event2.preventDefault();
    }, "onPageUpKey"),
    onPageDownKey: /* @__PURE__ */ __name(function onPageDownKey2(event2) {
      this.scrollInView(this.visibleOptions.length - 1);
      event2.preventDefault();
    }, "onPageDownKey"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey2(event2) {
      if (!this.overlayVisible) {
        this.focusedOptionIndex = -1;
        this.onArrowDownKey(event2);
      } else {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
        }
        this.hide();
      }
      event2.preventDefault();
    }, "onEnterKey"),
    onSpaceKey: /* @__PURE__ */ __name(function onSpaceKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      !pressedInInputText && this.onEnterKey(event2);
    }, "onSpaceKey"),
    onEscapeKey: /* @__PURE__ */ __name(function onEscapeKey(event2) {
      this.overlayVisible && this.hide(true);
      event2.preventDefault();
      event2.stopPropagation();
    }, "onEscapeKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!pressedInInputText) {
        if (this.overlayVisible && this.hasFocusableElements()) {
          focus(this.$refs.firstHiddenFocusableElementOnOverlay);
          event2.preventDefault();
        } else {
          if (this.focusedOptionIndex !== -1) {
            this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
          }
          this.overlayVisible && this.hide(this.filter);
        }
      }
    }, "onTabKey"),
    onBackspaceKey: /* @__PURE__ */ __name(function onBackspaceKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        !this.overlayVisible && this.show();
      }
    }, "onBackspaceKey"),
    onOverlayEnter: /* @__PURE__ */ __name(function onOverlayEnter(el) {
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
      addStyle(el, {
        position: "absolute",
        top: "0",
        left: "0"
      });
      this.alignOverlay();
      this.scrollInView();
      this.autoFilterFocus && focus(this.$refs.filterInput.$el);
    }, "onOverlayEnter"),
    onOverlayAfterEnter: /* @__PURE__ */ __name(function onOverlayAfterEnter() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.$emit("show");
    }, "onOverlayAfterEnter"),
    onOverlayLeave: /* @__PURE__ */ __name(function onOverlayLeave() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.autoFilterFocus && focus(this.$refs.focusInput);
      this.$emit("hide");
      this.overlay = null;
    }, "onOverlayLeave"),
    onOverlayAfterLeave: /* @__PURE__ */ __name(function onOverlayAfterLeave(el) {
      ZIndex.clear(el);
    }, "onOverlayAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay2() {
      if (this.appendTo === "self") {
        relativePosition(this.overlay, this.$el);
      } else {
        this.overlay.style.minWidth = getOuterWidth(this.$el) + "px";
        absolutePosition(this.overlay, this.$el);
      }
    }, "alignOverlay"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener() {
      var _this3 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this3.overlayVisible && _this3.overlay && !_this3.$el.contains(event2.target) && !_this3.overlay.contains(event2.target)) {
            _this3.hide();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener() {
      var _this4 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, function() {
          if (_this4.overlayVisible) {
            _this4.hide();
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener2() {
      var _this5 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this5.overlayVisible && !isTouchDevice()) {
            _this5.hide();
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener2() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    bindLabelClickListener: /* @__PURE__ */ __name(function bindLabelClickListener() {
      var _this6 = this;
      if (!this.editable && !this.labelClickListener) {
        var label5 = document.querySelector('label[for="'.concat(this.inputId, '"]'));
        if (label5 && isVisible(label5)) {
          this.labelClickListener = function() {
            focus(_this6.$refs.focusInput);
          };
          label5.addEventListener("click", this.labelClickListener);
        }
      }
    }, "bindLabelClickListener"),
    unbindLabelClickListener: /* @__PURE__ */ __name(function unbindLabelClickListener() {
      if (this.labelClickListener) {
        var label5 = document.querySelector('label[for="'.concat(this.inputId, '"]'));
        if (label5 && isVisible(label5)) {
          label5.removeEventListener("click", this.labelClickListener);
        }
      }
    }, "unbindLabelClickListener"),
    hasFocusableElements: /* @__PURE__ */ __name(function hasFocusableElements() {
      return getFocusableElements(this.overlay, ':not([data-p-hidden-focusable="true"])').length > 0;
    }, "hasFocusableElements"),
    isOptionMatched: /* @__PURE__ */ __name(function isOptionMatched2(option3) {
      var _this$getOptionLabel;
      return this.isValidOption(option3) && typeof this.getOptionLabel(option3) === "string" && ((_this$getOptionLabel = this.getOptionLabel(option3)) === null || _this$getOptionLabel === void 0 ? void 0 : _this$getOptionLabel.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale)));
    }, "isOptionMatched"),
    isValidOption: /* @__PURE__ */ __name(function isValidOption2(option3) {
      return isNotEmpty(option3) && !(this.isOptionDisabled(option3) || this.isOptionGroup(option3));
    }, "isValidOption"),
    isValidSelectedOption: /* @__PURE__ */ __name(function isValidSelectedOption2(option3) {
      return this.isValidOption(option3) && this.isSelected(option3);
    }, "isValidSelectedOption"),
    isSelected: /* @__PURE__ */ __name(function isSelected2(option3) {
      return this.isValidOption(option3) && equals(this.modelValue, this.getOptionValue(option3), this.equalityKey);
    }, "isSelected"),
    findFirstOptionIndex: /* @__PURE__ */ __name(function findFirstOptionIndex2() {
      var _this7 = this;
      return this.visibleOptions.findIndex(function(option3) {
        return _this7.isValidOption(option3);
      });
    }, "findFirstOptionIndex"),
    findLastOptionIndex: /* @__PURE__ */ __name(function findLastOptionIndex2() {
      var _this8 = this;
      return findLastIndex(this.visibleOptions, function(option3) {
        return _this8.isValidOption(option3);
      });
    }, "findLastOptionIndex"),
    findNextOptionIndex: /* @__PURE__ */ __name(function findNextOptionIndex2(index2) {
      var _this9 = this;
      var matchedOptionIndex = index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option3) {
        return _this9.isValidOption(option3);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : index2;
    }, "findNextOptionIndex"),
    findPrevOptionIndex: /* @__PURE__ */ __name(function findPrevOptionIndex2(index2) {
      var _this10 = this;
      var matchedOptionIndex = index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option3) {
        return _this10.isValidOption(option3);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    }, "findPrevOptionIndex"),
    findSelectedOptionIndex: /* @__PURE__ */ __name(function findSelectedOptionIndex2() {
      var _this11 = this;
      return this.hasSelectedOption ? this.visibleOptions.findIndex(function(option3) {
        return _this11.isValidSelectedOption(option3);
      }) : -1;
    }, "findSelectedOptionIndex"),
    findFirstFocusedOptionIndex: /* @__PURE__ */ __name(function findFirstFocusedOptionIndex2() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    }, "findFirstFocusedOptionIndex"),
    findLastFocusedOptionIndex: /* @__PURE__ */ __name(function findLastFocusedOptionIndex2() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    }, "findLastFocusedOptionIndex"),
    searchOptions: /* @__PURE__ */ __name(function searchOptions2(event2, _char) {
      var _this12 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var optionIndex = -1;
      var matched = false;
      if (isNotEmpty(this.searchValue)) {
        if (this.focusedOptionIndex !== -1) {
          optionIndex = this.visibleOptions.slice(this.focusedOptionIndex).findIndex(function(option3) {
            return _this12.isOptionMatched(option3);
          });
          optionIndex = optionIndex === -1 ? this.visibleOptions.slice(0, this.focusedOptionIndex).findIndex(function(option3) {
            return _this12.isOptionMatched(option3);
          }) : optionIndex + this.focusedOptionIndex;
        } else {
          optionIndex = this.visibleOptions.findIndex(function(option3) {
            return _this12.isOptionMatched(option3);
          });
        }
        if (optionIndex !== -1) {
          matched = true;
        }
        if (optionIndex === -1 && this.focusedOptionIndex === -1) {
          optionIndex = this.findFirstFocusedOptionIndex();
        }
        if (optionIndex !== -1) {
          this.changeFocusedOptionIndex(event2, optionIndex);
        }
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this12.searchValue = "";
        _this12.searchTimeout = null;
      }, 500);
      return matched;
    }, "searchOptions"),
    changeFocusedOptionIndex: /* @__PURE__ */ __name(function changeFocusedOptionIndex2(event2, index2) {
      if (this.focusedOptionIndex !== index2) {
        this.focusedOptionIndex = index2;
        this.scrollInView();
        if (this.selectOnFocus) {
          this.onOptionSelect(event2, this.visibleOptions[index2], false);
        }
      }
    }, "changeFocusedOptionIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView4() {
      var _this13 = this;
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var id3 = index2 !== -1 ? "".concat(_this13.id, "_").concat(index2) : _this13.focusedOptionId;
        var element = findSingle(_this13.list, 'li[id="'.concat(id3, '"]'));
        if (element) {
          element.scrollIntoView && element.scrollIntoView({
            block: "nearest",
            inline: "start"
          });
        } else if (!_this13.virtualScrollerDisabled) {
          _this13.virtualScroller && _this13.virtualScroller.scrollToIndex(index2 !== -1 ? index2 : _this13.focusedOptionIndex);
        }
      });
    }, "scrollInView"),
    autoUpdateModel: /* @__PURE__ */ __name(function autoUpdateModel2() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], false);
      }
    }, "autoUpdateModel"),
    updateModel: /* @__PURE__ */ __name(function updateModel3(event2, value3) {
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        originalEvent: event2,
        value: value3
      });
    }, "updateModel"),
    flatOptions: /* @__PURE__ */ __name(function flatOptions2(options3) {
      var _this14 = this;
      return (options3 || []).reduce(function(result, option3, index2) {
        result.push({
          optionGroup: option3,
          group: true,
          index: index2
        });
        var optionGroupChildren = _this14.getOptionGroupChildren(option3);
        optionGroupChildren && optionGroupChildren.forEach(function(o) {
          return result.push(o);
        });
        return result;
      }, []);
    }, "flatOptions"),
    overlayRef: /* @__PURE__ */ __name(function overlayRef(el) {
      this.overlay = el;
    }, "overlayRef"),
    listRef: /* @__PURE__ */ __name(function listRef2(el, contentRef3) {
      this.list = el;
      contentRef3 && contentRef3(el);
    }, "listRef"),
    virtualScrollerRef: /* @__PURE__ */ __name(function virtualScrollerRef2(el) {
      this.virtualScroller = el;
    }, "virtualScrollerRef")
  },
  computed: {
    visibleOptions: /* @__PURE__ */ __name(function visibleOptions2() {
      var _this15 = this;
      var options3 = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
      if (this.filterValue) {
        var filteredOptions = FilterService.filter(options3, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale);
        if (this.optionGroupLabel) {
          var optionGroups = this.options || [];
          var filtered = [];
          optionGroups.forEach(function(group) {
            var groupChildren = _this15.getOptionGroupChildren(group);
            var filteredItems = groupChildren.filter(function(item2) {
              return filteredOptions.includes(item2);
            });
            if (filteredItems.length > 0) filtered.push(_objectSpread$c(_objectSpread$c({}, group), {}, _defineProperty$a({}, typeof _this15.optionGroupChildren === "string" ? _this15.optionGroupChildren : "items", _toConsumableArray$7(filteredItems))));
          });
          return this.flatOptions(filtered);
        }
        return filteredOptions;
      }
      return options3;
    }, "visibleOptions"),
    hasSelectedOption: /* @__PURE__ */ __name(function hasSelectedOption2() {
      return isNotEmpty(this.modelValue);
    }, "hasSelectedOption"),
    label: /* @__PURE__ */ __name(function label2() {
      var selectedOptionIndex = this.findSelectedOptionIndex();
      return selectedOptionIndex !== -1 ? this.getOptionLabel(this.visibleOptions[selectedOptionIndex]) : this.placeholder || "p-emptylabel";
    }, "label"),
    editableInputValue: /* @__PURE__ */ __name(function editableInputValue() {
      var selectedOptionIndex = this.findSelectedOptionIndex();
      return selectedOptionIndex !== -1 ? this.getOptionLabel(this.visibleOptions[selectedOptionIndex]) : this.modelValue || "";
    }, "editableInputValue"),
    equalityKey: /* @__PURE__ */ __name(function equalityKey2() {
      return this.optionValue ? null : this.dataKey;
    }, "equalityKey"),
    searchFields: /* @__PURE__ */ __name(function searchFields2() {
      return this.filterFields || [this.optionLabel];
    }, "searchFields"),
    filterResultMessageText: /* @__PURE__ */ __name(function filterResultMessageText2() {
      return isNotEmpty(this.visibleOptions) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptyFilterMessageText;
    }, "filterResultMessageText"),
    filterMessageText: /* @__PURE__ */ __name(function filterMessageText2() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || "";
    }, "filterMessageText"),
    emptyFilterMessageText: /* @__PURE__ */ __name(function emptyFilterMessageText2() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || "";
    }, "emptyFilterMessageText"),
    emptyMessageText: /* @__PURE__ */ __name(function emptyMessageText2() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || "";
    }, "emptyMessageText"),
    selectionMessageText: /* @__PURE__ */ __name(function selectionMessageText2() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    }, "selectionMessageText"),
    emptySelectionMessageText: /* @__PURE__ */ __name(function emptySelectionMessageText2() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    }, "emptySelectionMessageText"),
    selectedMessageText: /* @__PURE__ */ __name(function selectedMessageText2() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll("{0}", "1") : this.emptySelectionMessageText;
    }, "selectedMessageText"),
    focusedOptionId: /* @__PURE__ */ __name(function focusedOptionId2() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.id, "_").concat(this.focusedOptionIndex) : null;
    }, "focusedOptionId"),
    ariaSetSize: /* @__PURE__ */ __name(function ariaSetSize2() {
      var _this16 = this;
      return this.visibleOptions.filter(function(option3) {
        return !_this16.isOptionGroup(option3);
      }).length;
    }, "ariaSetSize"),
    isClearIconVisible: /* @__PURE__ */ __name(function isClearIconVisible() {
      return this.showClear && this.modelValue != null && isNotEmpty(this.options);
    }, "isClearIconVisible"),
    virtualScrollerDisabled: /* @__PURE__ */ __name(function virtualScrollerDisabled2() {
      return !this.virtualScrollerOptions;
    }, "virtualScrollerDisabled"),
    hasFluid: /* @__PURE__ */ __name(function hasFluid4() {
      return isEmpty(this.fluid) ? !!this.$pcFluid : this.fluid;
    }, "hasFluid")
  },
  directives: {
    ripple: Ripple
  },
  components: {
    InputText: script$R,
    VirtualScroller: script$P,
    Portal: script$z,
    InputIcon: script$S,
    IconField: script$T,
    TimesIcon: script$A,
    ChevronDownIcon: script$B,
    SpinnerIcon: script$Q,
    SearchIcon: script$U,
    CheckIcon: script$V,
    BlankIcon: script$W
  }
};
var _hoisted_1$Y = ["id"];
var _hoisted_2$I = ["id", "value", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid"];
var _hoisted_3$n = ["id", "tabindex", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-disabled"];
var _hoisted_4$g = ["id"];
var _hoisted_5$b = ["id"];
var _hoisted_6$7 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousemove", "data-p-selected", "data-p-focused", "data-p-disabled"];
function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_BlankIcon = resolveComponent("BlankIcon");
  var _component_VirtualScroller = resolveComponent("VirtualScroller");
  var _component_Portal = resolveComponent("Portal");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    id: $data.id,
    "class": _ctx.cx("root"),
    onClick: _cache[11] || (_cache[11] = function() {
      return $options.onContainerClick && $options.onContainerClick.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [_ctx.editable ? (openBlock(), createElementBlock("input", mergeProps({
    key: 0,
    ref: "focusInput",
    id: _ctx.labelId || _ctx.inputId,
    type: "text",
    "class": [_ctx.cx("label"), _ctx.inputClass, _ctx.labelClass],
    style: [_ctx.inputStyle, _ctx.labelStyle],
    value: $options.editableInputValue,
    placeholder: _ctx.placeholder,
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    disabled: _ctx.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $data.id + "_list",
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onKeydown: _cache[2] || (_cache[2] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    }),
    onInput: _cache[3] || (_cache[3] = function() {
      return $options.onEditableInput && $options.onEditableInput.apply($options, arguments);
    })
  }, _ctx.ptm("label")), null, 16, _hoisted_2$I)) : (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    ref: "focusInput",
    id: _ctx.labelId || _ctx.inputId,
    "class": [_ctx.cx("label"), _ctx.inputClass, _ctx.labelClass],
    style: [_ctx.inputStyle, _ctx.labelStyle],
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    role: "combobox",
    "aria-label": _ctx.ariaLabel || ($options.label === "p-emptylabel" ? void 0 : $options.label),
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $data.id + "_list",
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    "aria-disabled": _ctx.disabled,
    onFocus: _cache[4] || (_cache[4] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[5] || (_cache[5] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onKeydown: _cache[6] || (_cache[6] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    })
  }, _ctx.ptm("label")), [renderSlot(_ctx.$slots, "value", {
    value: _ctx.modelValue,
    placeholder: _ctx.placeholder
  }, function() {
    return [createTextVNode(toDisplayString$1($options.label === "p-emptylabel" ? "" : $options.label || "empty"), 1)];
  })], 16, _hoisted_3$n)), $options.isClearIconVisible ? renderSlot(_ctx.$slots, "clearicon", {
    key: 2,
    "class": normalizeClass(_ctx.cx("clearIcon")),
    clearCallback: $options.onClearClick
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon ? "i" : "TimesIcon"), mergeProps({
      ref: "clearIcon",
      "class": [_ctx.cx("clearIcon"), _ctx.clearIcon],
      onClick: $options.onClearClick
    }, _ctx.ptm("clearIcon"), {
      "data-pc-section": "clearicon"
    }), null, 16, ["class", "onClick"]))];
  }) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("dropdown")
  }, _ctx.ptm("dropdown")), [_ctx.loading ? renderSlot(_ctx.$slots, "loadingicon", {
    key: 0,
    "class": normalizeClass(_ctx.cx("loadingIcon"))
  }, function() {
    return [_ctx.loadingIcon ? (openBlock(), createElementBlock("span", mergeProps({
      key: 0,
      "class": [_ctx.cx("loadingIcon"), "pi-spin", _ctx.loadingIcon],
      "aria-hidden": "true"
    }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
      key: 1,
      "class": _ctx.cx("loadingIcon"),
      spin: "",
      "aria-hidden": "true"
    }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
  }) : renderSlot(_ctx.$slots, "dropdownicon", {
    key: 1,
    "class": normalizeClass(_ctx.cx("dropdownIcon"))
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.dropdownIcon ? "span" : "ChevronDownIcon"), mergeProps({
      "class": [_ctx.cx("dropdownIcon"), _ctx.dropdownIcon],
      "aria-hidden": "true"
    }, _ctx.ptm("dropdownIcon")), null, 16, ["class"]))];
  })], 16), createVNode(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-connected-overlay",
        onEnter: $options.onOverlayEnter,
        onAfterEnter: $options.onOverlayAfterEnter,
        onLeave: $options.onOverlayLeave,
        onAfterLeave: $options.onOverlayAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.overlayRef,
            "class": [_ctx.cx("overlay"), _ctx.panelClass, _ctx.overlayClass],
            style: [_ctx.panelStyle, _ctx.overlayStyle],
            onClick: _cache[9] || (_cache[9] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            onKeydown: _cache[10] || (_cache[10] = function() {
              return $options.onOverlayKeyDown && $options.onOverlayKeyDown.apply($options, arguments);
            })
          }, _ctx.ptm("overlay")), [createBaseVNode("span", mergeProps({
            ref: "firstHiddenFocusableElementOnOverlay",
            role: "presentation",
            "aria-hidden": "true",
            "class": "p-hidden-accessible p-hidden-focusable",
            tabindex: 0,
            onFocus: _cache[7] || (_cache[7] = function() {
              return $options.onFirstHiddenFocus && $options.onFirstHiddenFocus.apply($options, arguments);
            })
          }, _ctx.ptm("hiddenFirstFocusableEl"), {
            "data-p-hidden-accessible": true,
            "data-p-hidden-focusable": true
          }), null, 16), renderSlot(_ctx.$slots, "header", {
            value: _ctx.modelValue,
            options: $options.visibleOptions
          }), _ctx.filter ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            "class": _ctx.cx("header")
          }, _ctx.ptm("header")), [createVNode(_component_IconField, {
            unstyled: _ctx.unstyled,
            pt: _ctx.ptm("pcFilterContainer")
          }, {
            "default": withCtx(function() {
              return [createVNode(_component_InputText, {
                ref: "filterInput",
                type: "text",
                value: $data.filterValue,
                onVnodeMounted: $options.onFilterUpdated,
                onVnodeUpdated: $options.onFilterUpdated,
                "class": normalizeClass(_ctx.cx("pcFilter")),
                placeholder: _ctx.filterPlaceholder,
                variant: _ctx.variant,
                unstyled: _ctx.unstyled,
                role: "searchbox",
                autocomplete: "off",
                "aria-owns": $data.id + "_list",
                "aria-activedescendant": $options.focusedOptionId,
                onKeydown: $options.onFilterKeyDown,
                onBlur: $options.onFilterBlur,
                onInput: $options.onFilterChange,
                pt: _ctx.ptm("pcFilter")
              }, null, 8, ["value", "onVnodeMounted", "onVnodeUpdated", "class", "placeholder", "variant", "unstyled", "aria-owns", "aria-activedescendant", "onKeydown", "onBlur", "onInput", "pt"]), createVNode(_component_InputIcon, mergeProps({
                unstyled: _ctx.unstyled
              }, _ctx.ptm("pcFilterIconContainer")), {
                "default": withCtx(function() {
                  return [renderSlot(_ctx.$slots, "filtericon", {}, function() {
                    return [_ctx.filterIcon ? (openBlock(), createElementBlock("span", mergeProps({
                      key: 0,
                      "class": _ctx.filterIcon
                    }, _ctx.ptm("filterIcon")), null, 16)) : (openBlock(), createBlock(_component_SearchIcon, normalizeProps(mergeProps({
                      key: 1
                    }, _ctx.ptm("filterIcon"))), null, 16))];
                  })];
                }),
                _: 3
              }, 16, ["unstyled"])];
            }),
            _: 3
          }, 8, ["unstyled", "pt"]), createBaseVNode("span", mergeProps({
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenFilterResult"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.filterResultMessageText), 17)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("listContainer"),
            style: {
              "max-height": $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
            }
          }, _ctx.ptm("listContainer")), [createVNode(_component_VirtualScroller, mergeProps({
            ref: $options.virtualScrollerRef
          }, _ctx.virtualScrollerOptions, {
            items: $options.visibleOptions,
            style: {
              height: _ctx.scrollHeight
            },
            tabindex: -1,
            disabled: $options.virtualScrollerDisabled,
            pt: _ctx.ptm("virtualScroller")
          }), createSlots({
            content: withCtx(function(_ref) {
              var styleClass = _ref.styleClass, contentRef3 = _ref.contentRef, items2 = _ref.items, getItemOptions = _ref.getItemOptions, contentStyle = _ref.contentStyle, itemSize2 = _ref.itemSize;
              return [createBaseVNode("ul", mergeProps({
                ref: /* @__PURE__ */ __name(function ref2(el) {
                  return $options.listRef(el, contentRef3);
                }, "ref"),
                id: $data.id + "_list",
                "class": [_ctx.cx("list"), styleClass],
                style: contentStyle,
                role: "listbox"
              }, _ctx.ptm("list")), [(openBlock(true), createElementBlock(Fragment, null, renderList(items2, function(option3, i2) {
                return openBlock(), createElementBlock(Fragment, {
                  key: $options.getOptionRenderKey(option3, $options.getOptionIndex(i2, getItemOptions))
                }, [$options.isOptionGroup(option3) ? (openBlock(), createElementBlock("li", mergeProps({
                  key: 0,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  "class": _ctx.cx("optionGroup"),
                  role: "option",
                  ref_for: true
                }, _ctx.ptm("optionGroup")), [renderSlot(_ctx.$slots, "optiongroup", {
                  option: option3.optionGroup,
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createBaseVNode("span", mergeProps({
                    "class": _ctx.cx("optionGroupLabel"),
                    ref_for: true
                  }, _ctx.ptm("optionGroupLabel")), toDisplayString$1($options.getOptionGroupLabel(option3.optionGroup)), 17)];
                })], 16, _hoisted_5$b)) : withDirectives((openBlock(), createElementBlock("li", mergeProps({
                  key: 1,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  "class": _ctx.cx("option", {
                    option: option3,
                    focusedOption: $options.getOptionIndex(i2, getItemOptions)
                  }),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  role: "option",
                  "aria-label": $options.getOptionLabel(option3),
                  "aria-selected": $options.isSelected(option3),
                  "aria-disabled": $options.isOptionDisabled(option3),
                  "aria-setsize": $options.ariaSetSize,
                  "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i2, getItemOptions)),
                  onClick: /* @__PURE__ */ __name(function onClick3($event) {
                    return $options.onOptionSelect($event, option3);
                  }, "onClick"),
                  onMousemove: /* @__PURE__ */ __name(function onMousemove($event) {
                    return $options.onOptionMouseMove($event, $options.getOptionIndex(i2, getItemOptions));
                  }, "onMousemove"),
                  "data-p-selected": $options.isSelected(option3),
                  "data-p-focused": $data.focusedOptionIndex === $options.getOptionIndex(i2, getItemOptions),
                  "data-p-disabled": $options.isOptionDisabled(option3),
                  ref_for: true
                }, $options.getPTItemOptions(option3, getItemOptions, i2, "option")), [_ctx.checkmark ? (openBlock(), createElementBlock(Fragment, {
                  key: 0
                }, [$options.isSelected(option3) ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
                  key: 0,
                  "class": _ctx.cx("optionCheckIcon"),
                  ref_for: true
                }, _ctx.ptm("optionCheckIcon")), null, 16, ["class"])) : (openBlock(), createBlock(_component_BlankIcon, mergeProps({
                  key: 1,
                  "class": _ctx.cx("optionBlankIcon"),
                  ref_for: true
                }, _ctx.ptm("optionBlankIcon")), null, 16, ["class"]))], 64)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "option", {
                  option: option3,
                  selected: $options.isSelected(option3),
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createBaseVNode("span", mergeProps({
                    "class": _ctx.cx("optionLabel"),
                    ref_for: true
                  }, _ctx.ptm("optionLabel")), toDisplayString$1($options.getOptionLabel(option3)), 17)];
                })], 16, _hoisted_6$7)), [[_directive_ripple]])], 64);
              }), 128)), $data.filterValue && (!items2 || items2 && items2.length === 0) ? (openBlock(), createElementBlock("li", mergeProps({
                key: 0,
                "class": _ctx.cx("emptyMessage"),
                role: "option"
              }, _ctx.ptm("emptyMessage"), {
                "data-p-hidden-accessible": true
              }), [renderSlot(_ctx.$slots, "emptyfilter", {}, function() {
                return [createTextVNode(toDisplayString$1($options.emptyFilterMessageText), 1)];
              })], 16)) : !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("li", mergeProps({
                key: 1,
                "class": _ctx.cx("emptyMessage"),
                role: "option"
              }, _ctx.ptm("emptyMessage"), {
                "data-p-hidden-accessible": true
              }), [renderSlot(_ctx.$slots, "empty", {}, function() {
                return [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)];
              })], 16)) : createCommentVNode("", true)], 16, _hoisted_4$g)];
            }),
            _: 2
          }, [_ctx.$slots.loader ? {
            name: "loader",
            fn: withCtx(function(_ref2) {
              var options3 = _ref2.options;
              return [renderSlot(_ctx.$slots, "loader", {
                options: options3
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["items", "style", "disabled", "pt"])], 16), renderSlot(_ctx.$slots, "footer", {
            value: _ctx.modelValue,
            options: $options.visibleOptions
          }), !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("span", mergeProps({
            key: 1,
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenEmptyMessage"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.emptyMessageText), 17)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenSelectedMessage"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.selectedMessageText), 17), createBaseVNode("span", mergeProps({
            ref: "lastHiddenFocusableElementOnOverlay",
            role: "presentation",
            "aria-hidden": "true",
            "class": "p-hidden-accessible p-hidden-focusable",
            tabindex: 0,
            onFocus: _cache[8] || (_cache[8] = function() {
              return $options.onLastHiddenFocus && $options.onLastHiddenFocus.apply($options, arguments);
            })
          }, _ctx.ptm("hiddenLastFocusableEl"), {
            "data-p-hidden-accessible": true,
            "data-p-hidden-focusable": true
          }), null, 16)], 16)) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"])], 16, _hoisted_1$Y);
}
__name(render$x, "render$x");
script$y.render = render$x;
var theme$k = /* @__PURE__ */ __name(function theme17(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-toggleswitch {\n    display: inline-block;\n    width: ".concat(dt2("toggleswitch.width"), ";\n    height: ").concat(dt2("toggleswitch.height"), ";\n}\n\n.p-toggleswitch-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border-radius: ").concat(dt2("toggleswitch.border.radius"), ";\n}\n\n.p-toggleswitch-slider {\n    display: inline-block;\n    cursor: pointer;\n    width: 100%;\n    height: 100%;\n    border-width: ").concat(dt2("toggleswitch.border.width"), ";\n    border-style: solid;\n    border-color: ").concat(dt2("toggleswitch.border.color"), ";\n    background: ").concat(dt2("toggleswitch.background"), ";\n    transition: background ").concat(dt2("toggleswitch.transition.duration"), ", color ").concat(dt2("toggleswitch.transition.duration"), ", border-color ").concat(dt2("toggleswitch.transition.duration"), ", outline-color ").concat(dt2("toggleswitch.transition.duration"), ", box-shadow ").concat(dt2("toggleswitch.transition.duration"), ";\n    border-radius: ").concat(dt2("toggleswitch.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt2("toggleswitch.shadow"), ';\n}\n\n.p-toggleswitch-slider:before {\n    position: absolute;\n    content: "";\n    top: 50%;\n    background: ').concat(dt2("toggleswitch.handle.background"), ";\n    width: ").concat(dt2("toggleswitch.handle.size"), ";\n    height: ").concat(dt2("toggleswitch.handle.size"), ";\n    left: ").concat(dt2("toggleswitch.gap"), ";\n    margin-top: calc(-1 * calc(").concat(dt2("toggleswitch.handle.size"), " / 2));\n    border-radius: ").concat(dt2("toggleswitch.handle.border.radius"), ";\n    transition: background ").concat(dt2("toggleswitch.transition.duration"), ", left ").concat(dt2("toggleswitch.slide.duration"), ";\n}\n\n.p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-slider {\n    background: ").concat(dt2("toggleswitch.checked.background"), ";\n    border-color: ").concat(dt2("toggleswitch.checked.border.color"), ";\n}\n\n.p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-slider:before {\n    background: ").concat(dt2("toggleswitch.handle.checked.background"), ";\n    left: calc(").concat(dt2("toggleswitch.width"), " - calc(").concat(dt2("toggleswitch.handle.size"), " + ").concat(dt2("toggleswitch.gap"), "));\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-slider {\n    background: ").concat(dt2("toggleswitch.hover.background"), ";\n    border-color: ").concat(dt2("toggleswitch.hover.border.color"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-slider:before {\n    background: ").concat(dt2("toggleswitch.handle.hover.background"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-slider {\n    background: ").concat(dt2("toggleswitch.checked.hover.background"), ";\n    border-color: ").concat(dt2("toggleswitch.checked.hover.border.color"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-slider:before {\n    background: ").concat(dt2("toggleswitch.handle.checked.hover.background"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:focus-visible) .p-toggleswitch-slider {\n    box-shadow: ").concat(dt2("toggleswitch.focus.ring.shadow"), ";\n    outline: ").concat(dt2("toggleswitch.focus.ring.width"), " ").concat(dt2("toggleswitch.focus.ring.style"), " ").concat(dt2("toggleswitch.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("toggleswitch.focus.ring.offset"), ";\n}\n\n.p-toggleswitch.p-invalid > .p-toggleswitch-slider {\n    border-color: ").concat(dt2("toggleswitch.invalid.border.color"), ";\n}\n\n.p-toggleswitch.p-disabled {\n    opacity: 1;\n}\n\n.p-toggleswitch.p-disabled .p-toggleswitch-slider {\n    background: ").concat(dt2("toggleswitch.disabled.background"), ";\n}\n\n.p-toggleswitch.p-disabled .p-toggleswitch-slider:before {\n    background: ").concat(dt2("toggleswitch.handle.disabled.background"), ";\n}\n");
}, "theme");
var inlineStyles$2 = {
  root: {
    position: "relative"
  }
};
var classes$k = {
  root: /* @__PURE__ */ __name(function root12(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-toggleswitch p-component", {
      "p-toggleswitch-checked": instance.checked,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid
    }];
  }, "root"),
  input: "p-toggleswitch-input",
  slider: "p-toggleswitch-slider"
};
var ToggleSwitchStyle = BaseStyle.extend({
  name: "toggleswitch",
  theme: theme$k,
  classes: classes$k,
  inlineStyles: inlineStyles$2
});
var script$1$j = {
  name: "BaseToggleSwitch",
  "extends": script$Y,
  props: {
    modelValue: {
      type: null,
      "default": false
    },
    trueValue: {
      type: null,
      "default": true
    },
    falseValue: {
      type: null,
      "default": false
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: ToggleSwitchStyle,
  provide: /* @__PURE__ */ __name(function provide19() {
    return {
      $pcToggleSwitch: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$x = {
  name: "ToggleSwitch",
  "extends": script$1$j,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur"],
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions4(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          checked: this.checked,
          disabled: this.disabled
        }
      });
    }, "getPTOptions"),
    onChange: /* @__PURE__ */ __name(function onChange(event2) {
      if (!this.disabled && !this.readonly) {
        var newValue = this.checked ? this.falseValue : this.trueValue;
        this.$emit("update:modelValue", newValue);
        this.$emit("change", event2);
      }
    }, "onChange"),
    onFocus: /* @__PURE__ */ __name(function onFocus3(event2) {
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur3(event2) {
      this.$emit("blur", event2);
    }, "onBlur")
  },
  computed: {
    checked: /* @__PURE__ */ __name(function checked() {
      return this.modelValue === this.trueValue;
    }, "checked")
  }
};
var _hoisted_1$X = ["data-p-checked", "data-p-disabled"];
var _hoisted_2$H = ["id", "checked", "tabindex", "disabled", "readonly", "aria-checked", "aria-labelledby", "aria-label", "aria-invalid"];
function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    style: _ctx.sx("root")
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.checked,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("input", mergeProps({
    id: _ctx.inputId,
    type: "checkbox",
    role: "switch",
    "class": [_ctx.cx("input"), _ctx.inputClass],
    style: _ctx.inputStyle,
    checked: $options.checked,
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    "aria-checked": $options.checked,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("input")), null, 16, _hoisted_2$H), createBaseVNode("span", mergeProps({
    "class": _ctx.cx("slider")
  }, $options.getPTOptions("slider")), null, 16)], 16, _hoisted_1$X);
}
__name(render$w, "render$w");
script$x.render = render$w;
var theme$j = /* @__PURE__ */ __name(function theme18(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-tag {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    background: ".concat(dt2("tag.primary.background"), ";\n    color: ").concat(dt2("tag.primary.color"), ";\n    font-size: ").concat(dt2("tag.font.size"), ";\n    font-weight: ").concat(dt2("tag.font.weight"), ";\n    padding: ").concat(dt2("tag.padding"), ";\n    border-radius: ").concat(dt2("tag.border.radius"), ";\n    gap: ").concat(dt2("tag.gap"), ";\n}\n\n.p-tag-icon {\n    font-size: ").concat(dt2("tag.icon.size"), ";\n    width: ").concat(dt2("tag.icon.size"), ";\n    height:").concat(dt2("tag.icon.size"), ";\n}\n\n.p-tag-rounded {\n    border-radius: ").concat(dt2("tag.rounded.border.radius"), ";\n}\n\n.p-tag-success {\n    background: ").concat(dt2("tag.success.background"), ";\n    color: ").concat(dt2("tag.success.color"), ";\n}\n\n.p-tag-info {\n    background: ").concat(dt2("tag.info.background"), ";\n    color: ").concat(dt2("tag.info.color"), ";\n}\n\n.p-tag-warn {\n    background: ").concat(dt2("tag.warn.background"), ";\n    color: ").concat(dt2("tag.warn.color"), ";\n}\n\n.p-tag-danger {\n    background: ").concat(dt2("tag.danger.background"), ";\n    color: ").concat(dt2("tag.danger.color"), ";\n}\n\n.p-tag-secondary {\n    background: ").concat(dt2("tag.secondary.background"), ";\n    color: ").concat(dt2("tag.secondary.color"), ";\n}\n\n.p-tag-contrast {\n    background: ").concat(dt2("tag.contrast.background"), ";\n    color: ").concat(dt2("tag.contrast.color"), ";\n}\n");
}, "theme");
var classes$j = {
  root: /* @__PURE__ */ __name(function root13(_ref2) {
    var props = _ref2.props;
    return ["p-tag p-component", {
      "p-tag-info": props.severity === "info",
      "p-tag-success": props.severity === "success",
      "p-tag-warn": props.severity === "warn",
      "p-tag-danger": props.severity === "danger",
      "p-tag-secondary": props.severity === "secondary",
      "p-tag-contrast": props.severity === "contrast",
      "p-tag-rounded": props.rounded
    }];
  }, "root"),
  icon: "p-tag-icon",
  label: "p-tag-label"
};
var TagStyle = BaseStyle.extend({
  name: "tag",
  theme: theme$j,
  classes: classes$j
});
var script$1$i = {
  name: "BaseTag",
  "extends": script$Y,
  props: {
    value: null,
    severity: null,
    rounded: Boolean,
    icon: String
  },
  style: TagStyle,
  provide: /* @__PURE__ */ __name(function provide20() {
    return {
      $pcTag: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$w = {
  name: "Tag",
  "extends": script$1$i,
  inheritAttrs: false
};
function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), mergeProps({
    key: 0,
    "class": _ctx.cx("icon")
  }, _ctx.ptm("icon")), null, 16, ["class"])) : _ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    "class": [_ctx.cx("icon"), _ctx.icon]
  }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true), _ctx.value != null || _ctx.$slots["default"] ? renderSlot(_ctx.$slots, "default", {
    key: 2
  }, function() {
    return [createBaseVNode("span", mergeProps({
      "class": _ctx.cx("label")
    }, _ctx.ptm("label")), toDisplayString$1(_ctx.value), 17)];
  }) : createCommentVNode("", true)], 16);
}
__name(render$v, "render$v");
script$w.render = render$v;
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "CustomSettingValue",
  props: {
    renderFunction: { type: Function }
  },
  setup(__props) {
    const props = __props;
    const container = ref(null);
    function renderContent() {
      if (container.value) {
        container.value.innerHTML = "";
        const element = props.renderFunction();
        container.value.appendChild(element);
      }
    }
    __name(renderContent, "renderContent");
    onMounted(renderContent);
    watch(() => props.renderFunction, renderContent);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container
      }, null, 512);
    };
  }
});
var theme$i = /* @__PURE__ */ __name(function theme19(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-slider {\n    position: relative;\n    background: ".concat(dt2("slider.track.background"), ";\n    border-radius: ").concat(dt2("slider.border.radius"), ";\n}\n\n.p-slider-handle {\n    cursor: grab;\n    touch-action: none;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: ").concat(dt2("slider.handle.height"), ";\n    width: ").concat(dt2("slider.handle.width"), ";\n    background: ").concat(dt2("slider.handle.background"), ";\n    border-radius: ").concat(dt2("slider.handle.border.radius"), ";\n    transition: background ").concat(dt2("slider.transition.duration"), ", color ").concat(dt2("slider.transition.duration"), ", border-color ").concat(dt2("slider.transition.duration"), ", box-shadow ").concat(dt2("slider.transition.duration"), ", outline-color ").concat(dt2("slider.transition.duration"), ';\n    outline-color: transparent;\n}\n\n.p-slider-handle::before {\n    content: "";\n    width: ').concat(dt2("slider.handle.content.width"), ";\n    height: ").concat(dt2("slider.handle.content.height"), ";\n    display: block;\n    background: ").concat(dt2("slider.handle.content.background"), ";\n    border-radius: ").concat(dt2("slider.handle.content.border.radius"), ";\n    box-shadow: ").concat(dt2("slider.handle.content.shadow"), ";\n    transition: background ").concat(dt2("slider.transition.duration"), ";\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover {\n    background: ").concat(dt2("slider.handle.hover.background"), ";\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover::before {\n    background: ").concat(dt2("slider.handle.content.hover.background"), ";\n}\n\n.p-slider-handle:focus-visible {\n    border-color: ").concat(dt2("slider.handle.focus.border.color"), ";\n    box-shadow: ").concat(dt2("slider.handle.focus.ring.shadow"), ";\n    outline: ").concat(dt2("slider.handle.focus.ring.width"), " ").concat(dt2("slider.handle.focus.ring.style"), " ").concat(dt2("slider.handle.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("slider.handle.focus.ring.offset"), ";\n}\n\n.p-slider-range {\n    display: block;\n    background: ").concat(dt2("slider.range.background"), ";\n    border-radius: ").concat(dt2("slider.border.radius"), ";\n}\n\n.p-slider.p-slider-horizontal {\n    height: ").concat(dt2("slider.track.size"), ";\n}\n\n.p-slider-horizontal .p-slider-range {\n    top: 0;\n    left: 0;\n    height: 100%;\n}\n\n.p-slider-horizontal .p-slider-handle {\n    top: 50%;\n    margin-top: calc(-1 * calc(").concat(dt2("slider.handle.height"), " / 2));\n    margin-left: calc(-1 * calc(").concat(dt2("slider.handle.width"), " / 2));\n}\n\n.p-slider-vertical {\n    min-height: 100px;\n    width: ").concat(dt2("slider.track.size"), ";\n}\n\n.p-slider-vertical .p-slider-handle {\n    left: 50%;\n    margin-left: calc(-1 * calc(").concat(dt2("slider.handle.width"), " / 2));\n    margin-bottom: calc(-1 * calc(").concat(dt2("slider.handle.height"), " / 2));\n}\n\n.p-slider-vertical .p-slider-range {\n    bottom: 0;\n    left: 0;\n    width: 100%;\n}\n");
}, "theme");
var inlineStyles$1 = {
  handle: {
    position: "absolute"
  },
  range: {
    position: "absolute"
  }
};
var classes$i = {
  root: /* @__PURE__ */ __name(function root14(_ref2) {
    var props = _ref2.props;
    return ["p-slider p-component", {
      "p-disabled": props.disabled,
      "p-slider-horizontal": props.orientation === "horizontal",
      "p-slider-vertical": props.orientation === "vertical"
    }];
  }, "root"),
  range: "p-slider-range",
  handle: "p-slider-handle"
};
var SliderStyle = BaseStyle.extend({
  name: "slider",
  theme: theme$i,
  classes: classes$i,
  inlineStyles: inlineStyles$1
});
var script$1$h = {
  name: "BaseSlider",
  "extends": script$Y,
  props: {
    modelValue: [Number, Array],
    min: {
      type: Number,
      "default": 0
    },
    max: {
      type: Number,
      "default": 100
    },
    orientation: {
      type: String,
      "default": "horizontal"
    },
    step: {
      type: Number,
      "default": null
    },
    range: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: SliderStyle,
  provide: /* @__PURE__ */ __name(function provide21() {
    return {
      $pcSlider: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$6(r) {
  return _arrayWithoutHoles$6(r) || _iterableToArray$6(r) || _unsupportedIterableToArray$9(r) || _nonIterableSpread$6();
}
__name(_toConsumableArray$6, "_toConsumableArray$6");
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$6, "_nonIterableSpread$6");
function _unsupportedIterableToArray$9(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$9(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$9(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$9, "_unsupportedIterableToArray$9");
function _iterableToArray$6(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$6, "_iterableToArray$6");
function _arrayWithoutHoles$6(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$9(r);
}
__name(_arrayWithoutHoles$6, "_arrayWithoutHoles$6");
function _arrayLikeToArray$9(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$9, "_arrayLikeToArray$9");
var script$v = {
  name: "Slider",
  "extends": script$1$h,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "slideend"],
  dragging: false,
  handleIndex: null,
  initX: null,
  initY: null,
  barWidth: null,
  barHeight: null,
  dragListener: null,
  dragEndListener: null,
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount4() {
    this.unbindDragListeners();
  }, "beforeUnmount"),
  methods: {
    updateDomData: /* @__PURE__ */ __name(function updateDomData() {
      var rect = this.$el.getBoundingClientRect();
      this.initX = rect.left + getWindowScrollLeft();
      this.initY = rect.top + getWindowScrollTop();
      this.barWidth = this.$el.offsetWidth;
      this.barHeight = this.$el.offsetHeight;
    }, "updateDomData"),
    setValue: /* @__PURE__ */ __name(function setValue(event2) {
      var handleValue;
      var pageX = event2.touches ? event2.touches[0].pageX : event2.pageX;
      var pageY = event2.touches ? event2.touches[0].pageY : event2.pageY;
      if (this.orientation === "horizontal") handleValue = (pageX - this.initX) * 100 / this.barWidth;
      else handleValue = (this.initY + this.barHeight - pageY) * 100 / this.barHeight;
      var newValue = (this.max - this.min) * (handleValue / 100) + this.min;
      if (this.step) {
        var oldValue = this.range ? this.value[this.handleIndex] : this.value;
        var diff2 = newValue - oldValue;
        if (diff2 < 0) newValue = oldValue + Math.ceil(newValue / this.step - oldValue / this.step) * this.step;
        else if (diff2 > 0) newValue = oldValue + Math.floor(newValue / this.step - oldValue / this.step) * this.step;
      } else {
        newValue = Math.floor(newValue);
      }
      this.updateModel(event2, newValue);
    }, "setValue"),
    updateModel: /* @__PURE__ */ __name(function updateModel4(event2, value3) {
      var newValue = parseFloat(value3.toFixed(10));
      var modelValue3;
      if (this.range) {
        modelValue3 = this.value ? _toConsumableArray$6(this.value) : [];
        if (this.handleIndex == 0) {
          if (newValue < this.min) newValue = this.min;
          else if (newValue >= this.max) newValue = this.max;
          modelValue3[0] = newValue;
        } else {
          if (newValue > this.max) newValue = this.max;
          else if (newValue <= this.min) newValue = this.min;
          modelValue3[1] = newValue;
        }
      } else {
        if (newValue < this.min) newValue = this.min;
        else if (newValue > this.max) newValue = this.max;
        modelValue3 = newValue;
      }
      this.$emit("update:modelValue", modelValue3);
      this.$emit("change", modelValue3);
    }, "updateModel"),
    onDragStart: /* @__PURE__ */ __name(function onDragStart(event2, index2) {
      if (this.disabled) {
        return;
      }
      this.$el.setAttribute("data-p-sliding", true);
      this.dragging = true;
      this.updateDomData();
      if (this.range && this.value[0] === this.max) {
        this.handleIndex = 0;
      } else {
        this.handleIndex = index2;
      }
      event2.currentTarget.focus();
      event2.preventDefault();
    }, "onDragStart"),
    onDrag: /* @__PURE__ */ __name(function onDrag(event2) {
      if (this.dragging) {
        this.setValue(event2);
        event2.preventDefault();
      }
    }, "onDrag"),
    onDragEnd: /* @__PURE__ */ __name(function onDragEnd(event2) {
      if (this.dragging) {
        this.dragging = false;
        this.$el.setAttribute("data-p-sliding", false);
        this.$emit("slideend", {
          originalEvent: event2,
          value: this.value
        });
      }
    }, "onDragEnd"),
    onBarClick: /* @__PURE__ */ __name(function onBarClick(event2) {
      if (this.disabled) {
        return;
      }
      if (getAttribute(event2.target, "data-pc-section") !== "handle") {
        this.updateDomData();
        this.setValue(event2);
      }
    }, "onBarClick"),
    onMouseDown: /* @__PURE__ */ __name(function onMouseDown2(event2, index2) {
      this.bindDragListeners();
      this.onDragStart(event2, index2);
    }, "onMouseDown"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown4(event2, index2) {
      this.handleIndex = index2;
      switch (event2.code) {
        case "ArrowDown":
        case "ArrowLeft":
          this.decrementValue(event2, index2);
          event2.preventDefault();
          break;
        case "ArrowUp":
        case "ArrowRight":
          this.incrementValue(event2, index2);
          event2.preventDefault();
          break;
        case "PageDown":
          this.decrementValue(event2, index2, true);
          event2.preventDefault();
          break;
        case "PageUp":
          this.incrementValue(event2, index2, true);
          event2.preventDefault();
          break;
        case "Home":
          this.updateModel(event2, this.min);
          event2.preventDefault();
          break;
        case "End":
          this.updateModel(event2, this.max);
          event2.preventDefault();
          break;
      }
    }, "onKeyDown"),
    decrementValue: /* @__PURE__ */ __name(function decrementValue(event2, index2) {
      var pageKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var newValue;
      if (this.range) {
        if (this.step) newValue = this.value[index2] - this.step;
        else newValue = this.value[index2] - 1;
      } else {
        if (this.step) newValue = this.value - this.step;
        else if (!this.step && pageKey) newValue = this.value - 10;
        else newValue = this.value - 1;
      }
      this.updateModel(event2, newValue);
      event2.preventDefault();
    }, "decrementValue"),
    incrementValue: /* @__PURE__ */ __name(function incrementValue(event2, index2) {
      var pageKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var newValue;
      if (this.range) {
        if (this.step) newValue = this.value[index2] + this.step;
        else newValue = this.value[index2] + 1;
      } else {
        if (this.step) newValue = this.value + this.step;
        else if (!this.step && pageKey) newValue = this.value + 10;
        else newValue = this.value + 1;
      }
      this.updateModel(event2, newValue);
      event2.preventDefault();
    }, "incrementValue"),
    bindDragListeners: /* @__PURE__ */ __name(function bindDragListeners() {
      if (!this.dragListener) {
        this.dragListener = this.onDrag.bind(this);
        document.addEventListener("mousemove", this.dragListener);
      }
      if (!this.dragEndListener) {
        this.dragEndListener = this.onDragEnd.bind(this);
        document.addEventListener("mouseup", this.dragEndListener);
      }
    }, "bindDragListeners"),
    unbindDragListeners: /* @__PURE__ */ __name(function unbindDragListeners() {
      if (this.dragListener) {
        document.removeEventListener("mousemove", this.dragListener);
        this.dragListener = null;
      }
      if (this.dragEndListener) {
        document.removeEventListener("mouseup", this.dragEndListener);
        this.dragEndListener = null;
      }
    }, "unbindDragListeners")
  },
  computed: {
    value: /* @__PURE__ */ __name(function value2() {
      var _this$modelValue3;
      if (this.range) {
        var _this$modelValue$, _this$modelValue, _this$modelValue$2, _this$modelValue2;
        return [(_this$modelValue$ = (_this$modelValue = this.modelValue) === null || _this$modelValue === void 0 ? void 0 : _this$modelValue[0]) !== null && _this$modelValue$ !== void 0 ? _this$modelValue$ : this.min, (_this$modelValue$2 = (_this$modelValue2 = this.modelValue) === null || _this$modelValue2 === void 0 ? void 0 : _this$modelValue2[1]) !== null && _this$modelValue$2 !== void 0 ? _this$modelValue$2 : this.max];
      }
      return (_this$modelValue3 = this.modelValue) !== null && _this$modelValue3 !== void 0 ? _this$modelValue3 : this.min;
    }, "value"),
    horizontal: /* @__PURE__ */ __name(function horizontal() {
      return this.orientation === "horizontal";
    }, "horizontal"),
    vertical: /* @__PURE__ */ __name(function vertical() {
      return this.orientation === "vertical";
    }, "vertical"),
    rangeStyle: /* @__PURE__ */ __name(function rangeStyle() {
      if (this.range) {
        var rangeSliderWidth = this.rangeEndPosition > this.rangeStartPosition ? this.rangeEndPosition - this.rangeStartPosition : this.rangeStartPosition - this.rangeEndPosition;
        var rangeSliderPosition = this.rangeEndPosition > this.rangeStartPosition ? this.rangeStartPosition : this.rangeEndPosition;
        if (this.horizontal) return {
          left: rangeSliderPosition + "%",
          width: rangeSliderWidth + "%"
        };
        else return {
          bottom: rangeSliderPosition + "%",
          height: rangeSliderWidth + "%"
        };
      } else {
        if (this.horizontal) return {
          width: this.handlePosition + "%"
        };
        else return {
          height: this.handlePosition + "%"
        };
      }
    }, "rangeStyle"),
    handleStyle: /* @__PURE__ */ __name(function handleStyle() {
      if (this.horizontal) return {
        left: this.handlePosition + "%"
      };
      else return {
        bottom: this.handlePosition + "%"
      };
    }, "handleStyle"),
    handlePosition: /* @__PURE__ */ __name(function handlePosition() {
      if (this.value < this.min) return 0;
      else if (this.value > this.max) return 100;
      else return (this.value - this.min) * 100 / (this.max - this.min);
    }, "handlePosition"),
    rangeStartPosition: /* @__PURE__ */ __name(function rangeStartPosition() {
      if (this.value && this.value[0]) return (this.value[0] < this.min ? 0 : this.value[0] - this.min) * 100 / (this.max - this.min);
      else return 0;
    }, "rangeStartPosition"),
    rangeEndPosition: /* @__PURE__ */ __name(function rangeEndPosition() {
      if (this.value && this.value.length === 2) return (this.value[1] > this.max ? 100 : this.value[1] - this.min) * 100 / (this.max - this.min);
      else return 100;
    }, "rangeEndPosition"),
    rangeStartHandleStyle: /* @__PURE__ */ __name(function rangeStartHandleStyle() {
      if (this.horizontal) return {
        left: this.rangeStartPosition + "%"
      };
      else return {
        bottom: this.rangeStartPosition + "%"
      };
    }, "rangeStartHandleStyle"),
    rangeEndHandleStyle: /* @__PURE__ */ __name(function rangeEndHandleStyle() {
      if (this.horizontal) return {
        left: this.rangeEndPosition + "%"
      };
      else return {
        bottom: this.rangeEndPosition + "%"
      };
    }, "rangeEndHandleStyle")
  }
};
var _hoisted_1$W = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
var _hoisted_2$G = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
var _hoisted_3$m = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    onClick: _cache[15] || (_cache[15] = function() {
      return $options.onBarClick && $options.onBarClick.apply($options, arguments);
    })
  }, _ctx.ptmi("root"), {
    "data-p-sliding": false
  }), [createBaseVNode("span", mergeProps({
    "class": _ctx.cx("range"),
    style: [_ctx.sx("range"), $options.rangeStyle]
  }, _ctx.ptm("range")), null, 16), !_ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 0,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.handleStyle],
    onTouchstartPassive: _cache[0] || (_cache[0] = function($event) {
      return $options.onDragStart($event);
    }),
    onTouchmovePassive: _cache[1] || (_cache[1] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[2] || (_cache[2] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[3] || (_cache[3] = function($event) {
      return $options.onMouseDown($event);
    }),
    onKeydown: _cache[4] || (_cache[4] = function($event) {
      return $options.onKeyDown($event);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("handle")), null, 16, _hoisted_1$W)) : createCommentVNode("", true), _ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.rangeStartHandleStyle],
    onTouchstartPassive: _cache[5] || (_cache[5] = function($event) {
      return $options.onDragStart($event, 0);
    }),
    onTouchmovePassive: _cache[6] || (_cache[6] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[7] || (_cache[7] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[8] || (_cache[8] = function($event) {
      return $options.onMouseDown($event, 0);
    }),
    onKeydown: _cache[9] || (_cache[9] = function($event) {
      return $options.onKeyDown($event, 0);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue ? _ctx.modelValue[0] : null,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("startHandler")), null, 16, _hoisted_2$G)) : createCommentVNode("", true), _ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.rangeEndHandleStyle],
    onTouchstartPassive: _cache[10] || (_cache[10] = function($event) {
      return $options.onDragStart($event, 1);
    }),
    onTouchmovePassive: _cache[11] || (_cache[11] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[12] || (_cache[12] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[13] || (_cache[13] = function($event) {
      return $options.onMouseDown($event, 1);
    }),
    onKeydown: _cache[14] || (_cache[14] = function($event) {
      return $options.onKeyDown($event, 1);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue ? _ctx.modelValue[1] : null,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("endHandler")), null, 16, _hoisted_3$m)) : createCommentVNode("", true)], 16);
}
__name(render$u, "render$u");
script$v.render = render$u;
const _hoisted_1$V = { class: "input-slider flex flex-row items-center gap-2" };
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "InputSlider",
  props: {
    modelValue: {},
    inputClass: {},
    sliderClass: {},
    min: {},
    max: {},
    step: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const localValue = ref(props.modelValue);
    watch(
      () => props.modelValue,
      (newValue) => {
        localValue.value = newValue;
      }
    );
    const updateValue3 = /* @__PURE__ */ __name((newValue) => {
      if (newValue === null) {
        newValue = Number(props.min) || 0;
      }
      const min = Number(props.min ?? Number.NEGATIVE_INFINITY);
      const max = Number(props.max ?? Number.POSITIVE_INFINITY);
      const step2 = Number(props.step) || 1;
      newValue = Math.max(min, Math.min(max, newValue));
      newValue = Math.round(newValue / step2) * step2;
      localValue.value = newValue;
      emit2("update:modelValue", newValue);
    }, "updateValue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$V, [
        createVNode(unref(script$v), {
          modelValue: _ctx.modelValue,
          "onUpdate:modelValue": updateValue3,
          class: normalizeClass(["slider-part", _ctx.sliderClass]),
          min: _ctx.min,
          max: _ctx.max,
          step: _ctx.step
        }, null, 8, ["modelValue", "class", "min", "max", "step"]),
        createVNode(unref(script$C), {
          modelValue: _ctx.modelValue,
          "onUpdate:modelValue": updateValue3,
          class: normalizeClass(["input-part", _ctx.inputClass]),
          min: _ctx.min,
          max: _ctx.max,
          step: _ctx.step,
          allowEmpty: false
        }, null, 8, ["modelValue", "class", "min", "max", "step"])
      ]);
    };
  }
});
const _withScopeId$j = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-db59abe0"), n = n(), popScopeId(), n), "_withScopeId$j");
const _hoisted_1$U = { class: "setting-group" };
const _hoisted_2$F = { class: "setting-label flex flex-grow items-center" };
const _hoisted_3$l = { class: "text-[var(--p-text-muted-color)]" };
const _hoisted_4$f = {
  key: 2,
  class: "pi pi-info-circle bg-transparent"
};
const _hoisted_5$a = { class: "setting-input flex justify-end" };
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "SettingGroup",
  props: {
    group: {},
    divider: { type: Boolean }
  },
  setup(__props) {
    const settingStore = useSettingStore();
    function getSettingAttrs(setting) {
      const attrs3 = { ...setting.attrs || {} };
      const settingType = setting.type;
      if (typeof settingType === "function") {
        attrs3["renderFunction"] = () => settingType(
          setting.name,
          (v2) => updateSetting(setting, v2),
          settingStore.get(setting.id),
          setting.attrs
        );
      }
      switch (setting.type) {
        case "combo":
          attrs3["options"] = typeof setting.options === "function" ? setting.options(settingStore.get(setting.id)) : setting.options;
          if (typeof setting.options[0] !== "string") {
            attrs3["optionLabel"] = "text";
            attrs3["optionValue"] = "value";
          }
          break;
      }
      return attrs3;
    }
    __name(getSettingAttrs, "getSettingAttrs");
    const updateSetting = /* @__PURE__ */ __name((setting, value3) => {
      settingStore.set(setting.id, value3);
    }, "updateSetting");
    function getSettingComponent(setting) {
      if (typeof setting.type === "function") {
        return _sfc_main$H;
      }
      switch (setting.type) {
        case "boolean":
          return script$x;
        case "number":
          return script$C;
        case "slider":
          return _sfc_main$G;
        case "combo":
          return script$y;
        default:
          return script$R;
      }
    }
    __name(getSettingComponent, "getSettingComponent");
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$U, [
        _ctx.divider ? (openBlock(), createBlock(unref(script$G), { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("h3", null, toDisplayString$1(unref(formatCamelCase)(_ctx.group.label)), 1),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.group.settings, (setting) => {
          return openBlock(), createElementBlock("div", {
            key: setting.id,
            class: "setting-item flex items-center mb-4"
          }, [
            createBaseVNode("div", _hoisted_2$F, [
              createBaseVNode("span", _hoisted_3$l, [
                setting.experimental ? (openBlock(), createBlock(unref(script$w), {
                  key: 0,
                  value: _ctx.$t("experimental")
                }, null, 8, ["value"])) : createCommentVNode("", true),
                setting.deprecated ? (openBlock(), createBlock(unref(script$w), {
                  key: 1,
                  value: _ctx.$t("deprecated"),
                  severity: "danger"
                }, null, 8, ["value"])) : createCommentVNode("", true),
                createTextVNode(" " + toDisplayString$1(setting.name) + " ", 1),
                setting.tooltip ? withDirectives((openBlock(), createElementBlock("i", _hoisted_4$f, null, 512)), [
                  [_directive_tooltip, setting.tooltip]
                ]) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_5$a, [
              (openBlock(), createBlock(resolveDynamicComponent(markRaw(getSettingComponent(setting))), mergeProps({
                id: setting.id,
                modelValue: unref(settingStore).get(setting.id),
                "onUpdate:modelValue": /* @__PURE__ */ __name(($event) => updateSetting(setting, $event), "onUpdate:modelValue"),
                ref_for: true
              }, getSettingAttrs(setting)), null, 16, ["id", "modelValue", "onUpdate:modelValue"]))
            ])
          ]);
        }), 128))
      ]);
    };
  }
});
const SettingGroup = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__scopeId", "data-v-db59abe0"]]);
var script$u = {
  name: "TimesCircleIcon",
  "extends": script$X
};
var _hoisted_1$T = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7 14C5.61553 14 4.26215 13.5895 3.11101 12.8203C1.95987 12.0511 1.06266 10.9579 0.532846 9.67879C0.00303296 8.3997 -0.13559 6.99224 0.134506 5.63437C0.404603 4.2765 1.07129 3.02922 2.05026 2.05026C3.02922 1.07129 4.2765 0.404603 5.63437 0.134506C6.99224 -0.13559 8.3997 0.00303296 9.67879 0.532846C10.9579 1.06266 12.0511 1.95987 12.8203 3.11101C13.5895 4.26215 14 5.61553 14 7C14 8.85652 13.2625 10.637 11.9497 11.9497C10.637 13.2625 8.85652 14 7 14ZM7 1.16667C5.84628 1.16667 4.71846 1.50879 3.75918 2.14976C2.79989 2.79074 2.05222 3.70178 1.61071 4.76768C1.16919 5.83358 1.05367 7.00647 1.27876 8.13803C1.50384 9.26958 2.05941 10.309 2.87521 11.1248C3.69102 11.9406 4.73042 12.4962 5.86198 12.7212C6.99353 12.9463 8.16642 12.8308 9.23232 12.3893C10.2982 11.9478 11.2093 11.2001 11.8502 10.2408C12.4912 9.28154 12.8333 8.15373 12.8333 7C12.8333 5.45291 12.2188 3.96918 11.1248 2.87521C10.0308 1.78125 8.5471 1.16667 7 1.16667ZM4.66662 9.91668C4.58998 9.91704 4.51404 9.90209 4.44325 9.87271C4.37246 9.84333 4.30826 9.8001 4.2544 9.74557C4.14516 9.6362 4.0838 9.48793 4.0838 9.33335C4.0838 9.17876 4.14516 9.0305 4.2544 8.92113L6.17553 7L4.25443 5.07891C4.15139 4.96832 4.09529 4.82207 4.09796 4.67094C4.10063 4.51982 4.16185 4.37563 4.26872 4.26876C4.3756 4.16188 4.51979 4.10066 4.67091 4.09799C4.82204 4.09532 4.96829 4.15142 5.07887 4.25446L6.99997 6.17556L8.92106 4.25446C9.03164 4.15142 9.1779 4.09532 9.32903 4.09799C9.48015 4.10066 9.62434 4.16188 9.73121 4.26876C9.83809 4.37563 9.89931 4.51982 9.90198 4.67094C9.90464 4.82207 9.84855 4.96832 9.74551 5.07891L7.82441 7L9.74554 8.92113C9.85478 9.0305 9.91614 9.17876 9.91614 9.33335C9.91614 9.48793 9.85478 9.6362 9.74554 9.74557C9.69168 9.8001 9.62748 9.84333 9.55669 9.87271C9.4859 9.90209 9.40996 9.91704 9.33332 9.91668C9.25668 9.91704 9.18073 9.90209 9.10995 9.87271C9.03916 9.84333 8.97495 9.8001 8.9211 9.74557L6.99997 7.82444L5.07884 9.74557C5.02499 9.8001 4.96078 9.84333 4.88999 9.87271C4.81921 9.90209 4.74326 9.91704 4.66662 9.91668Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$E = [_hoisted_1$T];
function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$E, 16);
}
__name(render$t, "render$t");
script$u.render = render$t;
var theme$h = /* @__PURE__ */ __name(function theme20(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-chip {\n    display: inline-flex;\n    align-items: center;\n    background: ".concat(dt2("chip.background"), ";\n    color: ").concat(dt2("chip.color"), ";\n    border-radius: ").concat(dt2("chip.border.radius"), ";\n    padding: ").concat(dt2("chip.padding.y"), " ").concat(dt2("chip.padding.x"), ";\n    gap: ").concat(dt2("chip.gap"), ";\n}\n\n.p-chip-icon {\n    color: ").concat(dt2("chip.icon.color"), ";\n    font-size: ").concat(dt2("chip.icon.font.size"), ";\n    width: ").concat(dt2("chip.icon.size"), ";\n    height: ").concat(dt2("chip.icon.size"), ";\n}\n\n.p-chip-image {\n    border-radius: 50%;\n    width: ").concat(dt2("chip.image.width"), ";\n    height: ").concat(dt2("chip.image.height"), ";\n    margin-left: calc(-1 * ").concat(dt2("chip.padding.y"), ");\n}\n\n.p-chip:has(.p-chip-remove-icon) {\n    padding-right: ").concat(dt2("chip.padding.y"), ";\n}\n\n.p-chip:has(.p-chip-image) {\n    padding-top: calc(").concat(dt2("chip.padding.y"), " / 2);\n    padding-bottom: calc(").concat(dt2("chip.padding.y"), " / 2);\n}\n\n.p-chip-remove-icon {\n    cursor: pointer;\n    font-size: ").concat(dt2("chip.remove.icon.size"), ";\n    width: ").concat(dt2("chip.remove.icon.size"), ";\n    height: ").concat(dt2("chip.remove.icon.size"), ";\n    color: ").concat(dt2("chip.remove.icon.color"), ";\n    border-radius: 50%;\n    transition: outline-color ").concat(dt2("chip.transition.duration"), ", box-shadow ").concat(dt2("chip.transition.duration"), ";\n    outline-color: transparent;\n}\n\n.p-chip-remove-icon:focus-visible {\n    box-shadow: ").concat(dt2("chip.remove.icon.focus.ring.shadow"), ";\n    outline: ").concat(dt2("chip.remove.icon.focus.ring.width"), " ").concat(dt2("chip.remove.icon.focus.ring.style"), " ").concat(dt2("chip.remove.icon.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("chip.remove.icon.focus.ring.offset"), ";\n}\n");
}, "theme");
var classes$h = {
  root: "p-chip p-component",
  image: "p-chip-image",
  icon: "p-chip-icon",
  label: "p-chip-label",
  removeIcon: "p-chip-remove-icon"
};
var ChipStyle = BaseStyle.extend({
  name: "chip",
  theme: theme$h,
  classes: classes$h
});
var script$1$g = {
  name: "BaseChip",
  "extends": script$Y,
  props: {
    label: {
      type: String,
      "default": null
    },
    icon: {
      type: String,
      "default": null
    },
    image: {
      type: String,
      "default": null
    },
    removable: {
      type: Boolean,
      "default": false
    },
    removeIcon: {
      type: String,
      "default": void 0
    }
  },
  style: ChipStyle,
  provide: /* @__PURE__ */ __name(function provide22() {
    return {
      $pcChip: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$t = {
  name: "Chip",
  "extends": script$1$g,
  inheritAttrs: false,
  emits: ["remove"],
  data: /* @__PURE__ */ __name(function data8() {
    return {
      visible: true
    };
  }, "data"),
  methods: {
    onKeydown: /* @__PURE__ */ __name(function onKeydown(event2) {
      if (event2.key === "Enter" || event2.key === "Backspace") {
        this.close(event2);
      }
    }, "onKeydown"),
    close: /* @__PURE__ */ __name(function close(event2) {
      this.visible = false;
      this.$emit("remove", event2);
    }, "close")
  },
  components: {
    TimesCircleIcon: script$u
  }
};
var _hoisted_1$S = ["aria-label"];
var _hoisted_2$D = ["src"];
function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return $data.visible ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("root"),
    "aria-label": _ctx.label
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [_ctx.image ? (openBlock(), createElementBlock("img", mergeProps({
      key: 0,
      src: _ctx.image
    }, _ctx.ptm("image"), {
      "class": _ctx.cx("image")
    }), null, 16, _hoisted_2$D)) : _ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), mergeProps({
      key: 1,
      "class": _ctx.cx("icon")
    }, _ctx.ptm("icon")), null, 16, ["class"])) : _ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
      key: 2,
      "class": [_ctx.cx("icon"), _ctx.icon]
    }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true), _ctx.label ? (openBlock(), createElementBlock("div", mergeProps({
      key: 3,
      "class": _ctx.cx("label")
    }, _ctx.ptm("label")), toDisplayString$1(_ctx.label), 17)) : createCommentVNode("", true)];
  }), _ctx.removable ? renderSlot(_ctx.$slots, "removeicon", {
    key: 0,
    removeCallback: $options.close,
    keydownCallback: $options.onKeydown
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.removeIcon ? "span" : "TimesCircleIcon"), mergeProps({
      tabindex: "0",
      "class": [_ctx.cx("removeIcon"), _ctx.removeIcon],
      onClick: $options.close,
      onKeydown: $options.onKeydown
    }, _ctx.ptm("removeIcon")), null, 16, ["class", "onClick", "onKeydown"]))];
  }) : createCommentVNode("", true)], 16, _hoisted_1$S)) : createCommentVNode("", true);
}
__name(render$s, "render$s");
script$t.render = render$s;
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "SearchFilterChip",
  props: {
    text: {},
    badge: {},
    badgeClass: {}
  },
  emits: ["remove"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$t), {
        removable: "",
        onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove", $event))
      }, {
        default: withCtx(() => [
          createVNode(unref(script$N), {
            size: "small",
            class: normalizeClass(_ctx.badgeClass)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(_ctx.badge), 1)
            ]),
            _: 1
          }, 8, ["class"]),
          createTextVNode(" " + toDisplayString$1(_ctx.text), 1)
        ]),
        _: 1
      });
    };
  }
});
const SearchFilterChip = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__scopeId", "data-v-a4c03005"]]);
const _withScopeId$i = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-f28148d1"), n = n(), popScopeId(), n), "_withScopeId$i");
const _hoisted_1$R = {
  key: 0,
  class: "search-filters pt-2 flex flex-wrap gap-2"
};
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "SearchBox",
  props: {
    class: {},
    modelValue: {},
    placeholder: { default: "Search..." },
    icon: { default: "pi pi-search" },
    debounceTime: { default: 300 },
    filterIcon: {},
    filters: {}
  },
  emits: [
    "update:modelValue",
    "search",
    "showFilter",
    "removeFilter"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { filters } = toRefs$1(props);
    const emit2 = __emit;
    const emitSearch = lodashExports.debounce((value3) => {
      emit2("search", value3, props.filters);
    }, props.debounceTime);
    const handleInput = /* @__PURE__ */ __name((event2) => {
      const target = event2.target;
      emit2("update:modelValue", target.value);
      emitSearch(target.value);
    }, "handleInput");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(props.class)
      }, [
        createVNode(unref(script$T), null, {
          default: withCtx(() => [
            createVNode(unref(script$S), {
              class: normalizeClass(props.icon)
            }, null, 8, ["class"]),
            createVNode(unref(script$R), {
              class: normalizeClass(["search-box-input", { ["with-filter"]: props.filterIcon }]),
              onInput: handleInput,
              modelValue: props.modelValue,
              placeholder: props.placeholder
            }, null, 8, ["class", "modelValue", "placeholder"]),
            props.filterIcon ? (openBlock(), createBlock(unref(script$M), {
              key: 0,
              class: "p-inputicon",
              icon: props.filterIcon,
              text: "",
              severity: "contrast",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("showFilter", $event))
            }, null, 8, ["icon"])) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        unref(filters)?.length ? (openBlock(), createElementBlock("div", _hoisted_1$R, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(filters), (filter4) => {
            return openBlock(), createBlock(SearchFilterChip, {
              key: filter4.id,
              text: filter4.text,
              badge: filter4.badge,
              "badge-class": filter4.badgeClass,
              onRemove: /* @__PURE__ */ __name(($event) => _ctx.$emit("removeFilter", filter4), "onRemove")
            }, null, 8, ["text", "badge", "badge-class", "onRemove"]);
          }), 128))
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});
const SearchBox = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-f28148d1"]]);
const useSystemStatsStore = /* @__PURE__ */ defineStore("systemStats", () => {
  const systemStats = ref(null);
  const isLoading = ref(false);
  const error = ref(null);
  async function fetchSystemStats() {
    isLoading.value = true;
    error.value = null;
    try {
      systemStats.value = await api.getSystemStats();
    } catch (err) {
      error.value = err instanceof Error ? err.message : "An error occurred while fetching system stats";
      console.error("Error fetching system stats:", err);
    } finally {
      isLoading.value = false;
    }
  }
  __name(fetchSystemStats, "fetchSystemStats");
  return {
    systemStats,
    isLoading,
    error,
    fetchSystemStats
  };
});
const CORE_KEYBINDINGS = [
  {
    combo: {
      ctrl: true,
      key: "Enter"
    },
    commandId: "Comfy.QueuePrompt"
  },
  {
    combo: {
      ctrl: true,
      shift: true,
      key: "Enter"
    },
    commandId: "Comfy.QueuePromptFront"
  },
  {
    combo: {
      ctrl: true,
      alt: true,
      key: "Enter"
    },
    commandId: "Comfy.Interrupt"
  },
  {
    combo: {
      key: "r"
    },
    commandId: "Comfy.RefreshNodeDefinitions"
  },
  {
    combo: {
      key: "q"
    },
    commandId: "Workspace.ToggleSidebarTab.queue"
  },
  {
    combo: {
      key: "w"
    },
    commandId: "Workspace.ToggleSidebarTab.workflows"
  },
  {
    combo: {
      key: "n"
    },
    commandId: "Workspace.ToggleSidebarTab.node-library"
  },
  {
    combo: {
      key: "m"
    },
    commandId: "Workspace.ToggleSidebarTab.model-library"
  },
  {
    combo: {
      key: "s",
      ctrl: true
    },
    commandId: "Comfy.ExportWorkflow"
  },
  {
    combo: {
      key: "o",
      ctrl: true
    },
    commandId: "Comfy.OpenWorkflow"
  },
  {
    combo: {
      key: "Backspace"
    },
    commandId: "Comfy.ClearWorkflow"
  },
  {
    combo: {
      key: "d",
      ctrl: true
    },
    commandId: "Comfy.LoadDefaultWorkflow"
  },
  {
    combo: {
      key: "g",
      ctrl: true
    },
    commandId: "Comfy.Graph.GroupSelectedNodes"
  },
  {
    combo: {
      key: ",",
      ctrl: true
    },
    commandId: "Comfy.ShowSettingsDialog"
  },
  // For '=' both holding shift and not holding shift
  {
    combo: {
      key: "=",
      alt: true
    },
    commandId: "Comfy.Canvas.ZoomIn",
    targetSelector: "#graph-canvas"
  },
  {
    combo: {
      key: "+",
      alt: true,
      shift: true
    },
    commandId: "Comfy.Canvas.ZoomIn",
    targetSelector: "#graph-canvas"
  },
  // For number pad '+'
  {
    combo: {
      key: "+",
      alt: true
    },
    commandId: "Comfy.Canvas.ZoomIn",
    targetSelector: "#graph-canvas"
  },
  {
    combo: {
      key: "-",
      alt: true
    },
    commandId: "Comfy.Canvas.ZoomOut",
    targetSelector: "#graph-canvas"
  },
  {
    combo: {
      key: "."
    },
    commandId: "Comfy.Canvas.FitView",
    targetSelector: "#graph-canvas"
  },
  {
    combo: {
      key: "p"
    },
    commandId: "Comfy.Canvas.ToggleSelected.Pin",
    targetSelector: "#graph-canvas"
  },
  {
    combo: {
      key: "c",
      alt: true
    },
    commandId: "Comfy.Canvas.ToggleSelectedNodes.Collapse",
    targetSelector: "#graph-canvas"
  },
  {
    combo: {
      key: "b",
      ctrl: true
    },
    commandId: "Comfy.Canvas.ToggleSelectedNodes.Bypass",
    targetSelector: "#graph-canvas"
  },
  {
    combo: {
      key: "m",
      ctrl: true
    },
    commandId: "Comfy.Canvas.ToggleSelectedNodes.Mute",
    targetSelector: "#graph-canvas"
  },
  {
    combo: {
      key: "`",
      ctrl: true
    },
    commandId: "Workspace.ToggleBottomPanelTab.integrated-terminal"
  },
  {
    combo: {
      key: "f"
    },
    commandId: "Workspace.ToggleFocusMode"
  }
];
class KeybindingImpl {
  static {
    __name(this, "KeybindingImpl");
  }
  commandId;
  combo;
  targetSelector;
  constructor(obj) {
    this.commandId = obj.commandId;
    this.combo = new KeyComboImpl(obj.combo);
    this.targetSelector = obj.targetSelector;
  }
  equals(other) {
    if (toRaw(other) instanceof KeybindingImpl) {
      return this.commandId === other.commandId && this.combo.equals(other.combo) && this.targetSelector === other.targetSelector;
    }
    return false;
  }
}
class KeyComboImpl {
  static {
    __name(this, "KeyComboImpl");
  }
  key;
  // ctrl or meta(cmd on mac)
  ctrl;
  alt;
  shift;
  constructor(obj) {
    this.key = obj.key;
    this.ctrl = obj.ctrl ?? false;
    this.alt = obj.alt ?? false;
    this.shift = obj.shift ?? false;
  }
  static fromEvent(event2) {
    return new KeyComboImpl({
      key: event2.key,
      ctrl: event2.ctrlKey || event2.metaKey,
      alt: event2.altKey,
      shift: event2.shiftKey
    });
  }
  equals(other) {
    if (toRaw(other) instanceof KeyComboImpl) {
      return this.key === other.key && this.ctrl === other.ctrl && this.alt === other.alt && this.shift === other.shift;
    }
    return false;
  }
  serialize() {
    return `${this.key}:${this.ctrl}:${this.alt}:${this.shift}`;
  }
  deserialize(serialized) {
    const [key, ctrl, alt, shift] = serialized.split(":");
    return new KeyComboImpl({
      key,
      ctrl: ctrl === "true",
      alt: alt === "true",
      shift: shift === "true"
    });
  }
  toString() {
    return this.getKeySequences().join(" + ");
  }
  get hasModifier() {
    return this.ctrl || this.alt || this.shift;
  }
  get isModifier() {
    return ["Control", "Meta", "Alt", "Shift"].includes(this.key);
  }
  getKeySequences() {
    const sequences = [];
    if (this.ctrl) {
      sequences.push("Ctrl");
    }
    if (this.alt) {
      sequences.push("Alt");
    }
    if (this.shift) {
      sequences.push("Shift");
    }
    sequences.push(this.key);
    return sequences;
  }
}
const useKeybindingStore = /* @__PURE__ */ defineStore("keybinding", () => {
  const defaultKeybindings = ref({});
  const userKeybindings = ref({});
  const userUnsetKeybindings = ref({});
  const keybindingByKeyCombo = computed(() => {
    const result = {
      ...defaultKeybindings.value,
      ...userKeybindings.value
    };
    for (const keybinding of Object.values(userUnsetKeybindings.value)) {
      const serializedCombo = keybinding.combo.serialize();
      if (result[serializedCombo]?.equals(keybinding)) {
        delete result[serializedCombo];
      }
    }
    return result;
  });
  const keybindings = computed(
    () => Object.values(keybindingByKeyCombo.value)
  );
  function getKeybinding(combo) {
    return keybindingByKeyCombo.value[combo.serialize()];
  }
  __name(getKeybinding, "getKeybinding");
  function createKeybindingsByCommandId(keybindings2) {
    const result = {};
    for (const keybinding of keybindings2) {
      if (!(keybinding.commandId in result)) {
        result[keybinding.commandId] = [];
      }
      result[keybinding.commandId].push(keybinding);
    }
    return result;
  }
  __name(createKeybindingsByCommandId, "createKeybindingsByCommandId");
  const keybindingsByCommandId = computed(
    () => {
      return createKeybindingsByCommandId(keybindings.value);
    }
  );
  function getKeybindingsByCommandId(commandId) {
    return keybindingsByCommandId.value[commandId] ?? [];
  }
  __name(getKeybindingsByCommandId, "getKeybindingsByCommandId");
  const defaultKeybindingsByCommandId = computed(() => {
    return createKeybindingsByCommandId(Object.values(defaultKeybindings.value));
  });
  function getKeybindingByCommandId(commandId) {
    return getKeybindingsByCommandId(commandId)[0];
  }
  __name(getKeybindingByCommandId, "getKeybindingByCommandId");
  function addKeybinding(target, keybinding, { existOk = false }) {
    if (!existOk && keybinding.combo.serialize() in target.value) {
      throw new Error(
        `Keybinding on ${keybinding.combo} already exists on ${target.value[keybinding.combo.serialize()].commandId}`
      );
    }
    target.value[keybinding.combo.serialize()] = keybinding;
  }
  __name(addKeybinding, "addKeybinding");
  function addDefaultKeybinding(keybinding) {
    addKeybinding(defaultKeybindings, keybinding, { existOk: false });
  }
  __name(addDefaultKeybinding, "addDefaultKeybinding");
  function addUserKeybinding(keybinding) {
    const defaultKeybinding = defaultKeybindings.value[keybinding.combo.serialize()];
    const userUnsetKeybinding = userUnsetKeybindings.value[keybinding.combo.serialize()];
    if (keybinding.equals(defaultKeybinding) && keybinding.equals(userUnsetKeybinding)) {
      delete userUnsetKeybindings.value[keybinding.combo.serialize()];
      return;
    }
    if (defaultKeybinding && !defaultKeybinding.equals(userUnsetKeybinding)) {
      unsetKeybinding(defaultKeybinding);
    }
    addKeybinding(userKeybindings, keybinding, { existOk: true });
  }
  __name(addUserKeybinding, "addUserKeybinding");
  function unsetKeybinding(keybinding) {
    const serializedCombo = keybinding.combo.serialize();
    if (!(serializedCombo in keybindingByKeyCombo.value)) {
      throw new Error(`Keybinding on ${keybinding.combo} does not exist`);
    }
    if (userKeybindings.value[serializedCombo]?.equals(keybinding)) {
      delete userKeybindings.value[serializedCombo];
      return;
    }
    if (defaultKeybindings.value[serializedCombo]?.equals(keybinding)) {
      addKeybinding(userUnsetKeybindings, keybinding, { existOk: false });
      return;
    }
    throw new Error(`NOT_REACHED`);
  }
  __name(unsetKeybinding, "unsetKeybinding");
  function updateKeybindingOnCommand(keybinding) {
    const currentKeybinding = getKeybindingByCommandId(keybinding.commandId);
    if (currentKeybinding?.equals(keybinding)) {
      return false;
    }
    if (currentKeybinding) {
      unsetKeybinding(currentKeybinding);
    }
    addUserKeybinding(keybinding);
    return true;
  }
  __name(updateKeybindingOnCommand, "updateKeybindingOnCommand");
  function loadUserKeybindings() {
    const settingStore = useSettingStore();
    const unsetBindings = settingStore.get("Comfy.Keybinding.UnsetBindings");
    for (const keybinding of unsetBindings) {
      unsetKeybinding(new KeybindingImpl(keybinding));
    }
    const newBindings = settingStore.get("Comfy.Keybinding.NewBindings");
    for (const keybinding of newBindings) {
      addUserKeybinding(new KeybindingImpl(keybinding));
    }
  }
  __name(loadUserKeybindings, "loadUserKeybindings");
  function loadCoreKeybindings() {
    for (const keybinding of CORE_KEYBINDINGS) {
      addDefaultKeybinding(new KeybindingImpl(keybinding));
    }
  }
  __name(loadCoreKeybindings, "loadCoreKeybindings");
  function loadExtensionKeybindings(extension) {
    if (extension.keybindings) {
      for (const keybinding of extension.keybindings) {
        try {
          addDefaultKeybinding(new KeybindingImpl(keybinding));
        } catch (error) {
          console.warn(
            `Failed to load keybinding for extension ${extension.name}`,
            error
          );
        }
      }
    }
  }
  __name(loadExtensionKeybindings, "loadExtensionKeybindings");
  async function persistUserKeybindings() {
    const settingStore = useSettingStore();
    await settingStore.set(
      "Comfy.Keybinding.NewBindings",
      Object.values(userKeybindings.value)
    );
    await settingStore.set(
      "Comfy.Keybinding.UnsetBindings",
      Object.values(userUnsetKeybindings.value)
    );
  }
  __name(persistUserKeybindings, "persistUserKeybindings");
  function resetKeybindings() {
    userKeybindings.value = {};
    userUnsetKeybindings.value = {};
  }
  __name(resetKeybindings, "resetKeybindings");
  function isCommandKeybindingModified(commandId) {
    const currentKeybinding = getKeybindingByCommandId(commandId);
    const defaultKeybinding = defaultKeybindingsByCommandId.value[commandId]?.[0];
    return !(currentKeybinding === void 0 && defaultKeybinding === void 0 || currentKeybinding?.equals(defaultKeybinding));
  }
  __name(isCommandKeybindingModified, "isCommandKeybindingModified");
  return {
    keybindings,
    getKeybinding,
    getKeybindingsByCommandId,
    getKeybindingByCommandId,
    addDefaultKeybinding,
    addUserKeybinding,
    unsetKeybinding,
    updateKeybindingOnCommand,
    loadUserKeybindings,
    loadCoreKeybindings,
    loadExtensionKeybindings,
    persistUserKeybindings,
    resetKeybindings,
    isCommandKeybindingModified
  };
});
const useMenuItemStore = /* @__PURE__ */ defineStore("menuItem", () => {
  const commandStore = useCommandStore();
  const menuItems = ref([]);
  const registerMenuGroup = /* @__PURE__ */ __name((path, items2) => {
    let currentLevel = menuItems.value;
    for (let i2 = 0; i2 < path.length; i2++) {
      const segment = path[i2];
      let found = currentLevel.find((item2) => item2.label === segment);
      if (!found) {
        found = {
          label: segment,
          items: []
        };
        currentLevel.push(found);
      }
      if (!found.items) {
        found.items = [];
      }
      currentLevel = found.items;
    }
    if (currentLevel.length > 0) {
      currentLevel.push({
        separator: true
      });
    }
    currentLevel.push(...items2);
  }, "registerMenuGroup");
  const registerCommands = /* @__PURE__ */ __name((path, commandIds) => {
    const items2 = commandIds.map((commandId) => commandStore.getCommand(commandId)).map(
      (command) => ({
        command: /* @__PURE__ */ __name(() => commandStore.execute(command.id), "command"),
        label: command.menubarLabel,
        icon: command.icon,
        tooltip: command.tooltip,
        comfyCommand: command
      })
    );
    registerMenuGroup(path, items2);
  }, "registerCommands");
  const loadExtensionMenuCommands = /* @__PURE__ */ __name((extension) => {
    if (!extension.menuCommands) {
      return;
    }
    const extensionCommandIds = new Set(
      extension.commands?.map((command) => command.id) ?? []
    );
    extension.menuCommands.forEach((menuCommand) => {
      const commands = menuCommand.commands.filter(
        (command) => extensionCommandIds.has(command)
      );
      if (commands.length) {
        registerCommands(menuCommand.path, commands);
      }
    });
  }, "loadExtensionMenuCommands");
  registerCommands(["Workflow"], ["Comfy.NewBlankWorkflow"]);
  registerCommands(
    ["Workflow"],
    ["Comfy.OpenWorkflow", "Comfy.BrowseTemplates"]
  );
  registerCommands(
    ["Workflow"],
    [
      "Comfy.SaveWorkflow",
      "Comfy.SaveWorkflowAs",
      "Comfy.ExportWorkflow",
      "Comfy.ExportWorkflowAPI"
    ]
  );
  registerCommands(["Edit"], ["Comfy.Undo", "Comfy.Redo"]);
  registerCommands(["Edit"], ["Comfy.RefreshNodeDefinitions"]);
  registerCommands(["Edit"], ["Comfy.ClearWorkflow"]);
  registerCommands(["Edit"], ["Comfy.OpenClipspace"]);
  registerMenuGroup(
    ["Help"],
    [
      {
        icon: "pi pi-github",
        label: "ComfyUI Issues",
        url: "https://github.com/comfyanonymous/ComfyUI/issues"
      },
      {
        icon: "pi pi-info-circle",
        label: "ComfyUI Docs",
        url: "https://docs.comfy.org/"
      },
      {
        icon: "pi pi-discord",
        label: "Comfy-Org",
        url: "https://www.comfy.org/discord"
      }
    ]
  );
  return {
    menuItems,
    registerMenuGroup,
    registerCommands,
    loadExtensionMenuCommands
  };
});
var xterm$2 = { exports: {} };
var xterm = xterm$2.exports;
(function(module, exports) {
  !function(e, t) {
    if (true) module.exports = t();
    else if (false) (void 0)([], t);
    else {
      var i2 = t();
      for (var s in i2) (true ? exports : e)[s] = i2[s];
    }
  }(globalThis, () => (() => {
    "use strict";
    var e = { 4567: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.AccessibilityManager = void 0;
      const n = i3(9042), o = i3(9924), a = i3(844), h2 = i3(4725), c = i3(2585), l = i3(3656);
      let d = t2.AccessibilityManager = class extends a.Disposable {
        constructor(e3, t3, i4, s3) {
          super(), this._terminal = e3, this._coreBrowserService = i4, this._renderService = s3, this._rowColumns = /* @__PURE__ */ new WeakMap(), this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = this._coreBrowserService.mainDocument.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = this._coreBrowserService.mainDocument.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
          for (let e4 = 0; e4 < this._terminal.rows; e4++) this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
          if (this._topBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 0), this._bottomBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = this._coreBrowserService.mainDocument.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new o.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
          this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((e4) => this._handleResize(e4.rows))), this.register(this._terminal.onRender((e4) => this._refreshRows(e4.start, e4.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((e4) => this._handleChar(e4))), this.register(this._terminal.onLineFeed(() => this._handleChar("\n"))), this.register(this._terminal.onA11yTab((e4) => this._handleTab(e4))), this.register(this._terminal.onKey((e4) => this._handleKey(e4.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this.register((0, l.addDisposableDomListener)(document, "selectionchange", () => this._handleSelectionChange())), this.register(this._coreBrowserService.onDprChange(() => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, a.toDisposable)(() => {
            this._accessibilityContainer.remove(), this._rowElements.length = 0;
          }));
        }
        _handleTab(e3) {
          for (let t3 = 0; t3 < e3; t3++) this._handleChar(" ");
        }
        _handleChar(e3) {
          this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e3 && (this._charsToAnnounce += e3) : this._charsToAnnounce += e3, "\n" === e3 && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += n.tooMuchOutput)));
        }
        _clearLiveRegion() {
          this._liveRegion.textContent = "", this._liveRegionLineCount = 0;
        }
        _handleKey(e3) {
          this._clearLiveRegion(), /\p{Control}/u.test(e3) || this._charsToConsume.push(e3);
        }
        _refreshRows(e3, t3) {
          this._liveRegionDebouncer.refresh(e3, t3, this._terminal.rows);
        }
        _renderRows(e3, t3) {
          const i4 = this._terminal.buffer, s3 = i4.lines.length.toString();
          for (let r2 = e3; r2 <= t3; r2++) {
            const e4 = i4.lines.get(i4.ydisp + r2), t4 = [], n2 = e4?.translateToString(true, void 0, void 0, t4) || "", o2 = (i4.ydisp + r2 + 1).toString(), a2 = this._rowElements[r2];
            a2 && (0 === n2.length ? (a2.innerText = "", this._rowColumns.set(a2, [0, 1])) : (a2.textContent = n2, this._rowColumns.set(a2, t4)), a2.setAttribute("aria-posinset", o2), a2.setAttribute("aria-setsize", s3));
          }
          this._announceCharacters();
        }
        _announceCharacters() {
          0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
        }
        _handleBoundaryFocus(e3, t3) {
          const i4 = e3.target, s3 = this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2];
          if (i4.getAttribute("aria-posinset") === (0 === t3 ? "1" : `${this._terminal.buffer.lines.length}`)) return;
          if (e3.relatedTarget !== s3) return;
          let r2, n2;
          if (0 === t3 ? (r2 = i4, n2 = this._rowElements.pop(), this._rowContainer.removeChild(n2)) : (r2 = this._rowElements.shift(), n2 = i4, this._rowContainer.removeChild(r2)), r2.removeEventListener("focus", this._topBoundaryFocusListener), n2.removeEventListener("focus", this._bottomBoundaryFocusListener), 0 === t3) {
            const e4 = this._createAccessibilityTreeNode();
            this._rowElements.unshift(e4), this._rowContainer.insertAdjacentElement("afterbegin", e4);
          } else {
            const e4 = this._createAccessibilityTreeNode();
            this._rowElements.push(e4), this._rowContainer.appendChild(e4);
          }
          this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t3 ? -1 : 1), this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2].focus(), e3.preventDefault(), e3.stopImmediatePropagation();
        }
        _handleSelectionChange() {
          if (0 === this._rowElements.length) return;
          const e3 = document.getSelection();
          if (!e3) return;
          if (e3.isCollapsed) return void (this._rowContainer.contains(e3.anchorNode) && this._terminal.clearSelection());
          if (!e3.anchorNode || !e3.focusNode) return void console.error("anchorNode and/or focusNode are null");
          let t3 = { node: e3.anchorNode, offset: e3.anchorOffset }, i4 = { node: e3.focusNode, offset: e3.focusOffset };
          if ((t3.node.compareDocumentPosition(i4.node) & Node.DOCUMENT_POSITION_PRECEDING || t3.node === i4.node && t3.offset > i4.offset) && ([t3, i4] = [i4, t3]), t3.node.compareDocumentPosition(this._rowElements[0]) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING) && (t3 = { node: this._rowElements[0].childNodes[0], offset: 0 }), !this._rowContainer.contains(t3.node)) return;
          const s3 = this._rowElements.slice(-1)[0];
          if (i4.node.compareDocumentPosition(s3) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_PRECEDING) && (i4 = { node: s3, offset: s3.textContent?.length ?? 0 }), !this._rowContainer.contains(i4.node)) return;
          const r2 = /* @__PURE__ */ __name(({ node: e4, offset: t4 }) => {
            const i5 = e4 instanceof Text ? e4.parentNode : e4;
            let s4 = parseInt(i5?.getAttribute("aria-posinset"), 10) - 1;
            if (isNaN(s4)) return console.warn("row is invalid. Race condition?"), null;
            const r3 = this._rowColumns.get(i5);
            if (!r3) return console.warn("columns is null. Race condition?"), null;
            let n3 = t4 < r3.length ? r3[t4] : r3.slice(-1)[0] + 1;
            return n3 >= this._terminal.cols && (++s4, n3 = 0), { row: s4, column: n3 };
          }, "r"), n2 = r2(t3), o2 = r2(i4);
          if (n2 && o2) {
            if (n2.row > o2.row || n2.row === o2.row && n2.column >= o2.column) throw new Error("invalid range");
            this._terminal.select(n2.column, n2.row, (o2.row - n2.row) * this._terminal.cols - n2.column + o2.column);
          }
        }
        _handleResize(e3) {
          this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
          for (let e4 = this._rowContainer.children.length; e4 < this._terminal.rows; e4++) this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
          for (; this._rowElements.length > e3; ) this._rowContainer.removeChild(this._rowElements.pop());
          this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
        }
        _createAccessibilityTreeNode() {
          const e3 = this._coreBrowserService.mainDocument.createElement("div");
          return e3.setAttribute("role", "listitem"), e3.tabIndex = -1, this._refreshRowDimensions(e3), e3;
        }
        _refreshRowsDimensions() {
          if (this._renderService.dimensions.css.cell.height) {
            this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
            for (let e3 = 0; e3 < this._terminal.rows; e3++) this._refreshRowDimensions(this._rowElements[e3]);
          }
        }
        _refreshRowDimensions(e3) {
          e3.style.height = `${this._renderService.dimensions.css.cell.height}px`;
        }
      };
      t2.AccessibilityManager = d = s2([r(1, c.IInstantiationService), r(2, h2.ICoreBrowserService), r(3, h2.IRenderService)], d);
    }, 3614: (e2, t2) => {
      function i3(e3) {
        return e3.replace(/\r?\n/g, "\r");
      }
      __name(i3, "i");
      function s2(e3, t3) {
        return t3 ? "\x1B[200~" + e3 + "\x1B[201~" : e3;
      }
      __name(s2, "s");
      function r(e3, t3, r2, n2) {
        e3 = s2(e3 = i3(e3), r2.decPrivateModes.bracketedPasteMode && true !== n2.rawOptions.ignoreBracketedPasteMode), r2.triggerDataEvent(e3, true), t3.value = "";
      }
      __name(r, "r");
      function n(e3, t3, i4) {
        const s3 = i4.getBoundingClientRect(), r2 = e3.clientX - s3.left - 10, n2 = e3.clientY - s3.top - 10;
        t3.style.width = "20px", t3.style.height = "20px", t3.style.left = `${r2}px`, t3.style.top = `${n2}px`, t3.style.zIndex = "1000", t3.focus();
      }
      __name(n, "n");
      Object.defineProperty(t2, "__esModule", { value: true }), t2.rightClickHandler = t2.moveTextAreaUnderMouseCursor = t2.paste = t2.handlePasteEvent = t2.copyHandler = t2.bracketTextForPaste = t2.prepareTextForTerminal = void 0, t2.prepareTextForTerminal = i3, t2.bracketTextForPaste = s2, t2.copyHandler = function(e3, t3) {
        e3.clipboardData && e3.clipboardData.setData("text/plain", t3.selectionText), e3.preventDefault();
      }, t2.handlePasteEvent = function(e3, t3, i4, s3) {
        e3.stopPropagation(), e3.clipboardData && r(e3.clipboardData.getData("text/plain"), t3, i4, s3);
      }, t2.paste = r, t2.moveTextAreaUnderMouseCursor = n, t2.rightClickHandler = function(e3, t3, i4, s3, r2) {
        n(e3, t3, i4), r2 && s3.rightClickSelect(e3), t3.value = s3.selectionText, t3.select();
      };
    }, 7239: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorContrastCache = void 0;
      const s2 = i3(1505);
      t2.ColorContrastCache = class {
        constructor() {
          this._color = new s2.TwoKeyMap(), this._css = new s2.TwoKeyMap();
        }
        setCss(e3, t3, i4) {
          this._css.set(e3, t3, i4);
        }
        getCss(e3, t3) {
          return this._css.get(e3, t3);
        }
        setColor(e3, t3, i4) {
          this._color.set(e3, t3, i4);
        }
        getColor(e3, t3) {
          return this._color.get(e3, t3);
        }
        clear() {
          this._color.clear(), this._css.clear();
        }
      };
    }, 3656: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.addDisposableDomListener = void 0, t2.addDisposableDomListener = function(e3, t3, i3, s2) {
        e3.addEventListener(t3, i3, s2);
        let r = false;
        return { dispose: /* @__PURE__ */ __name(() => {
          r || (r = true, e3.removeEventListener(t3, i3, s2));
        }, "dispose") };
      };
    }, 3551: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Linkifier = void 0;
      const n = i3(3656), o = i3(8460), a = i3(844), h2 = i3(2585), c = i3(4725);
      let l = t2.Linkifier = class extends a.Disposable {
        get currentLink() {
          return this._currentLink;
        }
        constructor(e3, t3, i4, s3, r2) {
          super(), this._element = e3, this._mouseService = t3, this._renderService = i4, this._bufferService = s3, this._linkProviderService = r2, this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)(() => {
            this._lastMouseEvent = void 0, this._activeProviderReplies?.clear();
          })), this.register(this._bufferService.onResize(() => {
            this._clearCurrentLink(), this._wasResized = true;
          })), this.register((0, n.addDisposableDomListener)(this._element, "mouseleave", () => {
            this._isMouseOut = true, this._clearCurrentLink();
          })), this.register((0, n.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
        }
        _handleMouseMove(e3) {
          this._lastMouseEvent = e3;
          const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
          if (!t3) return;
          this._isMouseOut = false;
          const i4 = e3.composedPath();
          for (let e4 = 0; e4 < i4.length; e4++) {
            const t4 = i4[e4];
            if (t4.classList.contains("xterm")) break;
            if (t4.classList.contains("xterm-hover")) return;
          }
          this._lastBufferCell && t3.x === this._lastBufferCell.x && t3.y === this._lastBufferCell.y || (this._handleHover(t3), this._lastBufferCell = t3);
        }
        _handleHover(e3) {
          if (this._activeLine !== e3.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(e3, false), void (this._wasResized = false);
          this._currentLink && this._linkAtPosition(this._currentLink.link, e3) || (this._clearCurrentLink(), this._askForLink(e3, true));
        }
        _askForLink(e3, t3) {
          this._activeProviderReplies && t3 || (this._activeProviderReplies?.forEach((e4) => {
            e4?.forEach((e5) => {
              e5.link.dispose && e5.link.dispose();
            });
          }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = e3.y);
          let i4 = false;
          for (const [s3, r2] of this._linkProviderService.linkProviders.entries()) if (t3) {
            const t4 = this._activeProviderReplies?.get(s3);
            t4 && (i4 = this._checkLinkProviderResult(s3, e3, i4));
          } else r2.provideLinks(e3.y, (t4) => {
            if (this._isMouseOut) return;
            const r3 = t4?.map((e4) => ({ link: e4 }));
            this._activeProviderReplies?.set(s3, r3), i4 = this._checkLinkProviderResult(s3, e3, i4), this._activeProviderReplies?.size === this._linkProviderService.linkProviders.length && this._removeIntersectingLinks(e3.y, this._activeProviderReplies);
          });
        }
        _removeIntersectingLinks(e3, t3) {
          const i4 = /* @__PURE__ */ new Set();
          for (let s3 = 0; s3 < t3.size; s3++) {
            const r2 = t3.get(s3);
            if (r2) for (let t4 = 0; t4 < r2.length; t4++) {
              const s4 = r2[t4], n2 = s4.link.range.start.y < e3 ? 0 : s4.link.range.start.x, o2 = s4.link.range.end.y > e3 ? this._bufferService.cols : s4.link.range.end.x;
              for (let e4 = n2; e4 <= o2; e4++) {
                if (i4.has(e4)) {
                  r2.splice(t4--, 1);
                  break;
                }
                i4.add(e4);
              }
            }
          }
        }
        _checkLinkProviderResult(e3, t3, i4) {
          if (!this._activeProviderReplies) return i4;
          const s3 = this._activeProviderReplies.get(e3);
          let r2 = false;
          for (let t4 = 0; t4 < e3; t4++) this._activeProviderReplies.has(t4) && !this._activeProviderReplies.get(t4) || (r2 = true);
          if (!r2 && s3) {
            const e4 = s3.find((e5) => this._linkAtPosition(e5.link, t3));
            e4 && (i4 = true, this._handleNewLink(e4));
          }
          if (this._activeProviderReplies.size === this._linkProviderService.linkProviders.length && !i4) for (let e4 = 0; e4 < this._activeProviderReplies.size; e4++) {
            const s4 = this._activeProviderReplies.get(e4)?.find((e5) => this._linkAtPosition(e5.link, t3));
            if (s4) {
              i4 = true, this._handleNewLink(s4);
              break;
            }
          }
          return i4;
        }
        _handleMouseDown() {
          this._mouseDownLink = this._currentLink;
        }
        _handleMouseUp(e3) {
          if (!this._currentLink) return;
          const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
          t3 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t3) && this._currentLink.link.activate(e3, this._currentLink.link.text);
        }
        _clearCurrentLink(e3, t3) {
          this._currentLink && this._lastMouseEvent && (!e3 || !t3 || this._currentLink.link.range.start.y >= e3 && this._currentLink.link.range.end.y <= t3) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));
        }
        _handleNewLink(e3) {
          if (!this._lastMouseEvent) return;
          const t3 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
          t3 && this._linkAtPosition(e3.link, t3) && (this._currentLink = e3, this._currentLink.state = { decorations: { underline: void 0 === e3.link.decorations || e3.link.decorations.underline, pointerCursor: void 0 === e3.link.decorations || e3.link.decorations.pointerCursor }, isHovered: true }, this._linkHover(this._element, e3.link, this._lastMouseEvent), e3.link.decorations = {}, Object.defineProperties(e3.link.decorations, { pointerCursor: { get: /* @__PURE__ */ __name(() => this._currentLink?.state?.decorations.pointerCursor, "get"), set: /* @__PURE__ */ __name((e4) => {
            this._currentLink?.state && this._currentLink.state.decorations.pointerCursor !== e4 && (this._currentLink.state.decorations.pointerCursor = e4, this._currentLink.state.isHovered && this._element.classList.toggle("xterm-cursor-pointer", e4));
          }, "set") }, underline: { get: /* @__PURE__ */ __name(() => this._currentLink?.state?.decorations.underline, "get"), set: /* @__PURE__ */ __name((t4) => {
            this._currentLink?.state && this._currentLink?.state?.decorations.underline !== t4 && (this._currentLink.state.decorations.underline = t4, this._currentLink.state.isHovered && this._fireUnderlineEvent(e3.link, t4));
          }, "set") } }), this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((e4) => {
            if (!this._currentLink) return;
            const t4 = 0 === e4.start ? 0 : e4.start + 1 + this._bufferService.buffer.ydisp, i4 = this._bufferService.buffer.ydisp + 1 + e4.end;
            if (this._currentLink.link.range.start.y >= t4 && this._currentLink.link.range.end.y <= i4 && (this._clearCurrentLink(t4, i4), this._lastMouseEvent)) {
              const e5 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
              e5 && this._askForLink(e5, false);
            }
          })));
        }
        _linkHover(e3, t3, i4) {
          this._currentLink?.state && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, true), this._currentLink.state.decorations.pointerCursor && e3.classList.add("xterm-cursor-pointer")), t3.hover && t3.hover(i4, t3.text);
        }
        _fireUnderlineEvent(e3, t3) {
          const i4 = e3.range, s3 = this._bufferService.buffer.ydisp, r2 = this._createLinkUnderlineEvent(i4.start.x - 1, i4.start.y - s3 - 1, i4.end.x, i4.end.y - s3 - 1, void 0);
          (t3 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r2);
        }
        _linkLeave(e3, t3, i4) {
          this._currentLink?.state && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, false), this._currentLink.state.decorations.pointerCursor && e3.classList.remove("xterm-cursor-pointer")), t3.leave && t3.leave(i4, t3.text);
        }
        _linkAtPosition(e3, t3) {
          const i4 = e3.range.start.y * this._bufferService.cols + e3.range.start.x, s3 = e3.range.end.y * this._bufferService.cols + e3.range.end.x, r2 = t3.y * this._bufferService.cols + t3.x;
          return i4 <= r2 && r2 <= s3;
        }
        _positionFromMouseEvent(e3, t3, i4) {
          const s3 = i4.getCoords(e3, t3, this._bufferService.cols, this._bufferService.rows);
          if (s3) return { x: s3[0], y: s3[1] + this._bufferService.buffer.ydisp };
        }
        _createLinkUnderlineEvent(e3, t3, i4, s3, r2) {
          return { x1: e3, y1: t3, x2: i4, y2: s3, cols: this._bufferService.cols, fg: r2 };
        }
      };
      t2.Linkifier = l = s2([r(1, c.IMouseService), r(2, c.IRenderService), r(3, h2.IBufferService), r(4, c.ILinkProviderService)], l);
    }, 9042: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.tooMuchOutput = t2.promptLabel = void 0, t2.promptLabel = "Terminal input", t2.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
    }, 3730: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkProvider = void 0;
      const n = i3(511), o = i3(2585);
      let a = t2.OscLinkProvider = class {
        constructor(e3, t3, i4) {
          this._bufferService = e3, this._optionsService = t3, this._oscLinkService = i4;
        }
        provideLinks(e3, t3) {
          const i4 = this._bufferService.buffer.lines.get(e3 - 1);
          if (!i4) return void t3(void 0);
          const s3 = [], r2 = this._optionsService.rawOptions.linkHandler, o2 = new n.CellData(), a2 = i4.getTrimmedLength();
          let c = -1, l = -1, d = false;
          for (let t4 = 0; t4 < a2; t4++) if (-1 !== l || i4.hasContent(t4)) {
            if (i4.loadCell(t4, o2), o2.hasExtendedAttrs() && o2.extended.urlId) {
              if (-1 === l) {
                l = t4, c = o2.extended.urlId;
                continue;
              }
              d = o2.extended.urlId !== c;
            } else -1 !== l && (d = true);
            if (d || -1 !== l && t4 === a2 - 1) {
              const i5 = this._oscLinkService.getLinkData(c)?.uri;
              if (i5) {
                const n2 = { start: { x: l + 1, y: e3 }, end: { x: t4 + (d || t4 !== a2 - 1 ? 0 : 1), y: e3 } };
                let o3 = false;
                if (!r2?.allowNonHttpProtocols) try {
                  const e4 = new URL(i5);
                  ["http:", "https:"].includes(e4.protocol) || (o3 = true);
                } catch (e4) {
                  o3 = true;
                }
                o3 || s3.push({ text: i5, range: n2, activate: /* @__PURE__ */ __name((e4, t5) => r2 ? r2.activate(e4, t5, n2) : h2(0, t5), "activate"), hover: /* @__PURE__ */ __name((e4, t5) => r2?.hover?.(e4, t5, n2), "hover"), leave: /* @__PURE__ */ __name((e4, t5) => r2?.leave?.(e4, t5, n2), "leave") });
              }
              d = false, o2.hasExtendedAttrs() && o2.extended.urlId ? (l = t4, c = o2.extended.urlId) : (l = -1, c = -1);
            }
          }
          t3(s3);
        }
      };
      function h2(e3, t3) {
        if (confirm(`Do you want to navigate to ${t3}?

WARNING: This link could potentially be dangerous`)) {
          const e4 = window.open();
          if (e4) {
            try {
              e4.opener = null;
            } catch {
            }
            e4.location.href = t3;
          } else console.warn("Opening link blocked as opener could not be cleared");
        }
      }
      __name(h2, "h");
      t2.OscLinkProvider = a = s2([r(0, o.IBufferService), r(1, o.IOptionsService), r(2, o.IOscLinkService)], a);
    }, 6193: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderDebouncer = void 0, t2.RenderDebouncer = class {
        constructor(e3, t3) {
          this._renderCallback = e3, this._coreBrowserService = t3, this._refreshCallbacks = [];
        }
        dispose() {
          this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
        }
        addRefreshCallback(e3) {
          return this._refreshCallbacks.push(e3), this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
        }
        refresh(e3, t3, i3) {
          this._rowCount = i3, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return void this._runRefreshCallbacks();
          const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3), this._runRefreshCallbacks();
        }
        _runRefreshCallbacks() {
          for (const e3 of this._refreshCallbacks) e3(0);
          this._refreshCallbacks = [];
        }
      };
    }, 3236: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Terminal = void 0;
      const s2 = i3(3614), r = i3(3656), n = i3(3551), o = i3(9042), a = i3(3730), h2 = i3(1680), c = i3(3107), l = i3(5744), d = i3(2950), _2 = i3(1296), u = i3(428), f = i3(4269), v2 = i3(5114), p2 = i3(8934), g = i3(3230), m = i3(9312), S = i3(4725), C = i3(6731), b = i3(8055), w2 = i3(8969), y2 = i3(8460), E = i3(844), k = i3(6114), L = i3(8437), D = i3(2584), R = i3(7399), x2 = i3(5941), A = i3(9074), B = i3(2585), T = i3(5435), M = i3(4567), O = i3(779);
      class P extends w2.CoreTerminal {
        static {
          __name(this, "P");
        }
        get onFocus() {
          return this._onFocus.event;
        }
        get onBlur() {
          return this._onBlur.event;
        }
        get onA11yChar() {
          return this._onA11yCharEmitter.event;
        }
        get onA11yTab() {
          return this._onA11yTabEmitter.event;
        }
        get onWillOpen() {
          return this._onWillOpen.event;
        }
        constructor(e3 = {}) {
          super(e3), this.browser = k, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._accessibilityManager = this.register(new E.MutableDisposable()), this._onCursorMove = this.register(new y2.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new y2.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new y2.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new y2.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new y2.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new y2.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new y2.EventEmitter()), this._onBlur = this.register(new y2.EventEmitter()), this._onA11yCharEmitter = this.register(new y2.EventEmitter()), this._onA11yTabEmitter = this.register(new y2.EventEmitter()), this._onWillOpen = this.register(new y2.EventEmitter()), this._setup(), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(B.IDecorationService, this._decorationService), this._linkProviderService = this._instantiationService.createInstance(O.LinkProviderService), this._instantiationService.setService(S.ILinkProviderService, this._linkProviderService), this._linkProviderService.registerLinkProvider(this._instantiationService.createInstance(a.OscLinkProvider)), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((e4, t3) => this.refresh(e4, t3))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((e4) => this._reportWindowsOptions(e4))), this.register(this._inputHandler.onColor((e4) => this._handleColorEvent(e4))), this.register((0, y2.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, y2.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, y2.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, y2.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((e4) => this._afterResize(e4.cols, e4.rows))), this.register((0, E.toDisposable)(() => {
            this._customKeyEventHandler = void 0, this.element?.parentNode?.removeChild(this.element);
          }));
        }
        _handleColorEvent(e3) {
          if (this._themeService) for (const t3 of e3) {
            let e4, i4 = "";
            switch (t3.index) {
              case 256:
                e4 = "foreground", i4 = "10";
                break;
              case 257:
                e4 = "background", i4 = "11";
                break;
              case 258:
                e4 = "cursor", i4 = "12";
                break;
              default:
                e4 = "ansi", i4 = "4;" + t3.index;
            }
            switch (t3.type) {
              case 0:
                const s3 = b.color.toColorRGB("ansi" === e4 ? this._themeService.colors.ansi[t3.index] : this._themeService.colors[e4]);
                this.coreService.triggerDataEvent(`${D.C0.ESC}]${i4};${(0, x2.toRgbString)(s3)}${D.C1_ESCAPED.ST}`);
                break;
              case 1:
                if ("ansi" === e4) this._themeService.modifyColors((e5) => e5.ansi[t3.index] = b.channels.toColor(...t3.color));
                else {
                  const i5 = e4;
                  this._themeService.modifyColors((e5) => e5[i5] = b.channels.toColor(...t3.color));
                }
                break;
              case 2:
                this._themeService.restoreColor(t3.index);
            }
          }
        }
        _setup() {
          super._setup(), this._customKeyEventHandler = void 0;
        }
        get buffer() {
          return this.buffers.active;
        }
        focus() {
          this.textarea && this.textarea.focus({ preventScroll: true });
        }
        _handleScreenReaderModeOptionChange(e3) {
          e3 ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)) : this._accessibilityManager.clear();
        }
        _handleTextAreaFocus(e3) {
          this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[I"), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
        }
        blur() {
          return this.textarea?.blur();
        }
        _handleTextAreaBlur() {
          this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
        }
        _syncTextArea() {
          if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
          const e3 = this.buffer.ybase + this.buffer.y, t3 = this.buffer.lines.get(e3);
          if (!t3) return;
          const i4 = Math.min(this.buffer.x, this.cols - 1), s3 = this._renderService.dimensions.css.cell.height, r2 = t3.getWidth(i4), n2 = this._renderService.dimensions.css.cell.width * r2, o2 = this.buffer.y * this._renderService.dimensions.css.cell.height, a2 = i4 * this._renderService.dimensions.css.cell.width;
          this.textarea.style.left = a2 + "px", this.textarea.style.top = o2 + "px", this.textarea.style.width = n2 + "px", this.textarea.style.height = s3 + "px", this.textarea.style.lineHeight = s3 + "px", this.textarea.style.zIndex = "-5";
        }
        _initGlobal() {
          this._bindKeys(), this.register((0, r.addDisposableDomListener)(this.element, "copy", (e4) => {
            this.hasSelection() && (0, s2.copyHandler)(e4, this._selectionService);
          }));
          const e3 = /* @__PURE__ */ __name((e4) => (0, s2.handlePasteEvent)(e4, this.textarea, this.coreService, this.optionsService), "e");
          this.register((0, r.addDisposableDomListener)(this.textarea, "paste", e3)), this.register((0, r.addDisposableDomListener)(this.element, "paste", e3)), k.isFirefox ? this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => {
            2 === e4.button && (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })) : this.register((0, r.addDisposableDomListener)(this.element, "contextmenu", (e4) => {
            (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })), k.isLinux && this.register((0, r.addDisposableDomListener)(this.element, "auxclick", (e4) => {
            1 === e4.button && (0, s2.moveTextAreaUnderMouseCursor)(e4, this.textarea, this.screenElement);
          }));
        }
        _bindKeys() {
          this.register((0, r.addDisposableDomListener)(this.textarea, "keyup", (e3) => this._keyUp(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keydown", (e3) => this._keyDown(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keypress", (e3) => this._keyPress(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionupdate", (e3) => this._compositionHelper.compositionupdate(e3))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, r.addDisposableDomListener)(this.textarea, "input", (e3) => this._inputEvent(e3), true)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
        }
        open(e3) {
          if (!e3) throw new Error("Terminal requires a parent element.");
          if (e3.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this.element?.ownerDocument.defaultView && this._coreBrowserService) return void (this.element.ownerDocument.defaultView !== this._coreBrowserService.window && (this._coreBrowserService.window = this.element.ownerDocument.defaultView));
          this._document = e3.ownerDocument, this.options.documentOverride && this.options.documentOverride instanceof Document && (this._document = this.optionsService.rawOptions.documentOverride), this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e3.appendChild(this.element);
          const t3 = this._document.createDocumentFragment();
          this._viewportElement = this._document.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), t3.appendChild(this._viewportElement), this._viewportScrollArea = this._document.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = this._document.createElement("div"), this.screenElement.classList.add("xterm-screen"), this.register((0, r.addDisposableDomListener)(this.screenElement, "mousemove", (e4) => this.updateCursorStyle(e4))), this._helperContainer = this._document.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), t3.appendChild(this.screenElement), this.textarea = this._document.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", o.promptLabel), k.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this.register(this._instantiationService.createInstance(v2.CoreBrowserService, this.textarea, e3.ownerDocument.defaultView ?? window, this._document ?? "undefined" != typeof window ? window.document : null)), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, r.addDisposableDomListener)(this.textarea, "focus", (e4) => this._handleTextAreaFocus(e4))), this.register((0, r.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(u.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(C.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(f.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(g.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((e4) => this._onRender.fire(e4))), this.onResize((e4) => this._renderService.resize(e4.cols, e4.rows)), this._compositionView = this._document.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(d.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this._mouseService = this._instantiationService.createInstance(p2.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.linkifier = this.register(this._instantiationService.createInstance(n.Linkifier, this.screenElement)), this.element.appendChild(t3);
          try {
            this._onWillOpen.fire(this.element);
          } catch {
          }
          this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this.viewport = this._instantiationService.createInstance(h2.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
            this._renderService.handleCursorMove(), this._syncTextArea();
          })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(m.SelectionService, this.element, this.screenElement, this.linkifier)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((e4) => this._renderService.handleSelectionChanged(e4.start, e4.end, e4.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((e4) => {
            this.textarea.value = e4, this.textarea.focus(), this.textarea.select();
          })), this.register(this._onScroll.event((e4) => {
            this.viewport.syncScrollArea(), this._selectionService.refresh();
          })), this.register((0, r.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.register(this._instantiationService.createInstance(c.BufferDecorationRenderer, this.screenElement)), this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => this._selectionService.handleMouseDown(e4))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (e4) => this._handleScreenReaderModeOptionChange(e4))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (e4) => {
            !this._overviewRulerRenderer && e4 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
          }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
        }
        _createRenderer() {
          return this._instantiationService.createInstance(_2.DomRenderer, this, this._document, this.element, this.screenElement, this._viewportElement, this._helperContainer, this.linkifier);
        }
        bindMouse() {
          const e3 = this, t3 = this.element;
          function i4(t4) {
            const i5 = e3._mouseService.getMouseReportCoords(t4, e3.screenElement);
            if (!i5) return false;
            let s4, r2;
            switch (t4.overrideType || t4.type) {
              case "mousemove":
                r2 = 32, void 0 === t4.buttons ? (s4 = 3, void 0 !== t4.button && (s4 = t4.button < 3 ? t4.button : 3)) : s4 = 1 & t4.buttons ? 0 : 4 & t4.buttons ? 1 : 2 & t4.buttons ? 2 : 3;
                break;
              case "mouseup":
                r2 = 0, s4 = t4.button < 3 ? t4.button : 3;
                break;
              case "mousedown":
                r2 = 1, s4 = t4.button < 3 ? t4.button : 3;
                break;
              case "wheel":
                if (e3._customWheelEventHandler && false === e3._customWheelEventHandler(t4)) return false;
                if (0 === e3.viewport.getLinesScrolled(t4)) return false;
                r2 = t4.deltaY < 0 ? 0 : 1, s4 = 4;
                break;
              default:
                return false;
            }
            return !(void 0 === r2 || void 0 === s4 || s4 > 4) && e3.coreMouseService.triggerMouseEvent({ col: i5.col, row: i5.row, x: i5.x, y: i5.y, button: s4, action: r2, ctrl: t4.ctrlKey, alt: t4.altKey, shift: t4.shiftKey });
          }
          __name(i4, "i");
          const s3 = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, n2 = { mouseup: /* @__PURE__ */ __name((e4) => (i4(e4), e4.buttons || (this._document.removeEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.removeEventListener("mousemove", s3.mousedrag)), this.cancel(e4)), "mouseup"), wheel: /* @__PURE__ */ __name((e4) => (i4(e4), this.cancel(e4, true)), "wheel"), mousedrag: /* @__PURE__ */ __name((e4) => {
            e4.buttons && i4(e4);
          }, "mousedrag"), mousemove: /* @__PURE__ */ __name((e4) => {
            e4.buttons || i4(e4);
          }, "mousemove") };
          this.register(this.coreMouseService.onProtocolChange((e4) => {
            e4 ? ("debug" === this.optionsService.rawOptions.logLevel && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e4)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e4 ? s3.mousemove || (t3.addEventListener("mousemove", n2.mousemove), s3.mousemove = n2.mousemove) : (t3.removeEventListener("mousemove", s3.mousemove), s3.mousemove = null), 16 & e4 ? s3.wheel || (t3.addEventListener("wheel", n2.wheel, { passive: false }), s3.wheel = n2.wheel) : (t3.removeEventListener("wheel", s3.wheel), s3.wheel = null), 2 & e4 ? s3.mouseup || (s3.mouseup = n2.mouseup) : (this._document.removeEventListener("mouseup", s3.mouseup), s3.mouseup = null), 4 & e4 ? s3.mousedrag || (s3.mousedrag = n2.mousedrag) : (this._document.removeEventListener("mousemove", s3.mousedrag), s3.mousedrag = null);
          })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, r.addDisposableDomListener)(t3, "mousedown", (e4) => {
            if (e4.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e4)) return i4(e4), s3.mouseup && this._document.addEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.addEventListener("mousemove", s3.mousedrag), this.cancel(e4);
          })), this.register((0, r.addDisposableDomListener)(t3, "wheel", (e4) => {
            if (!s3.wheel) {
              if (this._customWheelEventHandler && false === this._customWheelEventHandler(e4)) return false;
              if (!this.buffer.hasScrollback) {
                const t4 = this.viewport.getLinesScrolled(e4);
                if (0 === t4) return;
                const i5 = D.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e4.deltaY < 0 ? "A" : "B");
                let s4 = "";
                for (let e5 = 0; e5 < Math.abs(t4); e5++) s4 += i5;
                return this.coreService.triggerDataEvent(s4, true), this.cancel(e4, true);
              }
              return this.viewport.handleWheel(e4) ? this.cancel(e4) : void 0;
            }
          }, { passive: false })), this.register((0, r.addDisposableDomListener)(t3, "touchstart", (e4) => {
            if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(e4), this.cancel(e4);
          }, { passive: true })), this.register((0, r.addDisposableDomListener)(t3, "touchmove", (e4) => {
            if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(e4) ? void 0 : this.cancel(e4);
          }, { passive: false }));
        }
        refresh(e3, t3) {
          this._renderService?.refreshRows(e3, t3);
        }
        updateCursorStyle(e3) {
          this._selectionService?.shouldColumnSelect(e3) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
        }
        _showCursor() {
          this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
        }
        scrollLines(e3, t3, i4 = 0) {
          1 === i4 ? (super.scrollLines(e3, t3, i4), this.refresh(0, this.rows - 1)) : this.viewport?.scrollLines(e3);
        }
        paste(e3) {
          (0, s2.paste)(e3, this.textarea, this.coreService, this.optionsService);
        }
        attachCustomKeyEventHandler(e3) {
          this._customKeyEventHandler = e3;
        }
        attachCustomWheelEventHandler(e3) {
          this._customWheelEventHandler = e3;
        }
        registerLinkProvider(e3) {
          return this._linkProviderService.registerLinkProvider(e3);
        }
        registerCharacterJoiner(e3) {
          if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
          const t3 = this._characterJoinerService.register(e3);
          return this.refresh(0, this.rows - 1), t3;
        }
        deregisterCharacterJoiner(e3) {
          if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
          this._characterJoinerService.deregister(e3) && this.refresh(0, this.rows - 1);
        }
        get markers() {
          return this.buffer.markers;
        }
        registerMarker(e3) {
          return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e3);
        }
        registerDecoration(e3) {
          return this._decorationService.registerDecoration(e3);
        }
        hasSelection() {
          return !!this._selectionService && this._selectionService.hasSelection;
        }
        select(e3, t3, i4) {
          this._selectionService.setSelection(e3, t3, i4);
        }
        getSelection() {
          return this._selectionService ? this._selectionService.selectionText : "";
        }
        getSelectionPosition() {
          if (this._selectionService && this._selectionService.hasSelection) return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
        }
        clearSelection() {
          this._selectionService?.clearSelection();
        }
        selectAll() {
          this._selectionService?.selectAll();
        }
        selectLines(e3, t3) {
          this._selectionService?.selectLines(e3, t3);
        }
        _keyDown(e3) {
          if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && false === this._customKeyEventHandler(e3)) return false;
          const t3 = this.browser.isMac && this.options.macOptionIsMeta && e3.altKey;
          if (!t3 && !this._compositionHelper.keydown(e3)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), false;
          t3 || "Dead" !== e3.key && "AltGraph" !== e3.key || (this._unprocessedDeadKey = true);
          const i4 = (0, R.evaluateKeyboardEvent)(e3, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
          if (this.updateCursorStyle(e3), 3 === i4.type || 2 === i4.type) {
            const t4 = this.rows - 1;
            return this.scrollLines(2 === i4.type ? -t4 : t4), this.cancel(e3, true);
          }
          return 1 === i4.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e3) || (i4.cancel && this.cancel(e3, true), !i4.key || !!(e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && 1 === e3.key.length && e3.key.charCodeAt(0) >= 65 && e3.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (i4.key !== D.C0.ETX && i4.key !== D.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: i4.key, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(i4.key, true), !this.optionsService.rawOptions.screenReaderMode || e3.altKey || e3.ctrlKey ? this.cancel(e3, true) : void (this._keyDownHandled = true))));
        }
        _isThirdLevelShift(e3, t3) {
          const i4 = e3.isMac && !this.options.macOptionIsMeta && t3.altKey && !t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.altKey && t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.getModifierState("AltGraph");
          return "keypress" === t3.type ? i4 : i4 && (!t3.keyCode || t3.keyCode > 47);
        }
        _keyUp(e3) {
          this._keyDownSeen = false, this._customKeyEventHandler && false === this._customKeyEventHandler(e3) || (function(e4) {
            return 16 === e4.keyCode || 17 === e4.keyCode || 18 === e4.keyCode;
          }(e3) || this.focus(), this.updateCursorStyle(e3), this._keyPressHandled = false);
        }
        _keyPress(e3) {
          let t3;
          if (this._keyPressHandled = false, this._keyDownHandled) return false;
          if (this._customKeyEventHandler && false === this._customKeyEventHandler(e3)) return false;
          if (this.cancel(e3), e3.charCode) t3 = e3.charCode;
          else if (null === e3.which || void 0 === e3.which) t3 = e3.keyCode;
          else {
            if (0 === e3.which || 0 === e3.charCode) return false;
            t3 = e3.which;
          }
          return !(!t3 || (e3.altKey || e3.ctrlKey || e3.metaKey) && !this._isThirdLevelShift(this.browser, e3) || (t3 = String.fromCharCode(t3), this._onKey.fire({ key: t3, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(t3, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
        }
        _inputEvent(e3) {
          if (e3.data && "insertText" === e3.inputType && (!e3.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
            if (this._keyPressHandled) return false;
            this._unprocessedDeadKey = false;
            const t3 = e3.data;
            return this.coreService.triggerDataEvent(t3, true), this.cancel(e3), true;
          }
          return false;
        }
        resize(e3, t3) {
          e3 !== this.cols || t3 !== this.rows ? super.resize(e3, t3) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
        }
        _afterResize(e3, t3) {
          this._charSizeService?.measure(), this.viewport?.syncScrollArea(true);
        }
        clear() {
          if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
            this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
            for (let e3 = 1; e3 < this.rows; e3++) this.buffer.lines.push(this.buffer.getBlankLine(L.DEFAULT_ATTR_DATA));
            this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), this.viewport?.reset(), this.refresh(0, this.rows - 1);
          }
        }
        reset() {
          this.options.rows = this.rows, this.options.cols = this.cols;
          const e3 = this._customKeyEventHandler;
          this._setup(), super.reset(), this._selectionService?.reset(), this._decorationService.reset(), this.viewport?.reset(), this._customKeyEventHandler = e3, this.refresh(0, this.rows - 1);
        }
        clearTextureAtlas() {
          this._renderService?.clearTextureAtlas();
        }
        _reportFocus() {
          this.element?.classList.contains("focus") ? this.coreService.triggerDataEvent(D.C0.ESC + "[I") : this.coreService.triggerDataEvent(D.C0.ESC + "[O");
        }
        _reportWindowsOptions(e3) {
          if (this._renderService) switch (e3) {
            case T.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
              const e4 = this._renderService.dimensions.css.canvas.width.toFixed(0), t3 = this._renderService.dimensions.css.canvas.height.toFixed(0);
              this.coreService.triggerDataEvent(`${D.C0.ESC}[4;${t3};${e4}t`);
              break;
            case T.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
              const i4 = this._renderService.dimensions.css.cell.width.toFixed(0), s3 = this._renderService.dimensions.css.cell.height.toFixed(0);
              this.coreService.triggerDataEvent(`${D.C0.ESC}[6;${s3};${i4}t`);
          }
        }
        cancel(e3, t3) {
          if (this.options.cancelEvents || t3) return e3.preventDefault(), e3.stopPropagation(), false;
        }
      }
      t2.Terminal = P;
    }, 9924: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.TimeBasedDebouncer = void 0, t2.TimeBasedDebouncer = class {
        constructor(e3, t3 = 1e3) {
          this._renderCallback = e3, this._debounceThresholdMS = t3, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
        }
        dispose() {
          this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
        }
        refresh(e3, t3, i3) {
          this._rowCount = i3, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3;
          const s2 = Date.now();
          if (s2 - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = s2, this._innerRefresh();
          else if (!this._additionalRefreshRequested) {
            const e4 = s2 - this._lastRefreshMs, t4 = this._debounceThresholdMS - e4;
            this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout(() => {
              this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = void 0;
            }, t4);
          }
        }
        _innerRefresh() {
          if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return;
          const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3);
        }
      };
    }, 1680: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Viewport = void 0;
      const n = i3(3656), o = i3(4725), a = i3(8460), h2 = i3(844), c = i3(2585);
      let l = t2.Viewport = class extends h2.Disposable {
        constructor(e3, t3, i4, s3, r2, o2, h3, c2) {
          super(), this._viewportElement = e3, this._scrollArea = t3, this._bufferService = i4, this._optionsService = s3, this._charSizeService = r2, this._renderService = o2, this._coreBrowserService = h3, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new a.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((e4) => this._renderDimensions = e4)), this._handleThemeChange(c2.colors), this.register(c2.onChangeColors((e4) => this._handleThemeChange(e4))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
        }
        _handleThemeChange(e3) {
          this._viewportElement.style.backgroundColor = e3.background.css;
        }
        reset() {
          this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
        }
        _refresh(e3) {
          if (e3) return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
          null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._charSizeService.height > 0) {
            this._currentRowHeight = this._renderDimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderDimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
            const e4 = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderDimensions.css.canvas.height);
            this._lastRecordedBufferHeight !== e4 && (this._lastRecordedBufferHeight = e4, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
          }
          const e3 = this._bufferService.buffer.ydisp * this._currentRowHeight;
          this._viewportElement.scrollTop !== e3 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = e3), this._refreshAnimationFrame = null;
        }
        syncScrollArea(e3 = false) {
          if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e3);
          this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e3);
        }
        _handleScroll(e3) {
          if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
          if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = false, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: true });
          const t3 = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
          this._onRequestScrollLines.fire({ amount: t3, suppressScrollEvent: true });
        }
        _smoothScroll() {
          if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target) return;
          const e3 = this._smoothScrollPercent();
          this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e3 * (this._smoothScrollState.target - this._smoothScrollState.origin)), e3 < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
        }
        _smoothScrollPercent() {
          return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
        }
        _clearSmoothScrollState() {
          this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
        }
        _bubbleScroll(e3, t3) {
          const i4 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
          return !(t3 < 0 && 0 !== this._viewportElement.scrollTop || t3 > 0 && i4 < this._lastRecordedBufferHeight) || (e3.cancelable && e3.preventDefault(), false);
        }
        handleWheel(e3) {
          const t3 = this._getPixelsScrolled(e3);
          return 0 !== t3 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t3 : this._smoothScrollState.target += t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
        }
        scrollLines(e3) {
          if (0 !== e3) if (this._optionsService.rawOptions.smoothScrollDuration) {
            const t3 = e3 * this._currentRowHeight;
            this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
          } else this._onRequestScrollLines.fire({ amount: e3, suppressScrollEvent: false });
        }
        _getPixelsScrolled(e3) {
          if (0 === e3.deltaY || e3.shiftKey) return 0;
          let t3 = this._applyScrollModifier(e3.deltaY, e3);
          return e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? t3 *= this._currentRowHeight : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._currentRowHeight * this._bufferService.rows), t3;
        }
        getBufferElements(e3, t3) {
          let i4, s3 = "";
          const r2 = [], n2 = t3 ?? this._bufferService.buffer.lines.length, o2 = this._bufferService.buffer.lines;
          for (let t4 = e3; t4 < n2; t4++) {
            const e4 = o2.get(t4);
            if (!e4) continue;
            const n3 = o2.get(t4 + 1)?.isWrapped;
            if (s3 += e4.translateToString(!n3), !n3 || t4 === o2.length - 1) {
              const e5 = document.createElement("div");
              e5.textContent = s3, r2.push(e5), s3.length > 0 && (i4 = e5), s3 = "";
            }
          }
          return { bufferElements: r2, cursorElement: i4 };
        }
        getLinesScrolled(e3) {
          if (0 === e3.deltaY || e3.shiftKey) return 0;
          let t3 = this._applyScrollModifier(e3.deltaY, e3);
          return e3.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t3 /= this._currentRowHeight + 0, this._wheelPartialScroll += t3, t3 = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._bufferService.rows), t3;
        }
        _applyScrollModifier(e3, t3) {
          const i4 = this._optionsService.rawOptions.fastScrollModifier;
          return "alt" === i4 && t3.altKey || "ctrl" === i4 && t3.ctrlKey || "shift" === i4 && t3.shiftKey ? e3 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e3 * this._optionsService.rawOptions.scrollSensitivity;
        }
        handleTouchStart(e3) {
          this._lastTouchY = e3.touches[0].pageY;
        }
        handleTouchMove(e3) {
          const t3 = this._lastTouchY - e3.touches[0].pageY;
          return this._lastTouchY = e3.touches[0].pageY, 0 !== t3 && (this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
        }
      };
      t2.Viewport = l = s2([r(2, c.IBufferService), r(3, c.IOptionsService), r(4, o.ICharSizeService), r(5, o.IRenderService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], l);
    }, 3107: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferDecorationRenderer = void 0;
      const n = i3(4725), o = i3(844), a = i3(2585);
      let h2 = t2.BufferDecorationRenderer = class extends o.Disposable {
        constructor(e3, t3, i4, s3, r2) {
          super(), this._screenElement = e3, this._bufferService = t3, this._coreBrowserService = i4, this._decorationService = s3, this._renderService = r2, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
            this._dimensionsChanged = true, this._queueRefresh();
          })), this.register(this._coreBrowserService.onDprChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
          })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((e4) => this._removeDecoration(e4))), this.register((0, o.toDisposable)(() => {
            this._container.remove(), this._decorationElements.clear();
          }));
        }
        _queueRefresh() {
          void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback(() => {
            this._doRefreshDecorations(), this._animationFrame = void 0;
          }));
        }
        _doRefreshDecorations() {
          for (const e3 of this._decorationService.decorations) this._renderDecoration(e3);
          this._dimensionsChanged = false;
        }
        _renderDecoration(e3) {
          this._refreshStyle(e3), this._dimensionsChanged && this._refreshXPosition(e3);
        }
        _createElement(e3) {
          const t3 = this._coreBrowserService.mainDocument.createElement("div");
          t3.classList.add("xterm-decoration"), t3.classList.toggle("xterm-decoration-top-layer", "top" === e3?.options?.layer), t3.style.width = `${Math.round((e3.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, t3.style.height = (e3.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", t3.style.top = (e3.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", t3.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
          const i4 = e3.options.x ?? 0;
          return i4 && i4 > this._bufferService.cols && (t3.style.display = "none"), this._refreshXPosition(e3, t3), t3;
        }
        _refreshStyle(e3) {
          const t3 = e3.marker.line - this._bufferService.buffers.active.ydisp;
          if (t3 < 0 || t3 >= this._bufferService.rows) e3.element && (e3.element.style.display = "none", e3.onRenderEmitter.fire(e3.element));
          else {
            let i4 = this._decorationElements.get(e3);
            i4 || (i4 = this._createElement(e3), e3.element = i4, this._decorationElements.set(e3, i4), this._container.appendChild(i4), e3.onDispose(() => {
              this._decorationElements.delete(e3), i4.remove();
            })), i4.style.top = t3 * this._renderService.dimensions.css.cell.height + "px", i4.style.display = this._altBufferIsActive ? "none" : "block", e3.onRenderEmitter.fire(i4);
          }
        }
        _refreshXPosition(e3, t3 = e3.element) {
          if (!t3) return;
          const i4 = e3.options.x ?? 0;
          "right" === (e3.options.anchor || "left") ? t3.style.right = i4 ? i4 * this._renderService.dimensions.css.cell.width + "px" : "" : t3.style.left = i4 ? i4 * this._renderService.dimensions.css.cell.width + "px" : "";
        }
        _removeDecoration(e3) {
          this._decorationElements.get(e3)?.remove(), this._decorationElements.delete(e3), e3.dispose();
        }
      };
      t2.BufferDecorationRenderer = h2 = s2([r(1, a.IBufferService), r(2, n.ICoreBrowserService), r(3, a.IDecorationService), r(4, n.IRenderService)], h2);
    }, 5871: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorZoneStore = void 0, t2.ColorZoneStore = class {
        constructor() {
          this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
        }
        get zones() {
          return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
        }
        clear() {
          this._zones.length = 0, this._zonePoolIndex = 0;
        }
        addDecoration(e3) {
          if (e3.options.overviewRulerOptions) {
            for (const t3 of this._zones) if (t3.color === e3.options.overviewRulerOptions.color && t3.position === e3.options.overviewRulerOptions.position) {
              if (this._lineIntersectsZone(t3, e3.marker.line)) return;
              if (this._lineAdjacentToZone(t3, e3.marker.line, e3.options.overviewRulerOptions.position)) return void this._addLineToZone(t3, e3.marker.line);
            }
            if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = e3.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e3.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e3.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e3.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
            this._zones.push({ color: e3.options.overviewRulerOptions.color, position: e3.options.overviewRulerOptions.position, startBufferLine: e3.marker.line, endBufferLine: e3.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
          }
        }
        setPadding(e3) {
          this._linePadding = e3;
        }
        _lineIntersectsZone(e3, t3) {
          return t3 >= e3.startBufferLine && t3 <= e3.endBufferLine;
        }
        _lineAdjacentToZone(e3, t3, i3) {
          return t3 >= e3.startBufferLine - this._linePadding[i3 || "full"] && t3 <= e3.endBufferLine + this._linePadding[i3 || "full"];
        }
        _addLineToZone(e3, t3) {
          e3.startBufferLine = Math.min(e3.startBufferLine, t3), e3.endBufferLine = Math.max(e3.endBufferLine, t3);
        }
      };
    }, 5744: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OverviewRulerRenderer = void 0;
      const n = i3(5871), o = i3(4725), a = i3(844), h2 = i3(2585), c = { full: 0, left: 0, center: 0, right: 0 }, l = { full: 0, left: 0, center: 0, right: 0 }, d = { full: 0, left: 0, center: 0, right: 0 };
      let _2 = t2.OverviewRulerRenderer = class extends a.Disposable {
        get _width() {
          return this._optionsService.options.overviewRulerWidth || 0;
        }
        constructor(e3, t3, i4, s3, r2, o2, h3) {
          super(), this._viewportElement = e3, this._screenElement = t3, this._bufferService = i4, this._decorationService = s3, this._renderService = r2, this._optionsService = o2, this._coreBrowserService = h3, this._colorZoneStore = new n.ColorZoneStore(), this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = this._coreBrowserService.mainDocument.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), this._viewportElement.parentElement?.insertBefore(this._canvas, this._viewportElement);
          const c2 = this._canvas.getContext("2d");
          if (!c2) throw new Error("Ctx cannot be null");
          this._ctx = c2, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, a.toDisposable)(() => {
            this._canvas?.remove();
          }));
        }
        _registerDecorationListeners() {
          this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, true))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, true)));
        }
        _registerBufferChangeListeners() {
          this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
          })), this.register(this._bufferService.onScroll(() => {
            this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
          }));
        }
        _registerDimensionChangeListeners() {
          this.register(this._renderService.onRender(() => {
            this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
          })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(true))), this.register(this._coreBrowserService.onDprChange(() => this._queueRefresh(true))), this._queueRefresh(true);
        }
        _refreshDrawConstants() {
          const e3 = Math.floor(this._canvas.width / 3), t3 = Math.ceil(this._canvas.width / 3);
          l.full = this._canvas.width, l.left = e3, l.center = t3, l.right = e3, this._refreshDrawHeightConstants(), d.full = 0, d.left = 0, d.center = l.left, d.right = l.left + l.center;
        }
        _refreshDrawHeightConstants() {
          c.full = Math.round(2 * this._coreBrowserService.dpr);
          const e3 = this._canvas.height / this._bufferService.buffer.lines.length, t3 = Math.round(Math.max(Math.min(e3, 12), 6) * this._coreBrowserService.dpr);
          c.left = t3, c.center = t3, c.right = t3;
        }
        _refreshColorZonePadding() {
          this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
        }
        _refreshCanvasDimensions() {
          this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowserService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowserService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
        }
        _refreshDecorations() {
          this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
          for (const e4 of this._decorationService.decorations) this._colorZoneStore.addDecoration(e4);
          this._ctx.lineWidth = 1;
          const e3 = this._colorZoneStore.zones;
          for (const t3 of e3) "full" !== t3.position && this._renderColorZone(t3);
          for (const t3 of e3) "full" === t3.position && this._renderColorZone(t3);
          this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
        }
        _renderColorZone(e3) {
          this._ctx.fillStyle = e3.color, this._ctx.fillRect(d[e3.position || "full"], Math.round((this._canvas.height - 1) * (e3.startBufferLine / this._bufferService.buffers.active.lines.length) - c[e3.position || "full"] / 2), l[e3.position || "full"], Math.round((this._canvas.height - 1) * ((e3.endBufferLine - e3.startBufferLine) / this._bufferService.buffers.active.lines.length) + c[e3.position || "full"]));
        }
        _queueRefresh(e3, t3) {
          this._shouldUpdateDimensions = e3 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t3 || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
            this._refreshDecorations(), this._animationFrame = void 0;
          }));
        }
      };
      t2.OverviewRulerRenderer = _2 = s2([r(2, h2.IBufferService), r(3, h2.IDecorationService), r(4, o.IRenderService), r(5, h2.IOptionsService), r(6, o.ICoreBrowserService)], _2);
    }, 2950: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CompositionHelper = void 0;
      const n = i3(4725), o = i3(2585), a = i3(2584);
      let h2 = t2.CompositionHelper = class {
        get isComposing() {
          return this._isComposing;
        }
        constructor(e3, t3, i4, s3, r2, n2) {
          this._textarea = e3, this._compositionView = t3, this._bufferService = i4, this._optionsService = s3, this._coreService = r2, this._renderService = n2, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
        }
        compositionstart() {
          this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
        }
        compositionupdate(e3) {
          this._compositionView.textContent = e3.data, this.updateCompositionElements(), setTimeout(() => {
            this._compositionPosition.end = this._textarea.value.length;
          }, 0);
        }
        compositionend() {
          this._finalizeComposition(true);
        }
        keydown(e3) {
          if (this._isComposing || this._isSendingComposition) {
            if (229 === e3.keyCode) return false;
            if (16 === e3.keyCode || 17 === e3.keyCode || 18 === e3.keyCode) return false;
            this._finalizeComposition(false);
          }
          return 229 !== e3.keyCode || (this._handleAnyTextareaChanges(), false);
        }
        _finalizeComposition(e3) {
          if (this._compositionView.classList.remove("active"), this._isComposing = false, e3) {
            const e4 = { start: this._compositionPosition.start, end: this._compositionPosition.end };
            this._isSendingComposition = true, setTimeout(() => {
              if (this._isSendingComposition) {
                let t3;
                this._isSendingComposition = false, e4.start += this._dataAlreadySent.length, t3 = this._isComposing ? this._textarea.value.substring(e4.start, e4.end) : this._textarea.value.substring(e4.start), t3.length > 0 && this._coreService.triggerDataEvent(t3, true);
              }
            }, 0);
          } else {
            this._isSendingComposition = false;
            const e4 = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
            this._coreService.triggerDataEvent(e4, true);
          }
        }
        _handleAnyTextareaChanges() {
          const e3 = this._textarea.value;
          setTimeout(() => {
            if (!this._isComposing) {
              const t3 = this._textarea.value, i4 = t3.replace(e3, "");
              this._dataAlreadySent = i4, t3.length > e3.length ? this._coreService.triggerDataEvent(i4, true) : t3.length < e3.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, true) : t3.length === e3.length && t3 !== e3 && this._coreService.triggerDataEvent(t3, true);
            }
          }, 0);
        }
        updateCompositionElements(e3) {
          if (this._isComposing) {
            if (this._bufferService.buffer.isCursorInViewport) {
              const e4 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t3 = this._renderService.dimensions.css.cell.height, i4 = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s3 = e4 * this._renderService.dimensions.css.cell.width;
              this._compositionView.style.left = s3 + "px", this._compositionView.style.top = i4 + "px", this._compositionView.style.height = t3 + "px", this._compositionView.style.lineHeight = t3 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
              const r2 = this._compositionView.getBoundingClientRect();
              this._textarea.style.left = s3 + "px", this._textarea.style.top = i4 + "px", this._textarea.style.width = Math.max(r2.width, 1) + "px", this._textarea.style.height = Math.max(r2.height, 1) + "px", this._textarea.style.lineHeight = r2.height + "px";
            }
            e3 || setTimeout(() => this.updateCompositionElements(true), 0);
          }
        }
      };
      t2.CompositionHelper = h2 = s2([r(2, o.IBufferService), r(3, o.IOptionsService), r(4, o.ICoreService), r(5, n.IRenderService)], h2);
    }, 9806: (e2, t2) => {
      function i3(e3, t3, i4) {
        const s2 = i4.getBoundingClientRect(), r = e3.getComputedStyle(i4), n = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
        return [t3.clientX - s2.left - n, t3.clientY - s2.top - o];
      }
      __name(i3, "i");
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getCoords = t2.getCoordsRelativeToElement = void 0, t2.getCoordsRelativeToElement = i3, t2.getCoords = function(e3, t3, s2, r, n, o, a, h2, c) {
        if (!o) return;
        const l = i3(e3, t3, s2);
        return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h2), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : void 0;
      };
    }, 9504: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.moveToCellSequence = void 0;
      const s2 = i3(2584);
      function r(e3, t3, i4, s3) {
        const r2 = e3 - n(e3, i4), a2 = t3 - n(t3, i4), l = Math.abs(r2 - a2) - function(e4, t4, i5) {
          let s4 = 0;
          const r3 = e4 - n(e4, i5), a3 = t4 - n(t4, i5);
          for (let n2 = 0; n2 < Math.abs(r3 - a3); n2++) {
            const a4 = "A" === o(e4, t4) ? -1 : 1, h3 = i5.buffer.lines.get(r3 + a4 * n2);
            h3?.isWrapped && s4++;
          }
          return s4;
        }(e3, t3, i4);
        return c(l, h2(o(e3, t3), s3));
      }
      __name(r, "r");
      function n(e3, t3) {
        let i4 = 0, s3 = t3.buffer.lines.get(e3), r2 = s3?.isWrapped;
        for (; r2 && e3 >= 0 && e3 < t3.rows; ) i4++, s3 = t3.buffer.lines.get(--e3), r2 = s3?.isWrapped;
        return i4;
      }
      __name(n, "n");
      function o(e3, t3) {
        return e3 > t3 ? "A" : "B";
      }
      __name(o, "o");
      function a(e3, t3, i4, s3, r2, n2) {
        let o2 = e3, a2 = t3, h3 = "";
        for (; o2 !== i4 || a2 !== s3; ) o2 += r2 ? 1 : -1, r2 && o2 > n2.cols - 1 ? (h3 += n2.buffer.translateBufferLineToString(a2, false, e3, o2), o2 = 0, e3 = 0, a2++) : !r2 && o2 < 0 && (h3 += n2.buffer.translateBufferLineToString(a2, false, 0, e3 + 1), o2 = n2.cols - 1, e3 = o2, a2--);
        return h3 + n2.buffer.translateBufferLineToString(a2, false, e3, o2);
      }
      __name(a, "a");
      function h2(e3, t3) {
        const i4 = t3 ? "O" : "[";
        return s2.C0.ESC + i4 + e3;
      }
      __name(h2, "h");
      function c(e3, t3) {
        e3 = Math.floor(e3);
        let i4 = "";
        for (let s3 = 0; s3 < e3; s3++) i4 += t3;
        return i4;
      }
      __name(c, "c");
      t2.moveToCellSequence = function(e3, t3, i4, s3) {
        const o2 = i4.buffer.x, l = i4.buffer.y;
        if (!i4.buffer.hasScrollback) return function(e4, t4, i5, s4, o3, l2) {
          return 0 === r(t4, s4, o3, l2).length ? "" : c(a(e4, t4, e4, t4 - n(t4, o3), false, o3).length, h2("D", l2));
        }(o2, l, 0, t3, i4, s3) + r(l, t3, i4, s3) + function(e4, t4, i5, s4, o3, l2) {
          let d2;
          d2 = r(t4, s4, o3, l2).length > 0 ? s4 - n(s4, o3) : t4;
          const _3 = s4, u = function(e5, t5, i6, s5, o4, a2) {
            let h3;
            return h3 = r(i6, s5, o4, a2).length > 0 ? s5 - n(s5, o4) : t5, e5 < i6 && h3 <= s5 || e5 >= i6 && h3 < s5 ? "C" : "D";
          }(e4, t4, i5, s4, o3, l2);
          return c(a(e4, d2, i5, _3, "C" === u, o3).length, h2(u, l2));
        }(o2, l, e3, t3, i4, s3);
        let d;
        if (l === t3) return d = o2 > e3 ? "D" : "C", c(Math.abs(o2 - e3), h2(d, s3));
        d = l > t3 ? "D" : "C";
        const _2 = Math.abs(l - t3);
        return c(function(e4, t4) {
          return t4.cols - e4;
        }(l > t3 ? e3 : o2, i4) + (_2 - 1) * i4.cols + 1 + ((l > t3 ? o2 : e3) - 1), h2(d, s3));
      };
    }, 1296: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRenderer = void 0;
      const n = i3(3787), o = i3(2550), a = i3(2223), h2 = i3(6171), c = i3(6052), l = i3(4725), d = i3(8055), _2 = i3(8460), u = i3(844), f = i3(2585), v2 = "xterm-dom-renderer-owner-", p2 = "xterm-rows", g = "xterm-fg-", m = "xterm-bg-", S = "xterm-focus", C = "xterm-selection";
      let b = 1, w2 = t2.DomRenderer = class extends u.Disposable {
        constructor(e3, t3, i4, s3, r2, a2, l2, d2, f2, g2, m2, S2, w3) {
          super(), this._terminal = e3, this._document = t3, this._element = i4, this._screenElement = s3, this._viewportElement = r2, this._helperContainer = a2, this._linkifier2 = l2, this._charSizeService = f2, this._optionsService = g2, this._bufferService = m2, this._coreBrowserService = S2, this._themeService = w3, this._terminalClass = b++, this._rowElements = [], this._selectionRenderModel = (0, c.createSelectionRenderModel)(), this.onRequestRedraw = this.register(new _2.EventEmitter()).event, this._rowContainer = this._document.createElement("div"), this._rowContainer.classList.add(p2), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = this._document.createElement("div"), this._selectionContainer.classList.add(C), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, h2.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((e4) => this._injectCss(e4))), this._injectCss(this._themeService.colors), this._rowFactory = d2.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(v2 + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((e4) => this._handleLinkHover(e4))), this.register(this._linkifier2.onHideLinkUnderline((e4) => this._handleLinkLeave(e4))), this.register((0, u.toDisposable)(() => {
            this._element.classList.remove(v2 + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
          })), this._widthCache = new o.WidthCache(this._document, this._helperContainer), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        _updateDimensions() {
          const e3 = this._coreBrowserService.dpr;
          this.dimensions.device.char.width = this._charSizeService.width * e3, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e3), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e3), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e3), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
          for (const e4 of this._rowElements) e4.style.width = `${this.dimensions.css.canvas.width}px`, e4.style.height = `${this.dimensions.css.cell.height}px`, e4.style.lineHeight = `${this.dimensions.css.cell.height}px`, e4.style.overflow = "hidden";
          this._dimensionsStyleElement || (this._dimensionsStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
          const t3 = `${this._terminalSelector} .${p2} span { display: inline-block; height: 100%; vertical-align: top;}`;
          this._dimensionsStyleElement.textContent = t3, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
        }
        _injectCss(e3) {
          this._themeStyleElement || (this._themeStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
          let t3 = `${this._terminalSelector} .${p2} { color: ${e3.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
          t3 += `${this._terminalSelector} .${p2} .xterm-dim { color: ${d.color.multiplyOpacity(e3.foreground, 0.5).css};}`, t3 += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`;
          const i4 = `blink_underline_${this._terminalClass}`, s3 = `blink_bar_${this._terminalClass}`, r2 = `blink_block_${this._terminalClass}`;
          t3 += `@keyframes ${i4} { 50% {  border-bottom-style: hidden; }}`, t3 += `@keyframes ${s3} { 50% {  box-shadow: none; }}`, t3 += `@keyframes ${r2} { 0% {  background-color: ${e3.cursor.css};  color: ${e3.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${e3.cursor.css}; }}`, t3 += `${this._terminalSelector} .${p2}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-underline { animation: ${i4} 1s step-end infinite;}${this._terminalSelector} .${p2}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-bar { animation: ${s3} 1s step-end infinite;}${this._terminalSelector} .${p2}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: ${r2} 1s step-end infinite;}${this._terminalSelector} .${p2} .xterm-cursor.xterm-cursor-block { background-color: ${e3.cursor.css}; color: ${e3.cursorAccent.css};}${this._terminalSelector} .${p2} .xterm-cursor.xterm-cursor-block:not(.xterm-cursor-blink) { background-color: ${e3.cursor.css} !important; color: ${e3.cursorAccent.css} !important;}${this._terminalSelector} .${p2} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${e3.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${p2} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e3.cursor.css} inset;}${this._terminalSelector} .${p2} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${e3.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, t3 += `${this._terminalSelector} .${C} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${C} div { position: absolute; background-color: ${e3.selectionBackgroundOpaque.css};}${this._terminalSelector} .${C} div { position: absolute; background-color: ${e3.selectionInactiveBackgroundOpaque.css};}`;
          for (const [i5, s4] of e3.ansi.entries()) t3 += `${this._terminalSelector} .${g}${i5} { color: ${s4.css}; }${this._terminalSelector} .${g}${i5}.xterm-dim { color: ${d.color.multiplyOpacity(s4, 0.5).css}; }${this._terminalSelector} .${m}${i5} { background-color: ${s4.css}; }`;
          t3 += `${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR} { color: ${d.color.opaque(e3.background).css}; }${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${d.color.multiplyOpacity(d.color.opaque(e3.background), 0.5).css}; }${this._terminalSelector} .${m}${a.INVERTED_DEFAULT_COLOR} { background-color: ${e3.foreground.css}; }`, this._themeStyleElement.textContent = t3;
        }
        _setDefaultSpacing() {
          const e3 = this.dimensions.css.cell.width - this._widthCache.get("W", false, false);
          this._rowContainer.style.letterSpacing = `${e3}px`, this._rowFactory.defaultSpacing = e3;
        }
        handleDevicePixelRatioChange() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        _refreshRowElements(e3, t3) {
          for (let e4 = this._rowElements.length; e4 <= t3; e4++) {
            const e5 = this._document.createElement("div");
            this._rowContainer.appendChild(e5), this._rowElements.push(e5);
          }
          for (; this._rowElements.length > t3; ) this._rowContainer.removeChild(this._rowElements.pop());
        }
        handleResize(e3, t3) {
          this._refreshRowElements(e3, t3), this._updateDimensions(), this.handleSelectionChanged(this._selectionRenderModel.selectionStart, this._selectionRenderModel.selectionEnd, this._selectionRenderModel.columnSelectMode);
        }
        handleCharSizeChanged() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        handleBlur() {
          this._rowContainer.classList.remove(S), this.renderRows(0, this._bufferService.rows - 1);
        }
        handleFocus() {
          this._rowContainer.classList.add(S), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
        }
        handleSelectionChanged(e3, t3, i4) {
          if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(e3, t3, i4), this.renderRows(0, this._bufferService.rows - 1), !e3 || !t3) return;
          this._selectionRenderModel.update(this._terminal, e3, t3, i4);
          const s3 = this._selectionRenderModel.viewportStartRow, r2 = this._selectionRenderModel.viewportEndRow, n2 = this._selectionRenderModel.viewportCappedStartRow, o2 = this._selectionRenderModel.viewportCappedEndRow;
          if (n2 >= this._bufferService.rows || o2 < 0) return;
          const a2 = this._document.createDocumentFragment();
          if (i4) {
            const i5 = e3[0] > t3[0];
            a2.appendChild(this._createSelectionElement(n2, i5 ? t3[0] : e3[0], i5 ? e3[0] : t3[0], o2 - n2 + 1));
          } else {
            const i5 = s3 === n2 ? e3[0] : 0, h3 = n2 === r2 ? t3[0] : this._bufferService.cols;
            a2.appendChild(this._createSelectionElement(n2, i5, h3));
            const c2 = o2 - n2 - 1;
            if (a2.appendChild(this._createSelectionElement(n2 + 1, 0, this._bufferService.cols, c2)), n2 !== o2) {
              const e4 = r2 === o2 ? t3[0] : this._bufferService.cols;
              a2.appendChild(this._createSelectionElement(o2, 0, e4));
            }
          }
          this._selectionContainer.appendChild(a2);
        }
        _createSelectionElement(e3, t3, i4, s3 = 1) {
          const r2 = this._document.createElement("div"), n2 = t3 * this.dimensions.css.cell.width;
          let o2 = this.dimensions.css.cell.width * (i4 - t3);
          return n2 + o2 > this.dimensions.css.canvas.width && (o2 = this.dimensions.css.canvas.width - n2), r2.style.height = s3 * this.dimensions.css.cell.height + "px", r2.style.top = e3 * this.dimensions.css.cell.height + "px", r2.style.left = `${n2}px`, r2.style.width = `${o2}px`, r2;
        }
        handleCursorMove() {
        }
        _handleOptionsChanged() {
          this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        clear() {
          for (const e3 of this._rowElements) e3.replaceChildren();
        }
        renderRows(e3, t3) {
          const i4 = this._bufferService.buffer, s3 = i4.ybase + i4.y, r2 = Math.min(i4.x, this._bufferService.cols - 1), n2 = this._optionsService.rawOptions.cursorBlink, o2 = this._optionsService.rawOptions.cursorStyle, a2 = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let h3 = e3; h3 <= t3; h3++) {
            const e4 = h3 + i4.ydisp, t4 = this._rowElements[h3], c2 = i4.lines.get(e4);
            if (!t4 || !c2) break;
            t4.replaceChildren(...this._rowFactory.createRow(c2, e4, e4 === s3, o2, a2, r2, n2, this.dimensions.css.cell.width, this._widthCache, -1, -1));
          }
        }
        get _terminalSelector() {
          return `.${v2}${this._terminalClass}`;
        }
        _handleLinkHover(e3) {
          this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, true);
        }
        _handleLinkLeave(e3) {
          this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, false);
        }
        _setCellUnderline(e3, t3, i4, s3, r2, n2) {
          i4 < 0 && (e3 = 0), s3 < 0 && (t3 = 0);
          const o2 = this._bufferService.rows - 1;
          i4 = Math.max(Math.min(i4, o2), 0), s3 = Math.max(Math.min(s3, o2), 0), r2 = Math.min(r2, this._bufferService.cols);
          const a2 = this._bufferService.buffer, h3 = a2.ybase + a2.y, c2 = Math.min(a2.x, r2 - 1), l2 = this._optionsService.rawOptions.cursorBlink, d2 = this._optionsService.rawOptions.cursorStyle, _3 = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let o3 = i4; o3 <= s3; ++o3) {
            const u2 = o3 + a2.ydisp, f2 = this._rowElements[o3], v3 = a2.lines.get(u2);
            if (!f2 || !v3) break;
            f2.replaceChildren(...this._rowFactory.createRow(v3, u2, u2 === h3, d2, _3, c2, l2, this.dimensions.css.cell.width, this._widthCache, n2 ? o3 === i4 ? e3 : 0 : -1, n2 ? (o3 === s3 ? t3 : r2) - 1 : -1));
          }
        }
      };
      t2.DomRenderer = w2 = s2([r(7, f.IInstantiationService), r(8, l.ICharSizeService), r(9, f.IOptionsService), r(10, f.IBufferService), r(11, l.ICoreBrowserService), r(12, l.IThemeService)], w2);
    }, 3787: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRendererRowFactory = void 0;
      const n = i3(2223), o = i3(643), a = i3(511), h2 = i3(2585), c = i3(8055), l = i3(4725), d = i3(4269), _2 = i3(6171), u = i3(3734);
      let f = t2.DomRendererRowFactory = class {
        constructor(e3, t3, i4, s3, r2, n2, o2) {
          this._document = e3, this._characterJoinerService = t3, this._optionsService = i4, this._coreBrowserService = s3, this._coreService = r2, this._decorationService = n2, this._themeService = o2, this._workCell = new a.CellData(), this._columnSelectMode = false, this.defaultSpacing = 0;
        }
        handleSelectionChanged(e3, t3, i4) {
          this._selectionStart = e3, this._selectionEnd = t3, this._columnSelectMode = i4;
        }
        createRow(e3, t3, i4, s3, r2, a2, h3, l2, _3, f2, p2) {
          const g = [], m = this._characterJoinerService.getJoinedCharacters(t3), S = this._themeService.colors;
          let C, b = e3.getNoBgTrimmedLength();
          i4 && b < a2 + 1 && (b = a2 + 1);
          let w2 = 0, y2 = "", E = 0, k = 0, L = 0, D = false, R = 0, x2 = false, A = 0;
          const B = [], T = -1 !== f2 && -1 !== p2;
          for (let M = 0; M < b; M++) {
            e3.loadCell(M, this._workCell);
            let b2 = this._workCell.getWidth();
            if (0 === b2) continue;
            let O = false, P = M, I = this._workCell;
            if (m.length > 0 && M === m[0][0]) {
              O = true;
              const t4 = m.shift();
              I = new d.JoinedCellData(this._workCell, e3.translateToString(true, t4[0], t4[1]), t4[1] - t4[0]), P = t4[1] - 1, b2 = I.getWidth();
            }
            const H = this._isCellInSelection(M, t3), F = i4 && M === a2, W = T && M >= f2 && M <= p2;
            let U = false;
            this._decorationService.forEachDecorationAtCell(M, t3, void 0, (e4) => {
              U = true;
            });
            let N = I.getChars() || o.WHITESPACE_CELL_CHAR;
            if (" " === N && (I.isUnderline() || I.isOverline()) && (N = ""), A = b2 * l2 - _3.get(N, I.isBold(), I.isItalic()), C) {
              if (w2 && (H && x2 || !H && !x2 && I.bg === E) && (H && x2 && S.selectionForeground || I.fg === k) && I.extended.ext === L && W === D && A === R && !F && !O && !U) {
                I.isInvisible() ? y2 += o.WHITESPACE_CELL_CHAR : y2 += N, w2++;
                continue;
              }
              w2 && (C.textContent = y2), C = this._document.createElement("span"), w2 = 0, y2 = "";
            } else C = this._document.createElement("span");
            if (E = I.bg, k = I.fg, L = I.extended.ext, D = W, R = A, x2 = H, O && a2 >= M && a2 <= P && (a2 = M), !this._coreService.isCursorHidden && F && this._coreService.isCursorInitialized) {
              if (B.push("xterm-cursor"), this._coreBrowserService.isFocused) h3 && B.push("xterm-cursor-blink"), B.push("bar" === s3 ? "xterm-cursor-bar" : "underline" === s3 ? "xterm-cursor-underline" : "xterm-cursor-block");
              else if (r2) switch (r2) {
                case "outline":
                  B.push("xterm-cursor-outline");
                  break;
                case "block":
                  B.push("xterm-cursor-block");
                  break;
                case "bar":
                  B.push("xterm-cursor-bar");
                  break;
                case "underline":
                  B.push("xterm-cursor-underline");
              }
            }
            if (I.isBold() && B.push("xterm-bold"), I.isItalic() && B.push("xterm-italic"), I.isDim() && B.push("xterm-dim"), y2 = I.isInvisible() ? o.WHITESPACE_CELL_CHAR : I.getChars() || o.WHITESPACE_CELL_CHAR, I.isUnderline() && (B.push(`xterm-underline-${I.extended.underlineStyle}`), " " === y2 && (y2 = ""), !I.isUnderlineColorDefault())) if (I.isUnderlineColorRGB()) C.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(I.getUnderlineColor()).join(",")})`;
            else {
              let e4 = I.getUnderlineColor();
              this._optionsService.rawOptions.drawBoldTextInBrightColors && I.isBold() && e4 < 8 && (e4 += 8), C.style.textDecorationColor = S.ansi[e4].css;
            }
            I.isOverline() && (B.push("xterm-overline"), " " === y2 && (y2 = "")), I.isStrikethrough() && B.push("xterm-strikethrough"), W && (C.style.textDecoration = "underline");
            let $ = I.getFgColor(), j = I.getFgColorMode(), z2 = I.getBgColor(), K = I.getBgColorMode();
            const q = !!I.isInverse();
            if (q) {
              const e4 = $;
              $ = z2, z2 = e4;
              const t4 = j;
              j = K, K = t4;
            }
            let V, G, X, J = false;
            switch (this._decorationService.forEachDecorationAtCell(M, t3, void 0, (e4) => {
              "top" !== e4.options.layer && J || (e4.backgroundColorRGB && (K = 50331648, z2 = e4.backgroundColorRGB.rgba >> 8 & 16777215, V = e4.backgroundColorRGB), e4.foregroundColorRGB && (j = 50331648, $ = e4.foregroundColorRGB.rgba >> 8 & 16777215, G = e4.foregroundColorRGB), J = "top" === e4.options.layer);
            }), !J && H && (V = this._coreBrowserService.isFocused ? S.selectionBackgroundOpaque : S.selectionInactiveBackgroundOpaque, z2 = V.rgba >> 8 & 16777215, K = 50331648, J = true, S.selectionForeground && (j = 50331648, $ = S.selectionForeground.rgba >> 8 & 16777215, G = S.selectionForeground)), J && B.push("xterm-decoration-top"), K) {
              case 16777216:
              case 33554432:
                X = S.ansi[z2], B.push(`xterm-bg-${z2}`);
                break;
              case 50331648:
                X = c.channels.toColor(z2 >> 16, z2 >> 8 & 255, 255 & z2), this._addStyle(C, `background-color:#${v2((z2 >>> 0).toString(16), "0", 6)}`);
                break;
              default:
                q ? (X = S.foreground, B.push(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : X = S.background;
            }
            switch (V || I.isDim() && (V = c.color.multiplyOpacity(X, 0.5)), j) {
              case 16777216:
              case 33554432:
                I.isBold() && $ < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && ($ += 8), this._applyMinimumContrast(C, X, S.ansi[$], I, V, void 0) || B.push(`xterm-fg-${$}`);
                break;
              case 50331648:
                const e4 = c.channels.toColor($ >> 16 & 255, $ >> 8 & 255, 255 & $);
                this._applyMinimumContrast(C, X, e4, I, V, G) || this._addStyle(C, `color:#${v2($.toString(16), "0", 6)}`);
                break;
              default:
                this._applyMinimumContrast(C, X, S.foreground, I, V, G) || q && B.push(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);
            }
            B.length && (C.className = B.join(" "), B.length = 0), F || O || U ? C.textContent = y2 : w2++, A !== this.defaultSpacing && (C.style.letterSpacing = `${A}px`), g.push(C), M = P;
          }
          return C && w2 && (C.textContent = y2), g;
        }
        _applyMinimumContrast(e3, t3, i4, s3, r2, n2) {
          if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _2.treatGlyphAsBackgroundColor)(s3.getCode())) return false;
          const o2 = this._getContrastCache(s3);
          let a2;
          if (r2 || n2 || (a2 = o2.getColor(t3.rgba, i4.rgba)), void 0 === a2) {
            const e4 = this._optionsService.rawOptions.minimumContrastRatio / (s3.isDim() ? 2 : 1);
            a2 = c.color.ensureContrastRatio(r2 || t3, n2 || i4, e4), o2.setColor((r2 || t3).rgba, (n2 || i4).rgba, a2 ?? null);
          }
          return !!a2 && (this._addStyle(e3, `color:${a2.css}`), true);
        }
        _getContrastCache(e3) {
          return e3.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
        }
        _addStyle(e3, t3) {
          e3.setAttribute("style", `${e3.getAttribute("style") || ""}${t3};`);
        }
        _isCellInSelection(e3, t3) {
          const i4 = this._selectionStart, s3 = this._selectionEnd;
          return !(!i4 || !s3) && (this._columnSelectMode ? i4[0] <= s3[0] ? e3 >= i4[0] && t3 >= i4[1] && e3 < s3[0] && t3 <= s3[1] : e3 < i4[0] && t3 >= i4[1] && e3 >= s3[0] && t3 <= s3[1] : t3 > i4[1] && t3 < s3[1] || i4[1] === s3[1] && t3 === i4[1] && e3 >= i4[0] && e3 < s3[0] || i4[1] < s3[1] && t3 === s3[1] && e3 < s3[0] || i4[1] < s3[1] && t3 === i4[1] && e3 >= i4[0]);
        }
      };
      function v2(e3, t3, i4) {
        for (; e3.length < i4; ) e3 = t3 + e3;
        return e3;
      }
      __name(v2, "v");
      t2.DomRendererRowFactory = f = s2([r(1, l.ICharacterJoinerService), r(2, h2.IOptionsService), r(3, l.ICoreBrowserService), r(4, h2.ICoreService), r(5, h2.IDecorationService), r(6, l.IThemeService)], f);
    }, 2550: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WidthCache = void 0, t2.WidthCache = class {
        constructor(e3, t3) {
          this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = e3.createElement("div"), this._container.classList.add("xterm-width-cache-measure-container"), this._container.setAttribute("aria-hidden", "true"), this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
          const i3 = e3.createElement("span");
          i3.classList.add("xterm-char-measure-element");
          const s2 = e3.createElement("span");
          s2.classList.add("xterm-char-measure-element"), s2.style.fontWeight = "bold";
          const r = e3.createElement("span");
          r.classList.add("xterm-char-measure-element"), r.style.fontStyle = "italic";
          const n = e3.createElement("span");
          n.classList.add("xterm-char-measure-element"), n.style.fontWeight = "bold", n.style.fontStyle = "italic", this._measureElements = [i3, s2, r, n], this._container.appendChild(i3), this._container.appendChild(s2), this._container.appendChild(r), this._container.appendChild(n), t3.appendChild(this._container), this.clear();
        }
        dispose() {
          this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
        }
        clear() {
          this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
        }
        setFont(e3, t3, i3, s2) {
          e3 === this._font && t3 === this._fontSize && i3 === this._weight && s2 === this._weightBold || (this._font = e3, this._fontSize = t3, this._weight = i3, this._weightBold = s2, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${i3}`, this._measureElements[1].style.fontWeight = `${s2}`, this._measureElements[2].style.fontWeight = `${i3}`, this._measureElements[3].style.fontWeight = `${s2}`, this.clear());
        }
        get(e3, t3, i3) {
          let s2 = 0;
          if (!t3 && !i3 && 1 === e3.length && (s2 = e3.charCodeAt(0)) < 256) {
            if (-9999 !== this._flat[s2]) return this._flat[s2];
            const t4 = this._measure(e3, 0);
            return t4 > 0 && (this._flat[s2] = t4), t4;
          }
          let r = e3;
          t3 && (r += "B"), i3 && (r += "I");
          let n = this._holey.get(r);
          if (void 0 === n) {
            let s3 = 0;
            t3 && (s3 |= 1), i3 && (s3 |= 2), n = this._measure(e3, s3), n > 0 && this._holey.set(r, n);
          }
          return n;
        }
        _measure(e3, t3) {
          const i3 = this._measureElements[t3];
          return i3.textContent = e3.repeat(32), i3.offsetWidth / 32;
        }
      };
    }, 2223: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.TEXT_BASELINE = t2.DIM_OPACITY = t2.INVERTED_DEFAULT_COLOR = void 0;
      const s2 = i3(6114);
      t2.INVERTED_DEFAULT_COLOR = 257, t2.DIM_OPACITY = 0.5, t2.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
    }, 6171: (e2, t2) => {
      function i3(e3) {
        return 57508 <= e3 && e3 <= 57558;
      }
      __name(i3, "i");
      function s2(e3) {
        return e3 >= 128512 && e3 <= 128591 || e3 >= 127744 && e3 <= 128511 || e3 >= 128640 && e3 <= 128767 || e3 >= 9728 && e3 <= 9983 || e3 >= 9984 && e3 <= 10175 || e3 >= 65024 && e3 <= 65039 || e3 >= 129280 && e3 <= 129535 || e3 >= 127462 && e3 <= 127487;
      }
      __name(s2, "s");
      Object.defineProperty(t2, "__esModule", { value: true }), t2.computeNextVariantOffset = t2.createRenderDimensions = t2.treatGlyphAsBackgroundColor = t2.allowRescaling = t2.isEmoji = t2.isRestrictedPowerlineGlyph = t2.isPowerlineGlyph = t2.throwIfFalsy = void 0, t2.throwIfFalsy = function(e3) {
        if (!e3) throw new Error("value must not be falsy");
        return e3;
      }, t2.isPowerlineGlyph = i3, t2.isRestrictedPowerlineGlyph = function(e3) {
        return 57520 <= e3 && e3 <= 57527;
      }, t2.isEmoji = s2, t2.allowRescaling = function(e3, t3, r, n) {
        return 1 === t3 && r > Math.ceil(1.5 * n) && void 0 !== e3 && e3 > 255 && !s2(e3) && !i3(e3) && !function(e4) {
          return 57344 <= e4 && e4 <= 63743;
        }(e3);
      }, t2.treatGlyphAsBackgroundColor = function(e3) {
        return i3(e3) || function(e4) {
          return 9472 <= e4 && e4 <= 9631;
        }(e3);
      }, t2.createRenderDimensions = function() {
        return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
      }, t2.computeNextVariantOffset = function(e3, t3, i4 = 0) {
        return (e3 - (2 * Math.round(t3) - i4)) % (2 * Math.round(t3));
      };
    }, 6052: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createSelectionRenderModel = void 0;
      class i3 {
        static {
          __name(this, "i");
        }
        constructor() {
          this.clear();
        }
        clear() {
          this.hasSelection = false, this.columnSelectMode = false, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0;
        }
        update(e3, t3, i4, s2 = false) {
          if (this.selectionStart = t3, this.selectionEnd = i4, !t3 || !i4 || t3[0] === i4[0] && t3[1] === i4[1]) return void this.clear();
          const r = e3.buffers.active.ydisp, n = t3[1] - r, o = i4[1] - r, a = Math.max(n, 0), h2 = Math.min(o, e3.rows - 1);
          a >= e3.rows || h2 < 0 ? this.clear() : (this.hasSelection = true, this.columnSelectMode = s2, this.viewportStartRow = n, this.viewportEndRow = o, this.viewportCappedStartRow = a, this.viewportCappedEndRow = h2, this.startCol = t3[0], this.endCol = i4[0]);
        }
        isCellSelected(e3, t3, i4) {
          return !!this.hasSelection && (i4 -= e3.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? t3 >= this.startCol && i4 >= this.viewportCappedStartRow && t3 < this.endCol && i4 <= this.viewportCappedEndRow : t3 < this.startCol && i4 >= this.viewportCappedStartRow && t3 >= this.endCol && i4 <= this.viewportCappedEndRow : i4 > this.viewportStartRow && i4 < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && i4 === this.viewportStartRow && t3 >= this.startCol && t3 < this.endCol || this.viewportStartRow < this.viewportEndRow && i4 === this.viewportEndRow && t3 < this.endCol || this.viewportStartRow < this.viewportEndRow && i4 === this.viewportStartRow && t3 >= this.startCol);
        }
      }
      t2.createSelectionRenderModel = function() {
        return new i3();
      };
    }, 456: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionModel = void 0, t2.SelectionModel = class {
        constructor(e3) {
          this._bufferService = e3, this.isSelectAllActive = false, this.selectionStartLength = 0;
        }
        clearSelection() {
          this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = false, this.selectionStartLength = 0;
        }
        get finalSelectionStart() {
          return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
        }
        get finalSelectionEnd() {
          if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
          if (this.selectionStart) {
            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
              const e3 = this.selectionStart[0] + this.selectionStartLength;
              return e3 > this._bufferService.cols ? e3 % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols) - 1] : [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [e3, this.selectionStart[1]];
            }
            if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
              const e3 = this.selectionStart[0] + this.selectionStartLength;
              return e3 > this._bufferService.cols ? [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [Math.max(e3, this.selectionEnd[0]), this.selectionEnd[1]];
            }
            return this.selectionEnd;
          }
        }
        areSelectionValuesReversed() {
          const e3 = this.selectionStart, t3 = this.selectionEnd;
          return !(!e3 || !t3) && (e3[1] > t3[1] || e3[1] === t3[1] && e3[0] > t3[0]);
        }
        handleTrim(e3) {
          return this.selectionStart && (this.selectionStart[1] -= e3), this.selectionEnd && (this.selectionEnd[1] -= e3), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
        }
      };
    }, 428: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CharSizeService = void 0;
      const n = i3(2585), o = i3(8460), a = i3(844);
      let h2 = t2.CharSizeService = class extends a.Disposable {
        get hasValidSize() {
          return this.width > 0 && this.height > 0;
        }
        constructor(e3, t3, i4) {
          super(), this._optionsService = i4, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event;
          try {
            this._measureStrategy = this.register(new d(this._optionsService));
          } catch {
            this._measureStrategy = this.register(new l(e3, t3, this._optionsService));
          }
          this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
        }
        measure() {
          const e3 = this._measureStrategy.measure();
          e3.width === this.width && e3.height === this.height || (this.width = e3.width, this.height = e3.height, this._onCharSizeChange.fire());
        }
      };
      t2.CharSizeService = h2 = s2([r(2, n.IOptionsService)], h2);
      class c extends a.Disposable {
        static {
          __name(this, "c");
        }
        constructor() {
          super(...arguments), this._result = { width: 0, height: 0 };
        }
        _validateAndSet(e3, t3) {
          void 0 !== e3 && e3 > 0 && void 0 !== t3 && t3 > 0 && (this._result.width = e3, this._result.height = t3);
        }
      }
      class l extends c {
        static {
          __name(this, "l");
        }
        constructor(e3, t3, i4) {
          super(), this._document = e3, this._parentElement = t3, this._optionsService = i4, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
        }
        measure() {
          return this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`, this._validateAndSet(Number(this._measureElement.offsetWidth) / 32, Number(this._measureElement.offsetHeight)), this._result;
        }
      }
      class d extends c {
        static {
          __name(this, "d");
        }
        constructor(e3) {
          super(), this._optionsService = e3, this._canvas = new OffscreenCanvas(100, 100), this._ctx = this._canvas.getContext("2d");
          const t3 = this._ctx.measureText("W");
          if (!("width" in t3 && "fontBoundingBoxAscent" in t3 && "fontBoundingBoxDescent" in t3)) throw new Error("Required font metrics not supported");
        }
        measure() {
          this._ctx.font = `${this._optionsService.rawOptions.fontSize}px ${this._optionsService.rawOptions.fontFamily}`;
          const e3 = this._ctx.measureText("W");
          return this._validateAndSet(e3.width, e3.fontBoundingBoxAscent + e3.fontBoundingBoxDescent), this._result;
        }
      }
    }, 4269: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CharacterJoinerService = t2.JoinedCellData = void 0;
      const n = i3(3734), o = i3(643), a = i3(511), h2 = i3(2585);
      class c extends n.AttributeData {
        static {
          __name(this, "c");
        }
        constructor(e3, t3, i4) {
          super(), this.content = 0, this.combinedData = "", this.fg = e3.fg, this.bg = e3.bg, this.combinedData = t3, this._width = i4;
        }
        isCombined() {
          return 2097152;
        }
        getWidth() {
          return this._width;
        }
        getChars() {
          return this.combinedData;
        }
        getCode() {
          return 2097151;
        }
        setFromCharData(e3) {
          throw new Error("not implemented");
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      t2.JoinedCellData = c;
      let l = t2.CharacterJoinerService = class e3 {
        static {
          __name(this, "e");
        }
        constructor(e4) {
          this._bufferService = e4, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();
        }
        register(e4) {
          const t3 = { id: this._nextCharacterJoinerId++, handler: e4 };
          return this._characterJoiners.push(t3), t3.id;
        }
        deregister(e4) {
          for (let t3 = 0; t3 < this._characterJoiners.length; t3++) if (this._characterJoiners[t3].id === e4) return this._characterJoiners.splice(t3, 1), true;
          return false;
        }
        getJoinedCharacters(e4) {
          if (0 === this._characterJoiners.length) return [];
          const t3 = this._bufferService.buffer.lines.get(e4);
          if (!t3 || 0 === t3.length) return [];
          const i4 = [], s3 = t3.translateToString(true);
          let r2 = 0, n2 = 0, a2 = 0, h3 = t3.getFg(0), c2 = t3.getBg(0);
          for (let e5 = 0; e5 < t3.getTrimmedLength(); e5++) if (t3.loadCell(e5, this._workCell), 0 !== this._workCell.getWidth()) {
            if (this._workCell.fg !== h3 || this._workCell.bg !== c2) {
              if (e5 - r2 > 1) {
                const e6 = this._getJoinedRanges(s3, a2, n2, t3, r2);
                for (let t4 = 0; t4 < e6.length; t4++) i4.push(e6[t4]);
              }
              r2 = e5, a2 = n2, h3 = this._workCell.fg, c2 = this._workCell.bg;
            }
            n2 += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
          }
          if (this._bufferService.cols - r2 > 1) {
            const e5 = this._getJoinedRanges(s3, a2, n2, t3, r2);
            for (let t4 = 0; t4 < e5.length; t4++) i4.push(e5[t4]);
          }
          return i4;
        }
        _getJoinedRanges(t3, i4, s3, r2, n2) {
          const o2 = t3.substring(i4, s3);
          let a2 = [];
          try {
            a2 = this._characterJoiners[0].handler(o2);
          } catch (e4) {
            console.error(e4);
          }
          for (let t4 = 1; t4 < this._characterJoiners.length; t4++) try {
            const i5 = this._characterJoiners[t4].handler(o2);
            for (let t5 = 0; t5 < i5.length; t5++) e3._mergeRanges(a2, i5[t5]);
          } catch (e4) {
            console.error(e4);
          }
          return this._stringRangesToCellRanges(a2, r2, n2), a2;
        }
        _stringRangesToCellRanges(e4, t3, i4) {
          let s3 = 0, r2 = false, n2 = 0, a2 = e4[s3];
          if (a2) {
            for (let h3 = i4; h3 < this._bufferService.cols; h3++) {
              const i5 = t3.getWidth(h3), c2 = t3.getString(h3).length || o.WHITESPACE_CELL_CHAR.length;
              if (0 !== i5) {
                if (!r2 && a2[0] <= n2 && (a2[0] = h3, r2 = true), a2[1] <= n2) {
                  if (a2[1] = h3, a2 = e4[++s3], !a2) break;
                  a2[0] <= n2 ? (a2[0] = h3, r2 = true) : r2 = false;
                }
                n2 += c2;
              }
            }
            a2 && (a2[1] = this._bufferService.cols);
          }
        }
        static _mergeRanges(e4, t3) {
          let i4 = false;
          for (let s3 = 0; s3 < e4.length; s3++) {
            const r2 = e4[s3];
            if (i4) {
              if (t3[1] <= r2[0]) return e4[s3 - 1][1] = t3[1], e4;
              if (t3[1] <= r2[1]) return e4[s3 - 1][1] = Math.max(t3[1], r2[1]), e4.splice(s3, 1), e4;
              e4.splice(s3, 1), s3--;
            } else {
              if (t3[1] <= r2[0]) return e4.splice(s3, 0, t3), e4;
              if (t3[1] <= r2[1]) return r2[0] = Math.min(t3[0], r2[0]), e4;
              t3[0] < r2[1] && (r2[0] = Math.min(t3[0], r2[0]), i4 = true);
            }
          }
          return i4 ? e4[e4.length - 1][1] = t3[1] : e4.push(t3), e4;
        }
      };
      t2.CharacterJoinerService = l = s2([r(0, h2.IBufferService)], l);
    }, 5114: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreBrowserService = void 0;
      const s2 = i3(844), r = i3(8460), n = i3(3656);
      class o extends s2.Disposable {
        static {
          __name(this, "o");
        }
        constructor(e3, t3, i4) {
          super(), this._textarea = e3, this._window = t3, this.mainDocument = i4, this._isFocused = false, this._cachedIsFocused = void 0, this._screenDprMonitor = new a(this._window), this._onDprChange = this.register(new r.EventEmitter()), this.onDprChange = this._onDprChange.event, this._onWindowChange = this.register(new r.EventEmitter()), this.onWindowChange = this._onWindowChange.event, this.register(this.onWindowChange((e4) => this._screenDprMonitor.setWindow(e4))), this.register((0, r.forwardEvent)(this._screenDprMonitor.onDprChange, this._onDprChange)), this._textarea.addEventListener("focus", () => this._isFocused = true), this._textarea.addEventListener("blur", () => this._isFocused = false);
        }
        get window() {
          return this._window;
        }
        set window(e3) {
          this._window !== e3 && (this._window = e3, this._onWindowChange.fire(this._window));
        }
        get dpr() {
          return this.window.devicePixelRatio;
        }
        get isFocused() {
          return void 0 === this._cachedIsFocused && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
        }
      }
      t2.CoreBrowserService = o;
      class a extends s2.Disposable {
        static {
          __name(this, "a");
        }
        constructor(e3) {
          super(), this._parentWindow = e3, this._windowResizeListener = this.register(new s2.MutableDisposable()), this._onDprChange = this.register(new r.EventEmitter()), this.onDprChange = this._onDprChange.event, this._outerListener = () => this._setDprAndFireIfDiffers(), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._updateDpr(), this._setWindowResizeListener(), this.register((0, s2.toDisposable)(() => this.clearListener()));
        }
        setWindow(e3) {
          this._parentWindow = e3, this._setWindowResizeListener(), this._setDprAndFireIfDiffers();
        }
        _setWindowResizeListener() {
          this._windowResizeListener.value = (0, n.addDisposableDomListener)(this._parentWindow, "resize", () => this._setDprAndFireIfDiffers());
        }
        _setDprAndFireIfDiffers() {
          this._parentWindow.devicePixelRatio !== this._currentDevicePixelRatio && this._onDprChange.fire(this._parentWindow.devicePixelRatio), this._updateDpr();
        }
        _updateDpr() {
          this._outerListener && (this._resolutionMediaMatchList?.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
        }
        clearListener() {
          this._resolutionMediaMatchList && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._outerListener = void 0);
        }
      }
    }, 779: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.LinkProviderService = void 0;
      const s2 = i3(844);
      class r extends s2.Disposable {
        static {
          __name(this, "r");
        }
        constructor() {
          super(), this.linkProviders = [], this.register((0, s2.toDisposable)(() => this.linkProviders.length = 0));
        }
        registerLinkProvider(e3) {
          return this.linkProviders.push(e3), { dispose: /* @__PURE__ */ __name(() => {
            const t3 = this.linkProviders.indexOf(e3);
            -1 !== t3 && this.linkProviders.splice(t3, 1);
          }, "dispose") };
        }
      }
      t2.LinkProviderService = r;
    }, 8934: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.MouseService = void 0;
      const n = i3(4725), o = i3(9806);
      let a = t2.MouseService = class {
        constructor(e3, t3) {
          this._renderService = e3, this._charSizeService = t3;
        }
        getCoords(e3, t3, i4, s3, r2) {
          return (0, o.getCoords)(window, e3, t3, i4, s3, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r2);
        }
        getMouseReportCoords(e3, t3) {
          const i4 = (0, o.getCoordsRelativeToElement)(window, e3, t3);
          if (this._charSizeService.hasValidSize) return i4[0] = Math.min(Math.max(i4[0], 0), this._renderService.dimensions.css.canvas.width - 1), i4[1] = Math.min(Math.max(i4[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(i4[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(i4[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(i4[0]), y: Math.floor(i4[1]) };
        }
      };
      t2.MouseService = a = s2([r(0, n.IRenderService), r(1, n.ICharSizeService)], a);
    }, 3230: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderService = void 0;
      const n = i3(6193), o = i3(4725), a = i3(8460), h2 = i3(844), c = i3(7226), l = i3(2585);
      let d = t2.RenderService = class extends h2.Disposable {
        get dimensions() {
          return this._renderer.value.dimensions;
        }
        constructor(e3, t3, i4, s3, r2, o2, l2, d2) {
          super(), this._rowCount = e3, this._charSizeService = s3, this._renderer = this.register(new h2.MutableDisposable()), this._pausedResizeTask = new c.DebouncedIdleTask(), this._observerDisposable = this.register(new h2.MutableDisposable()), this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: false }, this._onDimensionsChange = this.register(new a.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new a.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new a.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new a.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new n.RenderDebouncer((e4, t4) => this._renderRows(e4, t4), l2), this.register(this._renderDebouncer), this.register(l2.onDprChange(() => this.handleDevicePixelRatioChange())), this.register(o2.onResize(() => this._fullRefresh())), this.register(o2.buffers.onBufferActivate(() => this._renderer.value?.clear())), this.register(i4.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(r2.onDecorationRegistered(() => this._fullRefresh())), this.register(r2.onDecorationRemoved(() => this._fullRefresh())), this.register(i4.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio", "rescaleOverlappingGlyphs"], () => {
            this.clear(), this.handleResize(o2.cols, o2.rows), this._fullRefresh();
          })), this.register(i4.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(o2.buffer.y, o2.buffer.y, true))), this.register(d2.onChangeColors(() => this._fullRefresh())), this._registerIntersectionObserver(l2.window, t3), this.register(l2.onWindowChange((e4) => this._registerIntersectionObserver(e4, t3)));
        }
        _registerIntersectionObserver(e3, t3) {
          if ("IntersectionObserver" in e3) {
            const i4 = new e3.IntersectionObserver((e4) => this._handleIntersectionChange(e4[e4.length - 1]), { threshold: 0 });
            i4.observe(t3), this._observerDisposable.value = (0, h2.toDisposable)(() => i4.disconnect());
          }
        }
        _handleIntersectionChange(e3) {
          this._isPaused = void 0 === e3.isIntersecting ? 0 === e3.intersectionRatio : !e3.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
        }
        refreshRows(e3, t3, i4 = false) {
          this._isPaused ? this._needsFullRefresh = true : (i4 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(e3, t3, this._rowCount));
        }
        _renderRows(e3, t3) {
          this._renderer.value && (e3 = Math.min(e3, this._rowCount - 1), t3 = Math.min(t3, this._rowCount - 1), this._renderer.value.renderRows(e3, t3), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: e3, end: t3 }), this._onRender.fire({ start: e3, end: t3 }), this._isNextRenderRedrawOnly = true);
        }
        resize(e3, t3) {
          this._rowCount = t3, this._fireOnCanvasResize();
        }
        _handleOptionsChanged() {
          this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
        }
        _fireOnCanvasResize() {
          this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
        }
        hasRenderer() {
          return !!this._renderer.value;
        }
        setRenderer(e3) {
          this._renderer.value = e3, this._renderer.value && (this._renderer.value.onRequestRedraw((e4) => this.refreshRows(e4.start, e4.end, true)), this._needsSelectionRefresh = true, this._fullRefresh());
        }
        addRefreshCallback(e3) {
          return this._renderDebouncer.addRefreshCallback(e3);
        }
        _fullRefresh() {
          this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
        }
        clearTextureAtlas() {
          this._renderer.value && (this._renderer.value.clearTextureAtlas?.(), this._fullRefresh());
        }
        handleDevicePixelRatioChange() {
          this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
        }
        handleResize(e3, t3) {
          this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value?.handleResize(e3, t3)) : this._renderer.value.handleResize(e3, t3), this._fullRefresh());
        }
        handleCharSizeChanged() {
          this._renderer.value?.handleCharSizeChanged();
        }
        handleBlur() {
          this._renderer.value?.handleBlur();
        }
        handleFocus() {
          this._renderer.value?.handleFocus();
        }
        handleSelectionChanged(e3, t3, i4) {
          this._selectionState.start = e3, this._selectionState.end = t3, this._selectionState.columnSelectMode = i4, this._renderer.value?.handleSelectionChanged(e3, t3, i4);
        }
        handleCursorMove() {
          this._renderer.value?.handleCursorMove();
        }
        clear() {
          this._renderer.value?.clear();
        }
      };
      t2.RenderService = d = s2([r(2, l.IOptionsService), r(3, o.ICharSizeService), r(4, l.IDecorationService), r(5, l.IBufferService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], d);
    }, 9312: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionService = void 0;
      const n = i3(9806), o = i3(9504), a = i3(456), h2 = i3(4725), c = i3(8460), l = i3(844), d = i3(6114), _2 = i3(4841), u = i3(511), f = i3(2585), v2 = String.fromCharCode(160), p2 = new RegExp(v2, "g");
      let g = t2.SelectionService = class extends l.Disposable {
        constructor(e3, t3, i4, s3, r2, n2, o2, h3, d2) {
          super(), this._element = e3, this._screenElement = t3, this._linkifier = i4, this._bufferService = s3, this._coreService = r2, this._mouseService = n2, this._optionsService = o2, this._renderService = h3, this._coreBrowserService = d2, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new u.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new c.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new c.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new c.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new c.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e4) => this._handleMouseMove(e4), this._mouseUpListener = (e4) => this._handleMouseUp(e4), this._coreService.onUserInput(() => {
            this.hasSelection && this.clearSelection();
          }), this._trimListener = this._bufferService.buffer.lines.onTrim((e4) => this._handleTrim(e4)), this.register(this._bufferService.buffers.onBufferActivate((e4) => this._handleBufferActivate(e4))), this.enable(), this._model = new a.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, l.toDisposable)(() => {
            this._removeMouseDownListeners();
          }));
        }
        reset() {
          this.clearSelection();
        }
        disable() {
          this.clearSelection(), this._enabled = false;
        }
        enable() {
          this._enabled = true;
        }
        get selectionStart() {
          return this._model.finalSelectionStart;
        }
        get selectionEnd() {
          return this._model.finalSelectionEnd;
        }
        get hasSelection() {
          const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
          return !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
        }
        get selectionText() {
          const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
          if (!e3 || !t3) return "";
          const i4 = this._bufferService.buffer, s3 = [];
          if (3 === this._activeSelectionMode) {
            if (e3[0] === t3[0]) return "";
            const r2 = e3[0] < t3[0] ? e3[0] : t3[0], n2 = e3[0] < t3[0] ? t3[0] : e3[0];
            for (let o2 = e3[1]; o2 <= t3[1]; o2++) {
              const e4 = i4.translateBufferLineToString(o2, true, r2, n2);
              s3.push(e4);
            }
          } else {
            const r2 = e3[1] === t3[1] ? t3[0] : void 0;
            s3.push(i4.translateBufferLineToString(e3[1], true, e3[0], r2));
            for (let r3 = e3[1] + 1; r3 <= t3[1] - 1; r3++) {
              const e4 = i4.lines.get(r3), t4 = i4.translateBufferLineToString(r3, true);
              e4?.isWrapped ? s3[s3.length - 1] += t4 : s3.push(t4);
            }
            if (e3[1] !== t3[1]) {
              const e4 = i4.lines.get(t3[1]), r3 = i4.translateBufferLineToString(t3[1], true, 0, t3[0]);
              e4 && e4.isWrapped ? s3[s3.length - 1] += r3 : s3.push(r3);
            }
          }
          return s3.map((e4) => e4.replace(p2, " ")).join(d.isWindows ? "\r\n" : "\n");
        }
        clearSelection() {
          this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
        }
        refresh(e3) {
          this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), d.isLinux && e3 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
        }
        _refresh() {
          this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: 3 === this._activeSelectionMode });
        }
        _isClickInSelection(e3) {
          const t3 = this._getMouseBufferCoords(e3), i4 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
          return !!(i4 && s3 && t3) && this._areCoordsInSelection(t3, i4, s3);
        }
        isCellInSelection(e3, t3) {
          const i4 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
          return !(!i4 || !s3) && this._areCoordsInSelection([e3, t3], i4, s3);
        }
        _areCoordsInSelection(e3, t3, i4) {
          return e3[1] > t3[1] && e3[1] < i4[1] || t3[1] === i4[1] && e3[1] === t3[1] && e3[0] >= t3[0] && e3[0] < i4[0] || t3[1] < i4[1] && e3[1] === i4[1] && e3[0] < i4[0] || t3[1] < i4[1] && e3[1] === t3[1] && e3[0] >= t3[0];
        }
        _selectWordAtCursor(e3, t3) {
          const i4 = this._linkifier.currentLink?.link?.range;
          if (i4) return this._model.selectionStart = [i4.start.x - 1, i4.start.y - 1], this._model.selectionStartLength = (0, _2.getRangeLength)(i4, this._bufferService.cols), this._model.selectionEnd = void 0, true;
          const s3 = this._getMouseBufferCoords(e3);
          return !!s3 && (this._selectWordAt(s3, t3), this._model.selectionEnd = void 0, true);
        }
        selectAll() {
          this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
        }
        selectLines(e3, t3) {
          this._model.clearSelection(), e3 = Math.max(e3, 0), t3 = Math.min(t3, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, e3], this._model.selectionEnd = [this._bufferService.cols, t3], this.refresh(), this._onSelectionChange.fire();
        }
        _handleTrim(e3) {
          this._model.handleTrim(e3) && this.refresh();
        }
        _getMouseBufferCoords(e3) {
          const t3 = this._mouseService.getCoords(e3, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
          if (t3) return t3[0]--, t3[1]--, t3[1] += this._bufferService.buffer.ydisp, t3;
        }
        _getMouseEventScrollAmount(e3) {
          let t3 = (0, n.getCoordsRelativeToElement)(this._coreBrowserService.window, e3, this._screenElement)[1];
          const i4 = this._renderService.dimensions.css.canvas.height;
          return t3 >= 0 && t3 <= i4 ? 0 : (t3 > i4 && (t3 -= i4), t3 = Math.min(Math.max(t3, -50), 50), t3 /= 50, t3 / Math.abs(t3) + Math.round(14 * t3));
        }
        shouldForceSelection(e3) {
          return d.isMac ? e3.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e3.shiftKey;
        }
        handleMouseDown(e3) {
          if (this._mouseDownTimeStamp = e3.timeStamp, (2 !== e3.button || !this.hasSelection) && 0 === e3.button) {
            if (!this._enabled) {
              if (!this.shouldForceSelection(e3)) return;
              e3.stopPropagation();
            }
            e3.preventDefault(), this._dragScrollAmount = 0, this._enabled && e3.shiftKey ? this._handleIncrementalClick(e3) : 1 === e3.detail ? this._handleSingleClick(e3) : 2 === e3.detail ? this._handleDoubleClick(e3) : 3 === e3.detail && this._handleTripleClick(e3), this._addMouseDownListeners(), this.refresh(true);
          }
        }
        _addMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
        }
        _removeMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
        }
        _handleIncrementalClick(e3) {
          this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e3));
        }
        _handleSingleClick(e3) {
          if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(e3) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e3), !this._model.selectionStart) return;
          this._model.selectionEnd = void 0;
          const t3 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
          t3 && t3.length !== this._model.selectionStart[0] && 0 === t3.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;
        }
        _handleDoubleClick(e3) {
          this._selectWordAtCursor(e3, true) && (this._activeSelectionMode = 1);
        }
        _handleTripleClick(e3) {
          const t3 = this._getMouseBufferCoords(e3);
          t3 && (this._activeSelectionMode = 2, this._selectLineAt(t3[1]));
        }
        shouldColumnSelect(e3) {
          return e3.altKey && !(d.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
        }
        _handleMouseMove(e3) {
          if (e3.stopImmediatePropagation(), !this._model.selectionStart) return;
          const t3 = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
          if (this._model.selectionEnd = this._getMouseBufferCoords(e3), !this._model.selectionEnd) return void this.refresh(true);
          2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e3), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
          const i4 = this._bufferService.buffer;
          if (this._model.selectionEnd[1] < i4.lines.length) {
            const e4 = i4.lines.get(this._model.selectionEnd[1]);
            e4 && 0 === e4.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0] < this._bufferService.cols && this._model.selectionEnd[0]++;
          }
          t3 && t3[0] === this._model.selectionEnd[0] && t3[1] === this._model.selectionEnd[1] || this.refresh(true);
        }
        _dragScroll() {
          if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
            this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: false });
            const e3 = this._bufferService.buffer;
            this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e3.ydisp + this._bufferService.rows, e3.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e3.ydisp), this.refresh();
          }
        }
        _handleMouseUp(e3) {
          const t3 = e3.timeStamp - this._mouseDownTimeStamp;
          if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t3 < 500 && e3.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
            if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
              const t4 = this._mouseService.getCoords(e3, this._element, this._bufferService.cols, this._bufferService.rows, false);
              if (t4 && void 0 !== t4[0] && void 0 !== t4[1]) {
                const e4 = (0, o.moveToCellSequence)(t4[0] - 1, t4[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                this._coreService.triggerDataEvent(e4, true);
              }
            }
          } else this._fireEventIfSelectionChanged();
        }
        _fireEventIfSelectionChanged() {
          const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd, i4 = !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
          i4 ? e3 && t3 && (this._oldSelectionStart && this._oldSelectionEnd && e3[0] === this._oldSelectionStart[0] && e3[1] === this._oldSelectionStart[1] && t3[0] === this._oldSelectionEnd[0] && t3[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e3, t3, i4)) : this._oldHasSelection && this._fireOnSelectionChange(e3, t3, i4);
        }
        _fireOnSelectionChange(e3, t3, i4) {
          this._oldSelectionStart = e3, this._oldSelectionEnd = t3, this._oldHasSelection = i4, this._onSelectionChange.fire();
        }
        _handleBufferActivate(e3) {
          this.clearSelection(), this._trimListener.dispose(), this._trimListener = e3.activeBuffer.lines.onTrim((e4) => this._handleTrim(e4));
        }
        _convertViewportColToCharacterIndex(e3, t3) {
          let i4 = t3;
          for (let s3 = 0; t3 >= s3; s3++) {
            const r2 = e3.loadCell(s3, this._workCell).getChars().length;
            0 === this._workCell.getWidth() ? i4-- : r2 > 1 && t3 !== s3 && (i4 += r2 - 1);
          }
          return i4;
        }
        setSelection(e3, t3, i4) {
          this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [e3, t3], this._model.selectionStartLength = i4, this.refresh(), this._fireEventIfSelectionChanged();
        }
        rightClickSelect(e3) {
          this._isClickInSelection(e3) || (this._selectWordAtCursor(e3, false) && this.refresh(true), this._fireEventIfSelectionChanged());
        }
        _getWordAt(e3, t3, i4 = true, s3 = true) {
          if (e3[0] >= this._bufferService.cols) return;
          const r2 = this._bufferService.buffer, n2 = r2.lines.get(e3[1]);
          if (!n2) return;
          const o2 = r2.translateBufferLineToString(e3[1], false);
          let a2 = this._convertViewportColToCharacterIndex(n2, e3[0]), h3 = a2;
          const c2 = e3[0] - a2;
          let l2 = 0, d2 = 0, _3 = 0, u2 = 0;
          if (" " === o2.charAt(a2)) {
            for (; a2 > 0 && " " === o2.charAt(a2 - 1); ) a2--;
            for (; h3 < o2.length && " " === o2.charAt(h3 + 1); ) h3++;
          } else {
            let t4 = e3[0], i5 = e3[0];
            0 === n2.getWidth(t4) && (l2++, t4--), 2 === n2.getWidth(i5) && (d2++, i5++);
            const s4 = n2.getString(i5).length;
            for (s4 > 1 && (u2 += s4 - 1, h3 += s4 - 1); t4 > 0 && a2 > 0 && !this._isCharWordSeparator(n2.loadCell(t4 - 1, this._workCell)); ) {
              n2.loadCell(t4 - 1, this._workCell);
              const e4 = this._workCell.getChars().length;
              0 === this._workCell.getWidth() ? (l2++, t4--) : e4 > 1 && (_3 += e4 - 1, a2 -= e4 - 1), a2--, t4--;
            }
            for (; i5 < n2.length && h3 + 1 < o2.length && !this._isCharWordSeparator(n2.loadCell(i5 + 1, this._workCell)); ) {
              n2.loadCell(i5 + 1, this._workCell);
              const e4 = this._workCell.getChars().length;
              2 === this._workCell.getWidth() ? (d2++, i5++) : e4 > 1 && (u2 += e4 - 1, h3 += e4 - 1), h3++, i5++;
            }
          }
          h3++;
          let f2 = a2 + c2 - l2 + _3, v3 = Math.min(this._bufferService.cols, h3 - a2 + l2 + d2 - _3 - u2);
          if (t3 || "" !== o2.slice(a2, h3).trim()) {
            if (i4 && 0 === f2 && 32 !== n2.getCodePoint(0)) {
              const t4 = r2.lines.get(e3[1] - 1);
              if (t4 && n2.isWrapped && 32 !== t4.getCodePoint(this._bufferService.cols - 1)) {
                const t5 = this._getWordAt([this._bufferService.cols - 1, e3[1] - 1], false, true, false);
                if (t5) {
                  const e4 = this._bufferService.cols - t5.start;
                  f2 -= e4, v3 += e4;
                }
              }
            }
            if (s3 && f2 + v3 === this._bufferService.cols && 32 !== n2.getCodePoint(this._bufferService.cols - 1)) {
              const t4 = r2.lines.get(e3[1] + 1);
              if (t4?.isWrapped && 32 !== t4.getCodePoint(0)) {
                const t5 = this._getWordAt([0, e3[1] + 1], false, false, true);
                t5 && (v3 += t5.length);
              }
            }
            return { start: f2, length: v3 };
          }
        }
        _selectWordAt(e3, t3) {
          const i4 = this._getWordAt(e3, t3);
          if (i4) {
            for (; i4.start < 0; ) i4.start += this._bufferService.cols, e3[1]--;
            this._model.selectionStart = [i4.start, e3[1]], this._model.selectionStartLength = i4.length;
          }
        }
        _selectToWordAt(e3) {
          const t3 = this._getWordAt(e3, true);
          if (t3) {
            let i4 = e3[1];
            for (; t3.start < 0; ) t3.start += this._bufferService.cols, i4--;
            if (!this._model.areSelectionValuesReversed()) for (; t3.start + t3.length > this._bufferService.cols; ) t3.length -= this._bufferService.cols, i4++;
            this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? t3.start : t3.start + t3.length, i4];
          }
        }
        _isCharWordSeparator(e3) {
          return 0 !== e3.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e3.getChars()) >= 0;
        }
        _selectLineAt(e3) {
          const t3 = this._bufferService.buffer.getWrappedRangeForLine(e3), i4 = { start: { x: 0, y: t3.first }, end: { x: this._bufferService.cols - 1, y: t3.last } };
          this._model.selectionStart = [0, t3.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, _2.getRangeLength)(i4, this._bufferService.cols);
        }
      };
      t2.SelectionService = g = s2([r(3, f.IBufferService), r(4, f.ICoreService), r(5, h2.IMouseService), r(6, f.IOptionsService), r(7, h2.IRenderService), r(8, h2.ICoreBrowserService)], g);
    }, 4725: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ILinkProviderService = t2.IThemeService = t2.ICharacterJoinerService = t2.ISelectionService = t2.IRenderService = t2.IMouseService = t2.ICoreBrowserService = t2.ICharSizeService = void 0;
      const s2 = i3(8343);
      t2.ICharSizeService = (0, s2.createDecorator)("CharSizeService"), t2.ICoreBrowserService = (0, s2.createDecorator)("CoreBrowserService"), t2.IMouseService = (0, s2.createDecorator)("MouseService"), t2.IRenderService = (0, s2.createDecorator)("RenderService"), t2.ISelectionService = (0, s2.createDecorator)("SelectionService"), t2.ICharacterJoinerService = (0, s2.createDecorator)("CharacterJoinerService"), t2.IThemeService = (0, s2.createDecorator)("ThemeService"), t2.ILinkProviderService = (0, s2.createDecorator)("LinkProviderService");
    }, 6731: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ThemeService = t2.DEFAULT_ANSI_COLORS = void 0;
      const n = i3(7239), o = i3(8055), a = i3(8460), h2 = i3(844), c = i3(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _2 = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
      t2.DEFAULT_ANSI_COLORS = Object.freeze((() => {
        const e3 = [o.css.toColor("#2e3436"), o.css.toColor("#cc0000"), o.css.toColor("#4e9a06"), o.css.toColor("#c4a000"), o.css.toColor("#3465a4"), o.css.toColor("#75507b"), o.css.toColor("#06989a"), o.css.toColor("#d3d7cf"), o.css.toColor("#555753"), o.css.toColor("#ef2929"), o.css.toColor("#8ae234"), o.css.toColor("#fce94f"), o.css.toColor("#729fcf"), o.css.toColor("#ad7fa8"), o.css.toColor("#34e2e2"), o.css.toColor("#eeeeec")], t3 = [0, 95, 135, 175, 215, 255];
        for (let i4 = 0; i4 < 216; i4++) {
          const s3 = t3[i4 / 36 % 6 | 0], r2 = t3[i4 / 6 % 6 | 0], n2 = t3[i4 % 6];
          e3.push({ css: o.channels.toCss(s3, r2, n2), rgba: o.channels.toRgba(s3, r2, n2) });
        }
        for (let t4 = 0; t4 < 24; t4++) {
          const i4 = 8 + 10 * t4;
          e3.push({ css: o.channels.toCss(i4, i4, i4), rgba: o.channels.toRgba(i4, i4, i4) });
        }
        return e3;
      })());
      let v2 = t2.ThemeService = class extends h2.Disposable {
        get colors() {
          return this._colors;
        }
        constructor(e3) {
          super(), this._optionsService = e3, this._contrastCache = new n.ColorContrastCache(), this._halfContrastCache = new n.ColorContrastCache(), this._onChangeColors = this.register(new a.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: l, background: d, cursor: _2, cursorAccent: u, selectionForeground: void 0, selectionBackgroundTransparent: f, selectionBackgroundOpaque: o.color.blend(d, f), selectionInactiveBackgroundTransparent: f, selectionInactiveBackgroundOpaque: o.color.blend(d, f), ansi: t2.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
        }
        _setTheme(e3 = {}) {
          const i4 = this._colors;
          if (i4.foreground = p2(e3.foreground, l), i4.background = p2(e3.background, d), i4.cursor = p2(e3.cursor, _2), i4.cursorAccent = p2(e3.cursorAccent, u), i4.selectionBackgroundTransparent = p2(e3.selectionBackground, f), i4.selectionBackgroundOpaque = o.color.blend(i4.background, i4.selectionBackgroundTransparent), i4.selectionInactiveBackgroundTransparent = p2(e3.selectionInactiveBackground, i4.selectionBackgroundTransparent), i4.selectionInactiveBackgroundOpaque = o.color.blend(i4.background, i4.selectionInactiveBackgroundTransparent), i4.selectionForeground = e3.selectionForeground ? p2(e3.selectionForeground, o.NULL_COLOR) : void 0, i4.selectionForeground === o.NULL_COLOR && (i4.selectionForeground = void 0), o.color.isOpaque(i4.selectionBackgroundTransparent)) {
            const e4 = 0.3;
            i4.selectionBackgroundTransparent = o.color.opacity(i4.selectionBackgroundTransparent, e4);
          }
          if (o.color.isOpaque(i4.selectionInactiveBackgroundTransparent)) {
            const e4 = 0.3;
            i4.selectionInactiveBackgroundTransparent = o.color.opacity(i4.selectionInactiveBackgroundTransparent, e4);
          }
          if (i4.ansi = t2.DEFAULT_ANSI_COLORS.slice(), i4.ansi[0] = p2(e3.black, t2.DEFAULT_ANSI_COLORS[0]), i4.ansi[1] = p2(e3.red, t2.DEFAULT_ANSI_COLORS[1]), i4.ansi[2] = p2(e3.green, t2.DEFAULT_ANSI_COLORS[2]), i4.ansi[3] = p2(e3.yellow, t2.DEFAULT_ANSI_COLORS[3]), i4.ansi[4] = p2(e3.blue, t2.DEFAULT_ANSI_COLORS[4]), i4.ansi[5] = p2(e3.magenta, t2.DEFAULT_ANSI_COLORS[5]), i4.ansi[6] = p2(e3.cyan, t2.DEFAULT_ANSI_COLORS[6]), i4.ansi[7] = p2(e3.white, t2.DEFAULT_ANSI_COLORS[7]), i4.ansi[8] = p2(e3.brightBlack, t2.DEFAULT_ANSI_COLORS[8]), i4.ansi[9] = p2(e3.brightRed, t2.DEFAULT_ANSI_COLORS[9]), i4.ansi[10] = p2(e3.brightGreen, t2.DEFAULT_ANSI_COLORS[10]), i4.ansi[11] = p2(e3.brightYellow, t2.DEFAULT_ANSI_COLORS[11]), i4.ansi[12] = p2(e3.brightBlue, t2.DEFAULT_ANSI_COLORS[12]), i4.ansi[13] = p2(e3.brightMagenta, t2.DEFAULT_ANSI_COLORS[13]), i4.ansi[14] = p2(e3.brightCyan, t2.DEFAULT_ANSI_COLORS[14]), i4.ansi[15] = p2(e3.brightWhite, t2.DEFAULT_ANSI_COLORS[15]), e3.extendedAnsi) {
            const s3 = Math.min(i4.ansi.length - 16, e3.extendedAnsi.length);
            for (let r2 = 0; r2 < s3; r2++) i4.ansi[r2 + 16] = p2(e3.extendedAnsi[r2], t2.DEFAULT_ANSI_COLORS[r2 + 16]);
          }
          this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
        }
        restoreColor(e3) {
          this._restoreColor(e3), this._onChangeColors.fire(this.colors);
        }
        _restoreColor(e3) {
          if (void 0 !== e3) switch (e3) {
            case 256:
              this._colors.foreground = this._restoreColors.foreground;
              break;
            case 257:
              this._colors.background = this._restoreColors.background;
              break;
            case 258:
              this._colors.cursor = this._restoreColors.cursor;
              break;
            default:
              this._colors.ansi[e3] = this._restoreColors.ansi[e3];
          }
          else for (let e4 = 0; e4 < this._restoreColors.ansi.length; ++e4) this._colors.ansi[e4] = this._restoreColors.ansi[e4];
        }
        modifyColors(e3) {
          e3(this._colors), this._onChangeColors.fire(this.colors);
        }
        _updateRestoreColors() {
          this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
        }
      };
      function p2(e3, t3) {
        if (void 0 !== e3) try {
          return o.css.toColor(e3);
        } catch {
        }
        return t3;
      }
      __name(p2, "p");
      t2.ThemeService = v2 = s2([r(0, c.IOptionsService)], v2);
    }, 6349: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CircularList = void 0;
      const s2 = i3(8460), r = i3(844);
      class n extends r.Disposable {
        static {
          __name(this, "n");
        }
        constructor(e3) {
          super(), this._maxLength = e3, this.onDeleteEmitter = this.register(new s2.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s2.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s2.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
        }
        get maxLength() {
          return this._maxLength;
        }
        set maxLength(e3) {
          if (this._maxLength === e3) return;
          const t3 = new Array(e3);
          for (let i4 = 0; i4 < Math.min(e3, this.length); i4++) t3[i4] = this._array[this._getCyclicIndex(i4)];
          this._array = t3, this._maxLength = e3, this._startIndex = 0;
        }
        get length() {
          return this._length;
        }
        set length(e3) {
          if (e3 > this._length) for (let t3 = this._length; t3 < e3; t3++) this._array[t3] = void 0;
          this._length = e3;
        }
        get(e3) {
          return this._array[this._getCyclicIndex(e3)];
        }
        set(e3, t3) {
          this._array[this._getCyclicIndex(e3)] = t3;
        }
        push(e3) {
          this._array[this._getCyclicIndex(this._length)] = e3, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
        }
        recycle() {
          if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
          return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
        }
        get isFull() {
          return this._length === this._maxLength;
        }
        pop() {
          return this._array[this._getCyclicIndex(this._length-- - 1)];
        }
        splice(e3, t3, ...i4) {
          if (t3) {
            for (let i5 = e3; i5 < this._length - t3; i5++) this._array[this._getCyclicIndex(i5)] = this._array[this._getCyclicIndex(i5 + t3)];
            this._length -= t3, this.onDeleteEmitter.fire({ index: e3, amount: t3 });
          }
          for (let t4 = this._length - 1; t4 >= e3; t4--) this._array[this._getCyclicIndex(t4 + i4.length)] = this._array[this._getCyclicIndex(t4)];
          for (let t4 = 0; t4 < i4.length; t4++) this._array[this._getCyclicIndex(e3 + t4)] = i4[t4];
          if (i4.length && this.onInsertEmitter.fire({ index: e3, amount: i4.length }), this._length + i4.length > this._maxLength) {
            const e4 = this._length + i4.length - this._maxLength;
            this._startIndex += e4, this._length = this._maxLength, this.onTrimEmitter.fire(e4);
          } else this._length += i4.length;
        }
        trimStart(e3) {
          e3 > this._length && (e3 = this._length), this._startIndex += e3, this._length -= e3, this.onTrimEmitter.fire(e3);
        }
        shiftElements(e3, t3, i4) {
          if (!(t3 <= 0)) {
            if (e3 < 0 || e3 >= this._length) throw new Error("start argument out of range");
            if (e3 + i4 < 0) throw new Error("Cannot shift elements in list beyond index 0");
            if (i4 > 0) {
              for (let s4 = t3 - 1; s4 >= 0; s4--) this.set(e3 + s4 + i4, this.get(e3 + s4));
              const s3 = e3 + t3 + i4 - this._length;
              if (s3 > 0) for (this._length += s3; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
            } else for (let s3 = 0; s3 < t3; s3++) this.set(e3 + s3 + i4, this.get(e3 + s3));
          }
        }
        _getCyclicIndex(e3) {
          return (this._startIndex + e3) % this._maxLength;
        }
      }
      t2.CircularList = n;
    }, 1439: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.clone = void 0, t2.clone = /* @__PURE__ */ __name(function e3(t3, i3 = 5) {
        if ("object" != typeof t3) return t3;
        const s2 = Array.isArray(t3) ? [] : {};
        for (const r in t3) s2[r] = i3 <= 1 ? t3[r] : t3[r] && e3(t3[r], i3 - 1);
        return s2;
      }, "e");
    }, 8055: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.contrastRatio = t2.toPaddedHex = t2.rgba = t2.rgb = t2.css = t2.color = t2.channels = t2.NULL_COLOR = void 0;
      let i3 = 0, s2 = 0, r = 0, n = 0;
      var o, a, h2, c, l;
      function d(e3) {
        const t3 = e3.toString(16);
        return t3.length < 2 ? "0" + t3 : t3;
      }
      __name(d, "d");
      function _2(e3, t3) {
        return e3 < t3 ? (t3 + 0.05) / (e3 + 0.05) : (e3 + 0.05) / (t3 + 0.05);
      }
      __name(_2, "_");
      t2.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(e3) {
        e3.toCss = function(e4, t3, i4, s3) {
          return void 0 !== s3 ? `#${d(e4)}${d(t3)}${d(i4)}${d(s3)}` : `#${d(e4)}${d(t3)}${d(i4)}`;
        }, e3.toRgba = function(e4, t3, i4, s3 = 255) {
          return (e4 << 24 | t3 << 16 | i4 << 8 | s3) >>> 0;
        }, e3.toColor = function(t3, i4, s3, r2) {
          return { css: e3.toCss(t3, i4, s3, r2), rgba: e3.toRgba(t3, i4, s3, r2) };
        };
      }(o || (t2.channels = o = {})), function(e3) {
        function t3(e4, t4) {
          return n = Math.round(255 * t4), [i3, s2, r] = l.toChannels(e4.rgba), { css: o.toCss(i3, s2, r, n), rgba: o.toRgba(i3, s2, r, n) };
        }
        __name(t3, "t");
        e3.blend = function(e4, t4) {
          if (n = (255 & t4.rgba) / 255, 1 === n) return { css: t4.css, rgba: t4.rgba };
          const a2 = t4.rgba >> 24 & 255, h3 = t4.rgba >> 16 & 255, c2 = t4.rgba >> 8 & 255, l2 = e4.rgba >> 24 & 255, d2 = e4.rgba >> 16 & 255, _3 = e4.rgba >> 8 & 255;
          return i3 = l2 + Math.round((a2 - l2) * n), s2 = d2 + Math.round((h3 - d2) * n), r = _3 + Math.round((c2 - _3) * n), { css: o.toCss(i3, s2, r), rgba: o.toRgba(i3, s2, r) };
        }, e3.isOpaque = function(e4) {
          return 255 == (255 & e4.rgba);
        }, e3.ensureContrastRatio = function(e4, t4, i4) {
          const s3 = l.ensureContrastRatio(e4.rgba, t4.rgba, i4);
          if (s3) return o.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
        }, e3.opaque = function(e4) {
          const t4 = (255 | e4.rgba) >>> 0;
          return [i3, s2, r] = l.toChannels(t4), { css: o.toCss(i3, s2, r), rgba: t4 };
        }, e3.opacity = t3, e3.multiplyOpacity = function(e4, i4) {
          return n = 255 & e4.rgba, t3(e4, n * i4 / 255);
        }, e3.toColorRGB = function(e4) {
          return [e4.rgba >> 24 & 255, e4.rgba >> 16 & 255, e4.rgba >> 8 & 255];
        };
      }(a || (t2.color = a = {})), function(e3) {
        let t3, a2;
        try {
          const e4 = document.createElement("canvas");
          e4.width = 1, e4.height = 1;
          const i4 = e4.getContext("2d", { willReadFrequently: true });
          i4 && (t3 = i4, t3.globalCompositeOperation = "copy", a2 = t3.createLinearGradient(0, 0, 1, 1));
        } catch {
        }
        e3.toColor = function(e4) {
          if (e4.match(/#[\da-f]{3,8}/i)) switch (e4.length) {
            case 4:
              return i3 = parseInt(e4.slice(1, 2).repeat(2), 16), s2 = parseInt(e4.slice(2, 3).repeat(2), 16), r = parseInt(e4.slice(3, 4).repeat(2), 16), o.toColor(i3, s2, r);
            case 5:
              return i3 = parseInt(e4.slice(1, 2).repeat(2), 16), s2 = parseInt(e4.slice(2, 3).repeat(2), 16), r = parseInt(e4.slice(3, 4).repeat(2), 16), n = parseInt(e4.slice(4, 5).repeat(2), 16), o.toColor(i3, s2, r, n);
            case 7:
              return { css: e4, rgba: (parseInt(e4.slice(1), 16) << 8 | 255) >>> 0 };
            case 9:
              return { css: e4, rgba: parseInt(e4.slice(1), 16) >>> 0 };
          }
          const h3 = e4.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
          if (h3) return i3 = parseInt(h3[1]), s2 = parseInt(h3[2]), r = parseInt(h3[3]), n = Math.round(255 * (void 0 === h3[5] ? 1 : parseFloat(h3[5]))), o.toColor(i3, s2, r, n);
          if (!t3 || !a2) throw new Error("css.toColor: Unsupported css format");
          if (t3.fillStyle = a2, t3.fillStyle = e4, "string" != typeof t3.fillStyle) throw new Error("css.toColor: Unsupported css format");
          if (t3.fillRect(0, 0, 1, 1), [i3, s2, r, n] = t3.getImageData(0, 0, 1, 1).data, 255 !== n) throw new Error("css.toColor: Unsupported css format");
          return { rgba: o.toRgba(i3, s2, r, n), css: e4 };
        };
      }(h2 || (t2.css = h2 = {})), function(e3) {
        function t3(e4, t4, i4) {
          const s3 = e4 / 255, r2 = t4 / 255, n2 = i4 / 255;
          return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n2 <= 0.03928 ? n2 / 12.92 : Math.pow((n2 + 0.055) / 1.055, 2.4));
        }
        __name(t3, "t");
        e3.relativeLuminance = function(e4) {
          return t3(e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4);
        }, e3.relativeLuminance2 = t3;
      }(c || (t2.rgb = c = {})), function(e3) {
        function t3(e4, t4, i4) {
          const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
          let o2 = t4 >> 24 & 255, a3 = t4 >> 16 & 255, h3 = t4 >> 8 & 255, l2 = _2(c.relativeLuminance2(o2, a3, h3), c.relativeLuminance2(s3, r2, n2));
          for (; l2 < i4 && (o2 > 0 || a3 > 0 || h3 > 0); ) o2 -= Math.max(0, Math.ceil(0.1 * o2)), a3 -= Math.max(0, Math.ceil(0.1 * a3)), h3 -= Math.max(0, Math.ceil(0.1 * h3)), l2 = _2(c.relativeLuminance2(o2, a3, h3), c.relativeLuminance2(s3, r2, n2));
          return (o2 << 24 | a3 << 16 | h3 << 8 | 255) >>> 0;
        }
        __name(t3, "t");
        function a2(e4, t4, i4) {
          const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
          let o2 = t4 >> 24 & 255, a3 = t4 >> 16 & 255, h3 = t4 >> 8 & 255, l2 = _2(c.relativeLuminance2(o2, a3, h3), c.relativeLuminance2(s3, r2, n2));
          for (; l2 < i4 && (o2 < 255 || a3 < 255 || h3 < 255); ) o2 = Math.min(255, o2 + Math.ceil(0.1 * (255 - o2))), a3 = Math.min(255, a3 + Math.ceil(0.1 * (255 - a3))), h3 = Math.min(255, h3 + Math.ceil(0.1 * (255 - h3))), l2 = _2(c.relativeLuminance2(o2, a3, h3), c.relativeLuminance2(s3, r2, n2));
          return (o2 << 24 | a3 << 16 | h3 << 8 | 255) >>> 0;
        }
        __name(a2, "a");
        e3.blend = function(e4, t4) {
          if (n = (255 & t4) / 255, 1 === n) return t4;
          const a3 = t4 >> 24 & 255, h3 = t4 >> 16 & 255, c2 = t4 >> 8 & 255, l2 = e4 >> 24 & 255, d2 = e4 >> 16 & 255, _3 = e4 >> 8 & 255;
          return i3 = l2 + Math.round((a3 - l2) * n), s2 = d2 + Math.round((h3 - d2) * n), r = _3 + Math.round((c2 - _3) * n), o.toRgba(i3, s2, r);
        }, e3.ensureContrastRatio = function(e4, i4, s3) {
          const r2 = c.relativeLuminance(e4 >> 8), n2 = c.relativeLuminance(i4 >> 8);
          if (_2(r2, n2) < s3) {
            if (n2 < r2) {
              const n3 = t3(e4, i4, s3), o3 = _2(r2, c.relativeLuminance(n3 >> 8));
              if (o3 < s3) {
                const t4 = a2(e4, i4, s3);
                return o3 > _2(r2, c.relativeLuminance(t4 >> 8)) ? n3 : t4;
              }
              return n3;
            }
            const o2 = a2(e4, i4, s3), h3 = _2(r2, c.relativeLuminance(o2 >> 8));
            if (h3 < s3) {
              const n3 = t3(e4, i4, s3);
              return h3 > _2(r2, c.relativeLuminance(n3 >> 8)) ? o2 : n3;
            }
            return o2;
          }
        }, e3.reduceLuminance = t3, e3.increaseLuminance = a2, e3.toChannels = function(e4) {
          return [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
        };
      }(l || (t2.rgba = l = {})), t2.toPaddedHex = d, t2.contrastRatio = _2;
    }, 8969: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreTerminal = void 0;
      const s2 = i3(844), r = i3(2585), n = i3(4348), o = i3(7866), a = i3(744), h2 = i3(7302), c = i3(6975), l = i3(8460), d = i3(1753), _2 = i3(1480), u = i3(7994), f = i3(9282), v2 = i3(5435), p2 = i3(5981), g = i3(2660);
      let m = false;
      class S extends s2.Disposable {
        static {
          __name(this, "S");
        }
        get onScroll() {
          return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter()), this._onScroll.event((e3) => {
            this._onScrollApi?.fire(e3.position);
          })), this._onScrollApi.event;
        }
        get cols() {
          return this._bufferService.cols;
        }
        get rows() {
          return this._bufferService.rows;
        }
        get buffers() {
          return this._bufferService.buffers;
        }
        get options() {
          return this.optionsService.options;
        }
        set options(e3) {
          for (const t3 in e3) this.optionsService.options[t3] = e3[t3];
        }
        constructor(e3) {
          super(), this._windowsWrappingHeuristics = this.register(new s2.MutableDisposable()), this._onBinary = this.register(new l.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter()), this._instantiationService = new n.InstantiationService(), this.optionsService = this.register(new h2.OptionsService(e3)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_2.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(g.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v2.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((e4) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this.register(this._inputHandler.onScroll((e4) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this._writeBuffer = this.register(new p2.WriteBuffer((e4, t3) => this._inputHandler.parse(e4, t3))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
        }
        write(e3, t3) {
          this._writeBuffer.write(e3, t3);
        }
        writeSync(e3, t3) {
          this._logService.logLevel <= r.LogLevelEnum.WARN && !m && (this._logService.warn("writeSync is unreliable and will be removed soon."), m = true), this._writeBuffer.writeSync(e3, t3);
        }
        input(e3, t3 = true) {
          this.coreService.triggerDataEvent(e3, t3);
        }
        resize(e3, t3) {
          isNaN(e3) || isNaN(t3) || (e3 = Math.max(e3, a.MINIMUM_COLS), t3 = Math.max(t3, a.MINIMUM_ROWS), this._bufferService.resize(e3, t3));
        }
        scroll(e3, t3 = false) {
          this._bufferService.scroll(e3, t3);
        }
        scrollLines(e3, t3, i4) {
          this._bufferService.scrollLines(e3, t3, i4);
        }
        scrollPages(e3) {
          this.scrollLines(e3 * (this.rows - 1));
        }
        scrollToTop() {
          this.scrollLines(-this._bufferService.buffer.ydisp);
        }
        scrollToBottom() {
          this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
        }
        scrollToLine(e3) {
          const t3 = e3 - this._bufferService.buffer.ydisp;
          0 !== t3 && this.scrollLines(t3);
        }
        registerEscHandler(e3, t3) {
          return this._inputHandler.registerEscHandler(e3, t3);
        }
        registerDcsHandler(e3, t3) {
          return this._inputHandler.registerDcsHandler(e3, t3);
        }
        registerCsiHandler(e3, t3) {
          return this._inputHandler.registerCsiHandler(e3, t3);
        }
        registerOscHandler(e3, t3) {
          return this._inputHandler.registerOscHandler(e3, t3);
        }
        _setup() {
          this._handleWindowsPtyOptionChange();
        }
        reset() {
          this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
        }
        _handleWindowsPtyOptionChange() {
          let e3 = false;
          const t3 = this.optionsService.rawOptions.windowsPty;
          t3 && void 0 !== t3.buildNumber && void 0 !== t3.buildNumber ? e3 = !!("conpty" === t3.backend && t3.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (e3 = true), e3 ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
        }
        _enableWindowsWrappingHeuristics() {
          if (!this._windowsWrappingHeuristics.value) {
            const e3 = [];
            e3.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e3.push(this.registerCsiHandler({ final: "H" }, () => ((0, f.updateWindowsModeWrappedState)(this._bufferService), false))), this._windowsWrappingHeuristics.value = (0, s2.toDisposable)(() => {
              for (const t3 of e3) t3.dispose();
            });
          }
        }
      }
      t2.CoreTerminal = S;
    }, 8460: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.runAndSubscribe = t2.forwardEvent = t2.EventEmitter = void 0, t2.EventEmitter = class {
        constructor() {
          this._listeners = [], this._disposed = false;
        }
        get event() {
          return this._event || (this._event = (e3) => (this._listeners.push(e3), { dispose: /* @__PURE__ */ __name(() => {
            if (!this._disposed) {
              for (let t3 = 0; t3 < this._listeners.length; t3++) if (this._listeners[t3] === e3) return void this._listeners.splice(t3, 1);
            }
          }, "dispose") })), this._event;
        }
        fire(e3, t3) {
          const i3 = [];
          for (let e4 = 0; e4 < this._listeners.length; e4++) i3.push(this._listeners[e4]);
          for (let s2 = 0; s2 < i3.length; s2++) i3[s2].call(void 0, e3, t3);
        }
        dispose() {
          this.clearListeners(), this._disposed = true;
        }
        clearListeners() {
          this._listeners && (this._listeners.length = 0);
        }
      }, t2.forwardEvent = function(e3, t3) {
        return e3((e4) => t3.fire(e4));
      }, t2.runAndSubscribe = function(e3, t3) {
        return t3(void 0), e3((e4) => t3(e4));
      };
    }, 5435: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.InputHandler = t2.WindowsOptionsReportType = void 0;
      const n = i3(2584), o = i3(7116), a = i3(2015), h2 = i3(844), c = i3(482), l = i3(8437), d = i3(8460), _2 = i3(643), u = i3(511), f = i3(3734), v2 = i3(2585), p2 = i3(1480), g = i3(6242), m = i3(6351), S = i3(5941), C = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, b = 131072;
      function w2(e3, t3) {
        if (e3 > 24) return t3.setWinLines || false;
        switch (e3) {
          case 1:
            return !!t3.restoreWin;
          case 2:
            return !!t3.minimizeWin;
          case 3:
            return !!t3.setWinPosition;
          case 4:
            return !!t3.setWinSizePixels;
          case 5:
            return !!t3.raiseWin;
          case 6:
            return !!t3.lowerWin;
          case 7:
            return !!t3.refreshWin;
          case 8:
            return !!t3.setWinSizeChars;
          case 9:
            return !!t3.maximizeWin;
          case 10:
            return !!t3.fullscreenWin;
          case 11:
            return !!t3.getWinState;
          case 13:
            return !!t3.getWinPosition;
          case 14:
            return !!t3.getWinSizePixels;
          case 15:
            return !!t3.getScreenSizePixels;
          case 16:
            return !!t3.getCellSizePixels;
          case 18:
            return !!t3.getWinSizeChars;
          case 19:
            return !!t3.getScreenSizeChars;
          case 20:
            return !!t3.getIconTitle;
          case 21:
            return !!t3.getWinTitle;
          case 22:
            return !!t3.pushTitle;
          case 23:
            return !!t3.popTitle;
          case 24:
            return !!t3.setWinLines;
        }
        return false;
      }
      __name(w2, "w");
      var y2;
      !function(e3) {
        e3[e3.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e3[e3.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
      }(y2 || (t2.WindowsOptionsReportType = y2 = {}));
      let E = 0;
      class k extends h2.Disposable {
        static {
          __name(this, "k");
        }
        getAttrData() {
          return this._curAttrData;
        }
        constructor(e3, t3, i4, s3, r2, h3, _3, f2, v3 = new a.EscapeSequenceParser()) {
          super(), this._bufferService = e3, this._charsetService = t3, this._coreService = i4, this._logService = s3, this._optionsService = r2, this._oscLinkService = h3, this._coreMouseService = _3, this._unicodeService = f2, this._parser = v3, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32(), this._utf8Decoder = new c.Utf8ToUtf32(), this._workCell = new u.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: false, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new L(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._parser.setCsiHandlerFallback((e4, t4) => {
            this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(e4), params: t4.toArray() });
          }), this._parser.setEscHandlerFallback((e4) => {
            this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(e4) });
          }), this._parser.setExecuteHandlerFallback((e4) => {
            this._logService.debug("Unknown EXECUTE code: ", { code: e4 });
          }), this._parser.setOscHandlerFallback((e4, t4, i5) => {
            this._logService.debug("Unknown OSC code: ", { identifier: e4, action: t4, data: i5 });
          }), this._parser.setDcsHandlerFallback((e4, t4, i5) => {
            "HOOK" === t4 && (i5 = i5.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(e4), action: t4, payload: i5 });
          }), this._parser.setPrintHandler((e4, t4, i5) => this.print(e4, t4, i5)), this._parser.registerCsiHandler({ final: "@" }, (e4) => this.insertChars(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (e4) => this.scrollLeft(e4)), this._parser.registerCsiHandler({ final: "A" }, (e4) => this.cursorUp(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (e4) => this.scrollRight(e4)), this._parser.registerCsiHandler({ final: "B" }, (e4) => this.cursorDown(e4)), this._parser.registerCsiHandler({ final: "C" }, (e4) => this.cursorForward(e4)), this._parser.registerCsiHandler({ final: "D" }, (e4) => this.cursorBackward(e4)), this._parser.registerCsiHandler({ final: "E" }, (e4) => this.cursorNextLine(e4)), this._parser.registerCsiHandler({ final: "F" }, (e4) => this.cursorPrecedingLine(e4)), this._parser.registerCsiHandler({ final: "G" }, (e4) => this.cursorCharAbsolute(e4)), this._parser.registerCsiHandler({ final: "H" }, (e4) => this.cursorPosition(e4)), this._parser.registerCsiHandler({ final: "I" }, (e4) => this.cursorForwardTab(e4)), this._parser.registerCsiHandler({ final: "J" }, (e4) => this.eraseInDisplay(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (e4) => this.eraseInDisplay(e4, true)), this._parser.registerCsiHandler({ final: "K" }, (e4) => this.eraseInLine(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (e4) => this.eraseInLine(e4, true)), this._parser.registerCsiHandler({ final: "L" }, (e4) => this.insertLines(e4)), this._parser.registerCsiHandler({ final: "M" }, (e4) => this.deleteLines(e4)), this._parser.registerCsiHandler({ final: "P" }, (e4) => this.deleteChars(e4)), this._parser.registerCsiHandler({ final: "S" }, (e4) => this.scrollUp(e4)), this._parser.registerCsiHandler({ final: "T" }, (e4) => this.scrollDown(e4)), this._parser.registerCsiHandler({ final: "X" }, (e4) => this.eraseChars(e4)), this._parser.registerCsiHandler({ final: "Z" }, (e4) => this.cursorBackwardTab(e4)), this._parser.registerCsiHandler({ final: "`" }, (e4) => this.charPosAbsolute(e4)), this._parser.registerCsiHandler({ final: "a" }, (e4) => this.hPositionRelative(e4)), this._parser.registerCsiHandler({ final: "b" }, (e4) => this.repeatPrecedingCharacter(e4)), this._parser.registerCsiHandler({ final: "c" }, (e4) => this.sendDeviceAttributesPrimary(e4)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (e4) => this.sendDeviceAttributesSecondary(e4)), this._parser.registerCsiHandler({ final: "d" }, (e4) => this.linePosAbsolute(e4)), this._parser.registerCsiHandler({ final: "e" }, (e4) => this.vPositionRelative(e4)), this._parser.registerCsiHandler({ final: "f" }, (e4) => this.hVPosition(e4)), this._parser.registerCsiHandler({ final: "g" }, (e4) => this.tabClear(e4)), this._parser.registerCsiHandler({ final: "h" }, (e4) => this.setMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (e4) => this.setModePrivate(e4)), this._parser.registerCsiHandler({ final: "l" }, (e4) => this.resetMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (e4) => this.resetModePrivate(e4)), this._parser.registerCsiHandler({ final: "m" }, (e4) => this.charAttributes(e4)), this._parser.registerCsiHandler({ final: "n" }, (e4) => this.deviceStatus(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (e4) => this.deviceStatusPrivate(e4)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (e4) => this.softReset(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (e4) => this.setCursorStyle(e4)), this._parser.registerCsiHandler({ final: "r" }, (e4) => this.setScrollRegion(e4)), this._parser.registerCsiHandler({ final: "s" }, (e4) => this.saveCursor(e4)), this._parser.registerCsiHandler({ final: "t" }, (e4) => this.windowOptions(e4)), this._parser.registerCsiHandler({ final: "u" }, (e4) => this.restoreCursor(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (e4) => this.insertColumns(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (e4) => this.deleteColumns(e4)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (e4) => this.selectProtected(e4)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, true)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, false)), this._parser.setExecuteHandler(n.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n.C1.IND, () => this.index()), this._parser.setExecuteHandler(n.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new g.OscHandler((e4) => (this.setTitle(e4), this.setIconName(e4), true))), this._parser.registerOscHandler(1, new g.OscHandler((e4) => this.setIconName(e4))), this._parser.registerOscHandler(2, new g.OscHandler((e4) => this.setTitle(e4))), this._parser.registerOscHandler(4, new g.OscHandler((e4) => this.setOrReportIndexedColor(e4))), this._parser.registerOscHandler(8, new g.OscHandler((e4) => this.setHyperlink(e4))), this._parser.registerOscHandler(10, new g.OscHandler((e4) => this.setOrReportFgColor(e4))), this._parser.registerOscHandler(11, new g.OscHandler((e4) => this.setOrReportBgColor(e4))), this._parser.registerOscHandler(12, new g.OscHandler((e4) => this.setOrReportCursorColor(e4))), this._parser.registerOscHandler(104, new g.OscHandler((e4) => this.restoreIndexedColor(e4))), this._parser.registerOscHandler(110, new g.OscHandler((e4) => this.restoreFgColor(e4))), this._parser.registerOscHandler(111, new g.OscHandler((e4) => this.restoreBgColor(e4))), this._parser.registerOscHandler(112, new g.OscHandler((e4) => this.restoreCursorColor(e4))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
          for (const e4 in o.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: e4 }, () => this.selectCharset("(" + e4)), this._parser.registerEscHandler({ intermediates: ")", final: e4 }, () => this.selectCharset(")" + e4)), this._parser.registerEscHandler({ intermediates: "*", final: e4 }, () => this.selectCharset("*" + e4)), this._parser.registerEscHandler({ intermediates: "+", final: e4 }, () => this.selectCharset("+" + e4)), this._parser.registerEscHandler({ intermediates: "-", final: e4 }, () => this.selectCharset("-" + e4)), this._parser.registerEscHandler({ intermediates: ".", final: e4 }, () => this.selectCharset("." + e4)), this._parser.registerEscHandler({ intermediates: "/", final: e4 }, () => this.selectCharset("/" + e4));
          this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((e4) => (this._logService.error("Parsing error: ", e4), e4)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new m.DcsHandler((e4, t4) => this.requestStatusString(e4, t4)));
        }
        _preserveStack(e3, t3, i4, s3) {
          this._parseStack.paused = true, this._parseStack.cursorStartX = e3, this._parseStack.cursorStartY = t3, this._parseStack.decodedLength = i4, this._parseStack.position = s3;
        }
        _logSlowResolvingAsync(e3) {
          this._logService.logLevel <= v2.LogLevelEnum.WARN && Promise.race([e3, new Promise((e4, t3) => setTimeout(() => t3("#SLOW_TIMEOUT"), 5e3))]).catch((e4) => {
            if ("#SLOW_TIMEOUT" !== e4) throw e4;
            console.warn("async parser handler taking longer than 5000 ms");
          });
        }
        _getCurrentLinkId() {
          return this._curAttrData.extended.urlId;
        }
        parse(e3, t3) {
          let i4, s3 = this._activeBuffer.x, r2 = this._activeBuffer.y, n2 = 0;
          const o2 = this._parseStack.paused;
          if (o2) {
            if (i4 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t3)) return this._logSlowResolvingAsync(i4), i4;
            s3 = this._parseStack.cursorStartX, r2 = this._parseStack.cursorStartY, this._parseStack.paused = false, e3.length > b && (n2 = this._parseStack.position + b);
          }
          if (this._logService.logLevel <= v2.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + ("string" == typeof e3 ? ` "${e3}"` : ` "${Array.prototype.map.call(e3, (e4) => String.fromCharCode(e4)).join("")}"`), "string" == typeof e3 ? e3.split("").map((e4) => e4.charCodeAt(0)) : e3), this._parseBuffer.length < e3.length && this._parseBuffer.length < b && (this._parseBuffer = new Uint32Array(Math.min(e3.length, b))), o2 || this._dirtyRowTracker.clearRange(), e3.length > b) for (let t4 = n2; t4 < e3.length; t4 += b) {
            const n3 = t4 + b < e3.length ? t4 + b : e3.length, o3 = "string" == typeof e3 ? this._stringDecoder.decode(e3.substring(t4, n3), this._parseBuffer) : this._utf8Decoder.decode(e3.subarray(t4, n3), this._parseBuffer);
            if (i4 = this._parser.parse(this._parseBuffer, o3)) return this._preserveStack(s3, r2, o3, t4), this._logSlowResolvingAsync(i4), i4;
          }
          else if (!o2) {
            const t4 = "string" == typeof e3 ? this._stringDecoder.decode(e3, this._parseBuffer) : this._utf8Decoder.decode(e3, this._parseBuffer);
            if (i4 = this._parser.parse(this._parseBuffer, t4)) return this._preserveStack(s3, r2, t4, 0), this._logSlowResolvingAsync(i4), i4;
          }
          this._activeBuffer.x === s3 && this._activeBuffer.y === r2 || this._onCursorMove.fire();
          const a2 = this._dirtyRowTracker.end + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp), h3 = this._dirtyRowTracker.start + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
          h3 < this._bufferService.rows && this._onRequestRefreshRows.fire(Math.min(h3, this._bufferService.rows - 1), Math.min(a2, this._bufferService.rows - 1));
        }
        print(e3, t3, i4) {
          let s3, r2;
          const n2 = this._charsetService.charset, o2 = this._optionsService.rawOptions.screenReaderMode, a2 = this._bufferService.cols, h3 = this._coreService.decPrivateModes.wraparound, d2 = this._coreService.modes.insertMode, u2 = this._curAttrData;
          let f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i4 - t3 > 0 && 2 === f2.getWidth(this._activeBuffer.x - 1) && f2.setCellFromCodepoint(this._activeBuffer.x - 1, 0, 1, u2);
          let v3 = this._parser.precedingJoinState;
          for (let g2 = t3; g2 < i4; ++g2) {
            if (s3 = e3[g2], s3 < 127 && n2) {
              const e4 = n2[String.fromCharCode(s3)];
              e4 && (s3 = e4.charCodeAt(0));
            }
            const t4 = this._unicodeService.charProperties(s3, v3);
            r2 = p2.UnicodeService.extractWidth(t4);
            const i5 = p2.UnicodeService.extractShouldJoin(t4), m2 = i5 ? p2.UnicodeService.extractWidth(v3) : 0;
            if (v3 = t4, o2 && this._onA11yChar.fire((0, c.stringFromCodePoint)(s3)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), this._activeBuffer.x + r2 - m2 > a2) {
              if (h3) {
                const e4 = f2;
                let t5 = this._activeBuffer.x - m2;
                for (this._activeBuffer.x = m2, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y), m2 > 0 && f2 instanceof l.BufferLine && f2.copyCellsFrom(e4, t5, 0, m2, false); t5 < a2; ) e4.setCellFromCodepoint(t5++, 0, 1, u2);
              } else if (this._activeBuffer.x = a2 - 1, 2 === r2) continue;
            }
            if (i5 && this._activeBuffer.x) {
              const e4 = f2.getWidth(this._activeBuffer.x - 1) ? 1 : 2;
              f2.addCodepointToCell(this._activeBuffer.x - e4, s3, r2);
              for (let e5 = r2 - m2; --e5 >= 0; ) f2.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, u2);
            } else if (d2 && (f2.insertCells(this._activeBuffer.x, r2 - m2, this._activeBuffer.getNullCell(u2)), 2 === f2.getWidth(a2 - 1) && f2.setCellFromCodepoint(a2 - 1, _2.NULL_CELL_CODE, _2.NULL_CELL_WIDTH, u2)), f2.setCellFromCodepoint(this._activeBuffer.x++, s3, r2, u2), r2 > 0) for (; --r2; ) f2.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, u2);
          }
          this._parser.precedingJoinState = v3, this._activeBuffer.x < a2 && i4 - t3 > 0 && 0 === f2.getWidth(this._activeBuffer.x) && !f2.hasContent(this._activeBuffer.x) && f2.setCellFromCodepoint(this._activeBuffer.x, 0, 1, u2), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        registerCsiHandler(e3, t3) {
          return "t" !== e3.final || e3.prefix || e3.intermediates ? this._parser.registerCsiHandler(e3, t3) : this._parser.registerCsiHandler(e3, (e4) => !w2(e4.params[0], this._optionsService.rawOptions.windowOptions) || t3(e4));
        }
        registerDcsHandler(e3, t3) {
          return this._parser.registerDcsHandler(e3, new m.DcsHandler(t3));
        }
        registerEscHandler(e3, t3) {
          return this._parser.registerEscHandler(e3, t3);
        }
        registerOscHandler(e3, t3) {
          return this._parser.registerOscHandler(e3, new g.OscHandler(t3));
        }
        bell() {
          return this._onRequestBell.fire(), true;
        }
        lineFeed() {
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
        }
        carriageReturn() {
          return this._activeBuffer.x = 0, true;
        }
        backspace() {
          if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
          if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
          else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)?.isWrapped) {
            this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
            const e3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            e3.hasWidth(this._activeBuffer.x) && !e3.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
          }
          return this._restrictCursor(), true;
        }
        tab() {
          if (this._activeBuffer.x >= this._bufferService.cols) return true;
          const e3 = this._activeBuffer.x;
          return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e3), true;
        }
        shiftOut() {
          return this._charsetService.setgLevel(1), true;
        }
        shiftIn() {
          return this._charsetService.setgLevel(0), true;
        }
        _restrictCursor(e3 = this._bufferService.cols - 1) {
          this._activeBuffer.x = Math.min(e3, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _setCursor(e3, t3) {
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e3, this._activeBuffer.y = this._activeBuffer.scrollTop + t3) : (this._activeBuffer.x = e3, this._activeBuffer.y = t3), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _moveCursor(e3, t3) {
          this._restrictCursor(), this._setCursor(this._activeBuffer.x + e3, this._activeBuffer.y + t3);
        }
        cursorUp(e3) {
          const t3 = this._activeBuffer.y - this._activeBuffer.scrollTop;
          return t3 >= 0 ? this._moveCursor(0, -Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, -(e3.params[0] || 1)), true;
        }
        cursorDown(e3) {
          const t3 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
          return t3 >= 0 ? this._moveCursor(0, Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, e3.params[0] || 1), true;
        }
        cursorForward(e3) {
          return this._moveCursor(e3.params[0] || 1, 0), true;
        }
        cursorBackward(e3) {
          return this._moveCursor(-(e3.params[0] || 1), 0), true;
        }
        cursorNextLine(e3) {
          return this.cursorDown(e3), this._activeBuffer.x = 0, true;
        }
        cursorPrecedingLine(e3) {
          return this.cursorUp(e3), this._activeBuffer.x = 0, true;
        }
        cursorCharAbsolute(e3) {
          return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
        }
        cursorPosition(e3) {
          return this._setCursor(e3.length >= 2 ? (e3.params[1] || 1) - 1 : 0, (e3.params[0] || 1) - 1), true;
        }
        charPosAbsolute(e3) {
          return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
        }
        hPositionRelative(e3) {
          return this._moveCursor(e3.params[0] || 1, 0), true;
        }
        linePosAbsolute(e3) {
          return this._setCursor(this._activeBuffer.x, (e3.params[0] || 1) - 1), true;
        }
        vPositionRelative(e3) {
          return this._moveCursor(0, e3.params[0] || 1), true;
        }
        hVPosition(e3) {
          return this.cursorPosition(e3), true;
        }
        tabClear(e3) {
          const t3 = e3.params[0];
          return 0 === t3 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t3 && (this._activeBuffer.tabs = {}), true;
        }
        cursorForwardTab(e3) {
          if (this._activeBuffer.x >= this._bufferService.cols) return true;
          let t3 = e3.params[0] || 1;
          for (; t3--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
          return true;
        }
        cursorBackwardTab(e3) {
          if (this._activeBuffer.x >= this._bufferService.cols) return true;
          let t3 = e3.params[0] || 1;
          for (; t3--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
          return true;
        }
        selectProtected(e3) {
          const t3 = e3.params[0];
          return 1 === t3 && (this._curAttrData.bg |= 536870912), 2 !== t3 && 0 !== t3 || (this._curAttrData.bg &= -536870913), true;
        }
        _eraseInBufferLine(e3, t3, i4, s3 = false, r2 = false) {
          const n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
          n2.replaceCells(t3, i4, this._activeBuffer.getNullCell(this._eraseAttrData()), r2), s3 && (n2.isWrapped = false);
        }
        _resetBufferLine(e3, t3 = false) {
          const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
          i4 && (i4.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t3), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e3), i4.isWrapped = false);
        }
        eraseInDisplay(e3, t3 = false) {
          let i4;
          switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
            case 0:
              for (i4 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i4), this._eraseInBufferLine(i4++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3); i4 < this._bufferService.rows; i4++) this._resetBufferLine(i4, t3);
              this._dirtyRowTracker.markDirty(i4);
              break;
            case 1:
              for (i4 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i4), this._eraseInBufferLine(i4, 0, this._activeBuffer.x + 1, true, t3), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i4 + 1).isWrapped = false); i4--; ) this._resetBufferLine(i4, t3);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 2:
              for (i4 = this._bufferService.rows, this._dirtyRowTracker.markDirty(i4 - 1); i4--; ) this._resetBufferLine(i4, t3);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 3:
              const e4 = this._activeBuffer.lines.length - this._bufferService.rows;
              e4 > 0 && (this._activeBuffer.lines.trimStart(e4), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e4, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e4, 0), this._onScroll.fire(0));
          }
          return true;
        }
        eraseInLine(e3, t3 = false) {
          switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
            case 0:
              this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3);
              break;
            case 1:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, t3);
              break;
            case 2:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, t3);
          }
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
        }
        insertLines(e3) {
          this._restrictCursor();
          let t3 = e3.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
          const i4 = this._activeBuffer.ybase + this._activeBuffer.y, s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r2 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3 + 1;
          for (; t3--; ) this._activeBuffer.lines.splice(r2 - 1, 1), this._activeBuffer.lines.splice(i4, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
        }
        deleteLines(e3) {
          this._restrictCursor();
          let t3 = e3.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
          const i4 = this._activeBuffer.ybase + this._activeBuffer.y;
          let s3;
          for (s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s3 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3; t3--; ) this._activeBuffer.lines.splice(i4, 1), this._activeBuffer.lines.splice(s3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
        }
        insertChars(e3) {
          this._restrictCursor();
          const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return t3 && (t3.insertCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        deleteChars(e3) {
          this._restrictCursor();
          const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return t3 && (t3.deleteCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        scrollUp(e3) {
          let t3 = e3.params[0] || 1;
          for (; t3--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollDown(e3) {
          let t3 = e3.params[0] || 1;
          for (; t3--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollLeft(e3) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
          const t3 = e3.params[0] || 1;
          for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
            const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i4.deleteCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData())), i4.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollRight(e3) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
          const t3 = e3.params[0] || 1;
          for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
            const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i4.insertCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData())), i4.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        insertColumns(e3) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
          const t3 = e3.params[0] || 1;
          for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
            const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i4.insertCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData())), i4.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        deleteColumns(e3) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
          const t3 = e3.params[0] || 1;
          for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
            const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
            i4.deleteCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData())), i4.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        eraseChars(e3) {
          this._restrictCursor();
          const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return t3 && (t3.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e3.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        repeatPrecedingCharacter(e3) {
          const t3 = this._parser.precedingJoinState;
          if (!t3) return true;
          const i4 = e3.params[0] || 1, s3 = p2.UnicodeService.extractWidth(t3), r2 = this._activeBuffer.x - s3, n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).getString(r2), o2 = new Uint32Array(n2.length * i4);
          let a2 = 0;
          for (let e4 = 0; e4 < n2.length; ) {
            const t4 = n2.codePointAt(e4) || 0;
            o2[a2++] = t4, e4 += t4 > 65535 ? 2 : 1;
          }
          let h3 = a2;
          for (let e4 = 1; e4 < i4; ++e4) o2.copyWithin(h3, 0, a2), h3 += a2;
          return this.print(o2, 0, h3), true;
        }
        sendDeviceAttributesPrimary(e3) {
          return e3.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), true;
        }
        sendDeviceAttributesSecondary(e3) {
          return e3.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e3.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), true;
        }
        _is(e3) {
          return 0 === (this._optionsService.rawOptions.termName + "").indexOf(e3);
        }
        setMode(e3) {
          for (let t3 = 0; t3 < e3.length; t3++) switch (e3.params[t3]) {
            case 4:
              this._coreService.modes.insertMode = true;
              break;
            case 20:
              this._optionsService.options.convertEol = true;
          }
          return true;
        }
        setModePrivate(e3) {
          for (let t3 = 0; t3 < e3.length; t3++) switch (e3.params[t3]) {
            case 1:
              this._coreService.decPrivateModes.applicationCursorKeys = true;
              break;
            case 2:
              this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
              break;
            case 3:
              this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
              break;
            case 6:
              this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
              break;
            case 7:
              this._coreService.decPrivateModes.wraparound = true;
              break;
            case 12:
              this._optionsService.options.cursorBlink = true;
              break;
            case 45:
              this._coreService.decPrivateModes.reverseWraparound = true;
              break;
            case 66:
              this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
              break;
            case 9:
              this._coreMouseService.activeProtocol = "X10";
              break;
            case 1e3:
              this._coreMouseService.activeProtocol = "VT200";
              break;
            case 1002:
              this._coreMouseService.activeProtocol = "DRAG";
              break;
            case 1003:
              this._coreMouseService.activeProtocol = "ANY";
              break;
            case 1004:
              this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
              break;
            case 1005:
              this._logService.debug("DECSET 1005 not supported (see #2507)");
              break;
            case 1006:
              this._coreMouseService.activeEncoding = "SGR";
              break;
            case 1015:
              this._logService.debug("DECSET 1015 not supported (see #2507)");
              break;
            case 1016:
              this._coreMouseService.activeEncoding = "SGR_PIXELS";
              break;
            case 25:
              this._coreService.isCursorHidden = false;
              break;
            case 1048:
              this.saveCursor();
              break;
            case 1049:
              this.saveCursor();
            case 47:
            case 1047:
              this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
              break;
            case 2004:
              this._coreService.decPrivateModes.bracketedPasteMode = true;
          }
          return true;
        }
        resetMode(e3) {
          for (let t3 = 0; t3 < e3.length; t3++) switch (e3.params[t3]) {
            case 4:
              this._coreService.modes.insertMode = false;
              break;
            case 20:
              this._optionsService.options.convertEol = false;
          }
          return true;
        }
        resetModePrivate(e3) {
          for (let t3 = 0; t3 < e3.length; t3++) switch (e3.params[t3]) {
            case 1:
              this._coreService.decPrivateModes.applicationCursorKeys = false;
              break;
            case 3:
              this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
              break;
            case 6:
              this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
              break;
            case 7:
              this._coreService.decPrivateModes.wraparound = false;
              break;
            case 12:
              this._optionsService.options.cursorBlink = false;
              break;
            case 45:
              this._coreService.decPrivateModes.reverseWraparound = false;
              break;
            case 66:
              this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
              break;
            case 9:
            case 1e3:
            case 1002:
            case 1003:
              this._coreMouseService.activeProtocol = "NONE";
              break;
            case 1004:
              this._coreService.decPrivateModes.sendFocus = false;
              break;
            case 1005:
              this._logService.debug("DECRST 1005 not supported (see #2507)");
              break;
            case 1006:
            case 1016:
              this._coreMouseService.activeEncoding = "DEFAULT";
              break;
            case 1015:
              this._logService.debug("DECRST 1015 not supported (see #2507)");
              break;
            case 25:
              this._coreService.isCursorHidden = true;
              break;
            case 1048:
              this.restoreCursor();
              break;
            case 1049:
            case 47:
            case 1047:
              this._bufferService.buffers.activateNormalBuffer(), 1049 === e3.params[t3] && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
              break;
            case 2004:
              this._coreService.decPrivateModes.bracketedPasteMode = false;
          }
          return true;
        }
        requestMode(e3, t3) {
          const i4 = this._coreService.decPrivateModes, { activeProtocol: s3, activeEncoding: r2 } = this._coreMouseService, o2 = this._coreService, { buffers: a2, cols: h3 } = this._bufferService, { active: c2, alt: l2 } = a2, d2 = this._optionsService.rawOptions, _3 = /* @__PURE__ */ __name((e4) => e4 ? 1 : 2, "_"), u2 = e3.params[0];
          return f2 = u2, v3 = t3 ? 2 === u2 ? 4 : 4 === u2 ? _3(o2.modes.insertMode) : 12 === u2 ? 3 : 20 === u2 ? _3(d2.convertEol) : 0 : 1 === u2 ? _3(i4.applicationCursorKeys) : 3 === u2 ? d2.windowOptions.setWinLines ? 80 === h3 ? 2 : 132 === h3 ? 1 : 0 : 0 : 6 === u2 ? _3(i4.origin) : 7 === u2 ? _3(i4.wraparound) : 8 === u2 ? 3 : 9 === u2 ? _3("X10" === s3) : 12 === u2 ? _3(d2.cursorBlink) : 25 === u2 ? _3(!o2.isCursorHidden) : 45 === u2 ? _3(i4.reverseWraparound) : 66 === u2 ? _3(i4.applicationKeypad) : 67 === u2 ? 4 : 1e3 === u2 ? _3("VT200" === s3) : 1002 === u2 ? _3("DRAG" === s3) : 1003 === u2 ? _3("ANY" === s3) : 1004 === u2 ? _3(i4.sendFocus) : 1005 === u2 ? 4 : 1006 === u2 ? _3("SGR" === r2) : 1015 === u2 ? 4 : 1016 === u2 ? _3("SGR_PIXELS" === r2) : 1048 === u2 ? 1 : 47 === u2 || 1047 === u2 || 1049 === u2 ? _3(c2 === l2) : 2004 === u2 ? _3(i4.bracketedPasteMode) : 0, o2.triggerDataEvent(`${n.C0.ESC}[${t3 ? "" : "?"}${f2};${v3}$y`), true;
          var f2, v3;
        }
        _updateAttrColor(e3, t3, i4, s3, r2) {
          return 2 === t3 ? (e3 |= 50331648, e3 &= -16777216, e3 |= f.AttributeData.fromColorRGB([i4, s3, r2])) : 5 === t3 && (e3 &= -50331904, e3 |= 33554432 | 255 & i4), e3;
        }
        _extractColor(e3, t3, i4) {
          const s3 = [0, 0, -1, 0, 0, 0];
          let r2 = 0, n2 = 0;
          do {
            if (s3[n2 + r2] = e3.params[t3 + n2], e3.hasSubParams(t3 + n2)) {
              const i5 = e3.getSubParams(t3 + n2);
              let o2 = 0;
              do {
                5 === s3[1] && (r2 = 1), s3[n2 + o2 + 1 + r2] = i5[o2];
              } while (++o2 < i5.length && o2 + n2 + 1 + r2 < s3.length);
              break;
            }
            if (5 === s3[1] && n2 + r2 >= 2 || 2 === s3[1] && n2 + r2 >= 5) break;
            s3[1] && (r2 = 1);
          } while (++n2 + t3 < e3.length && n2 + r2 < s3.length);
          for (let e4 = 2; e4 < s3.length; ++e4) -1 === s3[e4] && (s3[e4] = 0);
          switch (s3[0]) {
            case 38:
              i4.fg = this._updateAttrColor(i4.fg, s3[1], s3[3], s3[4], s3[5]);
              break;
            case 48:
              i4.bg = this._updateAttrColor(i4.bg, s3[1], s3[3], s3[4], s3[5]);
              break;
            case 58:
              i4.extended = i4.extended.clone(), i4.extended.underlineColor = this._updateAttrColor(i4.extended.underlineColor, s3[1], s3[3], s3[4], s3[5]);
          }
          return n2;
        }
        _processUnderline(e3, t3) {
          t3.extended = t3.extended.clone(), (!~e3 || e3 > 5) && (e3 = 1), t3.extended.underlineStyle = e3, t3.fg |= 268435456, 0 === e3 && (t3.fg &= -268435457), t3.updateExtended();
        }
        _processSGR0(e3) {
          e3.fg = l.DEFAULT_ATTR_DATA.fg, e3.bg = l.DEFAULT_ATTR_DATA.bg, e3.extended = e3.extended.clone(), e3.extended.underlineStyle = 0, e3.extended.underlineColor &= -67108864, e3.updateExtended();
        }
        charAttributes(e3) {
          if (1 === e3.length && 0 === e3.params[0]) return this._processSGR0(this._curAttrData), true;
          const t3 = e3.length;
          let i4;
          const s3 = this._curAttrData;
          for (let r2 = 0; r2 < t3; r2++) i4 = e3.params[r2], i4 >= 30 && i4 <= 37 ? (s3.fg &= -50331904, s3.fg |= 16777216 | i4 - 30) : i4 >= 40 && i4 <= 47 ? (s3.bg &= -50331904, s3.bg |= 16777216 | i4 - 40) : i4 >= 90 && i4 <= 97 ? (s3.fg &= -50331904, s3.fg |= 16777224 | i4 - 90) : i4 >= 100 && i4 <= 107 ? (s3.bg &= -50331904, s3.bg |= 16777224 | i4 - 100) : 0 === i4 ? this._processSGR0(s3) : 1 === i4 ? s3.fg |= 134217728 : 3 === i4 ? s3.bg |= 67108864 : 4 === i4 ? (s3.fg |= 268435456, this._processUnderline(e3.hasSubParams(r2) ? e3.getSubParams(r2)[0] : 1, s3)) : 5 === i4 ? s3.fg |= 536870912 : 7 === i4 ? s3.fg |= 67108864 : 8 === i4 ? s3.fg |= 1073741824 : 9 === i4 ? s3.fg |= 2147483648 : 2 === i4 ? s3.bg |= 134217728 : 21 === i4 ? this._processUnderline(2, s3) : 22 === i4 ? (s3.fg &= -134217729, s3.bg &= -134217729) : 23 === i4 ? s3.bg &= -67108865 : 24 === i4 ? (s3.fg &= -268435457, this._processUnderline(0, s3)) : 25 === i4 ? s3.fg &= -536870913 : 27 === i4 ? s3.fg &= -67108865 : 28 === i4 ? s3.fg &= -1073741825 : 29 === i4 ? s3.fg &= 2147483647 : 39 === i4 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : 49 === i4 ? (s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : 38 === i4 || 48 === i4 || 58 === i4 ? r2 += this._extractColor(e3, r2, s3) : 53 === i4 ? s3.bg |= 1073741824 : 55 === i4 ? s3.bg &= -1073741825 : 59 === i4 ? (s3.extended = s3.extended.clone(), s3.extended.underlineColor = -1, s3.updateExtended()) : 100 === i4 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i4);
          return true;
        }
        deviceStatus(e3) {
          switch (e3.params[0]) {
            case 5:
              this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
              break;
            case 6:
              const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${n.C0.ESC}[${e4};${t3}R`);
          }
          return true;
        }
        deviceStatusPrivate(e3) {
          if (6 === e3.params[0]) {
            const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
            this._coreService.triggerDataEvent(`${n.C0.ESC}[?${e4};${t3}R`);
          }
          return true;
        }
        softReset(e3) {
          return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
        }
        setCursorStyle(e3) {
          const t3 = e3.params[0] || 1;
          switch (t3) {
            case 1:
            case 2:
              this._optionsService.options.cursorStyle = "block";
              break;
            case 3:
            case 4:
              this._optionsService.options.cursorStyle = "underline";
              break;
            case 5:
            case 6:
              this._optionsService.options.cursorStyle = "bar";
          }
          const i4 = t3 % 2 == 1;
          return this._optionsService.options.cursorBlink = i4, true;
        }
        setScrollRegion(e3) {
          const t3 = e3.params[0] || 1;
          let i4;
          return (e3.length < 2 || (i4 = e3.params[1]) > this._bufferService.rows || 0 === i4) && (i4 = this._bufferService.rows), i4 > t3 && (this._activeBuffer.scrollTop = t3 - 1, this._activeBuffer.scrollBottom = i4 - 1, this._setCursor(0, 0)), true;
        }
        windowOptions(e3) {
          if (!w2(e3.params[0], this._optionsService.rawOptions.windowOptions)) return true;
          const t3 = e3.length > 1 ? e3.params[1] : 0;
          switch (e3.params[0]) {
            case 14:
              2 !== t3 && this._onRequestWindowsOptionsReport.fire(y2.GET_WIN_SIZE_PIXELS);
              break;
            case 16:
              this._onRequestWindowsOptionsReport.fire(y2.GET_CELL_SIZE_PIXELS);
              break;
            case 18:
              this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
              break;
            case 22:
              0 !== t3 && 2 !== t3 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t3 && 1 !== t3 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
              break;
            case 23:
              0 !== t3 && 2 !== t3 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t3 && 1 !== t3 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
          }
          return true;
        }
        saveCursor(e3) {
          return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
        }
        restoreCursor(e3) {
          return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
        }
        setTitle(e3) {
          return this._windowTitle = e3, this._onTitleChange.fire(e3), true;
        }
        setIconName(e3) {
          return this._iconName = e3, true;
        }
        setOrReportIndexedColor(e3) {
          const t3 = [], i4 = e3.split(";");
          for (; i4.length > 1; ) {
            const e4 = i4.shift(), s3 = i4.shift();
            if (/^\d+$/.exec(e4)) {
              const i5 = parseInt(e4);
              if (D(i5)) if ("?" === s3) t3.push({ type: 0, index: i5 });
              else {
                const e5 = (0, S.parseColor)(s3);
                e5 && t3.push({ type: 1, index: i5, color: e5 });
              }
            }
          }
          return t3.length && this._onColor.fire(t3), true;
        }
        setHyperlink(e3) {
          const t3 = e3.split(";");
          return !(t3.length < 2) && (t3[1] ? this._createHyperlink(t3[0], t3[1]) : !t3[0] && this._finishHyperlink());
        }
        _createHyperlink(e3, t3) {
          this._getCurrentLinkId() && this._finishHyperlink();
          const i4 = e3.split(":");
          let s3;
          const r2 = i4.findIndex((e4) => e4.startsWith("id="));
          return -1 !== r2 && (s3 = i4[r2].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: s3, uri: t3 }), this._curAttrData.updateExtended(), true;
        }
        _finishHyperlink() {
          return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
        }
        _setOrReportSpecialColor(e3, t3) {
          const i4 = e3.split(";");
          for (let e4 = 0; e4 < i4.length && !(t3 >= this._specialColors.length); ++e4, ++t3) if ("?" === i4[e4]) this._onColor.fire([{ type: 0, index: this._specialColors[t3] }]);
          else {
            const s3 = (0, S.parseColor)(i4[e4]);
            s3 && this._onColor.fire([{ type: 1, index: this._specialColors[t3], color: s3 }]);
          }
          return true;
        }
        setOrReportFgColor(e3) {
          return this._setOrReportSpecialColor(e3, 0);
        }
        setOrReportBgColor(e3) {
          return this._setOrReportSpecialColor(e3, 1);
        }
        setOrReportCursorColor(e3) {
          return this._setOrReportSpecialColor(e3, 2);
        }
        restoreIndexedColor(e3) {
          if (!e3) return this._onColor.fire([{ type: 2 }]), true;
          const t3 = [], i4 = e3.split(";");
          for (let e4 = 0; e4 < i4.length; ++e4) if (/^\d+$/.exec(i4[e4])) {
            const s3 = parseInt(i4[e4]);
            D(s3) && t3.push({ type: 2, index: s3 });
          }
          return t3.length && this._onColor.fire(t3), true;
        }
        restoreFgColor(e3) {
          return this._onColor.fire([{ type: 2, index: 256 }]), true;
        }
        restoreBgColor(e3) {
          return this._onColor.fire([{ type: 2, index: 257 }]), true;
        }
        restoreCursorColor(e3) {
          return this._onColor.fire([{ type: 2, index: 258 }]), true;
        }
        nextLine() {
          return this._activeBuffer.x = 0, this.index(), true;
        }
        keypadApplicationMode() {
          return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
        }
        keypadNumericMode() {
          return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
        }
        selectDefaultCharset() {
          return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), true;
        }
        selectCharset(e3) {
          return 2 !== e3.length ? (this.selectDefaultCharset(), true) : ("/" === e3[0] || this._charsetService.setgCharset(C[e3[0]], o.CHARSETS[e3[1]] || o.DEFAULT_CHARSET), true);
        }
        index() {
          return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
        }
        tabSet() {
          return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
        }
        reverseIndex() {
          if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
            const e3 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
            this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e3, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
          } else this._activeBuffer.y--, this._restrictCursor();
          return true;
        }
        fullReset() {
          return this._parser.reset(), this._onRequestReset.fire(), true;
        }
        reset() {
          this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
        }
        _eraseAttrData() {
          return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
        }
        setgLevel(e3) {
          return this._charsetService.setgLevel(e3), true;
        }
        screenAlignmentPattern() {
          const e3 = new u.CellData();
          e3.content = 1 << 22 | "E".charCodeAt(0), e3.fg = this._curAttrData.fg, e3.bg = this._curAttrData.bg, this._setCursor(0, 0);
          for (let t3 = 0; t3 < this._bufferService.rows; ++t3) {
            const i4 = this._activeBuffer.ybase + this._activeBuffer.y + t3, s3 = this._activeBuffer.lines.get(i4);
            s3 && (s3.fill(e3), s3.isWrapped = false);
          }
          return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
        }
        requestStatusString(e3, t3) {
          const i4 = this._bufferService.buffer, s3 = this._optionsService.rawOptions;
          return ((e4) => (this._coreService.triggerDataEvent(`${n.C0.ESC}${e4}${n.C0.ESC}\\`), true))('"q' === e3 ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : '"p' === e3 ? 'P1$r61;1"p' : "r" === e3 ? `P1$r${i4.scrollTop + 1};${i4.scrollBottom + 1}r` : "m" === e3 ? "P1$r0m" : " q" === e3 ? `P1$r${{ block: 2, underline: 4, bar: 6 }[s3.cursorStyle] - (s3.cursorBlink ? 1 : 0)} q` : "P0$r");
        }
        markRangeDirty(e3, t3) {
          this._dirtyRowTracker.markRangeDirty(e3, t3);
        }
      }
      t2.InputHandler = k;
      let L = class {
        static {
          __name(this, "L");
        }
        constructor(e3) {
          this._bufferService = e3, this.clearRange();
        }
        clearRange() {
          this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
        }
        markDirty(e3) {
          e3 < this.start ? this.start = e3 : e3 > this.end && (this.end = e3);
        }
        markRangeDirty(e3, t3) {
          e3 > t3 && (E = e3, e3 = t3, t3 = E), e3 < this.start && (this.start = e3), t3 > this.end && (this.end = t3);
        }
        markAllDirty() {
          this.markRangeDirty(0, this._bufferService.rows - 1);
        }
      };
      function D(e3) {
        return 0 <= e3 && e3 < 256;
      }
      __name(D, "D");
      L = s2([r(0, v2.IBufferService)], L);
    }, 844: (e2, t2) => {
      function i3(e3) {
        for (const t3 of e3) t3.dispose();
        e3.length = 0;
      }
      __name(i3, "i");
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getDisposeArrayDisposable = t2.disposeArray = t2.toDisposable = t2.MutableDisposable = t2.Disposable = void 0, t2.Disposable = class {
        constructor() {
          this._disposables = [], this._isDisposed = false;
        }
        dispose() {
          this._isDisposed = true;
          for (const e3 of this._disposables) e3.dispose();
          this._disposables.length = 0;
        }
        register(e3) {
          return this._disposables.push(e3), e3;
        }
        unregister(e3) {
          const t3 = this._disposables.indexOf(e3);
          -1 !== t3 && this._disposables.splice(t3, 1);
        }
      }, t2.MutableDisposable = class {
        constructor() {
          this._isDisposed = false;
        }
        get value() {
          return this._isDisposed ? void 0 : this._value;
        }
        set value(e3) {
          this._isDisposed || e3 === this._value || (this._value?.dispose(), this._value = e3);
        }
        clear() {
          this.value = void 0;
        }
        dispose() {
          this._isDisposed = true, this._value?.dispose(), this._value = void 0;
        }
      }, t2.toDisposable = function(e3) {
        return { dispose: e3 };
      }, t2.disposeArray = i3, t2.getDisposeArrayDisposable = function(e3) {
        return { dispose: /* @__PURE__ */ __name(() => i3(e3), "dispose") };
      };
    }, 1505: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.FourKeyMap = t2.TwoKeyMap = void 0;
      class i3 {
        static {
          __name(this, "i");
        }
        constructor() {
          this._data = {};
        }
        set(e3, t3, i4) {
          this._data[e3] || (this._data[e3] = {}), this._data[e3][t3] = i4;
        }
        get(e3, t3) {
          return this._data[e3] ? this._data[e3][t3] : void 0;
        }
        clear() {
          this._data = {};
        }
      }
      t2.TwoKeyMap = i3, t2.FourKeyMap = class {
        constructor() {
          this._data = new i3();
        }
        set(e3, t3, s2, r, n) {
          this._data.get(e3, t3) || this._data.set(e3, t3, new i3()), this._data.get(e3, t3).set(s2, r, n);
        }
        get(e3, t3, i4, s2) {
          return this._data.get(e3, t3)?.get(i4, s2);
        }
        clear() {
          this._data.clear();
        }
      };
    }, 6114: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.isChromeOS = t2.isLinux = t2.isWindows = t2.isIphone = t2.isIpad = t2.isMac = t2.getSafariVersion = t2.isSafari = t2.isLegacyEdge = t2.isFirefox = t2.isNode = void 0, t2.isNode = "undefined" != typeof process && "title" in process;
      const i3 = t2.isNode ? "node" : navigator.userAgent, s2 = t2.isNode ? "node" : navigator.platform;
      t2.isFirefox = i3.includes("Firefox"), t2.isLegacyEdge = i3.includes("Edge"), t2.isSafari = /^((?!chrome|android).)*safari/i.test(i3), t2.getSafariVersion = function() {
        if (!t2.isSafari) return 0;
        const e3 = i3.match(/Version\/(\d+)/);
        return null === e3 || e3.length < 2 ? 0 : parseInt(e3[1]);
      }, t2.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(s2), t2.isIpad = "iPad" === s2, t2.isIphone = "iPhone" === s2, t2.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(s2), t2.isLinux = s2.indexOf("Linux") >= 0, t2.isChromeOS = /\bCrOS\b/.test(i3);
    }, 6106: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.SortedList = void 0;
      let i3 = 0;
      t2.SortedList = class {
        constructor(e3) {
          this._getKey = e3, this._array = [];
        }
        clear() {
          this._array.length = 0;
        }
        insert(e3) {
          0 !== this._array.length ? (i3 = this._search(this._getKey(e3)), this._array.splice(i3, 0, e3)) : this._array.push(e3);
        }
        delete(e3) {
          if (0 === this._array.length) return false;
          const t3 = this._getKey(e3);
          if (void 0 === t3) return false;
          if (i3 = this._search(t3), -1 === i3) return false;
          if (this._getKey(this._array[i3]) !== t3) return false;
          do {
            if (this._array[i3] === e3) return this._array.splice(i3, 1), true;
          } while (++i3 < this._array.length && this._getKey(this._array[i3]) === t3);
          return false;
        }
        *getKeyIterator(e3) {
          if (0 !== this._array.length && (i3 = this._search(e3), !(i3 < 0 || i3 >= this._array.length) && this._getKey(this._array[i3]) === e3)) do {
            yield this._array[i3];
          } while (++i3 < this._array.length && this._getKey(this._array[i3]) === e3);
        }
        forEachByKey(e3, t3) {
          if (0 !== this._array.length && (i3 = this._search(e3), !(i3 < 0 || i3 >= this._array.length) && this._getKey(this._array[i3]) === e3)) do {
            t3(this._array[i3]);
          } while (++i3 < this._array.length && this._getKey(this._array[i3]) === e3);
        }
        values() {
          return [...this._array].values();
        }
        _search(e3) {
          let t3 = 0, i4 = this._array.length - 1;
          for (; i4 >= t3; ) {
            let s2 = t3 + i4 >> 1;
            const r = this._getKey(this._array[s2]);
            if (r > e3) i4 = s2 - 1;
            else {
              if (!(r < e3)) {
                for (; s2 > 0 && this._getKey(this._array[s2 - 1]) === e3; ) s2--;
                return s2;
              }
              t3 = s2 + 1;
            }
          }
          return t3;
        }
      };
    }, 7226: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DebouncedIdleTask = t2.IdleTaskQueue = t2.PriorityTaskQueue = void 0;
      const s2 = i3(6114);
      class r {
        static {
          __name(this, "r");
        }
        constructor() {
          this._tasks = [], this._i = 0;
        }
        enqueue(e3) {
          this._tasks.push(e3), this._start();
        }
        flush() {
          for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
          this.clear();
        }
        clear() {
          this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
        }
        _start() {
          this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
        }
        _process(e3) {
          this._idleCallback = void 0;
          let t3 = 0, i4 = 0, s3 = e3.timeRemaining(), r2 = 0;
          for (; this._i < this._tasks.length; ) {
            if (t3 = Date.now(), this._tasks[this._i]() || this._i++, t3 = Math.max(1, Date.now() - t3), i4 = Math.max(t3, i4), r2 = e3.timeRemaining(), 1.5 * i4 > r2) return s3 - t3 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t3))}ms`), void this._start();
            s3 = r2;
          }
          this.clear();
        }
      }
      class n extends r {
        static {
          __name(this, "n");
        }
        _requestCallback(e3) {
          return setTimeout(() => e3(this._createDeadline(16)));
        }
        _cancelCallback(e3) {
          clearTimeout(e3);
        }
        _createDeadline(e3) {
          const t3 = Date.now() + e3;
          return { timeRemaining: /* @__PURE__ */ __name(() => Math.max(0, t3 - Date.now()), "timeRemaining") };
        }
      }
      t2.PriorityTaskQueue = n, t2.IdleTaskQueue = !s2.isNode && "requestIdleCallback" in window ? class extends r {
        _requestCallback(e3) {
          return requestIdleCallback(e3);
        }
        _cancelCallback(e3) {
          cancelIdleCallback(e3);
        }
      } : n, t2.DebouncedIdleTask = class {
        constructor() {
          this._queue = new t2.IdleTaskQueue();
        }
        set(e3) {
          this._queue.clear(), this._queue.enqueue(e3);
        }
        flush() {
          this._queue.flush();
        }
      };
    }, 9282: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.updateWindowsModeWrappedState = void 0;
      const s2 = i3(643);
      t2.updateWindowsModeWrappedState = function(e3) {
        const t3 = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y - 1), i4 = t3?.get(e3.cols - 1), r = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y);
        r && i4 && (r.isWrapped = i4[s2.CHAR_DATA_CODE_INDEX] !== s2.NULL_CELL_CODE && i4[s2.CHAR_DATA_CODE_INDEX] !== s2.WHITESPACE_CELL_CODE);
      };
    }, 3734: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ExtendedAttrs = t2.AttributeData = void 0;
      class i3 {
        static {
          __name(this, "i");
        }
        constructor() {
          this.fg = 0, this.bg = 0, this.extended = new s2();
        }
        static toColorRGB(e3) {
          return [e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
        }
        static fromColorRGB(e3) {
          return (255 & e3[0]) << 16 | (255 & e3[1]) << 8 | 255 & e3[2];
        }
        clone() {
          const e3 = new i3();
          return e3.fg = this.fg, e3.bg = this.bg, e3.extended = this.extended.clone(), e3;
        }
        isInverse() {
          return 67108864 & this.fg;
        }
        isBold() {
          return 134217728 & this.fg;
        }
        isUnderline() {
          return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
        }
        isBlink() {
          return 536870912 & this.fg;
        }
        isInvisible() {
          return 1073741824 & this.fg;
        }
        isItalic() {
          return 67108864 & this.bg;
        }
        isDim() {
          return 134217728 & this.bg;
        }
        isStrikethrough() {
          return 2147483648 & this.fg;
        }
        isProtected() {
          return 536870912 & this.bg;
        }
        isOverline() {
          return 1073741824 & this.bg;
        }
        getFgColorMode() {
          return 50331648 & this.fg;
        }
        getBgColorMode() {
          return 50331648 & this.bg;
        }
        isFgRGB() {
          return 50331648 == (50331648 & this.fg);
        }
        isBgRGB() {
          return 50331648 == (50331648 & this.bg);
        }
        isFgPalette() {
          return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
        }
        isBgPalette() {
          return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
        }
        isFgDefault() {
          return 0 == (50331648 & this.fg);
        }
        isBgDefault() {
          return 0 == (50331648 & this.bg);
        }
        isAttributeDefault() {
          return 0 === this.fg && 0 === this.bg;
        }
        getFgColor() {
          switch (50331648 & this.fg) {
            case 16777216:
            case 33554432:
              return 255 & this.fg;
            case 50331648:
              return 16777215 & this.fg;
            default:
              return -1;
          }
        }
        getBgColor() {
          switch (50331648 & this.bg) {
            case 16777216:
            case 33554432:
              return 255 & this.bg;
            case 50331648:
              return 16777215 & this.bg;
            default:
              return -1;
          }
        }
        hasExtendedAttrs() {
          return 268435456 & this.bg;
        }
        updateExtended() {
          this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
        }
        getUnderlineColor() {
          if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
            case 16777216:
            case 33554432:
              return 255 & this.extended.underlineColor;
            case 50331648:
              return 16777215 & this.extended.underlineColor;
            default:
              return this.getFgColor();
          }
          return this.getFgColor();
        }
        getUnderlineColorMode() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
        }
        isUnderlineColorRGB() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
        }
        isUnderlineColorPalette() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
        }
        isUnderlineColorDefault() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
        }
        getUnderlineStyle() {
          return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
        }
        getUnderlineVariantOffset() {
          return this.extended.underlineVariantOffset;
        }
      }
      t2.AttributeData = i3;
      class s2 {
        static {
          __name(this, "s");
        }
        get ext() {
          return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
        }
        set ext(e3) {
          this._ext = e3;
        }
        get underlineStyle() {
          return this._urlId ? 5 : (469762048 & this._ext) >> 26;
        }
        set underlineStyle(e3) {
          this._ext &= -469762049, this._ext |= e3 << 26 & 469762048;
        }
        get underlineColor() {
          return 67108863 & this._ext;
        }
        set underlineColor(e3) {
          this._ext &= -67108864, this._ext |= 67108863 & e3;
        }
        get urlId() {
          return this._urlId;
        }
        set urlId(e3) {
          this._urlId = e3;
        }
        get underlineVariantOffset() {
          const e3 = (3758096384 & this._ext) >> 29;
          return e3 < 0 ? 4294967288 ^ e3 : e3;
        }
        set underlineVariantOffset(e3) {
          this._ext &= 536870911, this._ext |= e3 << 29 & 3758096384;
        }
        constructor(e3 = 0, t3 = 0) {
          this._ext = 0, this._urlId = 0, this._ext = e3, this._urlId = t3;
        }
        clone() {
          return new s2(this._ext, this._urlId);
        }
        isEmpty() {
          return 0 === this.underlineStyle && 0 === this._urlId;
        }
      }
      t2.ExtendedAttrs = s2;
    }, 9092: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Buffer = t2.MAX_BUFFER_SIZE = void 0;
      const s2 = i3(6349), r = i3(7226), n = i3(3734), o = i3(8437), a = i3(4634), h2 = i3(511), c = i3(643), l = i3(4863), d = i3(7116);
      t2.MAX_BUFFER_SIZE = 4294967295, t2.Buffer = class {
        constructor(e3, t3, i4) {
          this._hasScrollback = e3, this._optionsService = t3, this._bufferService = i4, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = o.DEFAULT_ATTR_DATA.clone(), this.savedCharset = d.DEFAULT_CHARSET, this.markers = [], this._nullCell = h2.CellData.fromCharData([0, c.NULL_CELL_CHAR, c.NULL_CELL_WIDTH, c.NULL_CELL_CODE]), this._whitespaceCell = h2.CellData.fromCharData([0, c.WHITESPACE_CELL_CHAR, c.WHITESPACE_CELL_WIDTH, c.WHITESPACE_CELL_CODE]), this._isClearing = false, this._memoryCleanupQueue = new r.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        getNullCell(e3) {
          return e3 ? (this._nullCell.fg = e3.fg, this._nullCell.bg = e3.bg, this._nullCell.extended = e3.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs()), this._nullCell;
        }
        getWhitespaceCell(e3) {
          return e3 ? (this._whitespaceCell.fg = e3.fg, this._whitespaceCell.bg = e3.bg, this._whitespaceCell.extended = e3.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs()), this._whitespaceCell;
        }
        getBlankLine(e3, t3) {
          return new o.BufferLine(this._bufferService.cols, this.getNullCell(e3), t3);
        }
        get hasScrollback() {
          return this._hasScrollback && this.lines.maxLength > this._rows;
        }
        get isCursorInViewport() {
          const e3 = this.ybase + this.y - this.ydisp;
          return e3 >= 0 && e3 < this._rows;
        }
        _getCorrectBufferLength(e3) {
          if (!this._hasScrollback) return e3;
          const i4 = e3 + this._optionsService.rawOptions.scrollback;
          return i4 > t2.MAX_BUFFER_SIZE ? t2.MAX_BUFFER_SIZE : i4;
        }
        fillViewportRows(e3) {
          if (0 === this.lines.length) {
            void 0 === e3 && (e3 = o.DEFAULT_ATTR_DATA);
            let t3 = this._rows;
            for (; t3--; ) this.lines.push(this.getBlankLine(e3));
          }
        }
        clear() {
          this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        resize(e3, t3) {
          const i4 = this.getNullCell(o.DEFAULT_ATTR_DATA);
          let s3 = 0;
          const r2 = this._getCorrectBufferLength(t3);
          if (r2 > this.lines.maxLength && (this.lines.maxLength = r2), this.lines.length > 0) {
            if (this._cols < e3) for (let t4 = 0; t4 < this.lines.length; t4++) s3 += +this.lines.get(t4).resize(e3, i4);
            let n2 = 0;
            if (this._rows < t3) for (let s4 = this._rows; s4 < t3; s4++) this.lines.length < t3 + this.ybase && (this._optionsService.rawOptions.windowsMode || void 0 !== this._optionsService.rawOptions.windowsPty.backend || void 0 !== this._optionsService.rawOptions.windowsPty.buildNumber ? this.lines.push(new o.BufferLine(e3, i4)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + n2 + 1 ? (this.ybase--, n2++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new o.BufferLine(e3, i4)));
            else for (let e4 = this._rows; e4 > t3; e4--) this.lines.length > t3 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
            if (r2 < this.lines.maxLength) {
              const e4 = this.lines.length - r2;
              e4 > 0 && (this.lines.trimStart(e4), this.ybase = Math.max(this.ybase - e4, 0), this.ydisp = Math.max(this.ydisp - e4, 0), this.savedY = Math.max(this.savedY - e4, 0)), this.lines.maxLength = r2;
            }
            this.x = Math.min(this.x, e3 - 1), this.y = Math.min(this.y, t3 - 1), n2 && (this.y += n2), this.savedX = Math.min(this.savedX, e3 - 1), this.scrollTop = 0;
          }
          if (this.scrollBottom = t3 - 1, this._isReflowEnabled && (this._reflow(e3, t3), this._cols > e3)) for (let t4 = 0; t4 < this.lines.length; t4++) s3 += +this.lines.get(t4).resize(e3, i4);
          this._cols = e3, this._rows = t3, this._memoryCleanupQueue.clear(), s3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
        }
        _batchedMemoryCleanup() {
          let e3 = true;
          this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e3 = false);
          let t3 = 0;
          for (; this._memoryCleanupPosition < this.lines.length; ) if (t3 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t3 > 100) return true;
          return e3;
        }
        get _isReflowEnabled() {
          const e3 = this._optionsService.rawOptions.windowsPty;
          return e3 && e3.buildNumber ? this._hasScrollback && "conpty" === e3.backend && e3.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
        }
        _reflow(e3, t3) {
          this._cols !== e3 && (e3 > this._cols ? this._reflowLarger(e3, t3) : this._reflowSmaller(e3, t3));
        }
        _reflowLarger(e3, t3) {
          const i4 = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e3, this.ybase + this.y, this.getNullCell(o.DEFAULT_ATTR_DATA));
          if (i4.length > 0) {
            const s3 = (0, a.reflowLargerCreateNewLayout)(this.lines, i4);
            (0, a.reflowLargerApplyNewLayout)(this.lines, s3.layout), this._reflowLargerAdjustViewport(e3, t3, s3.countRemoved);
          }
        }
        _reflowLargerAdjustViewport(e3, t3, i4) {
          const s3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
          let r2 = i4;
          for (; r2-- > 0; ) 0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t3 && this.lines.push(new o.BufferLine(e3, s3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
          this.savedY = Math.max(this.savedY - i4, 0);
        }
        _reflowSmaller(e3, t3) {
          const i4 = this.getNullCell(o.DEFAULT_ATTR_DATA), s3 = [];
          let r2 = 0;
          for (let n2 = this.lines.length - 1; n2 >= 0; n2--) {
            let h3 = this.lines.get(n2);
            if (!h3 || !h3.isWrapped && h3.getTrimmedLength() <= e3) continue;
            const c2 = [h3];
            for (; h3.isWrapped && n2 > 0; ) h3 = this.lines.get(--n2), c2.unshift(h3);
            const l2 = this.ybase + this.y;
            if (l2 >= n2 && l2 < n2 + c2.length) continue;
            const d2 = c2[c2.length - 1].getTrimmedLength(), _2 = (0, a.reflowSmallerGetNewLineLengths)(c2, this._cols, e3), u = _2.length - c2.length;
            let f;
            f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
            const v2 = [];
            for (let e4 = 0; e4 < u; e4++) {
              const e5 = this.getBlankLine(o.DEFAULT_ATTR_DATA, true);
              v2.push(e5);
            }
            v2.length > 0 && (s3.push({ start: n2 + c2.length + r2, newLines: v2 }), r2 += v2.length), c2.push(...v2);
            let p2 = _2.length - 1, g = _2[p2];
            0 === g && (p2--, g = _2[p2]);
            let m = c2.length - u - 1, S = d2;
            for (; m >= 0; ) {
              const e4 = Math.min(S, g);
              if (void 0 === c2[p2]) break;
              if (c2[p2].copyCellsFrom(c2[m], S - e4, g - e4, e4, true), g -= e4, 0 === g && (p2--, g = _2[p2]), S -= e4, 0 === S) {
                m--;
                const e5 = Math.max(m, 0);
                S = (0, a.getWrappedLineTrimmedLength)(c2, e5, this._cols);
              }
            }
            for (let t4 = 0; t4 < c2.length; t4++) _2[t4] < e3 && c2[t4].setCell(_2[t4], i4);
            let C = u - f;
            for (; C-- > 0; ) 0 === this.ybase ? this.y < t3 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + r2) - t3 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
            this.savedY = Math.min(this.savedY + u, this.ybase + t3 - 1);
          }
          if (s3.length > 0) {
            const e4 = [], t4 = [];
            for (let e5 = 0; e5 < this.lines.length; e5++) t4.push(this.lines.get(e5));
            const i5 = this.lines.length;
            let n2 = i5 - 1, o2 = 0, a2 = s3[o2];
            this.lines.length = Math.min(this.lines.maxLength, this.lines.length + r2);
            let h3 = 0;
            for (let c3 = Math.min(this.lines.maxLength - 1, i5 + r2 - 1); c3 >= 0; c3--) if (a2 && a2.start > n2 + h3) {
              for (let e5 = a2.newLines.length - 1; e5 >= 0; e5--) this.lines.set(c3--, a2.newLines[e5]);
              c3++, e4.push({ index: n2 + 1, amount: a2.newLines.length }), h3 += a2.newLines.length, a2 = s3[++o2];
            } else this.lines.set(c3, t4[n2--]);
            let c2 = 0;
            for (let t5 = e4.length - 1; t5 >= 0; t5--) e4[t5].index += c2, this.lines.onInsertEmitter.fire(e4[t5]), c2 += e4[t5].amount;
            const l2 = Math.max(0, i5 + r2 - this.lines.maxLength);
            l2 > 0 && this.lines.onTrimEmitter.fire(l2);
          }
        }
        translateBufferLineToString(e3, t3, i4 = 0, s3) {
          const r2 = this.lines.get(e3);
          return r2 ? r2.translateToString(t3, i4, s3) : "";
        }
        getWrappedRangeForLine(e3) {
          let t3 = e3, i4 = e3;
          for (; t3 > 0 && this.lines.get(t3).isWrapped; ) t3--;
          for (; i4 + 1 < this.lines.length && this.lines.get(i4 + 1).isWrapped; ) i4++;
          return { first: t3, last: i4 };
        }
        setupTabStops(e3) {
          for (null != e3 ? this.tabs[e3] || (e3 = this.prevStop(e3)) : (this.tabs = {}, e3 = 0); e3 < this._cols; e3 += this._optionsService.rawOptions.tabStopWidth) this.tabs[e3] = true;
        }
        prevStop(e3) {
          for (null == e3 && (e3 = this.x); !this.tabs[--e3] && e3 > 0; ) ;
          return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
        }
        nextStop(e3) {
          for (null == e3 && (e3 = this.x); !this.tabs[++e3] && e3 < this._cols; ) ;
          return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
        }
        clearMarkers(e3) {
          this._isClearing = true;
          for (let t3 = 0; t3 < this.markers.length; t3++) this.markers[t3].line === e3 && (this.markers[t3].dispose(), this.markers.splice(t3--, 1));
          this._isClearing = false;
        }
        clearAllMarkers() {
          this._isClearing = true;
          for (let e3 = 0; e3 < this.markers.length; e3++) this.markers[e3].dispose(), this.markers.splice(e3--, 1);
          this._isClearing = false;
        }
        addMarker(e3) {
          const t3 = new l.Marker(e3);
          return this.markers.push(t3), t3.register(this.lines.onTrim((e4) => {
            t3.line -= e4, t3.line < 0 && t3.dispose();
          })), t3.register(this.lines.onInsert((e4) => {
            t3.line >= e4.index && (t3.line += e4.amount);
          })), t3.register(this.lines.onDelete((e4) => {
            t3.line >= e4.index && t3.line < e4.index + e4.amount && t3.dispose(), t3.line > e4.index && (t3.line -= e4.amount);
          })), t3.register(t3.onDispose(() => this._removeMarker(t3))), t3;
        }
        _removeMarker(e3) {
          this._isClearing || this.markers.splice(this.markers.indexOf(e3), 1);
        }
      };
    }, 8437: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLine = t2.DEFAULT_ATTR_DATA = void 0;
      const s2 = i3(3734), r = i3(511), n = i3(643), o = i3(482);
      t2.DEFAULT_ATTR_DATA = Object.freeze(new s2.AttributeData());
      let a = 0;
      class h2 {
        static {
          __name(this, "h");
        }
        constructor(e3, t3, i4 = false) {
          this.isWrapped = i4, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e3);
          const s3 = t3 || r.CellData.fromCharData([0, n.NULL_CELL_CHAR, n.NULL_CELL_WIDTH, n.NULL_CELL_CODE]);
          for (let t4 = 0; t4 < e3; ++t4) this.setCell(t4, s3);
          this.length = e3;
        }
        get(e3) {
          const t3 = this._data[3 * e3 + 0], i4 = 2097151 & t3;
          return [this._data[3 * e3 + 1], 2097152 & t3 ? this._combined[e3] : i4 ? (0, o.stringFromCodePoint)(i4) : "", t3 >> 22, 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : i4];
        }
        set(e3, t3) {
          this._data[3 * e3 + 1] = t3[n.CHAR_DATA_ATTR_INDEX], t3[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e3] = t3[1], this._data[3 * e3 + 0] = 2097152 | e3 | t3[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e3 + 0] = t3[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t3[n.CHAR_DATA_WIDTH_INDEX] << 22;
        }
        getWidth(e3) {
          return this._data[3 * e3 + 0] >> 22;
        }
        hasWidth(e3) {
          return 12582912 & this._data[3 * e3 + 0];
        }
        getFg(e3) {
          return this._data[3 * e3 + 1];
        }
        getBg(e3) {
          return this._data[3 * e3 + 2];
        }
        hasContent(e3) {
          return 4194303 & this._data[3 * e3 + 0];
        }
        getCodePoint(e3) {
          const t3 = this._data[3 * e3 + 0];
          return 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : 2097151 & t3;
        }
        isCombined(e3) {
          return 2097152 & this._data[3 * e3 + 0];
        }
        getString(e3) {
          const t3 = this._data[3 * e3 + 0];
          return 2097152 & t3 ? this._combined[e3] : 2097151 & t3 ? (0, o.stringFromCodePoint)(2097151 & t3) : "";
        }
        isProtected(e3) {
          return 536870912 & this._data[3 * e3 + 2];
        }
        loadCell(e3, t3) {
          return a = 3 * e3, t3.content = this._data[a + 0], t3.fg = this._data[a + 1], t3.bg = this._data[a + 2], 2097152 & t3.content && (t3.combinedData = this._combined[e3]), 268435456 & t3.bg && (t3.extended = this._extendedAttrs[e3]), t3;
        }
        setCell(e3, t3) {
          2097152 & t3.content && (this._combined[e3] = t3.combinedData), 268435456 & t3.bg && (this._extendedAttrs[e3] = t3.extended), this._data[3 * e3 + 0] = t3.content, this._data[3 * e3 + 1] = t3.fg, this._data[3 * e3 + 2] = t3.bg;
        }
        setCellFromCodepoint(e3, t3, i4, s3) {
          268435456 & s3.bg && (this._extendedAttrs[e3] = s3.extended), this._data[3 * e3 + 0] = t3 | i4 << 22, this._data[3 * e3 + 1] = s3.fg, this._data[3 * e3 + 2] = s3.bg;
        }
        addCodepointToCell(e3, t3, i4) {
          let s3 = this._data[3 * e3 + 0];
          2097152 & s3 ? this._combined[e3] += (0, o.stringFromCodePoint)(t3) : 2097151 & s3 ? (this._combined[e3] = (0, o.stringFromCodePoint)(2097151 & s3) + (0, o.stringFromCodePoint)(t3), s3 &= -2097152, s3 |= 2097152) : s3 = t3 | 1 << 22, i4 && (s3 &= -12582913, s3 |= i4 << 22), this._data[3 * e3 + 0] = s3;
        }
        insertCells(e3, t3, i4) {
          if ((e3 %= this.length) && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i4), t3 < this.length - e3) {
            const s3 = new r.CellData();
            for (let i5 = this.length - e3 - t3 - 1; i5 >= 0; --i5) this.setCell(e3 + t3 + i5, this.loadCell(e3 + i5, s3));
            for (let s4 = 0; s4 < t3; ++s4) this.setCell(e3 + s4, i4);
          } else for (let t4 = e3; t4 < this.length; ++t4) this.setCell(t4, i4);
          2 === this.getWidth(this.length - 1) && this.setCellFromCodepoint(this.length - 1, 0, 1, i4);
        }
        deleteCells(e3, t3, i4) {
          if (e3 %= this.length, t3 < this.length - e3) {
            const s3 = new r.CellData();
            for (let i5 = 0; i5 < this.length - e3 - t3; ++i5) this.setCell(e3 + i5, this.loadCell(e3 + t3 + i5, s3));
            for (let e4 = this.length - t3; e4 < this.length; ++e4) this.setCell(e4, i4);
          } else for (let t4 = e3; t4 < this.length; ++t4) this.setCell(t4, i4);
          e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i4), 0 !== this.getWidth(e3) || this.hasContent(e3) || this.setCellFromCodepoint(e3, 0, 1, i4);
        }
        replaceCells(e3, t3, i4, s3 = false) {
          if (s3) for (e3 && 2 === this.getWidth(e3 - 1) && !this.isProtected(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i4), t3 < this.length && 2 === this.getWidth(t3 - 1) && !this.isProtected(t3) && this.setCellFromCodepoint(t3, 0, 1, i4); e3 < t3 && e3 < this.length; ) this.isProtected(e3) || this.setCell(e3, i4), e3++;
          else for (e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i4), t3 < this.length && 2 === this.getWidth(t3 - 1) && this.setCellFromCodepoint(t3, 0, 1, i4); e3 < t3 && e3 < this.length; ) this.setCell(e3++, i4);
        }
        resize(e3, t3) {
          if (e3 === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
          const i4 = 3 * e3;
          if (e3 > this.length) {
            if (this._data.buffer.byteLength >= 4 * i4) this._data = new Uint32Array(this._data.buffer, 0, i4);
            else {
              const e4 = new Uint32Array(i4);
              e4.set(this._data), this._data = e4;
            }
            for (let i5 = this.length; i5 < e3; ++i5) this.setCell(i5, t3);
          } else {
            this._data = this._data.subarray(0, i4);
            const t4 = Object.keys(this._combined);
            for (let i5 = 0; i5 < t4.length; i5++) {
              const s4 = parseInt(t4[i5], 10);
              s4 >= e3 && delete this._combined[s4];
            }
            const s3 = Object.keys(this._extendedAttrs);
            for (let t5 = 0; t5 < s3.length; t5++) {
              const i5 = parseInt(s3[t5], 10);
              i5 >= e3 && delete this._extendedAttrs[i5];
            }
          }
          return this.length = e3, 4 * i4 * 2 < this._data.buffer.byteLength;
        }
        cleanupMemory() {
          if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
            const e3 = new Uint32Array(this._data.length);
            return e3.set(this._data), this._data = e3, 1;
          }
          return 0;
        }
        fill(e3, t3 = false) {
          if (t3) for (let t4 = 0; t4 < this.length; ++t4) this.isProtected(t4) || this.setCell(t4, e3);
          else {
            this._combined = {}, this._extendedAttrs = {};
            for (let t4 = 0; t4 < this.length; ++t4) this.setCell(t4, e3);
          }
        }
        copyFrom(e3) {
          this.length !== e3.length ? this._data = new Uint32Array(e3._data) : this._data.set(e3._data), this.length = e3.length, this._combined = {};
          for (const t3 in e3._combined) this._combined[t3] = e3._combined[t3];
          this._extendedAttrs = {};
          for (const t3 in e3._extendedAttrs) this._extendedAttrs[t3] = e3._extendedAttrs[t3];
          this.isWrapped = e3.isWrapped;
        }
        clone() {
          const e3 = new h2(0);
          e3._data = new Uint32Array(this._data), e3.length = this.length;
          for (const t3 in this._combined) e3._combined[t3] = this._combined[t3];
          for (const t3 in this._extendedAttrs) e3._extendedAttrs[t3] = this._extendedAttrs[t3];
          return e3.isWrapped = this.isWrapped, e3;
        }
        getTrimmedLength() {
          for (let e3 = this.length - 1; e3 >= 0; --e3) if (4194303 & this._data[3 * e3 + 0]) return e3 + (this._data[3 * e3 + 0] >> 22);
          return 0;
        }
        getNoBgTrimmedLength() {
          for (let e3 = this.length - 1; e3 >= 0; --e3) if (4194303 & this._data[3 * e3 + 0] || 50331648 & this._data[3 * e3 + 2]) return e3 + (this._data[3 * e3 + 0] >> 22);
          return 0;
        }
        copyCellsFrom(e3, t3, i4, s3, r2) {
          const n2 = e3._data;
          if (r2) for (let r3 = s3 - 1; r3 >= 0; r3--) {
            for (let e4 = 0; e4 < 3; e4++) this._data[3 * (i4 + r3) + e4] = n2[3 * (t3 + r3) + e4];
            268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i4 + r3] = e3._extendedAttrs[t3 + r3]);
          }
          else for (let r3 = 0; r3 < s3; r3++) {
            for (let e4 = 0; e4 < 3; e4++) this._data[3 * (i4 + r3) + e4] = n2[3 * (t3 + r3) + e4];
            268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i4 + r3] = e3._extendedAttrs[t3 + r3]);
          }
          const o2 = Object.keys(e3._combined);
          for (let s4 = 0; s4 < o2.length; s4++) {
            const r3 = parseInt(o2[s4], 10);
            r3 >= t3 && (this._combined[r3 - t3 + i4] = e3._combined[r3]);
          }
        }
        translateToString(e3, t3, i4, s3) {
          t3 = t3 ?? 0, i4 = i4 ?? this.length, e3 && (i4 = Math.min(i4, this.getTrimmedLength())), s3 && (s3.length = 0);
          let r2 = "";
          for (; t3 < i4; ) {
            const e4 = this._data[3 * t3 + 0], i5 = 2097151 & e4, a2 = 2097152 & e4 ? this._combined[t3] : i5 ? (0, o.stringFromCodePoint)(i5) : n.WHITESPACE_CELL_CHAR;
            if (r2 += a2, s3) for (let e5 = 0; e5 < a2.length; ++e5) s3.push(t3);
            t3 += e4 >> 22 || 1;
          }
          return s3 && s3.push(t3), r2;
        }
      }
      t2.BufferLine = h2;
    }, 4841: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getRangeLength = void 0, t2.getRangeLength = function(e3, t3) {
        if (e3.start.y > e3.end.y) throw new Error(`Buffer range end (${e3.end.x}, ${e3.end.y}) cannot be before start (${e3.start.x}, ${e3.start.y})`);
        return t3 * (e3.end.y - e3.start.y) + (e3.end.x - e3.start.x + 1);
      };
    }, 4634: (e2, t2) => {
      function i3(e3, t3, i4) {
        if (t3 === e3.length - 1) return e3[t3].getTrimmedLength();
        const s2 = !e3[t3].hasContent(i4 - 1) && 1 === e3[t3].getWidth(i4 - 1), r = 2 === e3[t3 + 1].getWidth(0);
        return s2 && r ? i4 - 1 : i4;
      }
      __name(i3, "i");
      Object.defineProperty(t2, "__esModule", { value: true }), t2.getWrappedLineTrimmedLength = t2.reflowSmallerGetNewLineLengths = t2.reflowLargerApplyNewLayout = t2.reflowLargerCreateNewLayout = t2.reflowLargerGetLinesToRemove = void 0, t2.reflowLargerGetLinesToRemove = function(e3, t3, s2, r, n) {
        const o = [];
        for (let a = 0; a < e3.length - 1; a++) {
          let h2 = a, c = e3.get(++h2);
          if (!c.isWrapped) continue;
          const l = [e3.get(a)];
          for (; h2 < e3.length && c.isWrapped; ) l.push(c), c = e3.get(++h2);
          if (r >= a && r < h2) {
            a += l.length - 1;
            continue;
          }
          let d = 0, _2 = i3(l, d, t3), u = 1, f = 0;
          for (; u < l.length; ) {
            const e4 = i3(l, u, t3), r2 = e4 - f, o2 = s2 - _2, a2 = Math.min(r2, o2);
            l[d].copyCellsFrom(l[u], f, _2, a2, false), _2 += a2, _2 === s2 && (d++, _2 = 0), f += a2, f === e4 && (u++, f = 0), 0 === _2 && 0 !== d && 2 === l[d - 1].getWidth(s2 - 1) && (l[d].copyCellsFrom(l[d - 1], s2 - 1, _2++, 1, false), l[d - 1].setCell(s2 - 1, n));
          }
          l[d].replaceCells(_2, s2, n);
          let v2 = 0;
          for (let e4 = l.length - 1; e4 > 0 && (e4 > d || 0 === l[e4].getTrimmedLength()); e4--) v2++;
          v2 > 0 && (o.push(a + l.length - v2), o.push(v2)), a += l.length - 1;
        }
        return o;
      }, t2.reflowLargerCreateNewLayout = function(e3, t3) {
        const i4 = [];
        let s2 = 0, r = t3[s2], n = 0;
        for (let o = 0; o < e3.length; o++) if (r === o) {
          const i5 = t3[++s2];
          e3.onDeleteEmitter.fire({ index: o - n, amount: i5 }), o += i5 - 1, n += i5, r = t3[++s2];
        } else i4.push(o);
        return { layout: i4, countRemoved: n };
      }, t2.reflowLargerApplyNewLayout = function(e3, t3) {
        const i4 = [];
        for (let s2 = 0; s2 < t3.length; s2++) i4.push(e3.get(t3[s2]));
        for (let t4 = 0; t4 < i4.length; t4++) e3.set(t4, i4[t4]);
        e3.length = t3.length;
      }, t2.reflowSmallerGetNewLineLengths = function(e3, t3, s2) {
        const r = [], n = e3.map((s3, r2) => i3(e3, r2, t3)).reduce((e4, t4) => e4 + t4);
        let o = 0, a = 0, h2 = 0;
        for (; h2 < n; ) {
          if (n - h2 < s2) {
            r.push(n - h2);
            break;
          }
          o += s2;
          const c = i3(e3, a, t3);
          o > c && (o -= c, a++);
          const l = 2 === e3[a].getWidth(o - 1);
          l && o--;
          const d = l ? s2 - 1 : s2;
          r.push(d), h2 += d;
        }
        return r;
      }, t2.getWrappedLineTrimmedLength = i3;
    }, 5295: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferSet = void 0;
      const s2 = i3(8460), r = i3(844), n = i3(9092);
      class o extends r.Disposable {
        static {
          __name(this, "o");
        }
        constructor(e3, t3) {
          super(), this._optionsService = e3, this._bufferService = t3, this._onBufferActivate = this.register(new s2.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
        }
        reset() {
          this._normal = new n.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
        }
        get alt() {
          return this._alt;
        }
        get active() {
          return this._activeBuffer;
        }
        get normal() {
          return this._normal;
        }
        activateNormalBuffer() {
          this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
        }
        activateAltBuffer(e3) {
          this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e3), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
        }
        resize(e3, t3) {
          this._normal.resize(e3, t3), this._alt.resize(e3, t3), this.setupTabStops(e3);
        }
        setupTabStops(e3) {
          this._normal.setupTabStops(e3), this._alt.setupTabStops(e3);
        }
      }
      t2.BufferSet = o;
    }, 511: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CellData = void 0;
      const s2 = i3(482), r = i3(643), n = i3(3734);
      class o extends n.AttributeData {
        static {
          __name(this, "o");
        }
        constructor() {
          super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs(), this.combinedData = "";
        }
        static fromCharData(e3) {
          const t3 = new o();
          return t3.setFromCharData(e3), t3;
        }
        isCombined() {
          return 2097152 & this.content;
        }
        getWidth() {
          return this.content >> 22;
        }
        getChars() {
          return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
        }
        getCode() {
          return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
        }
        setFromCharData(e3) {
          this.fg = e3[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
          let t3 = false;
          if (e3[r.CHAR_DATA_CHAR_INDEX].length > 2) t3 = true;
          else if (2 === e3[r.CHAR_DATA_CHAR_INDEX].length) {
            const i4 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
            if (55296 <= i4 && i4 <= 56319) {
              const s3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
              56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i4 - 55296) + s3 - 56320 + 65536 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22 : t3 = true;
            } else t3 = true;
          } else this.content = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e3[r.CHAR_DATA_WIDTH_INDEX] << 22;
          t3 && (this.combinedData = e3[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22);
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      t2.CellData = o;
    }, 643: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WHITESPACE_CELL_CODE = t2.WHITESPACE_CELL_WIDTH = t2.WHITESPACE_CELL_CHAR = t2.NULL_CELL_CODE = t2.NULL_CELL_WIDTH = t2.NULL_CELL_CHAR = t2.CHAR_DATA_CODE_INDEX = t2.CHAR_DATA_WIDTH_INDEX = t2.CHAR_DATA_CHAR_INDEX = t2.CHAR_DATA_ATTR_INDEX = t2.DEFAULT_EXT = t2.DEFAULT_ATTR = t2.DEFAULT_COLOR = void 0, t2.DEFAULT_COLOR = 0, t2.DEFAULT_ATTR = 256 | t2.DEFAULT_COLOR << 9, t2.DEFAULT_EXT = 0, t2.CHAR_DATA_ATTR_INDEX = 0, t2.CHAR_DATA_CHAR_INDEX = 1, t2.CHAR_DATA_WIDTH_INDEX = 2, t2.CHAR_DATA_CODE_INDEX = 3, t2.NULL_CELL_CHAR = "", t2.NULL_CELL_WIDTH = 1, t2.NULL_CELL_CODE = 0, t2.WHITESPACE_CELL_CHAR = " ", t2.WHITESPACE_CELL_WIDTH = 1, t2.WHITESPACE_CELL_CODE = 32;
    }, 4863: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Marker = void 0;
      const s2 = i3(8460), r = i3(844);
      class n {
        static {
          __name(this, "n");
        }
        get id() {
          return this._id;
        }
        constructor(e3) {
          this.line = e3, this.isDisposed = false, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new s2.EventEmitter()), this.onDispose = this._onDispose.event;
        }
        dispose() {
          this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
        }
        register(e3) {
          return this._disposables.push(e3), e3;
        }
      }
      t2.Marker = n, n._nextId = 1;
    }, 7116: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_CHARSET = t2.CHARSETS = void 0, t2.CHARSETS = {}, t2.DEFAULT_CHARSET = t2.CHARSETS.B, t2.CHARSETS[0] = { "`": "", a: "", b: "", c: "", d: "", e: "", f: "", g: "", h: "", i: "", j: "", k: "", l: "", m: "", n: "", o: "", p: "", q: "", r: "", s: "", t: "", u: "", v: "", w: "", x: "", y: "", z: "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.A = { "#": "" }, t2.CHARSETS.B = void 0, t2.CHARSETS[4] = { "#": "", "@": "", "[": "ij", "\\": "", "]": "|", "{": "", "|": "f", "}": "", "~": "" }, t2.CHARSETS.C = t2.CHARSETS[5] = { "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.R = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.Q = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.K = { "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.Y = { "#": "", "@": "", "[": "", "\\": "", "]": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.E = t2.CHARSETS[6] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.Z = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "" }, t2.CHARSETS.H = t2.CHARSETS[7] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS["="] = { "#": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "" };
    }, 2584: (e2, t2) => {
      var i3, s2, r;
      Object.defineProperty(t2, "__esModule", { value: true }), t2.C1_ESCAPED = t2.C1 = t2.C0 = void 0, function(e3) {
        e3.NUL = "\0", e3.SOH = "", e3.STX = "", e3.ETX = "", e3.EOT = "", e3.ENQ = "", e3.ACK = "", e3.BEL = "\x07", e3.BS = "\b", e3.HT = "	", e3.LF = "\n", e3.VT = "\v", e3.FF = "\f", e3.CR = "\r", e3.SO = "", e3.SI = "", e3.DLE = "", e3.DC1 = "", e3.DC2 = "", e3.DC3 = "", e3.DC4 = "", e3.NAK = "", e3.SYN = "", e3.ETB = "", e3.CAN = "", e3.EM = "", e3.SUB = "", e3.ESC = "\x1B", e3.FS = "", e3.GS = "", e3.RS = "", e3.US = "", e3.SP = " ", e3.DEL = "";
      }(i3 || (t2.C0 = i3 = {})), function(e3) {
        e3.PAD = "", e3.HOP = "", e3.BPH = "", e3.NBH = "", e3.IND = "", e3.NEL = "", e3.SSA = "", e3.ESA = "", e3.HTS = "", e3.HTJ = "", e3.VTS = "", e3.PLD = "", e3.PLU = "", e3.RI = "", e3.SS2 = "", e3.SS3 = "", e3.DCS = "", e3.PU1 = "", e3.PU2 = "", e3.STS = "", e3.CCH = "", e3.MW = "", e3.SPA = "", e3.EPA = "", e3.SOS = "", e3.SGCI = "", e3.SCI = "", e3.CSI = "", e3.ST = "", e3.OSC = "", e3.PM = "", e3.APC = "";
      }(s2 || (t2.C1 = s2 = {})), function(e3) {
        e3.ST = `${i3.ESC}\\`;
      }(r || (t2.C1_ESCAPED = r = {}));
    }, 7399: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluateKeyboardEvent = void 0;
      const s2 = i3(2584), r = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
      t2.evaluateKeyboardEvent = function(e3, t3, i4, n) {
        const o = { type: 0, cancel: false, key: void 0 }, a = (e3.shiftKey ? 1 : 0) | (e3.altKey ? 2 : 0) | (e3.ctrlKey ? 4 : 0) | (e3.metaKey ? 8 : 0);
        switch (e3.keyCode) {
          case 0:
            "UIKeyInputUpArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A" : "UIKeyInputLeftArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D" : "UIKeyInputRightArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C" : "UIKeyInputDownArrow" === e3.key && (o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B");
            break;
          case 8:
            o.key = e3.ctrlKey ? "\b" : s2.C0.DEL, e3.altKey && (o.key = s2.C0.ESC + o.key);
            break;
          case 9:
            if (e3.shiftKey) {
              o.key = s2.C0.ESC + "[Z";
              break;
            }
            o.key = s2.C0.HT, o.cancel = true;
            break;
          case 13:
            o.key = e3.altKey ? s2.C0.ESC + s2.C0.CR : s2.C0.CR, o.cancel = true;
            break;
          case 27:
            o.key = s2.C0.ESC, e3.altKey && (o.key = s2.C0.ESC + s2.C0.ESC), o.cancel = true;
            break;
          case 37:
            if (e3.metaKey) break;
            a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "D", o.key === s2.C0.ESC + "[1;3D" && (o.key = s2.C0.ESC + (i4 ? "b" : "[1;5D"))) : o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D";
            break;
          case 39:
            if (e3.metaKey) break;
            a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "C", o.key === s2.C0.ESC + "[1;3C" && (o.key = s2.C0.ESC + (i4 ? "f" : "[1;5C"))) : o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C";
            break;
          case 38:
            if (e3.metaKey) break;
            a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "A", i4 || o.key !== s2.C0.ESC + "[1;3A" || (o.key = s2.C0.ESC + "[1;5A")) : o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A";
            break;
          case 40:
            if (e3.metaKey) break;
            a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "B", i4 || o.key !== s2.C0.ESC + "[1;3B" || (o.key = s2.C0.ESC + "[1;5B")) : o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B";
            break;
          case 45:
            e3.shiftKey || e3.ctrlKey || (o.key = s2.C0.ESC + "[2~");
            break;
          case 46:
            o.key = a ? s2.C0.ESC + "[3;" + (a + 1) + "~" : s2.C0.ESC + "[3~";
            break;
          case 36:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "H" : t3 ? s2.C0.ESC + "OH" : s2.C0.ESC + "[H";
            break;
          case 35:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "F" : t3 ? s2.C0.ESC + "OF" : s2.C0.ESC + "[F";
            break;
          case 33:
            e3.shiftKey ? o.type = 2 : e3.ctrlKey ? o.key = s2.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[5~";
            break;
          case 34:
            e3.shiftKey ? o.type = 3 : e3.ctrlKey ? o.key = s2.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[6~";
            break;
          case 112:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "P" : s2.C0.ESC + "OP";
            break;
          case 113:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "Q" : s2.C0.ESC + "OQ";
            break;
          case 114:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "R" : s2.C0.ESC + "OR";
            break;
          case 115:
            o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "S" : s2.C0.ESC + "OS";
            break;
          case 116:
            o.key = a ? s2.C0.ESC + "[15;" + (a + 1) + "~" : s2.C0.ESC + "[15~";
            break;
          case 117:
            o.key = a ? s2.C0.ESC + "[17;" + (a + 1) + "~" : s2.C0.ESC + "[17~";
            break;
          case 118:
            o.key = a ? s2.C0.ESC + "[18;" + (a + 1) + "~" : s2.C0.ESC + "[18~";
            break;
          case 119:
            o.key = a ? s2.C0.ESC + "[19;" + (a + 1) + "~" : s2.C0.ESC + "[19~";
            break;
          case 120:
            o.key = a ? s2.C0.ESC + "[20;" + (a + 1) + "~" : s2.C0.ESC + "[20~";
            break;
          case 121:
            o.key = a ? s2.C0.ESC + "[21;" + (a + 1) + "~" : s2.C0.ESC + "[21~";
            break;
          case 122:
            o.key = a ? s2.C0.ESC + "[23;" + (a + 1) + "~" : s2.C0.ESC + "[23~";
            break;
          case 123:
            o.key = a ? s2.C0.ESC + "[24;" + (a + 1) + "~" : s2.C0.ESC + "[24~";
            break;
          default:
            if (!e3.ctrlKey || e3.shiftKey || e3.altKey || e3.metaKey) if (i4 && !n || !e3.altKey || e3.metaKey) !i4 || e3.altKey || e3.ctrlKey || e3.shiftKey || !e3.metaKey ? e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && e3.keyCode >= 48 && 1 === e3.key.length ? o.key = e3.key : e3.key && e3.ctrlKey && ("_" === e3.key && (o.key = s2.C0.US), "@" === e3.key && (o.key = s2.C0.NUL)) : 65 === e3.keyCode && (o.type = 1);
            else {
              const t4 = r[e3.keyCode], i5 = t4?.[e3.shiftKey ? 1 : 0];
              if (i5) o.key = s2.C0.ESC + i5;
              else if (e3.keyCode >= 65 && e3.keyCode <= 90) {
                const t5 = e3.ctrlKey ? e3.keyCode - 64 : e3.keyCode + 32;
                let i6 = String.fromCharCode(t5);
                e3.shiftKey && (i6 = i6.toUpperCase()), o.key = s2.C0.ESC + i6;
              } else if (32 === e3.keyCode) o.key = s2.C0.ESC + (e3.ctrlKey ? s2.C0.NUL : " ");
              else if ("Dead" === e3.key && e3.code.startsWith("Key")) {
                let t5 = e3.code.slice(3, 4);
                e3.shiftKey || (t5 = t5.toLowerCase()), o.key = s2.C0.ESC + t5, o.cancel = true;
              }
            }
            else e3.keyCode >= 65 && e3.keyCode <= 90 ? o.key = String.fromCharCode(e3.keyCode - 64) : 32 === e3.keyCode ? o.key = s2.C0.NUL : e3.keyCode >= 51 && e3.keyCode <= 55 ? o.key = String.fromCharCode(e3.keyCode - 51 + 27) : 56 === e3.keyCode ? o.key = s2.C0.DEL : 219 === e3.keyCode ? o.key = s2.C0.ESC : 220 === e3.keyCode ? o.key = s2.C0.FS : 221 === e3.keyCode && (o.key = s2.C0.GS);
        }
        return o;
      };
    }, 482: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Utf8ToUtf32 = t2.StringToUtf32 = t2.utf32ToString = t2.stringFromCodePoint = void 0, t2.stringFromCodePoint = function(e3) {
        return e3 > 65535 ? (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10)) + String.fromCharCode(e3 % 1024 + 56320)) : String.fromCharCode(e3);
      }, t2.utf32ToString = function(e3, t3 = 0, i3 = e3.length) {
        let s2 = "";
        for (let r = t3; r < i3; ++r) {
          let t4 = e3[r];
          t4 > 65535 ? (t4 -= 65536, s2 += String.fromCharCode(55296 + (t4 >> 10)) + String.fromCharCode(t4 % 1024 + 56320)) : s2 += String.fromCharCode(t4);
        }
        return s2;
      }, t2.StringToUtf32 = class {
        constructor() {
          this._interim = 0;
        }
        clear() {
          this._interim = 0;
        }
        decode(e3, t3) {
          const i3 = e3.length;
          if (!i3) return 0;
          let s2 = 0, r = 0;
          if (this._interim) {
            const i4 = e3.charCodeAt(r++);
            56320 <= i4 && i4 <= 57343 ? t3[s2++] = 1024 * (this._interim - 55296) + i4 - 56320 + 65536 : (t3[s2++] = this._interim, t3[s2++] = i4), this._interim = 0;
          }
          for (let n = r; n < i3; ++n) {
            const r2 = e3.charCodeAt(n);
            if (55296 <= r2 && r2 <= 56319) {
              if (++n >= i3) return this._interim = r2, s2;
              const o = e3.charCodeAt(n);
              56320 <= o && o <= 57343 ? t3[s2++] = 1024 * (r2 - 55296) + o - 56320 + 65536 : (t3[s2++] = r2, t3[s2++] = o);
            } else 65279 !== r2 && (t3[s2++] = r2);
          }
          return s2;
        }
      }, t2.Utf8ToUtf32 = class {
        constructor() {
          this.interim = new Uint8Array(3);
        }
        clear() {
          this.interim.fill(0);
        }
        decode(e3, t3) {
          const i3 = e3.length;
          if (!i3) return 0;
          let s2, r, n, o, a = 0, h2 = 0, c = 0;
          if (this.interim[0]) {
            let s3 = false, r2 = this.interim[0];
            r2 &= 192 == (224 & r2) ? 31 : 224 == (240 & r2) ? 15 : 7;
            let n2, o2 = 0;
            for (; (n2 = 63 & this.interim[++o2]) && o2 < 4; ) r2 <<= 6, r2 |= n2;
            const h3 = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, l2 = h3 - o2;
            for (; c < l2; ) {
              if (c >= i3) return 0;
              if (n2 = e3[c++], 128 != (192 & n2)) {
                c--, s3 = true;
                break;
              }
              this.interim[o2++] = n2, r2 <<= 6, r2 |= 63 & n2;
            }
            s3 || (2 === h3 ? r2 < 128 ? c-- : t3[a++] = r2 : 3 === h3 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || 65279 === r2 || (t3[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t3[a++] = r2)), this.interim.fill(0);
          }
          const l = i3 - 4;
          let d = c;
          for (; d < i3; ) {
            for (; !(!(d < l) || 128 & (s2 = e3[d]) || 128 & (r = e3[d + 1]) || 128 & (n = e3[d + 2]) || 128 & (o = e3[d + 3])); ) t3[a++] = s2, t3[a++] = r, t3[a++] = n, t3[a++] = o, d += 4;
            if (s2 = e3[d++], s2 < 128) t3[a++] = s2;
            else if (192 == (224 & s2)) {
              if (d >= i3) return this.interim[0] = s2, a;
              if (r = e3[d++], 128 != (192 & r)) {
                d--;
                continue;
              }
              if (h2 = (31 & s2) << 6 | 63 & r, h2 < 128) {
                d--;
                continue;
              }
              t3[a++] = h2;
            } else if (224 == (240 & s2)) {
              if (d >= i3) return this.interim[0] = s2, a;
              if (r = e3[d++], 128 != (192 & r)) {
                d--;
                continue;
              }
              if (d >= i3) return this.interim[0] = s2, this.interim[1] = r, a;
              if (n = e3[d++], 128 != (192 & n)) {
                d--;
                continue;
              }
              if (h2 = (15 & s2) << 12 | (63 & r) << 6 | 63 & n, h2 < 2048 || h2 >= 55296 && h2 <= 57343 || 65279 === h2) continue;
              t3[a++] = h2;
            } else if (240 == (248 & s2)) {
              if (d >= i3) return this.interim[0] = s2, a;
              if (r = e3[d++], 128 != (192 & r)) {
                d--;
                continue;
              }
              if (d >= i3) return this.interim[0] = s2, this.interim[1] = r, a;
              if (n = e3[d++], 128 != (192 & n)) {
                d--;
                continue;
              }
              if (d >= i3) return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = n, a;
              if (o = e3[d++], 128 != (192 & o)) {
                d--;
                continue;
              }
              if (h2 = (7 & s2) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h2 < 65536 || h2 > 1114111) continue;
              t3[a++] = h2;
            }
          }
          return a;
        }
      };
    }, 225: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeV6 = void 0;
      const s2 = i3(1480), r = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], n = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
      let o;
      t2.UnicodeV6 = class {
        constructor() {
          if (this.version = "6", !o) {
            o = new Uint8Array(65536), o.fill(1), o[0] = 0, o.fill(0, 1, 32), o.fill(0, 127, 160), o.fill(2, 4352, 4448), o[9001] = 2, o[9002] = 2, o.fill(2, 11904, 42192), o[12351] = 1, o.fill(2, 44032, 55204), o.fill(2, 63744, 64256), o.fill(2, 65040, 65050), o.fill(2, 65072, 65136), o.fill(2, 65280, 65377), o.fill(2, 65504, 65511);
            for (let e3 = 0; e3 < r.length; ++e3) o.fill(0, r[e3][0], r[e3][1] + 1);
          }
        }
        wcwidth(e3) {
          return e3 < 32 ? 0 : e3 < 127 ? 1 : e3 < 65536 ? o[e3] : function(e4, t3) {
            let i4, s3 = 0, r2 = t3.length - 1;
            if (e4 < t3[0][0] || e4 > t3[r2][1]) return false;
            for (; r2 >= s3; ) if (i4 = s3 + r2 >> 1, e4 > t3[i4][1]) s3 = i4 + 1;
            else {
              if (!(e4 < t3[i4][0])) return true;
              r2 = i4 - 1;
            }
            return false;
          }(e3, n) ? 0 : e3 >= 131072 && e3 <= 196605 || e3 >= 196608 && e3 <= 262141 ? 2 : 1;
        }
        charProperties(e3, t3) {
          let i4 = this.wcwidth(e3), r2 = 0 === i4 && 0 !== t3;
          if (r2) {
            const e4 = s2.UnicodeService.extractWidth(t3);
            0 === e4 ? r2 = false : e4 > i4 && (i4 = e4);
          }
          return s2.UnicodeService.createPropertyValue(0, i4, r2);
        }
      };
    }, 5981: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WriteBuffer = void 0;
      const s2 = i3(8460), r = i3(844);
      class n extends r.Disposable {
        static {
          __name(this, "n");
        }
        constructor(e3) {
          super(), this._action = e3, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new s2.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
        }
        handleUserInput() {
          this._didUserInput = true;
        }
        writeSync(e3, t3) {
          if (void 0 !== t3 && this._syncCalls > t3) return void (this._syncCalls = 0);
          if (this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
          let i4;
          for (this._isSyncWriting = true; i4 = this._writeBuffer.shift(); ) {
            this._action(i4);
            const e4 = this._callbacks.shift();
            e4 && e4();
          }
          this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
        }
        write(e3, t3) {
          if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
          if (!this._writeBuffer.length) {
            if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = false, this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3), void this._innerWrite();
            setTimeout(() => this._innerWrite());
          }
          this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3);
        }
        _innerWrite(e3 = 0, t3 = true) {
          const i4 = e3 || Date.now();
          for (; this._writeBuffer.length > this._bufferOffset; ) {
            const e4 = this._writeBuffer[this._bufferOffset], s3 = this._action(e4, t3);
            if (s3) {
              const e5 = /* @__PURE__ */ __name((e6) => Date.now() - i4 >= 12 ? setTimeout(() => this._innerWrite(0, e6)) : this._innerWrite(i4, e6), "e");
              return void s3.catch((e6) => (queueMicrotask(() => {
                throw e6;
              }), Promise.resolve(false))).then(e5);
            }
            const r2 = this._callbacks[this._bufferOffset];
            if (r2 && r2(), this._bufferOffset++, this._pendingData -= e4.length, Date.now() - i4 >= 12) break;
          }
          this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
        }
      }
      t2.WriteBuffer = n;
    }, 5941: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.toRgbString = t2.parseColor = void 0;
      const i3 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s2 = /^[\da-f]+$/;
      function r(e3, t3) {
        const i4 = e3.toString(16), s3 = i4.length < 2 ? "0" + i4 : i4;
        switch (t3) {
          case 4:
            return i4[0];
          case 8:
            return s3;
          case 12:
            return (s3 + s3).slice(0, 3);
          default:
            return s3 + s3;
        }
      }
      __name(r, "r");
      t2.parseColor = function(e3) {
        if (!e3) return;
        let t3 = e3.toLowerCase();
        if (0 === t3.indexOf("rgb:")) {
          t3 = t3.slice(4);
          const e4 = i3.exec(t3);
          if (e4) {
            const t4 = e4[1] ? 15 : e4[4] ? 255 : e4[7] ? 4095 : 65535;
            return [Math.round(parseInt(e4[1] || e4[4] || e4[7] || e4[10], 16) / t4 * 255), Math.round(parseInt(e4[2] || e4[5] || e4[8] || e4[11], 16) / t4 * 255), Math.round(parseInt(e4[3] || e4[6] || e4[9] || e4[12], 16) / t4 * 255)];
          }
        } else if (0 === t3.indexOf("#") && (t3 = t3.slice(1), s2.exec(t3) && [3, 6, 9, 12].includes(t3.length))) {
          const e4 = t3.length / 3, i4 = [0, 0, 0];
          for (let s3 = 0; s3 < 3; ++s3) {
            const r2 = parseInt(t3.slice(e4 * s3, e4 * s3 + e4), 16);
            i4[s3] = 1 === e4 ? r2 << 4 : 2 === e4 ? r2 : 3 === e4 ? r2 >> 4 : r2 >> 8;
          }
          return i4;
        }
      }, t2.toRgbString = function(e3, t3 = 16) {
        const [i4, s3, n] = e3;
        return `rgb:${r(i4, t3)}/${r(s3, t3)}/${r(n, t3)}`;
      };
    }, 5770: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.PAYLOAD_LIMIT = void 0, t2.PAYLOAD_LIMIT = 1e7;
    }, 6351: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DcsHandler = t2.DcsParser = void 0;
      const s2 = i3(482), r = i3(8742), n = i3(5770), o = [];
      t2.DcsParser = class {
        constructor() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {
          }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
        }
        dispose() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._active = o;
        }
        registerHandler(e3, t3) {
          void 0 === this._handlers[e3] && (this._handlers[e3] = []);
          const i4 = this._handlers[e3];
          return i4.push(t3), { dispose: /* @__PURE__ */ __name(() => {
            const e4 = i4.indexOf(t3);
            -1 !== e4 && i4.splice(e4, 1);
          }, "dispose") };
        }
        clearHandler(e3) {
          this._handlers[e3] && delete this._handlers[e3];
        }
        setHandlerFallback(e3) {
          this._handlerFb = e3;
        }
        reset() {
          if (this._active.length) for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3) this._active[e3].unhook(false);
          this._stack.paused = false, this._active = o, this._ident = 0;
        }
        hook(e3, t3) {
          if (this.reset(), this._ident = e3, this._active = this._handlers[e3] || o, this._active.length) for (let e4 = this._active.length - 1; e4 >= 0; e4--) this._active[e4].hook(t3);
          else this._handlerFb(this._ident, "HOOK", t3);
        }
        put(e3, t3, i4) {
          if (this._active.length) for (let s3 = this._active.length - 1; s3 >= 0; s3--) this._active[s3].put(e3, t3, i4);
          else this._handlerFb(this._ident, "PUT", (0, s2.utf32ToString)(e3, t3, i4));
        }
        unhook(e3, t3 = true) {
          if (this._active.length) {
            let i4 = false, s3 = this._active.length - 1, r2 = false;
            if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i4 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i4) {
              for (; s3 >= 0 && (i4 = this._active[s3].unhook(e3), true !== i4); s3--) if (i4 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i4;
              s3--;
            }
            for (; s3 >= 0; s3--) if (i4 = this._active[s3].unhook(false), i4 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i4;
          } else this._handlerFb(this._ident, "UNHOOK", e3);
          this._active = o, this._ident = 0;
        }
      };
      const a = new r.Params();
      a.addParam(0), t2.DcsHandler = class {
        constructor(e3) {
          this._handler = e3, this._data = "", this._params = a, this._hitLimit = false;
        }
        hook(e3) {
          this._params = e3.length > 1 || e3.params[0] ? e3.clone() : a, this._data = "", this._hitLimit = false;
        }
        put(e3, t3, i4) {
          this._hitLimit || (this._data += (0, s2.utf32ToString)(e3, t3, i4), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
        }
        unhook(e3) {
          let t3 = false;
          if (this._hitLimit) t3 = false;
          else if (e3 && (t3 = this._handler(this._data, this._params), t3 instanceof Promise)) return t3.then((e4) => (this._params = a, this._data = "", this._hitLimit = false, e4));
          return this._params = a, this._data = "", this._hitLimit = false, t3;
        }
      };
    }, 2015: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.EscapeSequenceParser = t2.VT500_TRANSITION_TABLE = t2.TransitionTable = void 0;
      const s2 = i3(844), r = i3(8742), n = i3(6242), o = i3(6351);
      class a {
        static {
          __name(this, "a");
        }
        constructor(e3) {
          this.table = new Uint8Array(e3);
        }
        setDefault(e3, t3) {
          this.table.fill(e3 << 4 | t3);
        }
        add(e3, t3, i4, s3) {
          this.table[t3 << 8 | e3] = i4 << 4 | s3;
        }
        addMany(e3, t3, i4, s3) {
          for (let r2 = 0; r2 < e3.length; r2++) this.table[t3 << 8 | e3[r2]] = i4 << 4 | s3;
        }
      }
      t2.TransitionTable = a;
      const h2 = 160;
      t2.VT500_TRANSITION_TABLE = function() {
        const e3 = new a(4095), t3 = Array.apply(null, Array(256)).map((e4, t4) => t4), i4 = /* @__PURE__ */ __name((e4, i5) => t3.slice(e4, i5), "i"), s3 = i4(32, 127), r2 = i4(0, 24);
        r2.push(25), r2.push.apply(r2, i4(28, 32));
        const n2 = i4(0, 14);
        let o2;
        for (o2 in e3.setDefault(1, 0), e3.addMany(s3, 0, 2, 0), n2) e3.addMany([24, 26, 153, 154], o2, 3, 0), e3.addMany(i4(128, 144), o2, 3, 0), e3.addMany(i4(144, 152), o2, 3, 0), e3.add(156, o2, 0, 0), e3.add(27, o2, 11, 1), e3.add(157, o2, 4, 8), e3.addMany([152, 158, 159], o2, 0, 7), e3.add(155, o2, 11, 3), e3.add(144, o2, 11, 9);
        return e3.addMany(r2, 0, 3, 0), e3.addMany(r2, 1, 3, 1), e3.add(127, 1, 0, 1), e3.addMany(r2, 8, 0, 8), e3.addMany(r2, 3, 3, 3), e3.add(127, 3, 0, 3), e3.addMany(r2, 4, 3, 4), e3.add(127, 4, 0, 4), e3.addMany(r2, 6, 3, 6), e3.addMany(r2, 5, 3, 5), e3.add(127, 5, 0, 5), e3.addMany(r2, 2, 3, 2), e3.add(127, 2, 0, 2), e3.add(93, 1, 4, 8), e3.addMany(s3, 8, 5, 8), e3.add(127, 8, 5, 8), e3.addMany([156, 27, 24, 26, 7], 8, 6, 0), e3.addMany(i4(28, 32), 8, 0, 8), e3.addMany([88, 94, 95], 1, 0, 7), e3.addMany(s3, 7, 0, 7), e3.addMany(r2, 7, 0, 7), e3.add(156, 7, 0, 0), e3.add(127, 7, 0, 7), e3.add(91, 1, 11, 3), e3.addMany(i4(64, 127), 3, 7, 0), e3.addMany(i4(48, 60), 3, 8, 4), e3.addMany([60, 61, 62, 63], 3, 9, 4), e3.addMany(i4(48, 60), 4, 8, 4), e3.addMany(i4(64, 127), 4, 7, 0), e3.addMany([60, 61, 62, 63], 4, 0, 6), e3.addMany(i4(32, 64), 6, 0, 6), e3.add(127, 6, 0, 6), e3.addMany(i4(64, 127), 6, 0, 0), e3.addMany(i4(32, 48), 3, 9, 5), e3.addMany(i4(32, 48), 5, 9, 5), e3.addMany(i4(48, 64), 5, 0, 6), e3.addMany(i4(64, 127), 5, 7, 0), e3.addMany(i4(32, 48), 4, 9, 5), e3.addMany(i4(32, 48), 1, 9, 2), e3.addMany(i4(32, 48), 2, 9, 2), e3.addMany(i4(48, 127), 2, 10, 0), e3.addMany(i4(48, 80), 1, 10, 0), e3.addMany(i4(81, 88), 1, 10, 0), e3.addMany([89, 90, 92], 1, 10, 0), e3.addMany(i4(96, 127), 1, 10, 0), e3.add(80, 1, 11, 9), e3.addMany(r2, 9, 0, 9), e3.add(127, 9, 0, 9), e3.addMany(i4(28, 32), 9, 0, 9), e3.addMany(i4(32, 48), 9, 9, 12), e3.addMany(i4(48, 60), 9, 8, 10), e3.addMany([60, 61, 62, 63], 9, 9, 10), e3.addMany(r2, 11, 0, 11), e3.addMany(i4(32, 128), 11, 0, 11), e3.addMany(i4(28, 32), 11, 0, 11), e3.addMany(r2, 10, 0, 10), e3.add(127, 10, 0, 10), e3.addMany(i4(28, 32), 10, 0, 10), e3.addMany(i4(48, 60), 10, 8, 10), e3.addMany([60, 61, 62, 63], 10, 0, 11), e3.addMany(i4(32, 48), 10, 9, 12), e3.addMany(r2, 12, 0, 12), e3.add(127, 12, 0, 12), e3.addMany(i4(28, 32), 12, 0, 12), e3.addMany(i4(32, 48), 12, 9, 12), e3.addMany(i4(48, 64), 12, 0, 11), e3.addMany(i4(64, 127), 12, 12, 13), e3.addMany(i4(64, 127), 10, 12, 13), e3.addMany(i4(64, 127), 9, 12, 13), e3.addMany(r2, 13, 13, 13), e3.addMany(s3, 13, 13, 13), e3.add(127, 13, 0, 13), e3.addMany([27, 156, 24, 26], 13, 14, 0), e3.add(h2, 0, 2, 0), e3.add(h2, 8, 5, 8), e3.add(h2, 6, 0, 6), e3.add(h2, 11, 0, 11), e3.add(h2, 13, 13, 13), e3;
      }();
      class c extends s2.Disposable {
        static {
          __name(this, "c");
        }
        constructor(e3 = t2.VT500_TRANSITION_TABLE) {
          super(), this._transitions = e3, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._printHandlerFb = (e4, t3, i4) => {
          }, this._executeHandlerFb = (e4) => {
          }, this._csiHandlerFb = (e4, t3) => {
          }, this._escHandlerFb = (e4) => {
          }, this._errorHandlerFb = (e4) => e4, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, s2.toDisposable)(() => {
            this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
          })), this._oscParser = this.register(new n.OscParser()), this._dcsParser = this.register(new o.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => true);
        }
        _identifier(e3, t3 = [64, 126]) {
          let i4 = 0;
          if (e3.prefix) {
            if (e3.prefix.length > 1) throw new Error("only one byte as prefix supported");
            if (i4 = e3.prefix.charCodeAt(0), i4 && 60 > i4 || i4 > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
          }
          if (e3.intermediates) {
            if (e3.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
            for (let t4 = 0; t4 < e3.intermediates.length; ++t4) {
              const s4 = e3.intermediates.charCodeAt(t4);
              if (32 > s4 || s4 > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
              i4 <<= 8, i4 |= s4;
            }
          }
          if (1 !== e3.final.length) throw new Error("final must be a single byte");
          const s3 = e3.final.charCodeAt(0);
          if (t3[0] > s3 || s3 > t3[1]) throw new Error(`final must be in range ${t3[0]} .. ${t3[1]}`);
          return i4 <<= 8, i4 |= s3, i4;
        }
        identToString(e3) {
          const t3 = [];
          for (; e3; ) t3.push(String.fromCharCode(255 & e3)), e3 >>= 8;
          return t3.reverse().join("");
        }
        setPrintHandler(e3) {
          this._printHandler = e3;
        }
        clearPrintHandler() {
          this._printHandler = this._printHandlerFb;
        }
        registerEscHandler(e3, t3) {
          const i4 = this._identifier(e3, [48, 126]);
          void 0 === this._escHandlers[i4] && (this._escHandlers[i4] = []);
          const s3 = this._escHandlers[i4];
          return s3.push(t3), { dispose: /* @__PURE__ */ __name(() => {
            const e4 = s3.indexOf(t3);
            -1 !== e4 && s3.splice(e4, 1);
          }, "dispose") };
        }
        clearEscHandler(e3) {
          this._escHandlers[this._identifier(e3, [48, 126])] && delete this._escHandlers[this._identifier(e3, [48, 126])];
        }
        setEscHandlerFallback(e3) {
          this._escHandlerFb = e3;
        }
        setExecuteHandler(e3, t3) {
          this._executeHandlers[e3.charCodeAt(0)] = t3;
        }
        clearExecuteHandler(e3) {
          this._executeHandlers[e3.charCodeAt(0)] && delete this._executeHandlers[e3.charCodeAt(0)];
        }
        setExecuteHandlerFallback(e3) {
          this._executeHandlerFb = e3;
        }
        registerCsiHandler(e3, t3) {
          const i4 = this._identifier(e3);
          void 0 === this._csiHandlers[i4] && (this._csiHandlers[i4] = []);
          const s3 = this._csiHandlers[i4];
          return s3.push(t3), { dispose: /* @__PURE__ */ __name(() => {
            const e4 = s3.indexOf(t3);
            -1 !== e4 && s3.splice(e4, 1);
          }, "dispose") };
        }
        clearCsiHandler(e3) {
          this._csiHandlers[this._identifier(e3)] && delete this._csiHandlers[this._identifier(e3)];
        }
        setCsiHandlerFallback(e3) {
          this._csiHandlerFb = e3;
        }
        registerDcsHandler(e3, t3) {
          return this._dcsParser.registerHandler(this._identifier(e3), t3);
        }
        clearDcsHandler(e3) {
          this._dcsParser.clearHandler(this._identifier(e3));
        }
        setDcsHandlerFallback(e3) {
          this._dcsParser.setHandlerFallback(e3);
        }
        registerOscHandler(e3, t3) {
          return this._oscParser.registerHandler(e3, t3);
        }
        clearOscHandler(e3) {
          this._oscParser.clearHandler(e3);
        }
        setOscHandlerFallback(e3) {
          this._oscParser.setHandlerFallback(e3);
        }
        setErrorHandler(e3) {
          this._errorHandler = e3;
        }
        clearErrorHandler() {
          this._errorHandler = this._errorHandlerFb;
        }
        reset() {
          this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);
        }
        _preserveStack(e3, t3, i4, s3, r2) {
          this._parseStack.state = e3, this._parseStack.handlers = t3, this._parseStack.handlerPos = i4, this._parseStack.transition = s3, this._parseStack.chunkPos = r2;
        }
        parse(e3, t3, i4) {
          let s3, r2 = 0, n2 = 0, o2 = 0;
          if (this._parseStack.state) if (2 === this._parseStack.state) this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1;
          else {
            if (void 0 === i4 || 1 === this._parseStack.state) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
            const t4 = this._parseStack.handlers;
            let n3 = this._parseStack.handlerPos - 1;
            switch (this._parseStack.state) {
              case 3:
                if (false === i4 && n3 > -1) {
                  for (; n3 >= 0 && (s3 = t4[n3](this._params), true !== s3); n3--) if (s3 instanceof Promise) return this._parseStack.handlerPos = n3, s3;
                }
                this._parseStack.handlers = [];
                break;
              case 4:
                if (false === i4 && n3 > -1) {
                  for (; n3 >= 0 && (s3 = t4[n3](), true !== s3); n3--) if (s3 instanceof Promise) return this._parseStack.handlerPos = n3, s3;
                }
                this._parseStack.handlers = [];
                break;
              case 6:
                if (r2 = e3[this._parseStack.chunkPos], s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2, i4), s3) return s3;
                27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                break;
              case 5:
                if (r2 = e3[this._parseStack.chunkPos], s3 = this._oscParser.end(24 !== r2 && 26 !== r2, i4), s3) return s3;
                27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
            }
            this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1, this.precedingJoinState = 0, this.currentState = 15 & this._parseStack.transition;
          }
          for (let i5 = o2; i5 < t3; ++i5) {
            switch (r2 = e3[i5], n2 = this._transitions.table[this.currentState << 8 | (r2 < 160 ? r2 : h2)], n2 >> 4) {
              case 2:
                for (let s4 = i5 + 1; ; ++s4) {
                  if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h2) {
                    this._printHandler(e3, i5, s4), i5 = s4 - 1;
                    break;
                  }
                  if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h2) {
                    this._printHandler(e3, i5, s4), i5 = s4 - 1;
                    break;
                  }
                  if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h2) {
                    this._printHandler(e3, i5, s4), i5 = s4 - 1;
                    break;
                  }
                  if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h2) {
                    this._printHandler(e3, i5, s4), i5 = s4 - 1;
                    break;
                  }
                }
                break;
              case 3:
                this._executeHandlers[r2] ? this._executeHandlers[r2]() : this._executeHandlerFb(r2), this.precedingJoinState = 0;
                break;
              case 0:
                break;
              case 1:
                if (this._errorHandler({ position: i5, code: r2, currentState: this.currentState, collect: this._collect, params: this._params, abort: false }).abort) return;
                break;
              case 7:
                const o3 = this._csiHandlers[this._collect << 8 | r2];
                let a2 = o3 ? o3.length - 1 : -1;
                for (; a2 >= 0 && (s3 = o3[a2](this._params), true !== s3); a2--) if (s3 instanceof Promise) return this._preserveStack(3, o3, a2, n2, i5), s3;
                a2 < 0 && this._csiHandlerFb(this._collect << 8 | r2, this._params), this.precedingJoinState = 0;
                break;
              case 8:
                do {
                  switch (r2) {
                    case 59:
                      this._params.addParam(0);
                      break;
                    case 58:
                      this._params.addSubParam(-1);
                      break;
                    default:
                      this._params.addDigit(r2 - 48);
                  }
                } while (++i5 < t3 && (r2 = e3[i5]) > 47 && r2 < 60);
                i5--;
                break;
              case 9:
                this._collect <<= 8, this._collect |= r2;
                break;
              case 10:
                const c2 = this._escHandlers[this._collect << 8 | r2];
                let l = c2 ? c2.length - 1 : -1;
                for (; l >= 0 && (s3 = c2[l](), true !== s3); l--) if (s3 instanceof Promise) return this._preserveStack(4, c2, l, n2, i5), s3;
                l < 0 && this._escHandlerFb(this._collect << 8 | r2), this.precedingJoinState = 0;
                break;
              case 11:
                this._params.reset(), this._params.addParam(0), this._collect = 0;
                break;
              case 12:
                this._dcsParser.hook(this._collect << 8 | r2, this._params);
                break;
              case 13:
                for (let s4 = i5 + 1; ; ++s4) if (s4 >= t3 || 24 === (r2 = e3[s4]) || 26 === r2 || 27 === r2 || r2 > 127 && r2 < h2) {
                  this._dcsParser.put(e3, i5, s4), i5 = s4 - 1;
                  break;
                }
                break;
              case 14:
                if (s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2), s3) return this._preserveStack(6, [], 0, n2, i5), s3;
                27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
                break;
              case 4:
                this._oscParser.start();
                break;
              case 5:
                for (let s4 = i5 + 1; ; s4++) if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 127 && r2 < h2) {
                  this._oscParser.put(e3, i5, s4), i5 = s4 - 1;
                  break;
                }
                break;
              case 6:
                if (s3 = this._oscParser.end(24 !== r2 && 26 !== r2), s3) return this._preserveStack(5, [], 0, n2, i5), s3;
                27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
            }
            this.currentState = 15 & n2;
          }
        }
      }
      t2.EscapeSequenceParser = c;
    }, 6242: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OscHandler = t2.OscParser = void 0;
      const s2 = i3(5770), r = i3(482), n = [];
      t2.OscParser = class {
        constructor() {
          this._state = 0, this._active = n, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
        }
        registerHandler(e3, t3) {
          void 0 === this._handlers[e3] && (this._handlers[e3] = []);
          const i4 = this._handlers[e3];
          return i4.push(t3), { dispose: /* @__PURE__ */ __name(() => {
            const e4 = i4.indexOf(t3);
            -1 !== e4 && i4.splice(e4, 1);
          }, "dispose") };
        }
        clearHandler(e3) {
          this._handlers[e3] && delete this._handlers[e3];
        }
        setHandlerFallback(e3) {
          this._handlerFb = e3;
        }
        dispose() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._active = n;
        }
        reset() {
          if (2 === this._state) for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3) this._active[e3].end(false);
          this._stack.paused = false, this._active = n, this._id = -1, this._state = 0;
        }
        _start() {
          if (this._active = this._handlers[this._id] || n, this._active.length) for (let e3 = this._active.length - 1; e3 >= 0; e3--) this._active[e3].start();
          else this._handlerFb(this._id, "START");
        }
        _put(e3, t3, i4) {
          if (this._active.length) for (let s3 = this._active.length - 1; s3 >= 0; s3--) this._active[s3].put(e3, t3, i4);
          else this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e3, t3, i4));
        }
        start() {
          this.reset(), this._state = 1;
        }
        put(e3, t3, i4) {
          if (3 !== this._state) {
            if (1 === this._state) for (; t3 < i4; ) {
              const i5 = e3[t3++];
              if (59 === i5) {
                this._state = 2, this._start();
                break;
              }
              if (i5 < 48 || 57 < i5) return void (this._state = 3);
              -1 === this._id && (this._id = 0), this._id = 10 * this._id + i5 - 48;
            }
            2 === this._state && i4 - t3 > 0 && this._put(e3, t3, i4);
          }
        }
        end(e3, t3 = true) {
          if (0 !== this._state) {
            if (3 !== this._state) if (1 === this._state && this._start(), this._active.length) {
              let i4 = false, s3 = this._active.length - 1, r2 = false;
              if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i4 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i4) {
                for (; s3 >= 0 && (i4 = this._active[s3].end(e3), true !== i4); s3--) if (i4 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i4;
                s3--;
              }
              for (; s3 >= 0; s3--) if (i4 = this._active[s3].end(false), i4 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i4;
            } else this._handlerFb(this._id, "END", e3);
            this._active = n, this._id = -1, this._state = 0;
          }
        }
      }, t2.OscHandler = class {
        constructor(e3) {
          this._handler = e3, this._data = "", this._hitLimit = false;
        }
        start() {
          this._data = "", this._hitLimit = false;
        }
        put(e3, t3, i4) {
          this._hitLimit || (this._data += (0, r.utf32ToString)(e3, t3, i4), this._data.length > s2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
        }
        end(e3) {
          let t3 = false;
          if (this._hitLimit) t3 = false;
          else if (e3 && (t3 = this._handler(this._data), t3 instanceof Promise)) return t3.then((e4) => (this._data = "", this._hitLimit = false, e4));
          return this._data = "", this._hitLimit = false, t3;
        }
      };
    }, 8742: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Params = void 0;
      const i3 = 2147483647;
      class s2 {
        static {
          __name(this, "s");
        }
        static fromArray(e3) {
          const t3 = new s2();
          if (!e3.length) return t3;
          for (let i4 = Array.isArray(e3[0]) ? 1 : 0; i4 < e3.length; ++i4) {
            const s3 = e3[i4];
            if (Array.isArray(s3)) for (let e4 = 0; e4 < s3.length; ++e4) t3.addSubParam(s3[e4]);
            else t3.addParam(s3);
          }
          return t3;
        }
        constructor(e3 = 32, t3 = 32) {
          if (this.maxLength = e3, this.maxSubParamsLength = t3, t3 > 256) throw new Error("maxSubParamsLength must not be greater than 256");
          this.params = new Int32Array(e3), this.length = 0, this._subParams = new Int32Array(t3), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e3), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
        }
        clone() {
          const e3 = new s2(this.maxLength, this.maxSubParamsLength);
          return e3.params.set(this.params), e3.length = this.length, e3._subParams.set(this._subParams), e3._subParamsLength = this._subParamsLength, e3._subParamsIdx.set(this._subParamsIdx), e3._rejectDigits = this._rejectDigits, e3._rejectSubDigits = this._rejectSubDigits, e3._digitIsSub = this._digitIsSub, e3;
        }
        toArray() {
          const e3 = [];
          for (let t3 = 0; t3 < this.length; ++t3) {
            e3.push(this.params[t3]);
            const i4 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
            s3 - i4 > 0 && e3.push(Array.prototype.slice.call(this._subParams, i4, s3));
          }
          return e3;
        }
        reset() {
          this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
        }
        addParam(e3) {
          if (this._digitIsSub = false, this.length >= this.maxLength) this._rejectDigits = true;
          else {
            if (e3 < -1) throw new Error("values lesser than -1 are not allowed");
            this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e3 > i3 ? i3 : e3;
          }
        }
        addSubParam(e3) {
          if (this._digitIsSub = true, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = true;
          else {
            if (e3 < -1) throw new Error("values lesser than -1 are not allowed");
            this._subParams[this._subParamsLength++] = e3 > i3 ? i3 : e3, this._subParamsIdx[this.length - 1]++;
          }
        }
        hasSubParams(e3) {
          return (255 & this._subParamsIdx[e3]) - (this._subParamsIdx[e3] >> 8) > 0;
        }
        getSubParams(e3) {
          const t3 = this._subParamsIdx[e3] >> 8, i4 = 255 & this._subParamsIdx[e3];
          return i4 - t3 > 0 ? this._subParams.subarray(t3, i4) : null;
        }
        getSubParamsAll() {
          const e3 = {};
          for (let t3 = 0; t3 < this.length; ++t3) {
            const i4 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
            s3 - i4 > 0 && (e3[t3] = this._subParams.slice(i4, s3));
          }
          return e3;
        }
        addDigit(e3) {
          let t3;
          if (this._rejectDigits || !(t3 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
          const s3 = this._digitIsSub ? this._subParams : this.params, r = s3[t3 - 1];
          s3[t3 - 1] = ~r ? Math.min(10 * r + e3, i3) : e3;
        }
      }
      t2.Params = s2;
    }, 5741: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.AddonManager = void 0, t2.AddonManager = class {
        constructor() {
          this._addons = [];
        }
        dispose() {
          for (let e3 = this._addons.length - 1; e3 >= 0; e3--) this._addons[e3].instance.dispose();
        }
        loadAddon(e3, t3) {
          const i3 = { instance: t3, dispose: t3.dispose, isDisposed: false };
          this._addons.push(i3), t3.dispose = () => this._wrappedAddonDispose(i3), t3.activate(e3);
        }
        _wrappedAddonDispose(e3) {
          if (e3.isDisposed) return;
          let t3 = -1;
          for (let i3 = 0; i3 < this._addons.length; i3++) if (this._addons[i3] === e3) {
            t3 = i3;
            break;
          }
          if (-1 === t3) throw new Error("Could not dispose an addon that has not been loaded");
          e3.isDisposed = true, e3.dispose.apply(e3.instance), this._addons.splice(t3, 1);
        }
      };
    }, 8771: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferApiView = void 0;
      const s2 = i3(3785), r = i3(511);
      t2.BufferApiView = class {
        constructor(e3, t3) {
          this._buffer = e3, this.type = t3;
        }
        init(e3) {
          return this._buffer = e3, this;
        }
        get cursorY() {
          return this._buffer.y;
        }
        get cursorX() {
          return this._buffer.x;
        }
        get viewportY() {
          return this._buffer.ydisp;
        }
        get baseY() {
          return this._buffer.ybase;
        }
        get length() {
          return this._buffer.lines.length;
        }
        getLine(e3) {
          const t3 = this._buffer.lines.get(e3);
          if (t3) return new s2.BufferLineApiView(t3);
        }
        getNullCell() {
          return new r.CellData();
        }
      };
    }, 3785: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLineApiView = void 0;
      const s2 = i3(511);
      t2.BufferLineApiView = class {
        constructor(e3) {
          this._line = e3;
        }
        get isWrapped() {
          return this._line.isWrapped;
        }
        get length() {
          return this._line.length;
        }
        getCell(e3, t3) {
          if (!(e3 < 0 || e3 >= this._line.length)) return t3 ? (this._line.loadCell(e3, t3), t3) : this._line.loadCell(e3, new s2.CellData());
        }
        translateToString(e3, t3, i4) {
          return this._line.translateToString(e3, t3, i4);
        }
      };
    }, 8285: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferNamespaceApi = void 0;
      const s2 = i3(8771), r = i3(8460), n = i3(844);
      class o extends n.Disposable {
        static {
          __name(this, "o");
        }
        constructor(e3) {
          super(), this._core = e3, this._onBufferChange = this.register(new r.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new s2.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s2.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
        }
        get active() {
          if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
          if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
          throw new Error("Active buffer is neither normal nor alternate");
        }
        get normal() {
          return this._normal.init(this._core.buffers.normal);
        }
        get alternate() {
          return this._alternate.init(this._core.buffers.alt);
        }
      }
      t2.BufferNamespaceApi = o;
    }, 7975: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ParserApi = void 0, t2.ParserApi = class {
        constructor(e3) {
          this._core = e3;
        }
        registerCsiHandler(e3, t3) {
          return this._core.registerCsiHandler(e3, (e4) => t3(e4.toArray()));
        }
        addCsiHandler(e3, t3) {
          return this.registerCsiHandler(e3, t3);
        }
        registerDcsHandler(e3, t3) {
          return this._core.registerDcsHandler(e3, (e4, i3) => t3(e4, i3.toArray()));
        }
        addDcsHandler(e3, t3) {
          return this.registerDcsHandler(e3, t3);
        }
        registerEscHandler(e3, t3) {
          return this._core.registerEscHandler(e3, t3);
        }
        addEscHandler(e3, t3) {
          return this.registerEscHandler(e3, t3);
        }
        registerOscHandler(e3, t3) {
          return this._core.registerOscHandler(e3, t3);
        }
        addOscHandler(e3, t3) {
          return this.registerOscHandler(e3, t3);
        }
      };
    }, 7090: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeApi = void 0, t2.UnicodeApi = class {
        constructor(e3) {
          this._core = e3;
        }
        register(e3) {
          this._core.unicodeService.register(e3);
        }
        get versions() {
          return this._core.unicodeService.versions;
        }
        get activeVersion() {
          return this._core.unicodeService.activeVersion;
        }
        set activeVersion(e3) {
          this._core.unicodeService.activeVersion = e3;
        }
      };
    }, 744: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferService = t2.MINIMUM_ROWS = t2.MINIMUM_COLS = void 0;
      const n = i3(8460), o = i3(844), a = i3(5295), h2 = i3(2585);
      t2.MINIMUM_COLS = 2, t2.MINIMUM_ROWS = 1;
      let c = t2.BufferService = class extends o.Disposable {
        get buffer() {
          return this.buffers.active;
        }
        constructor(e3) {
          super(), this.isUserScrolling = false, this._onResize = this.register(new n.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e3.rawOptions.cols || 0, t2.MINIMUM_COLS), this.rows = Math.max(e3.rawOptions.rows || 0, t2.MINIMUM_ROWS), this.buffers = this.register(new a.BufferSet(e3, this));
        }
        resize(e3, t3) {
          this.cols = e3, this.rows = t3, this.buffers.resize(e3, t3), this._onResize.fire({ cols: e3, rows: t3 });
        }
        reset() {
          this.buffers.reset(), this.isUserScrolling = false;
        }
        scroll(e3, t3 = false) {
          const i4 = this.buffer;
          let s3;
          s3 = this._cachedBlankLine, s3 && s3.length === this.cols && s3.getFg(0) === e3.fg && s3.getBg(0) === e3.bg || (s3 = i4.getBlankLine(e3, t3), this._cachedBlankLine = s3), s3.isWrapped = t3;
          const r2 = i4.ybase + i4.scrollTop, n2 = i4.ybase + i4.scrollBottom;
          if (0 === i4.scrollTop) {
            const e4 = i4.lines.isFull;
            n2 === i4.lines.length - 1 ? e4 ? i4.lines.recycle().copyFrom(s3) : i4.lines.push(s3.clone()) : i4.lines.splice(n2 + 1, 0, s3.clone()), e4 ? this.isUserScrolling && (i4.ydisp = Math.max(i4.ydisp - 1, 0)) : (i4.ybase++, this.isUserScrolling || i4.ydisp++);
          } else {
            const e4 = n2 - r2 + 1;
            i4.lines.shiftElements(r2 + 1, e4 - 1, -1), i4.lines.set(n2, s3.clone());
          }
          this.isUserScrolling || (i4.ydisp = i4.ybase), this._onScroll.fire(i4.ydisp);
        }
        scrollLines(e3, t3, i4) {
          const s3 = this.buffer;
          if (e3 < 0) {
            if (0 === s3.ydisp) return;
            this.isUserScrolling = true;
          } else e3 + s3.ydisp >= s3.ybase && (this.isUserScrolling = false);
          const r2 = s3.ydisp;
          s3.ydisp = Math.max(Math.min(s3.ydisp + e3, s3.ybase), 0), r2 !== s3.ydisp && (t3 || this._onScroll.fire(s3.ydisp));
        }
      };
      t2.BufferService = c = s2([r(0, h2.IOptionsService)], c);
    }, 7994: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CharsetService = void 0, t2.CharsetService = class {
        constructor() {
          this.glevel = 0, this._charsets = [];
        }
        reset() {
          this.charset = void 0, this._charsets = [], this.glevel = 0;
        }
        setgLevel(e3) {
          this.glevel = e3, this.charset = this._charsets[e3];
        }
        setgCharset(e3, t3) {
          this._charsets[e3] = t3, this.glevel === e3 && (this.charset = t3);
        }
      };
    }, 1753: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreMouseService = void 0;
      const n = i3(2585), o = i3(8460), a = i3(844), h2 = { NONE: { events: 0, restrict: /* @__PURE__ */ __name(() => false, "restrict") }, X10: { events: 1, restrict: /* @__PURE__ */ __name((e3) => 4 !== e3.button && 1 === e3.action && (e3.ctrl = false, e3.alt = false, e3.shift = false, true), "restrict") }, VT200: { events: 19, restrict: /* @__PURE__ */ __name((e3) => 32 !== e3.action, "restrict") }, DRAG: { events: 23, restrict: /* @__PURE__ */ __name((e3) => 32 !== e3.action || 3 !== e3.button, "restrict") }, ANY: { events: 31, restrict: /* @__PURE__ */ __name((e3) => true, "restrict") } };
      function c(e3, t3) {
        let i4 = (e3.ctrl ? 16 : 0) | (e3.shift ? 4 : 0) | (e3.alt ? 8 : 0);
        return 4 === e3.button ? (i4 |= 64, i4 |= e3.action) : (i4 |= 3 & e3.button, 4 & e3.button && (i4 |= 64), 8 & e3.button && (i4 |= 128), 32 === e3.action ? i4 |= 32 : 0 !== e3.action || t3 || (i4 |= 3)), i4;
      }
      __name(c, "c");
      const l = String.fromCharCode, d = { DEFAULT: /* @__PURE__ */ __name((e3) => {
        const t3 = [c(e3, false) + 32, e3.col + 32, e3.row + 32];
        return t3[0] > 255 || t3[1] > 255 || t3[2] > 255 ? "" : `\x1B[M${l(t3[0])}${l(t3[1])}${l(t3[2])}`;
      }, "DEFAULT"), SGR: /* @__PURE__ */ __name((e3) => {
        const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
        return `\x1B[<${c(e3, true)};${e3.col};${e3.row}${t3}`;
      }, "SGR"), SGR_PIXELS: /* @__PURE__ */ __name((e3) => {
        const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
        return `\x1B[<${c(e3, true)};${e3.x};${e3.y}${t3}`;
      }, "SGR_PIXELS") };
      let _2 = t2.CoreMouseService = class extends a.Disposable {
        constructor(e3, t3) {
          super(), this._bufferService = e3, this._coreService = t3, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
          for (const e4 of Object.keys(h2)) this.addProtocol(e4, h2[e4]);
          for (const e4 of Object.keys(d)) this.addEncoding(e4, d[e4]);
          this.reset();
        }
        addProtocol(e3, t3) {
          this._protocols[e3] = t3;
        }
        addEncoding(e3, t3) {
          this._encodings[e3] = t3;
        }
        get activeProtocol() {
          return this._activeProtocol;
        }
        get areMouseEventsActive() {
          return 0 !== this._protocols[this._activeProtocol].events;
        }
        set activeProtocol(e3) {
          if (!this._protocols[e3]) throw new Error(`unknown protocol "${e3}"`);
          this._activeProtocol = e3, this._onProtocolChange.fire(this._protocols[e3].events);
        }
        get activeEncoding() {
          return this._activeEncoding;
        }
        set activeEncoding(e3) {
          if (!this._encodings[e3]) throw new Error(`unknown encoding "${e3}"`);
          this._activeEncoding = e3;
        }
        reset() {
          this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
        }
        triggerMouseEvent(e3) {
          if (e3.col < 0 || e3.col >= this._bufferService.cols || e3.row < 0 || e3.row >= this._bufferService.rows) return false;
          if (4 === e3.button && 32 === e3.action) return false;
          if (3 === e3.button && 32 !== e3.action) return false;
          if (4 !== e3.button && (2 === e3.action || 3 === e3.action)) return false;
          if (e3.col++, e3.row++, 32 === e3.action && this._lastEvent && this._equalEvents(this._lastEvent, e3, "SGR_PIXELS" === this._activeEncoding)) return false;
          if (!this._protocols[this._activeProtocol].restrict(e3)) return false;
          const t3 = this._encodings[this._activeEncoding](e3);
          return t3 && ("DEFAULT" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t3) : this._coreService.triggerDataEvent(t3, true)), this._lastEvent = e3, true;
        }
        explainEvents(e3) {
          return { down: !!(1 & e3), up: !!(2 & e3), drag: !!(4 & e3), move: !!(8 & e3), wheel: !!(16 & e3) };
        }
        _equalEvents(e3, t3, i4) {
          if (i4) {
            if (e3.x !== t3.x) return false;
            if (e3.y !== t3.y) return false;
          } else {
            if (e3.col !== t3.col) return false;
            if (e3.row !== t3.row) return false;
          }
          return e3.button === t3.button && e3.action === t3.action && e3.ctrl === t3.ctrl && e3.alt === t3.alt && e3.shift === t3.shift;
        }
      };
      t2.CoreMouseService = _2 = s2([r(0, n.IBufferService), r(1, n.ICoreService)], _2);
    }, 6975: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreService = void 0;
      const n = i3(1439), o = i3(8460), a = i3(844), h2 = i3(2585), c = Object.freeze({ insertMode: false }), l = Object.freeze({ applicationCursorKeys: false, applicationKeypad: false, bracketedPasteMode: false, origin: false, reverseWraparound: false, sendFocus: false, wraparound: true });
      let d = t2.CoreService = class extends a.Disposable {
        constructor(e3, t3, i4) {
          super(), this._bufferService = e3, this._logService = t3, this._optionsService = i4, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new o.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
        }
        reset() {
          this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
        }
        triggerDataEvent(e3, t3 = false) {
          if (this._optionsService.rawOptions.disableStdin) return;
          const i4 = this._bufferService.buffer;
          t3 && this._optionsService.rawOptions.scrollOnUserInput && i4.ybase !== i4.ydisp && this._onRequestScrollToBottom.fire(), t3 && this._onUserInput.fire(), this._logService.debug(`sending data "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onData.fire(e3);
        }
        triggerBinaryEvent(e3) {
          this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onBinary.fire(e3));
        }
      };
      t2.CoreService = d = s2([r(0, h2.IBufferService), r(1, h2.ILogService), r(2, h2.IOptionsService)], d);
    }, 9074: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.DecorationService = void 0;
      const s2 = i3(8055), r = i3(8460), n = i3(844), o = i3(6106);
      let a = 0, h2 = 0;
      class c extends n.Disposable {
        static {
          __name(this, "c");
        }
        get decorations() {
          return this._decorations.values();
        }
        constructor() {
          super(), this._decorations = new o.SortedList((e3) => e3?.marker.line), this._onDecorationRegistered = this.register(new r.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)(() => this.reset()));
        }
        registerDecoration(e3) {
          if (e3.marker.isDisposed) return;
          const t3 = new l(e3);
          if (t3) {
            const e4 = t3.marker.onDispose(() => t3.dispose());
            t3.onDispose(() => {
              t3 && (this._decorations.delete(t3) && this._onDecorationRemoved.fire(t3), e4.dispose());
            }), this._decorations.insert(t3), this._onDecorationRegistered.fire(t3);
          }
          return t3;
        }
        reset() {
          for (const e3 of this._decorations.values()) e3.dispose();
          this._decorations.clear();
        }
        *getDecorationsAtCell(e3, t3, i4) {
          let s3 = 0, r2 = 0;
          for (const n2 of this._decorations.getKeyIterator(t3)) s3 = n2.options.x ?? 0, r2 = s3 + (n2.options.width ?? 1), e3 >= s3 && e3 < r2 && (!i4 || (n2.options.layer ?? "bottom") === i4) && (yield n2);
        }
        forEachDecorationAtCell(e3, t3, i4, s3) {
          this._decorations.forEachByKey(t3, (t4) => {
            a = t4.options.x ?? 0, h2 = a + (t4.options.width ?? 1), e3 >= a && e3 < h2 && (!i4 || (t4.options.layer ?? "bottom") === i4) && s3(t4);
          });
        }
      }
      t2.DecorationService = c;
      class l extends n.Disposable {
        static {
          __name(this, "l");
        }
        get isDisposed() {
          return this._isDisposed;
        }
        get backgroundColorRGB() {
          return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s2.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
        }
        get foregroundColorRGB() {
          return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s2.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
        }
        constructor(e3) {
          super(), this.options = e3, this.onRenderEmitter = this.register(new r.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e3.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
        }
        dispose() {
          this._onDispose.fire(), super.dispose();
        }
      }
    }, 4348: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.InstantiationService = t2.ServiceCollection = void 0;
      const s2 = i3(2585), r = i3(8343);
      class n {
        static {
          __name(this, "n");
        }
        constructor(...e3) {
          this._entries = /* @__PURE__ */ new Map();
          for (const [t3, i4] of e3) this.set(t3, i4);
        }
        set(e3, t3) {
          const i4 = this._entries.get(e3);
          return this._entries.set(e3, t3), i4;
        }
        forEach(e3) {
          for (const [t3, i4] of this._entries.entries()) e3(t3, i4);
        }
        has(e3) {
          return this._entries.has(e3);
        }
        get(e3) {
          return this._entries.get(e3);
        }
      }
      t2.ServiceCollection = n, t2.InstantiationService = class {
        constructor() {
          this._services = new n(), this._services.set(s2.IInstantiationService, this);
        }
        setService(e3, t3) {
          this._services.set(e3, t3);
        }
        getService(e3) {
          return this._services.get(e3);
        }
        createInstance(e3, ...t3) {
          const i4 = (0, r.getServiceDependencies)(e3).sort((e4, t4) => e4.index - t4.index), s3 = [];
          for (const t4 of i4) {
            const i5 = this._services.get(t4.id);
            if (!i5) throw new Error(`[createInstance] ${e3.name} depends on UNKNOWN service ${t4.id}.`);
            s3.push(i5);
          }
          const n2 = i4.length > 0 ? i4[0].index : t3.length;
          if (t3.length !== n2) throw new Error(`[createInstance] First service dependency of ${e3.name} at position ${n2 + 1} conflicts with ${t3.length} static arguments`);
          return new e3(...[...t3, ...s3]);
        }
      };
    }, 7866: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.traceCall = t2.setTraceLogger = t2.LogService = void 0;
      const n = i3(844), o = i3(2585), a = { trace: o.LogLevelEnum.TRACE, debug: o.LogLevelEnum.DEBUG, info: o.LogLevelEnum.INFO, warn: o.LogLevelEnum.WARN, error: o.LogLevelEnum.ERROR, off: o.LogLevelEnum.OFF };
      let h2, c = t2.LogService = class extends n.Disposable {
        get logLevel() {
          return this._logLevel;
        }
        constructor(e3) {
          super(), this._optionsService = e3, this._logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), h2 = this;
        }
        _updateLogLevel() {
          this._logLevel = a[this._optionsService.rawOptions.logLevel];
        }
        _evalLazyOptionalParams(e3) {
          for (let t3 = 0; t3 < e3.length; t3++) "function" == typeof e3[t3] && (e3[t3] = e3[t3]());
        }
        _log(e3, t3, i4) {
          this._evalLazyOptionalParams(i4), e3.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + t3, ...i4);
        }
        trace(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.TRACE && this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger) ?? console.log, e3, t3);
        }
        debug(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.DEBUG && this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger) ?? console.log, e3, t3);
        }
        info(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.INFO && this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger) ?? console.info, e3, t3);
        }
        warn(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.WARN && this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger) ?? console.warn, e3, t3);
        }
        error(e3, ...t3) {
          this._logLevel <= o.LogLevelEnum.ERROR && this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger) ?? console.error, e3, t3);
        }
      };
      t2.LogService = c = s2([r(0, o.IOptionsService)], c), t2.setTraceLogger = function(e3) {
        h2 = e3;
      }, t2.traceCall = function(e3, t3, i4) {
        if ("function" != typeof i4.value) throw new Error("not supported");
        const s3 = i4.value;
        i4.value = function(...e4) {
          if (h2.logLevel !== o.LogLevelEnum.TRACE) return s3.apply(this, e4);
          h2.trace(`GlyphRenderer#${s3.name}(${e4.map((e5) => JSON.stringify(e5)).join(", ")})`);
          const t4 = s3.apply(this, e4);
          return h2.trace(`GlyphRenderer#${s3.name} return`, t4), t4;
        };
      };
    }, 7302: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionsService = t2.DEFAULT_OPTIONS = void 0;
      const s2 = i3(8460), r = i3(844), n = i3(6114);
      t2.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: false, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: true, drawBoldTextInBrightColors: true, documentOverride: null, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: false, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: true, scrollSensitivity: 1, screenReaderMode: false, smoothScrollDuration: 0, macOptionIsMeta: false, macOptionClickForcesSelection: false, minimumContrastRatio: 1, disableStdin: false, allowProposedApi: false, allowTransparency: false, tabStopWidth: 8, theme: {}, rescaleOverlappingGlyphs: false, rightClickSelectsWord: n.isMac, windowOptions: {}, windowsMode: false, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: true, convertEol: false, termName: "xterm", cancelEvents: false, overviewRulerWidth: 0 };
      const o = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
      class a extends r.Disposable {
        static {
          __name(this, "a");
        }
        constructor(e3) {
          super(), this._onOptionChange = this.register(new s2.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
          const i4 = { ...t2.DEFAULT_OPTIONS };
          for (const t3 in e3) if (t3 in i4) try {
            const s3 = e3[t3];
            i4[t3] = this._sanitizeAndValidateOption(t3, s3);
          } catch (e4) {
            console.error(e4);
          }
          this.rawOptions = i4, this.options = { ...i4 }, this._setupOptions(), this.register((0, r.toDisposable)(() => {
            this.rawOptions.linkHandler = null, this.rawOptions.documentOverride = null;
          }));
        }
        onSpecificOptionChange(e3, t3) {
          return this.onOptionChange((i4) => {
            i4 === e3 && t3(this.rawOptions[e3]);
          });
        }
        onMultipleOptionChange(e3, t3) {
          return this.onOptionChange((i4) => {
            -1 !== e3.indexOf(i4) && t3();
          });
        }
        _setupOptions() {
          const e3 = /* @__PURE__ */ __name((e4) => {
            if (!(e4 in t2.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e4}"`);
            return this.rawOptions[e4];
          }, "e"), i4 = /* @__PURE__ */ __name((e4, i5) => {
            if (!(e4 in t2.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e4}"`);
            i5 = this._sanitizeAndValidateOption(e4, i5), this.rawOptions[e4] !== i5 && (this.rawOptions[e4] = i5, this._onOptionChange.fire(e4));
          }, "i");
          for (const t3 in this.rawOptions) {
            const s3 = { get: e3.bind(this, t3), set: i4.bind(this, t3) };
            Object.defineProperty(this.options, t3, s3);
          }
        }
        _sanitizeAndValidateOption(e3, i4) {
          switch (e3) {
            case "cursorStyle":
              if (i4 || (i4 = t2.DEFAULT_OPTIONS[e3]), !/* @__PURE__ */ function(e4) {
                return "block" === e4 || "underline" === e4 || "bar" === e4;
              }(i4)) throw new Error(`"${i4}" is not a valid value for ${e3}`);
              break;
            case "wordSeparator":
              i4 || (i4 = t2.DEFAULT_OPTIONS[e3]);
              break;
            case "fontWeight":
            case "fontWeightBold":
              if ("number" == typeof i4 && 1 <= i4 && i4 <= 1e3) break;
              i4 = o.includes(i4) ? i4 : t2.DEFAULT_OPTIONS[e3];
              break;
            case "cursorWidth":
              i4 = Math.floor(i4);
            case "lineHeight":
            case "tabStopWidth":
              if (i4 < 1) throw new Error(`${e3} cannot be less than 1, value: ${i4}`);
              break;
            case "minimumContrastRatio":
              i4 = Math.max(1, Math.min(21, Math.round(10 * i4) / 10));
              break;
            case "scrollback":
              if ((i4 = Math.min(i4, 4294967295)) < 0) throw new Error(`${e3} cannot be less than 0, value: ${i4}`);
              break;
            case "fastScrollSensitivity":
            case "scrollSensitivity":
              if (i4 <= 0) throw new Error(`${e3} cannot be less than or equal to 0, value: ${i4}`);
              break;
            case "rows":
            case "cols":
              if (!i4 && 0 !== i4) throw new Error(`${e3} must be numeric, value: ${i4}`);
              break;
            case "windowsPty":
              i4 = i4 ?? {};
          }
          return i4;
        }
      }
      t2.OptionsService = a;
    }, 2660: function(e2, t2, i3) {
      var s2 = this && this.__decorate || function(e3, t3, i4, s3) {
        var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i4) : s3;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i4, s3);
        else for (var a = e3.length - 1; a >= 0; a--) (r2 = e3[a]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i4, o2) : r2(t3, i4)) || o2);
        return n2 > 3 && o2 && Object.defineProperty(t3, i4, o2), o2;
      }, r = this && this.__param || function(e3, t3) {
        return function(i4, s3) {
          t3(i4, s3, e3);
        };
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkService = void 0;
      const n = i3(2585);
      let o = t2.OscLinkService = class {
        constructor(e3) {
          this._bufferService = e3, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
        }
        registerLink(e3) {
          const t3 = this._bufferService.buffer;
          if (void 0 === e3.id) {
            const i5 = t3.addMarker(t3.ybase + t3.y), s4 = { data: e3, id: this._nextId++, lines: [i5] };
            return i5.onDispose(() => this._removeMarkerFromLink(s4, i5)), this._dataByLinkId.set(s4.id, s4), s4.id;
          }
          const i4 = e3, s3 = this._getEntryIdKey(i4), r2 = this._entriesWithId.get(s3);
          if (r2) return this.addLineToLink(r2.id, t3.ybase + t3.y), r2.id;
          const n2 = t3.addMarker(t3.ybase + t3.y), o2 = { id: this._nextId++, key: this._getEntryIdKey(i4), data: i4, lines: [n2] };
          return n2.onDispose(() => this._removeMarkerFromLink(o2, n2)), this._entriesWithId.set(o2.key, o2), this._dataByLinkId.set(o2.id, o2), o2.id;
        }
        addLineToLink(e3, t3) {
          const i4 = this._dataByLinkId.get(e3);
          if (i4 && i4.lines.every((e4) => e4.line !== t3)) {
            const e4 = this._bufferService.buffer.addMarker(t3);
            i4.lines.push(e4), e4.onDispose(() => this._removeMarkerFromLink(i4, e4));
          }
        }
        getLinkData(e3) {
          return this._dataByLinkId.get(e3)?.data;
        }
        _getEntryIdKey(e3) {
          return `${e3.id};;${e3.uri}`;
        }
        _removeMarkerFromLink(e3, t3) {
          const i4 = e3.lines.indexOf(t3);
          -1 !== i4 && (e3.lines.splice(i4, 1), 0 === e3.lines.length && (void 0 !== e3.data.id && this._entriesWithId.delete(e3.key), this._dataByLinkId.delete(e3.id)));
        }
      };
      t2.OscLinkService = o = s2([r(0, n.IBufferService)], o);
    }, 8343: (e2, t2) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createDecorator = t2.getServiceDependencies = t2.serviceRegistry = void 0;
      const i3 = "di$target", s2 = "di$dependencies";
      t2.serviceRegistry = /* @__PURE__ */ new Map(), t2.getServiceDependencies = function(e3) {
        return e3[s2] || [];
      }, t2.createDecorator = function(e3) {
        if (t2.serviceRegistry.has(e3)) return t2.serviceRegistry.get(e3);
        const r = /* @__PURE__ */ __name(function(e4, t3, n) {
          if (3 !== arguments.length) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
          !function(e5, t4, r2) {
            t4[i3] === t4 ? t4[s2].push({ id: e5, index: r2 }) : (t4[s2] = [{ id: e5, index: r2 }], t4[i3] = t4);
          }(r, e4, n);
        }, "r");
        return r.toString = () => e3, t2.serviceRegistry.set(e3, r), r;
      };
    }, 2585: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.IDecorationService = t2.IUnicodeService = t2.IOscLinkService = t2.IOptionsService = t2.ILogService = t2.LogLevelEnum = t2.IInstantiationService = t2.ICharsetService = t2.ICoreService = t2.ICoreMouseService = t2.IBufferService = void 0;
      const s2 = i3(8343);
      var r;
      t2.IBufferService = (0, s2.createDecorator)("BufferService"), t2.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t2.ICoreService = (0, s2.createDecorator)("CoreService"), t2.ICharsetService = (0, s2.createDecorator)("CharsetService"), t2.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), function(e3) {
        e3[e3.TRACE = 0] = "TRACE", e3[e3.DEBUG = 1] = "DEBUG", e3[e3.INFO = 2] = "INFO", e3[e3.WARN = 3] = "WARN", e3[e3.ERROR = 4] = "ERROR", e3[e3.OFF = 5] = "OFF";
      }(r || (t2.LogLevelEnum = r = {})), t2.ILogService = (0, s2.createDecorator)("LogService"), t2.IOptionsService = (0, s2.createDecorator)("OptionsService"), t2.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t2.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t2.IDecorationService = (0, s2.createDecorator)("DecorationService");
    }, 1480: (e2, t2, i3) => {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeService = void 0;
      const s2 = i3(8460), r = i3(225);
      class n {
        static {
          __name(this, "n");
        }
        static extractShouldJoin(e3) {
          return 0 != (1 & e3);
        }
        static extractWidth(e3) {
          return e3 >> 1 & 3;
        }
        static extractCharKind(e3) {
          return e3 >> 3;
        }
        static createPropertyValue(e3, t3, i4 = false) {
          return (16777215 & e3) << 3 | (3 & t3) << 1 | (i4 ? 1 : 0);
        }
        constructor() {
          this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new s2.EventEmitter(), this.onChange = this._onChange.event;
          const e3 = new r.UnicodeV6();
          this.register(e3), this._active = e3.version, this._activeProvider = e3;
        }
        dispose() {
          this._onChange.dispose();
        }
        get versions() {
          return Object.keys(this._providers);
        }
        get activeVersion() {
          return this._active;
        }
        set activeVersion(e3) {
          if (!this._providers[e3]) throw new Error(`unknown Unicode version "${e3}"`);
          this._active = e3, this._activeProvider = this._providers[e3], this._onChange.fire(e3);
        }
        register(e3) {
          this._providers[e3.version] = e3;
        }
        wcwidth(e3) {
          return this._activeProvider.wcwidth(e3);
        }
        getStringCellWidth(e3) {
          let t3 = 0, i4 = 0;
          const s3 = e3.length;
          for (let r2 = 0; r2 < s3; ++r2) {
            let o = e3.charCodeAt(r2);
            if (55296 <= o && o <= 56319) {
              if (++r2 >= s3) return t3 + this.wcwidth(o);
              const i5 = e3.charCodeAt(r2);
              56320 <= i5 && i5 <= 57343 ? o = 1024 * (o - 55296) + i5 - 56320 + 65536 : t3 += this.wcwidth(i5);
            }
            const a = this.charProperties(o, i4);
            let h2 = n.extractWidth(a);
            n.extractShouldJoin(a) && (h2 -= n.extractWidth(i4)), t3 += h2, i4 = a;
          }
          return t3;
        }
        charProperties(e3, t3) {
          return this._activeProvider.charProperties(e3, t3);
        }
      }
      t2.UnicodeService = n;
    } }, t = {};
    function i2(s2) {
      var r = t[s2];
      if (void 0 !== r) return r.exports;
      var n = t[s2] = { exports: {} };
      return e[s2].call(n.exports, n, n.exports, i2), n.exports;
    }
    __name(i2, "i");
    var s = {};
    return (() => {
      var e2 = s;
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Terminal = void 0;
      const t2 = i2(9042), r = i2(3236), n = i2(844), o = i2(5741), a = i2(8285), h2 = i2(7975), c = i2(7090), l = ["cols", "rows"];
      class d extends n.Disposable {
        static {
          __name(this, "d");
        }
        constructor(e3) {
          super(), this._core = this.register(new r.Terminal(e3)), this._addonManager = this.register(new o.AddonManager()), this._publicOptions = { ...this._core.options };
          const t3 = /* @__PURE__ */ __name((e4) => this._core.options[e4], "t"), i3 = /* @__PURE__ */ __name((e4, t4) => {
            this._checkReadonlyOptions(e4), this._core.options[e4] = t4;
          }, "i");
          for (const e4 in this._core.options) {
            const s2 = { get: t3.bind(this, e4), set: i3.bind(this, e4) };
            Object.defineProperty(this._publicOptions, e4, s2);
          }
        }
        _checkReadonlyOptions(e3) {
          if (l.includes(e3)) throw new Error(`Option "${e3}" can only be set in the constructor`);
        }
        _checkProposedApi() {
          if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
        }
        get onBell() {
          return this._core.onBell;
        }
        get onBinary() {
          return this._core.onBinary;
        }
        get onCursorMove() {
          return this._core.onCursorMove;
        }
        get onData() {
          return this._core.onData;
        }
        get onKey() {
          return this._core.onKey;
        }
        get onLineFeed() {
          return this._core.onLineFeed;
        }
        get onRender() {
          return this._core.onRender;
        }
        get onResize() {
          return this._core.onResize;
        }
        get onScroll() {
          return this._core.onScroll;
        }
        get onSelectionChange() {
          return this._core.onSelectionChange;
        }
        get onTitleChange() {
          return this._core.onTitleChange;
        }
        get onWriteParsed() {
          return this._core.onWriteParsed;
        }
        get element() {
          return this._core.element;
        }
        get parser() {
          return this._parser || (this._parser = new h2.ParserApi(this._core)), this._parser;
        }
        get unicode() {
          return this._checkProposedApi(), new c.UnicodeApi(this._core);
        }
        get textarea() {
          return this._core.textarea;
        }
        get rows() {
          return this._core.rows;
        }
        get cols() {
          return this._core.cols;
        }
        get buffer() {
          return this._buffer || (this._buffer = this.register(new a.BufferNamespaceApi(this._core))), this._buffer;
        }
        get markers() {
          return this._checkProposedApi(), this._core.markers;
        }
        get modes() {
          const e3 = this._core.coreService.decPrivateModes;
          let t3 = "none";
          switch (this._core.coreMouseService.activeProtocol) {
            case "X10":
              t3 = "x10";
              break;
            case "VT200":
              t3 = "vt200";
              break;
            case "DRAG":
              t3 = "drag";
              break;
            case "ANY":
              t3 = "any";
          }
          return { applicationCursorKeysMode: e3.applicationCursorKeys, applicationKeypadMode: e3.applicationKeypad, bracketedPasteMode: e3.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: t3, originMode: e3.origin, reverseWraparoundMode: e3.reverseWraparound, sendFocusMode: e3.sendFocus, wraparoundMode: e3.wraparound };
        }
        get options() {
          return this._publicOptions;
        }
        set options(e3) {
          for (const t3 in e3) this._publicOptions[t3] = e3[t3];
        }
        blur() {
          this._core.blur();
        }
        focus() {
          this._core.focus();
        }
        input(e3, t3 = true) {
          this._core.input(e3, t3);
        }
        resize(e3, t3) {
          this._verifyIntegers(e3, t3), this._core.resize(e3, t3);
        }
        open(e3) {
          this._core.open(e3);
        }
        attachCustomKeyEventHandler(e3) {
          this._core.attachCustomKeyEventHandler(e3);
        }
        attachCustomWheelEventHandler(e3) {
          this._core.attachCustomWheelEventHandler(e3);
        }
        registerLinkProvider(e3) {
          return this._core.registerLinkProvider(e3);
        }
        registerCharacterJoiner(e3) {
          return this._checkProposedApi(), this._core.registerCharacterJoiner(e3);
        }
        deregisterCharacterJoiner(e3) {
          this._checkProposedApi(), this._core.deregisterCharacterJoiner(e3);
        }
        registerMarker(e3 = 0) {
          return this._verifyIntegers(e3), this._core.registerMarker(e3);
        }
        registerDecoration(e3) {
          return this._checkProposedApi(), this._verifyPositiveIntegers(e3.x ?? 0, e3.width ?? 0, e3.height ?? 0), this._core.registerDecoration(e3);
        }
        hasSelection() {
          return this._core.hasSelection();
        }
        select(e3, t3, i3) {
          this._verifyIntegers(e3, t3, i3), this._core.select(e3, t3, i3);
        }
        getSelection() {
          return this._core.getSelection();
        }
        getSelectionPosition() {
          return this._core.getSelectionPosition();
        }
        clearSelection() {
          this._core.clearSelection();
        }
        selectAll() {
          this._core.selectAll();
        }
        selectLines(e3, t3) {
          this._verifyIntegers(e3, t3), this._core.selectLines(e3, t3);
        }
        dispose() {
          super.dispose();
        }
        scrollLines(e3) {
          this._verifyIntegers(e3), this._core.scrollLines(e3);
        }
        scrollPages(e3) {
          this._verifyIntegers(e3), this._core.scrollPages(e3);
        }
        scrollToTop() {
          this._core.scrollToTop();
        }
        scrollToBottom() {
          this._core.scrollToBottom();
        }
        scrollToLine(e3) {
          this._verifyIntegers(e3), this._core.scrollToLine(e3);
        }
        clear() {
          this._core.clear();
        }
        write(e3, t3) {
          this._core.write(e3, t3);
        }
        writeln(e3, t3) {
          this._core.write(e3), this._core.write("\r\n", t3);
        }
        paste(e3) {
          this._core.paste(e3);
        }
        refresh(e3, t3) {
          this._verifyIntegers(e3, t3), this._core.refresh(e3, t3);
        }
        reset() {
          this._core.reset();
        }
        clearTextureAtlas() {
          this._core.clearTextureAtlas();
        }
        loadAddon(e3) {
          this._addonManager.loadAddon(this, e3);
        }
        static get strings() {
          return t2;
        }
        _verifyIntegers(...e3) {
          for (const t3 of e3) if (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0) throw new Error("This API only accepts integers");
        }
        _verifyPositiveIntegers(...e3) {
          for (const t3 of e3) if (t3 && (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0 || t3 < 0)) throw new Error("This API only accepts positive integers");
        }
      }
      e2.Terminal = d;
    })(), s;
  })());
})(xterm$2, xterm$2.exports);
var xtermExports = xterm$2.exports;
const xterm$1 = /* @__PURE__ */ getDefaultExportFromCjs(xtermExports);
var addonFit$2 = { exports: {} };
var addonFit = addonFit$2.exports;
(function(module, exports) {
  !function(e, t) {
    true ? module.exports = t() : false ? (void 0)([], t) : true ? exports.FitAddon = t() : e.FitAddon = t();
  }(self, () => (() => {
    "use strict";
    var e = {};
    return (() => {
      var t = e;
      Object.defineProperty(t, "__esModule", { value: true }), t.FitAddon = void 0, t.FitAddon = class {
        activate(e2) {
          this._terminal = e2;
        }
        dispose() {
        }
        fit() {
          const e2 = this.proposeDimensions();
          if (!e2 || !this._terminal || isNaN(e2.cols) || isNaN(e2.rows)) return;
          const t2 = this._terminal._core;
          this._terminal.rows === e2.rows && this._terminal.cols === e2.cols || (t2._renderService.clear(), this._terminal.resize(e2.cols, e2.rows));
        }
        proposeDimensions() {
          if (!this._terminal) return;
          if (!this._terminal.element || !this._terminal.element.parentElement) return;
          const e2 = this._terminal._core, t2 = e2._renderService.dimensions;
          if (0 === t2.css.cell.width || 0 === t2.css.cell.height) return;
          const r = 0 === this._terminal.options.scrollback ? 0 : e2.viewport.scrollBarWidth, i2 = window.getComputedStyle(this._terminal.element.parentElement), o = parseInt(i2.getPropertyValue("height")), s = Math.max(0, parseInt(i2.getPropertyValue("width"))), n = window.getComputedStyle(this._terminal.element), l = o - (parseInt(n.getPropertyValue("padding-top")) + parseInt(n.getPropertyValue("padding-bottom"))), a = s - (parseInt(n.getPropertyValue("padding-right")) + parseInt(n.getPropertyValue("padding-left"))) - r;
          return { cols: Math.max(2, Math.floor(a / t2.css.cell.width)), rows: Math.max(1, Math.floor(l / t2.css.cell.height)) };
        }
      };
    })(), e;
  })());
})(addonFit$2, addonFit$2.exports);
var addonFitExports = addonFit$2.exports;
const addonFit$1 = /* @__PURE__ */ getDefaultExportFromCjs(addonFitExports);
var theme$g = /* @__PURE__ */ __name(function theme21(_ref) {
  var dt2 = _ref.dt;
  return '\n.p-progressspinner {\n    position: relative;\n    margin: 0 auto;\n    width: 100px;\n    height: 100px;\n    display: inline-block;\n}\n\n.p-progressspinner::before {\n    content: "";\n    display: block;\n    padding-top: 100%;\n}\n\n.p-progressspinner-spin {\n    height: 100%;\n    transform-origin: center center;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n    animation: p-progressspinner-rotate 2s linear infinite;\n}\n\n.p-progressspinner-circle {\n    stroke-dasharray: 89, 200;\n    stroke-dashoffset: 0;\n    stroke: '.concat(dt2("progressspinner.color.1"), ";\n    animation: p-progressspinner-dash 1.5s ease-in-out infinite, p-progressspinner-color 6s ease-in-out infinite;\n    stroke-linecap: round;\n}\n\n@keyframes p-progressspinner-rotate {\n    100% {\n        transform: rotate(360deg);\n    }\n}\n@keyframes p-progressspinner-dash {\n    0% {\n        stroke-dasharray: 1, 200;\n        stroke-dashoffset: 0;\n    }\n    50% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -35px;\n    }\n    100% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -124px;\n    }\n}\n@keyframes p-progressspinner-color {\n    100%,\n    0% {\n        stroke: ").concat(dt2("progressspinner.color.1"), ";\n    }\n    40% {\n        stroke: ").concat(dt2("progressspinner.color.2"), ";\n    }\n    66% {\n        stroke: ").concat(dt2("progressspinner.color.3"), ";\n    }\n    80%,\n    90% {\n        stroke: ").concat(dt2("progressspinner.color.4"), ";\n    }\n}\n");
}, "theme");
var classes$g = {
  root: "p-progressspinner",
  spin: "p-progressspinner-spin",
  circle: "p-progressspinner-circle"
};
var ProgressSpinnerStyle = BaseStyle.extend({
  name: "progressspinner",
  theme: theme$g,
  classes: classes$g
});
var script$1$f = {
  name: "BaseProgressSpinner",
  "extends": script$Y,
  props: {
    strokeWidth: {
      type: String,
      "default": "2"
    },
    fill: {
      type: String,
      "default": "none"
    },
    animationDuration: {
      type: String,
      "default": "2s"
    }
  },
  style: ProgressSpinnerStyle,
  provide: /* @__PURE__ */ __name(function provide23() {
    return {
      $pcProgressSpinner: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$s = {
  name: "ProgressSpinner",
  "extends": script$1$f,
  inheritAttrs: false,
  computed: {
    svgStyle: /* @__PURE__ */ __name(function svgStyle() {
      return {
        "animation-duration": this.animationDuration
      };
    }, "svgStyle")
  }
};
var _hoisted_1$Q = ["fill", "stroke-width"];
function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "progressbar"
  }, _ctx.ptmi("root")), [(openBlock(), createElementBlock("svg", mergeProps({
    "class": _ctx.cx("spin"),
    viewBox: "25 25 50 50",
    style: $options.svgStyle
  }, _ctx.ptm("spin")), [createBaseVNode("circle", mergeProps({
    "class": _ctx.cx("circle"),
    cx: "50",
    cy: "50",
    r: "20",
    fill: _ctx.fill,
    "stroke-width": _ctx.strokeWidth,
    strokeMiterlimit: "10"
  }, _ctx.ptm("circle")), null, 16, _hoisted_1$Q)], 16))], 16);
}
__name(render$r, "render$r");
script$s.render = render$r;
const useExecutionStore = /* @__PURE__ */ defineStore("execution", () => {
  const clientId = ref(null);
  const activePromptId = ref(null);
  const queuedPrompts = ref({});
  const executingNodeId = ref(null);
  const executingNode = computed(() => {
    if (!executingNodeId.value) return null;
    const workflow = activePrompt.value?.workflow;
    if (!workflow) return null;
    const canvasState = workflow.changeTracker?.activeState ?? null;
    if (!canvasState) return null;
    return canvasState.nodes.find(
      (n) => String(n.id) === executingNodeId.value
    ) ?? null;
  });
  const _executingNodeProgress = ref(null);
  const executingNodeProgress = computed(
    () => _executingNodeProgress.value ? Math.round(
      _executingNodeProgress.value.value / _executingNodeProgress.value.max * 100
    ) : null
  );
  const activePrompt = computed(
    () => queuedPrompts.value[activePromptId.value ?? ""]
  );
  const totalNodesToExecute = computed(() => {
    if (!activePrompt.value) return 0;
    return Object.values(activePrompt.value.nodes).length;
  });
  const isIdle = computed(() => !activePromptId.value);
  const nodesExecuted = computed(() => {
    if (!activePrompt.value) return 0;
    return Object.values(activePrompt.value.nodes).filter(Boolean).length;
  });
  const executionProgress = computed(() => {
    if (!activePrompt.value) return 0;
    const total = totalNodesToExecute.value;
    const done = nodesExecuted.value;
    return Math.round(done / total * 100);
  });
  function bindExecutionEvents() {
    api.addEventListener(
      "execution_start",
      handleExecutionStart
    );
    api.addEventListener(
      "execution_cached",
      handleExecutionCached
    );
    api.addEventListener("executed", handleExecuted);
    api.addEventListener("executing", handleExecuting);
    api.addEventListener("progress", handleProgress);
    api.addEventListener("status", handleStatus);
  }
  __name(bindExecutionEvents, "bindExecutionEvents");
  function unbindExecutionEvents() {
    api.removeEventListener(
      "execution_start",
      handleExecutionStart
    );
    api.removeEventListener(
      "execution_cached",
      handleExecutionCached
    );
    api.removeEventListener("executed", handleExecuted);
    api.removeEventListener("executing", handleExecuting);
    api.removeEventListener("progress", handleProgress);
    api.removeEventListener("status", handleStatus);
  }
  __name(unbindExecutionEvents, "unbindExecutionEvents");
  function handleExecutionStart(e) {
    activePromptId.value = e.detail.prompt_id;
    queuedPrompts.value[activePromptId.value] ??= { nodes: {} };
  }
  __name(handleExecutionStart, "handleExecutionStart");
  function handleExecutionCached(e) {
    if (!activePrompt.value) return;
    for (const n of e.detail.nodes) {
      activePrompt.value.nodes[n] = true;
    }
  }
  __name(handleExecutionCached, "handleExecutionCached");
  function handleExecuted(e) {
    if (!activePrompt.value) return;
    activePrompt.value.nodes[e.detail.node] = true;
  }
  __name(handleExecuted, "handleExecuted");
  function handleExecuting(e) {
    _executingNodeProgress.value = null;
    if (!activePrompt.value) return;
    if (executingNodeId.value && activePrompt.value) {
      activePrompt.value.nodes[executingNodeId.value] = true;
    }
    executingNodeId.value = e.detail ? String(e.detail) : null;
    if (!executingNodeId.value) {
      if (activePromptId.value) {
        delete queuedPrompts.value[activePromptId.value];
      }
      activePromptId.value = null;
    }
  }
  __name(handleExecuting, "handleExecuting");
  function handleProgress(e) {
    _executingNodeProgress.value = e.detail;
  }
  __name(handleProgress, "handleProgress");
  function handleStatus(e) {
    if (api.clientId) {
      clientId.value = api.clientId;
      api.removeEventListener("status", handleStatus);
    }
  }
  __name(handleStatus, "handleStatus");
  function storePrompt({
    nodes,
    id: id3,
    workflow
  }) {
    queuedPrompts.value[id3] ??= { nodes: {} };
    const queuedPrompt = queuedPrompts.value[id3];
    queuedPrompt.nodes = {
      ...nodes.reduce((p2, n) => {
        p2[n] = false;
        return p2;
      }, {}),
      ...queuedPrompt.nodes
    };
    queuedPrompt.workflow = workflow;
    console.debug(
      `queued task ${id3} with ${Object.values(queuedPrompt.nodes).length} nodes`
    );
  }
  __name(storePrompt, "storePrompt");
  return {
    isIdle,
    clientId,
    activePromptId,
    queuedPrompts,
    executingNodeId,
    activePrompt,
    totalNodesToExecute,
    nodesExecuted,
    executionProgress,
    executingNode,
    executingNodeProgress,
    bindExecutionEvents,
    unbindExecutionEvents,
    storePrompt
  };
});
var isVue2$1 = false;
var isVue3$1 = true;
var Vue2$1 = void 0;
function install$1() {
}
__name(install$1, "install$1");
function set$2(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
__name(set$2, "set$2");
function del$1(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
__name(del$1, "del$1");
function computedEager(fn, options3) {
  var _a;
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, {
    ...options3,
    flush: (_a = options3 == null ? void 0 : options3.flush) != null ? _a : "sync"
  });
  return readonly(result);
}
__name(computedEager, "computedEager");
function computedWithControl(source, fn) {
  let v2 = void 0;
  let track2;
  let trigger2;
  const dirty = ref(true);
  const update = /* @__PURE__ */ __name(() => {
    dirty.value = true;
    trigger2();
  }, "update");
  watch(source, update, { flush: "sync" });
  const get2 = typeof fn === "function" ? fn : fn.get;
  const set2 = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track2 = _track;
    trigger2 = _trigger;
    return {
      get() {
        if (dirty.value) {
          v2 = get2(v2);
          dirty.value = false;
        }
        track2();
        return v2;
      },
      set(v22) {
        set2 == null ? void 0 : set2(v22);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}
__name(computedWithControl, "computedWithControl");
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
__name(tryOnScopeDispose, "tryOnScopeDispose");
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = /* @__PURE__ */ __name((fn) => {
    fns.delete(fn);
  }, "off");
  const on = /* @__PURE__ */ __name((fn) => {
    fns.add(fn);
    const offFn = /* @__PURE__ */ __name(() => off(fn), "offFn");
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  }, "on");
  const trigger2 = /* @__PURE__ */ __name((...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  }, "trigger");
  return {
    on,
    off,
    trigger: trigger2
  };
}
__name(createEventHook, "createEventHook");
function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = effectScope(true);
  return (...args) => {
    if (!initialized) {
      state = scope.run(() => stateFactory(...args));
      initialized = true;
    }
    return state;
  };
}
__name(createGlobalState, "createGlobalState");
const localProvidedStateMap = /* @__PURE__ */ new WeakMap();
const provideLocal = /* @__PURE__ */ __name((key, value3) => {
  var _a;
  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;
  if (instance == null)
    throw new Error("provideLocal must be called in setup");
  if (!localProvidedStateMap.has(instance))
    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));
  const localProvidedState = localProvidedStateMap.get(instance);
  localProvidedState[key] = value3;
  provide(key, value3);
}, "provideLocal");
const injectLocal = /* @__PURE__ */ __name((...args) => {
  var _a;
  const key = args[0];
  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;
  if (instance == null)
    throw new Error("injectLocal must be called in setup");
  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))
    return localProvidedStateMap.get(instance)[key];
  return inject(...args);
}, "injectLocal");
function createInjectionState(composable, options3) {
  const key = (options3 == null ? void 0 : options3.injectionKey) || Symbol(composable.name || "InjectionState");
  const defaultValue = options3 == null ? void 0 : options3.defaultValue;
  const useProvidingState = /* @__PURE__ */ __name((...args) => {
    const state = composable(...args);
    provideLocal(key, state);
    return state;
  }, "useProvidingState");
  const useInjectedState = /* @__PURE__ */ __name(() => injectLocal(key, defaultValue), "useInjectedState");
  return [useProvidingState, useInjectedState];
}
__name(createInjectionState, "createInjectionState");
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = /* @__PURE__ */ __name(() => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  }, "dispose");
  return (...args) => {
    subscribers += 1;
    if (!state) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}
__name(createSharedComposable, "createSharedComposable");
function extendRef(ref2, extend4, { enumerable = false, unwrap = true } = {}) {
  if (!isVue3$1 && !version.startsWith("2.7.")) {
    if (false)
      throw new Error("[VueUse] extendRef only works in Vue 2.7 or above.");
    return;
  }
  for (const [key, value3] of Object.entries(extend4)) {
    if (key === "value")
      continue;
    if (isRef(value3) && unwrap) {
      Object.defineProperty(ref2, key, {
        get() {
          return value3.value;
        },
        set(v2) {
          value3.value = v2;
        },
        enumerable
      });
    } else {
      Object.defineProperty(ref2, key, { value: value3, enumerable });
    }
  }
  return ref2;
}
__name(extendRef, "extendRef");
function get$2(obj, key) {
  if (key == null)
    return unref(obj);
  return unref(obj)[key];
}
__name(get$2, "get$2");
function isDefined$1(v2) {
  return unref(v2) != null;
}
__name(isDefined$1, "isDefined$1");
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone2 = { ...obj };
    Object.defineProperty(clone2, Symbol.iterator, {
      enumerable: false,
      value() {
        let index2 = 0;
        return {
          next: /* @__PURE__ */ __name(() => ({
            value: arr[index2++],
            done: index2 > arr.length
          }), "next")
        };
      }
    });
    return clone2;
  } else {
    return Object.assign([...arr], obj);
  }
}
__name(makeDestructurable, "makeDestructurable");
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
__name(toValue, "toValue");
const resolveUnref = toValue;
function reactify(fn, options3) {
  const unrefFn = (options3 == null ? void 0 : options3.computedGetter) === false ? unref : toValue;
  return function(...args) {
    return computed(() => fn.apply(this, args.map((i2) => unrefFn(i2))));
  };
}
__name(reactify, "reactify");
function reactifyObject(obj, optionsOrKeys = {}) {
  let keys2 = [];
  let options3;
  if (Array.isArray(optionsOrKeys)) {
    keys2 = optionsOrKeys;
  } else {
    options3 = optionsOrKeys;
    const { includeOwnProperties = true } = optionsOrKeys;
    keys2.push(...Object.keys(obj));
    if (includeOwnProperties)
      keys2.push(...Object.getOwnPropertyNames(obj));
  }
  return Object.fromEntries(
    keys2.map((key) => {
      const value3 = obj[key];
      return [
        key,
        typeof value3 === "function" ? reactify(value3.bind(obj), options3) : value3
      ];
    })
  );
}
__name(reactifyObject, "reactifyObject");
function toReactive(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_2, p2, receiver) {
      return unref(Reflect.get(objectRef.value, p2, receiver));
    },
    set(_2, p2, value3) {
      if (isRef(objectRef.value[p2]) && !isRef(value3))
        objectRef.value[p2].value = value3;
      else
        objectRef.value[p2] = value3;
      return true;
    },
    deleteProperty(_2, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(_2, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
__name(toReactive, "toReactive");
function reactiveComputed(fn) {
  return toReactive(computed(fn));
}
__name(reactiveComputed, "reactiveComputed");
function reactiveOmit(obj, ...keys2) {
  const flatKeys = keys2.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v2]) => !predicate(toValue(v2), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
__name(reactiveOmit, "reactiveOmit");
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
const isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const isDef = /* @__PURE__ */ __name((val) => typeof val !== "undefined", "isDef");
const notNullish = /* @__PURE__ */ __name((val) => val != null, "notNullish");
const assert = /* @__PURE__ */ __name((condition, ...infos) => {
  if (!condition)
    console.warn(...infos);
}, "assert");
const toString$1 = Object.prototype.toString;
const isObject$1 = /* @__PURE__ */ __name((val) => toString$1.call(val) === "[object Object]", "isObject$1");
const now = /* @__PURE__ */ __name(() => Date.now(), "now");
const timestamp = /* @__PURE__ */ __name(() => +Date.now(), "timestamp");
const clamp = /* @__PURE__ */ __name((n, min, max) => Math.min(max, Math.max(min, n)), "clamp");
const noop$1 = /* @__PURE__ */ __name(() => {
}, "noop$1");
const rand = /* @__PURE__ */ __name((min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}, "rand");
const hasOwn$1 = /* @__PURE__ */ __name((val, key) => Object.prototype.hasOwnProperty.call(val, key), "hasOwn$1");
const isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
__name(getIsIOS, "getIsIOS");
function createFilterWrapper(filter4, fn) {
  function wrapper(...args) {
    return new Promise((resolve2, reject2) => {
      Promise.resolve(filter4(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve2).catch(reject2);
    });
  }
  __name(wrapper, "wrapper");
  return wrapper;
}
__name(createFilterWrapper, "createFilterWrapper");
const bypassFilter = /* @__PURE__ */ __name((invoke2) => {
  return invoke2();
}, "bypassFilter");
function debounceFilter(ms, options3 = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop$1;
  const _clearTimeout = /* @__PURE__ */ __name((timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop$1;
  }, "_clearTimeout");
  const filter4 = /* @__PURE__ */ __name((invoke2) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options3.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke2());
    }
    return new Promise((resolve2, reject2) => {
      lastRejector = options3.rejectOnCancel ? reject2 : resolve2;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve2(invoke2());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve2(invoke2());
      }, duration);
    });
  }, "filter");
  return filter4;
}
__name(debounceFilter, "debounceFilter");
function throttleFilter(...args) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  let lastRejector = noop$1;
  let lastValue;
  let ms;
  let trailing;
  let leading;
  let rejectOnCancel;
  if (!isRef(args[0]) && typeof args[0] === "object")
    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);
  else
    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;
  const clear2 = /* @__PURE__ */ __name(() => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
      lastRejector();
      lastRejector = noop$1;
    }
  }, "clear");
  const filter4 = /* @__PURE__ */ __name((_invoke) => {
    const duration = toValue(ms);
    const elapsed = Date.now() - lastExec;
    const invoke2 = /* @__PURE__ */ __name(() => {
      return lastValue = _invoke();
    }, "invoke2");
    clear2();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke2();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke2();
    } else if (trailing) {
      lastValue = new Promise((resolve2, reject2) => {
        lastRejector = rejectOnCancel ? reject2 : resolve2;
        timer = setTimeout(() => {
          lastExec = Date.now();
          isLeading = true;
          resolve2(invoke2());
          clear2();
        }, Math.max(0, duration - elapsed));
      });
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
    return lastValue;
  }, "filter");
  return filter4;
}
__name(throttleFilter, "throttleFilter");
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  __name(pause, "pause");
  function resume() {
    isActive.value = true;
  }
  __name(resume, "resume");
  const eventFilter = /* @__PURE__ */ __name((...args) => {
    if (isActive.value)
      extendFilter(...args);
  }, "eventFilter");
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
__name(pausableFilter, "pausableFilter");
const directiveHooks = {
  mounted: isVue3$1 ? "mounted" : "inserted",
  updated: isVue3$1 ? "updated" : "componentUpdated",
  unmounted: isVue3$1 ? "unmounted" : "unbind"
};
function cacheStringFunction(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
}
__name(cacheStringFunction, "cacheStringFunction");
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
});
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve2, reject2) => {
    if (throwOnTimeout)
      setTimeout(() => reject2(reason), ms);
    else
      setTimeout(resolve2, ms);
  });
}
__name(promiseTimeout, "promiseTimeout");
function identity(arg) {
  return arg;
}
__name(identity, "identity");
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  __name(wrapper, "wrapper");
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
__name(createSingletonPromise, "createSingletonPromise");
function invoke(fn) {
  return fn();
}
__name(invoke, "invoke");
function containsProp(obj, ...props) {
  return props.some((k) => k in obj);
}
__name(containsProp, "containsProp");
function increaseWithUnit(target, delta2) {
  var _a;
  if (typeof target === "number")
    return target + delta2;
  const value3 = ((_a = target.match(/^-?\d+\.?\d*/)) == null ? void 0 : _a[0]) || "";
  const unit = target.slice(value3.length);
  const result = Number.parseFloat(value3) + delta2;
  if (Number.isNaN(result))
    return target;
  return result + unit;
}
__name(increaseWithUnit, "increaseWithUnit");
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}
__name(objectPick, "objectPick");
function objectOmit(obj, keys2, omitUndefined = false) {
  return Object.fromEntries(Object.entries(obj).filter(([key, value3]) => {
    return (!omitUndefined || value3 !== void 0) && !keys2.includes(key);
  }));
}
__name(objectOmit, "objectOmit");
function objectEntries(obj) {
  return Object.entries(obj);
}
__name(objectEntries, "objectEntries");
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
__name(getLifeCycleTarget, "getLifeCycleTarget");
function toRef(...args) {
  if (args.length !== 1)
    return toRef$1(...args);
  const r = args[0];
  return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop$1 }))) : ref(r);
}
__name(toRef, "toRef");
const resolveRef = toRef;
function reactivePick(obj, ...keys2) {
  const flatKeys = keys2.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v2]) => predicate(toValue(v2), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));
}
__name(reactivePick, "reactivePick");
function refAutoReset(defaultValue, afterMs = 1e4) {
  return customRef((track2, trigger2) => {
    let value3 = toValue(defaultValue);
    let timer;
    const resetAfter = /* @__PURE__ */ __name(() => setTimeout(() => {
      value3 = toValue(defaultValue);
      trigger2();
    }, toValue(afterMs)), "resetAfter");
    tryOnScopeDispose(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track2();
        return value3;
      },
      set(newValue) {
        value3 = newValue;
        trigger2();
        clearTimeout(timer);
        timer = resetAfter();
      }
    };
  });
}
__name(refAutoReset, "refAutoReset");
function useDebounceFn(fn, ms = 200, options3 = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options3),
    fn
  );
}
__name(useDebounceFn, "useDebounceFn");
function refDebounced(value3, ms = 200, options3 = {}) {
  const debounced = ref(value3.value);
  const updater = useDebounceFn(() => {
    debounced.value = value3.value;
  }, ms, options3);
  watch(value3, () => updater());
  return debounced;
}
__name(refDebounced, "refDebounced");
function refDefault(source, defaultValue) {
  return computed({
    get() {
      var _a;
      return (_a = source.value) != null ? _a : defaultValue;
    },
    set(value3) {
      source.value = value3;
    }
  });
}
__name(refDefault, "refDefault");
function useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
  return createFilterWrapper(
    throttleFilter(ms, trailing, leading, rejectOnCancel),
    fn
  );
}
__name(useThrottleFn, "useThrottleFn");
function refThrottled(value3, delay = 200, trailing = true, leading = true) {
  if (delay <= 0)
    return value3;
  const throttled = ref(value3.value);
  const updater = useThrottleFn(() => {
    throttled.value = value3.value;
  }, delay, trailing, leading);
  watch(value3, () => updater());
  return throttled;
}
__name(refThrottled, "refThrottled");
function refWithControl(initial, options3 = {}) {
  let source = initial;
  let track2;
  let trigger2;
  const ref2 = customRef((_track, _trigger) => {
    track2 = _track;
    trigger2 = _trigger;
    return {
      get() {
        return get2();
      },
      set(v2) {
        set2(v2);
      }
    };
  });
  function get2(tracking = true) {
    if (tracking)
      track2();
    return source;
  }
  __name(get2, "get2");
  function set2(value3, triggering = true) {
    var _a, _b;
    if (value3 === source)
      return;
    const old = source;
    if (((_a = options3.onBeforeChange) == null ? void 0 : _a.call(options3, value3, old)) === false)
      return;
    source = value3;
    (_b = options3.onChanged) == null ? void 0 : _b.call(options3, value3, old);
    if (triggering)
      trigger2();
  }
  __name(set2, "set2");
  const untrackedGet = /* @__PURE__ */ __name(() => get2(false), "untrackedGet");
  const silentSet = /* @__PURE__ */ __name((v2) => set2(v2, false), "silentSet");
  const peek = /* @__PURE__ */ __name(() => get2(false), "peek");
  const lay = /* @__PURE__ */ __name((v2) => set2(v2, false), "lay");
  return extendRef(
    ref2,
    {
      get: get2,
      set: set2,
      untrackedGet,
      silentSet,
      peek,
      lay
    },
    { enumerable: true }
  );
}
__name(refWithControl, "refWithControl");
const controlledRef = refWithControl;
function set$1(...args) {
  if (args.length === 2) {
    const [ref2, value3] = args;
    ref2.value = value3;
  }
  if (args.length === 3) {
    if (isVue2$1) {
      set$2(...args);
    } else {
      const [target, key, value3] = args;
      target[key] = value3;
    }
  }
}
__name(set$1, "set$1");
function watchWithFilter(source, cb, options3 = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options3;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
__name(watchWithFilter, "watchWithFilter");
function watchPausable(source, cb, options3 = {}) {
  const {
    eventFilter: filter4,
    ...watchOptions
  } = options3;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter4);
  const stop2 = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop: stop2, pause, resume, isActive };
}
__name(watchPausable, "watchPausable");
function syncRef(left, right, ...[options3]) {
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both",
    transform: transform2 = {}
  } = options3 || {};
  const watchers = [];
  const transformLTR = "ltr" in transform2 && transform2.ltr || ((v2) => v2);
  const transformRTL = "rtl" in transform2 && transform2.rtl || ((v2) => v2);
  if (direction === "both" || direction === "ltr") {
    watchers.push(watchPausable(
      left,
      (newValue) => {
        watchers.forEach((w2) => w2.pause());
        right.value = transformLTR(newValue);
        watchers.forEach((w2) => w2.resume());
      },
      { flush, deep, immediate }
    ));
  }
  if (direction === "both" || direction === "rtl") {
    watchers.push(watchPausable(
      right,
      (newValue) => {
        watchers.forEach((w2) => w2.pause());
        left.value = transformRTL(newValue);
        watchers.forEach((w2) => w2.resume());
      },
      { flush, deep, immediate }
    ));
  }
  const stop2 = /* @__PURE__ */ __name(() => {
    watchers.forEach((w2) => w2.stop());
  }, "stop");
  return stop2;
}
__name(syncRef, "syncRef");
function syncRefs(source, targets, options3 = {}) {
  const {
    flush = "sync",
    deep = false,
    immediate = true
  } = options3;
  if (!Array.isArray(targets))
    targets = [targets];
  return watch(
    source,
    (newValue) => targets.forEach((target) => target.value = newValue),
    { flush, deep, immediate }
  );
}
__name(syncRefs, "syncRefs");
function toRefs(objectRef, options3 = {}) {
  if (!isRef(objectRef))
    return toRefs$1(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v2) {
        var _a;
        const replaceRef = (_a = toValue(options3.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v2;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v2 };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v2;
        }
      }
    }));
  }
  return result;
}
__name(toRefs, "toRefs");
function tryOnBeforeMount(fn, sync = true, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onBeforeMount(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
__name(tryOnBeforeMount, "tryOnBeforeMount");
function tryOnBeforeUnmount(fn, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onBeforeUnmount(fn, target);
}
__name(tryOnBeforeUnmount, "tryOnBeforeUnmount");
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
__name(tryOnMounted, "tryOnMounted");
function tryOnUnmounted(fn, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onUnmounted(fn, target);
}
__name(tryOnUnmounted, "tryOnUnmounted");
function createUntil(r, isNot = false) {
  function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
    let stop2 = null;
    const watcher = new Promise((resolve2) => {
      stop2 = watch(
        r,
        (v2) => {
          if (condition(v2) !== isNot) {
            if (stop2)
              stop2();
            else
              nextTick(() => stop2 == null ? void 0 : stop2());
            resolve2(v2);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop2 == null ? void 0 : stop2())
      );
    }
    return Promise.race(promises);
  }
  __name(toMatch, "toMatch");
  function toBe(value3, options3) {
    if (!isRef(value3))
      return toMatch((v2) => v2 === value3, options3);
    const { flush = "sync", deep = false, timeout, throwOnTimeout } = options3 != null ? options3 : {};
    let stop2 = null;
    const watcher = new Promise((resolve2) => {
      stop2 = watch(
        [r, value3],
        ([v1, v2]) => {
          if (isNot !== (v1 === v2)) {
            if (stop2)
              stop2();
            else
              nextTick(() => stop2 == null ? void 0 : stop2());
            resolve2(v1);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {
          stop2 == null ? void 0 : stop2();
          return toValue(r);
        })
      );
    }
    return Promise.race(promises);
  }
  __name(toBe, "toBe");
  function toBeTruthy(options3) {
    return toMatch((v2) => Boolean(v2), options3);
  }
  __name(toBeTruthy, "toBeTruthy");
  function toBeNull(options3) {
    return toBe(null, options3);
  }
  __name(toBeNull, "toBeNull");
  function toBeUndefined(options3) {
    return toBe(void 0, options3);
  }
  __name(toBeUndefined, "toBeUndefined");
  function toBeNaN(options3) {
    return toMatch(Number.isNaN, options3);
  }
  __name(toBeNaN, "toBeNaN");
  function toContains(value3, options3) {
    return toMatch((v2) => {
      const array = Array.from(v2);
      return array.includes(value3) || array.includes(toValue(value3));
    }, options3);
  }
  __name(toContains, "toContains");
  function changed(options3) {
    return changedTimes(1, options3);
  }
  __name(changed, "changed");
  function changedTimes(n = 1, options3) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options3);
  }
  __name(changedTimes, "changedTimes");
  if (Array.isArray(toValue(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  }
}
__name(createUntil, "createUntil");
function until(r) {
  return createUntil(r);
}
__name(until, "until");
function defaultComparator(value3, othVal) {
  return value3 === othVal;
}
__name(defaultComparator, "defaultComparator");
function useArrayDifference(...args) {
  var _a;
  const list = args[0];
  const values2 = args[1];
  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;
  if (typeof compareFn === "string") {
    const key = compareFn;
    compareFn = /* @__PURE__ */ __name((value3, othVal) => value3[key] === othVal[key], "compareFn");
  }
  return computed(() => toValue(list).filter((x2) => toValue(values2).findIndex((y2) => compareFn(x2, y2)) === -1));
}
__name(useArrayDifference, "useArrayDifference");
function useArrayEvery(list, fn) {
  return computed(() => toValue(list).every((element, index2, array) => fn(toValue(element), index2, array)));
}
__name(useArrayEvery, "useArrayEvery");
function useArrayFilter(list, fn) {
  return computed(() => toValue(list).map((i2) => toValue(i2)).filter(fn));
}
__name(useArrayFilter, "useArrayFilter");
function useArrayFind(list, fn) {
  return computed(() => toValue(
    toValue(list).find((element, index2, array) => fn(toValue(element), index2, array))
  ));
}
__name(useArrayFind, "useArrayFind");
function useArrayFindIndex(list, fn) {
  return computed(() => toValue(list).findIndex((element, index2, array) => fn(toValue(element), index2, array)));
}
__name(useArrayFindIndex, "useArrayFindIndex");
function findLast(arr, cb) {
  let index2 = arr.length;
  while (index2-- > 0) {
    if (cb(arr[index2], index2, arr))
      return arr[index2];
  }
  return void 0;
}
__name(findLast, "findLast");
function useArrayFindLast(list, fn) {
  return computed(() => toValue(
    !Array.prototype.findLast ? findLast(toValue(list), (element, index2, array) => fn(toValue(element), index2, array)) : toValue(list).findLast((element, index2, array) => fn(toValue(element), index2, array))
  ));
}
__name(useArrayFindLast, "useArrayFindLast");
function isArrayIncludesOptions(obj) {
  return isObject$1(obj) && containsProp(obj, "formIndex", "comparator");
}
__name(isArrayIncludesOptions, "isArrayIncludesOptions");
function useArrayIncludes(...args) {
  var _a;
  const list = args[0];
  const value3 = args[1];
  let comparator2 = args[2];
  let formIndex = 0;
  if (isArrayIncludesOptions(comparator2)) {
    formIndex = (_a = comparator2.fromIndex) != null ? _a : 0;
    comparator2 = comparator2.comparator;
  }
  if (typeof comparator2 === "string") {
    const key = comparator2;
    comparator2 = /* @__PURE__ */ __name((element, value22) => element[key] === toValue(value22), "comparator");
  }
  comparator2 = comparator2 != null ? comparator2 : (element, value22) => element === toValue(value22);
  return computed(() => toValue(list).slice(formIndex).some((element, index2, array) => comparator2(
    toValue(element),
    toValue(value3),
    index2,
    toValue(array)
  )));
}
__name(useArrayIncludes, "useArrayIncludes");
function useArrayJoin(list, separator) {
  return computed(() => toValue(list).map((i2) => toValue(i2)).join(toValue(separator)));
}
__name(useArrayJoin, "useArrayJoin");
function useArrayMap(list, fn) {
  return computed(() => toValue(list).map((i2) => toValue(i2)).map(fn));
}
__name(useArrayMap, "useArrayMap");
function useArrayReduce(list, reducer, ...args) {
  const reduceCallback = /* @__PURE__ */ __name((sum, value3, index2) => reducer(toValue(sum), toValue(value3), index2), "reduceCallback");
  return computed(() => {
    const resolved = toValue(list);
    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);
  });
}
__name(useArrayReduce, "useArrayReduce");
function useArraySome(list, fn) {
  return computed(() => toValue(list).some((element, index2, array) => fn(toValue(element), index2, array)));
}
__name(useArraySome, "useArraySome");
function uniq(array) {
  return Array.from(new Set(array));
}
__name(uniq, "uniq");
function uniqueElementsBy(array, fn) {
  return array.reduce((acc, v2) => {
    if (!acc.some((x2) => fn(v2, x2, array)))
      acc.push(v2);
    return acc;
  }, []);
}
__name(uniqueElementsBy, "uniqueElementsBy");
function useArrayUnique(list, compareFn) {
  return computed(() => {
    const resolvedList = toValue(list).map((element) => toValue(element));
    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);
  });
}
__name(useArrayUnique, "useArrayUnique");
function useCounter(initialValue = 0, options3 = {}) {
  let _initialValue = unref(initialValue);
  const count = ref(initialValue);
  const {
    max = Number.POSITIVE_INFINITY,
    min = Number.NEGATIVE_INFINITY
  } = options3;
  const inc2 = /* @__PURE__ */ __name((delta2 = 1) => count.value = Math.max(Math.min(max, count.value + delta2), min), "inc");
  const dec = /* @__PURE__ */ __name((delta2 = 1) => count.value = Math.min(Math.max(min, count.value - delta2), max), "dec");
  const get2 = /* @__PURE__ */ __name(() => count.value, "get2");
  const set2 = /* @__PURE__ */ __name((val) => count.value = Math.max(min, Math.min(max, val)), "set2");
  const reset = /* @__PURE__ */ __name((val = _initialValue) => {
    _initialValue = val;
    return set2(val);
  }, "reset");
  return { count, inc: inc2, dec, get: get2, set: set2, reset };
}
__name(useCounter, "useCounter");
const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[T\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/i;
const REGEX_FORMAT = /[YMDHhms]o|\[([^\]]+)\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
function defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {
  let m = hours < 12 ? "AM" : "PM";
  if (hasPeriod)
    m = m.split("").reduce((acc, curr) => acc += `${curr}.`, "");
  return isLowercase ? m.toLowerCase() : m;
}
__name(defaultMeridiem, "defaultMeridiem");
function formatOrdinal(num) {
  const suffixes = ["th", "st", "nd", "rd"];
  const v2 = num % 100;
  return num + (suffixes[(v2 - 20) % 10] || suffixes[v2] || suffixes[0]);
}
__name(formatOrdinal, "formatOrdinal");
function formatDate$1(date, formatStr, options3 = {}) {
  var _a;
  const years = date.getFullYear();
  const month = date.getMonth();
  const days = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();
  const day = date.getDay();
  const meridiem = (_a = options3.customMeridiem) != null ? _a : defaultMeridiem;
  const matches2 = {
    Yo: /* @__PURE__ */ __name(() => formatOrdinal(years), "Yo"),
    YY: /* @__PURE__ */ __name(() => String(years).slice(-2), "YY"),
    YYYY: /* @__PURE__ */ __name(() => years, "YYYY"),
    M: /* @__PURE__ */ __name(() => month + 1, "M"),
    Mo: /* @__PURE__ */ __name(() => formatOrdinal(month + 1), "Mo"),
    MM: /* @__PURE__ */ __name(() => `${month + 1}`.padStart(2, "0"), "MM"),
    MMM: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { month: "short" }), "MMM"),
    MMMM: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { month: "long" }), "MMMM"),
    D: /* @__PURE__ */ __name(() => String(days), "D"),
    Do: /* @__PURE__ */ __name(() => formatOrdinal(days), "Do"),
    DD: /* @__PURE__ */ __name(() => `${days}`.padStart(2, "0"), "DD"),
    H: /* @__PURE__ */ __name(() => String(hours), "H"),
    Ho: /* @__PURE__ */ __name(() => formatOrdinal(hours), "Ho"),
    HH: /* @__PURE__ */ __name(() => `${hours}`.padStart(2, "0"), "HH"),
    h: /* @__PURE__ */ __name(() => `${hours % 12 || 12}`.padStart(1, "0"), "h"),
    ho: /* @__PURE__ */ __name(() => formatOrdinal(hours % 12 || 12), "ho"),
    hh: /* @__PURE__ */ __name(() => `${hours % 12 || 12}`.padStart(2, "0"), "hh"),
    m: /* @__PURE__ */ __name(() => String(minutes), "m"),
    mo: /* @__PURE__ */ __name(() => formatOrdinal(minutes), "mo"),
    mm: /* @__PURE__ */ __name(() => `${minutes}`.padStart(2, "0"), "mm"),
    s: /* @__PURE__ */ __name(() => String(seconds), "s"),
    so: /* @__PURE__ */ __name(() => formatOrdinal(seconds), "so"),
    ss: /* @__PURE__ */ __name(() => `${seconds}`.padStart(2, "0"), "ss"),
    SSS: /* @__PURE__ */ __name(() => `${milliseconds}`.padStart(3, "0"), "SSS"),
    d: /* @__PURE__ */ __name(() => day, "d"),
    dd: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { weekday: "narrow" }), "dd"),
    ddd: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { weekday: "short" }), "ddd"),
    dddd: /* @__PURE__ */ __name(() => date.toLocaleDateString(toValue(options3.locales), { weekday: "long" }), "dddd"),
    A: /* @__PURE__ */ __name(() => meridiem(hours, minutes), "A"),
    AA: /* @__PURE__ */ __name(() => meridiem(hours, minutes, false, true), "AA"),
    a: /* @__PURE__ */ __name(() => meridiem(hours, minutes, true), "a"),
    aa: /* @__PURE__ */ __name(() => meridiem(hours, minutes, true, true), "aa")
  };
  return formatStr.replace(REGEX_FORMAT, (match, $1) => {
    var _a2, _b;
    return (_b = $1 != null ? $1 : (_a2 = matches2[match]) == null ? void 0 : _a2.call(matches2)) != null ? _b : match;
  });
}
__name(formatDate$1, "formatDate$1");
function normalizeDate(date) {
  if (date === null)
    return new Date(Number.NaN);
  if (date === void 0)
    return /* @__PURE__ */ new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    const d = date.match(REGEX_PARSE);
    if (d) {
      const m = d[2] - 1 || 0;
      const ms = (d[7] || "0").substring(0, 3);
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
}
__name(normalizeDate, "normalizeDate");
function useDateFormat(date, formatStr = "HH:mm:ss", options3 = {}) {
  return computed(() => formatDate$1(normalizeDate(toValue(date)), toValue(formatStr), options3));
}
__name(useDateFormat, "useDateFormat");
function useIntervalFn(cb, interval = 1e3, options3 = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options3;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  __name(clean, "clean");
  function pause() {
    isActive.value = false;
    clean();
  }
  __name(pause, "pause");
  function resume() {
    const intervalValue = toValue(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  __name(resume, "resume");
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
__name(useIntervalFn, "useIntervalFn");
function useInterval(interval = 1e3, options3 = {}) {
  const {
    controls: exposeControls = false,
    immediate = true,
    callback
  } = options3;
  const counter = ref(0);
  const update = /* @__PURE__ */ __name(() => counter.value += 1, "update");
  const reset = /* @__PURE__ */ __name(() => {
    counter.value = 0;
  }, "reset");
  const controls = useIntervalFn(
    callback ? () => {
      update();
      callback(counter.value);
    } : update,
    interval,
    { immediate }
  );
  if (exposeControls) {
    return {
      counter,
      reset,
      ...controls
    };
  } else {
    return counter;
  }
}
__name(useInterval, "useInterval");
function useLastChanged(source, options3 = {}) {
  var _a;
  const ms = ref((_a = options3.initialValue) != null ? _a : null);
  watch(
    source,
    () => ms.value = timestamp(),
    options3
  );
  return ms;
}
__name(useLastChanged, "useLastChanged");
function useTimeoutFn(cb, interval, options3 = {}) {
  const {
    immediate = true
  } = options3;
  const isPending = ref(false);
  let timer = null;
  function clear2() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  __name(clear2, "clear");
  function stop2() {
    isPending.value = false;
    clear2();
  }
  __name(stop2, "stop");
  function start2(...args) {
    clear2();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, toValue(interval));
  }
  __name(start2, "start");
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop2);
  return {
    isPending: readonly(isPending),
    start: start2,
    stop: stop2
  };
}
__name(useTimeoutFn, "useTimeoutFn");
function useTimeout(interval = 1e3, options3 = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options3;
  const controls = useTimeoutFn(
    callback != null ? callback : noop$1,
    interval,
    options3
  );
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  } else {
    return ready;
  }
}
__name(useTimeout, "useTimeout");
function useToNumber(value3, options3 = {}) {
  const {
    method = "parseFloat",
    radix,
    nanToZero
  } = options3;
  return computed(() => {
    let resolved = toValue(value3);
    if (typeof resolved === "string")
      resolved = Number[method](resolved, radix);
    if (nanToZero && Number.isNaN(resolved))
      resolved = 0;
    return resolved;
  });
}
__name(useToNumber, "useToNumber");
function useToString(value3) {
  return computed(() => `${toValue(value3)}`);
}
__name(useToString, "useToString");
function useToggle(initialValue = false, options3 = {}) {
  const {
    truthyValue = true,
    falsyValue = false
  } = options3;
  const valueIsRef = isRef(initialValue);
  const _value = ref(initialValue);
  function toggle4(value3) {
    if (arguments.length) {
      _value.value = value3;
      return _value.value;
    } else {
      const truthy = toValue(truthyValue);
      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;
      return _value.value;
    }
  }
  __name(toggle4, "toggle");
  if (valueIsRef)
    return toggle4;
  else
    return [_value, toggle4];
}
__name(useToggle, "useToggle");
function watchArray(source, cb, options3) {
  let oldList = (options3 == null ? void 0 : options3.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];
  return watch(source, (newList, _2, onCleanup) => {
    const oldListRemains = Array.from({ length: oldList.length });
    const added = [];
    for (const obj of newList) {
      let found = false;
      for (let i2 = 0; i2 < oldList.length; i2++) {
        if (!oldListRemains[i2] && obj === oldList[i2]) {
          oldListRemains[i2] = true;
          found = true;
          break;
        }
      }
      if (!found)
        added.push(obj);
    }
    const removed = oldList.filter((_22, i2) => !oldListRemains[i2]);
    cb(newList, oldList, added, removed, onCleanup);
    oldList = [...newList];
  }, options3);
}
__name(watchArray, "watchArray");
function watchAtMost(source, cb, options3) {
  const {
    count,
    ...watchOptions
  } = options3;
  const current = ref(0);
  const stop2 = watchWithFilter(
    source,
    (...args) => {
      current.value += 1;
      if (current.value >= toValue(count))
        nextTick(() => stop2());
      cb(...args);
    },
    watchOptions
  );
  return { count: current, stop: stop2 };
}
__name(watchAtMost, "watchAtMost");
function watchDebounced(source, cb, options3 = {}) {
  const {
    debounce = 0,
    maxWait = void 0,
    ...watchOptions
  } = options3;
  return watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter: debounceFilter(debounce, { maxWait })
    }
  );
}
__name(watchDebounced, "watchDebounced");
function watchDeep(source, cb, options3) {
  return watch(
    source,
    cb,
    {
      ...options3,
      deep: true
    }
  );
}
__name(watchDeep, "watchDeep");
function watchIgnorable(source, cb, options3 = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options3;
  const filteredCb = createFilterWrapper(
    eventFilter,
    cb
  );
  let ignoreUpdates;
  let ignorePrevAsyncUpdates;
  let stop2;
  if (watchOptions.flush === "sync") {
    const ignore = ref(false);
    ignorePrevAsyncUpdates = /* @__PURE__ */ __name(() => {
    }, "ignorePrevAsyncUpdates");
    ignoreUpdates = /* @__PURE__ */ __name((updater) => {
      ignore.value = true;
      updater();
      ignore.value = false;
    }, "ignoreUpdates");
    stop2 = watch(
      source,
      (...args) => {
        if (!ignore.value)
          filteredCb(...args);
      },
      watchOptions
    );
  } else {
    const disposables = [];
    const ignoreCounter = ref(0);
    const syncCounter = ref(0);
    ignorePrevAsyncUpdates = /* @__PURE__ */ __name(() => {
      ignoreCounter.value = syncCounter.value;
    }, "ignorePrevAsyncUpdates");
    disposables.push(
      watch(
        source,
        () => {
          syncCounter.value++;
        },
        { ...watchOptions, flush: "sync" }
      )
    );
    ignoreUpdates = /* @__PURE__ */ __name((updater) => {
      const syncCounterPrev = syncCounter.value;
      updater();
      ignoreCounter.value += syncCounter.value - syncCounterPrev;
    }, "ignoreUpdates");
    disposables.push(
      watch(
        source,
        (...args) => {
          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
          ignoreCounter.value = 0;
          syncCounter.value = 0;
          if (ignore)
            return;
          filteredCb(...args);
        },
        watchOptions
      )
    );
    stop2 = /* @__PURE__ */ __name(() => {
      disposables.forEach((fn) => fn());
    }, "stop");
  }
  return { stop: stop2, ignoreUpdates, ignorePrevAsyncUpdates };
}
__name(watchIgnorable, "watchIgnorable");
function watchImmediate(source, cb, options3) {
  return watch(
    source,
    cb,
    {
      ...options3,
      immediate: true
    }
  );
}
__name(watchImmediate, "watchImmediate");
function watchOnce(source, cb, options3) {
  const stop2 = watch(source, (...args) => {
    nextTick(() => stop2());
    return cb(...args);
  }, options3);
  return stop2;
}
__name(watchOnce, "watchOnce");
function watchThrottled(source, cb, options3 = {}) {
  const {
    throttle: throttle2 = 0,
    trailing = true,
    leading = true,
    ...watchOptions
  } = options3;
  return watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter: throttleFilter(throttle2, trailing, leading)
    }
  );
}
__name(watchThrottled, "watchThrottled");
function watchTriggerable(source, cb, options3 = {}) {
  let cleanupFn;
  function onEffect() {
    if (!cleanupFn)
      return;
    const fn = cleanupFn;
    cleanupFn = void 0;
    fn();
  }
  __name(onEffect, "onEffect");
  function onCleanup(callback) {
    cleanupFn = callback;
  }
  __name(onCleanup, "onCleanup");
  const _cb = /* @__PURE__ */ __name((value3, oldValue) => {
    onEffect();
    return cb(value3, oldValue, onCleanup);
  }, "_cb");
  const res = watchIgnorable(source, _cb, options3);
  const { ignoreUpdates } = res;
  const trigger2 = /* @__PURE__ */ __name(() => {
    let res2;
    ignoreUpdates(() => {
      res2 = _cb(getWatchSources(source), getOldValue(source));
    });
    return res2;
  }, "trigger");
  return {
    ...res,
    trigger: trigger2
  };
}
__name(watchTriggerable, "watchTriggerable");
function getWatchSources(sources) {
  if (isReactive(sources))
    return sources;
  if (Array.isArray(sources))
    return sources.map((item2) => toValue(item2));
  return toValue(sources);
}
__name(getWatchSources, "getWatchSources");
function getOldValue(source) {
  return Array.isArray(source) ? source.map(() => void 0) : void 0;
}
__name(getOldValue, "getOldValue");
function whenever(source, cb, options3) {
  const stop2 = watch(
    source,
    (v2, ov, onInvalidate) => {
      if (v2) {
        if (options3 == null ? void 0 : options3.once)
          nextTick(() => stop2());
        cb(v2, ov, onInvalidate);
      }
    },
    {
      ...options3,
      once: false
    }
  );
  return stop2;
}
__name(whenever, "whenever");
var isVue2 = false;
var isVue3 = true;
var Vue2 = void 0;
function install() {
}
__name(install, "install");
function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
__name(set, "set");
function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
__name(del, "del");
function computedAsync(evaluationCallback, initialState, optionsOrRef) {
  let options3;
  if (isRef(optionsOrRef)) {
    options3 = {
      evaluating: optionsOrRef
    };
  } else {
    options3 = optionsOrRef || {};
  }
  const {
    lazy = false,
    evaluating = void 0,
    shallow = true,
    onError = noop$1
  } = options3;
  const started = ref(!lazy);
  const current = shallow ? shallowRef(initialState) : ref(initialState);
  let counter = 0;
  watchEffect(async (onInvalidate) => {
    if (!started.value)
      return;
    counter++;
    const counterAtBeginning = counter;
    let hasFinished = false;
    if (evaluating) {
      Promise.resolve().then(() => {
        evaluating.value = true;
      });
    }
    try {
      const result = await evaluationCallback((cancelCallback) => {
        onInvalidate(() => {
          if (evaluating)
            evaluating.value = false;
          if (!hasFinished)
            cancelCallback();
        });
      });
      if (counterAtBeginning === counter)
        current.value = result;
    } catch (e) {
      onError(e);
    } finally {
      if (evaluating && counterAtBeginning === counter)
        evaluating.value = false;
      hasFinished = true;
    }
  });
  if (lazy) {
    return computed(() => {
      started.value = true;
      return current.value;
    });
  } else {
    return current;
  }
}
__name(computedAsync, "computedAsync");
function computedInject(key, options3, defaultSource, treatDefaultAsFactory) {
  let source = inject(key);
  if (defaultSource)
    source = inject(key, defaultSource);
  if (treatDefaultAsFactory)
    source = inject(key, defaultSource, treatDefaultAsFactory);
  if (typeof options3 === "function") {
    return computed((ctx) => options3(source, ctx));
  } else {
    return computed({
      get: /* @__PURE__ */ __name((ctx) => options3.get(source, ctx), "get"),
      set: options3.set
    });
  }
}
__name(computedInject, "computedInject");
function createReusableTemplate(options3 = {}) {
  if (!isVue3 && !version.startsWith("2.7.")) {
    if (false)
      throw new Error("[VueUse] createReusableTemplate only works in Vue 2.7 or above.");
    return;
  }
  const {
    inheritAttrs = true
  } = options3;
  const render2 = shallowRef();
  const define = /* @__PURE__ */ defineComponent({
    setup(_2, { slots }) {
      return () => {
        render2.value = slots.default;
      };
    }
  });
  const reuse = /* @__PURE__ */ defineComponent({
    inheritAttrs,
    setup(_2, { attrs: attrs3, slots }) {
      return () => {
        var _a;
        if (!render2.value && false)
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const vnode = (_a = render2.value) == null ? void 0 : _a.call(render2, { ...keysToCamelKebabCase(attrs3), $slots: slots });
        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;
      };
    }
  });
  return makeDestructurable(
    { define, reuse },
    [define, reuse]
  );
}
__name(createReusableTemplate, "createReusableTemplate");
function keysToCamelKebabCase(obj) {
  const newObj = {};
  for (const key in obj)
    newObj[camelize(key)] = obj[key];
  return newObj;
}
__name(keysToCamelKebabCase, "keysToCamelKebabCase");
function createTemplatePromise(options3 = {}) {
  if (!isVue3) {
    if (false)
      throw new Error("[VueUse] createTemplatePromise only works in Vue 3 or above.");
    return;
  }
  let index2 = 0;
  const instances = ref([]);
  function create3(...args) {
    const props = shallowReactive({
      key: index2++,
      args,
      promise: void 0,
      resolve: /* @__PURE__ */ __name(() => {
      }, "resolve"),
      reject: /* @__PURE__ */ __name(() => {
      }, "reject"),
      isResolving: false,
      options: options3
    });
    instances.value.push(props);
    props.promise = new Promise((_resolve, _reject) => {
      props.resolve = (v2) => {
        props.isResolving = true;
        return _resolve(v2);
      };
      props.reject = _reject;
    }).finally(() => {
      props.promise = void 0;
      const index22 = instances.value.indexOf(props);
      if (index22 !== -1)
        instances.value.splice(index22, 1);
    });
    return props.promise;
  }
  __name(create3, "create");
  function start2(...args) {
    if (options3.singleton && instances.value.length > 0)
      return instances.value[0].promise;
    return create3(...args);
  }
  __name(start2, "start");
  const component = /* @__PURE__ */ defineComponent((_2, { slots }) => {
    const renderList2 = /* @__PURE__ */ __name(() => instances.value.map((props) => {
      var _a;
      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));
    }), "renderList");
    if (options3.transition)
      return () => h(TransitionGroup, options3.transition, renderList2);
    return renderList2;
  });
  component.start = start2;
  return component;
}
__name(createTemplatePromise, "createTemplatePromise");
function createUnrefFn(fn) {
  return function(...args) {
    return fn.apply(this, args.map((i2) => toValue(i2)));
  };
}
__name(createUnrefFn, "createUnrefFn");
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
__name(unrefElement, "unrefElement");
const defaultWindow = isClient ? window : void 0;
const defaultDocument = isClient ? window.document : void 0;
const defaultNavigator = isClient ? window.navigator : void 0;
const defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events2;
  let listeners;
  let options3;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events2, listeners, options3] = args;
    target = defaultWindow;
  } else {
    [target, events2, listeners, options3] = args;
  }
  if (!target)
    return noop$1;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = /* @__PURE__ */ __name(() => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  }, "cleanup");
  const register3 = /* @__PURE__ */ __name((el, event2, listener, options22) => {
    el.addEventListener(event2, listener, options22);
    return () => el.removeEventListener(event2, listener, options22);
  }, "register");
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options3)],
    ([el, options22]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$1(options22) ? { ...options22 } : options22;
      cleanups.push(
        ...events2.flatMap((event2) => {
          return listeners.map((listener) => register3(el, event2, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop2 = /* @__PURE__ */ __name(() => {
    stopWatch();
    cleanup();
  }, "stop");
  tryOnScopeDispose(stop2);
  return stop2;
}
__name(useEventListener, "useEventListener");
let _iOSWorkaround = false;
function onClickOutside(target, handler6, options3 = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options3;
  if (!window2)
    return noop$1;
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
    window2.document.documentElement.addEventListener("click", noop$1);
  }
  let shouldListen = true;
  const shouldIgnore = /* @__PURE__ */ __name((event2) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event2.target || event2.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event2.target === el || event2.composedPath().includes(el));
      }
    });
  }, "shouldIgnore");
  const listener = /* @__PURE__ */ __name((event2) => {
    const el = unrefElement(target);
    if (!el || el === event2.target || event2.composedPath().includes(el))
      return;
    if (event2.detail === 0)
      shouldListen = !shouldIgnore(event2);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler6(event2);
  }, "listener");
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event2) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
          handler6(event2);
        }
      }, 0);
    })
  ].filter(Boolean);
  const stop2 = /* @__PURE__ */ __name(() => cleanup.forEach((fn) => fn()), "stop");
  return stop2;
}
__name(onClickOutside, "onClickOutside");
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event2) => event2.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event2) => keyFilter.includes(event2.key);
  return () => true;
}
__name(createKeyPredicate, "createKeyPredicate");
function onKeyStroke(...args) {
  let key;
  let handler6;
  let options3 = {};
  if (args.length === 3) {
    key = args[0];
    handler6 = args[1];
    options3 = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler6 = args[0];
      options3 = args[1];
    } else {
      key = args[0];
      handler6 = args[1];
    }
  } else {
    key = true;
    handler6 = args[0];
  }
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options3;
  const predicate = createKeyPredicate(key);
  const listener = /* @__PURE__ */ __name((e) => {
    if (e.repeat && toValue(dedupe))
      return;
    if (predicate(e))
      handler6(e);
  }, "listener");
  return useEventListener(target, eventName, listener, passive);
}
__name(onKeyStroke, "onKeyStroke");
function onKeyDown(key, handler6, options3 = {}) {
  return onKeyStroke(key, handler6, { ...options3, eventName: "keydown" });
}
__name(onKeyDown, "onKeyDown");
function onKeyPressed(key, handler6, options3 = {}) {
  return onKeyStroke(key, handler6, { ...options3, eventName: "keypress" });
}
__name(onKeyPressed, "onKeyPressed");
function onKeyUp(key, handler6, options3 = {}) {
  return onKeyStroke(key, handler6, { ...options3, eventName: "keyup" });
}
__name(onKeyUp, "onKeyUp");
const DEFAULT_DELAY = 500;
const DEFAULT_THRESHOLD = 10;
function onLongPress(target, handler6, options3) {
  var _a, _b;
  const elementRef2 = computed(() => unrefElement(target));
  let timeout;
  let posStart;
  let startTimestamp;
  let hasLongPressed = false;
  function clear2() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    posStart = void 0;
    startTimestamp = void 0;
    hasLongPressed = false;
  }
  __name(clear2, "clear");
  function onRelease(ev) {
    var _a2, _b2, _c;
    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];
    clear2();
    if (!(options3 == null ? void 0 : options3.onMouseUp) || !_posStart || !_startTimestamp)
      return;
    if (((_a2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef2.value)
      return;
    if ((_b2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    const dx = ev.x - _posStart.x;
    const dy = ev.y - _posStart.y;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    options3.onMouseUp(ev.timeStamp - _startTimestamp, distance2, _hasLongPressed);
  }
  __name(onRelease, "onRelease");
  function onDown(ev) {
    var _a2, _b2, _c, _d;
    if (((_a2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef2.value)
      return;
    clear2();
    if ((_b2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    posStart = {
      x: ev.x,
      y: ev.y
    };
    startTimestamp = ev.timeStamp;
    timeout = setTimeout(
      () => {
        hasLongPressed = true;
        handler6(ev);
      },
      (_d = options3 == null ? void 0 : options3.delay) != null ? _d : DEFAULT_DELAY
    );
  }
  __name(onDown, "onDown");
  function onMove(ev) {
    var _a2, _b2, _c, _d;
    if (((_a2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef2.value)
      return;
    if (!posStart || (options3 == null ? void 0 : options3.distanceThreshold) === false)
      return;
    if ((_b2 = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _b2.prevent)
      ev.preventDefault();
    if ((_c = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _c.stop)
      ev.stopPropagation();
    const dx = ev.x - posStart.x;
    const dy = ev.y - posStart.y;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    if (distance2 >= ((_d = options3 == null ? void 0 : options3.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))
      clear2();
  }
  __name(onMove, "onMove");
  const listenerOptions = {
    capture: (_a = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _a.capture,
    once: (_b = options3 == null ? void 0 : options3.modifiers) == null ? void 0 : _b.once
  };
  const cleanup = [
    useEventListener(elementRef2, "pointerdown", onDown, listenerOptions),
    useEventListener(elementRef2, "pointermove", onMove, listenerOptions),
    useEventListener(elementRef2, ["pointerup", "pointerleave"], onRelease, listenerOptions)
  ];
  const stop2 = /* @__PURE__ */ __name(() => cleanup.forEach((fn) => fn()), "stop");
  return stop2;
}
__name(onLongPress, "onLongPress");
function isFocusedElementEditable() {
  const { activeElement, body } = document;
  if (!activeElement)
    return false;
  if (activeElement === body)
    return false;
  switch (activeElement.tagName) {
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return activeElement.hasAttribute("contenteditable");
}
__name(isFocusedElementEditable, "isFocusedElementEditable");
function isTypedCharValid({
  keyCode,
  metaKey,
  ctrlKey,
  altKey
}) {
  if (metaKey || ctrlKey || altKey)
    return false;
  if (keyCode >= 48 && keyCode <= 57)
    return true;
  if (keyCode >= 65 && keyCode <= 90)
    return true;
  if (keyCode >= 97 && keyCode <= 122)
    return true;
  return false;
}
__name(isTypedCharValid, "isTypedCharValid");
function onStartTyping(callback, options3 = {}) {
  const { document: document2 = defaultDocument } = options3;
  const keydown = /* @__PURE__ */ __name((event2) => {
    if (!isFocusedElementEditable() && isTypedCharValid(event2)) {
      callback(event2);
    }
  }, "keydown");
  if (document2)
    useEventListener(document2, "keydown", keydown, { passive: true });
}
__name(onStartTyping, "onStartTyping");
function templateRef(key, initialValue = null) {
  const instance = getCurrentInstance();
  let _trigger = /* @__PURE__ */ __name(() => {
  }, "_trigger");
  const element = customRef((track2, trigger2) => {
    _trigger = trigger2;
    return {
      get() {
        var _a, _b;
        track2();
        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;
      },
      set() {
      }
    };
  });
  tryOnMounted(_trigger);
  onUpdated(_trigger);
  return element;
}
__name(templateRef, "templateRef");
function useMounted() {
  const isMounted = ref(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, isVue2 ? void 0 : instance);
  }
  return isMounted;
}
__name(useMounted, "useMounted");
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
__name(useSupported, "useSupported");
function useMutationObserver(target, callback, options3 = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options3;
  let observer;
  const isSupported2 = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = /* @__PURE__ */ __name(() => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  }, "cleanup");
  const targets = computed(() => {
    const value3 = toValue(target);
    const items2 = (Array.isArray(value3) ? value3 : [value3]).map(unrefElement).filter(notNullish);
    return new Set(items2);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported2.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = /* @__PURE__ */ __name(() => {
    return observer == null ? void 0 : observer.takeRecords();
  }, "takeRecords");
  const stop2 = /* @__PURE__ */ __name(() => {
    stopWatch();
    cleanup();
  }, "stop");
  tryOnScopeDispose(stop2);
  return {
    isSupported: isSupported2,
    stop: stop2,
    takeRecords
  };
}
__name(useMutationObserver, "useMutationObserver");
function useActiveElement(options3 = {}) {
  var _a;
  const {
    window: window2 = defaultWindow,
    deep = true,
    triggerOnRemoval = false
  } = options3;
  const document2 = (_a = options3.document) != null ? _a : window2 == null ? void 0 : window2.document;
  const getDeepActiveElement = /* @__PURE__ */ __name(() => {
    var _a2;
    let element = document2 == null ? void 0 : document2.activeElement;
    if (deep) {
      while (element == null ? void 0 : element.shadowRoot)
        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
    }
    return element;
  }, "getDeepActiveElement");
  const activeElement = ref();
  const trigger2 = /* @__PURE__ */ __name(() => {
    activeElement.value = getDeepActiveElement();
  }, "trigger");
  if (window2) {
    useEventListener(window2, "blur", (event2) => {
      if (event2.relatedTarget !== null)
        return;
      trigger2();
    }, true);
    useEventListener(window2, "focus", trigger2, true);
  }
  if (triggerOnRemoval) {
    useMutationObserver(document2, (mutations) => {
      mutations.filter((m) => m.removedNodes.length).map((n) => Array.from(n.removedNodes)).flat().forEach((node3) => {
        if (node3 === activeElement.value)
          trigger2();
      });
    }, {
      childList: true,
      subtree: true
    });
  }
  trigger2();
  return activeElement;
}
__name(useActiveElement, "useActiveElement");
function useRafFn(fn, options3 = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow
  } = options3;
  const isActive = ref(false);
  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta2 = timestamp2 - previousFrameTimestamp;
    if (intervalLimit && delta2 < intervalLimit) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta: delta2, timestamp: timestamp2 });
    rafId = window2.requestAnimationFrame(loop);
  }
  __name(loop, "loop");
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  __name(resume, "resume");
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  __name(pause, "pause");
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
__name(useRafFn, "useRafFn");
function useAnimate(target, keyframes, options3) {
  let config2;
  let animateOptions;
  if (isObject$1(options3)) {
    config2 = options3;
    animateOptions = objectOmit(options3, ["window", "immediate", "commitStyles", "persist", "onReady", "onError"]);
  } else {
    config2 = { duration: options3 };
    animateOptions = options3;
  }
  const {
    window: window2 = defaultWindow,
    immediate = true,
    commitStyles,
    persist,
    playbackRate: _playbackRate = 1,
    onReady,
    onError = /* @__PURE__ */ __name((e) => {
      console.error(e);
    }, "onError")
  } = config2;
  const isSupported2 = useSupported(() => window2 && HTMLElement && "animate" in HTMLElement.prototype);
  const animate = shallowRef(void 0);
  const store = shallowReactive({
    startTime: null,
    currentTime: null,
    timeline: null,
    playbackRate: _playbackRate,
    pending: false,
    playState: immediate ? "idle" : "paused",
    replaceState: "active"
  });
  const pending = computed(() => store.pending);
  const playState = computed(() => store.playState);
  const replaceState = computed(() => store.replaceState);
  const startTime = computed({
    get() {
      return store.startTime;
    },
    set(value3) {
      store.startTime = value3;
      if (animate.value)
        animate.value.startTime = value3;
    }
  });
  const currentTime = computed({
    get() {
      return store.currentTime;
    },
    set(value3) {
      store.currentTime = value3;
      if (animate.value) {
        animate.value.currentTime = value3;
        syncResume();
      }
    }
  });
  const timeline = computed({
    get() {
      return store.timeline;
    },
    set(value3) {
      store.timeline = value3;
      if (animate.value)
        animate.value.timeline = value3;
    }
  });
  const playbackRate = computed({
    get() {
      return store.playbackRate;
    },
    set(value3) {
      store.playbackRate = value3;
      if (animate.value)
        animate.value.playbackRate = value3;
    }
  });
  const play = /* @__PURE__ */ __name(() => {
    if (animate.value) {
      try {
        animate.value.play();
        syncResume();
      } catch (e) {
        syncPause();
        onError(e);
      }
    } else {
      update();
    }
  }, "play");
  const pause = /* @__PURE__ */ __name(() => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.pause();
      syncPause();
    } catch (e) {
      onError(e);
    }
  }, "pause");
  const reverse2 = /* @__PURE__ */ __name(() => {
    var _a;
    if (!animate.value)
      update();
    try {
      (_a = animate.value) == null ? void 0 : _a.reverse();
      syncResume();
    } catch (e) {
      syncPause();
      onError(e);
    }
  }, "reverse");
  const finish = /* @__PURE__ */ __name(() => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.finish();
      syncPause();
    } catch (e) {
      onError(e);
    }
  }, "finish");
  const cancel = /* @__PURE__ */ __name(() => {
    var _a;
    try {
      (_a = animate.value) == null ? void 0 : _a.cancel();
      syncPause();
    } catch (e) {
      onError(e);
    }
  }, "cancel");
  watch(() => unrefElement(target), (el) => {
    if (el)
      update();
  });
  watch(() => keyframes, (value3) => {
    if (animate.value)
      update();
    if (!unrefElement(target) && animate.value) {
      animate.value.effect = new KeyframeEffect(
        unrefElement(target),
        toValue(value3),
        animateOptions
      );
    }
  }, { deep: true });
  tryOnMounted(() => update(true), false);
  tryOnScopeDispose(cancel);
  function update(init2) {
    const el = unrefElement(target);
    if (!isSupported2.value || !el)
      return;
    if (!animate.value)
      animate.value = el.animate(toValue(keyframes), animateOptions);
    if (persist)
      animate.value.persist();
    if (_playbackRate !== 1)
      animate.value.playbackRate = _playbackRate;
    if (init2 && !immediate)
      animate.value.pause();
    else
      syncResume();
    onReady == null ? void 0 : onReady(animate.value);
  }
  __name(update, "update");
  useEventListener(animate, ["cancel", "finish", "remove"], syncPause);
  useEventListener(animate, "finish", () => {
    var _a;
    if (commitStyles)
      (_a = animate.value) == null ? void 0 : _a.commitStyles();
  });
  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {
    if (!animate.value)
      return;
    store.pending = animate.value.pending;
    store.playState = animate.value.playState;
    store.replaceState = animate.value.replaceState;
    store.startTime = animate.value.startTime;
    store.currentTime = animate.value.currentTime;
    store.timeline = animate.value.timeline;
    store.playbackRate = animate.value.playbackRate;
  }, { immediate: false });
  function syncResume() {
    if (isSupported2.value)
      resumeRef();
  }
  __name(syncResume, "syncResume");
  function syncPause() {
    if (isSupported2.value && window2)
      window2.requestAnimationFrame(pauseRef);
  }
  __name(syncPause, "syncPause");
  return {
    isSupported: isSupported2,
    animate,
    // actions
    play,
    pause,
    reverse: reverse2,
    finish,
    cancel,
    // state
    pending,
    playState,
    replaceState,
    startTime,
    currentTime,
    timeline,
    playbackRate
  };
}
__name(useAnimate, "useAnimate");
function useAsyncQueue(tasks, options3) {
  const {
    interrupt = true,
    onError = noop$1,
    onFinished = noop$1,
    signal
  } = options3 || {};
  const promiseState = {
    aborted: "aborted",
    fulfilled: "fulfilled",
    pending: "pending",
    rejected: "rejected"
  };
  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));
  const result = reactive(initialResult);
  const activeIndex3 = ref(-1);
  if (!tasks || tasks.length === 0) {
    onFinished();
    return {
      activeIndex: activeIndex3,
      result
    };
  }
  function updateResult(state, res) {
    activeIndex3.value++;
    result[activeIndex3.value].data = res;
    result[activeIndex3.value].state = state;
  }
  __name(updateResult, "updateResult");
  tasks.reduce((prev2, curr) => {
    return prev2.then((prevRes) => {
      var _a;
      if (signal == null ? void 0 : signal.aborted) {
        updateResult(promiseState.aborted, new Error("aborted"));
        return;
      }
      if (((_a = result[activeIndex3.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {
        onFinished();
        return;
      }
      const done = curr(prevRes).then((currentRes) => {
        updateResult(promiseState.fulfilled, currentRes);
        if (activeIndex3.value === tasks.length - 1)
          onFinished();
        return currentRes;
      });
      if (!signal)
        return done;
      return Promise.race([done, whenAborted(signal)]);
    }).catch((e) => {
      if (signal == null ? void 0 : signal.aborted) {
        updateResult(promiseState.aborted, e);
        return e;
      }
      updateResult(promiseState.rejected, e);
      onError();
      return e;
    });
  }, Promise.resolve());
  return {
    activeIndex: activeIndex3,
    result
  };
}
__name(useAsyncQueue, "useAsyncQueue");
function whenAborted(signal) {
  return new Promise((resolve2, reject2) => {
    const error = new Error("aborted");
    if (signal.aborted)
      reject2(error);
    else
      signal.addEventListener("abort", () => reject2(error), { once: true });
  });
}
__name(whenAborted, "whenAborted");
function useAsyncState(promise, initialState, options3) {
  const {
    immediate = true,
    delay = 0,
    onError = noop$1,
    onSuccess = noop$1,
    resetOnExecute = true,
    shallow = true,
    throwError
  } = options3 != null ? options3 : {};
  const state = shallow ? shallowRef(initialState) : ref(initialState);
  const isReady = ref(false);
  const isLoading = ref(false);
  const error = shallowRef(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      state.value = initialState;
    error.value = void 0;
    isReady.value = false;
    isLoading.value = true;
    if (delay2 > 0)
      await promiseTimeout(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data22 = await _promise;
      state.value = data22;
      isReady.value = true;
      onSuccess(data22);
    } catch (e) {
      error.value = e;
      onError(e);
      if (throwError)
        throw e;
    } finally {
      isLoading.value = false;
    }
    return state.value;
  }
  __name(execute, "execute");
  if (immediate)
    execute(delay);
  const shell = {
    state,
    isReady,
    isLoading,
    error,
    execute
  };
  function waitUntilIsLoaded() {
    return new Promise((resolve2, reject2) => {
      until(isLoading).toBe(false).then(() => resolve2(shell)).catch(reject2);
    });
  }
  __name(waitUntilIsLoaded, "waitUntilIsLoaded");
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilIsLoaded().then(onFulfilled, onRejected);
    }
  };
}
__name(useAsyncState, "useAsyncState");
const defaults = {
  array: /* @__PURE__ */ __name((v2) => JSON.stringify(v2), "array"),
  object: /* @__PURE__ */ __name((v2) => JSON.stringify(v2), "object"),
  set: /* @__PURE__ */ __name((v2) => JSON.stringify(Array.from(v2)), "set"),
  map: /* @__PURE__ */ __name((v2) => JSON.stringify(Object.fromEntries(v2)), "map"),
  null: /* @__PURE__ */ __name(() => "", "null")
};
function getDefaultSerialization(target) {
  if (!target)
    return defaults.null;
  if (target instanceof Map)
    return defaults.map;
  else if (target instanceof Set)
    return defaults.set;
  else if (Array.isArray(target))
    return defaults.array;
  else
    return defaults.object;
}
__name(getDefaultSerialization, "getDefaultSerialization");
function useBase64(target, options3) {
  const base64 = ref("");
  const promise = ref();
  function execute() {
    if (!isClient)
      return;
    promise.value = new Promise((resolve2, reject2) => {
      try {
        const _target = toValue(target);
        if (_target == null) {
          resolve2("");
        } else if (typeof _target === "string") {
          resolve2(blobToBase64(new Blob([_target], { type: "text/plain" })));
        } else if (_target instanceof Blob) {
          resolve2(blobToBase64(_target));
        } else if (_target instanceof ArrayBuffer) {
          resolve2(window.btoa(String.fromCharCode(...new Uint8Array(_target))));
        } else if (_target instanceof HTMLCanvasElement) {
          resolve2(_target.toDataURL(options3 == null ? void 0 : options3.type, options3 == null ? void 0 : options3.quality));
        } else if (_target instanceof HTMLImageElement) {
          const img = _target.cloneNode(false);
          img.crossOrigin = "Anonymous";
          imgLoaded(img).then(() => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve2(canvas.toDataURL(options3 == null ? void 0 : options3.type, options3 == null ? void 0 : options3.quality));
          }).catch(reject2);
        } else if (typeof _target === "object") {
          const _serializeFn = (options3 == null ? void 0 : options3.serializer) || getDefaultSerialization(_target);
          const serialized = _serializeFn(_target);
          return resolve2(blobToBase64(new Blob([serialized], { type: "application/json" })));
        } else {
          reject2(new Error("target is unsupported types"));
        }
      } catch (error) {
        reject2(error);
      }
    });
    promise.value.then((res) => base64.value = res);
    return promise.value;
  }
  __name(execute, "execute");
  if (isRef(target) || typeof target === "function")
    watch(target, execute, { immediate: true });
  else
    execute();
  return {
    base64,
    promise,
    execute
  };
}
__name(useBase64, "useBase64");
function imgLoaded(img) {
  return new Promise((resolve2, reject2) => {
    if (!img.complete) {
      img.onload = () => {
        resolve2();
      };
      img.onerror = reject2;
    } else {
      resolve2();
    }
  });
}
__name(imgLoaded, "imgLoaded");
function blobToBase64(blob) {
  return new Promise((resolve2, reject2) => {
    const fr = new FileReader();
    fr.onload = (e) => {
      resolve2(e.target.result);
    };
    fr.onerror = reject2;
    fr.readAsDataURL(blob);
  });
}
__name(blobToBase64, "blobToBase64");
function useBattery(options3 = {}) {
  const { navigator: navigator2 = defaultNavigator } = options3;
  const events2 = ["chargingchange", "chargingtimechange", "dischargingtimechange", "levelchange"];
  const isSupported2 = useSupported(() => navigator2 && "getBattery" in navigator2 && typeof navigator2.getBattery === "function");
  const charging = ref(false);
  const chargingTime = ref(0);
  const dischargingTime = ref(0);
  const level = ref(1);
  let battery;
  function updateBatteryInfo() {
    charging.value = this.charging;
    chargingTime.value = this.chargingTime || 0;
    dischargingTime.value = this.dischargingTime || 0;
    level.value = this.level;
  }
  __name(updateBatteryInfo, "updateBatteryInfo");
  if (isSupported2.value) {
    navigator2.getBattery().then((_battery) => {
      battery = _battery;
      updateBatteryInfo.call(battery);
      useEventListener(battery, events2, updateBatteryInfo, { passive: true });
    });
  }
  return {
    isSupported: isSupported2,
    charging,
    chargingTime,
    dischargingTime,
    level
  };
}
__name(useBattery, "useBattery");
function useBluetooth(options3) {
  let {
    acceptAllDevices = false
  } = options3 || {};
  const {
    filters = void 0,
    optionalServices = void 0,
    navigator: navigator2 = defaultNavigator
  } = options3 || {};
  const isSupported2 = useSupported(() => navigator2 && "bluetooth" in navigator2);
  const device = shallowRef(void 0);
  const error = shallowRef(null);
  watch(device, () => {
    connectToBluetoothGATTServer();
  });
  async function requestDevice() {
    if (!isSupported2.value)
      return;
    error.value = null;
    if (filters && filters.length > 0)
      acceptAllDevices = false;
    try {
      device.value = await (navigator2 == null ? void 0 : navigator2.bluetooth.requestDevice({
        acceptAllDevices,
        filters,
        optionalServices
      }));
    } catch (err) {
      error.value = err;
    }
  }
  __name(requestDevice, "requestDevice");
  const server = ref();
  const isConnected = computed(() => {
    var _a;
    return ((_a = server.value) == null ? void 0 : _a.connected) || false;
  });
  async function connectToBluetoothGATTServer() {
    error.value = null;
    if (device.value && device.value.gatt) {
      device.value.addEventListener("gattserverdisconnected", () => {
      });
      try {
        server.value = await device.value.gatt.connect();
      } catch (err) {
        error.value = err;
      }
    }
  }
  __name(connectToBluetoothGATTServer, "connectToBluetoothGATTServer");
  tryOnMounted(() => {
    var _a;
    if (device.value)
      (_a = device.value.gatt) == null ? void 0 : _a.connect();
  });
  tryOnScopeDispose(() => {
    var _a;
    if (device.value)
      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();
  });
  return {
    isSupported: isSupported2,
    isConnected,
    // Device:
    device,
    requestDevice,
    // Server:
    server,
    // Errors:
    error
  };
}
__name(useBluetooth, "useBluetooth");
function useMediaQuery(query, options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const isSupported2 = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches2 = ref(false);
  const handler6 = /* @__PURE__ */ __name((event2) => {
    matches2.value = event2.matches;
  }, "handler");
  const cleanup = /* @__PURE__ */ __name(() => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler6);
    else
      mediaQuery.removeListener(handler6);
  }, "cleanup");
  const stopWatch = watchEffect(() => {
    if (!isSupported2.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue(query));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler6);
    else
      mediaQuery.addListener(handler6);
    matches2.value = mediaQuery.matches;
  });
  tryOnScopeDispose(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches2;
}
__name(useMediaQuery, "useMediaQuery");
const breakpointsTailwind = {
  "sm": 640,
  "md": 768,
  "lg": 1024,
  "xl": 1280,
  "2xl": 1536
};
const breakpointsBootstrapV5 = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
const breakpointsVuetifyV2 = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1264,
  xl: 1904
};
const breakpointsVuetifyV3 = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1280,
  xl: 1920,
  xxl: 2560
};
const breakpointsVuetify = breakpointsVuetifyV2;
const breakpointsAntDesign = {
  xs: 480,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1600
};
const breakpointsQuasar = {
  xs: 0,
  sm: 600,
  md: 1024,
  lg: 1440,
  xl: 1920
};
const breakpointsSematic = {
  mobileS: 320,
  mobileM: 375,
  mobileL: 425,
  tablet: 768,
  laptop: 1024,
  laptopL: 1440,
  desktop4K: 2560
};
const breakpointsMasterCss = {
  "3xs": 360,
  "2xs": 480,
  "xs": 600,
  "sm": 768,
  "md": 1024,
  "lg": 1280,
  "xl": 1440,
  "2xl": 1600,
  "3xl": 1920,
  "4xl": 2560
};
const breakpointsPrimeFlex = {
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
function useBreakpoints(breakpoints, options3 = {}) {
  function getValue2(k, delta2) {
    let v2 = toValue(breakpoints[toValue(k)]);
    if (delta2 != null)
      v2 = increaseWithUnit(v2, delta2);
    if (typeof v2 === "number")
      v2 = `${v2}px`;
    return v2;
  }
  __name(getValue2, "getValue2");
  const { window: window2 = defaultWindow, strategy = "min-width" } = options3;
  function match(query) {
    if (!window2)
      return false;
    return window2.matchMedia(query).matches;
  }
  __name(match, "match");
  const greaterOrEqual = /* @__PURE__ */ __name((k) => {
    return useMediaQuery(() => `(min-width: ${getValue2(k)})`, options3);
  }, "greaterOrEqual");
  const smallerOrEqual = /* @__PURE__ */ __name((k) => {
    return useMediaQuery(() => `(max-width: ${getValue2(k)})`, options3);
  }, "smallerOrEqual");
  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      get: /* @__PURE__ */ __name(() => strategy === "min-width" ? greaterOrEqual(k) : smallerOrEqual(k), "get"),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  function current() {
    const points = Object.keys(breakpoints).map((i2) => [i2, greaterOrEqual(i2)]);
    return computed(() => points.filter(([, v2]) => v2.value).map(([k]) => k));
  }
  __name(current, "current");
  return Object.assign(shortcutMethods, {
    greaterOrEqual,
    smallerOrEqual,
    greater(k) {
      return useMediaQuery(() => `(min-width: ${getValue2(k, 0.1)})`, options3);
    },
    smaller(k) {
      return useMediaQuery(() => `(max-width: ${getValue2(k, -0.1)})`, options3);
    },
    between(a, b) {
      return useMediaQuery(() => `(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`, options3);
    },
    isGreater(k) {
      return match(`(min-width: ${getValue2(k, 0.1)})`);
    },
    isGreaterOrEqual(k) {
      return match(`(min-width: ${getValue2(k)})`);
    },
    isSmaller(k) {
      return match(`(max-width: ${getValue2(k, -0.1)})`);
    },
    isSmallerOrEqual(k) {
      return match(`(max-width: ${getValue2(k)})`);
    },
    isInBetween(a, b) {
      return match(`(min-width: ${getValue2(a)}) and (max-width: ${getValue2(b, -0.1)})`);
    },
    current,
    active() {
      const bps = current();
      return computed(() => bps.value.length === 0 ? "" : bps.value.at(-1));
    }
  });
}
__name(useBreakpoints, "useBreakpoints");
function useBroadcastChannel(options3) {
  const {
    name,
    window: window2 = defaultWindow
  } = options3;
  const isSupported2 = useSupported(() => window2 && "BroadcastChannel" in window2);
  const isClosed = ref(false);
  const channel = ref();
  const data22 = ref();
  const error = shallowRef(null);
  const post = /* @__PURE__ */ __name((data23) => {
    if (channel.value)
      channel.value.postMessage(data23);
  }, "post");
  const close4 = /* @__PURE__ */ __name(() => {
    if (channel.value)
      channel.value.close();
    isClosed.value = true;
  }, "close");
  if (isSupported2.value) {
    tryOnMounted(() => {
      error.value = null;
      channel.value = new BroadcastChannel(name);
      channel.value.addEventListener("message", (e) => {
        data22.value = e.data;
      }, { passive: true });
      channel.value.addEventListener("messageerror", (e) => {
        error.value = e;
      }, { passive: true });
      channel.value.addEventListener("close", () => {
        isClosed.value = true;
      });
    });
  }
  tryOnScopeDispose(() => {
    close4();
  });
  return {
    isSupported: isSupported2,
    channel,
    data: data22,
    post,
    close: close4,
    error,
    isClosed
  };
}
__name(useBroadcastChannel, "useBroadcastChannel");
const WRITABLE_PROPERTIES = [
  "hash",
  "host",
  "hostname",
  "href",
  "pathname",
  "port",
  "protocol",
  "search"
];
function useBrowserLocation(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const refs = Object.fromEntries(
    WRITABLE_PROPERTIES.map((key) => [key, ref()])
  );
  for (const [key, ref2] of objectEntries(refs)) {
    watch(ref2, (value3) => {
      if (!(window2 == null ? void 0 : window2.location) || window2.location[key] === value3)
        return;
      window2.location[key] = value3;
    });
  }
  const buildState2 = /* @__PURE__ */ __name((trigger2) => {
    var _a;
    const { state: state2, length } = (window2 == null ? void 0 : window2.history) || {};
    const { origin: origin2 } = (window2 == null ? void 0 : window2.location) || {};
    for (const key of WRITABLE_PROPERTIES)
      refs[key].value = (_a = window2 == null ? void 0 : window2.location) == null ? void 0 : _a[key];
    return reactive({
      trigger: trigger2,
      state: state2,
      length,
      origin: origin2,
      ...refs
    });
  }, "buildState");
  const state = ref(buildState2("load"));
  if (window2) {
    useEventListener(window2, "popstate", () => state.value = buildState2("popstate"), { passive: true });
    useEventListener(window2, "hashchange", () => state.value = buildState2("hashchange"), { passive: true });
  }
  return state;
}
__name(useBrowserLocation, "useBrowserLocation");
function useCached(refValue, comparator2 = (a, b) => a === b, watchOptions) {
  const cachedValue = ref(refValue.value);
  watch(() => refValue.value, (value3) => {
    if (!comparator2(value3, cachedValue.value))
      cachedValue.value = value3;
  }, watchOptions);
  return cachedValue;
}
__name(useCached, "useCached");
function usePermission(permissionDesc, options3 = {}) {
  const {
    controls = false,
    navigator: navigator2 = defaultNavigator
  } = options3;
  const isSupported2 = useSupported(() => navigator2 && "permissions" in navigator2);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const state = ref();
  const onChange4 = /* @__PURE__ */ __name(() => {
    if (permissionStatus)
      state.value = permissionStatus.state;
  }, "onChange");
  const query = createSingletonPromise(async () => {
    if (!isSupported2.value)
      return;
    if (!permissionStatus) {
      try {
        permissionStatus = await navigator2.permissions.query(desc);
        useEventListener(permissionStatus, "change", onChange4);
        onChange4();
      } catch (e) {
        state.value = "prompt";
      }
    }
    return permissionStatus;
  });
  query();
  if (controls) {
    return {
      state,
      isSupported: isSupported2,
      query
    };
  } else {
    return state;
  }
}
__name(usePermission, "usePermission");
function useClipboard(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500,
    legacy = false
  } = options3;
  const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
  const permissionRead = usePermission("clipboard-read");
  const permissionWrite = usePermission("clipboard-write");
  const isSupported2 = computed(() => isClipboardApiSupported.value || legacy);
  const text = ref("");
  const copied = ref(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
  function updateText() {
    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {
      navigator2.clipboard.readText().then((value3) => {
        text.value = value3;
      });
    } else {
      text.value = legacyRead();
    }
  }
  __name(updateText, "updateText");
  if (isSupported2.value && read)
    useEventListener(["copy", "cut"], updateText);
  async function copy(value3 = toValue(source)) {
    if (isSupported2.value && value3 != null) {
      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))
        await navigator2.clipboard.writeText(value3);
      else
        legacyCopy(value3);
      text.value = value3;
      copied.value = true;
      timeout.start();
    }
  }
  __name(copy, "copy");
  function legacyCopy(value3) {
    const ta = document.createElement("textarea");
    ta.value = value3 != null ? value3 : "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  __name(legacyCopy, "legacyCopy");
  function legacyRead() {
    var _a, _b, _c;
    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
  }
  __name(legacyRead, "legacyRead");
  function isAllowed(status) {
    return status === "granted" || status === "prompt";
  }
  __name(isAllowed, "isAllowed");
  return {
    isSupported: isSupported2,
    text,
    copied,
    copy
  };
}
__name(useClipboard, "useClipboard");
function useClipboardItems(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500
  } = options3;
  const isSupported2 = useSupported(() => navigator2 && "clipboard" in navigator2);
  const content2 = ref([]);
  const copied = ref(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
  function updateContent() {
    if (isSupported2.value) {
      navigator2.clipboard.read().then((items2) => {
        content2.value = items2;
      });
    }
  }
  __name(updateContent, "updateContent");
  if (isSupported2.value && read)
    useEventListener(["copy", "cut"], updateContent);
  async function copy(value3 = toValue(source)) {
    if (isSupported2.value && value3 != null) {
      await navigator2.clipboard.write(value3);
      content2.value = value3;
      copied.value = true;
      timeout.start();
    }
  }
  __name(copy, "copy");
  return {
    isSupported: isSupported2,
    content: content2,
    copied,
    copy
  };
}
__name(useClipboardItems, "useClipboardItems");
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
__name(cloneFnJSON, "cloneFnJSON");
function useCloned(source, options3 = {}) {
  const cloned = ref({});
  const {
    manual,
    clone: clone2 = cloneFnJSON,
    // watch options
    deep = true,
    immediate = true
  } = options3;
  function sync() {
    cloned.value = clone2(toValue(source));
  }
  __name(sync, "sync");
  if (!manual && (isRef(source) || typeof source === "function")) {
    watch(source, sync, {
      ...options3,
      deep,
      immediate
    });
  } else {
    sync();
  }
  return { cloned, sync };
}
__name(useCloned, "useCloned");
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
__name(getHandlers, "getHandlers");
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
__name(getSSRHandler, "getSSRHandler");
function setSSRHandler(key, fn) {
  handlers[key] = fn;
}
__name(setSSRHandler, "setSSRHandler");
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
__name(guessSerializerType, "guessSerializerType");
const StorageSerializers = {
  boolean: {
    read: /* @__PURE__ */ __name((v2) => v2 === "true", "read"),
    write: /* @__PURE__ */ __name((v2) => String(v2), "write")
  },
  object: {
    read: /* @__PURE__ */ __name((v2) => JSON.parse(v2), "read"),
    write: /* @__PURE__ */ __name((v2) => JSON.stringify(v2), "write")
  },
  number: {
    read: /* @__PURE__ */ __name((v2) => Number.parseFloat(v2), "read"),
    write: /* @__PURE__ */ __name((v2) => String(v2), "write")
  },
  any: {
    read: /* @__PURE__ */ __name((v2) => v2, "read"),
    write: /* @__PURE__ */ __name((v2) => String(v2), "write")
  },
  string: {
    read: /* @__PURE__ */ __name((v2) => v2, "read"),
    write: /* @__PURE__ */ __name((v2) => String(v2), "write")
  },
  map: {
    read: /* @__PURE__ */ __name((v2) => new Map(JSON.parse(v2)), "read"),
    write: /* @__PURE__ */ __name((v2) => JSON.stringify(Array.from(v2.entries())), "write")
  },
  set: {
    read: /* @__PURE__ */ __name((v2) => new Set(JSON.parse(v2)), "read"),
    write: /* @__PURE__ */ __name((v2) => JSON.stringify(Array.from(v2)), "write")
  },
  date: {
    read: /* @__PURE__ */ __name((v2) => new Date(v2), "read"),
    write: /* @__PURE__ */ __name((v2) => v2.toISOString(), "write")
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options3 = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults: mergeDefaults2 = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = /* @__PURE__ */ __name((e) => {
      console.error(e);
    }, "onError"),
    initOnMounted
  } = options3;
  const data22 = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data22;
  const rawInit = toValue(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = (_a = options3.serializer) != null ? _a : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data22,
    () => write(data22.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    tryOnMounted(() => {
      if (storage instanceof Storage)
        useEventListener(window2, "storage", update);
      else
        useEventListener(window2, customStorageEventName, updateFromCustomEvent);
      if (initOnMounted)
        update();
    });
  }
  if (!initOnMounted)
    update();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2 && !(storage instanceof Storage)) {
      window2.dispatchEvent(new CustomEvent(customStorageEventName, {
        detail: {
          key,
          oldValue,
          newValue,
          storageArea: storage
        }
      }));
    }
  }
  __name(dispatchWriteEvent, "dispatchWriteEvent");
  function write(v2) {
    try {
      const oldValue = storage.getItem(key);
      if (v2 == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v2);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  __name(write, "write");
  function read(event2) {
    const rawValue = event2 ? event2.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event2 && mergeDefaults2) {
      const value3 = serializer.read(rawValue);
      if (typeof mergeDefaults2 === "function")
        return mergeDefaults2(value3, rawInit);
      else if (type === "object" && !Array.isArray(value3))
        return { ...rawInit, ...value3 };
      return value3;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  __name(read, "read");
  function update(event2) {
    if (event2 && event2.storageArea !== storage)
      return;
    if (event2 && event2.key == null) {
      data22.value = rawInit;
      return;
    }
    if (event2 && event2.key !== key)
      return;
    pauseWatch();
    try {
      if ((event2 == null ? void 0 : event2.newValue) !== serializer.write(data22.value))
        data22.value = read(event2);
    } catch (e) {
      onError(e);
    } finally {
      if (event2)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
  __name(update, "update");
  function updateFromCustomEvent(event2) {
    update(event2.detail);
  }
  __name(updateFromCustomEvent, "updateFromCustomEvent");
  return data22;
}
__name(useStorage, "useStorage");
function usePreferredDark(options3) {
  return useMediaQuery("(prefers-color-scheme: dark)", options3);
}
__name(usePreferredDark, "usePreferredDark");
const CSS_DISABLE_TRANS = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function useColorMode(options3 = {}) {
  const {
    selector = "html",
    attribute = "class",
    initialValue = "auto",
    window: window2 = defaultWindow,
    storage,
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef,
    emitAuto,
    disableTransition = true
  } = options3;
  const modes = {
    auto: "",
    light: "light",
    dark: "dark",
    ...options3.modes || {}
  };
  const preferredDark = usePreferredDark({ window: window2 });
  const system = computed(() => preferredDark.value ? "dark" : "light");
  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
  const state = computed(() => store.value === "auto" ? system.value : store.value);
  const updateHTMLAttrs = getSSRHandler(
    "updateHTMLAttrs",
    (selector2, attribute2, value3) => {
      const el = typeof selector2 === "string" ? window2 == null ? void 0 : window2.document.querySelector(selector2) : unrefElement(selector2);
      if (!el)
        return;
      const classesToAdd = /* @__PURE__ */ new Set();
      const classesToRemove = /* @__PURE__ */ new Set();
      let attributeToChange = null;
      if (attribute2 === "class") {
        const current = value3.split(/\s/g);
        Object.values(modes).flatMap((i2) => (i2 || "").split(/\s/g)).filter(Boolean).forEach((v2) => {
          if (current.includes(v2))
            classesToAdd.add(v2);
          else
            classesToRemove.add(v2);
        });
      } else {
        attributeToChange = { key: attribute2, value: value3 };
      }
      if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)
        return;
      let style;
      if (disableTransition) {
        style = window2.document.createElement("style");
        style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));
        window2.document.head.appendChild(style);
      }
      for (const c of classesToAdd) {
        el.classList.add(c);
      }
      for (const c of classesToRemove) {
        el.classList.remove(c);
      }
      if (attributeToChange) {
        el.setAttribute(attributeToChange.key, attributeToChange.value);
      }
      if (disableTransition) {
        window2.getComputedStyle(style).opacity;
        document.head.removeChild(style);
      }
    }
  );
  function defaultOnChanged(mode2) {
    var _a;
    updateHTMLAttrs(selector, attribute, (_a = modes[mode2]) != null ? _a : mode2);
  }
  __name(defaultOnChanged, "defaultOnChanged");
  function onChanged(mode2) {
    if (options3.onChanged)
      options3.onChanged(mode2, defaultOnChanged);
    else
      defaultOnChanged(mode2);
  }
  __name(onChanged, "onChanged");
  watch(state, onChanged, { flush: "post", immediate: true });
  tryOnMounted(() => onChanged(state.value));
  const auto = computed({
    get() {
      return emitAuto ? store.value : state.value;
    },
    set(v2) {
      store.value = v2;
    }
  });
  try {
    return Object.assign(auto, { store, system, state });
  } catch (e) {
    return auto;
  }
}
__name(useColorMode, "useColorMode");
function useConfirmDialog(revealed = ref(false)) {
  const confirmHook = createEventHook();
  const cancelHook = createEventHook();
  const revealHook = createEventHook();
  let _resolve = noop$1;
  const reveal = /* @__PURE__ */ __name((data22) => {
    revealHook.trigger(data22);
    revealed.value = true;
    return new Promise((resolve2) => {
      _resolve = resolve2;
    });
  }, "reveal");
  const confirm2 = /* @__PURE__ */ __name((data22) => {
    revealed.value = false;
    confirmHook.trigger(data22);
    _resolve({ data: data22, isCanceled: false });
  }, "confirm");
  const cancel = /* @__PURE__ */ __name((data22) => {
    revealed.value = false;
    cancelHook.trigger(data22);
    _resolve({ data: data22, isCanceled: true });
  }, "cancel");
  return {
    isRevealed: computed(() => revealed.value),
    reveal,
    confirm: confirm2,
    cancel,
    onReveal: revealHook.on,
    onConfirm: confirmHook.on,
    onCancel: cancelHook.on
  };
}
__name(useConfirmDialog, "useConfirmDialog");
function useCssVar(prop2, target, options3 = {}) {
  const { window: window2 = defaultWindow, initialValue, observe = false } = options3;
  const variable = ref(initialValue);
  const elRef = computed(() => {
    var _a;
    return unrefElement(target) || ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
  });
  function updateCssVar() {
    var _a;
    const key = toValue(prop2);
    const el = toValue(elRef);
    if (el && window2 && key) {
      const value3 = (_a = window2.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();
      variable.value = value3 || initialValue;
    }
  }
  __name(updateCssVar, "updateCssVar");
  if (observe) {
    useMutationObserver(elRef, updateCssVar, {
      attributeFilter: ["style", "class"],
      window: window2
    });
  }
  watch(
    [elRef, () => toValue(prop2)],
    (_2, old) => {
      if (old[0] && old[1] && window2)
        window2.getComputedStyle(old[0]).removeProperty(old[1]);
      updateCssVar();
    },
    { immediate: true }
  );
  watch(
    variable,
    (val) => {
      var _a;
      const raw_prop = toValue(prop2);
      if (((_a = elRef.value) == null ? void 0 : _a.style) && raw_prop) {
        if (val == null)
          elRef.value.style.removeProperty(raw_prop);
        else
          elRef.value.style.setProperty(raw_prop, val);
      }
    }
  );
  return variable;
}
__name(useCssVar, "useCssVar");
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance();
  const currentElement = computedWithControl(
    () => null,
    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el
  );
  onUpdated(currentElement.trigger);
  onMounted(currentElement.trigger);
  return currentElement;
}
__name(useCurrentElement, "useCurrentElement");
function useCycleList(list, options3) {
  const state = shallowRef(getInitialValue());
  const listRef4 = toRef(list);
  const index2 = computed({
    get() {
      var _a;
      const targetList = listRef4.value;
      let index22 = (options3 == null ? void 0 : options3.getIndexOf) ? options3.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);
      if (index22 < 0)
        index22 = (_a = options3 == null ? void 0 : options3.fallbackIndex) != null ? _a : 0;
      return index22;
    },
    set(v2) {
      set2(v2);
    }
  });
  function set2(i2) {
    const targetList = listRef4.value;
    const length = targetList.length;
    const index22 = (i2 % length + length) % length;
    const value3 = targetList[index22];
    state.value = value3;
    return value3;
  }
  __name(set2, "set2");
  function shift(delta2 = 1) {
    return set2(index2.value + delta2);
  }
  __name(shift, "shift");
  function next2(n = 1) {
    return shift(n);
  }
  __name(next2, "next");
  function prev2(n = 1) {
    return shift(-n);
  }
  __name(prev2, "prev");
  function getInitialValue() {
    var _a, _b;
    return (_b = toValue((_a = options3 == null ? void 0 : options3.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;
  }
  __name(getInitialValue, "getInitialValue");
  watch(listRef4, () => set2(index2.value));
  return {
    state,
    index: index2,
    next: next2,
    prev: prev2,
    go: set2
  };
}
__name(useCycleList, "useCycleList");
function useDark(options3 = {}) {
  const {
    valueDark = "dark",
    valueLight = "",
    window: window2 = defaultWindow
  } = options3;
  const mode2 = useColorMode({
    ...options3,
    onChanged: /* @__PURE__ */ __name((mode22, defaultHandler) => {
      var _a;
      if (options3.onChanged)
        (_a = options3.onChanged) == null ? void 0 : _a.call(options3, mode22 === "dark", defaultHandler, mode22);
      else
        defaultHandler(mode22);
    }, "onChanged"),
    modes: {
      dark: valueDark,
      light: valueLight
    }
  });
  const system = computed(() => {
    if (mode2.system) {
      return mode2.system.value;
    } else {
      const preferredDark = usePreferredDark({ window: window2 });
      return preferredDark.value ? "dark" : "light";
    }
  });
  const isDark = computed({
    get() {
      return mode2.value === "dark";
    },
    set(v2) {
      const modeVal = v2 ? "dark" : "light";
      if (system.value === modeVal)
        mode2.value = "auto";
      else
        mode2.value = modeVal;
    }
  });
  return isDark;
}
__name(useDark, "useDark");
function fnBypass(v2) {
  return v2;
}
__name(fnBypass, "fnBypass");
function fnSetSource(source, value3) {
  return source.value = value3;
}
__name(fnSetSource, "fnSetSource");
function defaultDump(clone2) {
  return clone2 ? typeof clone2 === "function" ? clone2 : cloneFnJSON : fnBypass;
}
__name(defaultDump, "defaultDump");
function defaultParse(clone2) {
  return clone2 ? typeof clone2 === "function" ? clone2 : cloneFnJSON : fnBypass;
}
__name(defaultParse, "defaultParse");
function useManualRefHistory(source, options3 = {}) {
  const {
    clone: clone2 = false,
    dump = defaultDump(clone2),
    parse: parse2 = defaultParse(clone2),
    setSource = fnSetSource
  } = options3;
  function _createHistoryRecord() {
    return markRaw({
      snapshot: dump(source.value),
      timestamp: timestamp()
    });
  }
  __name(_createHistoryRecord, "_createHistoryRecord");
  const last = ref(_createHistoryRecord());
  const undoStack = ref([]);
  const redoStack = ref([]);
  const _setSource = /* @__PURE__ */ __name((record) => {
    setSource(source, parse2(record.snapshot));
    last.value = record;
  }, "_setSource");
  const commit = /* @__PURE__ */ __name(() => {
    undoStack.value.unshift(last.value);
    last.value = _createHistoryRecord();
    if (options3.capacity && undoStack.value.length > options3.capacity)
      undoStack.value.splice(options3.capacity, Number.POSITIVE_INFINITY);
    if (redoStack.value.length)
      redoStack.value.splice(0, redoStack.value.length);
  }, "commit");
  const clear2 = /* @__PURE__ */ __name(() => {
    undoStack.value.splice(0, undoStack.value.length);
    redoStack.value.splice(0, redoStack.value.length);
  }, "clear");
  const undo = /* @__PURE__ */ __name(() => {
    const state = undoStack.value.shift();
    if (state) {
      redoStack.value.unshift(last.value);
      _setSource(state);
    }
  }, "undo");
  const redo = /* @__PURE__ */ __name(() => {
    const state = redoStack.value.shift();
    if (state) {
      undoStack.value.unshift(last.value);
      _setSource(state);
    }
  }, "redo");
  const reset = /* @__PURE__ */ __name(() => {
    _setSource(last.value);
  }, "reset");
  const history2 = computed(() => [last.value, ...undoStack.value]);
  const canUndo = computed(() => undoStack.value.length > 0);
  const canRedo = computed(() => redoStack.value.length > 0);
  return {
    source,
    undoStack,
    redoStack,
    last,
    history: history2,
    canUndo,
    canRedo,
    clear: clear2,
    commit,
    reset,
    undo,
    redo
  };
}
__name(useManualRefHistory, "useManualRefHistory");
function useRefHistory(source, options3 = {}) {
  const {
    deep = false,
    flush = "pre",
    eventFilter
  } = options3;
  const {
    eventFilter: composedFilter,
    pause,
    resume: resumeTracking,
    isActive: isTracking
  } = pausableFilter(eventFilter);
  const {
    ignoreUpdates,
    ignorePrevAsyncUpdates,
    stop: stop2
  } = watchIgnorable(
    source,
    commit,
    { deep, flush, eventFilter: composedFilter }
  );
  function setSource(source2, value3) {
    ignorePrevAsyncUpdates();
    ignoreUpdates(() => {
      source2.value = value3;
    });
  }
  __name(setSource, "setSource");
  const manualHistory = useManualRefHistory(source, { ...options3, clone: options3.clone || deep, setSource });
  const { clear: clear2, commit: manualCommit } = manualHistory;
  function commit() {
    ignorePrevAsyncUpdates();
    manualCommit();
  }
  __name(commit, "commit");
  function resume(commitNow) {
    resumeTracking();
    if (commitNow)
      commit();
  }
  __name(resume, "resume");
  function batch(fn) {
    let canceled = false;
    const cancel = /* @__PURE__ */ __name(() => canceled = true, "cancel");
    ignoreUpdates(() => {
      fn(cancel);
    });
    if (!canceled)
      commit();
  }
  __name(batch, "batch");
  function dispose() {
    stop2();
    clear2();
  }
  __name(dispose, "dispose");
  return {
    ...manualHistory,
    isTracking,
    pause,
    resume,
    commit,
    batch,
    dispose
  };
}
__name(useRefHistory, "useRefHistory");
function useDebouncedRefHistory(source, options3 = {}) {
  const filter4 = options3.debounce ? debounceFilter(options3.debounce) : void 0;
  const history2 = useRefHistory(source, { ...options3, eventFilter: filter4 });
  return {
    ...history2
  };
}
__name(useDebouncedRefHistory, "useDebouncedRefHistory");
function useDeviceMotion(options3 = {}) {
  const {
    window: window2 = defaultWindow,
    eventFilter = bypassFilter
  } = options3;
  const acceleration = ref({ x: null, y: null, z: null });
  const rotationRate = ref({ alpha: null, beta: null, gamma: null });
  const interval = ref(0);
  const accelerationIncludingGravity = ref({
    x: null,
    y: null,
    z: null
  });
  if (window2) {
    const onDeviceMotion = createFilterWrapper(
      eventFilter,
      (event2) => {
        acceleration.value = event2.acceleration;
        accelerationIncludingGravity.value = event2.accelerationIncludingGravity;
        rotationRate.value = event2.rotationRate;
        interval.value = event2.interval;
      }
    );
    useEventListener(window2, "devicemotion", onDeviceMotion);
  }
  return {
    acceleration,
    accelerationIncludingGravity,
    rotationRate,
    interval
  };
}
__name(useDeviceMotion, "useDeviceMotion");
function useDeviceOrientation(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const isSupported2 = useSupported(() => window2 && "DeviceOrientationEvent" in window2);
  const isAbsolute = ref(false);
  const alpha = ref(null);
  const beta = ref(null);
  const gamma = ref(null);
  if (window2 && isSupported2.value) {
    useEventListener(window2, "deviceorientation", (event2) => {
      isAbsolute.value = event2.absolute;
      alpha.value = event2.alpha;
      beta.value = event2.beta;
      gamma.value = event2.gamma;
    });
  }
  return {
    isSupported: isSupported2,
    isAbsolute,
    alpha,
    beta,
    gamma
  };
}
__name(useDeviceOrientation, "useDeviceOrientation");
function useDevicePixelRatio(options3 = {}) {
  const {
    window: window2 = defaultWindow
  } = options3;
  const pixelRatio = ref(1);
  if (window2) {
    let observe2 = /* @__PURE__ */ __name(function() {
      pixelRatio.value = window2.devicePixelRatio;
      cleanup2();
      media = window2.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
      media.addEventListener("change", observe2, { once: true });
    }, "observe2"), cleanup2 = /* @__PURE__ */ __name(function() {
      media == null ? void 0 : media.removeEventListener("change", observe2);
    }, "cleanup2");
    let media;
    observe2();
    tryOnScopeDispose(cleanup2);
  }
  return { pixelRatio };
}
__name(useDevicePixelRatio, "useDevicePixelRatio");
function useDevicesList(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    requestPermissions = false,
    constraints = { audio: true, video: true },
    onUpdated: onUpdated2
  } = options3;
  const devices = ref([]);
  const videoInputs = computed(() => devices.value.filter((i2) => i2.kind === "videoinput"));
  const audioInputs = computed(() => devices.value.filter((i2) => i2.kind === "audioinput"));
  const audioOutputs = computed(() => devices.value.filter((i2) => i2.kind === "audiooutput"));
  const isSupported2 = useSupported(() => navigator2 && navigator2.mediaDevices && navigator2.mediaDevices.enumerateDevices);
  const permissionGranted = ref(false);
  let stream;
  async function update() {
    if (!isSupported2.value)
      return;
    devices.value = await navigator2.mediaDevices.enumerateDevices();
    onUpdated2 == null ? void 0 : onUpdated2(devices.value);
    if (stream) {
      stream.getTracks().forEach((t) => t.stop());
      stream = null;
    }
  }
  __name(update, "update");
  async function ensurePermissions() {
    if (!isSupported2.value)
      return false;
    if (permissionGranted.value)
      return true;
    const { state, query } = usePermission("camera", { controls: true });
    await query();
    if (state.value !== "granted") {
      stream = await navigator2.mediaDevices.getUserMedia(constraints);
      update();
      permissionGranted.value = true;
    } else {
      permissionGranted.value = true;
    }
    return permissionGranted.value;
  }
  __name(ensurePermissions, "ensurePermissions");
  if (isSupported2.value) {
    if (requestPermissions)
      ensurePermissions();
    useEventListener(navigator2.mediaDevices, "devicechange", update);
    update();
  }
  return {
    devices,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported: isSupported2
  };
}
__name(useDevicesList, "useDevicesList");
function useDisplayMedia(options3 = {}) {
  var _a;
  const enabled = ref((_a = options3.enabled) != null ? _a : false);
  const video = options3.video;
  const audio = options3.audio;
  const { navigator: navigator2 = defaultNavigator } = options3;
  const isSupported2 = useSupported(() => {
    var _a2;
    return (_a2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;
  });
  const constraint = { audio, video };
  const stream = shallowRef();
  async function _start() {
    var _a2;
    if (!isSupported2.value || stream.value)
      return;
    stream.value = await navigator2.mediaDevices.getDisplayMedia(constraint);
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.addEventListener("ended", stop2));
    return stream.value;
  }
  __name(_start, "_start");
  async function _stop() {
    var _a2;
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());
    stream.value = void 0;
  }
  __name(_stop, "_stop");
  function stop2() {
    _stop();
    enabled.value = false;
  }
  __name(stop2, "stop");
  async function start2() {
    await _start();
    if (stream.value)
      enabled.value = true;
    return stream.value;
  }
  __name(start2, "start");
  watch(
    enabled,
    (v2) => {
      if (v2)
        _start();
      else
        _stop();
    },
    { immediate: true }
  );
  return {
    isSupported: isSupported2,
    stream,
    start: start2,
    stop: stop2,
    enabled
  };
}
__name(useDisplayMedia, "useDisplayMedia");
function useDocumentVisibility(options3 = {}) {
  const { document: document2 = defaultDocument } = options3;
  if (!document2)
    return ref("visible");
  const visibility = ref(document2.visibilityState);
  useEventListener(document2, "visibilitychange", () => {
    visibility.value = document2.visibilityState;
  });
  return visibility;
}
__name(useDocumentVisibility, "useDocumentVisibility");
function useDraggable(target, options3 = {}) {
  var _a, _b;
  const {
    pointerTypes,
    preventDefault: preventDefault2,
    stopPropagation,
    exact,
    onMove,
    onEnd,
    onStart,
    initialValue,
    axis = "both",
    draggingElement = defaultWindow,
    containerElement,
    handle: draggingHandle = target,
    buttons = [0]
  } = options3;
  const position2 = ref(
    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }
  );
  const pressedDelta = ref();
  const filterEvent = /* @__PURE__ */ __name((e) => {
    if (pointerTypes)
      return pointerTypes.includes(e.pointerType);
    return true;
  }, "filterEvent");
  const handleEvent = /* @__PURE__ */ __name((e) => {
    if (toValue(preventDefault2))
      e.preventDefault();
    if (toValue(stopPropagation))
      e.stopPropagation();
  }, "handleEvent");
  const start2 = /* @__PURE__ */ __name((e) => {
    var _a2;
    if (!toValue(buttons).includes(e.button))
      return;
    if (toValue(options3.disabled) || !filterEvent(e))
      return;
    if (toValue(exact) && e.target !== toValue(target))
      return;
    const container = toValue(containerElement);
    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);
    const targetRect = toValue(target).getBoundingClientRect();
    const pos2 = {
      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),
      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)
    };
    if ((onStart == null ? void 0 : onStart(pos2, e)) === false)
      return;
    pressedDelta.value = pos2;
    handleEvent(e);
  }, "start");
  const move = /* @__PURE__ */ __name((e) => {
    if (toValue(options3.disabled) || !filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    const container = toValue(containerElement);
    const targetRect = toValue(target).getBoundingClientRect();
    let { x: x2, y: y2 } = position2.value;
    if (axis === "x" || axis === "both") {
      x2 = e.clientX - pressedDelta.value.x;
      if (container)
        x2 = Math.min(Math.max(0, x2), container.scrollWidth - targetRect.width);
    }
    if (axis === "y" || axis === "both") {
      y2 = e.clientY - pressedDelta.value.y;
      if (container)
        y2 = Math.min(Math.max(0, y2), container.scrollHeight - targetRect.height);
    }
    position2.value = {
      x: x2,
      y: y2
    };
    onMove == null ? void 0 : onMove(position2.value, e);
    handleEvent(e);
  }, "move");
  const end = /* @__PURE__ */ __name((e) => {
    if (toValue(options3.disabled) || !filterEvent(e))
      return;
    if (!pressedDelta.value)
      return;
    pressedDelta.value = void 0;
    onEnd == null ? void 0 : onEnd(position2.value, e);
    handleEvent(e);
  }, "end");
  if (isClient) {
    const config2 = { capture: (_b = options3.capture) != null ? _b : true };
    useEventListener(draggingHandle, "pointerdown", start2, config2);
    useEventListener(draggingElement, "pointermove", move, config2);
    useEventListener(draggingElement, "pointerup", end, config2);
  }
  return {
    ...toRefs(position2),
    position: position2,
    isDragging: computed(() => !!pressedDelta.value),
    style: computed(
      () => `left:${position2.value.x}px;top:${position2.value.y}px;`
    )
  };
}
__name(useDraggable, "useDraggable");
function useDropZone(target, options3 = {}) {
  const isOverDropZone = ref(false);
  const files = shallowRef(null);
  let counter = 0;
  let isDataTypeIncluded = true;
  if (isClient) {
    const _options = typeof options3 === "function" ? { onDrop: options3 } : options3;
    const getFiles = /* @__PURE__ */ __name((event2) => {
      var _a, _b;
      const list = Array.from((_b = (_a = event2.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);
      return files.value = list.length === 0 ? null : list;
    }, "getFiles");
    useEventListener(target, "dragenter", (event2) => {
      var _a, _b;
      const types = Array.from(((_a = event2 == null ? void 0 : event2.dataTransfer) == null ? void 0 : _a.items) || []).map((i2) => i2.kind === "file" ? i2.type : null).filter(notNullish);
      if (_options.dataTypes && event2.dataTransfer) {
        const dataTypes = unref(_options.dataTypes);
        isDataTypeIncluded = typeof dataTypes === "function" ? dataTypes(types) : dataTypes ? dataTypes.some((item2) => types.includes(item2)) : true;
        if (!isDataTypeIncluded)
          return;
      }
      event2.preventDefault();
      counter += 1;
      isOverDropZone.value = true;
      (_b = _options.onEnter) == null ? void 0 : _b.call(_options, getFiles(event2), event2);
    });
    useEventListener(target, "dragover", (event2) => {
      var _a;
      if (!isDataTypeIncluded)
        return;
      event2.preventDefault();
      (_a = _options.onOver) == null ? void 0 : _a.call(_options, getFiles(event2), event2);
    });
    useEventListener(target, "dragleave", (event2) => {
      var _a;
      if (!isDataTypeIncluded)
        return;
      event2.preventDefault();
      counter -= 1;
      if (counter === 0)
        isOverDropZone.value = false;
      (_a = _options.onLeave) == null ? void 0 : _a.call(_options, getFiles(event2), event2);
    });
    useEventListener(target, "drop", (event2) => {
      var _a;
      event2.preventDefault();
      counter = 0;
      isOverDropZone.value = false;
      (_a = _options.onDrop) == null ? void 0 : _a.call(_options, getFiles(event2), event2);
    });
  }
  return {
    files,
    isOverDropZone
  };
}
__name(useDropZone, "useDropZone");
function useResizeObserver(target, callback, options3 = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options3;
  let observer;
  const isSupported2 = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = /* @__PURE__ */ __name(() => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  }, "cleanup");
  const targets = computed(() => {
    const _targets = toValue(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch(
    targets,
    (els2) => {
      cleanup();
      if (isSupported2.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els2) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop2 = /* @__PURE__ */ __name(() => {
    cleanup();
    stopWatch();
  }, "stop");
  tryOnScopeDispose(stop2);
  return {
    isSupported: isSupported2,
    stop: stop2
  };
}
__name(useResizeObserver, "useResizeObserver");
function useElementBounding(target, options3 = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true,
    updateTiming = "sync"
  } = options3;
  const height = ref(0);
  const bottom = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top = ref(0);
  const width2 = ref(0);
  const x2 = ref(0);
  const y2 = ref(0);
  function recalculate() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width2.value = 0;
        x2.value = 0;
        y2.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width2.value = rect.width;
    x2.value = rect.x;
    y2.value = rect.y;
  }
  __name(recalculate, "recalculate");
  function update() {
    if (updateTiming === "sync")
      recalculate();
    else if (updateTiming === "next-frame")
      requestAnimationFrame(() => recalculate());
  }
  __name(update, "update");
  useResizeObserver(target, update);
  watch(() => unrefElement(target), (ele) => !ele && update());
  useMutationObserver(target, update, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width: width2,
    x: x2,
    y: y2,
    update
  };
}
__name(useElementBounding, "useElementBounding");
function useElementByPoint(options3) {
  const {
    x: x2,
    y: y2,
    document: document2 = defaultDocument,
    multiple,
    interval = "requestAnimationFrame",
    immediate = true
  } = options3;
  const isSupported2 = useSupported(() => {
    if (toValue(multiple))
      return document2 && "elementsFromPoint" in document2;
    return document2 && "elementFromPoint" in document2;
  });
  const element = ref(null);
  const cb = /* @__PURE__ */ __name(() => {
    var _a, _b;
    element.value = toValue(multiple) ? (_a = document2 == null ? void 0 : document2.elementsFromPoint(toValue(x2), toValue(y2))) != null ? _a : [] : (_b = document2 == null ? void 0 : document2.elementFromPoint(toValue(x2), toValue(y2))) != null ? _b : null;
  }, "cb");
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  return {
    isSupported: isSupported2,
    element,
    ...controls
  };
}
__name(useElementByPoint, "useElementByPoint");
function useElementHover(el, options3 = {}) {
  const {
    delayEnter = 0,
    delayLeave = 0,
    window: window2 = defaultWindow
  } = options3;
  const isHovered = ref(false);
  let timer;
  const toggle4 = /* @__PURE__ */ __name((entering) => {
    const delay = entering ? delayEnter : delayLeave;
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
    if (delay)
      timer = setTimeout(() => isHovered.value = entering, delay);
    else
      isHovered.value = entering;
  }, "toggle");
  if (!window2)
    return isHovered;
  useEventListener(el, "mouseenter", () => toggle4(true), { passive: true });
  useEventListener(el, "mouseleave", () => toggle4(false), { passive: true });
  return isHovered;
}
__name(useElementHover, "useElementHover");
function useElementSize(target, initialSize = { width: 0, height: 0 }, options3 = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options3;
  const isSVG = computed(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width2 = ref(initialSize.width);
  const height = ref(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width2.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width2.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width2.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options3
  );
  tryOnMounted(() => {
    const ele = unrefElement(target);
    if (ele) {
      width2.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch(
    () => unrefElement(target),
    (ele) => {
      width2.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop3() {
    stop1();
    stop2();
  }
  __name(stop3, "stop");
  return {
    width: width2,
    height,
    stop: stop3
  };
}
__name(useElementSize, "useElementSize");
function useIntersectionObserver(target, callback, options3 = {}) {
  const {
    root: root23,
    rootMargin = "0px",
    threshold = 0,
    window: window2 = defaultWindow,
    immediate = true
  } = options3;
  const isSupported2 = useSupported(() => window2 && "IntersectionObserver" in window2);
  const targets = computed(() => {
    const _target = toValue(target);
    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);
  });
  let cleanup = noop$1;
  const isActive = ref(immediate);
  const stopWatch = isSupported2.value ? watch(
    () => [targets.value, unrefElement(root23), isActive.value],
    ([targets2, root24]) => {
      cleanup();
      if (!isActive.value)
        return;
      if (!targets2.length)
        return;
      const observer = new IntersectionObserver(
        callback,
        {
          root: unrefElement(root24),
          rootMargin,
          threshold
        }
      );
      targets2.forEach((el) => el && observer.observe(el));
      cleanup = /* @__PURE__ */ __name(() => {
        observer.disconnect();
        cleanup = noop$1;
      }, "cleanup");
    },
    { immediate, flush: "post" }
  ) : noop$1;
  const stop2 = /* @__PURE__ */ __name(() => {
    cleanup();
    stopWatch();
    isActive.value = false;
  }, "stop");
  tryOnScopeDispose(stop2);
  return {
    isSupported: isSupported2,
    isActive,
    pause() {
      cleanup();
      isActive.value = false;
    },
    resume() {
      isActive.value = true;
    },
    stop: stop2
  };
}
__name(useIntersectionObserver, "useIntersectionObserver");
function useElementVisibility(element, options3 = {}) {
  const { window: window2 = defaultWindow, scrollTarget, threshold = 0 } = options3;
  const elementIsVisible = ref(false);
  useIntersectionObserver(
    element,
    (intersectionObserverEntries) => {
      let isIntersecting = elementIsVisible.value;
      let latestTime = 0;
      for (const entry of intersectionObserverEntries) {
        if (entry.time >= latestTime) {
          latestTime = entry.time;
          isIntersecting = entry.isIntersecting;
        }
      }
      elementIsVisible.value = isIntersecting;
    },
    {
      root: scrollTarget,
      window: window2,
      threshold
    }
  );
  return elementIsVisible;
}
__name(useElementVisibility, "useElementVisibility");
const events = /* @__PURE__ */ new Map();
function useEventBus(key) {
  const scope = getCurrentScope();
  function on(listener) {
    var _a;
    const listeners = events.get(key) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    events.set(key, listeners);
    const _off = /* @__PURE__ */ __name(() => off(listener), "_off");
    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);
    return _off;
  }
  __name(on, "on");
  function once2(listener) {
    function _listener(...args) {
      off(_listener);
      listener(...args);
    }
    __name(_listener, "_listener");
    return on(_listener);
  }
  __name(once2, "once");
  function off(listener) {
    const listeners = events.get(key);
    if (!listeners)
      return;
    listeners.delete(listener);
    if (!listeners.size)
      reset();
  }
  __name(off, "off");
  function reset() {
    events.delete(key);
  }
  __name(reset, "reset");
  function emit2(event2, payload) {
    var _a;
    (_a = events.get(key)) == null ? void 0 : _a.forEach((v2) => v2(event2, payload));
  }
  __name(emit2, "emit");
  return { on, once: once2, off, emit: emit2, reset };
}
__name(useEventBus, "useEventBus");
function resolveNestedOptions$1(options3) {
  if (options3 === true)
    return {};
  return options3;
}
__name(resolveNestedOptions$1, "resolveNestedOptions$1");
function useEventSource(url, events2 = [], options3 = {}) {
  const event2 = ref(null);
  const data22 = ref(null);
  const status = ref("CONNECTING");
  const eventSource = ref(null);
  const error = shallowRef(null);
  const urlRef = toRef(url);
  const lastEventId = shallowRef(null);
  let explicitlyClosed = false;
  let retried = 0;
  const {
    withCredentials = false,
    immediate = true
  } = options3;
  const close4 = /* @__PURE__ */ __name(() => {
    if (isClient && eventSource.value) {
      eventSource.value.close();
      eventSource.value = null;
      status.value = "CLOSED";
      explicitlyClosed = true;
    }
  }, "close");
  const _init = /* @__PURE__ */ __name(() => {
    if (explicitlyClosed || typeof urlRef.value === "undefined")
      return;
    const es = new EventSource(urlRef.value, { withCredentials });
    status.value = "CONNECTING";
    eventSource.value = es;
    es.onopen = () => {
      status.value = "OPEN";
      error.value = null;
    };
    es.onerror = (e) => {
      status.value = "CLOSED";
      error.value = e;
      if (es.readyState === 2 && !explicitlyClosed && options3.autoReconnect) {
        es.close();
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions$1(options3.autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    es.onmessage = (e) => {
      event2.value = null;
      data22.value = e.data;
      lastEventId.value = e.lastEventId;
    };
    for (const event_name of events2) {
      useEventListener(es, event_name, (e) => {
        event2.value = event_name;
        data22.value = e.data || null;
      });
    }
  }, "_init");
  const open2 = /* @__PURE__ */ __name(() => {
    if (!isClient)
      return;
    close4();
    explicitlyClosed = false;
    retried = 0;
    _init();
  }, "open");
  if (immediate)
    watch(urlRef, open2, { immediate: true });
  tryOnScopeDispose(close4);
  return {
    eventSource,
    event: event2,
    data: data22,
    status,
    error,
    open: open2,
    close: close4,
    lastEventId
  };
}
__name(useEventSource, "useEventSource");
function useEyeDropper(options3 = {}) {
  const { initialValue = "" } = options3;
  const isSupported2 = useSupported(() => typeof window !== "undefined" && "EyeDropper" in window);
  const sRGBHex = ref(initialValue);
  async function open2(openOptions) {
    if (!isSupported2.value)
      return;
    const eyeDropper = new window.EyeDropper();
    const result = await eyeDropper.open(openOptions);
    sRGBHex.value = result.sRGBHex;
    return result;
  }
  __name(open2, "open");
  return { isSupported: isSupported2, sRGBHex, open: open2 };
}
__name(useEyeDropper, "useEyeDropper");
function useFavicon(newIcon = null, options3 = {}) {
  const {
    baseUrl = "",
    rel = "icon",
    document: document2 = defaultDocument
  } = options3;
  const favicon = toRef(newIcon);
  const applyIcon = /* @__PURE__ */ __name((icon2) => {
    const elements = document2 == null ? void 0 : document2.head.querySelectorAll(`link[rel*="${rel}"]`);
    if (!elements || elements.length === 0) {
      const link = document2 == null ? void 0 : document2.createElement("link");
      if (link) {
        link.rel = rel;
        link.href = `${baseUrl}${icon2}`;
        link.type = `image/${icon2.split(".").pop()}`;
        document2 == null ? void 0 : document2.head.append(link);
      }
      return;
    }
    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon2}`);
  }, "applyIcon");
  watch(
    favicon,
    (i2, o) => {
      if (typeof i2 === "string" && i2 !== o)
        applyIcon(i2);
    },
    { immediate: true }
  );
  return favicon;
}
__name(useFavicon, "useFavicon");
const payloadMapping = {
  json: "application/json",
  text: "text/plain"
};
function isFetchOptions(obj) {
  return obj && containsProp(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch", "updateDataOnError");
}
__name(isFetchOptions, "isFetchOptions");
const reAbsolute = /^(?:[a-z][a-z\d+\-.]*:)?\/\//i;
function isAbsoluteURL(url) {
  return reAbsolute.test(url);
}
__name(isAbsoluteURL, "isAbsoluteURL");
function headersToObject(headers) {
  if (typeof Headers !== "undefined" && headers instanceof Headers)
    return Object.fromEntries(headers.entries());
  return headers;
}
__name(headersToObject, "headersToObject");
function combineCallbacks(combination, ...callbacks) {
  if (combination === "overwrite") {
    return async (ctx) => {
      const callback = callbacks[callbacks.length - 1];
      if (callback)
        return { ...ctx, ...await callback(ctx) };
      return ctx;
    };
  } else {
    return async (ctx) => {
      for (const callback of callbacks) {
        if (callback)
          ctx = { ...ctx, ...await callback(ctx) };
      }
      return ctx;
    };
  }
}
__name(combineCallbacks, "combineCallbacks");
function createFetch(config2 = {}) {
  const _combination = config2.combination || "chain";
  const _options = config2.options || {};
  const _fetchOptions = config2.fetchOptions || {};
  function useFactoryFetch(url, ...args) {
    const computedUrl = computed(() => {
      const baseUrl = toValue(config2.baseUrl);
      const targetUrl = toValue(url);
      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;
    });
    let options3 = _options;
    let fetchOptions = _fetchOptions;
    if (args.length > 0) {
      if (isFetchOptions(args[0])) {
        options3 = {
          ...options3,
          ...args[0],
          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),
          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),
          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)
        };
      } else {
        fetchOptions = {
          ...fetchOptions,
          ...args[0],
          headers: {
            ...headersToObject(fetchOptions.headers) || {},
            ...headersToObject(args[0].headers) || {}
          }
        };
      }
    }
    if (args.length > 1 && isFetchOptions(args[1])) {
      options3 = {
        ...options3,
        ...args[1],
        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),
        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),
        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)
      };
    }
    return useFetch(computedUrl, fetchOptions, options3);
  }
  __name(useFactoryFetch, "useFactoryFetch");
  return useFactoryFetch;
}
__name(createFetch, "createFetch");
function useFetch(url, ...args) {
  var _a;
  const supportsAbort = typeof AbortController === "function";
  let fetchOptions = {};
  let options3 = {
    immediate: true,
    refetch: false,
    timeout: 0,
    updateDataOnError: false
  };
  const config2 = {
    method: "GET",
    type: "text",
    payload: void 0
  };
  if (args.length > 0) {
    if (isFetchOptions(args[0]))
      options3 = { ...options3, ...args[0] };
    else
      fetchOptions = args[0];
  }
  if (args.length > 1) {
    if (isFetchOptions(args[1]))
      options3 = { ...options3, ...args[1] };
  }
  const {
    fetch: fetch2 = (_a = defaultWindow) == null ? void 0 : _a.fetch,
    initialData,
    timeout
  } = options3;
  const responseEvent = createEventHook();
  const errorEvent = createEventHook();
  const finallyEvent = createEventHook();
  const isFinished = ref(false);
  const isFetching = ref(false);
  const aborted = ref(false);
  const statusCode = ref(null);
  const response = shallowRef(null);
  const error = shallowRef(null);
  const data22 = shallowRef(initialData || null);
  const canAbort = computed(() => supportsAbort && isFetching.value);
  let controller;
  let timer;
  const abort = /* @__PURE__ */ __name(() => {
    if (supportsAbort) {
      controller == null ? void 0 : controller.abort();
      controller = new AbortController();
      controller.signal.onabort = () => aborted.value = true;
      fetchOptions = {
        ...fetchOptions,
        signal: controller.signal
      };
    }
  }, "abort");
  const loading2 = /* @__PURE__ */ __name((isLoading) => {
    isFetching.value = isLoading;
    isFinished.value = !isLoading;
  }, "loading");
  if (timeout)
    timer = useTimeoutFn(abort, timeout, { immediate: false });
  let executeCounter = 0;
  const execute = /* @__PURE__ */ __name(async (throwOnFailed = false) => {
    var _a2, _b;
    abort();
    loading2(true);
    error.value = null;
    statusCode.value = null;
    aborted.value = false;
    executeCounter += 1;
    const currentExecuteCounter = executeCounter;
    const defaultFetchOptions = {
      method: config2.method,
      headers: {}
    };
    if (config2.payload) {
      const headers = headersToObject(defaultFetchOptions.headers);
      const payload = toValue(config2.payload);
      if (!config2.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))
        config2.payloadType = "json";
      if (config2.payloadType)
        headers["Content-Type"] = (_a2 = payloadMapping[config2.payloadType]) != null ? _a2 : config2.payloadType;
      defaultFetchOptions.body = config2.payloadType === "json" ? JSON.stringify(payload) : payload;
    }
    let isCanceled = false;
    const context = {
      url: toValue(url),
      options: {
        ...defaultFetchOptions,
        ...fetchOptions
      },
      cancel: /* @__PURE__ */ __name(() => {
        isCanceled = true;
      }, "cancel")
    };
    if (options3.beforeFetch)
      Object.assign(context, await options3.beforeFetch(context));
    if (isCanceled || !fetch2) {
      loading2(false);
      return Promise.resolve(null);
    }
    let responseData = null;
    if (timer)
      timer.start();
    return fetch2(
      context.url,
      {
        ...defaultFetchOptions,
        ...context.options,
        headers: {
          ...headersToObject(defaultFetchOptions.headers),
          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)
        }
      }
    ).then(async (fetchResponse) => {
      response.value = fetchResponse;
      statusCode.value = fetchResponse.status;
      responseData = await fetchResponse.clone()[config2.type]();
      if (!fetchResponse.ok) {
        data22.value = initialData || null;
        throw new Error(fetchResponse.statusText);
      }
      if (options3.afterFetch) {
        ({ data: responseData } = await options3.afterFetch({
          data: responseData,
          response: fetchResponse
        }));
      }
      data22.value = responseData;
      responseEvent.trigger(fetchResponse);
      return fetchResponse;
    }).catch(async (fetchError) => {
      let errorData = fetchError.message || fetchError.name;
      if (options3.onFetchError) {
        ({ error: errorData, data: responseData } = await options3.onFetchError({
          data: responseData,
          error: fetchError,
          response: response.value
        }));
      }
      error.value = errorData;
      if (options3.updateDataOnError)
        data22.value = responseData;
      errorEvent.trigger(fetchError);
      if (throwOnFailed)
        throw fetchError;
      return null;
    }).finally(() => {
      if (currentExecuteCounter === executeCounter)
        loading2(false);
      if (timer)
        timer.stop();
      finallyEvent.trigger(null);
    });
  }, "execute");
  const refetch = toRef(options3.refetch);
  watch(
    [
      refetch,
      toRef(url)
    ],
    ([refetch2]) => refetch2 && execute(),
    { deep: true }
  );
  const shell = {
    isFinished: readonly(isFinished),
    isFetching: readonly(isFetching),
    statusCode,
    response,
    error,
    data: data22,
    canAbort,
    aborted,
    abort,
    execute,
    onFetchResponse: responseEvent.on,
    onFetchError: errorEvent.on,
    onFetchFinally: finallyEvent.on,
    // method
    get: setMethod("GET"),
    put: setMethod("PUT"),
    post: setMethod("POST"),
    delete: setMethod("DELETE"),
    patch: setMethod("PATCH"),
    head: setMethod("HEAD"),
    options: setMethod("OPTIONS"),
    // type
    json: setType2("json"),
    text: setType2("text"),
    blob: setType2("blob"),
    arrayBuffer: setType2("arrayBuffer"),
    formData: setType2("formData")
  };
  function setMethod(method) {
    return (payload, payloadType) => {
      if (!isFetching.value) {
        config2.method = method;
        config2.payload = payload;
        config2.payloadType = payloadType;
        if (isRef(config2.payload)) {
          watch(
            [
              refetch,
              toRef(config2.payload)
            ],
            ([refetch2]) => refetch2 && execute(),
            { deep: true }
          );
        }
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  __name(setMethod, "setMethod");
  function waitUntilFinished() {
    return new Promise((resolve2, reject2) => {
      until(isFinished).toBe(true).then(() => resolve2(shell)).catch((error2) => reject2(error2));
    });
  }
  __name(waitUntilFinished, "waitUntilFinished");
  function setType2(type) {
    return () => {
      if (!isFetching.value) {
        config2.type = type;
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      return void 0;
    };
  }
  __name(setType2, "setType");
  if (options3.immediate)
    Promise.resolve().then(() => execute());
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilFinished().then(onFulfilled, onRejected);
    }
  };
}
__name(useFetch, "useFetch");
function joinPaths(start2, end) {
  if (!start2.endsWith("/") && !end.startsWith("/"))
    return `${start2}/${end}`;
  return `${start2}${end}`;
}
__name(joinPaths, "joinPaths");
const DEFAULT_OPTIONS = {
  multiple: true,
  accept: "*",
  reset: false,
  directory: false
};
function useFileDialog(options3 = {}) {
  const {
    document: document2 = defaultDocument
  } = options3;
  const files = ref(null);
  const { on: onChange4, trigger: trigger2 } = createEventHook();
  let input;
  if (document2) {
    input = document2.createElement("input");
    input.type = "file";
    input.onchange = (event2) => {
      const result = event2.target;
      files.value = result.files;
      trigger2(files.value);
    };
  }
  const reset = /* @__PURE__ */ __name(() => {
    files.value = null;
    if (input && input.value) {
      input.value = "";
      trigger2(null);
    }
  }, "reset");
  const open2 = /* @__PURE__ */ __name((localOptions) => {
    if (!input)
      return;
    const _options = {
      ...DEFAULT_OPTIONS,
      ...options3,
      ...localOptions
    };
    input.multiple = _options.multiple;
    input.accept = _options.accept;
    input.webkitdirectory = _options.directory;
    if (hasOwn$1(_options, "capture"))
      input.capture = _options.capture;
    if (_options.reset)
      reset();
    input.click();
  }, "open");
  return {
    files: readonly(files),
    open: open2,
    reset,
    onChange: onChange4
  };
}
__name(useFileDialog, "useFileDialog");
function useFileSystemAccess(options3 = {}) {
  const {
    window: _window = defaultWindow,
    dataType = "Text"
  } = options3;
  const window2 = _window;
  const isSupported2 = useSupported(() => window2 && "showSaveFilePicker" in window2 && "showOpenFilePicker" in window2);
  const fileHandle = ref();
  const data22 = ref();
  const file = ref();
  const fileName = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : "";
  });
  const fileMIME = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : "";
  });
  const fileSize = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;
  });
  const fileLastModified = computed(() => {
    var _a, _b;
    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;
  });
  async function open2(_options = {}) {
    if (!isSupported2.value)
      return;
    const [handle] = await window2.showOpenFilePicker({ ...toValue(options3), ..._options });
    fileHandle.value = handle;
    await updateData();
  }
  __name(open2, "open");
  async function create3(_options = {}) {
    if (!isSupported2.value)
      return;
    fileHandle.value = await window2.showSaveFilePicker({ ...options3, ..._options });
    data22.value = void 0;
    await updateData();
  }
  __name(create3, "create");
  async function save(_options = {}) {
    if (!isSupported2.value)
      return;
    if (!fileHandle.value)
      return saveAs2(_options);
    if (data22.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data22.value);
      await writableStream.close();
    }
    await updateFile();
  }
  __name(save, "save");
  async function saveAs2(_options = {}) {
    if (!isSupported2.value)
      return;
    fileHandle.value = await window2.showSaveFilePicker({ ...options3, ..._options });
    if (data22.value) {
      const writableStream = await fileHandle.value.createWritable();
      await writableStream.write(data22.value);
      await writableStream.close();
    }
    await updateFile();
  }
  __name(saveAs2, "saveAs");
  async function updateFile() {
    var _a;
    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());
  }
  __name(updateFile, "updateFile");
  async function updateData() {
    var _a, _b;
    await updateFile();
    const type = toValue(dataType);
    if (type === "Text")
      data22.value = await ((_a = file.value) == null ? void 0 : _a.text());
    else if (type === "ArrayBuffer")
      data22.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());
    else if (type === "Blob")
      data22.value = file.value;
  }
  __name(updateData, "updateData");
  watch(() => toValue(dataType), updateData);
  return {
    isSupported: isSupported2,
    data: data22,
    file,
    fileName,
    fileMIME,
    fileSize,
    fileLastModified,
    open: open2,
    create: create3,
    save,
    saveAs: saveAs2,
    updateData
  };
}
__name(useFileSystemAccess, "useFileSystemAccess");
function useFocus(target, options3 = {}) {
  const { initialValue = false, focusVisible = false, preventScroll = false } = options3;
  const innerFocused = ref(false);
  const targetElement = computed(() => unrefElement(target));
  useEventListener(targetElement, "focus", (event2) => {
    var _a, _b;
    if (!focusVisible || ((_b = (_a = event2.target).matches) == null ? void 0 : _b.call(_a, ":focus-visible")))
      innerFocused.value = true;
  });
  useEventListener(targetElement, "blur", () => innerFocused.value = false);
  const focused = computed({
    get: /* @__PURE__ */ __name(() => innerFocused.value, "get"),
    set(value3) {
      var _a, _b;
      if (!value3 && innerFocused.value)
        (_a = targetElement.value) == null ? void 0 : _a.blur();
      else if (value3 && !innerFocused.value)
        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });
    }
  });
  watch(
    targetElement,
    () => {
      focused.value = initialValue;
    },
    { immediate: true, flush: "post" }
  );
  return { focused };
}
__name(useFocus, "useFocus");
function useFocusWithin(target, options3 = {}) {
  const activeElement = useActiveElement(options3);
  const targetElement = computed(() => unrefElement(target));
  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);
  return { focused };
}
__name(useFocusWithin, "useFocusWithin");
function useFps(options3) {
  var _a;
  const fps = ref(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a = options3 == null ? void 0 : options3.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now2 = performance.now();
      const diff2 = now2 - last;
      fps.value = Math.round(1e3 / (diff2 / ticks));
      last = now2;
      ticks = 0;
    }
  });
  return fps;
}
__name(useFps, "useFps");
const eventHandlers = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function useFullscreen(target, options3 = {}) {
  const {
    document: document2 = defaultDocument,
    autoExit = false
  } = options3;
  const targetRef = computed(() => {
    var _a;
    return (_a = unrefElement(target)) != null ? _a : document2 == null ? void 0 : document2.querySelector("html");
  });
  const isFullscreen = ref(false);
  const requestMethod = computed(() => {
    return [
      "requestFullscreen",
      "webkitRequestFullscreen",
      "webkitEnterFullscreen",
      "webkitEnterFullScreen",
      "webkitRequestFullScreen",
      "mozRequestFullScreen",
      "msRequestFullscreen"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const exitMethod = computed(() => {
    return [
      "exitFullscreen",
      "webkitExitFullscreen",
      "webkitExitFullScreen",
      "webkitCancelFullScreen",
      "mozCancelFullScreen",
      "msExitFullscreen"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const fullscreenEnabled = computed(() => {
    return [
      "fullScreen",
      "webkitIsFullScreen",
      "webkitDisplayingFullscreen",
      "mozFullScreen",
      "msFullscreenElement"
    ].find((m) => document2 && m in document2 || targetRef.value && m in targetRef.value);
  });
  const fullscreenElementMethod = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((m) => document2 && m in document2);
  const isSupported2 = useSupported(() => targetRef.value && document2 && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);
  const isCurrentElementFullScreen = /* @__PURE__ */ __name(() => {
    if (fullscreenElementMethod)
      return (document2 == null ? void 0 : document2[fullscreenElementMethod]) === targetRef.value;
    return false;
  }, "isCurrentElementFullScreen");
  const isElementFullScreen = /* @__PURE__ */ __name(() => {
    if (fullscreenEnabled.value) {
      if (document2 && document2[fullscreenEnabled.value] != null) {
        return document2[fullscreenEnabled.value];
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {
          return Boolean(target2[fullscreenEnabled.value]);
        }
      }
    }
    return false;
  }, "isElementFullScreen");
  async function exit() {
    if (!isSupported2.value || !isFullscreen.value)
      return;
    if (exitMethod.value) {
      if ((document2 == null ? void 0 : document2[exitMethod.value]) != null) {
        await document2[exitMethod.value]();
      } else {
        const target2 = targetRef.value;
        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)
          await target2[exitMethod.value]();
      }
    }
    isFullscreen.value = false;
  }
  __name(exit, "exit");
  async function enter() {
    if (!isSupported2.value || isFullscreen.value)
      return;
    if (isElementFullScreen())
      await exit();
    const target2 = targetRef.value;
    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {
      await target2[requestMethod.value]();
      isFullscreen.value = true;
    }
  }
  __name(enter, "enter");
  async function toggle4() {
    await (isFullscreen.value ? exit() : enter());
  }
  __name(toggle4, "toggle");
  const handlerCallback = /* @__PURE__ */ __name(() => {
    const isElementFullScreenValue = isElementFullScreen();
    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())
      isFullscreen.value = isElementFullScreenValue;
  }, "handlerCallback");
  useEventListener(document2, eventHandlers, handlerCallback, false);
  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);
  if (autoExit)
    tryOnScopeDispose(exit);
  return {
    isSupported: isSupported2,
    isFullscreen,
    enter,
    exit,
    toggle: toggle4
  };
}
__name(useFullscreen, "useFullscreen");
function mapGamepadToXbox360Controller(gamepad) {
  return computed(() => {
    if (gamepad.value) {
      return {
        buttons: {
          a: gamepad.value.buttons[0],
          b: gamepad.value.buttons[1],
          x: gamepad.value.buttons[2],
          y: gamepad.value.buttons[3]
        },
        bumper: {
          left: gamepad.value.buttons[4],
          right: gamepad.value.buttons[5]
        },
        triggers: {
          left: gamepad.value.buttons[6],
          right: gamepad.value.buttons[7]
        },
        stick: {
          left: {
            horizontal: gamepad.value.axes[0],
            vertical: gamepad.value.axes[1],
            button: gamepad.value.buttons[10]
          },
          right: {
            horizontal: gamepad.value.axes[2],
            vertical: gamepad.value.axes[3],
            button: gamepad.value.buttons[11]
          }
        },
        dpad: {
          up: gamepad.value.buttons[12],
          down: gamepad.value.buttons[13],
          left: gamepad.value.buttons[14],
          right: gamepad.value.buttons[15]
        },
        back: gamepad.value.buttons[8],
        start: gamepad.value.buttons[9]
      };
    }
    return null;
  });
}
__name(mapGamepadToXbox360Controller, "mapGamepadToXbox360Controller");
function useGamepad(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator
  } = options3;
  const isSupported2 = useSupported(() => navigator2 && "getGamepads" in navigator2);
  const gamepads = ref([]);
  const onConnectedHook = createEventHook();
  const onDisconnectedHook = createEventHook();
  const stateFromGamepad = /* @__PURE__ */ __name((gamepad) => {
    const hapticActuators = [];
    const vibrationActuator = "vibrationActuator" in gamepad ? gamepad.vibrationActuator : null;
    if (vibrationActuator)
      hapticActuators.push(vibrationActuator);
    if (gamepad.hapticActuators)
      hapticActuators.push(...gamepad.hapticActuators);
    return {
      id: gamepad.id,
      index: gamepad.index,
      connected: gamepad.connected,
      mapping: gamepad.mapping,
      timestamp: gamepad.timestamp,
      vibrationActuator: gamepad.vibrationActuator,
      hapticActuators,
      axes: gamepad.axes.map((axes) => axes),
      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))
    };
  }, "stateFromGamepad");
  const updateGamepadState = /* @__PURE__ */ __name(() => {
    const _gamepads = (navigator2 == null ? void 0 : navigator2.getGamepads()) || [];
    for (const gamepad of _gamepads) {
      if (gamepad && gamepads.value[gamepad.index])
        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);
    }
  }, "updateGamepadState");
  const { isActive, pause, resume } = useRafFn(updateGamepadState);
  const onGamepadConnected = /* @__PURE__ */ __name((gamepad) => {
    if (!gamepads.value.some(({ index: index2 }) => index2 === gamepad.index)) {
      gamepads.value.push(stateFromGamepad(gamepad));
      onConnectedHook.trigger(gamepad.index);
    }
    resume();
  }, "onGamepadConnected");
  const onGamepadDisconnected = /* @__PURE__ */ __name((gamepad) => {
    gamepads.value = gamepads.value.filter((x2) => x2.index !== gamepad.index);
    onDisconnectedHook.trigger(gamepad.index);
  }, "onGamepadDisconnected");
  useEventListener("gamepadconnected", (e) => onGamepadConnected(e.gamepad));
  useEventListener("gamepaddisconnected", (e) => onGamepadDisconnected(e.gamepad));
  tryOnMounted(() => {
    const _gamepads = (navigator2 == null ? void 0 : navigator2.getGamepads()) || [];
    for (const gamepad of _gamepads) {
      if (gamepad && gamepads.value[gamepad.index])
        onGamepadConnected(gamepad);
    }
  });
  pause();
  return {
    isSupported: isSupported2,
    onConnected: onConnectedHook.on,
    onDisconnected: onDisconnectedHook.on,
    gamepads,
    pause,
    resume,
    isActive
  };
}
__name(useGamepad, "useGamepad");
function useGeolocation(options3 = {}) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3,
    navigator: navigator2 = defaultNavigator,
    immediate = true
  } = options3;
  const isSupported2 = useSupported(() => navigator2 && "geolocation" in navigator2);
  const locatedAt = ref(null);
  const error = shallowRef(null);
  const coords = ref({
    accuracy: 0,
    latitude: Number.POSITIVE_INFINITY,
    longitude: Number.POSITIVE_INFINITY,
    altitude: null,
    altitudeAccuracy: null,
    heading: null,
    speed: null
  });
  function updatePosition(position2) {
    locatedAt.value = position2.timestamp;
    coords.value = position2.coords;
    error.value = null;
  }
  __name(updatePosition, "updatePosition");
  let watcher;
  function resume() {
    if (isSupported2.value) {
      watcher = navigator2.geolocation.watchPosition(
        updatePosition,
        (err) => error.value = err,
        {
          enableHighAccuracy,
          maximumAge,
          timeout
        }
      );
    }
  }
  __name(resume, "resume");
  if (immediate)
    resume();
  function pause() {
    if (watcher && navigator2)
      navigator2.geolocation.clearWatch(watcher);
  }
  __name(pause, "pause");
  tryOnScopeDispose(() => {
    pause();
  });
  return {
    isSupported: isSupported2,
    coords,
    locatedAt,
    error,
    resume,
    pause
  };
}
__name(useGeolocation, "useGeolocation");
const defaultEvents$1 = ["mousemove", "mousedown", "resize", "keydown", "touchstart", "wheel"];
const oneMinute = 6e4;
function useIdle(timeout = oneMinute, options3 = {}) {
  const {
    initialState = false,
    listenForVisibilityChange = true,
    events: events2 = defaultEvents$1,
    window: window2 = defaultWindow,
    eventFilter = throttleFilter(50)
  } = options3;
  const idle = ref(initialState);
  const lastActive = ref(timestamp());
  let timer;
  const reset = /* @__PURE__ */ __name(() => {
    idle.value = false;
    clearTimeout(timer);
    timer = setTimeout(() => idle.value = true, timeout);
  }, "reset");
  const onEvent = createFilterWrapper(
    eventFilter,
    () => {
      lastActive.value = timestamp();
      reset();
    }
  );
  if (window2) {
    const document2 = window2.document;
    for (const event2 of events2)
      useEventListener(window2, event2, onEvent, { passive: true });
    if (listenForVisibilityChange) {
      useEventListener(document2, "visibilitychange", () => {
        if (!document2.hidden)
          onEvent();
      });
    }
    reset();
  }
  return {
    idle,
    lastActive,
    reset
  };
}
__name(useIdle, "useIdle");
async function loadImage(options3) {
  return new Promise((resolve2, reject2) => {
    const img = new Image();
    const { src, srcset, sizes, class: clazz, loading: loading2, crossorigin, referrerPolicy } = options3;
    img.src = src;
    if (srcset)
      img.srcset = srcset;
    if (sizes)
      img.sizes = sizes;
    if (clazz)
      img.className = clazz;
    if (loading2)
      img.loading = loading2;
    if (crossorigin)
      img.crossOrigin = crossorigin;
    if (referrerPolicy)
      img.referrerPolicy = referrerPolicy;
    img.onload = () => resolve2(img);
    img.onerror = reject2;
  });
}
__name(loadImage, "loadImage");
function useImage(options3, asyncStateOptions = {}) {
  const state = useAsyncState(
    () => loadImage(toValue(options3)),
    void 0,
    {
      resetOnExecute: true,
      ...asyncStateOptions
    }
  );
  watch(
    () => toValue(options3),
    () => state.execute(asyncStateOptions.delay),
    { deep: true }
  );
  return state;
}
__name(useImage, "useImage");
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(element, options3 = {}) {
  const {
    throttle: throttle2 = 0,
    idle = 200,
    onStop = noop$1,
    onScroll: onScroll4 = noop$1,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions = {
      capture: false,
      passive: true
    },
    behavior = "auto",
    window: window2 = defaultWindow,
    onError = /* @__PURE__ */ __name((e) => {
      console.error(e);
    }, "onError")
  } = options3;
  const internalX = ref(0);
  const internalY = ref(0);
  const x2 = computed({
    get() {
      return internalX.value;
    },
    set(x22) {
      scrollTo22(x22, void 0);
    }
  });
  const y2 = computed({
    get() {
      return internalY.value;
    },
    set(y22) {
      scrollTo22(void 0, y22);
    }
  });
  function scrollTo22(_x, _y) {
    var _a, _b, _c, _d;
    if (!window2)
      return;
    const _element = toValue(element);
    if (!_element)
      return;
    (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
      top: (_a = toValue(_y)) != null ? _a : y2.value,
      left: (_b = toValue(_x)) != null ? _b : x2.value,
      behavior: toValue(behavior)
    });
    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
    if (x2 != null)
      internalX.value = scrollContainer.scrollLeft;
    if (y2 != null)
      internalY.value = scrollContainer.scrollTop;
  }
  __name(scrollTo22, "scrollTo2");
  const isScrolling = ref(false);
  const arrivedState = reactive({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const directions = reactive({
    left: false,
    right: false,
    top: false,
    bottom: false
  });
  const onScrollEnd = /* @__PURE__ */ __name((e) => {
    if (!isScrolling.value)
      return;
    isScrolling.value = false;
    directions.left = false;
    directions.right = false;
    directions.top = false;
    directions.bottom = false;
    onStop(e);
  }, "onScrollEnd");
  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle2 + idle);
  const setArrivedState = /* @__PURE__ */ __name((target) => {
    var _a;
    if (!window2)
      return;
    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);
    const { display, flexDirection } = getComputedStyle(el);
    const scrollLeft = el.scrollLeft;
    directions.left = scrollLeft < internalX.value;
    directions.right = scrollLeft > internalX.value;
    const left = Math.abs(scrollLeft) <= (offset.left || 0);
    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "row-reverse") {
      arrivedState.left = right;
      arrivedState.right = left;
    } else {
      arrivedState.left = left;
      arrivedState.right = right;
    }
    internalX.value = scrollLeft;
    let scrollTop2 = el.scrollTop;
    if (target === window2.document && !scrollTop2)
      scrollTop2 = window2.document.body.scrollTop;
    directions.top = scrollTop2 < internalY.value;
    directions.bottom = scrollTop2 > internalY.value;
    const top = Math.abs(scrollTop2) <= (offset.top || 0);
    const bottom = Math.abs(scrollTop2) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "column-reverse") {
      arrivedState.top = bottom;
      arrivedState.bottom = top;
    } else {
      arrivedState.top = top;
      arrivedState.bottom = bottom;
    }
    internalY.value = scrollTop2;
  }, "setArrivedState");
  const onScrollHandler = /* @__PURE__ */ __name((e) => {
    var _a;
    if (!window2)
      return;
    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;
    setArrivedState(eventTarget);
    isScrolling.value = true;
    onScrollEndDebounced(e);
    onScroll4(e);
  }, "onScrollHandler");
  useEventListener(
    element,
    "scroll",
    throttle2 ? useThrottleFn(onScrollHandler, throttle2, true, false) : onScrollHandler,
    eventListenerOptions
  );
  tryOnMounted(() => {
    try {
      const _element = toValue(element);
      if (!_element)
        return;
      setArrivedState(_element);
    } catch (e) {
      onError(e);
    }
  });
  useEventListener(
    element,
    "scrollend",
    onScrollEnd,
    eventListenerOptions
  );
  return {
    x: x2,
    y: y2,
    isScrolling,
    arrivedState,
    directions,
    measure() {
      const _element = toValue(element);
      if (window2 && _element)
        setArrivedState(_element);
    }
  };
}
__name(useScroll, "useScroll");
function resolveElement(el) {
  if (typeof Window !== "undefined" && el instanceof Window)
    return el.document.documentElement;
  if (typeof Document !== "undefined" && el instanceof Document)
    return el.documentElement;
  return el;
}
__name(resolveElement, "resolveElement");
function useInfiniteScroll(element, onLoadMore, options3 = {}) {
  var _a;
  const {
    direction = "bottom",
    interval = 100,
    canLoadMore = /* @__PURE__ */ __name(() => true, "canLoadMore")
  } = options3;
  const state = reactive(useScroll(
    element,
    {
      ...options3,
      offset: {
        [direction]: (_a = options3.distance) != null ? _a : 0,
        ...options3.offset
      }
    }
  ));
  const promise = ref();
  const isLoading = computed(() => !!promise.value);
  const observedElement = computed(() => {
    return resolveElement(toValue(element));
  });
  const isElementVisible = useElementVisibility(observedElement);
  function checkAndLoad() {
    state.measure();
    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))
      return;
    const { scrollHeight: scrollHeight2, clientHeight, scrollWidth: scrollWidth2, clientWidth } = observedElement.value;
    const isNarrower = direction === "bottom" || direction === "top" ? scrollHeight2 <= clientHeight : scrollWidth2 <= clientWidth;
    if (state.arrivedState[direction] || isNarrower) {
      if (!promise.value) {
        promise.value = Promise.all([
          onLoadMore(state),
          new Promise((resolve2) => setTimeout(resolve2, interval))
        ]).finally(() => {
          promise.value = null;
          nextTick(() => checkAndLoad());
        });
      }
    }
  }
  __name(checkAndLoad, "checkAndLoad");
  watch(
    () => [state.arrivedState[direction], isElementVisible.value],
    checkAndLoad,
    { immediate: true }
  );
  return {
    isLoading,
    reset() {
      nextTick(() => checkAndLoad());
    }
  };
}
__name(useInfiniteScroll, "useInfiniteScroll");
const defaultEvents = ["mousedown", "mouseup", "keydown", "keyup"];
function useKeyModifier(modifier, options3 = {}) {
  const {
    events: events2 = defaultEvents,
    document: document2 = defaultDocument,
    initial = null
  } = options3;
  const state = ref(initial);
  if (document2) {
    events2.forEach((listenerEvent) => {
      useEventListener(document2, listenerEvent, (evt) => {
        if (typeof evt.getModifierState === "function")
          state.value = evt.getModifierState(modifier);
      });
    });
  }
  return state;
}
__name(useKeyModifier, "useKeyModifier");
function useLocalStorage(key, initialValue, options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options3);
}
__name(useLocalStorage, "useLocalStorage");
const DefaultMagicKeysAliasMap = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
function useMagicKeys(options3 = {}) {
  const {
    reactive: useReactive = false,
    target = defaultWindow,
    aliasMap = DefaultMagicKeysAliasMap,
    passive = true,
    onEventFired = noop$1
  } = options3;
  const current = reactive(/* @__PURE__ */ new Set());
  const obj = {
    toJSON() {
      return {};
    },
    current
  };
  const refs = useReactive ? reactive(obj) : obj;
  const metaDeps = /* @__PURE__ */ new Set();
  const usedKeys = /* @__PURE__ */ new Set();
  function setRefs(key, value3) {
    if (key in refs) {
      if (useReactive)
        refs[key] = value3;
      else
        refs[key].value = value3;
    }
  }
  __name(setRefs, "setRefs");
  function reset() {
    current.clear();
    for (const key of usedKeys)
      setRefs(key, false);
  }
  __name(reset, "reset");
  function updateRefs(e, value3) {
    var _a, _b;
    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();
    const code2 = (_b = e.code) == null ? void 0 : _b.toLowerCase();
    const values2 = [code2, key].filter(Boolean);
    if (key) {
      if (value3)
        current.add(key);
      else
        current.delete(key);
    }
    for (const key2 of values2) {
      usedKeys.add(key2);
      setRefs(key2, value3);
    }
    if (key === "meta" && !value3) {
      metaDeps.forEach((key2) => {
        current.delete(key2);
        setRefs(key2, false);
      });
      metaDeps.clear();
    } else if (typeof e.getModifierState === "function" && e.getModifierState("Meta") && value3) {
      [...current, ...values2].forEach((key2) => metaDeps.add(key2));
    }
  }
  __name(updateRefs, "updateRefs");
  useEventListener(target, "keydown", (e) => {
    updateRefs(e, true);
    return onEventFired(e);
  }, { passive });
  useEventListener(target, "keyup", (e) => {
    updateRefs(e, false);
    return onEventFired(e);
  }, { passive });
  useEventListener("blur", reset, { passive: true });
  useEventListener("focus", reset, { passive: true });
  const proxy = new Proxy(
    refs,
    {
      get(target2, prop2, rec) {
        if (typeof prop2 !== "string")
          return Reflect.get(target2, prop2, rec);
        prop2 = prop2.toLowerCase();
        if (prop2 in aliasMap)
          prop2 = aliasMap[prop2];
        if (!(prop2 in refs)) {
          if (/[+_-]/.test(prop2)) {
            const keys2 = prop2.split(/[+_-]/g).map((i2) => i2.trim());
            refs[prop2] = computed(() => keys2.every((key) => toValue(proxy[key])));
          } else {
            refs[prop2] = ref(false);
          }
        }
        const r = Reflect.get(target2, prop2, rec);
        return useReactive ? toValue(r) : r;
      }
    }
  );
  return proxy;
}
__name(useMagicKeys, "useMagicKeys");
function usingElRef(source, cb) {
  if (toValue(source))
    cb(toValue(source));
}
__name(usingElRef, "usingElRef");
function timeRangeToArray(timeRanges) {
  let ranges = [];
  for (let i2 = 0; i2 < timeRanges.length; ++i2)
    ranges = [...ranges, [timeRanges.start(i2), timeRanges.end(i2)]];
  return ranges;
}
__name(timeRangeToArray, "timeRangeToArray");
function tracksToArray(tracks) {
  return Array.from(tracks).map(({ label: label5, kind, language, mode: mode2, activeCues, cues, inBandMetadataTrackDispatchType }, id3) => ({ id: id3, label: label5, kind, language, mode: mode2, activeCues, cues, inBandMetadataTrackDispatchType }));
}
__name(tracksToArray, "tracksToArray");
const defaultOptions$1 = {
  src: "",
  tracks: []
};
function useMediaControls(target, options3 = {}) {
  target = toRef(target);
  options3 = {
    ...defaultOptions$1,
    ...options3
  };
  const {
    document: document2 = defaultDocument
  } = options3;
  const currentTime = ref(0);
  const duration = ref(0);
  const seeking = ref(false);
  const volume = ref(1);
  const waiting = ref(false);
  const ended = ref(false);
  const playing = ref(false);
  const rate = ref(1);
  const stalled = ref(false);
  const buffered = ref([]);
  const tracks = ref([]);
  const selectedTrack = ref(-1);
  const isPictureInPicture = ref(false);
  const muted = ref(false);
  const supportsPictureInPicture = document2 && "pictureInPictureEnabled" in document2;
  const sourceErrorEvent = createEventHook();
  const disableTrack = /* @__PURE__ */ __name((track2) => {
    usingElRef(target, (el) => {
      if (track2) {
        const id3 = typeof track2 === "number" ? track2 : track2.id;
        el.textTracks[id3].mode = "disabled";
      } else {
        for (let i2 = 0; i2 < el.textTracks.length; ++i2)
          el.textTracks[i2].mode = "disabled";
      }
      selectedTrack.value = -1;
    });
  }, "disableTrack");
  const enableTrack = /* @__PURE__ */ __name((track2, disableTracks = true) => {
    usingElRef(target, (el) => {
      const id3 = typeof track2 === "number" ? track2 : track2.id;
      if (disableTracks)
        disableTrack();
      el.textTracks[id3].mode = "showing";
      selectedTrack.value = id3;
    });
  }, "enableTrack");
  const togglePictureInPicture = /* @__PURE__ */ __name(() => {
    return new Promise((resolve2, reject2) => {
      usingElRef(target, async (el) => {
        if (supportsPictureInPicture) {
          if (!isPictureInPicture.value) {
            el.requestPictureInPicture().then(resolve2).catch(reject2);
          } else {
            document2.exitPictureInPicture().then(resolve2).catch(reject2);
          }
        }
      });
    });
  }, "togglePictureInPicture");
  watchEffect(() => {
    if (!document2)
      return;
    const el = toValue(target);
    if (!el)
      return;
    const src = toValue(options3.src);
    let sources = [];
    if (!src)
      return;
    if (typeof src === "string")
      sources = [{ src }];
    else if (Array.isArray(src))
      sources = src;
    else if (isObject$1(src))
      sources = [src];
    el.querySelectorAll("source").forEach((e) => {
      e.removeEventListener("error", sourceErrorEvent.trigger);
      e.remove();
    });
    sources.forEach(({ src: src2, type }) => {
      const source = document2.createElement("source");
      source.setAttribute("src", src2);
      source.setAttribute("type", type || "");
      source.addEventListener("error", sourceErrorEvent.trigger);
      el.appendChild(source);
    });
    el.load();
  });
  tryOnScopeDispose(() => {
    const el = toValue(target);
    if (!el)
      return;
    el.querySelectorAll("source").forEach((e) => e.removeEventListener("error", sourceErrorEvent.trigger));
  });
  watch([target, volume], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.volume = volume.value;
  });
  watch([target, muted], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.muted = muted.value;
  });
  watch([target, rate], () => {
    const el = toValue(target);
    if (!el)
      return;
    el.playbackRate = rate.value;
  });
  watchEffect(() => {
    if (!document2)
      return;
    const textTracks = toValue(options3.tracks);
    const el = toValue(target);
    if (!textTracks || !textTracks.length || !el)
      return;
    el.querySelectorAll("track").forEach((e) => e.remove());
    textTracks.forEach(({ default: isDefault, kind, label: label5, src, srcLang }, i2) => {
      const track2 = document2.createElement("track");
      track2.default = isDefault || false;
      track2.kind = kind;
      track2.label = label5;
      track2.src = src;
      track2.srclang = srcLang;
      if (track2.default)
        selectedTrack.value = i2;
      el.appendChild(track2);
    });
  });
  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {
    const el = toValue(target);
    if (!el)
      return;
    el.currentTime = time;
  });
  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {
    const el = toValue(target);
    if (!el)
      return;
    if (isPlaying)
      el.play();
    else
      el.pause();
  });
  useEventListener(target, "timeupdate", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));
  useEventListener(target, "durationchange", () => duration.value = toValue(target).duration);
  useEventListener(target, "progress", () => buffered.value = timeRangeToArray(toValue(target).buffered));
  useEventListener(target, "seeking", () => seeking.value = true);
  useEventListener(target, "seeked", () => seeking.value = false);
  useEventListener(target, ["waiting", "loadstart"], () => {
    waiting.value = true;
    ignorePlayingUpdates(() => playing.value = false);
  });
  useEventListener(target, "loadeddata", () => waiting.value = false);
  useEventListener(target, "playing", () => {
    waiting.value = false;
    ended.value = false;
    ignorePlayingUpdates(() => playing.value = true);
  });
  useEventListener(target, "ratechange", () => rate.value = toValue(target).playbackRate);
  useEventListener(target, "stalled", () => stalled.value = true);
  useEventListener(target, "ended", () => ended.value = true);
  useEventListener(target, "pause", () => ignorePlayingUpdates(() => playing.value = false));
  useEventListener(target, "play", () => ignorePlayingUpdates(() => playing.value = true));
  useEventListener(target, "enterpictureinpicture", () => isPictureInPicture.value = true);
  useEventListener(target, "leavepictureinpicture", () => isPictureInPicture.value = false);
  useEventListener(target, "volumechange", () => {
    const el = toValue(target);
    if (!el)
      return;
    volume.value = el.volume;
    muted.value = el.muted;
  });
  const listeners = [];
  const stop2 = watch([target], () => {
    const el = toValue(target);
    if (!el)
      return;
    stop2();
    listeners[0] = useEventListener(el.textTracks, "addtrack", () => tracks.value = tracksToArray(el.textTracks));
    listeners[1] = useEventListener(el.textTracks, "removetrack", () => tracks.value = tracksToArray(el.textTracks));
    listeners[2] = useEventListener(el.textTracks, "change", () => tracks.value = tracksToArray(el.textTracks));
  });
  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));
  return {
    currentTime,
    duration,
    waiting,
    seeking,
    ended,
    stalled,
    buffered,
    playing,
    rate,
    // Volume
    volume,
    muted,
    // Tracks
    tracks,
    selectedTrack,
    enableTrack,
    disableTrack,
    // Picture in Picture
    supportsPictureInPicture,
    togglePictureInPicture,
    isPictureInPicture,
    // Events
    onSourceError: sourceErrorEvent.on
  };
}
__name(useMediaControls, "useMediaControls");
function getMapVue2Compat() {
  const data22 = shallowReactive({});
  return {
    get: /* @__PURE__ */ __name((key) => data22[key], "get"),
    set: /* @__PURE__ */ __name((key, value3) => set(data22, key, value3), "set"),
    has: /* @__PURE__ */ __name((key) => hasOwn$1(data22, key), "has"),
    delete: /* @__PURE__ */ __name((key) => del(data22, key), "delete"),
    clear: /* @__PURE__ */ __name(() => {
      Object.keys(data22).forEach((key) => {
        del(data22, key);
      });
    }, "clear")
  };
}
__name(getMapVue2Compat, "getMapVue2Compat");
function useMemoize(resolver, options3) {
  const initCache = /* @__PURE__ */ __name(() => {
    if (options3 == null ? void 0 : options3.cache)
      return shallowReactive(options3.cache);
    if (isVue2)
      return getMapVue2Compat();
    return shallowReactive(/* @__PURE__ */ new Map());
  }, "initCache");
  const cache2 = initCache();
  const generateKey = /* @__PURE__ */ __name((...args) => (options3 == null ? void 0 : options3.getKey) ? options3.getKey(...args) : JSON.stringify(args), "generateKey");
  const _loadData = /* @__PURE__ */ __name((key, ...args) => {
    cache2.set(key, resolver(...args));
    return cache2.get(key);
  }, "_loadData");
  const loadData = /* @__PURE__ */ __name((...args) => _loadData(generateKey(...args), ...args), "loadData");
  const deleteData = /* @__PURE__ */ __name((...args) => {
    cache2.delete(generateKey(...args));
  }, "deleteData");
  const clearData = /* @__PURE__ */ __name(() => {
    cache2.clear();
  }, "clearData");
  const memoized = /* @__PURE__ */ __name((...args) => {
    const key = generateKey(...args);
    if (cache2.has(key))
      return cache2.get(key);
    return _loadData(key, ...args);
  }, "memoized");
  memoized.load = loadData;
  memoized.delete = deleteData;
  memoized.clear = clearData;
  memoized.generateKey = generateKey;
  memoized.cache = cache2;
  return memoized;
}
__name(useMemoize, "useMemoize");
function useMemory(options3 = {}) {
  const memory = ref();
  const isSupported2 = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported2.value) {
    const { interval = 1e3 } = options3;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options3.immediate, immediateCallback: options3.immediateCallback });
  }
  return { isSupported: isSupported2, memory };
}
__name(useMemory, "useMemory");
const UseMouseBuiltinExtractors = {
  page: /* @__PURE__ */ __name((event2) => [event2.pageX, event2.pageY], "page"),
  client: /* @__PURE__ */ __name((event2) => [event2.clientX, event2.clientY], "client"),
  screen: /* @__PURE__ */ __name((event2) => [event2.screenX, event2.screenY], "screen"),
  movement: /* @__PURE__ */ __name((event2) => event2 instanceof Touch ? null : [event2.movementX, event2.movementY], "movement")
};
function useMouse(options3 = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow,
    target = window2,
    scroll = true,
    eventFilter
  } = options3;
  let _prevMouseEvent = null;
  const x2 = ref(initialValue.x);
  const y2 = ref(initialValue.y);
  const sourceType = ref(null);
  const extractor = typeof type === "function" ? type : UseMouseBuiltinExtractors[type];
  const mouseHandler = /* @__PURE__ */ __name((event2) => {
    const result = extractor(event2);
    _prevMouseEvent = event2;
    if (result) {
      [x2.value, y2.value] = result;
      sourceType.value = "mouse";
    }
  }, "mouseHandler");
  const touchHandler = /* @__PURE__ */ __name((event2) => {
    if (event2.touches.length > 0) {
      const result = extractor(event2.touches[0]);
      if (result) {
        [x2.value, y2.value] = result;
        sourceType.value = "touch";
      }
    }
  }, "touchHandler");
  const scrollHandler = /* @__PURE__ */ __name(() => {
    if (!_prevMouseEvent || !window2)
      return;
    const pos2 = extractor(_prevMouseEvent);
    if (_prevMouseEvent instanceof MouseEvent && pos2) {
      x2.value = pos2[0] + window2.scrollX;
      y2.value = pos2[1] + window2.scrollY;
    }
  }, "scrollHandler");
  const reset = /* @__PURE__ */ __name(() => {
    x2.value = initialValue.x;
    y2.value = initialValue.y;
  }, "reset");
  const mouseHandlerWrapper = eventFilter ? (event2) => eventFilter(() => mouseHandler(event2), {}) : (event2) => mouseHandler(event2);
  const touchHandlerWrapper = eventFilter ? (event2) => eventFilter(() => touchHandler(event2), {}) : (event2) => touchHandler(event2);
  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["mousemove", "dragover"], mouseHandlerWrapper, listenerOptions);
    if (touch && type !== "movement") {
      useEventListener(target, ["touchstart", "touchmove"], touchHandlerWrapper, listenerOptions);
      if (resetOnTouchEnds)
        useEventListener(target, "touchend", reset, listenerOptions);
    }
    if (scroll && type === "page")
      useEventListener(window2, "scroll", scrollHandlerWrapper, { passive: true });
  }
  return {
    x: x2,
    y: y2,
    sourceType
  };
}
__name(useMouse, "useMouse");
function useMouseInElement(target, options3 = {}) {
  const {
    handleOutside = true,
    window: window2 = defaultWindow
  } = options3;
  const type = options3.type || "page";
  const { x: x2, y: y2, sourceType } = useMouse(options3);
  const targetRef = ref(target != null ? target : window2 == null ? void 0 : window2.document.body);
  const elementX = ref(0);
  const elementY = ref(0);
  const elementPositionX = ref(0);
  const elementPositionY = ref(0);
  const elementHeight = ref(0);
  const elementWidth = ref(0);
  const isOutside = ref(true);
  let stop2 = /* @__PURE__ */ __name(() => {
  }, "stop");
  if (window2) {
    stop2 = watch(
      [targetRef, x2, y2],
      () => {
        const el = unrefElement(targetRef);
        if (!el || !(el instanceof HTMLElement))
          return;
        const {
          left,
          top,
          width: width2,
          height
        } = el.getBoundingClientRect();
        elementPositionX.value = left + (type === "page" ? window2.pageXOffset : 0);
        elementPositionY.value = top + (type === "page" ? window2.pageYOffset : 0);
        elementHeight.value = height;
        elementWidth.value = width2;
        const elX = x2.value - elementPositionX.value;
        const elY = y2.value - elementPositionY.value;
        isOutside.value = width2 === 0 || height === 0 || elX < 0 || elY < 0 || elX > width2 || elY > height;
        if (handleOutside || !isOutside.value) {
          elementX.value = elX;
          elementY.value = elY;
        }
      },
      { immediate: true }
    );
    useEventListener(document, "mouseleave", () => {
      isOutside.value = true;
    });
  }
  return {
    x: x2,
    y: y2,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop: stop2
  };
}
__name(useMouseInElement, "useMouseInElement");
function useMousePressed(options3 = {}) {
  const {
    touch = true,
    drag = true,
    capture = false,
    initialValue = false,
    window: window2 = defaultWindow
  } = options3;
  const pressed = ref(initialValue);
  const sourceType = ref(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = /* @__PURE__ */ __name((srcType) => () => {
    pressed.value = true;
    sourceType.value = srcType;
  }, "onPressed");
  const onReleased = /* @__PURE__ */ __name(() => {
    pressed.value = false;
    sourceType.value = null;
  }, "onReleased");
  const target = computed(() => unrefElement(options3.target) || window2);
  useEventListener(target, "mousedown", onPressed("mouse"), { passive: true, capture });
  useEventListener(window2, "mouseleave", onReleased, { passive: true, capture });
  useEventListener(window2, "mouseup", onReleased, { passive: true, capture });
  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), { passive: true, capture });
    useEventListener(window2, "drop", onReleased, { passive: true, capture });
    useEventListener(window2, "dragend", onReleased, { passive: true, capture });
  }
  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), { passive: true, capture });
    useEventListener(window2, "touchend", onReleased, { passive: true, capture });
    useEventListener(window2, "touchcancel", onReleased, { passive: true, capture });
  }
  return {
    pressed,
    sourceType
  };
}
__name(useMousePressed, "useMousePressed");
function useNavigatorLanguage(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported2 = useSupported(() => navigator2 && "language" in navigator2);
  const language = ref(navigator2 == null ? void 0 : navigator2.language);
  useEventListener(window2, "languagechange", () => {
    if (navigator2)
      language.value = navigator2.language;
  });
  return {
    isSupported: isSupported2,
    language
  };
}
__name(useNavigatorLanguage, "useNavigatorLanguage");
function useNetwork(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported2 = useSupported(() => navigator2 && "connection" in navigator2);
  const isOnline = ref(true);
  const saveData = ref(false);
  const offlineAt = ref(void 0);
  const onlineAt = ref(void 0);
  const downlink = ref(void 0);
  const downlinkMax = ref(void 0);
  const rtt = ref(void 0);
  const effectiveType = ref(void 0);
  const type = ref("unknown");
  const connection = isSupported2.value && navigator2.connection;
  function updateNetworkInformation() {
    if (!navigator2)
      return;
    isOnline.value = navigator2.onLine;
    offlineAt.value = isOnline.value ? void 0 : Date.now();
    onlineAt.value = isOnline.value ? Date.now() : void 0;
    if (connection) {
      downlink.value = connection.downlink;
      downlinkMax.value = connection.downlinkMax;
      effectiveType.value = connection.effectiveType;
      rtt.value = connection.rtt;
      saveData.value = connection.saveData;
      type.value = connection.type;
    }
  }
  __name(updateNetworkInformation, "updateNetworkInformation");
  if (window2) {
    useEventListener(window2, "offline", () => {
      isOnline.value = false;
      offlineAt.value = Date.now();
    });
    useEventListener(window2, "online", () => {
      isOnline.value = true;
      onlineAt.value = Date.now();
    });
  }
  if (connection)
    useEventListener(connection, "change", updateNetworkInformation, false);
  updateNetworkInformation();
  return {
    isSupported: isSupported2,
    isOnline,
    saveData,
    offlineAt,
    onlineAt,
    downlink,
    downlinkMax,
    effectiveType,
    rtt,
    type
  };
}
__name(useNetwork, "useNetwork");
function useNow(options3 = {}) {
  const {
    controls: exposeControls = false,
    interval = "requestAnimationFrame"
  } = options3;
  const now2 = ref(/* @__PURE__ */ new Date());
  const update = /* @__PURE__ */ __name(() => now2.value = /* @__PURE__ */ new Date(), "update");
  const controls = interval === "requestAnimationFrame" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });
  if (exposeControls) {
    return {
      now: now2,
      ...controls
    };
  } else {
    return now2;
  }
}
__name(useNow, "useNow");
function useObjectUrl(object) {
  const url = ref();
  const release = /* @__PURE__ */ __name(() => {
    if (url.value)
      URL.revokeObjectURL(url.value);
    url.value = void 0;
  }, "release");
  watch(
    () => toValue(object),
    (newObject) => {
      release();
      if (newObject)
        url.value = URL.createObjectURL(newObject);
    },
    { immediate: true }
  );
  tryOnScopeDispose(release);
  return readonly(url);
}
__name(useObjectUrl, "useObjectUrl");
function useClamp(value3, min, max) {
  if (typeof value3 === "function" || isReadonly(value3))
    return computed(() => clamp(toValue(value3), toValue(min), toValue(max)));
  const _value = ref(value3);
  return computed({
    get() {
      return _value.value = clamp(_value.value, toValue(min), toValue(max));
    },
    set(value22) {
      _value.value = clamp(value22, toValue(min), toValue(max));
    }
  });
}
__name(useClamp, "useClamp");
function useOffsetPagination(options3) {
  const {
    total = Number.POSITIVE_INFINITY,
    pageSize = 10,
    page = 1,
    onPageChange = noop$1,
    onPageSizeChange = noop$1,
    onPageCountChange = noop$1
  } = options3;
  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);
  const pageCount = computed(() => Math.max(
    1,
    Math.ceil(toValue(total) / toValue(currentPageSize))
  ));
  const currentPage = useClamp(page, 1, pageCount);
  const isFirstPage = computed(() => currentPage.value === 1);
  const isLastPage = computed(() => currentPage.value === pageCount.value);
  if (isRef(page)) {
    syncRef(page, currentPage, {
      direction: isReadonly(page) ? "ltr" : "both"
    });
  }
  if (isRef(pageSize)) {
    syncRef(pageSize, currentPageSize, {
      direction: isReadonly(pageSize) ? "ltr" : "both"
    });
  }
  function prev2() {
    currentPage.value--;
  }
  __name(prev2, "prev");
  function next2() {
    currentPage.value++;
  }
  __name(next2, "next");
  const returnValue = {
    currentPage,
    currentPageSize,
    pageCount,
    isFirstPage,
    isLastPage,
    prev: prev2,
    next: next2
  };
  watch(currentPage, () => {
    onPageChange(reactive(returnValue));
  });
  watch(currentPageSize, () => {
    onPageSizeChange(reactive(returnValue));
  });
  watch(pageCount, () => {
    onPageCountChange(reactive(returnValue));
  });
  return returnValue;
}
__name(useOffsetPagination, "useOffsetPagination");
function useOnline(options3 = {}) {
  const { isOnline } = useNetwork(options3);
  return isOnline;
}
__name(useOnline, "useOnline");
function usePageLeave(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  const isLeft = ref(false);
  const handler6 = /* @__PURE__ */ __name((event2) => {
    if (!window2)
      return;
    event2 = event2 || window2.event;
    const from = event2.relatedTarget || event2.toElement;
    isLeft.value = !from;
  }, "handler");
  if (window2) {
    useEventListener(window2, "mouseout", handler6, { passive: true });
    useEventListener(window2.document, "mouseleave", handler6, { passive: true });
    useEventListener(window2.document, "mouseenter", handler6, { passive: true });
  }
  return isLeft;
}
__name(usePageLeave, "usePageLeave");
function useScreenOrientation(options3 = {}) {
  const {
    window: window2 = defaultWindow
  } = options3;
  const isSupported2 = useSupported(() => window2 && "screen" in window2 && "orientation" in window2.screen);
  const screenOrientation = isSupported2.value ? window2.screen.orientation : {};
  const orientation2 = ref(screenOrientation.type);
  const angle = ref(screenOrientation.angle || 0);
  if (isSupported2.value) {
    useEventListener(window2, "orientationchange", () => {
      orientation2.value = screenOrientation.type;
      angle.value = screenOrientation.angle;
    });
  }
  const lockOrientation = /* @__PURE__ */ __name((type) => {
    if (isSupported2.value && typeof screenOrientation.lock === "function")
      return screenOrientation.lock(type);
    return Promise.reject(new Error("Not supported"));
  }, "lockOrientation");
  const unlockOrientation = /* @__PURE__ */ __name(() => {
    if (isSupported2.value && typeof screenOrientation.unlock === "function")
      screenOrientation.unlock();
  }, "unlockOrientation");
  return {
    isSupported: isSupported2,
    orientation: orientation2,
    angle,
    lockOrientation,
    unlockOrientation
  };
}
__name(useScreenOrientation, "useScreenOrientation");
function useParallax(target, options3 = {}) {
  const {
    deviceOrientationTiltAdjust = /* @__PURE__ */ __name((i2) => i2, "deviceOrientationTiltAdjust"),
    deviceOrientationRollAdjust = /* @__PURE__ */ __name((i2) => i2, "deviceOrientationRollAdjust"),
    mouseTiltAdjust = /* @__PURE__ */ __name((i2) => i2, "mouseTiltAdjust"),
    mouseRollAdjust = /* @__PURE__ */ __name((i2) => i2, "mouseRollAdjust"),
    window: window2 = defaultWindow
  } = options3;
  const orientation2 = reactive(useDeviceOrientation({ window: window2 }));
  const screenOrientation = reactive(useScreenOrientation({ window: window2 }));
  const {
    elementX: x2,
    elementY: y2,
    elementWidth: width2,
    elementHeight: height
  } = useMouseInElement(target, { handleOutside: false, window: window2 });
  const source = computed(() => {
    if (orientation2.isSupported && (orientation2.alpha != null && orientation2.alpha !== 0 || orientation2.gamma != null && orientation2.gamma !== 0)) {
      return "deviceOrientation";
    }
    return "mouse";
  });
  const roll = computed(() => {
    if (source.value === "deviceOrientation") {
      let value3;
      switch (screenOrientation.orientation) {
        case "landscape-primary":
          value3 = orientation2.gamma / 90;
          break;
        case "landscape-secondary":
          value3 = -orientation2.gamma / 90;
          break;
        case "portrait-primary":
          value3 = -orientation2.beta / 90;
          break;
        case "portrait-secondary":
          value3 = orientation2.beta / 90;
          break;
        default:
          value3 = -orientation2.beta / 90;
      }
      return deviceOrientationRollAdjust(value3);
    } else {
      const value3 = -(y2.value - height.value / 2) / height.value;
      return mouseRollAdjust(value3);
    }
  });
  const tilt = computed(() => {
    if (source.value === "deviceOrientation") {
      let value3;
      switch (screenOrientation.orientation) {
        case "landscape-primary":
          value3 = orientation2.beta / 90;
          break;
        case "landscape-secondary":
          value3 = -orientation2.beta / 90;
          break;
        case "portrait-primary":
          value3 = orientation2.gamma / 90;
          break;
        case "portrait-secondary":
          value3 = -orientation2.gamma / 90;
          break;
        default:
          value3 = orientation2.gamma / 90;
      }
      return deviceOrientationTiltAdjust(value3);
    } else {
      const value3 = (x2.value - width2.value / 2) / width2.value;
      return mouseTiltAdjust(value3);
    }
  });
  return { roll, tilt, source };
}
__name(useParallax, "useParallax");
function useParentElement(element = useCurrentElement()) {
  const parentElement = shallowRef();
  const update = /* @__PURE__ */ __name(() => {
    const el = unrefElement(element);
    if (el)
      parentElement.value = el.parentElement;
  }, "update");
  tryOnMounted(update);
  watch(() => toValue(element), update);
  return parentElement;
}
__name(useParentElement, "useParentElement");
function usePerformanceObserver(options3, callback) {
  const {
    window: window2 = defaultWindow,
    immediate = true,
    ...performanceOptions
  } = options3;
  const isSupported2 = useSupported(() => window2 && "PerformanceObserver" in window2);
  let observer;
  const stop2 = /* @__PURE__ */ __name(() => {
    observer == null ? void 0 : observer.disconnect();
  }, "stop");
  const start2 = /* @__PURE__ */ __name(() => {
    if (isSupported2.value) {
      stop2();
      observer = new PerformanceObserver(callback);
      observer.observe(performanceOptions);
    }
  }, "start");
  tryOnScopeDispose(stop2);
  if (immediate)
    start2();
  return {
    isSupported: isSupported2,
    start: start2,
    stop: stop2
  };
}
__name(usePerformanceObserver, "usePerformanceObserver");
const defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
const keys = /* @__PURE__ */ Object.keys(defaultState);
function usePointer(options3 = {}) {
  const {
    target = defaultWindow
  } = options3;
  const isInside = ref(false);
  const state = ref(options3.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler6 = /* @__PURE__ */ __name((event2) => {
    isInside.value = true;
    if (options3.pointerTypes && !options3.pointerTypes.includes(event2.pointerType))
      return;
    state.value = objectPick(event2, keys, false);
  }, "handler");
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler6, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs(state),
    isInside
  };
}
__name(usePointer, "usePointer");
function usePointerLock(target, options3 = {}) {
  const { document: document2 = defaultDocument } = options3;
  const isSupported2 = useSupported(() => document2 && "pointerLockElement" in document2);
  const element = ref();
  const triggerElement = ref();
  let targetElement;
  if (isSupported2.value) {
    useEventListener(document2, "pointerlockchange", () => {
      var _a;
      const currentElement = (_a = document2.pointerLockElement) != null ? _a : element.value;
      if (targetElement && currentElement === targetElement) {
        element.value = document2.pointerLockElement;
        if (!element.value)
          targetElement = triggerElement.value = null;
      }
    });
    useEventListener(document2, "pointerlockerror", () => {
      var _a;
      const currentElement = (_a = document2.pointerLockElement) != null ? _a : element.value;
      if (targetElement && currentElement === targetElement) {
        const action = document2.pointerLockElement ? "release" : "acquire";
        throw new Error(`Failed to ${action} pointer lock.`);
      }
    });
  }
  async function lock(e) {
    var _a;
    if (!isSupported2.value)
      throw new Error("Pointer Lock API is not supported by your browser.");
    triggerElement.value = e instanceof Event ? e.currentTarget : null;
    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);
    if (!targetElement)
      throw new Error("Target element undefined.");
    targetElement.requestPointerLock();
    return await until(element).toBe(targetElement);
  }
  __name(lock, "lock");
  async function unlock() {
    if (!element.value)
      return false;
    document2.exitPointerLock();
    await until(element).toBeNull();
    return true;
  }
  __name(unlock, "unlock");
  return {
    isSupported: isSupported2,
    element,
    triggerElement,
    lock,
    unlock
  };
}
__name(usePointerLock, "usePointerLock");
function usePointerSwipe(target, options3 = {}) {
  const targetRef = toRef(target);
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    disableTextSelect = false
  } = options3;
  const posStart = reactive({ x: 0, y: 0 });
  const updatePosStart = /* @__PURE__ */ __name((x2, y2) => {
    posStart.x = x2;
    posStart.y = y2;
  }, "updatePosStart");
  const posEnd = reactive({ x: 0, y: 0 });
  const updatePosEnd = /* @__PURE__ */ __name((x2, y2) => {
    posEnd.x = x2;
    posEnd.y = y2;
  }, "updatePosEnd");
  const distanceX = computed(() => posStart.x - posEnd.x);
  const distanceY = computed(() => posStart.y - posEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);
  const isSwiping = ref(false);
  const isPointerDown = ref(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(distanceX.value) > abs(distanceY.value)) {
      return distanceX.value > 0 ? "left" : "right";
    } else {
      return distanceY.value > 0 ? "up" : "down";
    }
  });
  const eventIsAllowed = /* @__PURE__ */ __name((e) => {
    var _a, _b, _c;
    const isReleasingButton = e.buttons === 0;
    const isPrimaryButton = e.buttons === 1;
    return (_c = (_b = (_a = options3.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;
  }, "eventIsAllowed");
  const stops = [
    useEventListener(target, "pointerdown", (e) => {
      if (!eventIsAllowed(e))
        return;
      isPointerDown.value = true;
      const eventTarget = e.target;
      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);
      const { clientX: x2, clientY: y2 } = e;
      updatePosStart(x2, y2);
      updatePosEnd(x2, y2);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }),
    useEventListener(target, "pointermove", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (!isPointerDown.value)
        return;
      const { clientX: x2, clientY: y2 } = e;
      updatePosEnd(x2, y2);
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }),
    useEventListener(target, "pointerup", (e) => {
      if (!eventIsAllowed(e))
        return;
      if (isSwiping.value)
        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
      isPointerDown.value = false;
      isSwiping.value = false;
    })
  ];
  tryOnMounted(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty("touch-action", "none");
    if (disableTextSelect) {
      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty("-webkit-user-select", "none");
      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty("-ms-user-select", "none");
      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty("user-select", "none");
    }
  });
  const stop2 = /* @__PURE__ */ __name(() => stops.forEach((s) => s()), "stop");
  return {
    isSwiping: readonly(isSwiping),
    direction: readonly(direction),
    posStart: readonly(posStart),
    posEnd: readonly(posEnd),
    distanceX,
    distanceY,
    stop: stop2
  };
}
__name(usePointerSwipe, "usePointerSwipe");
function usePreferredColorScheme(options3) {
  const isLight = useMediaQuery("(prefers-color-scheme: light)", options3);
  const isDark = useMediaQuery("(prefers-color-scheme: dark)", options3);
  return computed(() => {
    if (isDark.value)
      return "dark";
    if (isLight.value)
      return "light";
    return "no-preference";
  });
}
__name(usePreferredColorScheme, "usePreferredColorScheme");
function usePreferredContrast(options3) {
  const isMore = useMediaQuery("(prefers-contrast: more)", options3);
  const isLess = useMediaQuery("(prefers-contrast: less)", options3);
  const isCustom = useMediaQuery("(prefers-contrast: custom)", options3);
  return computed(() => {
    if (isMore.value)
      return "more";
    if (isLess.value)
      return "less";
    if (isCustom.value)
      return "custom";
    return "no-preference";
  });
}
__name(usePreferredContrast, "usePreferredContrast");
function usePreferredLanguages(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  if (!window2)
    return ref(["en"]);
  const navigator2 = window2.navigator;
  const value3 = ref(navigator2.languages);
  useEventListener(window2, "languagechange", () => {
    value3.value = navigator2.languages;
  });
  return value3;
}
__name(usePreferredLanguages, "usePreferredLanguages");
function usePreferredReducedMotion(options3) {
  const isReduced = useMediaQuery("(prefers-reduced-motion: reduce)", options3);
  return computed(() => {
    if (isReduced.value)
      return "reduce";
    return "no-preference";
  });
}
__name(usePreferredReducedMotion, "usePreferredReducedMotion");
function usePrevious(value3, initialValue) {
  const previous = shallowRef(initialValue);
  watch(
    toRef(value3),
    (_2, oldValue) => {
      previous.value = oldValue;
    },
    { flush: "sync" }
  );
  return readonly(previous);
}
__name(usePrevious, "usePrevious");
const topVarName = "--vueuse-safe-area-top";
const rightVarName = "--vueuse-safe-area-right";
const bottomVarName = "--vueuse-safe-area-bottom";
const leftVarName = "--vueuse-safe-area-left";
function useScreenSafeArea() {
  const top = ref("");
  const right = ref("");
  const bottom = ref("");
  const left = ref("");
  if (isClient) {
    const topCssVar = useCssVar(topVarName);
    const rightCssVar = useCssVar(rightVarName);
    const bottomCssVar = useCssVar(bottomVarName);
    const leftCssVar = useCssVar(leftVarName);
    topCssVar.value = "env(safe-area-inset-top, 0px)";
    rightCssVar.value = "env(safe-area-inset-right, 0px)";
    bottomCssVar.value = "env(safe-area-inset-bottom, 0px)";
    leftCssVar.value = "env(safe-area-inset-left, 0px)";
    update();
    useEventListener("resize", useDebounceFn(update));
  }
  function update() {
    top.value = getValue(topVarName);
    right.value = getValue(rightVarName);
    bottom.value = getValue(bottomVarName);
    left.value = getValue(leftVarName);
  }
  __name(update, "update");
  return {
    top,
    right,
    bottom,
    left,
    update
  };
}
__name(useScreenSafeArea, "useScreenSafeArea");
function getValue(position2) {
  return getComputedStyle(document.documentElement).getPropertyValue(position2);
}
__name(getValue, "getValue");
function useScriptTag(src, onLoaded = noop$1, options3 = {}) {
  const {
    immediate = true,
    manual = false,
    type = "text/javascript",
    async = true,
    crossOrigin,
    referrerPolicy,
    noModule,
    defer,
    document: document2 = defaultDocument,
    attrs: attrs3 = {}
  } = options3;
  const scriptTag = ref(null);
  let _promise = null;
  const loadScript = /* @__PURE__ */ __name((waitForScriptLoad) => new Promise((resolve2, reject2) => {
    const resolveWithElement = /* @__PURE__ */ __name((el2) => {
      scriptTag.value = el2;
      resolve2(el2);
      return el2;
    }, "resolveWithElement");
    if (!document2) {
      resolve2(false);
      return;
    }
    let shouldAppend = false;
    let el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (!el) {
      el = document2.createElement("script");
      el.type = type;
      el.async = async;
      el.src = toValue(src);
      if (defer)
        el.defer = defer;
      if (crossOrigin)
        el.crossOrigin = crossOrigin;
      if (noModule)
        el.noModule = noModule;
      if (referrerPolicy)
        el.referrerPolicy = referrerPolicy;
      Object.entries(attrs3).forEach(([name, value3]) => el == null ? void 0 : el.setAttribute(name, value3));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    el.addEventListener("error", (event2) => reject2(event2));
    el.addEventListener("abort", (event2) => reject2(event2));
    el.addEventListener("load", () => {
      el.setAttribute("data-loaded", "true");
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend)
      el = document2.head.appendChild(el);
    if (!waitForScriptLoad)
      resolveWithElement(el);
  }), "loadScript");
  const load2 = /* @__PURE__ */ __name((waitForScriptLoad = true) => {
    if (!_promise)
      _promise = loadScript(waitForScriptLoad);
    return _promise;
  }, "load");
  const unload = /* @__PURE__ */ __name(() => {
    if (!document2)
      return;
    _promise = null;
    if (scriptTag.value)
      scriptTag.value = null;
    const el = document2.querySelector(`script[src="${toValue(src)}"]`);
    if (el)
      document2.head.removeChild(el);
  }, "unload");
  if (immediate && !manual)
    tryOnMounted(load2);
  if (!manual)
    tryOnUnmounted(unload);
  return { scriptTag, load: load2, unload };
}
__name(useScriptTag, "useScriptTag");
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
__name(checkOverflowScroll, "checkOverflowScroll");
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault)
    e.preventDefault();
  return false;
}
__name(preventDefault, "preventDefault");
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element, initialState = false) {
  const isLocked = ref(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow = "";
  watch(toRef(element), (el) => {
    const target = resolveElement(toValue(el));
    if (target) {
      const ele = target;
      if (!elInitialOverflow.get(ele))
        elInitialOverflow.set(ele, ele.style.overflow);
      if (ele.style.overflow !== "hidden")
        initialOverflow = ele.style.overflow;
      if (ele.style.overflow === "hidden")
        return isLocked.value = true;
      if (isLocked.value)
        return ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const lock = /* @__PURE__ */ __name(() => {
    const el = resolveElement(toValue(element));
    if (!el || isLocked.value)
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        el,
        "touchmove",
        (e) => {
          preventDefault(e);
        },
        { passive: false }
      );
    }
    el.style.overflow = "hidden";
    isLocked.value = true;
  }, "lock");
  const unlock = /* @__PURE__ */ __name(() => {
    const el = resolveElement(toValue(element));
    if (!el || !isLocked.value)
      return;
    if (isIOS)
      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
    el.style.overflow = initialOverflow;
    elInitialOverflow.delete(el);
    isLocked.value = false;
  }, "unlock");
  tryOnScopeDispose(unlock);
  return computed({
    get() {
      return isLocked.value;
    },
    set(v2) {
      if (v2)
        lock();
      else unlock();
    }
  });
}
__name(useScrollLock, "useScrollLock");
function useSessionStorage(key, initialValue, options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.sessionStorage, options3);
}
__name(useSessionStorage, "useSessionStorage");
function useShare(shareOptions = {}, options3 = {}) {
  const { navigator: navigator2 = defaultNavigator } = options3;
  const _navigator2 = navigator2;
  const isSupported2 = useSupported(() => _navigator2 && "canShare" in _navigator2);
  const share = /* @__PURE__ */ __name(async (overrideOptions = {}) => {
    if (isSupported2.value) {
      const data22 = {
        ...toValue(shareOptions),
        ...toValue(overrideOptions)
      };
      let granted = true;
      if (data22.files && _navigator2.canShare)
        granted = _navigator2.canShare({ files: data22.files });
      if (granted)
        return _navigator2.share(data22);
    }
  }, "share");
  return {
    isSupported: isSupported2,
    share
  };
}
__name(useShare, "useShare");
const defaultSortFn = /* @__PURE__ */ __name((source, compareFn) => source.sort(compareFn), "defaultSortFn");
const defaultCompare = /* @__PURE__ */ __name((a, b) => a - b, "defaultCompare");
function useSorted(...args) {
  var _a, _b, _c, _d;
  const [source] = args;
  let compareFn = defaultCompare;
  let options3 = {};
  if (args.length === 2) {
    if (typeof args[1] === "object") {
      options3 = args[1];
      compareFn = (_a = options3.compareFn) != null ? _a : defaultCompare;
    } else {
      compareFn = (_b = args[1]) != null ? _b : defaultCompare;
    }
  } else if (args.length > 2) {
    compareFn = (_c = args[1]) != null ? _c : defaultCompare;
    options3 = (_d = args[2]) != null ? _d : {};
  }
  const {
    dirty = false,
    sortFn = defaultSortFn
  } = options3;
  if (!dirty)
    return computed(() => sortFn([...toValue(source)], compareFn));
  watchEffect(() => {
    const result = sortFn(toValue(source), compareFn);
    if (isRef(source))
      source.value = result;
    else
      source.splice(0, source.length, ...result);
  });
  return source;
}
__name(useSorted, "useSorted");
function useSpeechRecognition(options3 = {}) {
  const {
    interimResults = true,
    continuous = true,
    maxAlternatives = 1,
    window: window2 = defaultWindow
  } = options3;
  const lang = toRef(options3.lang || "en-US");
  const isListening = ref(false);
  const isFinal = ref(false);
  const result = ref("");
  const error = shallowRef(void 0);
  const toggle4 = /* @__PURE__ */ __name((value3 = !isListening.value) => {
    isListening.value = value3;
  }, "toggle");
  const start2 = /* @__PURE__ */ __name(() => {
    isListening.value = true;
  }, "start");
  const stop2 = /* @__PURE__ */ __name(() => {
    isListening.value = false;
  }, "stop");
  const SpeechRecognition = window2 && (window2.SpeechRecognition || window2.webkitSpeechRecognition);
  const isSupported2 = useSupported(() => SpeechRecognition);
  let recognition;
  if (isSupported2.value) {
    recognition = new SpeechRecognition();
    recognition.continuous = continuous;
    recognition.interimResults = interimResults;
    recognition.lang = toValue(lang);
    recognition.maxAlternatives = maxAlternatives;
    recognition.onstart = () => {
      isFinal.value = false;
    };
    watch(lang, (lang2) => {
      if (recognition && !isListening.value)
        recognition.lang = lang2;
    });
    recognition.onresult = (event2) => {
      const currentResult = event2.results[event2.resultIndex];
      const { transcript } = currentResult[0];
      isFinal.value = currentResult.isFinal;
      result.value = transcript;
      error.value = void 0;
    };
    recognition.onerror = (event2) => {
      error.value = event2;
    };
    recognition.onend = () => {
      isListening.value = false;
      recognition.lang = toValue(lang);
    };
    watch(isListening, () => {
      if (isListening.value)
        recognition.start();
      else
        recognition.stop();
    });
  }
  tryOnScopeDispose(() => {
    isListening.value = false;
  });
  return {
    isSupported: isSupported2,
    isListening,
    isFinal,
    recognition,
    result,
    error,
    toggle: toggle4,
    start: start2,
    stop: stop2
  };
}
__name(useSpeechRecognition, "useSpeechRecognition");
function useSpeechSynthesis(text, options3 = {}) {
  const {
    pitch = 1,
    rate = 1,
    volume = 1,
    window: window2 = defaultWindow
  } = options3;
  const synth = window2 && window2.speechSynthesis;
  const isSupported2 = useSupported(() => synth);
  const isPlaying = ref(false);
  const status = ref("init");
  const spokenText = toRef(text || "");
  const lang = toRef(options3.lang || "en-US");
  const error = shallowRef(void 0);
  const toggle4 = /* @__PURE__ */ __name((value3 = !isPlaying.value) => {
    isPlaying.value = value3;
  }, "toggle");
  const bindEventsForUtterance = /* @__PURE__ */ __name((utterance2) => {
    utterance2.lang = toValue(lang);
    utterance2.voice = toValue(options3.voice) || null;
    utterance2.pitch = toValue(pitch);
    utterance2.rate = toValue(rate);
    utterance2.volume = volume;
    utterance2.onstart = () => {
      isPlaying.value = true;
      status.value = "play";
    };
    utterance2.onpause = () => {
      isPlaying.value = false;
      status.value = "pause";
    };
    utterance2.onresume = () => {
      isPlaying.value = true;
      status.value = "play";
    };
    utterance2.onend = () => {
      isPlaying.value = false;
      status.value = "end";
    };
    utterance2.onerror = (event2) => {
      error.value = event2;
    };
  }, "bindEventsForUtterance");
  const utterance = computed(() => {
    isPlaying.value = false;
    status.value = "init";
    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
    bindEventsForUtterance(newUtterance);
    return newUtterance;
  });
  const speak = /* @__PURE__ */ __name(() => {
    synth.cancel();
    if (utterance)
      synth.speak(utterance.value);
  }, "speak");
  const stop2 = /* @__PURE__ */ __name(() => {
    synth.cancel();
    isPlaying.value = false;
  }, "stop");
  if (isSupported2.value) {
    bindEventsForUtterance(utterance.value);
    watch(lang, (lang2) => {
      if (utterance.value && !isPlaying.value)
        utterance.value.lang = lang2;
    });
    if (options3.voice) {
      watch(options3.voice, () => {
        synth.cancel();
      });
    }
    watch(isPlaying, () => {
      if (isPlaying.value)
        synth.resume();
      else
        synth.pause();
    });
  }
  tryOnScopeDispose(() => {
    isPlaying.value = false;
  });
  return {
    isSupported: isSupported2,
    isPlaying,
    status,
    utterance,
    error,
    stop: stop2,
    toggle: toggle4,
    speak
  };
}
__name(useSpeechSynthesis, "useSpeechSynthesis");
function useStepper(steps, initialStep) {
  const stepsRef = ref(steps);
  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));
  const index2 = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));
  const current = computed(() => at(index2.value));
  const isFirst = computed(() => index2.value === 0);
  const isLast = computed(() => index2.value === stepNames.value.length - 1);
  const next2 = computed(() => stepNames.value[index2.value + 1]);
  const previous = computed(() => stepNames.value[index2.value - 1]);
  function at(index22) {
    if (Array.isArray(stepsRef.value))
      return stepsRef.value[index22];
    return stepsRef.value[stepNames.value[index22]];
  }
  __name(at, "at");
  function get2(step2) {
    if (!stepNames.value.includes(step2))
      return;
    return at(stepNames.value.indexOf(step2));
  }
  __name(get2, "get");
  function goTo(step2) {
    if (stepNames.value.includes(step2))
      index2.value = stepNames.value.indexOf(step2);
  }
  __name(goTo, "goTo");
  function goToNext() {
    if (isLast.value)
      return;
    index2.value++;
  }
  __name(goToNext, "goToNext");
  function goToPrevious() {
    if (isFirst.value)
      return;
    index2.value--;
  }
  __name(goToPrevious, "goToPrevious");
  function goBackTo(step2) {
    if (isAfter(step2))
      goTo(step2);
  }
  __name(goBackTo, "goBackTo");
  function isNext(step2) {
    return stepNames.value.indexOf(step2) === index2.value + 1;
  }
  __name(isNext, "isNext");
  function isPrevious(step2) {
    return stepNames.value.indexOf(step2) === index2.value - 1;
  }
  __name(isPrevious, "isPrevious");
  function isCurrent(step2) {
    return stepNames.value.indexOf(step2) === index2.value;
  }
  __name(isCurrent, "isCurrent");
  function isBefore(step2) {
    return index2.value < stepNames.value.indexOf(step2);
  }
  __name(isBefore, "isBefore");
  function isAfter(step2) {
    return index2.value > stepNames.value.indexOf(step2);
  }
  __name(isAfter, "isAfter");
  return {
    steps: stepsRef,
    stepNames,
    index: index2,
    current,
    next: next2,
    previous,
    isFirst,
    isLast,
    at,
    get: get2,
    goTo,
    goToNext,
    goToPrevious,
    goBackTo,
    isNext,
    isPrevious,
    isCurrent,
    isBefore,
    isAfter
  };
}
__name(useStepper, "useStepper");
function useStorageAsync(key, initialValue, storage, options3 = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults: mergeDefaults2 = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = /* @__PURE__ */ __name((e) => {
      console.error(e);
    }, "onError")
  } = options3;
  const rawInit = toValue(initialValue);
  const type = guessSerializerType(rawInit);
  const data22 = (shallow ? shallowRef : ref)(initialValue);
  const serializer = (_a = options3.serializer) != null ? _a : StorageSerializers[type];
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorageAsync", () => {
        var _a2;
        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  async function read(event2) {
    if (!storage || event2 && event2.key !== key)
      return;
    try {
      const rawValue = event2 ? event2.newValue : await storage.getItem(key);
      if (rawValue == null) {
        data22.value = rawInit;
        if (writeDefaults && rawInit !== null)
          await storage.setItem(key, await serializer.write(rawInit));
      } else if (mergeDefaults2) {
        const value3 = await serializer.read(rawValue);
        if (typeof mergeDefaults2 === "function")
          data22.value = mergeDefaults2(value3, rawInit);
        else if (type === "object" && !Array.isArray(value3))
          data22.value = { ...rawInit, ...value3 };
        else data22.value = value3;
      } else {
        data22.value = await serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    }
  }
  __name(read, "read");
  read();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e) => Promise.resolve().then(() => read(e)));
  if (storage) {
    watchWithFilter(
      data22,
      async () => {
        try {
          if (data22.value == null)
            await storage.removeItem(key);
          else
            await storage.setItem(key, await serializer.write(data22.value));
        } catch (e) {
          onError(e);
        }
      },
      {
        flush,
        deep,
        eventFilter
      }
    );
  }
  return data22;
}
__name(useStorageAsync, "useStorageAsync");
let _id = 0;
function useStyleTag(css3, options3 = {}) {
  const isLoaded = ref(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id: id3 = `vueuse_styletag_${++_id}`
  } = options3;
  const cssRef = ref(css3);
  let stop2 = /* @__PURE__ */ __name(() => {
  }, "stop");
  const load2 = /* @__PURE__ */ __name(() => {
    if (!document2)
      return;
    const el = document2.getElementById(id3) || document2.createElement("style");
    if (!el.isConnected) {
      el.id = id3;
      if (options3.media)
        el.media = options3.media;
      document2.head.appendChild(el);
    }
    if (isLoaded.value)
      return;
    stop2 = watch(
      cssRef,
      (value3) => {
        el.textContent = value3;
      },
      { immediate: true }
    );
    isLoaded.value = true;
  }, "load");
  const unload = /* @__PURE__ */ __name(() => {
    if (!document2 || !isLoaded.value)
      return;
    stop2();
    document2.head.removeChild(document2.getElementById(id3));
    isLoaded.value = false;
  }, "unload");
  if (immediate && !manual)
    tryOnMounted(load2);
  if (!manual)
    tryOnScopeDispose(unload);
  return {
    id: id3,
    css: cssRef,
    unload,
    load: load2,
    isLoaded: readonly(isLoaded)
  };
}
__name(useStyleTag, "useStyleTag");
function useSwipe(target, options3 = {}) {
  const {
    threshold = 50,
    onSwipe,
    onSwipeEnd,
    onSwipeStart,
    passive = true,
    window: window2 = defaultWindow
  } = options3;
  const coordsStart = reactive({ x: 0, y: 0 });
  const coordsEnd = reactive({ x: 0, y: 0 });
  const diffX = computed(() => coordsStart.x - coordsEnd.x);
  const diffY = computed(() => coordsStart.y - coordsEnd.y);
  const { max, abs } = Math;
  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);
  const isSwiping = ref(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value)
      return "none";
    if (abs(diffX.value) > abs(diffY.value)) {
      return diffX.value > 0 ? "left" : "right";
    } else {
      return diffY.value > 0 ? "up" : "down";
    }
  });
  const getTouchEventCoords = /* @__PURE__ */ __name((e) => [e.touches[0].clientX, e.touches[0].clientY], "getTouchEventCoords");
  const updateCoordsStart = /* @__PURE__ */ __name((x2, y2) => {
    coordsStart.x = x2;
    coordsStart.y = y2;
  }, "updateCoordsStart");
  const updateCoordsEnd = /* @__PURE__ */ __name((x2, y2) => {
    coordsEnd.x = x2;
    coordsEnd.y = y2;
  }, "updateCoordsEnd");
  let listenerOptions;
  const isPassiveEventSupported = checkPassiveEventSupport(window2 == null ? void 0 : window2.document);
  if (!passive)
    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };
  else
    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };
  const onTouchEnd3 = /* @__PURE__ */ __name((e) => {
    if (isSwiping.value)
      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
    isSwiping.value = false;
  }, "onTouchEnd");
  const stops = [
    useEventListener(target, "touchstart", (e) => {
      if (e.touches.length !== 1)
        return;
      if (listenerOptions.capture && !listenerOptions.passive)
        e.preventDefault();
      const [x2, y2] = getTouchEventCoords(e);
      updateCoordsStart(x2, y2);
      updateCoordsEnd(x2, y2);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions),
    useEventListener(target, "touchmove", (e) => {
      if (e.touches.length !== 1)
        return;
      const [x2, y2] = getTouchEventCoords(e);
      updateCoordsEnd(x2, y2);
      if (!isSwiping.value && isThresholdExceeded.value)
        isSwiping.value = true;
      if (isSwiping.value)
        onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions),
    useEventListener(target, ["touchend", "touchcancel"], onTouchEnd3, listenerOptions)
  ];
  const stop2 = /* @__PURE__ */ __name(() => stops.forEach((s) => s()), "stop");
  return {
    isPassiveEventSupported,
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop: stop2
  };
}
__name(useSwipe, "useSwipe");
function checkPassiveEventSupport(document2) {
  if (!document2)
    return false;
  let supportsPassive = false;
  const optionsBlock = {
    get passive() {
      supportsPassive = true;
      return false;
    }
  };
  document2.addEventListener("x", noop$1, optionsBlock);
  document2.removeEventListener("x", noop$1);
  return supportsPassive;
}
__name(checkPassiveEventSupport, "checkPassiveEventSupport");
function useTemplateRefsList() {
  const refs = ref([]);
  refs.value.set = (el) => {
    if (el)
      refs.value.push(el);
  };
  onBeforeUpdate(() => {
    refs.value.length = 0;
  });
  return refs;
}
__name(useTemplateRefsList, "useTemplateRefsList");
function useTextDirection(options3 = {}) {
  const {
    document: document2 = defaultDocument,
    selector = "html",
    observe = false,
    initialValue = "ltr"
  } = options3;
  function getValue2() {
    var _a, _b;
    return (_b = (_a = document2 == null ? void 0 : document2.querySelector(selector)) == null ? void 0 : _a.getAttribute("dir")) != null ? _b : initialValue;
  }
  __name(getValue2, "getValue2");
  const dir = ref(getValue2());
  tryOnMounted(() => dir.value = getValue2());
  if (observe && document2) {
    useMutationObserver(
      document2.querySelector(selector),
      () => dir.value = getValue2(),
      { attributes: true }
    );
  }
  return computed({
    get() {
      return dir.value;
    },
    set(v2) {
      var _a, _b;
      dir.value = v2;
      if (!document2)
        return;
      if (dir.value)
        (_a = document2.querySelector(selector)) == null ? void 0 : _a.setAttribute("dir", dir.value);
      else
        (_b = document2.querySelector(selector)) == null ? void 0 : _b.removeAttribute("dir");
    }
  });
}
__name(useTextDirection, "useTextDirection");
function getRangesFromSelection(selection) {
  var _a;
  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;
  return Array.from({ length: rangeCount }, (_2, i2) => selection.getRangeAt(i2));
}
__name(getRangesFromSelection, "getRangesFromSelection");
function useTextSelection(options3 = {}) {
  const {
    window: window2 = defaultWindow
  } = options3;
  const selection = ref(null);
  const text = computed(() => {
    var _a, _b;
    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : "";
  });
  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);
  const rects = computed(() => ranges.value.map((range2) => range2.getBoundingClientRect()));
  function onSelectionChange() {
    selection.value = null;
    if (window2)
      selection.value = window2.getSelection();
  }
  __name(onSelectionChange, "onSelectionChange");
  if (window2)
    useEventListener(window2.document, "selectionchange", onSelectionChange);
  return {
    text,
    rects,
    ranges,
    selection
  };
}
__name(useTextSelection, "useTextSelection");
function useTextareaAutosize(options3) {
  var _a;
  const textarea = ref(options3 == null ? void 0 : options3.element);
  const input = ref(options3 == null ? void 0 : options3.input);
  const styleProp = (_a = options3 == null ? void 0 : options3.styleProp) != null ? _a : "height";
  const textareaScrollHeight = ref(1);
  const textareaOldWidth = ref(0);
  function triggerResize() {
    var _a2;
    if (!textarea.value)
      return;
    let height = "";
    textarea.value.style[styleProp] = "1px";
    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;
    const _styleTarget = toValue(options3 == null ? void 0 : options3.styleTarget);
    if (_styleTarget)
      _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;
    else
      height = `${textareaScrollHeight.value}px`;
    textarea.value.style[styleProp] = height;
  }
  __name(triggerResize, "triggerResize");
  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });
  watch(textareaScrollHeight, () => {
    var _a2;
    return (_a2 = options3 == null ? void 0 : options3.onResize) == null ? void 0 : _a2.call(options3);
  });
  useResizeObserver(textarea, ([{ contentRect }]) => {
    if (textareaOldWidth.value === contentRect.width)
      return;
    textareaOldWidth.value = contentRect.width;
    triggerResize();
  });
  if (options3 == null ? void 0 : options3.watch)
    watch(options3.watch, triggerResize, { immediate: true, deep: true });
  return {
    textarea,
    input,
    triggerResize
  };
}
__name(useTextareaAutosize, "useTextareaAutosize");
function useThrottledRefHistory(source, options3 = {}) {
  const { throttle: throttle2 = 200, trailing = true } = options3;
  const filter4 = throttleFilter(throttle2, trailing);
  const history2 = useRefHistory(source, { ...options3, eventFilter: filter4 });
  return {
    ...history2
  };
}
__name(useThrottledRefHistory, "useThrottledRefHistory");
const DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: /* @__PURE__ */ __name((n) => n.match(/\d/) ? `${n} ago` : n, "past"),
  future: /* @__PURE__ */ __name((n) => n.match(/\d/) ? `in ${n}` : n, "future"),
  month: /* @__PURE__ */ __name((n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`, "month"),
  year: /* @__PURE__ */ __name((n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`, "year"),
  day: /* @__PURE__ */ __name((n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`, "day"),
  week: /* @__PURE__ */ __name((n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`, "week"),
  hour: /* @__PURE__ */ __name((n) => `${n} hour${n > 1 ? "s" : ""}`, "hour"),
  minute: /* @__PURE__ */ __name((n) => `${n} minute${n > 1 ? "s" : ""}`, "minute"),
  second: /* @__PURE__ */ __name((n) => `${n} second${n > 1 ? "s" : ""}`, "second"),
  invalid: ""
};
function DEFAULT_FORMATTER(date) {
  return date.toISOString().slice(0, 10);
}
__name(DEFAULT_FORMATTER, "DEFAULT_FORMATTER");
function useTimeAgo(time, options3 = {}) {
  const {
    controls: exposeControls = false,
    updateInterval = 3e4
  } = options3;
  const { now: now2, ...controls } = useNow({ interval: updateInterval, controls: true });
  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options3, toValue(now2)));
  if (exposeControls) {
    return {
      timeAgo,
      ...controls
    };
  } else {
    return timeAgo;
  }
}
__name(useTimeAgo, "useTimeAgo");
function formatTimeAgo(from, options3 = {}, now2 = Date.now()) {
  var _a;
  const {
    max,
    messages: messages2 = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER,
    units = DEFAULT_UNITS,
    showSecond = false,
    rounding = "round"
  } = options3;
  const roundFn = typeof rounding === "number" ? (n) => +n.toFixed(rounding) : Math[rounding];
  const diff2 = +now2 - +from;
  const absDiff = Math.abs(diff2);
  function getValue2(diff22, unit) {
    return roundFn(Math.abs(diff22) / unit.value);
  }
  __name(getValue2, "getValue2");
  function format2(diff22, unit) {
    const val = getValue2(diff22, unit);
    const past = diff22 > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }
  __name(format2, "format");
  function applyFormat(name, val, isPast) {
    const formatter = messages2[name];
    if (typeof formatter === "function")
      return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }
  __name(applyFormat, "applyFormat");
  if (absDiff < 6e4 && !showSecond)
    return messages2.justNow;
  if (typeof max === "number" && absDiff > max)
    return fullDateFormatter(new Date(from));
  if (typeof max === "string") {
    const unitMax = (_a = units.find((i2) => i2.name === max)) == null ? void 0 : _a.max;
    if (unitMax && absDiff > unitMax)
      return fullDateFormatter(new Date(from));
  }
  for (const [idx, unit] of units.entries()) {
    const val = getValue2(diff2, unit);
    if (val <= 0 && units[idx - 1])
      return format2(diff2, units[idx - 1]);
    if (absDiff < unit.max)
      return format2(diff2, unit);
  }
  return messages2.invalid;
}
__name(formatTimeAgo, "formatTimeAgo");
function useTimeoutPoll(fn, interval, timeoutPollOptions) {
  const { start: start2 } = useTimeoutFn(loop, interval, { immediate: false });
  const isActive = ref(false);
  async function loop() {
    if (!isActive.value)
      return;
    await fn();
    start2();
  }
  __name(loop, "loop");
  function resume() {
    if (!isActive.value) {
      isActive.value = true;
      loop();
    }
  }
  __name(resume, "resume");
  function pause() {
    isActive.value = false;
  }
  __name(pause, "pause");
  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
__name(useTimeoutPoll, "useTimeoutPoll");
function useTimestamp(options3 = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval = "requestAnimationFrame",
    callback
  } = options3;
  const ts = ref(timestamp() + offset);
  const update = /* @__PURE__ */ __name(() => ts.value = timestamp() + offset, "update");
  const cb = callback ? () => {
    update();
    callback(ts.value);
  } : update;
  const controls = interval === "requestAnimationFrame" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });
  if (exposeControls) {
    return {
      timestamp: ts,
      ...controls
    };
  } else {
    return ts;
  }
}
__name(useTimestamp, "useTimestamp");
function useTitle(newTitle = null, options3 = {}) {
  var _a, _b, _c;
  const {
    document: document2 = defaultDocument,
    restoreOnUnmount = /* @__PURE__ */ __name((t) => t, "restoreOnUnmount")
  } = options3;
  const originalTitle = (_a = document2 == null ? void 0 : document2.title) != null ? _a : "";
  const title = toRef((_b = newTitle != null ? newTitle : document2 == null ? void 0 : document2.title) != null ? _b : null);
  const isReadonly2 = newTitle && typeof newTitle === "function";
  function format2(t) {
    if (!("titleTemplate" in options3))
      return t;
    const template = options3.titleTemplate || "%s";
    return typeof template === "function" ? template(t) : toValue(template).replace(/%s/g, t);
  }
  __name(format2, "format");
  watch(
    title,
    (t, o) => {
      if (t !== o && document2)
        document2.title = format2(typeof t === "string" ? t : "");
    },
    { immediate: true }
  );
  if (options3.observe && !options3.titleTemplate && document2 && !isReadonly2) {
    useMutationObserver(
      (_c = document2.head) == null ? void 0 : _c.querySelector("title"),
      () => {
        if (document2 && document2.title !== title.value)
          title.value = format2(document2.title);
      },
      { childList: true }
    );
  }
  tryOnBeforeUnmount(() => {
    if (restoreOnUnmount) {
      const restoredTitle = restoreOnUnmount(originalTitle, title.value || "");
      if (restoredTitle != null && document2)
        document2.title = restoredTitle;
    }
  });
  return title;
}
__name(useTitle, "useTitle");
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
const TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);
function createEasingFunction([p0, p1, p2, p3]) {
  const a = /* @__PURE__ */ __name((a1, a2) => 1 - 3 * a2 + 3 * a1, "a");
  const b = /* @__PURE__ */ __name((a1, a2) => 3 * a2 - 6 * a1, "b");
  const c = /* @__PURE__ */ __name((a1) => 3 * a1, "c");
  const calcBezier = /* @__PURE__ */ __name((t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t, "calcBezier");
  const getSlope = /* @__PURE__ */ __name((t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1), "getSlope");
  const getTforX = /* @__PURE__ */ __name((x2) => {
    let aGuessT = x2;
    for (let i2 = 0; i2 < 4; ++i2) {
      const currentSlope = getSlope(aGuessT, p0, p2);
      if (currentSlope === 0)
        return aGuessT;
      const currentX = calcBezier(aGuessT, p0, p2) - x2;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }, "getTforX");
  return (x2) => p0 === p1 && p2 === p3 ? x2 : calcBezier(getTforX(x2), p1, p3);
}
__name(createEasingFunction, "createEasingFunction");
function lerp(a, b, alpha) {
  return a + alpha * (b - a);
}
__name(lerp, "lerp");
function toVec(t) {
  return (typeof t === "number" ? [t] : t) || [];
}
__name(toVec, "toVec");
function executeTransition(source, from, to, options3 = {}) {
  var _a, _b;
  const fromVal = toValue(from);
  const toVal = toValue(to);
  const v1 = toVec(fromVal);
  const v2 = toVec(toVal);
  const duration = (_a = toValue(options3.duration)) != null ? _a : 1e3;
  const startedAt = Date.now();
  const endAt = Date.now() + duration;
  const trans = typeof options3.transition === "function" ? options3.transition : (_b = toValue(options3.transition)) != null ? _b : identity;
  const ease = typeof trans === "function" ? trans : createEasingFunction(trans);
  return new Promise((resolve2) => {
    source.value = fromVal;
    const tick = /* @__PURE__ */ __name(() => {
      var _a2;
      if ((_a2 = options3.abort) == null ? void 0 : _a2.call(options3)) {
        resolve2();
        return;
      }
      const now2 = Date.now();
      const alpha = ease((now2 - startedAt) / duration);
      const arr = toVec(source.value).map((n, i2) => lerp(v1[i2], v2[i2], alpha));
      if (Array.isArray(source.value))
        source.value = arr.map((n, i2) => {
          var _a3, _b2;
          return lerp((_a3 = v1[i2]) != null ? _a3 : 0, (_b2 = v2[i2]) != null ? _b2 : 0, alpha);
        });
      else if (typeof source.value === "number")
        source.value = arr[0];
      if (now2 < endAt) {
        requestAnimationFrame(tick);
      } else {
        source.value = toVal;
        resolve2();
      }
    }, "tick");
    tick();
  });
}
__name(executeTransition, "executeTransition");
function useTransition(source, options3 = {}) {
  let currentId = 0;
  const sourceVal = /* @__PURE__ */ __name(() => {
    const v2 = toValue(source);
    return typeof v2 === "number" ? v2 : v2.map(toValue);
  }, "sourceVal");
  const outputRef = ref(sourceVal());
  watch(sourceVal, async (to) => {
    var _a, _b;
    if (toValue(options3.disabled))
      return;
    const id3 = ++currentId;
    if (options3.delay)
      await promiseTimeout(toValue(options3.delay));
    if (id3 !== currentId)
      return;
    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);
    (_a = options3.onStarted) == null ? void 0 : _a.call(options3);
    await executeTransition(outputRef, outputRef.value, toVal, {
      ...options3,
      abort: /* @__PURE__ */ __name(() => {
        var _a2;
        return id3 !== currentId || ((_a2 = options3.abort) == null ? void 0 : _a2.call(options3));
      }, "abort")
    });
    (_b = options3.onFinished) == null ? void 0 : _b.call(options3);
  }, { deep: true });
  watch(() => toValue(options3.disabled), (disabled2) => {
    if (disabled2) {
      currentId++;
      outputRef.value = sourceVal();
    }
  });
  tryOnScopeDispose(() => {
    currentId++;
  });
  return computed(() => toValue(options3.disabled) ? sourceVal() : outputRef.value);
}
__name(useTransition, "useTransition");
function useUrlSearchParams(mode2 = "history", options3 = {}) {
  const {
    initialValue = {},
    removeNullishValues = true,
    removeFalsyValues = false,
    write: enableWrite = true,
    window: window2 = defaultWindow
  } = options3;
  if (!window2)
    return reactive(initialValue);
  const state = reactive({});
  function getRawParams() {
    if (mode2 === "history") {
      return window2.location.search || "";
    } else if (mode2 === "hash") {
      const hash = window2.location.hash || "";
      const index2 = hash.indexOf("?");
      return index2 > 0 ? hash.slice(index2) : "";
    } else {
      return (window2.location.hash || "").replace(/^#/, "");
    }
  }
  __name(getRawParams, "getRawParams");
  function constructQuery(params) {
    const stringified = params.toString();
    if (mode2 === "history")
      return `${stringified ? `?${stringified}` : ""}${window2.location.hash || ""}`;
    if (mode2 === "hash-params")
      return `${window2.location.search || ""}${stringified ? `#${stringified}` : ""}`;
    const hash = window2.location.hash || "#";
    const index2 = hash.indexOf("?");
    if (index2 > 0)
      return `${hash.slice(0, index2)}${stringified ? `?${stringified}` : ""}`;
    return `${hash}${stringified ? `?${stringified}` : ""}`;
  }
  __name(constructQuery, "constructQuery");
  function read() {
    return new URLSearchParams(getRawParams());
  }
  __name(read, "read");
  function updateState(params) {
    const unusedKeys = new Set(Object.keys(state));
    for (const key of params.keys()) {
      const paramsForKey = params.getAll(key);
      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || "";
      unusedKeys.delete(key);
    }
    Array.from(unusedKeys).forEach((key) => delete state[key]);
  }
  __name(updateState, "updateState");
  const { pause, resume } = watchPausable(
    state,
    () => {
      const params = new URLSearchParams("");
      Object.keys(state).forEach((key) => {
        const mapEntry = state[key];
        if (Array.isArray(mapEntry))
          mapEntry.forEach((value3) => params.append(key, value3));
        else if (removeNullishValues && mapEntry == null)
          params.delete(key);
        else if (removeFalsyValues && !mapEntry)
          params.delete(key);
        else
          params.set(key, mapEntry);
      });
      write(params);
    },
    { deep: true }
  );
  function write(params, shouldUpdate) {
    pause();
    if (shouldUpdate)
      updateState(params);
    window2.history.replaceState(
      window2.history.state,
      window2.document.title,
      window2.location.pathname + constructQuery(params)
    );
    resume();
  }
  __name(write, "write");
  function onChanged() {
    if (!enableWrite)
      return;
    write(read(), true);
  }
  __name(onChanged, "onChanged");
  useEventListener(window2, "popstate", onChanged, false);
  if (mode2 !== "history")
    useEventListener(window2, "hashchange", onChanged, false);
  const initial = read();
  if (initial.keys().next().value)
    updateState(initial);
  else
    Object.assign(state, initialValue);
  return state;
}
__name(useUrlSearchParams, "useUrlSearchParams");
function useUserMedia(options3 = {}) {
  var _a, _b;
  const enabled = ref((_a = options3.enabled) != null ? _a : false);
  const autoSwitch = ref((_b = options3.autoSwitch) != null ? _b : true);
  const constraints = ref(options3.constraints);
  const { navigator: navigator2 = defaultNavigator } = options3;
  const isSupported2 = useSupported(() => {
    var _a2;
    return (_a2 = navigator2 == null ? void 0 : navigator2.mediaDevices) == null ? void 0 : _a2.getUserMedia;
  });
  const stream = shallowRef();
  function getDeviceOptions(type) {
    switch (type) {
      case "video": {
        if (constraints.value)
          return constraints.value.video || false;
        break;
      }
      case "audio": {
        if (constraints.value)
          return constraints.value.audio || false;
        break;
      }
    }
  }
  __name(getDeviceOptions, "getDeviceOptions");
  async function _start() {
    if (!isSupported2.value || stream.value)
      return;
    stream.value = await navigator2.mediaDevices.getUserMedia({
      video: getDeviceOptions("video"),
      audio: getDeviceOptions("audio")
    });
    return stream.value;
  }
  __name(_start, "_start");
  function _stop() {
    var _a2;
    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());
    stream.value = void 0;
  }
  __name(_stop, "_stop");
  function stop2() {
    _stop();
    enabled.value = false;
  }
  __name(stop2, "stop");
  async function start2() {
    await _start();
    if (stream.value)
      enabled.value = true;
    return stream.value;
  }
  __name(start2, "start");
  async function restart() {
    _stop();
    return await start2();
  }
  __name(restart, "restart");
  watch(
    enabled,
    (v2) => {
      if (v2)
        _start();
      else _stop();
    },
    { immediate: true }
  );
  watch(
    constraints,
    () => {
      if (autoSwitch.value && stream.value)
        restart();
    },
    { immediate: true }
  );
  tryOnScopeDispose(() => {
    stop2();
  });
  return {
    isSupported: isSupported2,
    stream,
    start: start2,
    stop: stop2,
    restart,
    constraints,
    enabled,
    autoSwitch
  };
}
__name(useUserMedia, "useUserMedia");
function useVModel(props, key, emit2, options3 = {}) {
  var _a, _b, _c, _d, _e;
  const {
    clone: clone2 = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options3;
  const vm = getCurrentInstance();
  const _emit = emit2 || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event2 = eventName;
  if (!key) {
    if (isVue2) {
      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;
      key = (modelOptions == null ? void 0 : modelOptions.value) || "value";
      if (!eventName)
        event2 = (modelOptions == null ? void 0 : modelOptions.event) || "input";
    } else {
      key = "modelValue";
    }
  }
  event2 = event2 || `update:${key.toString()}`;
  const cloneFn = /* @__PURE__ */ __name((val) => !clone2 ? val : typeof clone2 === "function" ? clone2(val) : cloneFnJSON(val), "cloneFn");
  const getValue2 = /* @__PURE__ */ __name(() => isDef(props[key]) ? cloneFn(props[key]) : defaultValue, "getValue2");
  const triggerEmit = /* @__PURE__ */ __name((value3) => {
    if (shouldEmit) {
      if (shouldEmit(value3))
        _emit(event2, value3);
    } else {
      _emit(event2, value3);
    }
  }, "triggerEmit");
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v2) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v2);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v2) => {
        if (!isUpdating && (v2 !== props[key] || deep))
          triggerEmit(v2);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value3) {
        triggerEmit(value3);
      }
    });
  }
}
__name(useVModel, "useVModel");
function useVModels(props, emit2, options3 = {}) {
  const ret = {};
  for (const key in props) {
    ret[key] = useVModel(
      props,
      key,
      emit2,
      options3
    );
  }
  return ret;
}
__name(useVModels, "useVModels");
function useVibrate(options3) {
  const {
    pattern = [],
    interval = 0,
    navigator: navigator2 = defaultNavigator
  } = options3 || {};
  const isSupported2 = useSupported(() => typeof navigator2 !== "undefined" && "vibrate" in navigator2);
  const patternRef = toRef(pattern);
  let intervalControls;
  const vibrate = /* @__PURE__ */ __name((pattern2 = patternRef.value) => {
    if (isSupported2.value)
      navigator2.vibrate(pattern2);
  }, "vibrate");
  const stop2 = /* @__PURE__ */ __name(() => {
    if (isSupported2.value)
      navigator2.vibrate(0);
    intervalControls == null ? void 0 : intervalControls.pause();
  }, "stop");
  if (interval > 0) {
    intervalControls = useIntervalFn(
      vibrate,
      interval,
      {
        immediate: false,
        immediateCallback: false
      }
    );
  }
  return {
    isSupported: isSupported2,
    pattern,
    intervalControls,
    vibrate,
    stop: stop2
  };
}
__name(useVibrate, "useVibrate");
function useVirtualList(list, options3) {
  const { containerStyle, wrapperProps, scrollTo: scrollTo22, calculateRange, currentList, containerRef: containerRef6 } = "itemHeight" in options3 ? useVerticalVirtualList(options3, list) : useHorizontalVirtualList(options3, list);
  return {
    list: currentList,
    scrollTo: scrollTo22,
    containerProps: {
      ref: containerRef6,
      onScroll: /* @__PURE__ */ __name(() => {
        calculateRange();
      }, "onScroll"),
      style: containerStyle
    },
    wrapperProps
  };
}
__name(useVirtualList, "useVirtualList");
function useVirtualListResources(list) {
  const containerRef6 = ref(null);
  const size2 = useElementSize(containerRef6);
  const currentList = ref([]);
  const source = shallowRef(list);
  const state = ref({ start: 0, end: 10 });
  return { state, source, currentList, size: size2, containerRef: containerRef6 };
}
__name(useVirtualListResources, "useVirtualListResources");
function createGetViewCapacity(state, source, itemSize2) {
  return (containerSize) => {
    if (typeof itemSize2 === "number")
      return Math.ceil(containerSize / itemSize2);
    const { start: start2 = 0 } = state.value;
    let sum = 0;
    let capacity = 0;
    for (let i2 = start2; i2 < source.value.length; i2++) {
      const size2 = itemSize2(i2);
      sum += size2;
      capacity = i2;
      if (sum > containerSize)
        break;
    }
    return capacity - start2;
  };
}
__name(createGetViewCapacity, "createGetViewCapacity");
function createGetOffset(source, itemSize2) {
  return (scrollDirection) => {
    if (typeof itemSize2 === "number")
      return Math.floor(scrollDirection / itemSize2) + 1;
    let sum = 0;
    let offset = 0;
    for (let i2 = 0; i2 < source.value.length; i2++) {
      const size2 = itemSize2(i2);
      sum += size2;
      if (sum >= scrollDirection) {
        offset = i2;
        break;
      }
    }
    return offset + 1;
  };
}
__name(createGetOffset, "createGetOffset");
function createCalculateRange(type, overscan, getOffset2, getViewCapacity, { containerRef: containerRef6, state, currentList, source }) {
  return () => {
    const element = containerRef6.value;
    if (element) {
      const offset = getOffset2(type === "vertical" ? element.scrollTop : element.scrollLeft);
      const viewCapacity = getViewCapacity(type === "vertical" ? element.clientHeight : element.clientWidth);
      const from = offset - overscan;
      const to = offset + viewCapacity + overscan;
      state.value = {
        start: from < 0 ? 0 : from,
        end: to > source.value.length ? source.value.length : to
      };
      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index2) => ({
        data: ele,
        index: index2 + state.value.start
      }));
    }
  };
}
__name(createCalculateRange, "createCalculateRange");
function createGetDistance(itemSize2, source) {
  return (index2) => {
    if (typeof itemSize2 === "number") {
      const size22 = index2 * itemSize2;
      return size22;
    }
    const size2 = source.value.slice(0, index2).reduce((sum, _2, i2) => sum + itemSize2(i2), 0);
    return size2;
  };
}
__name(createGetDistance, "createGetDistance");
function useWatchForSizes(size2, list, containerRef6, calculateRange) {
  watch([size2.width, size2.height, list, containerRef6], () => {
    calculateRange();
  });
}
__name(useWatchForSizes, "useWatchForSizes");
function createComputedTotalSize(itemSize2, source) {
  return computed(() => {
    if (typeof itemSize2 === "number")
      return source.value.length * itemSize2;
    return source.value.reduce((sum, _2, index2) => sum + itemSize2(index2), 0);
  });
}
__name(createComputedTotalSize, "createComputedTotalSize");
const scrollToDictionaryForElementScrollKey = {
  horizontal: "scrollLeft",
  vertical: "scrollTop"
};
function createScrollTo(type, calculateRange, getDistance, containerRef6) {
  return (index2) => {
    if (containerRef6.value) {
      containerRef6.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index2);
      calculateRange();
    }
  };
}
__name(createScrollTo, "createScrollTo");
function useHorizontalVirtualList(options3, list) {
  const resources = useVirtualListResources(list);
  const { state, source, currentList, size: size2, containerRef: containerRef6 } = resources;
  const containerStyle = { overflowX: "auto" };
  const { itemWidth, overscan = 5 } = options3;
  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);
  const getOffset2 = createGetOffset(source, itemWidth);
  const calculateRange = createCalculateRange("horizontal", overscan, getOffset2, getViewCapacity, resources);
  const getDistanceLeft = createGetDistance(itemWidth, source);
  const offsetLeft = computed(() => getDistanceLeft(state.value.start));
  const totalWidth = createComputedTotalSize(itemWidth, source);
  useWatchForSizes(size2, list, containerRef6, calculateRange);
  const scrollTo22 = createScrollTo("horizontal", calculateRange, getDistanceLeft, containerRef6);
  const wrapperProps = computed(() => {
    return {
      style: {
        height: "100%",
        width: `${totalWidth.value - offsetLeft.value}px`,
        marginLeft: `${offsetLeft.value}px`,
        display: "flex"
      }
    };
  });
  return {
    scrollTo: scrollTo22,
    calculateRange,
    wrapperProps,
    containerStyle,
    currentList,
    containerRef: containerRef6
  };
}
__name(useHorizontalVirtualList, "useHorizontalVirtualList");
function useVerticalVirtualList(options3, list) {
  const resources = useVirtualListResources(list);
  const { state, source, currentList, size: size2, containerRef: containerRef6 } = resources;
  const containerStyle = { overflowY: "auto" };
  const { itemHeight, overscan = 5 } = options3;
  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);
  const getOffset2 = createGetOffset(source, itemHeight);
  const calculateRange = createCalculateRange("vertical", overscan, getOffset2, getViewCapacity, resources);
  const getDistanceTop = createGetDistance(itemHeight, source);
  const offsetTop = computed(() => getDistanceTop(state.value.start));
  const totalHeight = createComputedTotalSize(itemHeight, source);
  useWatchForSizes(size2, list, containerRef6, calculateRange);
  const scrollTo22 = createScrollTo("vertical", calculateRange, getDistanceTop, containerRef6);
  const wrapperProps = computed(() => {
    return {
      style: {
        width: "100%",
        height: `${totalHeight.value - offsetTop.value}px`,
        marginTop: `${offsetTop.value}px`
      }
    };
  });
  return {
    calculateRange,
    scrollTo: scrollTo22,
    containerStyle,
    wrapperProps,
    currentList,
    containerRef: containerRef6
  };
}
__name(useVerticalVirtualList, "useVerticalVirtualList");
function useWakeLock(options3 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    document: document2 = defaultDocument
  } = options3;
  const requestedType = ref(false);
  const sentinel = shallowRef(null);
  const documentVisibility = useDocumentVisibility({ document: document2 });
  const isSupported2 = useSupported(() => navigator2 && "wakeLock" in navigator2);
  const isActive = computed(() => !!sentinel.value && documentVisibility.value === "visible");
  if (isSupported2.value) {
    useEventListener(sentinel, "release", () => {
      var _a, _b;
      requestedType.value = (_b = (_a = sentinel.value) == null ? void 0 : _a.type) != null ? _b : false;
    });
    whenever(
      () => documentVisibility.value === "visible" && (document2 == null ? void 0 : document2.visibilityState) === "visible" && requestedType.value,
      (type) => {
        requestedType.value = false;
        forceRequest(type);
      }
    );
  }
  async function forceRequest(type) {
    var _a;
    await ((_a = sentinel.value) == null ? void 0 : _a.release());
    sentinel.value = isSupported2.value ? await navigator2.wakeLock.request(type) : null;
  }
  __name(forceRequest, "forceRequest");
  async function request(type) {
    if (documentVisibility.value === "visible")
      await forceRequest(type);
    else
      requestedType.value = type;
  }
  __name(request, "request");
  async function release() {
    requestedType.value = false;
    const s = sentinel.value;
    sentinel.value = null;
    await (s == null ? void 0 : s.release());
  }
  __name(release, "release");
  return {
    sentinel,
    isSupported: isSupported2,
    isActive,
    request,
    forceRequest,
    release
  };
}
__name(useWakeLock, "useWakeLock");
function useWebNotification(options3 = {}) {
  const {
    window: window2 = defaultWindow,
    requestPermissions: _requestForPermissions = true
  } = options3;
  const defaultWebNotificationOptions = options3;
  const isSupported2 = useSupported(() => {
    if (!window2 || !("Notification" in window2))
      return false;
    try {
      new Notification("");
    } catch (e) {
      return false;
    }
    return true;
  });
  const permissionGranted = ref(isSupported2.value && "permission" in Notification && Notification.permission === "granted");
  const notification = ref(null);
  const ensurePermissions = /* @__PURE__ */ __name(async () => {
    if (!isSupported2.value)
      return;
    if (!permissionGranted.value && Notification.permission !== "denied") {
      const result = await Notification.requestPermission();
      if (result === "granted")
        permissionGranted.value = true;
    }
    return permissionGranted.value;
  }, "ensurePermissions");
  const { on: onClick3, trigger: clickTrigger } = createEventHook();
  const { on: onShow, trigger: showTrigger } = createEventHook();
  const { on: onError, trigger: errorTrigger } = createEventHook();
  const { on: onClose, trigger: closeTrigger } = createEventHook();
  const show5 = /* @__PURE__ */ __name(async (overrides) => {
    if (!isSupported2.value || !permissionGranted.value)
      return;
    const options22 = Object.assign({}, defaultWebNotificationOptions, overrides);
    notification.value = new Notification(options22.title || "", options22);
    notification.value.onclick = clickTrigger;
    notification.value.onshow = showTrigger;
    notification.value.onerror = errorTrigger;
    notification.value.onclose = closeTrigger;
    return notification.value;
  }, "show");
  const close4 = /* @__PURE__ */ __name(() => {
    if (notification.value)
      notification.value.close();
    notification.value = null;
  }, "close");
  if (_requestForPermissions)
    tryOnMounted(ensurePermissions);
  tryOnScopeDispose(close4);
  if (isSupported2.value && window2) {
    const document2 = window2.document;
    useEventListener(document2, "visibilitychange", (e) => {
      e.preventDefault();
      if (document2.visibilityState === "visible") {
        close4();
      }
    });
  }
  return {
    isSupported: isSupported2,
    notification,
    ensurePermissions,
    permissionGranted,
    show: show5,
    close: close4,
    onClick: onClick3,
    onShow,
    onError,
    onClose
  };
}
__name(useWebNotification, "useWebNotification");
const DEFAULT_PING_MESSAGE = "ping";
function resolveNestedOptions(options3) {
  if (options3 === true)
    return {};
  return options3;
}
__name(resolveNestedOptions, "resolveNestedOptions");
function useWebSocket(url, options3 = {}) {
  const {
    onConnected,
    onDisconnected,
    onError,
    onMessage,
    immediate = true,
    autoClose = true,
    protocols = []
  } = options3;
  const data22 = ref(null);
  const status = ref("CLOSED");
  const wsRef = ref();
  const urlRef = toRef(url);
  let heartbeatPause;
  let heartbeatResume;
  let explicitlyClosed = false;
  let retried = 0;
  let bufferedData = [];
  let pongTimeoutWait;
  const _sendBuffer = /* @__PURE__ */ __name(() => {
    if (bufferedData.length && wsRef.value && status.value === "OPEN") {
      for (const buffer2 of bufferedData)
        wsRef.value.send(buffer2);
      bufferedData = [];
    }
  }, "_sendBuffer");
  const resetHeartbeat = /* @__PURE__ */ __name(() => {
    clearTimeout(pongTimeoutWait);
    pongTimeoutWait = void 0;
  }, "resetHeartbeat");
  const close4 = /* @__PURE__ */ __name((code2 = 1e3, reason) => {
    if (!isClient || !wsRef.value)
      return;
    explicitlyClosed = true;
    resetHeartbeat();
    heartbeatPause == null ? void 0 : heartbeatPause();
    wsRef.value.close(code2, reason);
    wsRef.value = void 0;
  }, "close");
  const send = /* @__PURE__ */ __name((data23, useBuffer = true) => {
    if (!wsRef.value || status.value !== "OPEN") {
      if (useBuffer)
        bufferedData.push(data23);
      return false;
    }
    _sendBuffer();
    wsRef.value.send(data23);
    return true;
  }, "send");
  const _init = /* @__PURE__ */ __name(() => {
    if (explicitlyClosed || typeof urlRef.value === "undefined")
      return;
    const ws = new WebSocket(urlRef.value, protocols);
    wsRef.value = ws;
    status.value = "CONNECTING";
    ws.onopen = () => {
      status.value = "OPEN";
      onConnected == null ? void 0 : onConnected(ws);
      heartbeatResume == null ? void 0 : heartbeatResume();
      _sendBuffer();
    };
    ws.onclose = (ev) => {
      status.value = "CLOSED";
      onDisconnected == null ? void 0 : onDisconnected(ws, ev);
      if (!explicitlyClosed && options3.autoReconnect) {
        const {
          retries = -1,
          delay = 1e3,
          onFailed
        } = resolveNestedOptions(options3.autoReconnect);
        retried += 1;
        if (typeof retries === "number" && (retries < 0 || retried < retries))
          setTimeout(_init, delay);
        else if (typeof retries === "function" && retries())
          setTimeout(_init, delay);
        else
          onFailed == null ? void 0 : onFailed();
      }
    };
    ws.onerror = (e) => {
      onError == null ? void 0 : onError(ws, e);
    };
    ws.onmessage = (e) => {
      if (options3.heartbeat) {
        resetHeartbeat();
        const {
          message: message2 = DEFAULT_PING_MESSAGE,
          responseMessage = message2
        } = resolveNestedOptions(options3.heartbeat);
        if (e.data === responseMessage)
          return;
      }
      data22.value = e.data;
      onMessage == null ? void 0 : onMessage(ws, e);
    };
  }, "_init");
  if (options3.heartbeat) {
    const {
      message: message2 = DEFAULT_PING_MESSAGE,
      interval = 1e3,
      pongTimeout = 1e3
    } = resolveNestedOptions(options3.heartbeat);
    const { pause, resume } = useIntervalFn(
      () => {
        send(message2, false);
        if (pongTimeoutWait != null)
          return;
        pongTimeoutWait = setTimeout(() => {
          close4();
          explicitlyClosed = false;
        }, pongTimeout);
      },
      interval,
      { immediate: false }
    );
    heartbeatPause = pause;
    heartbeatResume = resume;
  }
  if (autoClose) {
    if (isClient)
      useEventListener("beforeunload", () => close4());
    tryOnScopeDispose(close4);
  }
  const open2 = /* @__PURE__ */ __name(() => {
    if (!isClient && !isWorker)
      return;
    close4();
    explicitlyClosed = false;
    retried = 0;
    _init();
  }, "open");
  if (immediate)
    open2();
  watch(urlRef, open2);
  return {
    data: data22,
    status,
    close: close4,
    send,
    open: open2,
    ws: wsRef
  };
}
__name(useWebSocket, "useWebSocket");
function useWebWorker(arg0, workerOptions, options3) {
  const {
    window: window2 = defaultWindow
  } = options3 != null ? options3 : {};
  const data22 = ref(null);
  const worker = shallowRef();
  const post = /* @__PURE__ */ __name((...args) => {
    if (!worker.value)
      return;
    worker.value.postMessage(...args);
  }, "post");
  const terminate = /* @__PURE__ */ __name(function terminate2() {
    if (!worker.value)
      return;
    worker.value.terminate();
  }, "terminate2");
  if (window2) {
    if (typeof arg0 === "string")
      worker.value = new Worker(arg0, workerOptions);
    else if (typeof arg0 === "function")
      worker.value = arg0();
    else
      worker.value = arg0;
    worker.value.onmessage = (e) => {
      data22.value = e.data;
    };
    tryOnScopeDispose(() => {
      if (worker.value)
        worker.value.terminate();
    });
  }
  return {
    data: data22,
    post,
    terminate,
    worker
  };
}
__name(useWebWorker, "useWebWorker");
function jobRunner(userFunc) {
  return (e) => {
    const userFuncArgs = e.data[0];
    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {
      postMessage(["SUCCESS", result]);
    }).catch((error) => {
      postMessage(["ERROR", error]);
    });
  };
}
__name(jobRunner, "jobRunner");
function depsParser(deps, localDeps) {
  if (deps.length === 0 && localDeps.length === 0)
    return "";
  const depsString = deps.map((dep) => `'${dep}'`).toString();
  const depsFunctionString = localDeps.filter((dep) => typeof dep === "function").map((fn) => {
    const str = fn.toString();
    if (str.trim().startsWith("function")) {
      return str;
    } else {
      const name = fn.name;
      return `const ${name} = ${str}`;
    }
  }).join(";");
  const importString = `importScripts(${depsString});`;
  return `${depsString.trim() === "" ? "" : importString} ${depsFunctionString}`;
}
__name(depsParser, "depsParser");
function createWorkerBlobUrl(fn, deps, localDeps) {
  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;
  const blob = new Blob([blobCode], { type: "text/javascript" });
  const url = URL.createObjectURL(blob);
  return url;
}
__name(createWorkerBlobUrl, "createWorkerBlobUrl");
function useWebWorkerFn(fn, options3 = {}) {
  const {
    dependencies = [],
    localDependencies = [],
    timeout,
    window: window2 = defaultWindow
  } = options3;
  const worker = ref();
  const workerStatus = ref("PENDING");
  const promise = ref({});
  const timeoutId = ref();
  const workerTerminate = /* @__PURE__ */ __name((status = "PENDING") => {
    if (worker.value && worker.value._url && window2) {
      worker.value.terminate();
      URL.revokeObjectURL(worker.value._url);
      promise.value = {};
      worker.value = void 0;
      window2.clearTimeout(timeoutId.value);
      workerStatus.value = status;
    }
  }, "workerTerminate");
  workerTerminate();
  tryOnScopeDispose(workerTerminate);
  const generateWorker = /* @__PURE__ */ __name(() => {
    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;
    newWorker.onmessage = (e) => {
      const { resolve: resolve2 = /* @__PURE__ */ __name(() => {
      }, "resolve"), reject: reject2 = /* @__PURE__ */ __name(() => {
      }, "reject") } = promise.value;
      const [status, result] = e.data;
      switch (status) {
        case "SUCCESS":
          resolve2(result);
          workerTerminate(status);
          break;
        default:
          reject2(result);
          workerTerminate("ERROR");
          break;
      }
    };
    newWorker.onerror = (e) => {
      const { reject: reject2 = /* @__PURE__ */ __name(() => {
      }, "reject") } = promise.value;
      e.preventDefault();
      reject2(e);
      workerTerminate("ERROR");
    };
    if (timeout) {
      timeoutId.value = setTimeout(
        () => workerTerminate("TIMEOUT_EXPIRED"),
        timeout
      );
    }
    return newWorker;
  }, "generateWorker");
  const callWorker = /* @__PURE__ */ __name((...fnArgs) => new Promise((resolve2, reject2) => {
    var _a;
    promise.value = {
      resolve: resolve2,
      reject: reject2
    };
    (_a = worker.value) == null ? void 0 : _a.postMessage([[...fnArgs]]);
    workerStatus.value = "RUNNING";
  }), "callWorker");
  const workerFn = /* @__PURE__ */ __name((...fnArgs) => {
    if (workerStatus.value === "RUNNING") {
      console.error(
        "[useWebWorkerFn] You can only run one instance of the worker at a time."
      );
      return Promise.reject();
    }
    worker.value = generateWorker();
    return callWorker(...fnArgs);
  }, "workerFn");
  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
}
__name(useWebWorkerFn, "useWebWorkerFn");
function useWindowFocus(options3 = {}) {
  const { window: window2 = defaultWindow } = options3;
  if (!window2)
    return ref(false);
  const focused = ref(window2.document.hasFocus());
  useEventListener(window2, "blur", () => {
    focused.value = false;
  });
  useEventListener(window2, "focus", () => {
    focused.value = true;
  });
  return focused;
}
__name(useWindowFocus, "useWindowFocus");
function useWindowScroll(options3 = {}) {
  const { window: window2 = defaultWindow, behavior = "auto" } = options3;
  if (!window2) {
    return {
      x: ref(0),
      y: ref(0)
    };
  }
  const internalX = ref(window2.scrollX);
  const internalY = ref(window2.scrollY);
  const x2 = computed({
    get() {
      return internalX.value;
    },
    set(x22) {
      scrollTo({ left: x22, behavior });
    }
  });
  const y2 = computed({
    get() {
      return internalY.value;
    },
    set(y22) {
      scrollTo({ top: y22, behavior });
    }
  });
  useEventListener(
    window2,
    "scroll",
    () => {
      internalX.value = window2.scrollX;
      internalY.value = window2.scrollY;
    },
    {
      capture: false,
      passive: true
    }
  );
  return { x: x2, y: y2 };
}
__name(useWindowScroll, "useWindowScroll");
function useWindowSize(options3 = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true,
    type = "inner"
  } = options3;
  const width2 = ref(initialWidth);
  const height = ref(initialHeight);
  const update = /* @__PURE__ */ __name(() => {
    if (window2) {
      if (type === "outer") {
        width2.value = window2.outerWidth;
        height.value = window2.outerHeight;
      } else if (includeScrollbar) {
        width2.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width2.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  }, "update");
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation) {
    const matches2 = useMediaQuery("(orientation: portrait)");
    watch(matches2, () => update());
  }
  return { width: width2, height };
}
__name(useWindowSize, "useWindowSize");
const _withScopeId$h = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-f49d6486"), n = n(), popScopeId(), n), "_withScopeId$h");
const _hoisted_1$P = { class: "relative h-full w-full bg-black" };
const _hoisted_2$C = {
  key: 0,
  class: "p-4 text-center"
};
const _hoisted_3$k = { class: "p-terminal rounded-none h-full w-full p-2" };
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "IntegratedTerminal",
  setup(__props) {
    const errorMessage = ref("");
    const loading2 = ref(true);
    const terminalEl = ref();
    const fitAddon = new addonFitExports.FitAddon();
    const terminal = new xtermExports.Terminal({
      convertEol: true
    });
    terminal.loadAddon(fitAddon);
    const resizeTerminal = /* @__PURE__ */ __name(() => terminal.resize(terminal.cols, fitAddon.proposeDimensions().rows), "resizeTerminal");
    const resizeObserver = new ResizeObserver(lodashExports.debounce(resizeTerminal, 50));
    const update = /* @__PURE__ */ __name((entries, size2) => {
      if (size2) {
        terminal.resize(size2.cols, fitAddon.proposeDimensions().rows);
      }
      terminal.write(entries.map((e) => e.m).join(""));
    }, "update");
    const logReceived = /* @__PURE__ */ __name((e) => {
      update(e.detail.entries, e.detail.size);
    }, "logReceived");
    const loadLogEntries = /* @__PURE__ */ __name(async () => {
      const logs = await api.getRawLogs();
      update(logs.entries, logs.size);
    }, "loadLogEntries");
    const watchLogs = /* @__PURE__ */ __name(async () => {
      const { clientId } = storeToRefs(useExecutionStore());
      if (!clientId.value) {
        await until(clientId).not.toBeNull();
      }
      api.subscribeLogs(true);
      api.addEventListener("logs", logReceived);
    }, "watchLogs");
    onMounted(async () => {
      terminal.open(terminalEl.value);
      try {
        await loadLogEntries();
      } catch (err) {
        console.error("Error loading logs", err);
        errorMessage.value = "Unable to load logs, please ensure you have updated your ComfyUI backend.";
        return;
      }
      loading2.value = false;
      resizeObserver.observe(terminalEl.value);
      await watchLogs();
    });
    onUnmounted(() => {
      if (api.clientId) {
        api.subscribeLogs(false);
      }
      api.removeEventListener("logs", logReceived);
      resizeObserver.disconnect();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$P, [
        errorMessage.value ? (openBlock(), createElementBlock("p", _hoisted_2$C, toDisplayString$1(errorMessage.value), 1)) : loading2.value ? (openBlock(), createBlock(unref(script$s), {
          key: 1,
          class: "absolute inset-0 flex justify-center items-center h-full z-10"
        })) : createCommentVNode("", true),
        withDirectives(createBaseVNode("div", _hoisted_3$k, [
          createBaseVNode("div", {
            class: "h-full",
            ref_key: "terminalEl",
            ref: terminalEl
          }, null, 512)
        ], 512), [
          [vShow, !loading2.value]
        ])
      ]);
    };
  }
});
const IntegratedTerminal = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__scopeId", "data-v-f49d6486"]]);
const useIntegratedTerminalTab = /* @__PURE__ */ __name(() => {
  const { t } = useI18n();
  return {
    id: "integrated-terminal",
    title: t("terminal"),
    component: markRaw(IntegratedTerminal),
    type: "vue"
  };
}, "useIntegratedTerminalTab");
const useBottomPanelStore = /* @__PURE__ */ defineStore("bottomPanel", () => {
  const bottomPanelVisible = ref(false);
  const toggleBottomPanel = /* @__PURE__ */ __name(() => {
    if (bottomPanelTabs.value.length === 0) {
      return;
    }
    bottomPanelVisible.value = !bottomPanelVisible.value;
  }, "toggleBottomPanel");
  const bottomPanelTabs = ref([]);
  const activeBottomPanelTabId = ref(null);
  const activeBottomPanelTab = computed(() => {
    return bottomPanelTabs.value.find(
      (tab) => tab.id === activeBottomPanelTabId.value
    ) ?? null;
  });
  const setActiveTab = /* @__PURE__ */ __name((tabId) => {
    activeBottomPanelTabId.value = tabId;
  }, "setActiveTab");
  const toggleBottomPanelTab = /* @__PURE__ */ __name((tabId) => {
    if (activeBottomPanelTabId.value === tabId && bottomPanelVisible.value) {
      bottomPanelVisible.value = false;
    } else {
      activeBottomPanelTabId.value = tabId;
      bottomPanelVisible.value = true;
    }
  }, "toggleBottomPanelTab");
  const registerBottomPanelTab = /* @__PURE__ */ __name((tab) => {
    bottomPanelTabs.value = [...bottomPanelTabs.value, tab];
    if (bottomPanelTabs.value.length === 1) {
      activeBottomPanelTabId.value = tab.id;
    }
    useCommandStore().registerCommand({
      id: `Workspace.ToggleBottomPanelTab.${tab.id}`,
      icon: "pi pi-list",
      label: tab.title,
      function: /* @__PURE__ */ __name(() => toggleBottomPanelTab(tab.id), "function")
    });
  }, "registerBottomPanelTab");
  const registerCoreBottomPanelTabs = /* @__PURE__ */ __name(() => {
    registerBottomPanelTab(useIntegratedTerminalTab());
  }, "registerCoreBottomPanelTabs");
  const registerExtensionBottomPanelTabs = /* @__PURE__ */ __name((extension) => {
    if (extension.bottomPanelTabs) {
      extension.bottomPanelTabs.forEach(registerBottomPanelTab);
    }
  }, "registerExtensionBottomPanelTabs");
  return {
    bottomPanelVisible,
    toggleBottomPanel,
    bottomPanelTabs,
    activeBottomPanelTab,
    activeBottomPanelTabId,
    setActiveTab,
    toggleBottomPanelTab,
    registerBottomPanelTab,
    registerCoreBottomPanelTabs,
    registerExtensionBottomPanelTabs
  };
});
const SIZE = Symbol();
function intersect(a, b) {
  const x2 = Math.max(a.x, b.x);
  const num1 = Math.min(a.x + a.width, b.x + b.width);
  const y2 = Math.max(a.y, b.y);
  const num2 = Math.min(a.y + a.height, b.y + b.height);
  if (num1 >= x2 && num2 >= y2) return [x2, y2, num1 - x2, num2 - y2];
  else return null;
}
__name(intersect, "intersect");
function getClipPath(node3, element, canvasRect) {
  const selectedNode = Object.values(
    app$1.canvas.selected_nodes
  )[0];
  if (selectedNode && selectedNode !== node3) {
    const elRect = element.getBoundingClientRect();
    const MARGIN = 4;
    const { offset, scale } = app$1.canvas.ds;
    const { renderArea } = selectedNode;
    const intersection = intersect(
      {
        x: elRect.left - canvasRect.left,
        y: elRect.top - canvasRect.top,
        width: elRect.width,
        height: elRect.height
      },
      {
        x: (renderArea[0] + offset[0] - MARGIN) * scale,
        y: (renderArea[1] + offset[1] - MARGIN) * scale,
        width: (renderArea[2] + 2 * MARGIN) * scale,
        height: (renderArea[3] + 2 * MARGIN) * scale
      }
    );
    if (!intersection) {
      return "";
    }
    const clipX = (intersection[0] - elRect.left + canvasRect.left) / scale + "px";
    const clipY = (intersection[1] - elRect.top + canvasRect.top) / scale + "px";
    const clipWidth = intersection[2] / scale + "px";
    const clipHeight = intersection[3] / scale + "px";
    const path = `polygon(0% 0%, 0% 100%, ${clipX} 100%, ${clipX} ${clipY}, calc(${clipX} + ${clipWidth}) ${clipY}, calc(${clipX} + ${clipWidth}) calc(${clipY} + ${clipHeight}), ${clipX} calc(${clipY} + ${clipHeight}), ${clipX} 100%, 100% 100%, 100% 0%)`;
    return path;
  }
  return "";
}
__name(getClipPath, "getClipPath");
function computeSize(size2) {
  if (this.widgets?.[0]?.last_y == null) return;
  let y2 = this.widgets[0].last_y;
  let freeSpace = size2[1] - y2;
  let widgetHeight = 0;
  let dom = [];
  for (const w2 of this.widgets) {
    if (w2.type === "converted-widget") {
      delete w2.computedHeight;
    } else if (w2.computeSize) {
      widgetHeight += w2.computeSize()[1] + 4;
    } else if (w2.element) {
      const styles = getComputedStyle(w2.element);
      let minHeight = w2.options.getMinHeight?.() ?? parseInt(styles.getPropertyValue("--comfy-widget-min-height"));
      let maxHeight = w2.options.getMaxHeight?.() ?? parseInt(styles.getPropertyValue("--comfy-widget-max-height"));
      let prefHeight = w2.options.getHeight?.() ?? styles.getPropertyValue("--comfy-widget-height");
      if (prefHeight.endsWith?.("%")) {
        prefHeight = size2[1] * (parseFloat(prefHeight.substring(0, prefHeight.length - 1)) / 100);
      } else {
        prefHeight = parseInt(prefHeight);
        if (isNaN(minHeight)) {
          minHeight = prefHeight;
        }
      }
      if (isNaN(minHeight)) {
        minHeight = 50;
      }
      if (!isNaN(maxHeight)) {
        if (!isNaN(prefHeight)) {
          prefHeight = Math.min(prefHeight, maxHeight);
        } else {
          prefHeight = maxHeight;
        }
      }
      dom.push({
        minHeight,
        prefHeight,
        w: w2
      });
    } else {
      widgetHeight += LiteGraph.NODE_WIDGET_HEIGHT + 4;
    }
  }
  freeSpace -= widgetHeight;
  const prefGrow = [];
  const canGrow = [];
  let growBy = 0;
  for (const d of dom) {
    freeSpace -= d.minHeight;
    if (isNaN(d.prefHeight)) {
      canGrow.push(d);
      d.w.computedHeight = d.minHeight;
    } else {
      const diff2 = d.prefHeight - d.minHeight;
      if (diff2 > 0) {
        prefGrow.push(d);
        growBy += diff2;
        d.diff = diff2;
      } else {
        d.w.computedHeight = d.minHeight;
      }
    }
  }
  if (this.imgs && !this.widgets.find((w2) => w2.name === ANIM_PREVIEW_WIDGET)) {
    freeSpace -= 220;
  }
  this.freeWidgetSpace = freeSpace;
  if (freeSpace < 0) {
    size2[1] -= freeSpace;
    this.graph.setDirtyCanvas(true);
  } else {
    const growDiff = freeSpace - growBy;
    if (growDiff > 0) {
      freeSpace = growDiff;
      for (const d of prefGrow) {
        d.w.computedHeight = d.prefHeight;
      }
    } else {
      const shared = -growDiff / prefGrow.length;
      for (const d of prefGrow) {
        d.w.computedHeight = d.prefHeight - shared;
      }
      freeSpace = 0;
    }
    if (freeSpace > 0 && canGrow.length) {
      const shared = freeSpace / canGrow.length;
      for (const d of canGrow) {
        d.w.computedHeight += shared;
      }
    }
  }
  for (const w2 of this.widgets) {
    w2.y = y2;
    if (w2.computedHeight) {
      y2 += w2.computedHeight;
    } else if (w2.computeSize) {
      y2 += w2.computeSize()[1] + 4;
    } else {
      y2 += LiteGraph.NODE_WIDGET_HEIGHT + 4;
    }
  }
}
__name(computeSize, "computeSize");
const elementWidgets = /* @__PURE__ */ new Set();
const computeVisibleNodes = LGraphCanvas.prototype.computeVisibleNodes;
LGraphCanvas.prototype.computeVisibleNodes = function() {
  const visibleNodes = computeVisibleNodes.apply(this, arguments);
  for (const node3 of app$1.graph.nodes) {
    if (elementWidgets.has(node3)) {
      const hidden = visibleNodes.indexOf(node3) === -1;
      for (const w2 of node3.widgets) {
        if (w2.element) {
          w2.element.dataset.isInVisibleNodes = hidden ? "false" : "true";
          const shouldOtherwiseHide = w2.element.dataset.shouldHide === "true";
          const isCollapsed = w2.element.dataset.collapsed === "true";
          const wasHidden = w2.element.hidden;
          const actualHidden = hidden || shouldOtherwiseHide || isCollapsed;
          w2.element.hidden = actualHidden;
          w2.element.style.display = actualHidden ? "none" : null;
          if (actualHidden && !wasHidden) {
            w2.options.onHide?.(w2);
          }
        }
      }
    }
  }
  return visibleNodes;
};
LGraphNode.prototype.addDOMWidget = function(name, type, element, options3 = {}) {
  options3 = { hideOnZoom: true, selectOn: ["focus", "click"], ...options3 };
  if (!element.parentElement) {
    app$1.canvasContainer.append(element);
  }
  element.hidden = true;
  element.style.display = "none";
  let mouseDownHandler;
  if (element.blur) {
    mouseDownHandler = /* @__PURE__ */ __name((event2) => {
      if (!element.contains(event2.target)) {
        element.blur();
      }
    }, "mouseDownHandler");
    document.addEventListener("mousedown", mouseDownHandler);
  }
  const { nodeData } = this.constructor;
  const tooltip = (nodeData?.input.required?.[name] ?? nodeData?.input.optional?.[name])?.[1]?.tooltip;
  if (tooltip && !element.title) {
    element.title = tooltip;
  }
  const widget = {
    // @ts-expect-error All unrecognized types will be treated the same way as 'custom'
    // in litegraph internally.
    type,
    name,
    get value() {
      return options3.getValue?.() ?? void 0;
    },
    set value(v2) {
      options3.setValue?.(v2);
      widget.callback?.(widget.value);
    },
    draw: /* @__PURE__ */ __name(function(ctx, node3, widgetWidth, y2, widgetHeight) {
      if (widget.computedHeight == null) {
        computeSize.call(node3, node3.size);
      }
      const { offset, scale } = app$1.canvas.ds;
      const hidden = !!options3.hideOnZoom && scale < 0.5 || widget.computedHeight <= 0 || // @ts-expect-error Used by widgetInputs.ts
      widget.type === "converted-widget" || // @ts-expect-error Used by groupNode.ts
      widget.type === "hidden";
      element.dataset.shouldHide = hidden ? "true" : "false";
      const isInVisibleNodes = element.dataset.isInVisibleNodes === "true";
      const isCollapsed = element.dataset.collapsed === "true";
      const actualHidden = hidden || !isInVisibleNodes || isCollapsed;
      const wasHidden = element.hidden;
      element.hidden = actualHidden;
      element.style.display = actualHidden ? "none" : null;
      if (actualHidden && !wasHidden) {
        widget.options.onHide?.(widget);
      }
      if (actualHidden) {
        return;
      }
      const elRect = ctx.canvas.getBoundingClientRect();
      const margin = 10;
      const top = node3.pos[0] + offset[0] + margin;
      const left = node3.pos[1] + offset[1] + margin + y2;
      Object.assign(element.style, {
        transformOrigin: "0 0",
        transform: `scale(${scale})`,
        left: `${top * scale}px`,
        top: `${left * scale}px`,
        width: `${widgetWidth - margin * 2}px`,
        height: `${(widget.computedHeight ?? 50) - margin * 2}px`,
        position: "absolute",
        zIndex: app$1.graph.nodes.indexOf(node3),
        pointerEvents: app$1.canvas.read_only ? "none" : "auto"
      });
      if (useSettingStore().get("Comfy.DOMClippingEnabled")) {
        element.style.clipPath = getClipPath(node3, element, elRect);
        element.style.willChange = "clip-path";
      }
      this.options.onDraw?.(widget);
    }, "draw"),
    element,
    options: options3,
    onRemove() {
      if (mouseDownHandler) {
        document.removeEventListener("mousedown", mouseDownHandler);
      }
      element.remove();
    }
  };
  for (const evt of options3.selectOn) {
    element.addEventListener(evt, () => {
      app$1.canvas.selectNode(this);
      app$1.canvas.bringToFront(this);
    });
  }
  this.addCustomWidget(widget);
  elementWidgets.add(this);
  const collapse = this.collapse;
  this.collapse = function() {
    collapse.apply(this, arguments);
    if (this.flags?.collapsed) {
      element.hidden = true;
      element.style.display = "none";
    }
    element.dataset.collapsed = this.flags?.collapsed ? "true" : "false";
  };
  const onRemoved = this.onRemoved;
  this.onRemoved = function() {
    element.remove();
    elementWidgets.delete(this);
    onRemoved?.apply(this, arguments);
  };
  if (!this[SIZE]) {
    this[SIZE] = true;
    const onResize2 = this.onResize;
    this.onResize = function(size2) {
      options3.beforeResize?.call(widget, this);
      computeSize.call(this, size2);
      onResize2?.apply(this, arguments);
      options3.afterResize?.call(widget, this);
    };
  }
  return widget;
};
let controlValueRunBefore = false;
function updateControlWidgetLabel(widget) {
  let replacement = "after";
  let find2 = "before";
  if (controlValueRunBefore) {
    ;
    [find2, replacement] = [replacement, find2];
  }
  widget.label = (widget.label ?? widget.name).replace(find2, replacement);
}
__name(updateControlWidgetLabel, "updateControlWidgetLabel");
const IS_CONTROL_WIDGET = Symbol();
const HAS_EXECUTED = Symbol();
function getNumberDefaults(inputData, defaultStep, precision, enable_rounding) {
  let defaultVal = inputData[1]["default"];
  let { min, max, step: step2, round } = inputData[1];
  if (defaultVal == void 0) defaultVal = 0;
  if (min == void 0) min = 0;
  if (max == void 0) max = 2048;
  if (step2 == void 0) step2 = defaultStep;
  if (precision == void 0) {
    precision = Math.max(-Math.floor(Math.log10(step2)), 0);
  }
  if (enable_rounding && (round == void 0 || round === true)) {
    round = Math.round(1e6 * Math.pow(0.1, precision)) / 1e6;
  }
  return {
    val: defaultVal,
    config: { min, max, step: 10 * step2, round, precision }
  };
}
__name(getNumberDefaults, "getNumberDefaults");
function addValueControlWidget(node3, targetWidget, defaultValue = "randomize", values2, widgetName, inputData) {
  let name = inputData[1]?.control_after_generate;
  if (typeof name !== "string") {
    name = widgetName;
  }
  const widgets = addValueControlWidgets(
    node3,
    targetWidget,
    defaultValue,
    {
      addFilterList: false,
      controlAfterGenerateName: name
    },
    inputData
  );
  return widgets[0];
}
__name(addValueControlWidget, "addValueControlWidget");
function addValueControlWidgets(node3, targetWidget, defaultValue = "randomize", options3, inputData) {
  if (!defaultValue) defaultValue = "randomize";
  if (!options3) options3 = {};
  const getName = /* @__PURE__ */ __name((defaultName, optionName) => {
    let name = defaultName;
    if (options3[optionName]) {
      name = options3[optionName];
    } else if (typeof inputData?.[1]?.[defaultName] === "string") {
      name = inputData?.[1]?.[defaultName];
    } else if (inputData?.[1]?.control_prefix) {
      name = inputData?.[1]?.control_prefix + " " + name;
    }
    return name;
  }, "getName");
  const widgets = [];
  const valueControl = node3.addWidget(
    "combo",
    getName("control_after_generate", "controlAfterGenerateName"),
    defaultValue,
    function() {
    },
    {
      values: ["fixed", "increment", "decrement", "randomize"],
      serialize: false
      // Don't include this in prompt.
    }
  );
  valueControl.tooltip = "Allows the linked widget to be changed automatically, for example randomizing the noise seed.";
  valueControl[IS_CONTROL_WIDGET] = true;
  updateControlWidgetLabel(valueControl);
  widgets.push(valueControl);
  const isCombo = targetWidget.type === "combo";
  let comboFilter;
  if (isCombo) {
    valueControl.options.values.push("increment-wrap");
  }
  if (isCombo && options3.addFilterList !== false) {
    comboFilter = node3.addWidget(
      "string",
      getName("control_filter_list", "controlFilterListName"),
      "",
      function() {
      },
      {
        serialize: false
        // Don't include this in prompt.
      }
    );
    updateControlWidgetLabel(comboFilter);
    comboFilter.tooltip = "Allows for filtering the list of values when changing the value via the control generate mode. Allows for RegEx matches in the format /abc/ to only filter to values containing 'abc'.";
    widgets.push(comboFilter);
  }
  const applyWidgetControl = /* @__PURE__ */ __name(() => {
    var v2 = valueControl.value;
    if (isCombo && v2 !== "fixed") {
      let values2 = targetWidget.options.values;
      const filter4 = comboFilter?.value;
      if (filter4) {
        let check;
        if (filter4.startsWith("/") && filter4.endsWith("/")) {
          try {
            const regex = new RegExp(filter4.substring(1, filter4.length - 1));
            check = /* @__PURE__ */ __name((item2) => regex.test(item2), "check");
          } catch (error) {
            console.error(
              "Error constructing RegExp filter for node " + node3.id,
              filter4,
              error
            );
          }
        }
        if (!check) {
          const lower = filter4.toLocaleLowerCase();
          check = /* @__PURE__ */ __name((item2) => item2.toLocaleLowerCase().includes(lower), "check");
        }
        values2 = values2.filter((item2) => check(item2));
        if (!values2.length && targetWidget.options.values.length) {
          console.warn(
            "Filter for node " + node3.id + " has filtered out all items",
            filter4
          );
        }
      }
      let current_index = values2.indexOf(targetWidget.value);
      let current_length = values2.length;
      switch (v2) {
        case "increment":
          current_index += 1;
          break;
        case "increment-wrap":
          current_index += 1;
          if (current_index >= current_length) {
            current_index = 0;
          }
          break;
        case "decrement":
          current_index -= 1;
          break;
        case "randomize":
          current_index = Math.floor(Math.random() * current_length);
          break;
        default:
          break;
      }
      current_index = Math.max(0, current_index);
      current_index = Math.min(current_length - 1, current_index);
      if (current_index >= 0) {
        let value3 = values2[current_index];
        targetWidget.value = value3;
        targetWidget.callback(value3);
      }
    } else {
      let min = targetWidget.options.min;
      let max = targetWidget.options.max;
      max = Math.min(1125899906842624, max);
      min = Math.max(-1125899906842624, min);
      let range2 = (max - min) / (targetWidget.options.step / 10);
      switch (v2) {
        case "fixed":
          break;
        case "increment":
          targetWidget.value += targetWidget.options.step / 10;
          break;
        case "decrement":
          targetWidget.value -= targetWidget.options.step / 10;
          break;
        case "randomize":
          targetWidget.value = Math.floor(Math.random() * range2) * (targetWidget.options.step / 10) + min;
          break;
        default:
          break;
      }
      if (targetWidget.value < min) targetWidget.value = min;
      if (targetWidget.value > max) targetWidget.value = max;
      targetWidget.callback(targetWidget.value);
    }
  }, "applyWidgetControl");
  valueControl.beforeQueued = () => {
    if (controlValueRunBefore) {
      if (valueControl[HAS_EXECUTED]) {
        applyWidgetControl();
      }
    }
    valueControl[HAS_EXECUTED] = true;
  };
  valueControl.afterQueued = () => {
    if (!controlValueRunBefore) {
      applyWidgetControl();
    }
  };
  return widgets;
}
__name(addValueControlWidgets, "addValueControlWidgets");
function seedWidget(node3, inputName, inputData, app2, widgetName) {
  const seed = createIntWidget(node3, inputName, inputData, app2, true);
  const seedControl = addValueControlWidget(
    node3,
    seed.widget,
    "randomize",
    void 0,
    widgetName,
    inputData
  );
  seed.widget.linkedWidgets = [seedControl];
  return seed;
}
__name(seedWidget, "seedWidget");
function createIntWidget(node3, inputName, inputData, app2, isSeedInput = false) {
  const control = inputData[1]?.control_after_generate;
  if (!isSeedInput && control) {
    return seedWidget(
      node3,
      inputName,
      inputData,
      app2,
      typeof control === "string" ? control : void 0
    );
  }
  let widgetType = isSlider(inputData[1]["display"], app2);
  const { val, config: config2 } = getNumberDefaults(inputData, 1, 0, true);
  Object.assign(config2, { precision: 0 });
  return {
    widget: node3.addWidget(
      widgetType,
      inputName,
      val,
      function(v2) {
        const s = this.options.step / 10;
        let sh = this.options.min % s;
        if (isNaN(sh)) {
          sh = 0;
        }
        this.value = Math.round((v2 - sh) / s) * s + sh;
      },
      config2
    )
  };
}
__name(createIntWidget, "createIntWidget");
function addMultilineWidget(node3, name, opts, app2) {
  const inputEl = document.createElement("textarea");
  inputEl.className = "comfy-multiline-input";
  inputEl.value = opts.defaultVal;
  inputEl.placeholder = opts.placeholder || name;
  if (app2.vueAppReady) {
    inputEl.spellcheck = useSettingStore().get(
      "Comfy.TextareaWidget.Spellcheck"
    );
  }
  const widget = node3.addDOMWidget(name, "customtext", inputEl, {
    getValue() {
      return inputEl.value;
    },
    setValue(v2) {
      inputEl.value = v2;
    }
  });
  widget.inputEl = inputEl;
  inputEl.addEventListener("input", () => {
    widget.callback?.(widget.value);
  });
  return { minWidth: 400, minHeight: 200, widget };
}
__name(addMultilineWidget, "addMultilineWidget");
function isSlider(display, app2) {
  if (app2.ui.settings.getSettingValue("Comfy.DisableSliders")) {
    return "number";
  }
  return display === "slider" ? "slider" : "number";
}
__name(isSlider, "isSlider");
function initWidgets(app2) {
  app2.ui.settings.addSetting({
    id: "Comfy.WidgetControlMode",
    category: ["Comfy", "Node Widget", "WidgetControlMode"],
    name: "Widget control mode",
    tooltip: "Controls when widget values are updated (randomize/increment/decrement), either before the prompt is queued or after.",
    type: "combo",
    defaultValue: "after",
    options: ["before", "after"],
    onChange(value3) {
      controlValueRunBefore = value3 === "before";
      for (const n of app2.graph.nodes) {
        if (!n.widgets) continue;
        for (const w2 of n.widgets) {
          if (w2[IS_CONTROL_WIDGET]) {
            updateControlWidgetLabel(w2);
            if (w2.linkedWidgets) {
              for (const l of w2.linkedWidgets) {
                updateControlWidgetLabel(l);
              }
            }
          }
        }
      }
      app2.graph.setDirtyCanvas(true);
    }
  });
}
__name(initWidgets, "initWidgets");
const ComfyWidgets = {
  "INT:seed": seedWidget,
  "INT:noise_seed": seedWidget,
  FLOAT(node3, inputName, inputData, app2) {
    let widgetType = isSlider(inputData[1]["display"], app2);
    let precision = app2.ui.settings.getSettingValue(
      "Comfy.FloatRoundingPrecision"
    );
    let disable_rounding = app2.ui.settings.getSettingValue(
      "Comfy.DisableFloatRounding"
    );
    if (precision == 0) precision = void 0;
    const { val, config: config2 } = getNumberDefaults(
      inputData,
      0.5,
      precision,
      !disable_rounding
    );
    return {
      widget: node3.addWidget(
        widgetType,
        inputName,
        val,
        function(v2) {
          if (config2.round) {
            this.value = Math.round((v2 + Number.EPSILON) / config2.round) * config2.round;
            if (this.value > config2.max) this.value = config2.max;
            if (this.value < config2.min) this.value = config2.min;
          } else {
            this.value = v2;
          }
        },
        config2
      )
    };
  },
  INT(node3, inputName, inputData, app2) {
    return createIntWidget(node3, inputName, inputData, app2);
  },
  BOOLEAN(node3, inputName, inputData) {
    let defaultVal = false;
    let options3 = {};
    if (inputData[1]) {
      if (inputData[1].default) defaultVal = inputData[1].default;
      if (inputData[1].label_on) options3["on"] = inputData[1].label_on;
      if (inputData[1].label_off) options3["off"] = inputData[1].label_off;
    }
    return {
      widget: node3.addWidget("toggle", inputName, defaultVal, () => {
      }, options3)
    };
  },
  STRING(node3, inputName, inputData, app2) {
    const defaultVal = inputData[1].default || "";
    const multiline = !!inputData[1].multiline;
    let res;
    if (multiline) {
      res = addMultilineWidget(
        node3,
        inputName,
        { defaultVal, ...inputData[1] },
        app2
      );
    } else {
      res = {
        widget: node3.addWidget("text", inputName, defaultVal, () => {
        }, {})
      };
    }
    if (inputData[1].dynamicPrompts != void 0)
      res.widget.dynamicPrompts = inputData[1].dynamicPrompts;
    return res;
  },
  COMBO(node3, inputName, inputData) {
    const type = inputData[0];
    let defaultValue = type[0];
    if (inputData[1] && inputData[1].default) {
      defaultValue = inputData[1].default;
    }
    const res = {
      widget: node3.addWidget("combo", inputName, defaultValue, () => {
      }, {
        values: type
      })
    };
    if (inputData[1]?.control_after_generate) {
      res.widget.linkedWidgets = addValueControlWidgets(
        node3,
        res.widget,
        void 0,
        void 0,
        inputData
      );
    }
    return res;
  },
  IMAGEUPLOAD(node3, inputName, inputData, app2) {
    const imageWidget = node3.widgets.find(
      (w2) => w2.name === (inputData[1]?.widget ?? "image")
    );
    let uploadWidget;
    function showImage(name) {
      const img = new Image();
      img.onload = () => {
        node3.imgs = [img];
        app2.graph.setDirtyCanvas(true);
      };
      let folder_separator = name.lastIndexOf("/");
      let subfolder = "";
      if (folder_separator > -1) {
        subfolder = name.substring(0, folder_separator);
        name = name.substring(folder_separator + 1);
      }
      img.src = api.apiURL(
        `/view?filename=${encodeURIComponent(name)}&type=input&subfolder=${subfolder}${app2.getPreviewFormatParam()}${app2.getRandParam()}`
      );
      node3.setSizeForImage?.();
    }
    __name(showImage, "showImage");
    var default_value = imageWidget.value;
    Object.defineProperty(imageWidget, "value", {
      set: /* @__PURE__ */ __name(function(value3) {
        this._real_value = value3;
      }, "set"),
      get: /* @__PURE__ */ __name(function() {
        if (!this._real_value) {
          return default_value;
        }
        let value3 = this._real_value;
        if (value3.filename) {
          let real_value = value3;
          value3 = "";
          if (real_value.subfolder) {
            value3 = real_value.subfolder + "/";
          }
          value3 += real_value.filename;
          if (real_value.type && real_value.type !== "input")
            value3 += ` [${real_value.type}]`;
        }
        return value3;
      }, "get")
    });
    const cb = node3.callback;
    imageWidget.callback = function() {
      showImage(imageWidget.value);
      if (cb) {
        return cb.apply(this, arguments);
      }
    };
    requestAnimationFrame(() => {
      if (imageWidget.value) {
        showImage(imageWidget.value);
      }
    });
    async function uploadFile(file, updateNode, pasted = false) {
      try {
        const body = new FormData();
        body.append("image", file);
        if (pasted) body.append("subfolder", "pasted");
        const resp = await api.fetchApi("/upload/image", {
          method: "POST",
          body
        });
        if (resp.status === 200) {
          const data22 = await resp.json();
          let path = data22.name;
          if (data22.subfolder) path = data22.subfolder + "/" + path;
          if (!imageWidget.options.values.includes(path)) {
            imageWidget.options.values.push(path);
          }
          if (updateNode) {
            showImage(path);
            imageWidget.value = path;
          }
        } else {
          useToastStore().addAlert(resp.status + " - " + resp.statusText);
        }
      } catch (error) {
        useToastStore().addAlert(error);
      }
    }
    __name(uploadFile, "uploadFile");
    const fileInput2 = document.createElement("input");
    Object.assign(fileInput2, {
      type: "file",
      accept: "image/jpeg,image/png,image/webp",
      style: "display: none",
      onchange: /* @__PURE__ */ __name(async () => {
        if (fileInput2.files.length) {
          await uploadFile(fileInput2.files[0], true);
        }
      }, "onchange")
    });
    document.body.append(fileInput2);
    uploadWidget = node3.addWidget("button", inputName, "image", () => {
      fileInput2.click();
    });
    uploadWidget.label = "choose file to upload";
    uploadWidget.serialize = false;
    node3.onDragOver = function(e) {
      if (e.dataTransfer && e.dataTransfer.items) {
        const image = [...e.dataTransfer.items].find((f) => f.kind === "file");
        return !!image;
      }
      return false;
    };
    node3.onDragDrop = function(e) {
      console.log("onDragDrop called");
      let handled = false;
      for (const file of e.dataTransfer.files) {
        if (file.type.startsWith("image/")) {
          uploadFile(file, !handled);
          handled = true;
        }
      }
      return handled;
    };
    node3.pasteFile = function(file) {
      if (file.type.startsWith("image/")) {
        const is_pasted = file.name === "image.png" && file.lastModified - Date.now() < 2e3;
        uploadFile(file, true, is_pasted);
        return true;
      }
      return false;
    };
    return { widget: uploadWidget };
  }
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.widgets = window.comfyAPI.widgets || {};
window.comfyAPI.widgets.updateControlWidgetLabel = updateControlWidgetLabel;
window.comfyAPI.widgets.addValueControlWidget = addValueControlWidget;
window.comfyAPI.widgets.addValueControlWidgets = addValueControlWidgets;
window.comfyAPI.widgets.initWidgets = initWidgets;
window.comfyAPI.widgets.ComfyWidgets = ComfyWidgets;
const useWidgetStore = /* @__PURE__ */ defineStore("widget", () => {
  const coreWidgets = ComfyWidgets;
  const customWidgets = ref({});
  const widgets = computed(() => ({
    ...customWidgets.value,
    ...coreWidgets
  }));
  function getWidgetType(type, inputName) {
    if (type === "COMBO") {
      return "COMBO";
    } else if (`${type}:${inputName}` in widgets.value) {
      return `${type}:${inputName}`;
    } else if (type in widgets.value) {
      return type;
    } else {
      return null;
    }
  }
  __name(getWidgetType, "getWidgetType");
  function inputIsWidget(spec) {
    return getWidgetType(spec.type, spec.name) !== null;
  }
  __name(inputIsWidget, "inputIsWidget");
  function registerCustomWidgets(newWidgets) {
    customWidgets.value = {
      ...customWidgets.value,
      ...newWidgets
    };
  }
  __name(registerCustomWidgets, "registerCustomWidgets");
  return {
    widgets,
    getWidgetType,
    inputIsWidget,
    registerCustomWidgets
  };
});
const useExtensionStore = /* @__PURE__ */ defineStore("extension", () => {
  const extensionByName = ref({});
  const extensions = computed(() => Object.values(extensionByName.value));
  const disabledExtensionNames = ref(/* @__PURE__ */ new Set());
  const inactiveDisabledExtensionNames = computed(() => {
    return Array.from(disabledExtensionNames.value).filter(
      (name) => !(name in extensionByName.value)
    );
  });
  const isExtensionEnabled = /* @__PURE__ */ __name((name) => !disabledExtensionNames.value.has(name), "isExtensionEnabled");
  const enabledExtensions = computed(() => {
    return extensions.value.filter((ext) => isExtensionEnabled(ext.name));
  });
  function registerExtension(extension) {
    if (!extension.name) {
      throw new Error("Extensions must have a 'name' property.");
    }
    if (extensionByName.value[extension.name]) {
      throw new Error(`Extension named '${extension.name}' already registered.`);
    }
    if (disabledExtensionNames.value.has(extension.name)) {
      console.log(`Extension ${extension.name} is disabled.`);
    }
    extensionByName.value[extension.name] = markRaw(extension);
    useKeybindingStore().loadExtensionKeybindings(extension);
    useCommandStore().loadExtensionCommands(extension);
    useMenuItemStore().loadExtensionMenuCommands(extension);
    useSettingStore().loadExtensionSettings(extension);
    useBottomPanelStore().registerExtensionBottomPanelTabs(extension);
    if (extension.getCustomWidgets) {
      ;
      (async () => {
        if (extension.getCustomWidgets) {
          const widgets = await extension.getCustomWidgets(app$1);
          useWidgetStore().registerCustomWidgets(widgets);
        }
      })();
    }
    app$1.extensions.push(extension);
  }
  __name(registerExtension, "registerExtension");
  function loadDisabledExtensionNames() {
    disabledExtensionNames.value = new Set(
      useSettingStore().get("Comfy.Extension.Disabled")
    );
    disabledExtensionNames.value.add("pysssss.Locking");
    disabledExtensionNames.value.add("pysssss.SnapToGrid");
  }
  __name(loadDisabledExtensionNames, "loadDisabledExtensionNames");
  for (const ext of app$1.extensions) {
    extensionByName.value[ext.name] = markRaw(ext);
  }
  return {
    extensions,
    enabledExtensions,
    inactiveDisabledExtensionNames,
    isExtensionEnabled,
    registerExtension,
    loadDisabledExtensionNames
  };
});
const useAboutPanelStore = /* @__PURE__ */ defineStore("aboutPanel", () => {
  const frontendVersion = "1.3.44";
  const extensionStore = useExtensionStore();
  const systemStatsStore = useSystemStatsStore();
  const coreVersion = computed(
    () => systemStatsStore?.systemStats?.system?.comfyui_version ?? ""
  );
  const coreBadges = computed(() => [
    {
      label: `ComfyUI ${coreVersion.value}`,
      url: "https://github.com/comfyanonymous/ComfyUI",
      icon: "pi pi-github"
    },
    {
      label: `ComfyUI_frontend v${frontendVersion}`,
      url: "https://github.com/Comfy-Org/ComfyUI_frontend",
      icon: "pi pi-github"
    },
    {
      label: "Discord",
      url: "https://www.comfy.org/discord",
      icon: "pi pi-discord"
    },
    { label: "ComfyOrg", url: "https://www.comfy.org/", icon: "pi pi-globe" }
  ]);
  const allBadges = computed(() => [
    ...coreBadges.value,
    ...extensionStore.extensions.flatMap((e) => e.aboutPageBadges ?? [])
  ]);
  return {
    badges: allBadges
  };
});
var script$r = {
  name: "ChevronLeftIcon",
  "extends": script$X
};
var _hoisted_1$O = /* @__PURE__ */ createBaseVNode("path", {
  d: "M9.61296 13C9.50997 13.0005 9.40792 12.9804 9.3128 12.9409C9.21767 12.9014 9.13139 12.8433 9.05902 12.7701L3.83313 7.54416C3.68634 7.39718 3.60388 7.19795 3.60388 6.99022C3.60388 6.78249 3.68634 6.58325 3.83313 6.43628L9.05902 1.21039C9.20762 1.07192 9.40416 0.996539 9.60724 1.00012C9.81032 1.00371 10.0041 1.08597 10.1477 1.22959C10.2913 1.37322 10.3736 1.56698 10.3772 1.77005C10.3808 1.97313 10.3054 2.16968 10.1669 2.31827L5.49496 6.99022L10.1669 11.6622C10.3137 11.8091 10.3962 12.0084 10.3962 12.2161C10.3962 12.4238 10.3137 12.6231 10.1669 12.7701C10.0945 12.8433 10.0083 12.9014 9.91313 12.9409C9.81801 12.9804 9.71596 13.0005 9.61296 13Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$B = [_hoisted_1$O];
function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$B, 16);
}
__name(render$q, "render$q");
script$r.render = render$q;
var script$q = {
  name: "ChevronRightIcon",
  "extends": script$X
};
var _hoisted_1$N = /* @__PURE__ */ createBaseVNode("path", {
  d: "M4.38708 13C4.28408 13.0005 4.18203 12.9804 4.08691 12.9409C3.99178 12.9014 3.9055 12.8433 3.83313 12.7701C3.68634 12.6231 3.60388 12.4238 3.60388 12.2161C3.60388 12.0084 3.68634 11.8091 3.83313 11.6622L8.50507 6.99022L3.83313 2.31827C3.69467 2.16968 3.61928 1.97313 3.62287 1.77005C3.62645 1.56698 3.70872 1.37322 3.85234 1.22959C3.99596 1.08597 4.18972 1.00371 4.3928 1.00012C4.59588 0.996539 4.79242 1.07192 4.94102 1.21039L10.1669 6.43628C10.3137 6.58325 10.3962 6.78249 10.3962 6.99022C10.3962 7.19795 10.3137 7.39718 10.1669 7.54416L4.94102 12.7701C4.86865 12.8433 4.78237 12.9014 4.68724 12.9409C4.59212 12.9804 4.49007 13.0005 4.38708 13Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$A = [_hoisted_1$N];
function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$A, 16);
}
__name(render$p, "render$p");
script$q.render = render$p;
var theme$f = /* @__PURE__ */ __name(function theme22(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-tabview-tablist-container {\n    position: relative;\n}\n\n.p-tabview-scrollable > .p-tabview-tablist-container {\n    overflow: hidden;\n}\n\n.p-tabview-tablist-scroll-container {\n    overflow-x: auto;\n    overflow-y: hidden;\n    scroll-behavior: smooth;\n    scrollbar-width: none;\n    overscroll-behavior: contain auto;\n}\n\n.p-tabview-tablist-scroll-container::-webkit-scrollbar {\n    display: none;\n}\n\n.p-tabview-tablist {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    flex: 1 1 auto;\n    background: ".concat(dt2("tabview.tab.list.background"), ";\n    border: 1px solid ").concat(dt2("tabview.tab.list.border.color"), ";\n    border-width: 0 0 1px 0;\n    position: relative;\n}\n\n.p-tabview-tab-header {\n    cursor: pointer;\n    user-select: none;\n    display: flex;\n    align-items: center;\n    text-decoration: none;\n    position: relative;\n    overflow: hidden;\n    border-style: solid;\n    border-width: 0 0 1px 0;\n    border-color: transparent transparent ").concat(dt2("tabview.tab.border.color"), " transparent;\n    color: ").concat(dt2("tabview.tab.color"), ";\n    padding: 1rem 1.125rem;\n    font-weight: 600;\n    border-top-right-radius: ").concat(dt2("border.radius.md"), ";\n    border-top-left-radius: ").concat(dt2("border.radius.md"), ";\n    transition: color ").concat(dt2("tabview.transition.duration"), ", outline-color ").concat(dt2("tabview.transition.duration"), ";\n    margin: 0 0 -1px 0;\n    outline-color: transparent;\n}\n\n.p-tabview-tablist-item:not(.p-disabled) .p-tabview-tab-header:focus-visible {\n    outline: ").concat(dt2("focus.ring.width"), " ").concat(dt2("focus.ring.style"), " ").concat(dt2("focus.ring.color"), ";\n    outline-offset: -1px;\n}\n\n.p-tabview-tablist-item:not(.p-highlight):not(.p-disabled):hover > .p-tabview-tab-header {\n    color: ").concat(dt2("tabview.tab.hover.color"), ";\n}\n\n.p-tabview-tablist-item.p-highlight > .p-tabview-tab-header {\n    color: ").concat(dt2("tabview.tab.active.color"), ";\n}\n\n.p-tabview-tab-title {\n    line-height: 1;\n    white-space: nowrap;\n}\n\n.p-tabview-next-button,\n.p-tabview-prev-button {\n    position: absolute;\n    top: 0;\n    margin: 0;\n    padding: 0;\n    z-index: 2;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: ").concat(dt2("tabview.nav.button.background"), ";\n    color: ").concat(dt2("tabview.nav.button.color"), ";\n    width: 2.5rem;\n    border-radius: 0;\n    outline-color: transparent;\n    transition: color ").concat(dt2("tabview.transition.duration"), ", outline-color ").concat(dt2("tabview.transition.duration"), ";\n    box-shadow: ").concat(dt2("tabview.nav.button.shadow"), ";\n    border: none;\n    cursor: pointer;\n    user-select: none;\n}\n\n.p-tabview-next-button:focus-visible,\n.p-tabview-prev-button:focus-visible {\n    outline: ").concat(dt2("focus.ring.width"), " ").concat(dt2("focus.ring.style"), " ").concat(dt2("focus.ring.color"), ";\n    outline-offset: ").concat(dt2("focus.ring.offset"), ";\n}\n\n.p-tabview-next-button:hover,\n.p-tabview-prev-button:hover {\n    color: ").concat(dt2("tabview.nav.button.hover.color"), ";\n}\n\n.p-tabview-prev-button {\n    left: 0;\n}\n\n.p-tabview-next-button {\n    right: 0;\n}\n\n.p-tabview-panels {\n    background: ").concat(dt2("tabview.tab.panel.background"), ";\n    color: ").concat(dt2("tabview.tab.panel.color"), ";\n    padding: 0.875rem 1.125rem 1.125rem 1.125rem;\n}\n\n.p-tabview-ink-bar {\n    z-index: 1;\n    display: block;\n    position: absolute;\n    bottom: -1px;\n    height: 1px;\n    background: ").concat(dt2("tabview.tab.active.border.color"), ";\n    transition: 250ms cubic-bezier(0.35, 0, 0.25, 1);\n}\n");
}, "theme");
var classes$f = {
  root: /* @__PURE__ */ __name(function root15(_ref2) {
    var props = _ref2.props;
    return ["p-tabview p-component", {
      "p-tabview-scrollable": props.scrollable
    }];
  }, "root"),
  navContainer: "p-tabview-tablist-container",
  prevButton: "p-tabview-prev-button",
  navContent: "p-tabview-tablist-scroll-container",
  nav: "p-tabview-tablist",
  tab: {
    header: /* @__PURE__ */ __name(function header(_ref3) {
      var instance = _ref3.instance, tab = _ref3.tab, index2 = _ref3.index;
      return ["p-tabview-tablist-item", instance.getTabProp(tab, "headerClass"), {
        "p-tabview-tablist-item-active": instance.d_activeIndex === index2,
        "p-disabled": instance.getTabProp(tab, "disabled")
      }];
    }, "header"),
    headerAction: "p-tabview-tab-header",
    headerTitle: "p-tabview-tab-title",
    content: /* @__PURE__ */ __name(function content(_ref4) {
      var instance = _ref4.instance, tab = _ref4.tab;
      return ["p-tabview-panel", instance.getTabProp(tab, "contentClass")];
    }, "content")
  },
  inkbar: "p-tabview-ink-bar",
  nextButton: "p-tabview-next-button",
  panelContainer: "p-tabview-panels"
};
var TabViewStyle = BaseStyle.extend({
  name: "tabview",
  theme: theme$f,
  classes: classes$f
});
var script$1$e = {
  name: "BaseTabView",
  "extends": script$Y,
  props: {
    activeIndex: {
      type: Number,
      "default": 0
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    scrollable: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    prevButtonProps: {
      type: null,
      "default": null
    },
    nextButtonProps: {
      type: null,
      "default": null
    },
    prevIcon: {
      type: String,
      "default": void 0
    },
    nextIcon: {
      type: String,
      "default": void 0
    }
  },
  style: TabViewStyle,
  provide: /* @__PURE__ */ __name(function provide24() {
    return {
      $pcTabs: void 0,
      // Backwards compatible to prevent <TabPanel> component from breaking
      $pcTabView: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$p = {
  name: "TabView",
  "extends": script$1$e,
  inheritAttrs: false,
  emits: ["update:activeIndex", "tab-change", "tab-click"],
  data: /* @__PURE__ */ __name(function data9() {
    return {
      id: this.$attrs.id,
      d_activeIndex: this.activeIndex,
      isPrevButtonDisabled: true,
      isNextButtonDisabled: false
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId5(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    activeIndex: /* @__PURE__ */ __name(function activeIndex(newValue) {
      this.d_activeIndex = newValue;
      this.scrollInView({
        index: newValue
      });
    }, "activeIndex")
  },
  mounted: /* @__PURE__ */ __name(function mounted8() {
    console.warn("Deprecated since v4. Use Tabs component instead.");
    this.id = this.id || UniqueComponentId();
    this.updateInkBar();
    this.scrollable && this.updateButtonState();
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated5() {
    this.updateInkBar();
    this.scrollable && this.updateButtonState();
  }, "updated"),
  methods: {
    isTabPanel: /* @__PURE__ */ __name(function isTabPanel(child) {
      return child.type.name === "TabPanel";
    }, "isTabPanel"),
    isTabActive: /* @__PURE__ */ __name(function isTabActive(index2) {
      return this.d_activeIndex === index2;
    }, "isTabActive"),
    getTabProp: /* @__PURE__ */ __name(function getTabProp(tab, name) {
      return tab.props ? tab.props[name] : void 0;
    }, "getTabProp"),
    getKey: /* @__PURE__ */ __name(function getKey(tab, index2) {
      return this.getTabProp(tab, "header") || index2;
    }, "getKey"),
    getTabHeaderActionId: /* @__PURE__ */ __name(function getTabHeaderActionId(index2) {
      return "".concat(this.id, "_").concat(index2, "_header_action");
    }, "getTabHeaderActionId"),
    getTabContentId: /* @__PURE__ */ __name(function getTabContentId(index2) {
      return "".concat(this.id, "_").concat(index2, "_content");
    }, "getTabContentId"),
    getTabPT: /* @__PURE__ */ __name(function getTabPT(tab, key, index2) {
      var count = this.tabs.length;
      var tabMetaData = {
        props: tab.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: index2,
          count,
          first: index2 === 0,
          last: index2 === count - 1,
          active: this.isTabActive(index2)
        }
      };
      return mergeProps(this.ptm("tabpanel.".concat(key), {
        tabpanel: tabMetaData
      }), this.ptm("tabpanel.".concat(key), tabMetaData), this.ptmo(this.getTabProp(tab, "pt"), key, tabMetaData));
    }, "getTabPT"),
    onScroll: /* @__PURE__ */ __name(function onScroll3(event2) {
      this.scrollable && this.updateButtonState();
      event2.preventDefault();
    }, "onScroll"),
    onPrevButtonClick: /* @__PURE__ */ __name(function onPrevButtonClick() {
      var content2 = this.$refs.content;
      var width2 = getWidth(content2);
      var pos2 = content2.scrollLeft - width2;
      content2.scrollLeft = pos2 <= 0 ? 0 : pos2;
    }, "onPrevButtonClick"),
    onNextButtonClick: /* @__PURE__ */ __name(function onNextButtonClick() {
      var content2 = this.$refs.content;
      var width2 = getWidth(content2) - this.getVisibleButtonWidths();
      var pos2 = content2.scrollLeft + width2;
      var lastPos = content2.scrollWidth - width2;
      content2.scrollLeft = pos2 >= lastPos ? lastPos : pos2;
    }, "onNextButtonClick"),
    onTabClick: /* @__PURE__ */ __name(function onTabClick(event2, tab, index2) {
      this.changeActiveIndex(event2, tab, index2);
      this.$emit("tab-click", {
        originalEvent: event2,
        index: index2
      });
    }, "onTabClick"),
    onTabKeyDown: /* @__PURE__ */ __name(function onTabKeyDown(event2, tab, index2) {
      switch (event2.code) {
        case "ArrowLeft":
          this.onTabArrowLeftKey(event2);
          break;
        case "ArrowRight":
          this.onTabArrowRightKey(event2);
          break;
        case "Home":
          this.onTabHomeKey(event2);
          break;
        case "End":
          this.onTabEndKey(event2);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.onTabEnterKey(event2, tab, index2);
          break;
      }
    }, "onTabKeyDown"),
    onTabArrowRightKey: /* @__PURE__ */ __name(function onTabArrowRightKey(event2) {
      var nextHeaderAction = this.findNextHeaderAction(event2.target.parentElement);
      nextHeaderAction ? this.changeFocusedTab(event2, nextHeaderAction) : this.onTabHomeKey(event2);
      event2.preventDefault();
    }, "onTabArrowRightKey"),
    onTabArrowLeftKey: /* @__PURE__ */ __name(function onTabArrowLeftKey(event2) {
      var prevHeaderAction = this.findPrevHeaderAction(event2.target.parentElement);
      prevHeaderAction ? this.changeFocusedTab(event2, prevHeaderAction) : this.onTabEndKey(event2);
      event2.preventDefault();
    }, "onTabArrowLeftKey"),
    onTabHomeKey: /* @__PURE__ */ __name(function onTabHomeKey(event2) {
      var firstHeaderAction = this.findFirstHeaderAction();
      this.changeFocusedTab(event2, firstHeaderAction);
      event2.preventDefault();
    }, "onTabHomeKey"),
    onTabEndKey: /* @__PURE__ */ __name(function onTabEndKey(event2) {
      var lastHeaderAction = this.findLastHeaderAction();
      this.changeFocusedTab(event2, lastHeaderAction);
      event2.preventDefault();
    }, "onTabEndKey"),
    onPageDownKey: /* @__PURE__ */ __name(function onPageDownKey3(event2) {
      this.scrollInView({
        index: this.$refs.nav.children.length - 2
      });
      event2.preventDefault();
    }, "onPageDownKey"),
    onPageUpKey: /* @__PURE__ */ __name(function onPageUpKey3(event2) {
      this.scrollInView({
        index: 0
      });
      event2.preventDefault();
    }, "onPageUpKey"),
    onTabEnterKey: /* @__PURE__ */ __name(function onTabEnterKey(event2, tab, index2) {
      this.changeActiveIndex(event2, tab, index2);
      event2.preventDefault();
    }, "onTabEnterKey"),
    findNextHeaderAction: /* @__PURE__ */ __name(function findNextHeaderAction(tabElement) {
      var selfCheck = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var headerElement = selfCheck ? tabElement : tabElement.nextElementSibling;
      return headerElement ? getAttribute(headerElement, "data-p-disabled") || getAttribute(headerElement, "data-pc-section") === "inkbar" ? this.findNextHeaderAction(headerElement) : findSingle(headerElement, '[data-pc-section="headeraction"]') : null;
    }, "findNextHeaderAction"),
    findPrevHeaderAction: /* @__PURE__ */ __name(function findPrevHeaderAction(tabElement) {
      var selfCheck = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var headerElement = selfCheck ? tabElement : tabElement.previousElementSibling;
      return headerElement ? getAttribute(headerElement, "data-p-disabled") || getAttribute(headerElement, "data-pc-section") === "inkbar" ? this.findPrevHeaderAction(headerElement) : findSingle(headerElement, '[data-pc-section="headeraction"]') : null;
    }, "findPrevHeaderAction"),
    findFirstHeaderAction: /* @__PURE__ */ __name(function findFirstHeaderAction() {
      return this.findNextHeaderAction(this.$refs.nav.firstElementChild, true);
    }, "findFirstHeaderAction"),
    findLastHeaderAction: /* @__PURE__ */ __name(function findLastHeaderAction() {
      return this.findPrevHeaderAction(this.$refs.nav.lastElementChild, true);
    }, "findLastHeaderAction"),
    changeActiveIndex: /* @__PURE__ */ __name(function changeActiveIndex(event2, tab, index2) {
      if (!this.getTabProp(tab, "disabled") && this.d_activeIndex !== index2) {
        this.d_activeIndex = index2;
        this.$emit("update:activeIndex", index2);
        this.$emit("tab-change", {
          originalEvent: event2,
          index: index2
        });
        this.scrollInView({
          index: index2
        });
      }
    }, "changeActiveIndex"),
    changeFocusedTab: /* @__PURE__ */ __name(function changeFocusedTab(event2, element) {
      if (element) {
        focus(element);
        this.scrollInView({
          element
        });
        if (this.selectOnFocus) {
          var index2 = parseInt(element.parentElement.dataset.pcIndex, 10);
          var tab = this.tabs[index2];
          this.changeActiveIndex(event2, tab, index2);
        }
      }
    }, "changeFocusedTab"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView5(_ref) {
      var element = _ref.element, _ref$index = _ref.index, index2 = _ref$index === void 0 ? -1 : _ref$index;
      var currentElement = element || this.$refs.nav.children[index2];
      if (currentElement) {
        currentElement.scrollIntoView && currentElement.scrollIntoView({
          block: "nearest"
        });
      }
    }, "scrollInView"),
    updateInkBar: /* @__PURE__ */ __name(function updateInkBar() {
      var tabHeader = this.$refs.nav.children[this.d_activeIndex];
      this.$refs.inkbar.style.width = getWidth(tabHeader) + "px";
      this.$refs.inkbar.style.left = getOffset(tabHeader).left - getOffset(this.$refs.nav).left + "px";
    }, "updateInkBar"),
    updateButtonState: /* @__PURE__ */ __name(function updateButtonState() {
      var content2 = this.$refs.content;
      var scrollLeft = content2.scrollLeft, scrollWidth2 = content2.scrollWidth;
      var width2 = getWidth(content2);
      this.isPrevButtonDisabled = scrollLeft === 0;
      this.isNextButtonDisabled = parseInt(scrollLeft) === scrollWidth2 - width2;
    }, "updateButtonState"),
    getVisibleButtonWidths: /* @__PURE__ */ __name(function getVisibleButtonWidths() {
      var _this$$refs = this.$refs, prevBtn = _this$$refs.prevBtn, nextBtn = _this$$refs.nextBtn;
      return [prevBtn, nextBtn].reduce(function(acc, el) {
        return el ? acc + getWidth(el) : acc;
      }, 0);
    }, "getVisibleButtonWidths")
  },
  computed: {
    tabs: /* @__PURE__ */ __name(function tabs() {
      var _this = this;
      return this.$slots["default"]().reduce(function(tabs2, child) {
        if (_this.isTabPanel(child)) {
          tabs2.push(child);
        } else if (child.children && child.children instanceof Array) {
          child.children.forEach(function(nestedChild) {
            if (_this.isTabPanel(nestedChild)) {
              tabs2.push(nestedChild);
            }
          });
        }
        return tabs2;
      }, []);
    }, "tabs"),
    prevButtonAriaLabel: /* @__PURE__ */ __name(function prevButtonAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.previous : void 0;
    }, "prevButtonAriaLabel"),
    nextButtonAriaLabel: /* @__PURE__ */ __name(function nextButtonAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.next : void 0;
    }, "nextButtonAriaLabel")
  },
  directives: {
    ripple: Ripple
  },
  components: {
    ChevronLeftIcon: script$r,
    ChevronRightIcon: script$q
  }
};
function _typeof$9(o) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$9(o);
}
__name(_typeof$9, "_typeof$9");
function ownKeys$b(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$b, "ownKeys$b");
function _objectSpread$b(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$b(Object(t), true).forEach(function(r2) {
      _defineProperty$9(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$b, "_objectSpread$b");
function _defineProperty$9(e, r, t) {
  return (r = _toPropertyKey$8(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$9, "_defineProperty$9");
function _toPropertyKey$8(t) {
  var i2 = _toPrimitive$8(t, "string");
  return "symbol" == _typeof$9(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$8, "_toPropertyKey$8");
function _toPrimitive$8(t, r) {
  if ("object" != _typeof$9(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$9(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$8, "_toPrimitive$8");
var _hoisted_1$M = ["tabindex", "aria-label"];
var _hoisted_2$z = ["data-p-active", "data-p-disabled", "data-pc-index"];
var _hoisted_3$j = ["id", "tabindex", "aria-disabled", "aria-selected", "aria-controls", "onClick", "onKeydown"];
var _hoisted_4$e = ["tabindex", "aria-label"];
var _hoisted_5$9 = ["id", "aria-labelledby", "data-pc-index", "data-p-active"];
function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "tablist"
  }, _ctx.ptmi("root")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("navContainer")
  }, _ctx.ptm("navContainer")), [_ctx.scrollable && !$data.isPrevButtonDisabled ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    ref: "prevBtn",
    type: "button",
    "class": _ctx.cx("prevButton"),
    tabindex: _ctx.tabindex,
    "aria-label": $options.prevButtonAriaLabel,
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onPrevButtonClick && $options.onPrevButtonClick.apply($options, arguments);
    })
  }, _objectSpread$b(_objectSpread$b({}, _ctx.prevButtonProps), _ctx.ptm("prevButton")), {
    "data-pc-group-section": "navbutton"
  }), [renderSlot(_ctx.$slots, "previcon", {}, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.prevIcon ? "span" : "ChevronLeftIcon"), mergeProps({
      "aria-hidden": "true",
      "class": _ctx.prevIcon
    }, _ctx.ptm("prevIcon")), null, 16, ["class"]))];
  })], 16, _hoisted_1$M)), [[_directive_ripple]]) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    ref: "content",
    "class": _ctx.cx("navContent"),
    onScroll: _cache[1] || (_cache[1] = function() {
      return $options.onScroll && $options.onScroll.apply($options, arguments);
    })
  }, _ctx.ptm("navContent")), [createBaseVNode("ul", mergeProps({
    ref: "nav",
    "class": _ctx.cx("nav")
  }, _ctx.ptm("nav")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.tabs, function(tab, index2) {
    return openBlock(), createElementBlock("li", mergeProps({
      key: $options.getKey(tab, index2),
      style: $options.getTabProp(tab, "headerStyle"),
      "class": _ctx.cx("tab.header", {
        tab,
        index: index2
      }),
      role: "presentation",
      ref_for: true
    }, _objectSpread$b(_objectSpread$b(_objectSpread$b({}, $options.getTabProp(tab, "headerProps")), $options.getTabPT(tab, "root", index2)), $options.getTabPT(tab, "header", index2)), {
      "data-pc-name": "tabpanel",
      "data-p-active": $data.d_activeIndex === index2,
      "data-p-disabled": $options.getTabProp(tab, "disabled"),
      "data-pc-index": index2
    }), [withDirectives((openBlock(), createElementBlock("a", mergeProps({
      id: $options.getTabHeaderActionId(index2),
      "class": _ctx.cx("tab.headerAction"),
      tabindex: $options.getTabProp(tab, "disabled") || !$options.isTabActive(index2) ? -1 : _ctx.tabindex,
      role: "tab",
      "aria-disabled": $options.getTabProp(tab, "disabled"),
      "aria-selected": $options.isTabActive(index2),
      "aria-controls": $options.getTabContentId(index2),
      onClick: /* @__PURE__ */ __name(function onClick3($event) {
        return $options.onTabClick($event, tab, index2);
      }, "onClick"),
      onKeydown: /* @__PURE__ */ __name(function onKeydown3($event) {
        return $options.onTabKeyDown($event, tab, index2);
      }, "onKeydown"),
      ref_for: true
    }, _objectSpread$b(_objectSpread$b({}, $options.getTabProp(tab, "headerActionProps")), $options.getTabPT(tab, "headerAction", index2))), [tab.props && tab.props.header ? (openBlock(), createElementBlock("span", mergeProps({
      key: 0,
      "class": _ctx.cx("tab.headerTitle"),
      ref_for: true
    }, $options.getTabPT(tab, "headerTitle", index2)), toDisplayString$1(tab.props.header), 17)) : createCommentVNode("", true), tab.children && tab.children.header ? (openBlock(), createBlock(resolveDynamicComponent(tab.children.header), {
      key: 1
    })) : createCommentVNode("", true)], 16, _hoisted_3$j)), [[_directive_ripple]])], 16, _hoisted_2$z);
  }), 128)), createBaseVNode("li", mergeProps({
    ref: "inkbar",
    "class": _ctx.cx("inkbar"),
    role: "presentation",
    "aria-hidden": "true"
  }, _ctx.ptm("inkbar")), null, 16)], 16)], 16), _ctx.scrollable && !$data.isNextButtonDisabled ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 1,
    ref: "nextBtn",
    type: "button",
    "class": _ctx.cx("nextButton"),
    tabindex: _ctx.tabindex,
    "aria-label": $options.nextButtonAriaLabel,
    onClick: _cache[2] || (_cache[2] = function() {
      return $options.onNextButtonClick && $options.onNextButtonClick.apply($options, arguments);
    })
  }, _objectSpread$b(_objectSpread$b({}, _ctx.nextButtonProps), _ctx.ptm("nextButton")), {
    "data-pc-group-section": "navbutton"
  }), [renderSlot(_ctx.$slots, "nexticon", {}, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.nextIcon ? "span" : "ChevronRightIcon"), mergeProps({
      "aria-hidden": "true",
      "class": _ctx.nextIcon
    }, _ctx.ptm("nextIcon")), null, 16, ["class"]))];
  })], 16, _hoisted_4$e)), [[_directive_ripple]]) : createCommentVNode("", true)], 16), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("panelContainer")
  }, _ctx.ptm("panelContainer")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.tabs, function(tab, index2) {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.getKey(tab, index2)
    }, [(_ctx.lazy ? $options.isTabActive(index2) : true) ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
      key: 0,
      id: $options.getTabContentId(index2),
      style: $options.getTabProp(tab, "contentStyle"),
      "class": _ctx.cx("tab.content", {
        tab
      }),
      role: "tabpanel",
      "aria-labelledby": $options.getTabHeaderActionId(index2),
      ref_for: true
    }, _objectSpread$b(_objectSpread$b(_objectSpread$b({}, $options.getTabProp(tab, "contentProps")), $options.getTabPT(tab, "root", index2)), $options.getTabPT(tab, "content", index2)), {
      "data-pc-name": "tabpanel",
      "data-pc-index": index2,
      "data-p-active": $data.d_activeIndex === index2
    }), [(openBlock(), createBlock(resolveDynamicComponent(tab)))], 16, _hoisted_5$9)), [[vShow, _ctx.lazy ? true : $options.isTabActive(index2)]]) : createCommentVNode("", true)], 64);
  }), 128))], 16)], 16);
}
__name(render$o, "render$o");
script$p.render = render$o;
const _hoisted_1$L = { class: "grid grid-cols-2 gap-2" };
const _hoisted_2$y = { class: "font-medium" };
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "DeviceInfo",
  props: {
    device: {}
  },
  setup(__props) {
    const props = __props;
    const deviceColumns = [
      { field: "name", header: "Name" },
      { field: "type", header: "Type" },
      { field: "vram_total", header: "VRAM Total" },
      { field: "vram_free", header: "VRAM Free" },
      { field: "torch_vram_total", header: "Torch VRAM Total" },
      { field: "torch_vram_free", header: "Torch VRAM Free" }
    ];
    const formatValue2 = /* @__PURE__ */ __name((value3, field) => {
      if (["vram_total", "vram_free", "torch_vram_total", "torch_vram_free"].includes(
        field
      )) {
        return formatSize(value3);
      }
      return value3;
    }, "formatValue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$L, [
        (openBlock(), createElementBlock(Fragment, null, renderList(deviceColumns, (col) => {
          return openBlock(), createElementBlock(Fragment, {
            key: col.field
          }, [
            createBaseVNode("div", _hoisted_2$y, toDisplayString$1(_ctx.$t(col.header)), 1),
            createBaseVNode("div", null, toDisplayString$1(formatValue2(props.device[col.field], col.field)), 1)
          ], 64);
        }), 64))
      ]);
    };
  }
});
const _hoisted_1$K = { class: "system-stats" };
const _hoisted_2$x = { class: "mb-6" };
const _hoisted_3$i = { class: "text-2xl font-semibold mb-4" };
const _hoisted_4$d = { class: "grid grid-cols-2 gap-2" };
const _hoisted_5$8 = { class: "font-medium" };
const _hoisted_6$6 = { class: "text-2xl font-semibold mb-4" };
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "SystemStatsPanel",
  props: {
    stats: {}
  },
  setup(__props) {
    const props = __props;
    const systemInfo = computed(() => ({
      ...props.stats.system,
      argv: props.stats.system.argv.join(" ")
    }));
    const systemColumns = [
      { field: "os", header: "OS" },
      { field: "python_version", header: "Python Version" },
      { field: "embedded_python", header: "Embedded Python" },
      { field: "pytorch_version", header: "Pytorch Version" },
      { field: "argv", header: "Arguments" },
      { field: "ram_total", header: "RAM Total" },
      { field: "ram_free", header: "RAM Free" }
    ];
    const formatValue2 = /* @__PURE__ */ __name((value3, field) => {
      if (["ram_total", "ram_free"].includes(field)) {
        return formatSize(value3);
      }
      return value3;
    }, "formatValue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$K, [
        createBaseVNode("div", _hoisted_2$x, [
          createBaseVNode("h2", _hoisted_3$i, toDisplayString$1(_ctx.$t("systemInfo")), 1),
          createBaseVNode("div", _hoisted_4$d, [
            (openBlock(), createElementBlock(Fragment, null, renderList(systemColumns, (col) => {
              return openBlock(), createElementBlock(Fragment, {
                key: col.field
              }, [
                createBaseVNode("div", _hoisted_5$8, toDisplayString$1(_ctx.$t(col.header)), 1),
                createBaseVNode("div", null, toDisplayString$1(formatValue2(systemInfo.value[col.field], col.field)), 1)
              ], 64);
            }), 64))
          ])
        ]),
        createVNode(unref(script$G)),
        createBaseVNode("div", null, [
          createBaseVNode("h2", _hoisted_6$6, toDisplayString$1(_ctx.$t("devices")), 1),
          props.stats.devices.length > 1 ? (openBlock(), createBlock(unref(script$p), { key: 0 }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(props.stats.devices, (device) => {
                return openBlock(), createBlock(unref(script$H), {
                  key: device.index,
                  header: device.name
                }, {
                  default: withCtx(() => [
                    createVNode(_sfc_main$B, { device }, null, 8, ["device"])
                  ]),
                  _: 2
                }, 1032, ["header"]);
              }), 128))
            ]),
            _: 1
          })) : (openBlock(), createBlock(_sfc_main$B, {
            key: 1,
            device: props.stats.devices[0]
          }, null, 8, ["device"]))
        ])
      ]);
    };
  }
});
const _hoisted_1$J = { class: "about-container" };
const _hoisted_2$w = { class: "text-2xl font-bold mb-2" };
const _hoisted_3$h = { class: "space-y-2" };
const _hoisted_4$c = ["href", "title"];
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "AboutPanel",
  setup(__props) {
    const systemStatsStore = useSystemStatsStore();
    const aboutPanelStore = useAboutPanelStore();
    onMounted(async () => {
      if (!systemStatsStore.systemStats) {
        await systemStatsStore.fetchSystemStats();
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$J, [
        createBaseVNode("h2", _hoisted_2$w, toDisplayString$1(_ctx.$t("about")), 1),
        createBaseVNode("div", _hoisted_3$h, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(aboutPanelStore).badges, (badge) => {
            return openBlock(), createElementBlock("a", {
              key: badge.url,
              href: badge.url,
              target: "_blank",
              rel: "noopener noreferrer",
              class: "about-badge inline-flex items-center no-underline",
              title: badge.url
            }, [
              createVNode(unref(script$w), { class: "mr-2" }, {
                icon: withCtx(() => [
                  createBaseVNode("i", {
                    class: normalizeClass([badge.icon, "mr-2 text-xl"])
                  }, null, 2)
                ]),
                default: withCtx(() => [
                  createTextVNode(" " + toDisplayString$1(badge.label), 1)
                ]),
                _: 2
              }, 1024)
            ], 8, _hoisted_4$c);
          }), 128))
        ]),
        createVNode(unref(script$G)),
        unref(systemStatsStore).systemStats ? (openBlock(), createBlock(_sfc_main$A, {
          key: 0,
          stats: unref(systemStatsStore).systemStats
        }, null, 8, ["stats"])) : createCommentVNode("", true)
      ]);
    };
  }
});
var script$o = {
  name: "ExclamationTriangleIcon",
  "extends": script$X
};
var _hoisted_1$I = /* @__PURE__ */ createBaseVNode("path", {
  d: "M13.4018 13.1893H0.598161C0.49329 13.189 0.390283 13.1615 0.299143 13.1097C0.208003 13.0578 0.131826 12.9832 0.0780112 12.8932C0.0268539 12.8015 0 12.6982 0 12.5931C0 12.4881 0.0268539 12.3848 0.0780112 12.293L6.47985 1.08982C6.53679 1.00399 6.61408 0.933574 6.70484 0.884867C6.7956 0.836159 6.897 0.810669 7 0.810669C7.103 0.810669 7.2044 0.836159 7.29516 0.884867C7.38592 0.933574 7.46321 1.00399 7.52015 1.08982L13.922 12.293C13.9731 12.3848 14 12.4881 14 12.5931C14 12.6982 13.9731 12.8015 13.922 12.8932C13.8682 12.9832 13.792 13.0578 13.7009 13.1097C13.6097 13.1615 13.5067 13.189 13.4018 13.1893ZM1.63046 11.989H12.3695L7 2.59425L1.63046 11.989Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$v = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99996 8.78801C6.84143 8.78594 6.68997 8.72204 6.57787 8.60993C6.46576 8.49782 6.40186 8.34637 6.39979 8.18784V5.38703C6.39979 5.22786 6.46302 5.0752 6.57557 4.96265C6.68813 4.85009 6.84078 4.78686 6.99996 4.78686C7.15914 4.78686 7.31179 4.85009 7.42435 4.96265C7.5369 5.0752 7.60013 5.22786 7.60013 5.38703V8.18784C7.59806 8.34637 7.53416 8.49782 7.42205 8.60993C7.30995 8.72204 7.15849 8.78594 6.99996 8.78801Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_3$g = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99996 11.1887C6.84143 11.1866 6.68997 11.1227 6.57787 11.0106C6.46576 10.8985 6.40186 10.7471 6.39979 10.5885V10.1884C6.39979 10.0292 6.46302 9.87658 6.57557 9.76403C6.68813 9.65147 6.84078 9.58824 6.99996 9.58824C7.15914 9.58824 7.31179 9.65147 7.42435 9.76403C7.5369 9.87658 7.60013 10.0292 7.60013 10.1884V10.5885C7.59806 10.7471 7.53416 10.8985 7.42205 11.0106C7.30995 11.1227 7.15849 11.1866 6.99996 11.1887Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_4$b = [_hoisted_1$I, _hoisted_2$v, _hoisted_3$g];
function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_4$b, 16);
}
__name(render$n, "render$n");
script$o.render = render$n;
var script$n = {
  name: "InfoCircleIcon",
  "extends": script$X
};
var _hoisted_1$H = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M3.11101 12.8203C4.26215 13.5895 5.61553 14 7 14C8.85652 14 10.637 13.2625 11.9497 11.9497C13.2625 10.637 14 8.85652 14 7C14 5.61553 13.5895 4.26215 12.8203 3.11101C12.0511 1.95987 10.9579 1.06266 9.67879 0.532846C8.3997 0.00303296 6.99224 -0.13559 5.63437 0.134506C4.2765 0.404603 3.02922 1.07129 2.05026 2.05026C1.07129 3.02922 0.404603 4.2765 0.134506 5.63437C-0.13559 6.99224 0.00303296 8.3997 0.532846 9.67879C1.06266 10.9579 1.95987 12.0511 3.11101 12.8203ZM3.75918 2.14976C4.71846 1.50879 5.84628 1.16667 7 1.16667C8.5471 1.16667 10.0308 1.78125 11.1248 2.87521C12.2188 3.96918 12.8333 5.45291 12.8333 7C12.8333 8.15373 12.4912 9.28154 11.8502 10.2408C11.2093 11.2001 10.2982 11.9478 9.23232 12.3893C8.16642 12.8308 6.99353 12.9463 5.86198 12.7212C4.73042 12.4962 3.69102 11.9406 2.87521 11.1248C2.05941 10.309 1.50384 9.26958 1.27876 8.13803C1.05367 7.00647 1.16919 5.83358 1.61071 4.76768C2.05222 3.70178 2.79989 2.79074 3.75918 2.14976ZM7.00002 4.8611C6.84594 4.85908 6.69873 4.79698 6.58977 4.68801C6.48081 4.57905 6.4187 4.43185 6.41669 4.27776V3.88888C6.41669 3.73417 6.47815 3.58579 6.58754 3.4764C6.69694 3.367 6.84531 3.30554 7.00002 3.30554C7.15473 3.30554 7.3031 3.367 7.4125 3.4764C7.52189 3.58579 7.58335 3.73417 7.58335 3.88888V4.27776C7.58134 4.43185 7.51923 4.57905 7.41027 4.68801C7.30131 4.79698 7.1541 4.85908 7.00002 4.8611ZM7.00002 10.6945C6.84594 10.6925 6.69873 10.6304 6.58977 10.5214C6.48081 10.4124 6.4187 10.2652 6.41669 10.1111V6.22225C6.41669 6.06754 6.47815 5.91917 6.58754 5.80977C6.69694 5.70037 6.84531 5.63892 7.00002 5.63892C7.15473 5.63892 7.3031 5.70037 7.4125 5.80977C7.52189 5.91917 7.58335 6.06754 7.58335 6.22225V10.1111C7.58134 10.2652 7.51923 10.4124 7.41027 10.5214C7.30131 10.6304 7.1541 10.6925 7.00002 10.6945Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$u = [_hoisted_1$H];
function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$u, 16);
}
__name(render$m, "render$m");
script$n.render = render$m;
var theme$e = /* @__PURE__ */ __name(function theme23(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-message {\n    border-radius: ".concat(dt2("message.border.radius"), ";\n    outline-width: ").concat(dt2("message.border.width"), ";\n    outline-style: solid;\n}\n\n.p-message-content {\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt2("message.content.padding"), ";\n    gap: ").concat(dt2("message.content.gap"), ";\n    height: 100%;\n}\n\n.p-message-icon {\n    flex-shrink: 0;\n}\n\n.p-message-close-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n    margin: 0 0 0 auto;\n    overflow: hidden;\n    position: relative;\n    width: ").concat(dt2("message.close.button.width"), ";\n    height: ").concat(dt2("message.close.button.height"), ";\n    border-radius: ").concat(dt2("message.close.button.border.radius"), ";\n    background: transparent;\n    transition: background ").concat(dt2("message.transition.duration"), ", color ").concat(dt2("message.transition.duration"), ", outline-color ").concat(dt2("message.transition.duration"), ", box-shadow ").concat(dt2("message.transition.duration"), ", opacity 0.3s;\n    outline-color: transparent;\n    color: inherit;\n    padding: 0;\n    border: none;\n    cursor: pointer;\n    user-select: none;\n}\n\n.p-message-close-icon {\n    font-size: ").concat(dt2("message.close.icon.size"), ";\n    width: ").concat(dt2("message.close.icon.size"), ";\n    height: ").concat(dt2("message.close.icon.size"), ";\n}\n\n.p-message-close-button:focus-visible {\n    outline-width: ").concat(dt2("message.close.button.focus.ring.width"), ";\n    outline-style: ").concat(dt2("message.close.button.focus.ring.style"), ";\n    outline-offset: ").concat(dt2("message.close.button.focus.ring.offset"), ";\n}\n\n.p-message-info {\n    background: ").concat(dt2("message.info.background"), ";\n    outline-color: ").concat(dt2("message.info.border.color"), ";\n    color: ").concat(dt2("message.info.color"), ";\n    box-shadow: ").concat(dt2("message.info.shadow"), ";\n}\n\n.p-message-info .p-message-close-button:focus-visible {\n    outline-color: ").concat(dt2("message.info.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("message.info.close.button.focus.ring.shadow"), ";\n}\n\n.p-message-info .p-message-close-button:hover {\n    background: ").concat(dt2("message.info.close.button.hover.background"), ";\n}\n\n.p-message-success {\n    background: ").concat(dt2("message.success.background"), ";\n    outline-color: ").concat(dt2("message.success.border.color"), ";\n    color: ").concat(dt2("message.success.color"), ";\n    box-shadow: ").concat(dt2("message.success.shadow"), ";\n}\n\n.p-message-success .p-message-close-button:focus-visible {\n    outline-color: ").concat(dt2("message.success.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("message.success.close.button.focus.ring.shadow"), ";\n}\n\n.p-message-success .p-message-close-button:hover {\n    background: ").concat(dt2("message.success.close.button.hover.background"), ";\n}\n\n.p-message-warn {\n    background: ").concat(dt2("message.warn.background"), ";\n    outline-color: ").concat(dt2("message.warn.border.color"), ";\n    color: ").concat(dt2("message.warn.color"), ";\n    box-shadow: ").concat(dt2("message.warn.shadow"), ";\n}\n\n.p-message-warn .p-message-close-button:focus-visible {\n    outline-color: ").concat(dt2("message.warn.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("message.warn.close.button.focus.ring.shadow"), ";\n}\n\n.p-message-warn .p-message-close-button:hover {\n    background: ").concat(dt2("message.warn.close.button.hover.background"), ";\n}\n\n.p-message-error {\n    background: ").concat(dt2("message.error.background"), ";\n    outline-color: ").concat(dt2("message.error.border.color"), ";\n    color: ").concat(dt2("message.error.color"), ";\n    box-shadow: ").concat(dt2("message.error.shadow"), ";\n}\n\n.p-message-error .p-message-close-button:focus-visible {\n    outline-color: ").concat(dt2("message.error.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("message.error.close.button.focus.ring.shadow"), ";\n}\n\n.p-message-error .p-message-close-button:hover {\n    background: ").concat(dt2("message.error.close.button.hover.background"), ";\n}\n\n.p-message-secondary {\n    background: ").concat(dt2("message.secondary.background"), ";\n    outline-color: ").concat(dt2("message.secondary.border.color"), ";\n    color: ").concat(dt2("message.secondary.color"), ";\n    box-shadow: ").concat(dt2("message.secondary.shadow"), ";\n}\n\n.p-message-secondary .p-message-close-button:focus-visible {\n    outline-color: ").concat(dt2("message.secondary.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("message.secondary.close.button.focus.ring.shadow"), ";\n}\n\n.p-message-secondary .p-message-close-button:hover {\n    background: ").concat(dt2("message.secondary.close.button.hover.background"), ";\n}\n\n.p-message-contrast {\n    background: ").concat(dt2("message.contrast.background"), ";\n    outline-color: ").concat(dt2("message.contrast.border.color"), ";\n    color: ").concat(dt2("message.contrast.color"), ";\n    box-shadow: ").concat(dt2("message.contrast.shadow"), ";\n}\n\n.p-message-contrast .p-message-close-button:focus-visible {\n    outline-color: ").concat(dt2("message.contrast.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt2("message.contrast.close.button.focus.ring.shadow"), ";\n}\n\n.p-message-contrast .p-message-close-button:hover {\n    background: ").concat(dt2("message.contrast.close.button.hover.background"), ";\n}\n\n.p-message-text {\n    font-size: ").concat(dt2("message.text.font.size"), ";\n    font-weight: ").concat(dt2("message.text.font.weight"), ";\n}\n\n.p-message-icon {\n    font-size: ").concat(dt2("message.icon.size"), ";\n    width: ").concat(dt2("message.icon.size"), ";\n    height: ").concat(dt2("message.icon.size"), ";\n}\n\n.p-message-enter-from {\n    opacity: 0;\n}\n\n.p-message-enter-active {\n    transition: opacity 0.3s;\n}\n\n.p-message.p-message-leave-from {\n    max-height: 1000px;\n}\n\n.p-message.p-message-leave-to {\n    max-height: 0;\n    opacity: 0;\n    margin: 0;\n}\n\n.p-message-leave-active {\n    overflow: hidden;\n    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1), opacity 0.3s, margin 0.3s;\n}\n\n.p-message-leave-active .p-message-close-button {\n    opacity: 0;\n}\n");
}, "theme");
var classes$e = {
  root: /* @__PURE__ */ __name(function root16(_ref2) {
    var props = _ref2.props;
    return "p-message p-component p-message-" + props.severity;
  }, "root"),
  content: "p-message-content",
  icon: "p-message-icon",
  text: "p-message-text",
  closeButton: "p-message-close-button",
  closeIcon: "p-message-close-icon"
};
var MessageStyle = BaseStyle.extend({
  name: "message",
  theme: theme$e,
  classes: classes$e
});
var script$1$d = {
  name: "BaseMessage",
  "extends": script$Y,
  props: {
    severity: {
      type: String,
      "default": "info"
    },
    closable: {
      type: Boolean,
      "default": false
    },
    life: {
      type: Number,
      "default": null
    },
    icon: {
      type: String,
      "default": void 0
    },
    closeIcon: {
      type: String,
      "default": void 0
    },
    closeButtonProps: {
      type: null,
      "default": null
    }
  },
  style: MessageStyle,
  provide: /* @__PURE__ */ __name(function provide25() {
    return {
      $pcMessage: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$m = {
  name: "Message",
  "extends": script$1$d,
  inheritAttrs: false,
  emits: ["close", "life-end"],
  timeout: null,
  data: /* @__PURE__ */ __name(function data10() {
    return {
      visible: true
    };
  }, "data"),
  mounted: /* @__PURE__ */ __name(function mounted9() {
    var _this = this;
    if (this.life) {
      setTimeout(function() {
        _this.visible = false;
        _this.$emit("life-end");
      }, this.life);
    }
  }, "mounted"),
  methods: {
    close: /* @__PURE__ */ __name(function close2(event2) {
      this.visible = false;
      this.$emit("close", event2);
    }, "close")
  },
  computed: {
    iconComponent: /* @__PURE__ */ __name(function iconComponent() {
      return {
        info: script$n,
        success: script$V,
        warn: script$o,
        error: script$u
      }[this.severity];
    }, "iconComponent"),
    closeAriaLabel: /* @__PURE__ */ __name(function closeAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    }, "closeAriaLabel")
  },
  directives: {
    ripple: Ripple
  },
  components: {
    TimesIcon: script$A,
    InfoCircleIcon: script$n,
    CheckIcon: script$V,
    ExclamationTriangleIcon: script$o,
    TimesCircleIcon: script$u
  }
};
function _typeof$8(o) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$8(o);
}
__name(_typeof$8, "_typeof$8");
function ownKeys$a(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$a, "ownKeys$a");
function _objectSpread$a(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$a(Object(t), true).forEach(function(r2) {
      _defineProperty$8(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$a, "_objectSpread$a");
function _defineProperty$8(e, r, t) {
  return (r = _toPropertyKey$7(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$8, "_defineProperty$8");
function _toPropertyKey$7(t) {
  var i2 = _toPrimitive$7(t, "string");
  return "symbol" == _typeof$8(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$7, "_toPropertyKey$7");
function _toPrimitive$7(t, r) {
  if ("object" != _typeof$8(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$8(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$7, "_toPrimitive$7");
var _hoisted_1$G = ["aria-label"];
function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_TimesIcon = resolveComponent("TimesIcon");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createBlock(Transition, mergeProps({
    name: "p-message",
    appear: ""
  }, _ctx.ptmi("transition")), {
    "default": withCtx(function() {
      return [withDirectives(createBaseVNode("div", mergeProps({
        "class": _ctx.cx("root"),
        role: "alert",
        "aria-live": "assertive",
        "aria-atomic": "true"
      }, _ctx.ptm("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
        key: 0,
        closeCallback: $options.close
      }) : (openBlock(), createElementBlock("div", mergeProps({
        key: 1,
        "class": _ctx.cx("content")
      }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "icon", {
        "class": "p-message-icon"
      }, function() {
        return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.icon ? "span" : null), mergeProps({
          "class": [_ctx.cx("icon"), _ctx.icon]
        }, _ctx.ptm("icon")), null, 16, ["class"]))];
      }), _ctx.$slots["default"] ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        "class": ["p-message-text", _ctx.cx("text")]
      }, _ctx.ptm("text")), [renderSlot(_ctx.$slots, "default")], 16)) : createCommentVNode("", true), _ctx.closable ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
        key: 1,
        "class": _ctx.cx("closeButton"),
        "aria-label": $options.closeAriaLabel,
        type: "button",
        onClick: _cache[0] || (_cache[0] = function($event) {
          return $options.close($event);
        })
      }, _objectSpread$a(_objectSpread$a({}, _ctx.closeButtonProps), _ctx.ptm("closeButton"))), [renderSlot(_ctx.$slots, "closeicon", {}, function() {
        return [_ctx.closeIcon ? (openBlock(), createElementBlock("i", mergeProps({
          key: 0,
          "class": [_ctx.cx("closeIcon"), _ctx.closeIcon]
        }, _ctx.ptm("closeIcon")), null, 16)) : (openBlock(), createBlock(_component_TimesIcon, mergeProps({
          key: 1,
          "class": [_ctx.cx("closeIcon"), _ctx.closeIcon]
        }, _ctx.ptm("closeIcon")), null, 16, ["class"]))];
      })], 16, _hoisted_1$G)), [[_directive_ripple]]) : createCommentVNode("", true)], 16))], 16), [[vShow, $data.visible]])];
    }),
    _: 3
  }, 16);
}
__name(render$l, "render$l");
script$m.render = render$l;
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "FirstTimeUIMessage",
  setup(__props) {
    const settingStore = useSettingStore();
    const show5 = computed(() => !settingStore.exists("Comfy.UseNewMenu"));
    const handleClose = /* @__PURE__ */ __name(() => {
      const currentValue = settingStore.get("Comfy.UseNewMenu");
      settingStore.set("Comfy.UseNewMenu", currentValue);
    }, "handleClose");
    return (_ctx, _cache) => {
      return show5.value ? (openBlock(), createBlock(unref(script$m), {
        key: 0,
        class: "first-time-ui-message m-2",
        severity: "info",
        closable: true,
        onClose: handleClose
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString$1(_ctx.$t("firstTimeUIMessage")), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true);
    };
  }
});
const _withScopeId$g = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-73776114"), n = n(), popScopeId(), n), "_withScopeId$g");
const _hoisted_1$F = { class: "settings-container" };
const _hoisted_2$t = { key: 0 };
const _hoisted_3$f = /* @__PURE__ */ _withScopeId$g(() => /* @__PURE__ */ createBaseVNode("div", null, "Loading keybinding panel...", -1));
const _hoisted_4$a = /* @__PURE__ */ _withScopeId$g(() => /* @__PURE__ */ createBaseVNode("div", null, "Loading extension panel...", -1));
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "SettingDialogContent",
  setup(__props) {
    const KeybindingPanel = /* @__PURE__ */ defineAsyncComponent(
      () => __vitePreload(() => import("./KeybindingPanel-DcEfyPZZ.js"), true ? __vite__mapDeps([0,1,2,3]) : void 0, import.meta.url)
    );
    const ExtensionPanel = /* @__PURE__ */ defineAsyncComponent(
      () => __vitePreload(() => import("./ExtensionPanel-CfMfcLgI.js"), true ? __vite__mapDeps([4,1,2]) : void 0, import.meta.url)
    );
    const aboutPanelNode = {
      key: "about",
      label: "About",
      children: []
    };
    const keybindingPanelNode = {
      key: "keybinding",
      label: "Keybinding",
      children: []
    };
    const extensionPanelNode = {
      key: "extension",
      label: "Extension",
      children: []
    };
    const extensionPanelNodeList = computed(() => {
      const settingStore2 = useSettingStore();
      const showExtensionPanel = settingStore2.get("Comfy.Settings.ExtensionPanel");
      return showExtensionPanel ? [extensionPanelNode] : [];
    });
    const settingStore = useSettingStore();
    const settingRoot = computed(() => settingStore.settingTree);
    const categories = computed(() => [
      ...settingRoot.value.children || [],
      keybindingPanelNode,
      ...extensionPanelNodeList.value,
      aboutPanelNode
    ]);
    const activeCategory = ref(null);
    const searchResults = ref([]);
    watch(activeCategory, (newCategory, oldCategory) => {
      if (newCategory === null) {
        activeCategory.value = oldCategory;
      }
    });
    onMounted(() => {
      activeCategory.value = categories.value[0];
    });
    const sortedGroups = /* @__PURE__ */ __name((category) => {
      return [...category.children || []].sort(
        (a, b) => a.label.localeCompare(b.label)
      );
    }, "sortedGroups");
    const searchQuery = ref("");
    const searchInProgress = ref(false);
    watch(searchQuery, () => searchInProgress.value = true);
    const handleSearch = /* @__PURE__ */ __name((query) => {
      if (!query) {
        searchResults.value = [];
        return;
      }
      const allSettings = flattenTree(settingRoot.value);
      const filteredSettings = allSettings.filter(
        (setting) => setting.id.toLowerCase().includes(query.toLowerCase()) || setting.name.toLowerCase().includes(query.toLowerCase())
      );
      const groupedSettings = {};
      filteredSettings.forEach((setting) => {
        const groupLabel = setting.id.split(".")[1];
        if (!groupedSettings[groupLabel]) {
          groupedSettings[groupLabel] = [];
        }
        groupedSettings[groupLabel].push(setting);
      });
      searchResults.value = Object.entries(groupedSettings).map(
        ([label5, settings]) => ({
          label: label5,
          settings
        })
      );
      searchInProgress.value = false;
    }, "handleSearch");
    const inSearch = computed(
      () => searchQuery.value.length > 0 && !searchInProgress.value
    );
    const tabValue = computed(
      () => inSearch.value ? "Search Results" : activeCategory.value?.label
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$F, [
        createVNode(unref(script$F), { class: "settings-sidebar flex-shrink-0 p-2 w-48 2xl:w-64" }, {
          default: withCtx(() => [
            createVNode(SearchBox, {
              class: "settings-search-box w-full mb-2",
              modelValue: searchQuery.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
              onSearch: handleSearch,
              placeholder: _ctx.$t("searchSettings") + "..."
            }, null, 8, ["modelValue", "placeholder"]),
            createVNode(unref(script$O), {
              modelValue: activeCategory.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => activeCategory.value = $event),
              options: categories.value,
              optionLabel: "label",
              scrollHeight: "100%",
              disabled: inSearch.value,
              class: "border-none w-full"
            }, null, 8, ["modelValue", "options", "disabled"])
          ]),
          _: 1
        }),
        createVNode(unref(script$G), {
          layout: "vertical",
          class: "mx-1 2xl:mx-4"
        }),
        createVNode(unref(script$F), { class: "settings-content flex-grow" }, {
          default: withCtx(() => [
            createVNode(unref(script$J), {
              value: tabValue.value,
              lazy: true
            }, {
              default: withCtx(() => [
                tabValue.value === "Comfy" ? (openBlock(), createBlock(_sfc_main$y, { key: 0 })) : createCommentVNode("", true),
                createVNode(unref(script$I), { class: "settings-tab-panels" }, {
                  default: withCtx(() => [
                    createVNode(unref(script$H), {
                      key: "search-results",
                      value: "Search Results"
                    }, {
                      default: withCtx(() => [
                        searchResults.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_2$t, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(searchResults.value, (group, i2) => {
                            return openBlock(), createBlock(SettingGroup, {
                              key: group.label,
                              divider: i2 !== 0,
                              group
                            }, null, 8, ["divider", "group"]);
                          }), 128))
                        ])) : (openBlock(), createBlock(NoResultsPlaceholder, {
                          key: 1,
                          icon: "pi pi-search",
                          title: _ctx.$t("noResultsFound"),
                          message: _ctx.$t("searchFailedMessage")
                        }, null, 8, ["title", "message"]))
                      ]),
                      _: 1
                    }),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(categories.value, (category) => {
                      return openBlock(), createBlock(unref(script$H), {
                        key: category.key,
                        value: category.label
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(sortedGroups(category), (group, i2) => {
                            return openBlock(), createBlock(SettingGroup, {
                              key: group.label,
                              divider: i2 !== 0,
                              group: {
                                label: group.label,
                                settings: unref(flattenTree)(group)
                              }
                            }, null, 8, ["divider", "group"]);
                          }), 128))
                        ]),
                        _: 2
                      }, 1032, ["value"]);
                    }), 128)),
                    createVNode(unref(script$H), {
                      key: "about",
                      value: "About"
                    }, {
                      default: withCtx(() => [
                        createVNode(_sfc_main$z)
                      ]),
                      _: 1
                    }),
                    createVNode(unref(script$H), {
                      key: "keybinding",
                      value: "Keybinding"
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(Suspense, null, {
                          fallback: withCtx(() => [
                            _hoisted_3$f
                          ]),
                          default: withCtx(() => [
                            createVNode(unref(KeybindingPanel))
                          ]),
                          _: 1
                        }))
                      ]),
                      _: 1
                    }),
                    createVNode(unref(script$H), {
                      key: "extension",
                      value: "Extension"
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(Suspense, null, {
                          fallback: withCtx(() => [
                            _hoisted_4$a
                          ]),
                          default: withCtx(() => [
                            createVNode(unref(ExtensionPanel))
                          ]),
                          _: 1
                        }))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["value"])
          ]),
          _: 1
        })
      ]);
    };
  }
});
const SettingDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__scopeId", "data-v-73776114"]]);
const _sfc_main$w = {};
const _withScopeId$f = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-f3b37ea3"), n = n(), popScopeId(), n), "_withScopeId$f");
const _hoisted_1$E = { class: "px-4" };
const _hoisted_2$s = /* @__PURE__ */ _withScopeId$f(() => /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-cog" }, null, -1));
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, [
    createBaseVNode("h2", _hoisted_1$E, [
      _hoisted_2$s,
      createBaseVNode("span", null, toDisplayString$1(_ctx.$t("settings")), 1)
    ])
  ]);
}
__name(_sfc_render$1, "_sfc_render$1");
const SettingDialogHeader = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$1], ["__scopeId", "data-v-f3b37ea3"]]);
var PrimeVueToastSymbol = Symbol();
function useToast() {
  var PrimeVueToast = inject(PrimeVueToastSymbol);
  if (!PrimeVueToast) {
    throw new Error("No PrimeVue Toast provided!");
  }
  return PrimeVueToast;
}
__name(useToast, "useToast");
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "FindIssueButton",
  props: {
    errorMessage: {},
    repoOwner: {},
    repoName: {}
  },
  setup(__props) {
    const props = __props;
    const queryString = computed(() => props.errorMessage + " is:issue");
    const openGitHubIssues = /* @__PURE__ */ __name(() => {
      const query = encodeURIComponent(queryString.value);
      const url = `https://github.com/${props.repoOwner}/${props.repoName}/issues?q=${query}`;
      window.open(url, "_blank");
    }, "openGitHubIssues");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$M), {
        onClick: openGitHubIssues,
        label: _ctx.$t("findIssues"),
        severity: "secondary",
        icon: "pi pi-github"
      }, null, 8, ["label"]);
    };
  }
});
const _withScopeId$e = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-27b8189d"), n = n(), popScopeId(), n), "_withScopeId$e");
const _hoisted_1$D = { class: "comfy-error-report" };
const _hoisted_2$r = { class: "wrapper-pre" };
const _hoisted_3$e = { class: "action-container" };
const repoOwner = "comfyanonymous";
const repoName = "ComfyUI";
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "ExecutionErrorDialogContent",
  props: {
    error: {}
  },
  setup(__props) {
    const props = __props;
    const reportContent = ref("");
    const reportOpen = ref(false);
    const showReport = /* @__PURE__ */ __name(() => {
      reportOpen.value = true;
    }, "showReport");
    const toast = useToast();
    const { copy, isSupported: isSupported2 } = useClipboard();
    onMounted(async () => {
      try {
        const [systemStats, logs] = await Promise.all([
          api.getSystemStats(),
          api.getLogs()
        ]);
        generateReport(systemStats, logs);
      } catch (error) {
        console.error("Error fetching system stats or logs:", error);
        toast.add({
          severity: "error",
          summary: "Error",
          detail: "Failed to fetch system information",
          life: 5e3
        });
      }
    });
    const generateReport = /* @__PURE__ */ __name((systemStats, logs) => {
      const MAX_JSON_LENGTH = 2e4;
      const workflowJSONString = JSON.stringify(app$1.graph.serialize());
      const workflowText = workflowJSONString.length > MAX_JSON_LENGTH ? "Workflow too large. Please manually upload the workflow from local file system." : workflowJSONString;
      reportContent.value = `
# ComfyUI Error Report
## Error Details
- **Node ID:** ${props.error.node_id}
- **Node Type:** ${props.error.node_type}
- **Exception Type:** ${props.error.exception_type}
- **Exception Message:** ${props.error.exception_message}
## Stack Trace
\`\`\`
${props.error.traceback.join("\n")}
\`\`\`
## System Information
- **ComfyUI Version:** ${systemStats.system.comfyui_version}
- **Arguments:** ${systemStats.system.argv.join(" ")}
- **OS:** ${systemStats.system.os}
- **Python Version:** ${systemStats.system.python_version}
- **Embedded Python:** ${systemStats.system.embedded_python}
- **PyTorch Version:** ${systemStats.system.pytorch_version}
## Devices
${systemStats.devices.map(
        (device) => `
- **Name:** ${device.name}
  - **Type:** ${device.type}
  - **VRAM Total:** ${device.vram_total}
  - **VRAM Free:** ${device.vram_free}
  - **Torch VRAM Total:** ${device.torch_vram_total}
  - **Torch VRAM Free:** ${device.torch_vram_free}
`
      ).join("\n")}
## Logs
\`\`\`
${logs}
\`\`\`
## Attached Workflow
Please make sure that workflow does not contain any sensitive information such as API keys or passwords.
\`\`\`
${workflowText}
\`\`\`

## Additional Context
(Please add any additional context or steps to reproduce the error here)
`;
    }, "generateReport");
    const copyReportToClipboard = /* @__PURE__ */ __name(async () => {
      if (isSupported2) {
        try {
          await copy(reportContent.value);
          toast.add({
            severity: "success",
            summary: "Success",
            detail: "Report copied to clipboard",
            life: 3e3
          });
        } catch (err) {
          toast.add({
            severity: "error",
            summary: "Error",
            detail: "Failed to copy report"
          });
        }
      } else {
        toast.add({
          severity: "error",
          summary: "Error",
          detail: "Clipboard API not supported in your browser"
        });
      }
    }, "copyReportToClipboard");
    const openNewGithubIssue = /* @__PURE__ */ __name(async () => {
      await copyReportToClipboard();
      const issueTitle = encodeURIComponent(
        `[Bug]: ${props.error.exception_type} in ${props.error.node_type}`
      );
      const issueBody = encodeURIComponent(
        "The report has been copied to the clipboard. Please paste it here."
      );
      const url = `https://github.com/${repoOwner}/${repoName}/issues/new?title=${issueTitle}&body=${issueBody}`;
      window.open(url, "_blank");
    }, "openNewGithubIssue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(NoResultsPlaceholder, {
          icon: "pi pi-exclamation-circle",
          title: props.error.node_type,
          message: props.error.exception_message
        }, null, 8, ["title", "message"]),
        createBaseVNode("div", _hoisted_1$D, [
          withDirectives(createVNode(unref(script$M), {
            label: _ctx.$t("showReport"),
            onClick: showReport,
            text: ""
          }, null, 8, ["label"]), [
            [vShow, !reportOpen.value]
          ]),
          reportOpen.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createVNode(unref(script$G)),
            createVNode(unref(script$F), { style: { "width": "100%", "height": "400px", "max-width": "80vw" } }, {
              default: withCtx(() => [
                createBaseVNode("pre", _hoisted_2$r, toDisplayString$1(reportContent.value), 1)
              ]),
              _: 1
            }),
            createVNode(unref(script$G))
          ], 64)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_3$e, [
            createVNode(_sfc_main$v, {
              errorMessage: props.error.exception_message,
              repoOwner,
              repoName
            }, null, 8, ["errorMessage"]),
            reportOpen.value ? (openBlock(), createBlock(unref(script$M), {
              key: 0,
              label: _ctx.$t("copyToClipboard"),
              icon: "pi pi-copy",
              onClick: copyReportToClipboard
            }, null, 8, ["label"])) : createCommentVNode("", true)
          ])
        ])
      ], 64);
    };
  }
});
const ExecutionErrorDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-27b8189d"]]);
const _withScopeId$d = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-98830966"), n = n(), popScopeId(), n), "_withScopeId$d");
const _hoisted_1$C = {
  class: "flex flex-wrap content-around justify-around gap-4 mt-4",
  "data-testid": "template-workflows-content"
};
const _hoisted_2$q = ["data-testid"];
const _hoisted_3$d = ["onClick"];
const _hoisted_4$9 = ["src"];
const _hoisted_5$7 = /* @__PURE__ */ _withScopeId$d(() => /* @__PURE__ */ createBaseVNode("a", null, [
  /* @__PURE__ */ createBaseVNode("div", { class: "absolute top-0 left-0 w-64 h-64 overflow-hidden opacity-0 transition duration-300 ease-in-out hover:opacity-100 bg-opacity-50 bg-black flex items-center justify-center" }, [
    /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-play-circle" })
  ])
], -1));
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "TemplateWorkflowsContent",
  setup(__props) {
    const { t } = useI18n();
    const templates = ["default", "image2image", "upscale", "flux_schnell"];
    const loading2 = ref(null);
    const loadWorkflow = /* @__PURE__ */ __name(async (id3) => {
      loading2.value = id3;
      const json = await fetch(api.fileURL(`templates/${id3}.json`)).then(
        (r) => r.json()
      );
      useDialogStore().closeDialog();
      await app$1.loadGraphData(
        json,
        true,
        true,
        t(`templateWorkflows.template.${id3}`)
      );
      return false;
    }, "loadWorkflow");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$C, [
        (openBlock(), createElementBlock(Fragment, null, renderList(templates, (template) => {
          return createBaseVNode("div", {
            key: template,
            "data-testid": `template-workflow-${template}`
          }, [
            createVNode(unref(script$L), null, {
              header: withCtx(() => [
                createBaseVNode("div", {
                  class: "relative overflow-hidden rounded-lg cursor-pointer",
                  onClick: /* @__PURE__ */ __name(($event) => loadWorkflow(template), "onClick")
                }, [
                  createBaseVNode("img", {
                    src: `/templates/${template}.jpg`,
                    class: "w-64 h-64 rounded-lg object-cover"
                  }, null, 8, _hoisted_4$9),
                  _hoisted_5$7,
                  loading2.value === template ? (openBlock(), createBlock(unref(script$s), {
                    key: 0,
                    class: "absolute inset-0 z-1 w-3/12 h-full"
                  })) : createCommentVNode("", true)
                ], 8, _hoisted_3$d)
              ]),
              subtitle: withCtx(() => [
                createTextVNode(toDisplayString$1(_ctx.$t(`templateWorkflows.template.${template}`)), 1)
              ]),
              _: 2
            }, 1024)
          ], 8, _hoisted_2$q);
        }), 64))
      ]);
    };
  }
});
const TemplateWorkflowsContent = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-98830966"]]);
var theme$d = /* @__PURE__ */ __name(function theme24(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-floatlabel {\n    display: block;\n    position: relative;\n}\n\n.p-floatlabel label {\n    position: absolute;\n    pointer-events: none;\n    top: 50%;\n    margin-top: -.5rem;\n    transition-property: all;\n    transition-timing-function: ease;\n    line-height: 1;\n    left: 0.75rem;\n    color: ".concat(dt2("floatlabel.color"), ";\n    transition-duration: ").concat(dt2("floatlabel.transition.duration"), ";\n}\n\n.p-floatlabel:has(textarea) label {\n    top: 1rem;\n}\n\n.p-floatlabel:has(input:focus) label,\n.p-floatlabel:has(input.p-filled) label,\n.p-floatlabel:has(input:-webkit-autofill) label,\n.p-floatlabel:has(textarea:focus) label,\n.p-floatlabel:has(textarea.p-filled) label,\n.p-floatlabel:has(.p-inputwrapper-focus) label,\n.p-floatlabel:has(.p-inputwrapper-filled) label {\n    top: -.75rem;\n    font-size: 12px;\n    color: ").concat(dt2("floatlabel.focus.color"), ";\n}\n\n.p-floatlabel .p-placeholder,\n.p-floatlabel input::placeholder,\n.p-floatlabel .p-inputtext::placeholder {\n    opacity: 0;\n    transition-property: all;\n    transition-timing-function: ease;\n}\n\n.p-floatlabel .p-focus .p-placeholder,\n.p-floatlabel input:focus::placeholder,\n.p-floatlabel .p-inputtext:focus::placeholder {\n    opacity: 1;\n    transition-property: all;\n    transition-timing-function: ease;\n}\n\n.p-floatlabel > .p-invalid + label {\n    color: ").concat(dt2("floatlabel.invalid.color"), ";\n}\n");
}, "theme");
var classes$d = {
  root: "p-floatlabel"
};
var FloatLabelStyle = BaseStyle.extend({
  name: "floatlabel",
  theme: theme$d,
  classes: classes$d
});
var script$1$c = {
  name: "BaseFloatLabel",
  "extends": script$Y,
  props: {},
  style: FloatLabelStyle,
  provide: /* @__PURE__ */ __name(function provide26() {
    return {
      $pcFloatLabel: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$l = {
  name: "FloatLabel",
  "extends": script$1$c,
  inheritAttrs: false
};
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
__name(render$k, "render$k");
script$l.render = render$k;
const _hoisted_1$B = { class: "prompt-dialog-content flex flex-col gap-2 pt-8" };
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "PromptDialogContent",
  props: {
    message: {},
    defaultValue: {},
    onConfirm: { type: Function }
  },
  setup(__props) {
    const props = __props;
    const inputValue = ref(props.defaultValue);
    const onConfirm = /* @__PURE__ */ __name(() => {
      props.onConfirm(inputValue.value);
      useDialogStore().closeDialog();
    }, "onConfirm");
    const inputRef = ref(null);
    const selectAllText = /* @__PURE__ */ __name(() => {
      if (!inputRef.value) return;
      const inputElement = inputRef.value.$el;
      inputElement.setSelectionRange(0, inputElement.value.length);
    }, "selectAllText");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$B, [
        createVNode(unref(script$l), null, {
          default: withCtx(() => [
            createVNode(unref(script$R), {
              ref_key: "inputRef",
              ref: inputRef,
              modelValue: inputValue.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue.value = $event),
              onKeyup: withKeys(onConfirm, ["enter"]),
              onFocus: selectAllText,
              autofocus: ""
            }, null, 8, ["modelValue"]),
            createBaseVNode("label", null, toDisplayString$1(_ctx.message), 1)
          ]),
          _: 1
        }),
        createVNode(unref(script$M), { onClick: onConfirm }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString$1(_ctx.$t("confirm")), 1)
          ]),
          _: 1
        })
      ]);
    };
  }
});
const messages = {
  en: {
    welcome: {
      title: "Welcome to ComfyUI",
      getStarted: "Get Started"
    },
    install: {
      installLocation: "Install Location",
      migration: "Migration",
      desktopSettings: "Desktop Settings",
      chooseInstallationLocation: "Choose Installation Location",
      systemLocations: "System Locations",
      failedToSelectDirectory: "Failed to select directory",
      pathValidationFailed: "Failed to validate path",
      installLocationDescription: "Select the directory for ComfyUI's user data. A python environment will be installed to the selected location. Please make sure the selected disk has enough space (~5GB) left.",
      installLocationTooltip: "ComfyUI's user data directory. Stores:\n- Python Environment\n- Models\n- Custom nodes\n",
      appDataLocationTooltip: "ComfyUI's app data directory. Stores:\n- Logs\n- Server configs",
      appPathLocationTooltip: "ComfyUI's app asset directory. Stores the ComfyUI code and assets",
      migrateFromExistingInstallation: "Migrate from Existing Installation",
      migrationSourcePathDescription: "If you have an existing ComfyUI installation, we can copy/link your existing user files and models to the new installation.",
      selectItemsToMigrate: "Select Items to Migrate",
      migrationOptional: "Migration is optional. If you don't have an existing installation, you can skip this step.",
      desktopAppSettings: "Desktop App Settings",
      desktopAppSettingsDescription: "Configure how ComfyUI behaves on your desktop. You can change these settings later.",
      settings: {
        autoUpdate: "Automatic Updates",
        allowMetrics: "Usage Analytics",
        autoUpdateDescription: "Automatically download and install updates when they become available. You'll always be notified before updates are installed.",
        allowMetricsDescription: "Help improve ComfyUI by sending anonymous usage data. No personal information or workflow content will be collected.",
        learnMoreAboutData: "Learn more about data collection",
        dataCollectionDialog: {
          title: "About Data Collection",
          whatWeCollect: "What we collect:",
          whatWeDoNotCollect: "What we don't collect:",
          errorReports: "Error reports",
          systemInfo: "Operating system and app version",
          personalInformation: "Personal information",
          workflowContent: "Workflow content",
          fileSystemInformation: "File system information"
        }
      }
    },
    firstTimeUIMessage: 'This is the first time you use the new UI. Choose "Menu > Use New Menu > Disabled" to restore the old UI.',
    download: "Download",
    loadAllFolders: "Load All Folders",
    refresh: "Refresh",
    terminal: "Terminal",
    videoFailedToLoad: "Video failed to load",
    extensionName: "Extension Name",
    reloadToApplyChanges: "Reload to apply changes",
    insert: "Insert",
    systemInfo: "System Info",
    devices: "Devices",
    about: "About",
    add: "Add",
    confirm: "Confirm",
    reset: "Reset",
    resetKeybindingsTooltip: "Reset keybindings to default",
    customizeFolder: "Customize Folder",
    icon: "Icon",
    color: "Color",
    bookmark: "Bookmark",
    folder: "Folder",
    star: "Star",
    heart: "Heart",
    file: "File",
    inbox: "Inbox",
    box: "Box",
    briefcase: "Briefcase",
    error: "Error",
    loading: "Loading",
    findIssues: "Find Issues",
    copyToClipboard: "Copy to Clipboard",
    openNewIssue: "Open New Issue",
    showReport: "Show Report",
    imageFailedToLoad: "Image failed to load",
    reconnecting: "Reconnecting",
    reconnected: "Reconnected",
    delete: "Delete",
    rename: "Rename",
    customize: "Customize",
    experimental: "BETA",
    deprecated: "DEPR",
    loadWorkflow: "Load Workflow",
    goToNode: "Go to Node",
    settings: "Settings",
    searchWorkflows: "Search Workflows",
    searchSettings: "Search Settings",
    searchNodes: "Search Nodes",
    searchModels: "Search Models",
    searchKeybindings: "Search Keybindings",
    noResultsFound: "No Results Found",
    searchFailedMessage: "We couldn't find any settings matching your search. Try adjusting your search terms.",
    noTasksFound: "No Tasks Found",
    noTasksFoundMessage: "There are no tasks in the queue.",
    newFolder: "New Folder",
    sideToolbar: {
      themeToggle: "Toggle Theme",
      queue: "Queue",
      nodeLibrary: "Node Library",
      workflows: "Workflows",
      browseTemplates: "Browse example templates",
      openWorkflow: "Open workflow in local file system",
      newBlankWorkflow: "Create a new blank workflow",
      nodeLibraryTab: {
        sortOrder: "Sort Order"
      },
      modelLibrary: "Model Library",
      downloads: "Downloads",
      queueTab: {
        showFlatList: "Show Flat List",
        backToAllTasks: "Back to All Tasks",
        containImagePreview: "Fill Image Preview",
        coverImagePreview: "Fit Image Preview",
        clearPendingTasks: "Clear Pending Tasks"
      }
    },
    menu: {
      hideMenu: "Hide Menu",
      showMenu: "Show Menu",
      batchCount: "Batch Count",
      batchCountTooltip: "The number of times the workflow generation should be queued",
      autoQueue: "Auto Queue",
      disabled: "Disabled",
      disabledTooltip: "The workflow will not be automatically queued",
      instant: "Instant",
      instantTooltip: "The workflow will be queued instantly after a generation finishes",
      change: "On Change",
      changeTooltip: "The workflow will be queued once a change is made",
      queueWorkflow: "Queue workflow",
      queueWorkflowFront: "Queue workflow (Insert at Front)",
      queue: "Queue",
      interrupt: "Cancel current run",
      refresh: "Refresh node definitions",
      clipspace: "Open Clipspace",
      resetView: "Reset canvas view",
      clear: "Clear workflow",
      toggleBottomPanel: "Toggle Bottom Panel"
    },
    templateWorkflows: {
      title: "Get Started with a Template",
      template: {
        default: "Image Generation",
        image2image: "Image to Image",
        upscale: "2 Pass Upscale",
        flux_schnell: "Flux Schnell"
      }
    },
    graphCanvasMenu: {
      zoomIn: "Zoom In",
      zoomOut: "Zoom Out",
      resetView: "Reset View",
      fitView: "Fit View",
      selectMode: "Select Mode",
      panMode: "Pan Mode",
      toggleLinkVisibility: "Toggle Link Visibility"
    },
    electronFileDownload: {
      inProgress: "In Progress",
      pause: "Pause Download",
      paused: "Paused",
      resume: "Resume Download",
      cancel: "Cancel Download",
      cancelled: "Cancelled"
    }
  },
  zh: {
    firstTimeUIMessage: "Menu > Use New Menu > Disabled",
    download: "",
    loadAllFolders: "",
    refresh: "",
    terminal: "",
    videoFailedToLoad: "",
    extensionName: "",
    reloadToApplyChanges: "",
    insert: "",
    systemInfo: "",
    devices: "",
    about: "",
    add: "",
    confirm: "",
    reset: "",
    resetKeybindingsTooltip: "",
    customizeFolder: "",
    icon: "",
    color: "",
    bookmark: "",
    folder: "",
    star: "",
    heart: "",
    file: "",
    inbox: "",
    box: "",
    briefcase: "",
    error: "",
    loading: "",
    findIssues: " Issue",
    copyToClipboard: "",
    openNewIssue: " Issue",
    showReport: "",
    imageFailedToLoad: "",
    reconnecting: "",
    reconnected: "",
    delete: "",
    rename: "",
    customize: "",
    experimental: "BETA",
    deprecated: "",
    loadWorkflow: "",
    goToNode: "",
    settings: "",
    searchWorkflows: "",
    searchSettings: "",
    searchNodes: "",
    searchModels: "",
    searchKeybindings: "",
    noResultsFound: "",
    searchFailedMessage: "",
    noContent: "()",
    noTasksFound: "",
    noTasksFoundMessage: "",
    newFolder: "",
    sideToolbar: {
      themeToggle: "",
      queue: "",
      nodeLibrary: "",
      workflows: "",
      browseTemplates: "",
      openWorkflow: "",
      newBlankWorkflow: "",
      nodeLibraryTab: {
        sortOrder: ""
      },
      modelLibrary: "",
      queueTab: {
        showFlatList: "",
        backToAllTasks: "",
        containImagePreview: "",
        coverImagePreview: "",
        clearPendingTasks: ""
      }
    },
    menu: {
      hideMenu: "",
      showMenu: "",
      batchCount: "",
      batchCountTooltip: "",
      autoQueue: "",
      disabled: "",
      disabledTooltip: "",
      instant: "",
      instantTooltip: "",
      change: "",
      changeTooltip: "",
      queueWorkflow: "",
      queueWorkflowFront: " ()",
      queue: "",
      interrupt: "",
      refresh: "",
      clipspace: "",
      resetView: "",
      clear: "",
      toggleBottomPanel: ""
    },
    templateWorkflows: {
      title: "",
      template: {
        default: "Image Generation",
        image2image: "Image to Image",
        upscale: "2 Pass Upscale",
        flux_schnell: "Flux Schnell"
      }
    },
    graphCanvasMenu: {
      zoomIn: "",
      zoomOut: "",
      resetView: "",
      fitView: "",
      selectMode: "",
      panMode: "",
      toggleLinkVisibility: ""
    }
  },
  ru: {
    download: "",
    refresh: "",
    loadAllFolders: "  ",
    terminal: "",
    videoFailedToLoad: "   ",
    extensionName: " ",
    reloadToApplyChanges: ",   ",
    insert: "",
    systemInfo: "  ",
    devices: "",
    about: "",
    add: "",
    confirm: "",
    reset: "",
    resetKeybindingsTooltip: "    ",
    customizeFolder: " ",
    icon: "",
    color: "",
    bookmark: "",
    folder: "",
    star: "",
    heart: "",
    file: "",
    inbox: "",
    box: "",
    briefcase: "",
    error: "",
    loading: "",
    findIssues: " Issue",
    copyToClipboard: "   ",
    openNewIssue: "  Issue",
    showReport: " ",
    imageFailedToLoad: "   ",
    reconnecting: "",
    reconnected: "",
    delete: "",
    rename: "",
    customize: "",
    experimental: "",
    deprecated: "",
    loadWorkflow: "  ",
    goToNode: "  ",
    settings: "",
    searchWorkflows: "  ",
    searchSettings: " ",
    searchNodes: " ",
    searchModels: " ",
    searchKeybindings: "  ",
    noResultsFound: "  ",
    searchFailedMessage: "     ,   .    .",
    noContent: "( )",
    noTasksFound: "  ",
    noTasksFoundMessage: "   .",
    newFolder: " ",
    sideToolbar: {
      themeToggle: " ",
      queue: "",
      nodeLibrary: " ",
      workflows: " ",
      browseTemplates: "  ",
      openWorkflow: "      ",
      newBlankWorkflow: "    ",
      nodeLibraryTab: {
        sortOrder: " "
      },
      modelLibrary: " ",
      queueTab: {
        showFlatList: "  ",
        backToAllTasks: "   ",
        containImagePreview: "  ",
        coverImagePreview: "  ",
        clearPendingTasks: "  "
      }
    },
    menu: {
      hideMenu: " ",
      showMenu: " ",
      batchCount: " ",
      batchCountTooltip: " ,         ",
      autoQueue: "",
      disabled: "",
      disabledTooltip: "       ",
      instant: "",
      instantTooltip: "          ",
      change: " ",
      changeTooltip: "        ",
      queueWorkflow: "  ",
      queueWorkflowFront: "   ( )",
      queue: "",
      interrupt: "  ",
      refresh: "  ",
      clipspace: " Clipspace",
      resetView: "  ",
      clear: "  "
    },
    templateWorkflows: {
      title: "   ",
      template: {
        default: "Image Generation",
        image2image: "Image to Image",
        upscale: "2 Pass Upscale",
        flux_schnell: "Flux Schnell"
      }
    },
    graphCanvasMenu: {
      zoomIn: "",
      zoomOut: "",
      resetView: " ",
      fitView: "  ",
      selectMode: " ",
      panMode: " ",
      toggleLinkVisibility: "  "
    }
  }
  // TODO: Add more languages
};
const i18n = createI18n({
  // Must set `false`, as Vue I18n Legacy API is for Vue 2
  legacy: false,
  locale: navigator.language.split("-")[0] || "en",
  fallbackLocale: "en",
  messages
});
function showLoadWorkflowWarning(props) {
  const dialogStore = useDialogStore();
  dialogStore.showDialog({
    component: LoadWorkflowWarning,
    props
  });
}
__name(showLoadWorkflowWarning, "showLoadWorkflowWarning");
function showMissingModelsWarning(props) {
  const dialogStore = useDialogStore();
  dialogStore.showDialog({
    component: MissingModelsWarning,
    props
  });
}
__name(showMissingModelsWarning, "showMissingModelsWarning");
function showSettingsDialog() {
  useDialogStore().showDialog({
    headerComponent: SettingDialogHeader,
    component: SettingDialogContent
  });
}
__name(showSettingsDialog, "showSettingsDialog");
function showExecutionErrorDialog(error) {
  useDialogStore().showDialog({
    component: ExecutionErrorDialogContent,
    props: {
      error
    }
  });
}
__name(showExecutionErrorDialog, "showExecutionErrorDialog");
function showTemplateWorkflowsDialog() {
  useDialogStore().showDialog({
    title: i18n.global.t("templateWorkflows.title"),
    component: TemplateWorkflowsContent
  });
}
__name(showTemplateWorkflowsDialog, "showTemplateWorkflowsDialog");
async function showPromptDialog({
  title,
  message: message2,
  defaultValue = ""
}) {
  const dialogStore = useDialogStore();
  return new Promise((resolve2) => {
    dialogStore.showDialog({
      title,
      component: _sfc_main$s,
      props: {
        message: message2,
        defaultValue,
        onConfirm: /* @__PURE__ */ __name((value3) => {
          resolve2(value3);
        }, "onConfirm")
      },
      dialogComponentProps: {
        onClose: /* @__PURE__ */ __name(() => {
          resolve2(null);
        }, "onClose")
      }
    });
  });
}
__name(showPromptDialog, "showPromptDialog");
const ComfyDialog = ComfyDialog$1;
function $el(tag, propsOrChildren, children) {
  const split = tag.split(".");
  const element = document.createElement(split.shift());
  if (split.length > 0) {
    element.classList.add(...split);
  }
  if (propsOrChildren) {
    if (typeof propsOrChildren === "string") {
      propsOrChildren = { textContent: propsOrChildren };
    } else if (propsOrChildren instanceof Element) {
      propsOrChildren = [propsOrChildren];
    }
    if (Array.isArray(propsOrChildren)) {
      element.append(...propsOrChildren);
    } else {
      const {
        parent,
        $: cb,
        dataset,
        style,
        ...rest
      } = propsOrChildren;
      if (rest.for) {
        element.setAttribute("for", rest.for);
      }
      if (style) {
        Object.assign(element.style, style);
      }
      if (dataset) {
        Object.assign(element.dataset, dataset);
      }
      Object.assign(element, rest);
      if (children) {
        element.append(...Array.isArray(children) ? children : [children]);
      }
      if (parent) {
        parent.append(element);
      }
      if (cb) {
        cb(element);
      }
    }
  }
  return element;
}
__name($el, "$el");
function dragElement(dragEl, settings) {
  var posDiffX = 0, posDiffY = 0, posStartX = 0, posStartY = 0, newPosX = 0, newPosY = 0;
  if (dragEl.getElementsByClassName("drag-handle")[0]) {
    dragEl.getElementsByClassName("drag-handle")[0].onmousedown = dragMouseDown;
  } else {
    dragEl.onmousedown = dragMouseDown;
  }
  const resizeObserver = new ResizeObserver(() => {
    ensureInBounds();
  }).observe(dragEl);
  function ensureInBounds() {
    try {
      newPosX = Math.min(
        document.body.clientWidth - dragEl.clientWidth,
        Math.max(0, dragEl.offsetLeft)
      );
      newPosY = Math.min(
        document.body.clientHeight - dragEl.clientHeight,
        Math.max(0, dragEl.offsetTop)
      );
      positionElement();
    } catch (exception) {
    }
  }
  __name(ensureInBounds, "ensureInBounds");
  function positionElement() {
    if (dragEl.style.display === "none") return;
    const halfWidth = document.body.clientWidth / 2;
    const anchorRight = newPosX + dragEl.clientWidth / 2 > halfWidth;
    if (anchorRight) {
      dragEl.style.left = "unset";
      dragEl.style.right = document.body.clientWidth - newPosX - dragEl.clientWidth + "px";
    } else {
      dragEl.style.left = newPosX + "px";
      dragEl.style.right = "unset";
    }
    dragEl.style.top = newPosY + "px";
    dragEl.style.bottom = "unset";
    if (savePos) {
      localStorage.setItem(
        "Comfy.MenuPosition",
        JSON.stringify({
          x: dragEl.offsetLeft,
          y: dragEl.offsetTop
        })
      );
    }
  }
  __name(positionElement, "positionElement");
  function restorePos() {
    let posString = localStorage.getItem("Comfy.MenuPosition");
    if (posString) {
      const pos2 = JSON.parse(posString);
      newPosX = pos2.x;
      newPosY = pos2.y;
      positionElement();
      ensureInBounds();
    }
  }
  __name(restorePos, "restorePos");
  let savePos = void 0;
  settings.addSetting({
    id: "Comfy.MenuPosition",
    category: ["Comfy", "Menu", "MenuPosition"],
    name: "Save legacy menu's position",
    type: "boolean",
    defaultValue: savePos,
    onChange(value3) {
      if (savePos === void 0 && value3) {
        restorePos();
      }
      savePos = value3;
    }
  });
  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    posStartX = e.clientX;
    posStartY = e.clientY;
    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;
  }
  __name(dragMouseDown, "dragMouseDown");
  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    dragEl.classList.add("comfy-menu-manual-pos");
    posDiffX = e.clientX - posStartX;
    posDiffY = e.clientY - posStartY;
    posStartX = e.clientX;
    posStartY = e.clientY;
    newPosX = Math.min(
      document.body.clientWidth - dragEl.clientWidth,
      Math.max(0, dragEl.offsetLeft + posDiffX)
    );
    newPosY = Math.min(
      document.body.clientHeight - dragEl.clientHeight,
      Math.max(0, dragEl.offsetTop + posDiffY)
    );
    positionElement();
  }
  __name(elementDrag, "elementDrag");
  window.addEventListener("resize", () => {
    ensureInBounds();
  });
  function closeDragElement() {
    document.onmouseup = null;
    document.onmousemove = null;
  }
  __name(closeDragElement, "closeDragElement");
  return restorePos;
}
__name(dragElement, "dragElement");
class ComfyList {
  static {
    __name(this, "ComfyList");
  }
  #type;
  #text;
  #reverse;
  element;
  button;
  constructor(text, type, reverse2) {
    this.#text = text;
    this.#type = type || text.toLowerCase();
    this.#reverse = reverse2 || false;
    this.element = $el("div.comfy-list");
    this.element.style.display = "none";
  }
  get visible() {
    return this.element.style.display !== "none";
  }
  async load() {
    const items2 = await api.getItems(this.#type);
    this.element.replaceChildren(
      ...Object.keys(items2).flatMap((section) => [
        $el("h4", {
          textContent: section
        }),
        $el("div.comfy-list-items", [
          ...(this.#reverse ? items2[section].reverse() : items2[section]).map(
            (item2) => {
              const removeAction = "remove" in item2 ? item2.remove : {
                name: "Delete",
                cb: /* @__PURE__ */ __name(() => api.deleteItem(this.#type, item2.prompt[1]), "cb")
              };
              return $el("div", { textContent: item2.prompt[0] + ": " }, [
                $el("button", {
                  textContent: "Load",
                  onclick: /* @__PURE__ */ __name(async () => {
                    await app$1.loadGraphData(
                      item2.prompt[3].extra_pnginfo.workflow,
                      true,
                      false
                    );
                    if ("outputs" in item2) {
                      app$1.nodeOutputs = {};
                      for (const [key, value3] of Object.entries(item2.outputs)) {
                        const realKey = item2["meta"]?.[key]?.display_node ?? key;
                        app$1.nodeOutputs[realKey] = value3;
                      }
                    }
                  }, "onclick")
                }),
                $el("button", {
                  textContent: removeAction.name,
                  onclick: /* @__PURE__ */ __name(async () => {
                    await removeAction.cb();
                    await this.update();
                  }, "onclick")
                })
              ]);
            }
          )
        ])
      ]),
      $el("div.comfy-list-actions", [
        $el("button", {
          textContent: "Clear " + this.#text,
          onclick: /* @__PURE__ */ __name(async () => {
            await api.clearItems(this.#type);
            await this.load();
          }, "onclick")
        }),
        $el("button", { textContent: "Refresh", onclick: /* @__PURE__ */ __name(() => this.load(), "onclick") })
      ])
    );
  }
  async update() {
    if (this.visible) {
      await this.load();
    }
  }
  async show() {
    this.element.style.display = "block";
    this.button.textContent = "Close";
    await this.load();
  }
  hide() {
    this.element.style.display = "none";
    this.button.textContent = "View " + this.#text;
  }
  toggle() {
    if (this.visible) {
      this.hide();
      return false;
    } else {
      this.show();
      return true;
    }
  }
}
class ComfyUI {
  static {
    __name(this, "ComfyUI");
  }
  app;
  dialog;
  settings;
  batchCount;
  lastQueueSize;
  queue;
  history;
  autoQueueMode;
  graphHasChanged;
  autoQueueEnabled;
  menuContainer;
  queueSize;
  restoreMenuPosition;
  loadFile;
  constructor(app2) {
    this.app = app2;
    this.dialog = new ComfyDialog();
    this.settings = new ComfySettingsDialog(app2);
    this.batchCount = 1;
    this.lastQueueSize = 0;
    this.queue = new ComfyList("Queue");
    this.history = new ComfyList("History", "history", true);
    api.addEventListener("status", () => {
      this.queue.update();
      this.history.update();
    });
    this.setup(document.body);
  }
  setup(containerElement) {
    const fileInput2 = $el("input", {
      id: "comfy-file-input",
      type: "file",
      accept: ".json,image/png,.latent,.safetensors,image/webp,audio/flac",
      style: { display: "none" },
      parent: document.body,
      onchange: /* @__PURE__ */ __name(async () => {
        await app$1.handleFile(fileInput2.files[0]);
        fileInput2.value = "";
      }, "onchange")
    });
    this.loadFile = () => fileInput2.click();
    const autoQueueModeEl = toggleSwitch(
      "autoQueueMode",
      [
        {
          text: "instant",
          tooltip: "A new prompt will be queued as soon as the queue reaches 0"
        },
        {
          text: "change",
          tooltip: "A new prompt will be queued when the queue is at 0 and the graph is/has changed"
        }
      ],
      {
        onChange: /* @__PURE__ */ __name((value3) => {
          this.autoQueueMode = value3.item.value;
        }, "onChange")
      }
    );
    autoQueueModeEl.style.display = "none";
    api.addEventListener("graphChanged", () => {
      if (this.autoQueueMode === "change" && this.autoQueueEnabled === true) {
        if (this.lastQueueSize === 0) {
          this.graphHasChanged = false;
          app$1.queuePrompt(0, this.batchCount);
        } else {
          this.graphHasChanged = true;
        }
      }
    });
    this.menuContainer = $el("div.comfy-menu", { parent: containerElement }, [
      $el(
        "div.drag-handle.comfy-menu-header",
        {
          style: {
            overflow: "hidden",
            position: "relative",
            width: "100%",
            cursor: "default"
          }
        },
        [
          $el("span.drag-handle"),
          $el("span.comfy-menu-queue-size", { $: /* @__PURE__ */ __name((q) => this.queueSize = q, "$") }),
          $el("div.comfy-menu-actions", [
            $el("button.comfy-settings-btn", {
              textContent: "",
              onclick: showSettingsDialog
            }),
            $el("button.comfy-close-menu-btn", {
              textContent: "",
              onclick: /* @__PURE__ */ __name(() => {
                useWorkspaceStore().focusMode = true;
              }, "onclick")
            })
          ])
        ]
      ),
      $el("button.comfy-queue-btn", {
        id: "queue-button",
        textContent: "Queue Prompt",
        onclick: /* @__PURE__ */ __name(() => app$1.queuePrompt(0, this.batchCount), "onclick")
      }),
      $el("div", {}, [
        $el("label", { innerHTML: "Extra options" }, [
          $el("input", {
            type: "checkbox",
            onchange: /* @__PURE__ */ __name((i2) => {
              document.getElementById("extraOptions").style.display = i2.srcElement.checked ? "block" : "none";
              this.batchCount = i2.srcElement.checked ? Number.parseInt(
                document.getElementById(
                  "batchCountInputRange"
                ).value
              ) : 1;
              document.getElementById("autoQueueCheckbox").checked = false;
              this.autoQueueEnabled = false;
            }, "onchange")
          })
        ])
      ]),
      $el(
        "div",
        { id: "extraOptions", style: { width: "100%", display: "none" } },
        [
          $el("div", [
            $el("label", { innerHTML: "Batch count" }),
            $el("input", {
              id: "batchCountInputNumber",
              type: "number",
              value: this.batchCount,
              min: "1",
              style: { width: "35%", marginLeft: "0.4em" },
              oninput: /* @__PURE__ */ __name((i2) => {
                this.batchCount = i2.target.value;
                document.getElementById(
                  "batchCountInputRange"
                ).value = this.batchCount.toString();
              }, "oninput")
            }),
            $el("input", {
              id: "batchCountInputRange",
              type: "range",
              min: "1",
              max: "100",
              value: this.batchCount,
              oninput: /* @__PURE__ */ __name((i2) => {
                this.batchCount = i2.srcElement.value;
                document.getElementById(
                  "batchCountInputNumber"
                ).value = i2.srcElement.value;
              }, "oninput")
            })
          ]),
          $el("div", [
            $el("label", {
              for: "autoQueueCheckbox",
              innerHTML: "Auto Queue"
            }),
            $el("input", {
              id: "autoQueueCheckbox",
              type: "checkbox",
              checked: false,
              title: "Automatically queue prompt when the queue size hits 0",
              onchange: /* @__PURE__ */ __name((e) => {
                this.autoQueueEnabled = e.target.checked;
                autoQueueModeEl.style.display = this.autoQueueEnabled ? "" : "none";
              }, "onchange")
            }),
            autoQueueModeEl
          ])
        ]
      ),
      $el("div.comfy-menu-btns", [
        $el("button", {
          id: "queue-front-button",
          textContent: "Queue Front",
          onclick: /* @__PURE__ */ __name(() => app$1.queuePrompt(-1, this.batchCount), "onclick")
        }),
        $el("button", {
          $: /* @__PURE__ */ __name((b) => this.queue.button = b, "$"),
          id: "comfy-view-queue-button",
          textContent: "View Queue",
          onclick: /* @__PURE__ */ __name(() => {
            this.history.hide();
            this.queue.toggle();
          }, "onclick")
        }),
        $el("button", {
          $: /* @__PURE__ */ __name((b) => this.history.button = b, "$"),
          id: "comfy-view-history-button",
          textContent: "View History",
          onclick: /* @__PURE__ */ __name(() => {
            this.queue.hide();
            this.history.toggle();
          }, "onclick")
        })
      ]),
      this.queue.element,
      this.history.element,
      $el("button", {
        id: "comfy-save-button",
        textContent: "Save",
        onclick: /* @__PURE__ */ __name(() => {
          useCommandStore().execute("Comfy.ExportWorkflow");
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-dev-save-api-button",
        textContent: "Save (API Format)",
        style: { width: "100%", display: "none" },
        onclick: /* @__PURE__ */ __name(() => {
          useCommandStore().execute("Comfy.ExportWorkflowAPI");
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-load-button",
        textContent: "Load",
        onclick: /* @__PURE__ */ __name(() => fileInput2.click(), "onclick")
      }),
      $el("button", {
        id: "comfy-refresh-button",
        textContent: "Refresh",
        onclick: /* @__PURE__ */ __name(() => app$1.refreshComboInNodes(), "onclick")
      }),
      $el("button", {
        id: "comfy-clipspace-button",
        textContent: "Clipspace",
        onclick: /* @__PURE__ */ __name(() => app$1.openClipspace(), "onclick")
      }),
      $el("button", {
        id: "comfy-clear-button",
        textContent: "Clear",
        onclick: /* @__PURE__ */ __name(() => {
          if (!useSettingStore().get("Comfy.ConfirmClear") || confirm("Clear workflow?")) {
            app$1.clean();
            app$1.graph.clear();
            app$1.resetView();
            api.dispatchEvent(new CustomEvent("graphCleared"));
          }
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-load-default-button",
        textContent: "Load Default",
        onclick: /* @__PURE__ */ __name(async () => {
          if (!useSettingStore().get("Comfy.ConfirmClear") || confirm("Load default workflow?")) {
            app$1.resetView();
            await app$1.loadGraphData();
          }
        }, "onclick")
      }),
      $el("button", {
        id: "comfy-reset-view-button",
        textContent: "Reset View",
        onclick: /* @__PURE__ */ __name(async () => {
          app$1.resetView();
        }, "onclick")
      })
    ]);
    this.menuContainer.style.display = "none";
    this.restoreMenuPosition = dragElement(this.menuContainer, this.settings);
    this.setStatus({ exec_info: { queue_remaining: "X" } });
  }
  setStatus(status) {
    this.queueSize.textContent = "Queue size: " + (status ? status.exec_info.queue_remaining : "ERR");
    if (status) {
      if (this.lastQueueSize != 0 && status.exec_info.queue_remaining == 0 && this.autoQueueEnabled && (this.autoQueueMode === "instant" || this.graphHasChanged) && !app$1.lastExecutionError) {
        app$1.queuePrompt(0, this.batchCount);
        status.exec_info.queue_remaining += this.batchCount;
        this.graphHasChanged = false;
      }
      this.lastQueueSize = status.exec_info.queue_remaining;
    }
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.ui = window.comfyAPI.ui || {};
window.comfyAPI.ui.ComfyDialog = ComfyDialog;
window.comfyAPI.ui.$el = $el;
window.comfyAPI.ui.ComfyUI = ComfyUI;
$el("style", {
  textContent: `
        .comfy-logging-logs {
            display: grid;
            color: var(--fg-color);
            white-space: pre-wrap;
        }
        .comfy-logging-log {
            display: contents;
        }
        .comfy-logging-title {
            background: var(--tr-even-bg-color);
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }
        .comfy-logging-log div {
            background: var(--row-bg);
            padding: 5px;
        }
    `,
  parent: document.body
});
function stringify(val, depth, replacer2, space, onGetObjID) {
  depth = isNaN(+depth) ? 1 : depth;
  var recursMap = /* @__PURE__ */ new WeakMap();
  function _build(val2, depth2, o, a, r) {
    return !val2 || typeof val2 != "object" ? val2 : (r = recursMap.has(val2), recursMap.set(val2, true), a = Array.isArray(val2), r ? o = onGetObjID && onGetObjID(val2) || null : JSON.stringify(val2, function(k, v2) {
      if (a || depth2 > 0) {
        if (replacer2) v2 = replacer2(k, v2);
        if (!k) return a = Array.isArray(v2), val2 = v2;
        !o && (o = a ? [] : {});
        o[k] = _build(v2, a ? depth2 : depth2 - 1);
      }
    }), o === void 0 ? a ? [] : {} : o);
  }
  __name(_build, "_build");
  return JSON.stringify(_build(val, depth), null, space);
}
__name(stringify, "stringify");
const jsonReplacer = /* @__PURE__ */ __name((k, v2, ui) => {
  if (v2 instanceof Array && v2.length === 1) {
    v2 = v2[0];
  }
  if (v2 instanceof Date) {
    v2 = v2.toISOString();
    if (ui) {
      v2 = v2.split("T")[1];
    }
  }
  if (v2 instanceof Error) {
    let err = "";
    if (v2.name) err += v2.name + "\n";
    if (v2.message) err += v2.message + "\n";
    if (v2.stack) err += v2.stack + "\n";
    if (!err) {
      err = v2.toString();
    }
    v2 = err;
  }
  return v2;
}, "jsonReplacer");
const fileInput = $el("input", {
  type: "file",
  accept: ".json",
  style: { display: "none" },
  parent: document.body
});
class ComfyLoggingDialog extends ComfyDialog {
  static {
    __name(this, "ComfyLoggingDialog");
  }
  logging;
  constructor(logging) {
    super();
    this.logging = logging;
  }
  clear() {
    this.logging.clear();
    this.show();
  }
  export() {
    const blob = new Blob(
      [stringify([...this.logging.entries], 20, jsonReplacer, "	")],
      {
        type: "application/json"
      }
    );
    const url = URL.createObjectURL(blob);
    const a = $el("a", {
      href: url,
      download: `comfyui-logs-${Date.now()}.json`,
      style: { display: "none" },
      parent: document.body
    });
    a.click();
    setTimeout(function() {
      a.remove();
      window.URL.revokeObjectURL(url);
    }, 0);
  }
  import() {
    fileInput.onchange = () => {
      const reader = new FileReader();
      reader.onload = () => {
        fileInput.remove();
        try {
          const obj = JSON.parse(reader.result);
          if (obj instanceof Array) {
            this.show(obj);
          } else {
            throw new Error("Invalid file selected.");
          }
        } catch (error) {
          useToastStore().addAlert("Unable to load logs: " + error.message);
        }
      };
      reader.readAsText(fileInput.files[0]);
    };
    fileInput.click();
  }
  createButtons() {
    return [
      $el("button", {
        type: "button",
        textContent: "Clear",
        onclick: /* @__PURE__ */ __name(() => this.clear(), "onclick")
      }),
      $el("button", {
        type: "button",
        textContent: "Export logs...",
        onclick: /* @__PURE__ */ __name(() => this.export(), "onclick")
      }),
      $el("button", {
        type: "button",
        textContent: "View exported logs...",
        onclick: /* @__PURE__ */ __name(() => this.import(), "onclick")
      }),
      ...super.createButtons()
    ];
  }
  getTypeColor(type) {
    switch (type) {
      case "error":
        return "red";
      case "warn":
        return "orange";
      case "debug":
        return "dodgerblue";
    }
  }
  show(entries) {
    if (!entries) entries = this.logging.entries;
    this.element.style.width = "100%";
    const cols = {
      source: "Source",
      type: "Type",
      timestamp: "Timestamp",
      message: "Message"
    };
    const keys2 = Object.keys(cols);
    const headers = Object.values(cols).map(
      (title) => $el("div.comfy-logging-title", {
        textContent: title
      })
    );
    const rows = entries.map((entry, i2) => {
      return $el(
        "div.comfy-logging-log",
        {
          $: /* @__PURE__ */ __name((el) => el.style.setProperty(
            "--row-bg",
            `var(--tr-${i2 % 2 ? "even" : "odd"}-bg-color)`
          ), "$")
        },
        keys2.map((key) => {
          let v2 = entry[key];
          let color;
          if (key === "type") {
            color = this.getTypeColor(v2);
          } else {
            v2 = jsonReplacer(key, v2, true);
            if (typeof v2 === "object") {
              v2 = stringify(v2, 5, jsonReplacer, "  ");
            }
          }
          return $el("div", {
            style: {
              color
            },
            textContent: v2
          });
        })
      );
    });
    const grid = $el(
      "div.comfy-logging-logs",
      {
        style: {
          gridTemplateColumns: `repeat(${headers.length}, 1fr)`
        }
      },
      [...headers, ...rows]
    );
    const els2 = [grid];
    if (!this.logging.enabled) {
      els2.unshift(
        $el("h3", {
          style: { textAlign: "center" },
          textContent: "Logging is disabled"
        })
      );
    }
    super.show($el("div", els2));
  }
}
class ComfyLogging {
  static {
    __name(this, "ComfyLogging");
  }
  /**
   * @type Array<{ source: string, type: string, timestamp: Date, message: any }>
   */
  entries = [];
  #enabled;
  #console = {};
  app;
  dialog;
  get enabled() {
    return this.#enabled;
  }
  set enabled(value3) {
    if (value3 === this.#enabled) return;
    if (value3) {
      this.patchConsole();
    } else {
      this.unpatchConsole();
    }
    this.#enabled = value3;
  }
  constructor(app2) {
    this.app = app2;
    this.dialog = new ComfyLoggingDialog(this);
    this.addSetting();
    this.catchUnhandled();
    this.addInitData();
  }
  addSetting() {
    const settingId = "Comfy.Logging.Enabled";
    const htmlSettingId = settingId.replaceAll(".", "-");
    const setting = this.app.ui.settings.addSetting({
      id: settingId,
      name: "Enable logging",
      defaultValue: true,
      onChange: /* @__PURE__ */ __name((value3) => {
        this.enabled = value3;
      }, "onChange"),
      type: /* @__PURE__ */ __name((name, setter, value3) => {
        return $el("tr", [
          $el("td", [
            $el("label", {
              textContent: "Logging",
              for: htmlSettingId
            })
          ]),
          $el("td", [
            $el("input", {
              id: htmlSettingId,
              type: "checkbox",
              checked: value3,
              onchange: /* @__PURE__ */ __name((event2) => {
                setter(event2.target.checked);
              }, "onchange")
            }),
            $el("button", {
              textContent: "View Logs",
              onclick: /* @__PURE__ */ __name(() => {
                this.app.ui.settings.element.close();
                this.dialog.show();
              }, "onclick"),
              style: {
                fontSize: "14px",
                display: "block",
                marginTop: "5px"
              }
            })
          ])
        ]);
      }, "type")
    });
    this.enabled = setting.value;
  }
  patchConsole() {
    const self2 = this;
    for (const type of ["log", "warn", "error", "debug"]) {
      const orig = console[type];
      this.#console[type] = orig;
      console[type] = function() {
        orig.apply(console, arguments);
        self2.addEntry("console", type, ...arguments);
      };
    }
  }
  unpatchConsole() {
    for (const type of Object.keys(this.#console)) {
      console[type] = this.#console[type];
    }
    this.#console = {};
  }
  catchUnhandled() {
    window.addEventListener("error", (e) => {
      this.addEntry("window", "error", e.error ?? "Unknown error");
      return false;
    });
    window.addEventListener("unhandledrejection", (e) => {
      this.addEntry("unhandledrejection", "error", e.reason ?? "Unknown error");
    });
  }
  clear() {
    this.entries = [];
  }
  addEntry(source, type, ...args) {
    if (this.enabled) {
      this.entries.push({
        source,
        type,
        timestamp: /* @__PURE__ */ new Date(),
        message: args
      });
    }
  }
  log(source, ...args) {
    this.addEntry(source, "log", ...args);
  }
  async addInitData() {
    if (!this.enabled) return;
    const source = "ComfyUI.Logging";
    this.addEntry(source, "debug", { UserAgent: navigator.userAgent });
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.logging = window.comfyAPI.logging || {};
window.comfyAPI.logging.ComfyLogging = ComfyLogging;
const defaultGraph = {
  last_node_id: 9,
  last_link_id: 9,
  nodes: [
    {
      id: 7,
      type: "CLIPTextEncode",
      pos: [413, 389],
      size: [425.27801513671875, 180.6060791015625],
      flags: {},
      order: 3,
      mode: 0,
      inputs: [{ name: "clip", type: "CLIP", link: 5 }],
      outputs: [
        {
          name: "CONDITIONING",
          type: "CONDITIONING",
          links: [6],
          slot_index: 0
        }
      ],
      properties: {},
      widgets_values: ["text, watermark"]
    },
    {
      id: 6,
      type: "CLIPTextEncode",
      pos: [415, 186],
      size: [422.84503173828125, 164.31304931640625],
      flags: {},
      order: 2,
      mode: 0,
      inputs: [{ name: "clip", type: "CLIP", link: 3 }],
      outputs: [
        {
          name: "CONDITIONING",
          type: "CONDITIONING",
          links: [4],
          slot_index: 0
        }
      ],
      properties: {},
      widgets_values: [
        "beautiful scenery nature glass bottle landscape, , purple galaxy bottle,"
      ]
    },
    {
      id: 5,
      type: "EmptyLatentImage",
      pos: [473, 609],
      size: [315, 106],
      flags: {},
      order: 1,
      mode: 0,
      outputs: [{ name: "LATENT", type: "LATENT", links: [2], slot_index: 0 }],
      properties: {},
      widgets_values: [512, 512, 1]
    },
    {
      id: 3,
      type: "KSampler",
      pos: [863, 186],
      size: [315, 262],
      flags: {},
      order: 4,
      mode: 0,
      inputs: [
        { name: "model", type: "MODEL", link: 1 },
        { name: "positive", type: "CONDITIONING", link: 4 },
        { name: "negative", type: "CONDITIONING", link: 6 },
        { name: "latent_image", type: "LATENT", link: 2 }
      ],
      outputs: [{ name: "LATENT", type: "LATENT", links: [7], slot_index: 0 }],
      properties: {},
      widgets_values: [156680208700286, true, 20, 8, "euler", "normal", 1]
    },
    {
      id: 8,
      type: "VAEDecode",
      pos: [1209, 188],
      size: [210, 46],
      flags: {},
      order: 5,
      mode: 0,
      inputs: [
        { name: "samples", type: "LATENT", link: 7 },
        { name: "vae", type: "VAE", link: 8 }
      ],
      outputs: [{ name: "IMAGE", type: "IMAGE", links: [9], slot_index: 0 }],
      properties: {}
    },
    {
      id: 9,
      type: "SaveImage",
      pos: [1451, 189],
      size: [210, 26],
      flags: {},
      order: 6,
      mode: 0,
      inputs: [{ name: "images", type: "IMAGE", link: 9 }],
      properties: {}
    },
    {
      id: 4,
      type: "CheckpointLoaderSimple",
      pos: [26, 474],
      size: [315, 98],
      flags: {},
      order: 0,
      mode: 0,
      outputs: [
        { name: "MODEL", type: "MODEL", links: [1], slot_index: 0 },
        { name: "CLIP", type: "CLIP", links: [3, 5], slot_index: 1 },
        { name: "VAE", type: "VAE", links: [8], slot_index: 2 }
      ],
      properties: {},
      widgets_values: ["v1-5-pruned-emaonly.ckpt"]
    }
  ],
  links: [
    [1, 4, 0, 3, 0, "MODEL"],
    [2, 5, 0, 3, 3, "LATENT"],
    [3, 4, 1, 6, 0, "CLIP"],
    [4, 6, 0, 3, 1, "CONDITIONING"],
    [5, 4, 1, 7, 0, "CLIP"],
    [6, 7, 0, 3, 2, "CONDITIONING"],
    [7, 3, 0, 8, 0, "LATENT"],
    [8, 4, 2, 8, 1, "VAE"],
    [9, 8, 0, 9, 0, "IMAGE"]
  ],
  groups: [],
  config: {},
  extra: {},
  version: 0.4
};
const defaultGraphJSON = JSON.stringify(defaultGraph);
const blankGraph = {
  last_node_id: 0,
  last_link_id: 0,
  nodes: [],
  links: [],
  groups: [],
  config: {},
  extra: {},
  version: 0.4
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.defaultGraph = window.comfyAPI.defaultGraph || {};
window.comfyAPI.defaultGraph.defaultGraph = defaultGraph;
window.comfyAPI.defaultGraph.defaultGraphJSON = defaultGraphJSON;
window.comfyAPI.defaultGraph.blankGraph = blankGraph;
function getFromPngBuffer(buffer2) {
  const pngData = new Uint8Array(buffer2);
  const dataView = new DataView(pngData.buffer);
  if (dataView.getUint32(0) !== 2303741511) {
    console.error("Not a valid PNG file");
    return;
  }
  let offset = 8;
  let txt_chunks = {};
  while (offset < pngData.length) {
    const length = dataView.getUint32(offset);
    const type = String.fromCharCode(...pngData.slice(offset + 4, offset + 8));
    if (type === "tEXt" || type == "comf" || type === "iTXt") {
      let keyword_end = offset + 8;
      while (pngData[keyword_end] !== 0) {
        keyword_end++;
      }
      const keyword = String.fromCharCode(
        ...pngData.slice(offset + 8, keyword_end)
      );
      const contentArraySegment = pngData.slice(
        keyword_end + 1,
        offset + 8 + length
      );
      const contentJson = new TextDecoder("utf-8").decode(contentArraySegment);
      txt_chunks[keyword] = contentJson;
    }
    offset += 12 + length;
  }
  return txt_chunks;
}
__name(getFromPngBuffer, "getFromPngBuffer");
function getFromPngFile(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      r(getFromPngBuffer(event2.target.result));
    };
    reader.readAsArrayBuffer(file);
  });
}
__name(getFromPngFile, "getFromPngFile");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.png = window.comfyAPI.png || {};
window.comfyAPI.png.getFromPngBuffer = getFromPngBuffer;
window.comfyAPI.png.getFromPngFile = getFromPngFile;
function getFromFlacBuffer(buffer2) {
  const dataView = new DataView(buffer2);
  const signature = String.fromCharCode(...new Uint8Array(buffer2, 0, 4));
  if (signature !== "fLaC") {
    console.error("Not a valid FLAC file");
    return;
  }
  let offset = 4;
  let vorbisComment = null;
  while (offset < dataView.byteLength) {
    const isLastBlock = dataView.getUint8(offset) & 128;
    const blockType = dataView.getUint8(offset) & 127;
    const blockSize = dataView.getUint32(offset, false) & 16777215;
    offset += 4;
    if (blockType === 4) {
      vorbisComment = parseVorbisComment(
        new DataView(buffer2, offset, blockSize)
      );
    }
    offset += blockSize;
    if (isLastBlock) break;
  }
  return vorbisComment;
}
__name(getFromFlacBuffer, "getFromFlacBuffer");
function getFromFlacFile(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = function(event2) {
      const arrayBuffer = event2.target.result;
      r(getFromFlacBuffer(arrayBuffer));
    };
    reader.readAsArrayBuffer(file);
  });
}
__name(getFromFlacFile, "getFromFlacFile");
function parseVorbisComment(dataView) {
  let offset = 0;
  const vendorLength = dataView.getUint32(offset, true);
  offset += 4;
  const vendorString = getString(dataView, offset, vendorLength);
  offset += vendorLength;
  const userCommentListLength = dataView.getUint32(offset, true);
  offset += 4;
  const comments = {};
  for (let i2 = 0; i2 < userCommentListLength; i2++) {
    const commentLength = dataView.getUint32(offset, true);
    offset += 4;
    const comment = getString(dataView, offset, commentLength);
    offset += commentLength;
    const ind = comment.indexOf("=");
    const key = comment.substring(0, ind);
    comments[key] = comment.substring(ind + 1);
  }
  return comments;
}
__name(parseVorbisComment, "parseVorbisComment");
function getString(dataView, offset, length) {
  let string = "";
  for (let i2 = 0; i2 < length; i2++) {
    string += String.fromCharCode(dataView.getUint8(offset + i2));
  }
  return string;
}
__name(getString, "getString");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.flac = window.comfyAPI.flac || {};
window.comfyAPI.flac.getFromFlacBuffer = getFromFlacBuffer;
window.comfyAPI.flac.getFromFlacFile = getFromFlacFile;
function getPngMetadata(file) {
  return getFromPngFile(file);
}
__name(getPngMetadata, "getPngMetadata");
function getFlacMetadata(file) {
  return getFromFlacFile(file);
}
__name(getFlacMetadata, "getFlacMetadata");
function parseExifData(exifData) {
  const isLittleEndian = String.fromCharCode(...exifData.slice(0, 2)) === "II";
  function readInt(offset, isLittleEndian2, length) {
    let arr = exifData.slice(offset, offset + length);
    if (length === 2) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).getUint16(
        0,
        isLittleEndian2
      );
    } else if (length === 4) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).getUint32(
        0,
        isLittleEndian2
      );
    }
  }
  __name(readInt, "readInt");
  const ifdOffset = readInt(4, isLittleEndian, 4);
  function parseIFD(offset) {
    const numEntries = readInt(offset, isLittleEndian, 2);
    const result = {};
    for (let i2 = 0; i2 < numEntries; i2++) {
      const entryOffset = offset + 2 + i2 * 12;
      const tag = readInt(entryOffset, isLittleEndian, 2);
      const type = readInt(entryOffset + 2, isLittleEndian, 2);
      const numValues = readInt(entryOffset + 4, isLittleEndian, 4);
      const valueOffset = readInt(entryOffset + 8, isLittleEndian, 4);
      let value3;
      if (type === 2) {
        value3 = new TextDecoder("utf-8").decode(
          exifData.subarray(valueOffset, valueOffset + numValues - 1)
        );
      }
      result[tag] = value3;
    }
    return result;
  }
  __name(parseIFD, "parseIFD");
  const ifdData = parseIFD(ifdOffset);
  return ifdData;
}
__name(parseExifData, "parseExifData");
function splitValues(input) {
  var output = {};
  for (var key in input) {
    var value3 = input[key];
    var splitValues2 = value3.split(":", 2);
    output[splitValues2[0]] = splitValues2[1];
  }
  return output;
}
__name(splitValues, "splitValues");
function getWebpMetadata(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      const webp = new Uint8Array(event2.target.result);
      const dataView = new DataView(webp.buffer);
      if (dataView.getUint32(0) !== 1380533830 || dataView.getUint32(8) !== 1464156752) {
        console.error("Not a valid WEBP file");
        r({});
        return;
      }
      let offset = 12;
      let txt_chunks = {};
      while (offset < webp.length) {
        const chunk_length = dataView.getUint32(offset + 4, true);
        const chunk_type = String.fromCharCode(
          ...webp.slice(offset, offset + 4)
        );
        if (chunk_type === "EXIF") {
          if (String.fromCharCode(...webp.slice(offset + 8, offset + 8 + 6)) == "Exif\0\0") {
            offset += 6;
          }
          let data22 = parseExifData(
            webp.slice(offset + 8, offset + 8 + chunk_length)
          );
          for (var key in data22) {
            const value3 = data22[key];
            if (typeof value3 === "string") {
              const index2 = value3.indexOf(":");
              txt_chunks[value3.slice(0, index2)] = value3.slice(index2 + 1);
            }
          }
          break;
        }
        offset += 8 + chunk_length;
      }
      r(txt_chunks);
    };
    reader.readAsArrayBuffer(file);
  });
}
__name(getWebpMetadata, "getWebpMetadata");
function getLatentMetadata(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      const safetensorsData = new Uint8Array(event2.target.result);
      const dataView = new DataView(safetensorsData.buffer);
      let header_size = dataView.getUint32(0, true);
      let offset = 8;
      let header2 = JSON.parse(
        new TextDecoder().decode(
          safetensorsData.slice(offset, offset + header_size)
        )
      );
      r(header2.__metadata__);
    };
    var slice = file.slice(0, 1024 * 1024 * 4);
    reader.readAsArrayBuffer(slice);
  });
}
__name(getLatentMetadata, "getLatentMetadata");
async function importA1111(graph, parameters) {
  const p2 = parameters.lastIndexOf("\nSteps:");
  if (p2 > -1) {
    const embeddings = await api.getEmbeddings();
    const opts = parameters.substr(p2).split("\n")[1].match(
      new RegExp('\\s*([^:]+:\\s*([^"\\{].*?|".*?"|\\{.*?\\}))\\s*(,|$)', "g")
    ).reduce((p3, n) => {
      const s = n.split(":");
      if (s[1].endsWith(",")) {
        s[1] = s[1].substr(0, s[1].length - 1);
      }
      p3[s[0].trim().toLowerCase()] = s[1].trim();
      return p3;
    }, {});
    const p22 = parameters.lastIndexOf("\nNegative prompt:", p2);
    if (p22 > -1) {
      let positive = parameters.substr(0, p22).trim();
      let negative = parameters.substring(p22 + 18, p2).trim();
      const ckptNode = LiteGraph.createNode("CheckpointLoaderSimple");
      const clipSkipNode = LiteGraph.createNode("CLIPSetLastLayer");
      const positiveNode = LiteGraph.createNode("CLIPTextEncode");
      const negativeNode = LiteGraph.createNode("CLIPTextEncode");
      const samplerNode = LiteGraph.createNode("KSampler");
      const imageNode = LiteGraph.createNode("EmptyLatentImage");
      const vaeNode = LiteGraph.createNode("VAEDecode");
      const vaeLoaderNode = LiteGraph.createNode("VAELoader");
      const saveNode = LiteGraph.createNode("SaveImage");
      let hrSamplerNode = null;
      let hrSteps = null;
      const ceil64 = /* @__PURE__ */ __name((v2) => Math.ceil(v2 / 64) * 64, "ceil64");
      const getWidget = /* @__PURE__ */ __name((node3, name) => {
        return node3.widgets.find((w2) => w2.name === name);
      }, "getWidget");
      const setWidgetValue = /* @__PURE__ */ __name((node3, name, value3, isOptionPrefix) => {
        const w2 = getWidget(node3, name);
        if (isOptionPrefix) {
          const o = w2.options.values.find((w22) => w22.startsWith(value3));
          if (o) {
            w2.value = o;
          } else {
            console.warn(`Unknown value '${value3}' for widget '${name}'`, node3);
            w2.value = value3;
          }
        } else {
          w2.value = value3;
        }
      }, "setWidgetValue");
      const createLoraNodes = /* @__PURE__ */ __name((clipNode, text, prevClip, prevModel) => {
        const loras = [];
        text = text.replace(/<lora:([^:]+:[^>]+)>/g, function(m, c) {
          const s = c.split(":");
          const weight = parseFloat(s[1]);
          if (isNaN(weight)) {
            console.warn("Invalid LORA", m);
          } else {
            loras.push({ name: s[0], weight });
          }
          return "";
        });
        for (const l of loras) {
          const loraNode = LiteGraph.createNode("LoraLoader");
          graph.add(loraNode);
          setWidgetValue(loraNode, "lora_name", l.name, true);
          setWidgetValue(loraNode, "strength_model", l.weight);
          setWidgetValue(loraNode, "strength_clip", l.weight);
          prevModel.node.connect(prevModel.index, loraNode, 0);
          prevClip.node.connect(prevClip.index, loraNode, 1);
          prevModel = { node: loraNode, index: 0 };
          prevClip = { node: loraNode, index: 1 };
        }
        prevClip.node.connect(1, clipNode, 0);
        prevModel.node.connect(0, samplerNode, 0);
        if (hrSamplerNode) {
          prevModel.node.connect(0, hrSamplerNode, 0);
        }
        return { text, prevModel, prevClip };
      }, "createLoraNodes");
      const replaceEmbeddings = /* @__PURE__ */ __name((text) => {
        if (!embeddings.length) return text;
        return text.replaceAll(
          new RegExp(
            "\\b(" + embeddings.map((e) => e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("\\b|\\b") + ")\\b",
            "ig"
          ),
          "embedding:$1"
        );
      }, "replaceEmbeddings");
      const popOpt = /* @__PURE__ */ __name((name) => {
        const v2 = opts[name];
        delete opts[name];
        return v2;
      }, "popOpt");
      graph.clear();
      graph.add(ckptNode);
      graph.add(clipSkipNode);
      graph.add(positiveNode);
      graph.add(negativeNode);
      graph.add(samplerNode);
      graph.add(imageNode);
      graph.add(vaeNode);
      graph.add(vaeLoaderNode);
      graph.add(saveNode);
      ckptNode.connect(1, clipSkipNode, 0);
      clipSkipNode.connect(0, positiveNode, 0);
      clipSkipNode.connect(0, negativeNode, 0);
      ckptNode.connect(0, samplerNode, 0);
      positiveNode.connect(0, samplerNode, 1);
      negativeNode.connect(0, samplerNode, 2);
      imageNode.connect(0, samplerNode, 3);
      vaeNode.connect(0, saveNode, 0);
      samplerNode.connect(0, vaeNode, 0);
      vaeLoaderNode.connect(0, vaeNode, 1);
      const handlers2 = {
        model(v2) {
          setWidgetValue(ckptNode, "ckpt_name", v2, true);
        },
        vae(v2) {
          setWidgetValue(vaeLoaderNode, "vae_name", v2, true);
        },
        "cfg scale"(v2) {
          setWidgetValue(samplerNode, "cfg", +v2);
        },
        "clip skip"(v2) {
          setWidgetValue(clipSkipNode, "stop_at_clip_layer", -v2);
        },
        sampler(v2) {
          let name = v2.toLowerCase().replace("++", "pp").replaceAll(" ", "_");
          if (name.includes("karras")) {
            name = name.replace("karras", "").replace(/_+$/, "");
            setWidgetValue(samplerNode, "scheduler", "karras");
          } else {
            setWidgetValue(samplerNode, "scheduler", "normal");
          }
          const w2 = getWidget(samplerNode, "sampler_name");
          const o = w2.options.values.find(
            (w22) => w22 === name || w22 === "sample_" + name
          );
          if (o) {
            setWidgetValue(samplerNode, "sampler_name", o);
          }
        },
        size(v2) {
          const wxh = v2.split("x");
          const w2 = ceil64(+wxh[0]);
          const h2 = ceil64(+wxh[1]);
          const hrUp = popOpt("hires upscale");
          const hrSz = popOpt("hires resize");
          hrSteps = popOpt("hires steps");
          let hrMethod = popOpt("hires upscaler");
          setWidgetValue(imageNode, "width", w2);
          setWidgetValue(imageNode, "height", h2);
          if (hrUp || hrSz) {
            let uw, uh;
            if (hrUp) {
              uw = w2 * hrUp;
              uh = h2 * hrUp;
            } else {
              const s = hrSz.split("x");
              uw = +s[0];
              uh = +s[1];
            }
            let upscaleNode;
            let latentNode;
            if (hrMethod.startsWith("Latent")) {
              latentNode = upscaleNode = LiteGraph.createNode("LatentUpscale");
              graph.add(upscaleNode);
              samplerNode.connect(0, upscaleNode, 0);
              switch (hrMethod) {
                case "Latent (nearest-exact)":
                  hrMethod = "nearest-exact";
                  break;
              }
              setWidgetValue(upscaleNode, "upscale_method", hrMethod, true);
            } else {
              const decode2 = LiteGraph.createNode("VAEDecodeTiled");
              graph.add(decode2);
              samplerNode.connect(0, decode2, 0);
              vaeLoaderNode.connect(0, decode2, 1);
              const upscaleLoaderNode = LiteGraph.createNode("UpscaleModelLoader");
              graph.add(upscaleLoaderNode);
              setWidgetValue(upscaleLoaderNode, "model_name", hrMethod, true);
              const modelUpscaleNode = LiteGraph.createNode(
                "ImageUpscaleWithModel"
              );
              graph.add(modelUpscaleNode);
              decode2.connect(0, modelUpscaleNode, 1);
              upscaleLoaderNode.connect(0, modelUpscaleNode, 0);
              upscaleNode = LiteGraph.createNode("ImageScale");
              graph.add(upscaleNode);
              modelUpscaleNode.connect(0, upscaleNode, 0);
              const vaeEncodeNode = latentNode = LiteGraph.createNode("VAEEncodeTiled");
              graph.add(vaeEncodeNode);
              upscaleNode.connect(0, vaeEncodeNode, 0);
              vaeLoaderNode.connect(0, vaeEncodeNode, 1);
            }
            setWidgetValue(upscaleNode, "width", ceil64(uw));
            setWidgetValue(upscaleNode, "height", ceil64(uh));
            hrSamplerNode = LiteGraph.createNode("KSampler");
            graph.add(hrSamplerNode);
            ckptNode.connect(0, hrSamplerNode, 0);
            positiveNode.connect(0, hrSamplerNode, 1);
            negativeNode.connect(0, hrSamplerNode, 2);
            latentNode.connect(0, hrSamplerNode, 3);
            hrSamplerNode.connect(0, vaeNode, 0);
          }
        },
        steps(v2) {
          setWidgetValue(samplerNode, "steps", +v2);
        },
        seed(v2) {
          setWidgetValue(samplerNode, "seed", +v2);
        }
      };
      for (const opt in opts) {
        if (opt in handlers2) {
          handlers2[opt](popOpt(opt));
        }
      }
      if (hrSamplerNode) {
        setWidgetValue(
          hrSamplerNode,
          "steps",
          hrSteps ? +hrSteps : getWidget(samplerNode, "steps").value
        );
        setWidgetValue(
          hrSamplerNode,
          "cfg",
          getWidget(samplerNode, "cfg").value
        );
        setWidgetValue(
          hrSamplerNode,
          "scheduler",
          getWidget(samplerNode, "scheduler").value
        );
        setWidgetValue(
          hrSamplerNode,
          "sampler_name",
          getWidget(samplerNode, "sampler_name").value
        );
        setWidgetValue(
          hrSamplerNode,
          "denoise",
          +(popOpt("denoising strength") || "1")
        );
      }
      let n = createLoraNodes(
        positiveNode,
        positive,
        { node: clipSkipNode, index: 0 },
        { node: ckptNode, index: 0 }
      );
      positive = n.text;
      n = createLoraNodes(negativeNode, negative, n.prevClip, n.prevModel);
      negative = n.text;
      setWidgetValue(positiveNode, "text", replaceEmbeddings(positive));
      setWidgetValue(negativeNode, "text", replaceEmbeddings(negative));
      graph.arrange();
      for (const opt of [
        "model hash",
        "ensd",
        "version",
        "vae hash",
        "ti hashes",
        "lora hashes",
        "hashes"
      ]) {
        delete opts[opt];
      }
      console.warn("Unhandled parameters:", opts);
    }
  }
}
__name(importA1111, "importA1111");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.pnginfo = window.comfyAPI.pnginfo || {};
window.comfyAPI.pnginfo.getPngMetadata = getPngMetadata;
window.comfyAPI.pnginfo.getFlacMetadata = getFlacMetadata;
window.comfyAPI.pnginfo.getWebpMetadata = getWebpMetadata;
window.comfyAPI.pnginfo.getLatentMetadata = getLatentMetadata;
window.comfyAPI.pnginfo.importA1111 = importA1111;
function calculateImageGrid(imgs, dw, dh) {
  let best = 0;
  let w2 = imgs[0].naturalWidth;
  let h2 = imgs[0].naturalHeight;
  const numImages = imgs.length;
  let cellWidth, cellHeight, cols, rows, shiftX;
  for (let c = 1; c <= numImages; c++) {
    const r = Math.ceil(numImages / c);
    const cW = dw / c;
    const cH = dh / r;
    const scaleX = cW / w2;
    const scaleY = cH / h2;
    const scale = Math.min(scaleX, scaleY, 1);
    const imageW = w2 * scale;
    const imageH = h2 * scale;
    const area = imageW * imageH * numImages;
    if (area > best) {
      best = area;
      cellWidth = imageW;
      cellHeight = imageH;
      cols = c;
      rows = r;
      shiftX = c * ((cW - imageW) / 2);
    }
  }
  return { cellWidth, cellHeight, cols, rows, shiftX };
}
__name(calculateImageGrid, "calculateImageGrid");
function createImageHost(node3) {
  const el = $el("div.comfy-img-preview");
  let currentImgs;
  let first = true;
  function updateSize() {
    let w2 = null;
    let h2 = null;
    if (currentImgs) {
      let elH = el.clientHeight;
      if (first) {
        first = false;
        if (elH < 190) {
          elH = 190;
        }
        el.style.setProperty("--comfy-widget-min-height", elH.toString());
      } else {
        el.style.setProperty("--comfy-widget-min-height", null);
      }
      const nw = node3.size[0];
      ({ cellWidth: w2, cellHeight: h2 } = calculateImageGrid(
        currentImgs,
        nw - 20,
        elH
      ));
      w2 += "px";
      h2 += "px";
      el.style.setProperty("--comfy-img-preview-width", w2);
      el.style.setProperty("--comfy-img-preview-height", h2);
    }
  }
  __name(updateSize, "updateSize");
  return {
    el,
    updateImages(imgs) {
      if (imgs !== currentImgs) {
        if (currentImgs == null) {
          requestAnimationFrame(() => {
            updateSize();
          });
        }
        el.replaceChildren(...imgs);
        currentImgs = imgs;
        node3.onResize(node3.size);
        node3.graph.setDirtyCanvas(true, true);
      }
    },
    getHeight() {
      updateSize();
    },
    onDraw() {
      el.style.pointerEvents = "all";
      const over = document.elementFromPoint(
        app$1.canvas.mouse[0],
        app$1.canvas.mouse[1]
      );
      el.style.pointerEvents = "none";
      if (!over) return;
      const idx = currentImgs.indexOf(over);
      node3.overIndex = idx;
    }
  };
}
__name(createImageHost, "createImageHost");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.imagePreview = window.comfyAPI.imagePreview || {};
window.comfyAPI.imagePreview.calculateImageGrid = calculateImageGrid;
window.comfyAPI.imagePreview.createImageHost = createImageHost;
$el("style", {
  parent: document.head,
  textContent: `
        .draggable-item {
            position: relative;
            will-change: transform;
            user-select: none;
        }
        .draggable-item.is-idle {
            transition: 0.25s ease transform;
        }
        .draggable-item.is-draggable {
            z-index: 10;
        }
    `
});
class DraggableList extends EventTarget {
  static {
    __name(this, "DraggableList");
  }
  listContainer;
  draggableItem;
  pointerStartX;
  pointerStartY;
  scrollYMax;
  itemsGap = 0;
  items = [];
  itemSelector;
  handleClass = "drag-handle";
  off = [];
  offDrag = [];
  constructor(element, itemSelector) {
    super();
    this.listContainer = element;
    this.itemSelector = itemSelector;
    if (!this.listContainer) return;
    this.off.push(this.on(this.listContainer, "mousedown", this.dragStart));
    this.off.push(this.on(this.listContainer, "touchstart", this.dragStart));
    this.off.push(this.on(document, "mouseup", this.dragEnd));
    this.off.push(this.on(document, "touchend", this.dragEnd));
  }
  getAllItems() {
    if (!this.items?.length) {
      this.items = Array.from(
        this.listContainer.querySelectorAll(this.itemSelector)
      );
      this.items.forEach((element) => {
        element.classList.add("is-idle");
      });
    }
    return this.items;
  }
  getIdleItems() {
    return this.getAllItems().filter(
      (item2) => item2.classList.contains("is-idle")
    );
  }
  isItemAbove(item2) {
    return item2.hasAttribute("data-is-above");
  }
  isItemToggled(item2) {
    return item2.hasAttribute("data-is-toggled");
  }
  on(source, event2, listener, options3) {
    listener = listener.bind(this);
    source.addEventListener(event2, listener, options3);
    return () => source.removeEventListener(event2, listener);
  }
  dragStart(e) {
    if (e.target.classList.contains(this.handleClass)) {
      this.draggableItem = e.target.closest(this.itemSelector);
    }
    if (!this.draggableItem) return;
    this.pointerStartX = e.clientX || e.touches[0].clientX;
    this.pointerStartY = e.clientY || e.touches[0].clientY;
    this.scrollYMax = this.listContainer.scrollHeight - this.listContainer.clientHeight;
    this.setItemsGap();
    this.initDraggableItem();
    this.initItemsState();
    this.offDrag.push(this.on(document, "mousemove", this.drag));
    this.offDrag.push(
      this.on(document, "touchmove", this.drag, { passive: false })
    );
    this.dispatchEvent(
      new CustomEvent("dragstart", {
        detail: {
          element: this.draggableItem,
          position: this.getAllItems().indexOf(this.draggableItem)
        }
      })
    );
  }
  setItemsGap() {
    if (this.getIdleItems().length <= 1) {
      this.itemsGap = 0;
      return;
    }
    const item1 = this.getIdleItems()[0];
    const item2 = this.getIdleItems()[1];
    const item1Rect = item1.getBoundingClientRect();
    const item2Rect = item2.getBoundingClientRect();
    this.itemsGap = Math.abs(item1Rect.bottom - item2Rect.top);
  }
  initItemsState() {
    this.getIdleItems().forEach((item2, i2) => {
      if (this.getAllItems().indexOf(this.draggableItem) > i2) {
        item2.dataset.isAbove = "";
      }
    });
  }
  initDraggableItem() {
    this.draggableItem.classList.remove("is-idle");
    this.draggableItem.classList.add("is-draggable");
  }
  drag(e) {
    if (!this.draggableItem) return;
    e.preventDefault();
    const clientX = e.clientX || e.touches[0].clientX;
    const clientY = e.clientY || e.touches[0].clientY;
    const listRect = this.listContainer.getBoundingClientRect();
    if (clientY > listRect.bottom) {
      if (this.listContainer.scrollTop < this.scrollYMax) {
        this.listContainer.scrollBy(0, 10);
        this.pointerStartY -= 10;
      }
    } else if (clientY < listRect.top && this.listContainer.scrollTop > 0) {
      this.pointerStartY += 10;
      this.listContainer.scrollBy(0, -10);
    }
    const pointerOffsetX = clientX - this.pointerStartX;
    const pointerOffsetY = clientY - this.pointerStartY;
    this.updateIdleItemsStateAndPosition();
    this.draggableItem.style.transform = `translate(${pointerOffsetX}px, ${pointerOffsetY}px)`;
  }
  updateIdleItemsStateAndPosition() {
    const draggableItemRect = this.draggableItem.getBoundingClientRect();
    const draggableItemY = draggableItemRect.top + draggableItemRect.height / 2;
    this.getIdleItems().forEach((item2) => {
      const itemRect = item2.getBoundingClientRect();
      const itemY = itemRect.top + itemRect.height / 2;
      if (this.isItemAbove(item2)) {
        if (draggableItemY <= itemY) {
          item2.dataset.isToggled = "";
        } else {
          delete item2.dataset.isToggled;
        }
      } else {
        if (draggableItemY >= itemY) {
          item2.dataset.isToggled = "";
        } else {
          delete item2.dataset.isToggled;
        }
      }
    });
    this.getIdleItems().forEach((item2) => {
      if (this.isItemToggled(item2)) {
        const direction = this.isItemAbove(item2) ? 1 : -1;
        item2.style.transform = `translateY(${direction * (draggableItemRect.height + this.itemsGap)}px)`;
      } else {
        item2.style.transform = "";
      }
    });
  }
  dragEnd() {
    if (!this.draggableItem) return;
    this.applyNewItemsOrder();
    this.cleanup();
  }
  applyNewItemsOrder() {
    const reorderedItems = [];
    let oldPosition = -1;
    this.getAllItems().forEach((item2, index2) => {
      if (item2 === this.draggableItem) {
        oldPosition = index2;
        return;
      }
      if (!this.isItemToggled(item2)) {
        reorderedItems[index2] = item2;
        return;
      }
      const newIndex = this.isItemAbove(item2) ? index2 + 1 : index2 - 1;
      reorderedItems[newIndex] = item2;
    });
    for (let index2 = 0; index2 < this.getAllItems().length; index2++) {
      const item2 = reorderedItems[index2];
      if (typeof item2 === "undefined") {
        reorderedItems[index2] = this.draggableItem;
      }
    }
    reorderedItems.forEach((item2) => {
      this.listContainer.appendChild(item2);
    });
    this.items = reorderedItems;
    this.dispatchEvent(
      new CustomEvent("dragend", {
        detail: {
          element: this.draggableItem,
          oldPosition,
          newPosition: reorderedItems.indexOf(this.draggableItem)
        }
      })
    );
  }
  cleanup() {
    this.itemsGap = 0;
    this.items = [];
    this.unsetDraggableItem();
    this.unsetItemState();
    this.offDrag.forEach((f) => f());
    this.offDrag = [];
  }
  unsetDraggableItem() {
    this.draggableItem.style = null;
    this.draggableItem.classList.remove("is-draggable");
    this.draggableItem.classList.add("is-idle");
    this.draggableItem = null;
  }
  unsetItemState() {
    this.getIdleItems().forEach((item2, i2) => {
      delete item2.dataset.isAbove;
      delete item2.dataset.isToggled;
      item2.style.transform = "";
    });
  }
  dispose() {
    this.off.forEach((f) => f());
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.draggableList = window.comfyAPI.draggableList || {};
window.comfyAPI.draggableList.DraggableList = DraggableList;
const parts = {
  d: /* @__PURE__ */ __name((d) => d.getDate(), "d"),
  M: /* @__PURE__ */ __name((d) => d.getMonth() + 1, "M"),
  h: /* @__PURE__ */ __name((d) => d.getHours(), "h"),
  m: /* @__PURE__ */ __name((d) => d.getMinutes(), "m"),
  s: /* @__PURE__ */ __name((d) => d.getSeconds(), "s")
};
const format$1 = Object.keys(parts).map((k) => k + k + "?").join("|") + "|yyy?y?";
function formatDate(text, date) {
  return text.replace(new RegExp(format$1, "g"), (text2) => {
    if (text2 === "yy") return (date.getFullYear() + "").substring(2);
    if (text2 === "yyyy") return date.getFullYear().toString();
    if (text2[0] in parts) {
      const p2 = parts[text2[0]](date);
      return (p2 + "").padStart(text2.length, "0");
    }
    return text2;
  });
}
__name(formatDate, "formatDate");
function clone$3(obj) {
  try {
    if (typeof structuredClone !== "undefined") {
      return structuredClone(obj);
    }
  } catch (error) {
  }
  return JSON.parse(JSON.stringify(obj));
}
__name(clone$3, "clone$3");
function applyTextReplacements(app2, value3) {
  return value3.replace(/%([^%]+)%/g, function(match, text) {
    const split = text.split(".");
    if (split.length !== 2) {
      if (split[0].startsWith("date:")) {
        return formatDate(split[0].substring(5), /* @__PURE__ */ new Date());
      }
      if (text !== "width" && text !== "height") {
        console.warn("Invalid replacement pattern", text);
      }
      return match;
    }
    let nodes = app2.graph.nodes.filter(
      (n) => n.properties?.["Node name for S&R"] === split[0]
    );
    if (!nodes.length) {
      nodes = app2.graph.nodes.filter((n) => n.title === split[0]);
    }
    if (!nodes.length) {
      console.warn("Unable to find node", split[0]);
      return match;
    }
    if (nodes.length > 1) {
      console.warn("Multiple nodes matched", split[0], "using first match");
    }
    const node3 = nodes[0];
    const widget = node3.widgets?.find((w2) => w2.name === split[1]);
    if (!widget) {
      console.warn("Unable to find widget", split[1], "on node", split[0], node3);
      return match;
    }
    return ((widget.value ?? "") + "").replaceAll(/\/|\\/g, "_");
  });
}
__name(applyTextReplacements, "applyTextReplacements");
async function addStylesheet(urlOrFile, relativeTo) {
  return new Promise((res, rej) => {
    let url;
    if (urlOrFile.endsWith(".js")) {
      url = urlOrFile.substr(0, urlOrFile.length - 2) + "css";
    } else {
      url = new URL(
        urlOrFile,
        relativeTo ?? `${window.location.protocol}//${window.location.host}`
      ).toString();
    }
    $el("link", {
      parent: document.head,
      rel: "stylesheet",
      type: "text/css",
      href: url,
      onload: res,
      onerror: rej
    });
  });
}
__name(addStylesheet, "addStylesheet");
function downloadBlob(filename, blob) {
  const url = URL.createObjectURL(blob);
  const a = $el("a", {
    href: url,
    download: filename,
    style: { display: "none" },
    parent: document.body
  });
  a.click();
  setTimeout(function() {
    a.remove();
    window.URL.revokeObjectURL(url);
  }, 0);
}
__name(downloadBlob, "downloadBlob");
function prop(target, name, defaultValue, onChanged) {
  let currentValue;
  Object.defineProperty(target, name, {
    get() {
      return currentValue;
    },
    set(newValue) {
      const prevValue = currentValue;
      currentValue = newValue;
      onChanged?.(currentValue, prevValue, target, name);
    }
  });
  return defaultValue;
}
__name(prop, "prop");
function getStorageValue(id3) {
  const clientId = api.clientId ?? api.initialClientId;
  return (clientId && sessionStorage.getItem(`${id3}:${clientId}`)) ?? localStorage.getItem(id3);
}
__name(getStorageValue, "getStorageValue");
function setStorageValue(id3, value3) {
  const clientId = api.clientId ?? api.initialClientId;
  if (clientId) {
    sessionStorage.setItem(`${id3}:${clientId}`, value3);
  }
  localStorage.setItem(id3, value3);
}
__name(setStorageValue, "setStorageValue");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.utils = window.comfyAPI.utils || {};
window.comfyAPI.utils.clone = clone$3;
window.comfyAPI.utils.applyTextReplacements = applyTextReplacements;
window.comfyAPI.utils.addStylesheet = addStylesheet;
window.comfyAPI.utils.downloadBlob = downloadBlob;
window.comfyAPI.utils.prop = prop;
window.comfyAPI.utils.getStorageValue = getStorageValue;
window.comfyAPI.utils.setStorageValue = setStorageValue;
function rgbToHsl({ r, g, b }) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h2 = 0, s = 0;
  const l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, l };
}
__name(rgbToHsl, "rgbToHsl");
function hexToRgb(hex) {
  let r = 0, g = 0, b = 0;
  if (hex.length == 4) {
    r = parseInt(hex[1] + hex[1], 16);
    g = parseInt(hex[2] + hex[2], 16);
    b = parseInt(hex[3] + hex[3], 16);
  } else if (hex.length == 7) {
    r = parseInt(hex.slice(1, 3), 16);
    g = parseInt(hex.slice(3, 5), 16);
    b = parseInt(hex.slice(5, 7), 16);
  }
  return { r, g, b };
}
__name(hexToRgb, "hexToRgb");
const identifyColorFormat = /* @__PURE__ */ __name((color) => {
  if (!color) return null;
  if (color.startsWith("#") && (color.length === 4 || color.length === 7))
    return "hex";
  if (/rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*/.test(color))
    return color.includes("rgba") ? "rgba" : "rgb";
  if (/hsla?\(\s*\d+(\.\d+)?\s*,\s*\d+(\.\d+)?%\s*,\s*\d+(\.\d+)?%/.test(color))
    return color.includes("hsla") ? "hsla" : "hsl";
  return null;
}, "identifyColorFormat");
const isHSLA = /* @__PURE__ */ __name((color) => {
  if (typeof color !== "object" || color === null) return false;
  return ["h", "s", "l", "a"].every(
    (key) => typeof color[key] === "number" && !isNaN(color[key])
  );
}, "isHSLA");
function parseToHSLA(color, format2) {
  let match;
  switch (format2) {
    case "hex": {
      const hsl = rgbToHsl(hexToRgb(color));
      return {
        h: Math.round(hsl.h * 360),
        s: +(hsl.s * 100).toFixed(1),
        l: +(hsl.l * 100).toFixed(1),
        a: 1
      };
    }
    case "rgb":
    case "rgba": {
      match = color.match(/\d+(\.\d+)?/g);
      if (!match || match.length < 3) return null;
      const [r, g, b] = match.map(Number);
      const hsl = rgbToHsl({ r, g, b });
      const a = format2 === "rgba" && match[3] ? parseFloat(match[3]) : 1;
      return {
        h: Math.round(hsl.h * 360),
        s: +(hsl.s * 100).toFixed(1),
        l: +(hsl.l * 100).toFixed(1),
        a
      };
    }
    case "hsl":
    case "hsla": {
      match = color.match(/\d+(\.\d+)?/g);
      if (!match || match.length < 3) return null;
      const [h2, s, l] = match.map(Number);
      const a = format2 === "hsla" && match[3] ? parseFloat(match[3]) : 1;
      return { h: h2, s, l, a };
    }
    default:
      return null;
  }
}
__name(parseToHSLA, "parseToHSLA");
const applyColorAdjustments = /* @__PURE__ */ __name((color, options3) => {
  if (!Object.keys(options3).length) return color;
  const format2 = identifyColorFormat(color);
  if (!format2) {
    console.warn(`Unsupported color format in color palette: ${color}`);
    return color;
  }
  const hsla = parseToHSLA(color, format2);
  if (!isHSLA(hsla)) {
    console.warn(`Invalid color values in color palette: ${color}`);
    return color;
  }
  if (options3.lightness) {
    hsla.l = Math.max(0, Math.min(100, hsla.l + options3.lightness * 100));
  }
  if (options3.opacity) {
    hsla.a = Math.max(0, Math.min(1, options3.opacity));
  }
  return `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;
}, "applyColorAdjustments");
const adjustColor = lodashExports.memoize(
  applyColorAdjustments,
  (color, options3) => `${color}-${JSON.stringify(options3)}`
);
class ComfyButtonGroup {
  static {
    __name(this, "ComfyButtonGroup");
  }
  element = $el("div.comfyui-button-group");
  buttons;
  constructor(...buttons) {
    this.buttons = prop(this, "buttons", buttons, () => this.update());
  }
  insert(button, index2) {
    this.buttons.splice(index2, 0, button);
    this.update();
  }
  append(button) {
    this.buttons.push(button);
    this.update();
  }
  remove(indexOrButton) {
    if (typeof indexOrButton !== "number") {
      indexOrButton = this.buttons.indexOf(indexOrButton);
    }
    if (indexOrButton > -1) {
      const r = this.buttons.splice(indexOrButton, 1);
      this.update();
      return r;
    }
  }
  update() {
    this.element.replaceChildren(...this.buttons.map((b) => b["element"] ?? b));
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.buttonGroup = window.comfyAPI.buttonGroup || {};
window.comfyAPI.buttonGroup.ComfyButtonGroup = ComfyButtonGroup;
function applyClasses(element, classList, ...requiredClasses) {
  classList ??= "";
  let str;
  if (typeof classList === "string") {
    str = classList;
  } else if (classList instanceof Array) {
    str = classList.join(" ");
  } else {
    str = Object.entries(classList).reduce((p2, c) => {
      if (c[1]) {
        p2 += (p2.length ? " " : "") + c[0];
      }
      return p2;
    }, "");
  }
  element.className = str;
  if (requiredClasses) {
    element.classList.add(...requiredClasses);
  }
}
__name(applyClasses, "applyClasses");
function toggleElement(element, {
  onHide: onHide2,
  onShow
} = {}) {
  let placeholder;
  let hidden;
  return (value3) => {
    if (value3) {
      if (hidden) {
        hidden = false;
        placeholder.replaceWith(element);
      }
      onShow?.(element, value3);
    } else {
      if (!placeholder) {
        placeholder = document.createComment("");
      }
      hidden = true;
      element.replaceWith(placeholder);
      onHide2?.(element);
    }
  };
}
__name(toggleElement, "toggleElement");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.utils = window.comfyAPI.utils || {};
window.comfyAPI.utils.applyClasses = applyClasses;
window.comfyAPI.utils.toggleElement = toggleElement;
class ComfyButton {
  static {
    __name(this, "ComfyButton");
  }
  #over = 0;
  #popupOpen = false;
  isOver = false;
  iconElement = $el("i.mdi");
  contentElement = $el("span");
  popup;
  element;
  overIcon;
  iconSize;
  content;
  icon;
  tooltip;
  classList;
  hidden;
  enabled;
  action;
  constructor({
    icon: icon2,
    overIcon,
    iconSize,
    content: content2,
    tooltip,
    action,
    classList = "comfyui-button",
    visibilitySetting,
    app: app2,
    enabled = true
  }) {
    this.element = $el(
      "button",
      {
        onmouseenter: /* @__PURE__ */ __name(() => {
          this.isOver = true;
          if (this.overIcon) {
            this.updateIcon();
          }
        }, "onmouseenter"),
        onmouseleave: /* @__PURE__ */ __name(() => {
          this.isOver = false;
          if (this.overIcon) {
            this.updateIcon();
          }
        }, "onmouseleave")
      },
      [this.iconElement, this.contentElement]
    );
    this.icon = prop(
      this,
      "icon",
      icon2,
      toggleElement(this.iconElement, { onShow: this.updateIcon })
    );
    this.overIcon = prop(this, "overIcon", overIcon, () => {
      if (this.isOver) {
        this.updateIcon();
      }
    });
    this.iconSize = prop(this, "iconSize", iconSize, this.updateIcon);
    this.content = prop(
      this,
      "content",
      content2,
      toggleElement(this.contentElement, {
        onShow: /* @__PURE__ */ __name((el, v2) => {
          if (typeof v2 === "string") {
            el.textContent = v2;
          } else {
            el.replaceChildren(v2);
          }
        }, "onShow")
      })
    );
    this.tooltip = prop(this, "tooltip", tooltip, (v2) => {
      if (v2) {
        this.element.title = v2;
      } else {
        this.element.removeAttribute("title");
      }
    });
    if (tooltip !== void 0) {
      this.element.setAttribute("aria-label", tooltip);
    }
    this.classList = prop(this, "classList", classList, this.updateClasses);
    this.hidden = prop(this, "hidden", false, this.updateClasses);
    this.enabled = prop(this, "enabled", enabled, () => {
      this.updateClasses();
      this.element.disabled = !this.enabled;
    });
    this.action = prop(this, "action", action);
    this.element.addEventListener("click", (e) => {
      if (this.popup) {
        if (!this.#over) {
          this.popup.toggle();
        }
      }
      this.action?.(e, this);
    });
    if (visibilitySetting?.id) {
      const settingUpdated = /* @__PURE__ */ __name(() => {
        this.hidden = app2.ui.settings.getSettingValue(visibilitySetting.id) !== visibilitySetting.showValue;
      }, "settingUpdated");
      app2.ui.settings.addEventListener(
        visibilitySetting.id + ".change",
        settingUpdated
      );
      settingUpdated();
    }
  }
  updateIcon = /* @__PURE__ */ __name(() => this.iconElement.className = `mdi mdi-${this.isOver && this.overIcon || this.icon}${this.iconSize ? " mdi-" + this.iconSize + "px" : ""}`, "updateIcon");
  updateClasses = /* @__PURE__ */ __name(() => {
    const internalClasses = [];
    if (this.hidden) {
      internalClasses.push("hidden");
    }
    if (!this.enabled) {
      internalClasses.push("disabled");
    }
    if (this.popup) {
      if (this.#popupOpen) {
        internalClasses.push("popup-open");
      } else {
        internalClasses.push("popup-closed");
      }
    }
    applyClasses(this.element, this.classList, ...internalClasses);
  }, "updateClasses");
  withPopup(popup, mode2 = "click") {
    this.popup = popup;
    if (mode2 === "hover") {
      for (const el of [this.element, this.popup.element]) {
        el.addEventListener("mouseenter", () => {
          this.popup.open = !!++this.#over;
        });
        el.addEventListener("mouseleave", () => {
          this.popup.open = !!--this.#over;
        });
      }
    }
    popup.addEventListener("change", () => {
      this.#popupOpen = popup.open;
      this.updateClasses();
    });
    return this;
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.button = window.comfyAPI.button || {};
window.comfyAPI.button.ComfyButton = ComfyButton;
class ComfyPopup extends EventTarget {
  static {
    __name(this, "ComfyPopup");
  }
  element = $el("div.comfyui-popup");
  open;
  children;
  target;
  ignoreTarget;
  container;
  position;
  closeOnEscape;
  horizontal;
  classList;
  constructor({
    target,
    container = document.body,
    classList = "",
    ignoreTarget = true,
    closeOnEscape = true,
    position: position2 = "absolute",
    horizontal: horizontal2 = "left"
  }, ...children) {
    super();
    this.target = target;
    this.ignoreTarget = ignoreTarget;
    this.container = container;
    this.position = position2;
    this.closeOnEscape = closeOnEscape;
    this.horizontal = horizontal2;
    container.append(this.element);
    this.children = prop(this, "children", children, () => {
      this.element.replaceChildren(...this.children);
      this.update();
    });
    this.classList = prop(
      this,
      "classList",
      classList,
      () => applyClasses(this.element, this.classList, "comfyui-popup", horizontal2)
    );
    this.open = prop(this, "open", false, (v2, o) => {
      if (v2 === o) return;
      if (v2) {
        this.#show();
      } else {
        this.#hide();
      }
    });
  }
  toggle() {
    this.open = !this.open;
  }
  #hide() {
    this.element.classList.remove("open");
    window.removeEventListener("resize", this.update);
    window.removeEventListener("click", this.#clickHandler, { capture: true });
    window.removeEventListener("keydown", this.#escHandler, { capture: true });
    this.dispatchEvent(new CustomEvent("close"));
    this.dispatchEvent(new CustomEvent("change"));
  }
  #show() {
    this.element.classList.add("open");
    this.update();
    window.addEventListener("resize", this.update);
    window.addEventListener("click", this.#clickHandler, { capture: true });
    if (this.closeOnEscape) {
      window.addEventListener("keydown", this.#escHandler, { capture: true });
    }
    this.dispatchEvent(new CustomEvent("open"));
    this.dispatchEvent(new CustomEvent("change"));
  }
  #escHandler = /* @__PURE__ */ __name((e) => {
    if (e.key === "Escape") {
      this.open = false;
      e.preventDefault();
      e.stopImmediatePropagation();
    }
  }, "#escHandler");
  #clickHandler = /* @__PURE__ */ __name((e) => {
    const target = e.target;
    if (!this.element.contains(target) && this.ignoreTarget && !this.target.contains(target)) {
      this.open = false;
    }
  }, "#clickHandler");
  update = /* @__PURE__ */ __name(() => {
    const rect = this.target.getBoundingClientRect();
    this.element.style.setProperty("--bottom", "unset");
    if (this.position === "absolute") {
      if (this.horizontal === "left") {
        this.element.style.setProperty("--left", rect.left + "px");
      } else {
        this.element.style.setProperty(
          "--left",
          rect.right - this.element.clientWidth + "px"
        );
      }
      this.element.style.setProperty("--top", rect.bottom + "px");
      this.element.style.setProperty("--limit", rect.bottom + "px");
    } else {
      this.element.style.setProperty("--left", "0px");
      this.element.style.setProperty("--top", rect.height + "px");
      this.element.style.setProperty("--limit", rect.height + "px");
    }
    const thisRect = this.element.getBoundingClientRect();
    if (thisRect.height < 30) {
      this.element.style.setProperty("--top", "unset");
      this.element.style.setProperty("--bottom", rect.height + 5 + "px");
      this.element.style.setProperty("--limit", rect.height + 5 + "px");
    }
  }, "update");
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.popup = window.comfyAPI.popup || {};
window.comfyAPI.popup.ComfyPopup = ComfyPopup;
class ComfySplitButton {
  static {
    __name(this, "ComfySplitButton");
  }
  arrow;
  element;
  popup;
  items;
  constructor({
    primary,
    mode: mode2,
    horizontal: horizontal2 = "left",
    position: position2 = "relative"
  }, ...items2) {
    this.arrow = new ComfyButton({
      icon: "chevron-down"
    });
    this.element = $el(
      "div.comfyui-split-button" + (mode2 === "hover" ? ".hover" : ""),
      [
        $el(
          "div.comfyui-split-primary",
          {
            ariaLabel: "Queue current workflow"
          },
          primary.element
        ),
        $el(
          "div.comfyui-split-arrow",
          {
            ariaLabel: "Open extra opens",
            ariaHasPopup: "true"
          },
          this.arrow.element
        )
      ]
    );
    this.popup = new ComfyPopup({
      target: this.element,
      container: position2 === "relative" ? this.element : document.body,
      classList: "comfyui-split-button-popup" + (mode2 === "hover" ? " hover" : ""),
      closeOnEscape: mode2 === "click",
      position: position2,
      horizontal: horizontal2
    });
    this.arrow.withPopup(this.popup, mode2);
    this.items = prop(this, "items", items2, () => this.update());
  }
  update() {
    this.popup.element.replaceChildren(
      ...this.items.map((b) => "element" in b ? b.element : b)
    );
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.splitButton = window.comfyAPI.splitButton || {};
window.comfyAPI.splitButton.ComfySplitButton = ComfySplitButton;
class ComfyAppMenu {
  static {
    __name(this, "ComfyAppMenu");
  }
  app;
  actionsGroup;
  settingsGroup;
  viewGroup;
  element;
  constructor(app2) {
    this.app = app2;
    this.actionsGroup = new ComfyButtonGroup();
    this.settingsGroup = new ComfyButtonGroup();
    this.viewGroup = new ComfyButtonGroup();
    this.element = $el("div.flex.gap-2.mx-2", [
      this.actionsGroup.element,
      this.settingsGroup.element,
      this.viewGroup.element
    ]);
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.index = window.comfyAPI.index || {};
window.comfyAPI.index.ComfyAppMenu = ComfyAppMenu;
function isArray$1(value3) {
  return !Array.isArray ? getTag(value3) === "[object Array]" : Array.isArray(value3);
}
__name(isArray$1, "isArray$1");
const INFINITY = 1 / 0;
function baseToString(value3) {
  if (typeof value3 == "string") {
    return value3;
  }
  let result = value3 + "";
  return result == "0" && 1 / value3 == -INFINITY ? "-0" : result;
}
__name(baseToString, "baseToString");
function toString(value3) {
  return value3 == null ? "" : baseToString(value3);
}
__name(toString, "toString");
function isString(value3) {
  return typeof value3 === "string";
}
__name(isString, "isString");
function isNumber(value3) {
  return typeof value3 === "number";
}
__name(isNumber, "isNumber");
function isBoolean(value3) {
  return value3 === true || value3 === false || isObjectLike(value3) && getTag(value3) == "[object Boolean]";
}
__name(isBoolean, "isBoolean");
function isObject(value3) {
  return typeof value3 === "object";
}
__name(isObject, "isObject");
function isObjectLike(value3) {
  return isObject(value3) && value3 !== null;
}
__name(isObjectLike, "isObjectLike");
function isDefined(value3) {
  return value3 !== void 0 && value3 !== null;
}
__name(isDefined, "isDefined");
function isBlank(value3) {
  return !value3.trim().length;
}
__name(isBlank, "isBlank");
function getTag(value3) {
  return value3 == null ? value3 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value3);
}
__name(getTag, "getTag");
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = /* @__PURE__ */ __name((key) => `Invalid value for key ${key}`, "LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY");
const PATTERN_LENGTH_TOO_LARGE = /* @__PURE__ */ __name((max) => `Pattern length exceeds max of ${max}.`, "PATTERN_LENGTH_TOO_LARGE");
const MISSING_KEY_PROPERTY = /* @__PURE__ */ __name((name) => `Missing ${name} property in key`, "MISSING_KEY_PROPERTY");
const INVALID_KEY_WEIGHT_VALUE = /* @__PURE__ */ __name((key) => `Property 'weight' in key '${key}' must be a positive integer`, "INVALID_KEY_WEIGHT_VALUE");
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  static {
    __name(this, "KeyStore");
  }
  constructor(keys2) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys2.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id3 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray$1(key)) {
    src = key;
    path = createKeyPath(key);
    id3 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id3 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id3, weight, src, getFn };
}
__name(createKey, "createKey");
function createKeyPath(key) {
  return isArray$1(key) ? key : key.split(".");
}
__name(createKeyPath, "createKeyPath");
function createKeyId(key) {
  return isArray$1(key) ? key.join(".") : key;
}
__name(createKeyId, "createKeyId");
function get$1(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = /* @__PURE__ */ __name((obj2, path2, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index2]) {
      list.push(obj2);
    } else {
      let key = path2[index2];
      const value3 = obj2[key];
      if (!isDefined(value3)) {
        return;
      }
      if (index2 === path2.length - 1 && (isString(value3) || isNumber(value3) || isBoolean(value3))) {
        list.push(toString(value3));
      } else if (isArray$1(value3)) {
        arr = true;
        for (let i2 = 0, len = value3.length; i2 < len; i2 += 1) {
          deepGet(value3[i2], path2, index2 + 1);
        }
      } else if (path2.length) {
        deepGet(value3, path2, index2 + 1);
      }
    }
  }, "deepGet");
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
__name(get$1, "get$1");
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: /* @__PURE__ */ __name((a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1, "sortFn")
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get$1,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache2 = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value3) {
      const numTokens = value3.match(SPACE).length;
      if (cache2.has(numTokens)) {
        return cache2.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache2.set(numTokens, n);
      return n;
    },
    clear() {
      cache2.clear();
    }
  };
}
__name(norm, "norm");
class FuseIndex {
  static {
    __name(this, "FuseIndex");
  }
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys2 = []) {
    this.keys = keys2;
    this._keysMap = {};
    keys2.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc2, docIndex) => {
        this._addString(doc2, docIndex);
      });
    } else {
      this.docs.forEach((doc2, docIndex) => {
        this._addObject(doc2, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc2) {
    const idx = this.size();
    if (isString(doc2)) {
      this._addString(doc2, idx);
    } else {
      this._addObject(doc2, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
      this.records[i2].i -= 1;
    }
  }
  getValueForItemAtKeyId(item2, keyId) {
    return item2[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc2, docIndex) {
    if (!isDefined(doc2) || isBlank(doc2)) {
      return;
    }
    let record = {
      v: doc2,
      i: docIndex,
      n: this.norm.get(doc2)
    };
    this.records.push(record);
  }
  _addObject(doc2, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value3 = key.getFn ? key.getFn(doc2) : this.getFn(doc2, key.path);
      if (!isDefined(value3)) {
        return;
      }
      if (isArray$1(value3)) {
        let subRecords = [];
        const stack2 = [{ nestedArrIndex: -1, value: value3 }];
        while (stack2.length) {
          const { nestedArrIndex, value: value4 } = stack2.pop();
          if (!isDefined(value4)) {
            continue;
          }
          if (isString(value4) && !isBlank(value4)) {
            let subRecord = {
              v: value4,
              i: nestedArrIndex,
              n: this.norm.get(value4)
            };
            subRecords.push(subRecord);
          } else if (isArray$1(value4)) {
            value4.forEach((item2, k) => {
              stack2.push({
                nestedArrIndex: k,
                value: item2
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value3) && !isBlank(value3)) {
        let subRecord = {
          v: value3,
          n: this.norm.get(value3)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys2, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
__name(createIndex, "createIndex");
function parseIndex(data22, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys: keys2, records } = data22;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2);
  myIndex.setIndexRecords(records);
  return myIndex;
}
__name(parseIndex, "parseIndex");
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance: distance2 = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance2) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance2;
}
__name(computeScore$1, "computeScore$1");
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end = -1;
  let i2 = 0;
  for (let len = matchmask.length; i2 < len; i2 += 1) {
    let match = matchmask[i2];
    if (match && start2 === -1) {
      start2 = i2;
    } else if (!match && start2 !== -1) {
      end = i2 - 1;
      if (end - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i2 - 1] && i2 - start2 >= minMatchCharLength) {
    indices.push([start2, i2 - 1]);
  }
  return indices;
}
__name(convertMaskToIndices, "convertMaskToIndices");
const MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location: location2 = Config.location,
  distance: distance2 = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i2 = 0;
      while (i2 < patternLen) {
        matchMask[index2 + i2] = 1;
        i2 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask3 = 1 << patternLen - 1;
  for (let i2 = 0; i2 < patternLen; i2 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i2,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance: distance2,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i2) - 1;
    for (let j = finish; j >= start2; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i2) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask3) {
        finalScore = computeScore$1(pattern, {
          errors: i2,
          currentLocation,
          expectedLocation,
          distance: distance2,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i2 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
__name(search, "search");
function createPatternAlphabet(pattern) {
  let mask3 = {};
  for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
    const char = pattern.charAt(i2);
    mask3[char] = (mask3[char] || 0) | 1 << len - i2 - 1;
  }
  return mask3;
}
__name(createPatternAlphabet, "createPatternAlphabet");
class BitapSearch {
  static {
    __name(this, "BitapSearch");
  }
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = /* @__PURE__ */ __name((pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    }, "addChunk");
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i2 = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i2 < end) {
        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
        i2 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance: distance2,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location2 + startIndex,
        distance: distance2,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  static {
    __name(this, "BaseMatch");
  }
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches2 = pattern.match(exp);
  return matches2 ? matches2[1] : null;
}
__name(getMatch, "getMatch");
class ExactMatch extends BaseMatch {
  static {
    __name(this, "ExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  static {
    __name(this, "InverseExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index2 = text.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  static {
    __name(this, "PrefixExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  static {
    __name(this, "InversePrefixExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  static {
    __name(this, "SuffixExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  static {
    __name(this, "InverseSuffixExactMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  static {
    __name(this, "FuzzyMatch");
  }
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
}
class IncludeMatch extends BaseMatch {
  static {
    __name(this, "IncludeMatch");
  }
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location2 = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text.indexOf(this.pattern, location2)) > -1) {
      location2 = index2 + patternLen;
      indices.push([index2, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery$1(pattern, options3 = {}) {
  return pattern.split(OR_TOKEN).map((item2) => {
    let query = item2.trim().split(SPACE_RE).filter((item3) => item3 && !!item3.trim());
    let results = [];
    for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
      const queryItem = query[i2];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options3));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options3));
          break;
        }
      }
    }
    return results;
  });
}
__name(parseQuery$1, "parseQuery$1");
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  static {
    __name(this, "ExtendedSearch");
  }
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance: distance2
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery$1(this.pattern, this.options);
  }
  static condition(_2, options3) {
    return options3.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
      const searchers2 = query[i2];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register$1(...args) {
  registeredSearchers.push(...args);
}
__name(register$1, "register$1");
function createSearcher(pattern, options3) {
  for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
    let searcherClass = registeredSearchers[i2];
    if (searcherClass.condition(pattern, options3)) {
      return new searcherClass(pattern, options3);
    }
  }
  return new BitapSearch(pattern, options3);
}
__name(createSearcher, "createSearcher");
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = /* @__PURE__ */ __name((query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]), "isExpression");
const isPath = /* @__PURE__ */ __name((query) => !!query[KeyType.PATH], "isPath");
const isLeaf = /* @__PURE__ */ __name((query) => !isArray$1(query) && isObject(query) && !isExpression(query), "isLeaf");
const convertToExplicit = /* @__PURE__ */ __name((query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
}), "convertToExplicit");
function parse(query, options3, { auto = true } = {}) {
  const next2 = /* @__PURE__ */ __name((query2) => {
    let keys2 = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
      return next2(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options3);
      }
      return obj;
    }
    let node3 = {
      children: [],
      operator: keys2[0]
    };
    keys2.forEach((key) => {
      const value3 = query2[key];
      if (isArray$1(value3)) {
        value3.forEach((item2) => {
          node3.children.push(next2(item2));
        });
      }
    });
    return node3;
  }, "next");
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next2(query);
}
__name(parse, "parse");
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
__name(computeScore, "computeScore");
function transformMatches(result, data22) {
  const matches2 = result.matches;
  data22.matches = [];
  if (!isDefined(matches2)) {
    return;
  }
  matches2.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value: value3 } = match;
    let obj = {
      indices,
      value: value3
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data22.matches.push(obj);
  });
}
__name(transformMatches, "transformMatches");
function transformScore(result, data22) {
  data22.score = result.score;
}
__name(transformScore, "transformScore");
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data22 = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data22);
      });
    }
    return data22;
  });
}
__name(format, "format");
class Fuse {
  static {
    __name(this, "Fuse");
  }
  constructor(docs, options3 = {}, index2) {
    this.options = { ...Config, ...options3 };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc2) {
    if (!isDefined(doc2)) {
      return;
    }
    this._docs.push(doc2);
    this._myIndex.add(doc2);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
      const doc2 = this._docs[i2];
      if (predicate(doc2, i2)) {
        this.removeAt(i2);
        i2 -= 1;
        len -= 1;
        results.push(doc2);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = /* @__PURE__ */ __name((node3, item2, idx) => {
      if (!node3.children) {
        const { keyId, searcher } = node3;
        const matches2 = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item2, keyId),
          searcher
        });
        if (matches2 && matches2.length) {
          return [
            {
              idx,
              item: item2,
              matches: matches2
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i2 = 0, len = node3.children.length; i2 < len; i2 += 1) {
        const child = node3.children[i2];
        const result = evaluate(child, item2, idx);
        if (result.length) {
          res.push(...result);
        } else if (node3.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    }, "evaluate");
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (isDefined(item2)) {
        let expResults = evaluate(expression, item2, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item: item2, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches: matches2 }) => {
            resultMap[idx].matches.push(...matches2);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys: keys2, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (!isDefined(item2)) {
        return;
      }
      let matches2 = [];
      keys2.forEach((key, keyIndex) => {
        matches2.push(
          ...this._findMatches({
            key,
            value: item2[keyIndex],
            searcher
          })
        );
      });
      if (matches2.length) {
        results.push({
          idx,
          item: item2,
          matches: matches2
        });
      }
    });
    return results;
  }
  _findMatches({ key, value: value3, searcher }) {
    if (!isDefined(value3)) {
      return [];
    }
    let matches2 = [];
    if (isArray$1(value3)) {
      value3.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches2.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value3;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches2.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches2;
  }
}
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register$1(ExtendedSearch);
}
class FuseSearch {
  static {
    __name(this, "FuseSearch");
  }
  fuse;
  keys;
  data;
  advancedScoring;
  constructor(data22, options3, createIndex2 = true, advancedScoring = false) {
    this.data = data22;
    this.keys = options3.keys ?? [];
    this.advancedScoring = advancedScoring;
    const index2 = createIndex2 && options3?.keys ? Fuse.createIndex(options3.keys, data22) : void 0;
    this.fuse = new Fuse(data22, options3, index2);
  }
  search(query, options3) {
    const fuseResult = !query ? this.data.map((x2) => ({ item: x2, score: 0 })) : this.fuse.search(query, options3);
    if (!this.advancedScoring) {
      return fuseResult.map((x2) => x2.item);
    }
    const aux = fuseResult.map((x2) => ({
      item: x2.item,
      scores: this.calcAuxScores(query.toLocaleLowerCase(), x2.item, x2.score)
    })).sort((a, b) => this.compareAux(a.scores, b.scores));
    return aux.map((x2) => x2.item);
  }
  calcAuxScores(query, entry, score) {
    let values2 = [];
    if (!this.keys.length) values2 = [entry];
    else values2 = this.keys.map((x2) => entry[x2]);
    const scores = values2.map((x2) => this.calcAuxSingle(query, x2, score));
    let result = scores.sort(this.compareAux)[0];
    const deprecated = values2.some(
      (x2) => x2.toLocaleLowerCase().includes("deprecated")
    );
    result[0] += deprecated && result[0] != 0 ? 5 : 0;
    if (entry["postProcessSearchScores"]) {
      result = entry["postProcessSearchScores"](result);
    }
    return result;
  }
  calcAuxSingle(query, item2, score) {
    const itemWords = item2.split(/ |\b|(?<=[a-z])(?=[A-Z])|(?=[A-Z][a-z])/).map((x2) => x2.toLocaleLowerCase());
    const queryParts = query.split(" ");
    item2 = item2.toLocaleLowerCase();
    let main = 9;
    let aux1 = 0;
    let aux2 = 0;
    if (item2 == query) {
      main = 0;
    } else if (item2.startsWith(query)) {
      main = 1;
      aux2 = item2.length;
    } else if (itemWords.includes(query)) {
      main = 2;
      aux1 = item2.indexOf(query) + item2.length * 0.5;
      aux2 = item2.length;
    } else if (item2.includes(query)) {
      main = 3;
      aux1 = item2.indexOf(query) + item2.length * 0.5;
      aux2 = item2.length;
    } else if (queryParts.every((x2) => itemWords.includes(x2))) {
      const indexes = queryParts.map((x2) => itemWords.indexOf(x2));
      const min = Math.min(...indexes);
      const max = Math.max(...indexes);
      main = 4;
      aux1 = max - min + max * 0.5 + item2.length * 0.5;
      aux2 = item2.length;
    } else if (queryParts.every((x2) => item2.includes(x2))) {
      const min = Math.min(...queryParts.map((x2) => item2.indexOf(x2)));
      const max = Math.max(...queryParts.map((x2) => item2.indexOf(x2) + x2.length));
      main = 5;
      aux1 = max - min + max * 0.5 + item2.length * 0.5;
      aux2 = item2.length;
    }
    const lengthPenalty = 0.2 * (1 - Math.min(item2.length, query.length) / Math.max(item2.length, query.length));
    return [main, aux1, aux2, score + lengthPenalty];
  }
  compareAux(a, b) {
    for (let i2 = 0; i2 < Math.min(a.length, b.length); i2++) {
      if (a[i2] !== b[i2]) {
        return a[i2] - b[i2];
      }
    }
    return a.length - b.length;
  }
}
class NodeFilter {
  static {
    __name(this, "NodeFilter");
  }
  fuseSearch;
  constructor(nodeDefs, options3) {
    this.fuseSearch = new FuseSearch(this.getAllNodeOptions(nodeDefs), options3);
  }
  getAllNodeOptions(nodeDefs) {
    return [
      ...new Set(
        nodeDefs.reduce((acc, nodeDef) => {
          return [...acc, ...this.getNodeOptions(nodeDef)];
        }, [])
      )
    ];
  }
  matches(node3, value3, extraOptions) {
    const matchWildcards = extraOptions?.matchWildcards !== false;
    if (matchWildcards && value3 === "*") {
      return true;
    }
    const options3 = this.getNodeOptions(node3);
    return options3.includes(value3) || matchWildcards && _.some(options3, (option3) => option3 === "*");
  }
}
class InputTypeFilter extends NodeFilter {
  static {
    __name(this, "InputTypeFilter");
  }
  id = "input";
  name = "Input Type";
  invokeSequence = "i";
  longInvokeSequence = "input";
  getNodeOptions(node3) {
    return node3.input.all.map((input) => input.type);
  }
}
class OutputTypeFilter extends NodeFilter {
  static {
    __name(this, "OutputTypeFilter");
  }
  id = "output";
  name = "Output Type";
  invokeSequence = "o";
  longInvokeSequence = "output";
  getNodeOptions(node3) {
    return node3.output.all.map((output) => output.type);
  }
}
class NodeSourceFilter extends NodeFilter {
  static {
    __name(this, "NodeSourceFilter");
  }
  id = "source";
  name = "Source";
  invokeSequence = "s";
  longInvokeSequence = "source";
  getNodeOptions(node3) {
    return [node3.nodeSource.displayText];
  }
}
class NodeCategoryFilter extends NodeFilter {
  static {
    __name(this, "NodeCategoryFilter");
  }
  id = "category";
  name = "Category";
  invokeSequence = "c";
  longInvokeSequence = "category";
  getNodeOptions(node3) {
    return [node3.category];
  }
}
class NodeSearchService {
  static {
    __name(this, "NodeSearchService");
  }
  nodeFuseSearch;
  nodeFilters;
  constructor(data22) {
    this.nodeFuseSearch = new FuseSearch(
      data22,
      {
        keys: ["name", "display_name"],
        includeScore: true,
        threshold: 0.3,
        shouldSort: false,
        useExtendedSearch: true
      },
      true,
      true
    );
    const filterSearchOptions = {
      includeScore: true,
      threshold: 0.3,
      shouldSort: true
    };
    this.nodeFilters = [
      new InputTypeFilter(data22, filterSearchOptions),
      new OutputTypeFilter(data22, filterSearchOptions),
      new NodeCategoryFilter(data22, filterSearchOptions)
    ];
    if (data22[0].python_module !== void 0) {
      this.nodeFilters.push(new NodeSourceFilter(data22, filterSearchOptions));
    }
  }
  endsWithFilterStartSequence(query) {
    return query.endsWith(":");
  }
  searchNode(query, filters = [], options3, extraOptions) {
    const matchedNodes = this.nodeFuseSearch.search(query);
    const results = matchedNodes.filter((node3) => {
      return _.every(filters, (filterAndValue) => {
        const [filter4, value3] = filterAndValue;
        return filter4.matches(node3, value3, extraOptions);
      });
    });
    return options3?.limit ? results.slice(0, options3.limit) : results;
  }
  getFilterById(id3) {
    return this.nodeFilters.find((filter4) => filter4.id === id3);
  }
}
class ComfyInputsSpec {
  static {
    __name(this, "ComfyInputsSpec");
  }
  required;
  optional;
  hidden;
  constructor(obj) {
    this.required = ComfyInputsSpec.transformInputSpecRecord(obj.required ?? {});
    this.optional = ComfyInputsSpec.transformInputSpecRecord(obj.optional ?? {});
    this.hidden = obj.hidden;
  }
  static transformInputSpecRecord(record) {
    const result = {};
    for (const [key, value3] of Object.entries(record)) {
      result[key] = ComfyInputsSpec.transformSingleInputSpec(key, value3);
    }
    return result;
  }
  static isInputSpec(obj) {
    return Array.isArray(obj) && obj.length >= 1 && (typeof obj[0] === "string" || Array.isArray(obj[0]));
  }
  static transformSingleInputSpec(name, value3) {
    if (!ComfyInputsSpec.isInputSpec(value3)) return value3;
    const [typeRaw, _spec] = value3;
    const spec = _spec ?? {};
    const type = Array.isArray(typeRaw) ? "COMBO" : value3[0];
    switch (type) {
      case "COMBO":
        return {
          name,
          type,
          ...spec,
          comboOptions: typeRaw,
          default: spec.default ?? typeRaw[0]
        };
      case "INT":
      case "FLOAT":
      case "BOOLEAN":
      case "STRING":
      default:
        return { name, type, ...spec };
    }
  }
  get all() {
    return [...Object.values(this.required), ...Object.values(this.optional)];
  }
  getInput(name) {
    return this.required[name] ?? this.optional[name];
  }
}
class ComfyOutputSpec {
  static {
    __name(this, "ComfyOutputSpec");
  }
  constructor(index2, name, type, is_list, comboOptions, tooltip) {
    this.index = index2;
    this.name = name;
    this.type = type;
    this.is_list = is_list;
    this.comboOptions = comboOptions;
    this.tooltip = tooltip;
  }
}
class ComfyOutputsSpec {
  static {
    __name(this, "ComfyOutputsSpec");
  }
  constructor(outputs) {
    this.outputs = outputs;
  }
  get all() {
    return this.outputs;
  }
}
class ComfyNodeDefImpl {
  static {
    __name(this, "ComfyNodeDefImpl");
  }
  name;
  display_name;
  category;
  python_module;
  description;
  deprecated;
  experimental;
  input;
  output;
  nodeSource;
  constructor(obj) {
    this.name = obj.name;
    this.display_name = obj.display_name;
    this.category = obj.category;
    this.python_module = obj.python_module;
    this.description = obj.description;
    this.deprecated = obj.deprecated ?? obj.category === "";
    this.experimental = obj.experimental ?? obj.category.startsWith("_for_testing");
    this.input = new ComfyInputsSpec(obj.input ?? {});
    this.output = ComfyNodeDefImpl.transformOutputSpec(obj);
    this.nodeSource = getNodeSource(obj.python_module);
  }
  static transformOutputSpec(obj) {
    const { output, output_is_list, output_name, output_tooltips } = obj;
    const result = (output ?? []).map((type, index2) => {
      const typeString = Array.isArray(type) ? "COMBO" : type;
      return new ComfyOutputSpec(
        index2,
        output_name?.[index2],
        typeString,
        output_is_list?.[index2],
        Array.isArray(type) ? type : void 0,
        output_tooltips?.[index2]
      );
    });
    return new ComfyOutputsSpec(result);
  }
  get nodePath() {
    return (this.category ? this.category + "/" : "") + this.name;
  }
  get isDummyFolder() {
    return this.name === "";
  }
  postProcessSearchScores(scores) {
    const nodeFrequencyStore = useNodeFrequencyStore();
    const nodeFrequency = nodeFrequencyStore.getNodeFrequencyByName(this.name);
    return [scores[0], -nodeFrequency, ...scores.slice(1)];
  }
  get isCoreNode() {
    return this.nodeSource.type === NodeSourceType.Core;
  }
  get nodeLifeCycleBadgeText() {
    if (this.deprecated) return "[DEPR]";
    if (this.experimental) return "[BETA]";
    return "";
  }
}
const SYSTEM_NODE_DEFS = {
  PrimitiveNode: {
    name: "PrimitiveNode",
    display_name: "Primitive",
    category: "utils",
    input: { required: {}, optional: {} },
    output: ["*"],
    output_name: ["connect to widget input"],
    output_is_list: [false],
    output_node: false,
    python_module: "nodes",
    description: "Primitive values like numbers, strings, and booleans."
  },
  Reroute: {
    name: "Reroute",
    display_name: "Reroute",
    category: "utils",
    input: { required: { "": ["*"] }, optional: {} },
    output: ["*"],
    output_name: [""],
    output_is_list: [false],
    output_node: false,
    python_module: "nodes",
    description: "Reroute the connection to another node."
  },
  Note: {
    name: "Note",
    display_name: "Note",
    category: "utils",
    input: { required: {}, optional: {} },
    output: [],
    output_name: [],
    output_is_list: [],
    output_node: false,
    python_module: "nodes",
    description: "Node that add notes to your project"
  }
};
function buildNodeDefTree(nodeDefs) {
  return buildTree(
    nodeDefs,
    (nodeDef) => nodeDef.nodePath.split("/")
  );
}
__name(buildNodeDefTree, "buildNodeDefTree");
function createDummyFolderNodeDef(folderPath) {
  return new ComfyNodeDefImpl({
    name: "",
    display_name: "",
    category: folderPath.endsWith("/") ? folderPath.slice(0, -1) : folderPath,
    python_module: "nodes",
    description: "Dummy Folder Node (User should never see this string)",
    input: {},
    output: [],
    output_name: [],
    output_is_list: [],
    output_node: false
  });
}
__name(createDummyFolderNodeDef, "createDummyFolderNodeDef");
const useNodeDefStore = /* @__PURE__ */ defineStore("nodeDef", () => {
  const nodeDefsByName = ref({});
  const nodeDefsByDisplayName = ref({});
  const widgets = ref({});
  const showDeprecated = ref(false);
  const showExperimental = ref(false);
  const nodeDefs = computed(() => Object.values(nodeDefsByName.value));
  const visibleNodeDefs = computed(
    () => nodeDefs.value.filter(
      (nodeDef) => (showDeprecated.value || !nodeDef.deprecated) && (showExperimental.value || !nodeDef.experimental)
    )
  );
  const nodeSearchService = computed(
    () => new NodeSearchService(visibleNodeDefs.value)
  );
  const nodeTree = computed(() => buildNodeDefTree(visibleNodeDefs.value));
  function updateNodeDefs(nodeDefs2) {
    const newNodeDefsByName = {};
    const newNodeDefsByDisplayName = {};
    for (const nodeDef of nodeDefs2) {
      try {
        const nodeDefImpl = new ComfyNodeDefImpl(nodeDef);
        newNodeDefsByName[nodeDef.name] = nodeDefImpl;
        newNodeDefsByDisplayName[nodeDef.display_name] = nodeDefImpl;
      } catch (e) {
        console.error("Error adding nodeDef:", e);
      }
    }
    nodeDefsByName.value = newNodeDefsByName;
    nodeDefsByDisplayName.value = newNodeDefsByDisplayName;
  }
  __name(updateNodeDefs, "updateNodeDefs");
  function addNodeDef(nodeDef) {
    const nodeDefImpl = new ComfyNodeDefImpl(nodeDef);
    nodeDefsByName.value[nodeDef.name] = nodeDefImpl;
    nodeDefsByDisplayName.value[nodeDef.display_name] = nodeDefImpl;
  }
  __name(addNodeDef, "addNodeDef");
  function fromLGraphNode(node3) {
    return nodeDefsByName.value[node3.constructor?.nodeData?.name] ?? null;
  }
  __name(fromLGraphNode, "fromLGraphNode");
  return {
    nodeDefsByName,
    nodeDefsByDisplayName,
    showDeprecated,
    showExperimental,
    nodeDefs,
    visibleNodeDefs,
    nodeSearchService,
    nodeTree,
    updateNodeDefs,
    addNodeDef,
    fromLGraphNode
  };
});
const useNodeFrequencyStore = /* @__PURE__ */ defineStore("nodeFrequency", () => {
  const topNodeDefLimit = ref(64);
  const nodeFrequencyLookup = ref({});
  const nodeNamesByFrequency = computed(
    () => Object.keys(nodeFrequencyLookup.value)
  );
  const isLoaded = ref(false);
  const loadNodeFrequencies = /* @__PURE__ */ __name(async () => {
    if (!isLoaded.value) {
      try {
        const response = await axios.get("assets/sorted-custom-node-map.json");
        nodeFrequencyLookup.value = response.data;
        isLoaded.value = true;
      } catch (error) {
        console.error("Error loading node frequencies:", error);
      }
    }
  }, "loadNodeFrequencies");
  const getNodeFrequency = /* @__PURE__ */ __name((nodeDef) => {
    return getNodeFrequencyByName(nodeDef.name);
  }, "getNodeFrequency");
  const getNodeFrequencyByName = /* @__PURE__ */ __name((nodeName) => {
    return nodeFrequencyLookup.value[nodeName] ?? 0;
  }, "getNodeFrequencyByName");
  const nodeDefStore = useNodeDefStore();
  const topNodeDefs = computed(() => {
    return nodeNamesByFrequency.value.map((nodeName) => nodeDefStore.nodeDefsByName[nodeName]).filter((nodeDef) => nodeDef !== void 0).slice(0, topNodeDefLimit.value);
  });
  return {
    nodeNamesByFrequency,
    topNodeDefs,
    isLoaded,
    loadNodeFrequencies,
    getNodeFrequency,
    getNodeFrequencyByName
  };
});
function _findInMetadata(metadata, ...keys2) {
  for (const key of keys2) {
    if (key in metadata) {
      return metadata[key];
    }
    for (const k in metadata) {
      if (k.endsWith(key)) {
        return metadata[k];
      }
    }
  }
  return null;
}
__name(_findInMetadata, "_findInMetadata");
class ComfyModelDef {
  static {
    __name(this, "ComfyModelDef");
  }
  /** Proper filename of the model */
  file_name;
  /** Normalized filename of the model, with all backslashes replaced with forward slashes */
  normalized_file_name;
  /** Directory containing the model, eg 'checkpoints' */
  directory;
  /** Simplified copy of name, used as a default title. Excludes the directory and the '.safetensors' file extension */
  simplified_file_name;
  /** Key for the model, used to uniquely identify the model. */
  key;
  /** Title / display name of the model, sometimes same as the name but not always */
  title;
  /** Metadata: architecture ID for the model, such as 'stable-diffusion-xl-v1-base' */
  architecture_id = "";
  /** Metadata: author of the model */
  author = "";
  /** Metadata: resolution of the model, eg '1024x1024' */
  resolution = "";
  /** Metadata: description of the model */
  description = "";
  /** Metadata: usage hint for the model */
  usage_hint = "";
  /** Metadata: trigger phrase for the model */
  trigger_phrase = "";
  /** Metadata: tags list for the model */
  tags = [];
  /** Metadata: image for the model */
  image = "";
  /** Whether the model metadata has been loaded from the server, used for `load()` */
  has_loaded_metadata = false;
  /** If true, a metadata load request has been triggered, but may or may not yet have finished loading */
  is_load_requested = false;
  /** A string full of auto-computed lowercase-only searchable text for this model */
  searchable = "";
  constructor(name, directory) {
    this.file_name = name;
    this.normalized_file_name = name.replaceAll("\\", "/");
    this.simplified_file_name = this.normalized_file_name.split("/").pop() ?? "";
    if (this.simplified_file_name.endsWith(".safetensors")) {
      this.simplified_file_name = this.simplified_file_name.slice(
        0,
        -".safetensors".length
      );
    }
    this.title = this.simplified_file_name;
    this.directory = directory;
    this.key = `${directory}/${this.normalized_file_name}`;
    this.updateSearchable();
  }
  updateSearchable() {
    this.searchable = [
      this.file_name,
      this.title,
      this.author,
      this.description,
      this.trigger_phrase,
      this.tags.join(", ")
    ].join("\n").toLowerCase();
  }
  /** Loads the model metadata from the server, filling in this object if data is available */
  async load() {
    if (this.has_loaded_metadata || this.is_load_requested) {
      return;
    }
    this.is_load_requested = true;
    try {
      const metadata = await api.viewMetadata(this.directory, this.file_name);
      if (!metadata) {
        return;
      }
      this.title = _findInMetadata(
        metadata,
        "modelspec.title",
        "title",
        "display_name",
        "name"
      ) || this.title;
      this.architecture_id = _findInMetadata(metadata, "modelspec.architecture", "architecture") || "";
      this.author = _findInMetadata(metadata, "modelspec.author", "author") || "";
      this.description = _findInMetadata(metadata, "modelspec.description", "description") || "";
      this.resolution = _findInMetadata(metadata, "modelspec.resolution", "resolution") || "";
      this.usage_hint = _findInMetadata(metadata, "modelspec.usage_hint", "usage_hint") || "";
      this.trigger_phrase = _findInMetadata(
        metadata,
        "modelspec.trigger_phrase",
        "trigger_phrase"
      ) || "";
      this.image = _findInMetadata(
        metadata,
        "modelspec.thumbnail",
        "thumbnail",
        "image",
        "icon"
      ) || "";
      const tagsCommaSeparated = _findInMetadata(metadata, "modelspec.tags", "tags") || "";
      this.tags = tagsCommaSeparated.split(",").map((tag) => tag.trim());
      this.has_loaded_metadata = true;
      this.updateSearchable();
    } catch (error) {
      console.error("Error loading model metadata", this.file_name, this, error);
    }
  }
}
var ResourceState = /* @__PURE__ */ ((ResourceState2) => {
  ResourceState2[ResourceState2["Uninitialized"] = 0] = "Uninitialized";
  ResourceState2[ResourceState2["Loading"] = 1] = "Loading";
  ResourceState2[ResourceState2["Loaded"] = 2] = "Loaded";
  return ResourceState2;
})(ResourceState || {});
class ModelFolder {
  static {
    __name(this, "ModelFolder");
  }
  constructor(directory) {
    this.directory = directory;
  }
  /** Models in this folder */
  models = {};
  state = 0;
  get key() {
    return this.directory + "/";
  }
  /**
   * Loads the models in this folder from the server
   */
  async load() {
    if (this.state !== 0) {
      return this;
    }
    this.state = 1;
    const models = await api.getModels(this.directory);
    for (const model of models) {
      this.models[model] = new ComfyModelDef(model, this.directory);
    }
    this.state = 2;
    return this;
  }
}
const useModelStore = /* @__PURE__ */ defineStore("models", () => {
  const modelFolderNames = ref([]);
  const modelFolderByName = ref({});
  const modelFolders = computed(
    () => modelFolderNames.value.map(
      (folderName) => modelFolderByName.value[folderName]
    )
  );
  const models = computed(
    () => modelFolders.value.flatMap((folder) => Object.values(folder.models))
  );
  async function loadModelFolders() {
    modelFolderNames.value = await api.getModelFolders();
    modelFolderByName.value = {};
    for (const folderName of modelFolderNames.value) {
      modelFolderByName.value[folderName] = new ModelFolder(folderName);
    }
  }
  __name(loadModelFolders, "loadModelFolders");
  async function getLoadedModelFolder(folderName) {
    const folder = modelFolderByName.value[folderName];
    return folder ? await folder.load() : null;
  }
  __name(getLoadedModelFolder, "getLoadedModelFolder");
  async function loadModels() {
    return Promise.all(modelFolders.value.map((folder) => folder.load()));
  }
  __name(loadModels, "loadModels");
  return {
    models,
    modelFolders,
    loadModelFolders,
    loadModels,
    getLoadedModelFolder
  };
});
class ComfyAsyncDialog extends ComfyDialog$1 {
  static {
    __name(this, "ComfyAsyncDialog");
  }
  #resolve;
  constructor(actions) {
    super(
      "dialog.comfy-dialog.comfyui-dialog",
      actions?.map((opt) => {
        if (typeof opt === "string") {
          opt = { text: opt };
        }
        return $el("button.comfyui-button", {
          type: "button",
          textContent: opt.text,
          onclick: /* @__PURE__ */ __name(() => this.close(opt.value ?? opt.text), "onclick")
        });
      })
    );
  }
  show(html) {
    this.element.addEventListener("close", () => {
      this.close();
    });
    super.show(html);
    return new Promise((resolve2) => {
      this.#resolve = resolve2;
    });
  }
  showModal(html) {
    this.element.addEventListener("close", () => {
      this.close();
    });
    super.show(html);
    this.element.showModal();
    return new Promise((resolve2) => {
      this.#resolve = resolve2;
    });
  }
  close(result = null) {
    this.#resolve(result);
    this.element.close();
    super.close();
  }
  static async prompt({
    title = null,
    message: message2,
    actions
  }) {
    const dialog = new ComfyAsyncDialog(actions);
    const content2 = [$el("span", message2)];
    if (title) {
      content2.unshift($el("h3", title));
    }
    const res = await dialog.showModal(content2);
    dialog.element.remove();
    return res;
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.asyncDialog = window.comfyAPI.asyncDialog || {};
window.comfyAPI.asyncDialog.ComfyAsyncDialog = ComfyAsyncDialog;
async function syncEntities(dir, entityByPath, createEntity, updateEntity, exclude = () => false) {
  const files = (await api.listUserDataFullInfo(dir)).map((file) => ({
    ...file,
    path: dir ? `${dir}/${file.path}` : file.path
  }));
  for (const file of files) {
    const existingEntity = entityByPath[file.path];
    if (!existingEntity) {
      entityByPath[file.path] = createEntity(file);
    } else if (exclude(existingEntity)) {
      continue;
    } else {
      updateEntity(existingEntity, file);
    }
  }
  for (const [path, entity] of Object.entries(entityByPath)) {
    if (exclude(entity)) continue;
    if (!files.some((file) => file.path === path)) {
      delete entityByPath[path];
    }
  }
}
__name(syncEntities, "syncEntities");
class UserFile {
  static {
    __name(this, "UserFile");
  }
  constructor(path, lastModified, size2) {
    this.path = path;
    this.lastModified = lastModified;
    this.size = size2;
    const details = getPathDetails(path);
    this.path = path;
    this.directory = details.directory;
    this.fullFilename = details.fullFilename;
    this.filename = details.filename;
    this.suffix = details.suffix;
  }
  /**
   * Various path components.
   * Example:
   * - path: 'dir/file.txt'
   * - directory: 'dir'
   * - fullFilename: 'file.txt'
   * - filename: 'file'
   * - suffix: 'txt'
   */
  directory;
  fullFilename;
  filename;
  suffix;
  isLoading = false;
  content = null;
  originalContent = null;
  updatePath(newPath) {
    const details = getPathDetails(newPath);
    this.path = newPath;
    this.directory = details.directory;
    this.fullFilename = details.fullFilename;
    this.filename = details.filename;
    this.suffix = details.suffix;
  }
  static createTemporary(path) {
    return new UserFile(path, Date.now(), -1);
  }
  get isTemporary() {
    return this.size === -1;
  }
  get isPersisted() {
    return !this.isTemporary;
  }
  get key() {
    return this.path;
  }
  get isLoaded() {
    return this.content !== null;
  }
  get isModified() {
    return this.content !== this.originalContent;
  }
  /**
   * Loads the file content from the remote storage.
   */
  async load({
    force = false
  } = {}) {
    if (this.isTemporary || !force && this.isLoaded)
      return this;
    this.isLoading = true;
    const resp = await api.getUserData(this.path);
    if (resp.status !== 200) {
      throw new Error(
        `Failed to load file '${this.path}': ${resp.status} ${resp.statusText}`
      );
    }
    this.content = await resp.text();
    this.originalContent = this.content;
    this.isLoading = false;
    return this;
  }
  /**
   * Unloads the file content from memory
   */
  unload() {
    this.content = null;
    this.originalContent = null;
    this.isLoading = false;
  }
  async saveAs(newPath) {
    const tempFile = this.isTemporary ? this : UserFile.createTemporary(newPath);
    tempFile.content = this.content;
    await tempFile.save();
    return tempFile;
  }
  /**
   * Saves the file to the remote storage.
   * @param force Whether to force the save even if the file is not modified.
   */
  async save({ force = false } = {}) {
    if (this.isPersisted && !this.isModified && !force) return this;
    const resp = await api.storeUserData(this.path, this.content, {
      overwrite: this.isPersisted,
      throwOnError: true,
      full_info: true
    });
    const updatedFile = await resp.json();
    if (typeof updatedFile === "object") {
      this.lastModified = updatedFile.modified;
      this.size = updatedFile.size;
    }
    this.originalContent = this.content;
    return this;
  }
  async delete() {
    if (this.isTemporary) return;
    const resp = await api.deleteUserData(this.path);
    if (resp.status !== 204) {
      throw new Error(
        `Failed to delete file '${this.path}': ${resp.status} ${resp.statusText}`
      );
    }
  }
  async rename(newPath) {
    if (this.isTemporary) {
      this.updatePath(newPath);
      return this;
    }
    const resp = await api.moveUserData(this.path, newPath);
    if (resp.status !== 200) {
      throw new Error(
        `Failed to rename file '${this.path}': ${resp.status} ${resp.statusText}`
      );
    }
    this.updatePath(newPath);
    const updatedFile = await resp.json();
    if (typeof updatedFile === "object") {
      this.lastModified = updatedFile.modified;
      this.size = updatedFile.size;
    }
    return this;
  }
}
const useUserFileStore = /* @__PURE__ */ defineStore("userFile", () => {
  const userFilesByPath = ref({});
  const userFiles = computed(() => Object.values(userFilesByPath.value));
  const modifiedFiles = computed(
    () => userFiles.value.filter((file) => file.isModified)
  );
  const loadedFiles = computed(
    () => userFiles.value.filter((file) => file.isLoaded)
  );
  const fileTree = computed(
    () => buildTree(
      userFiles.value,
      (userFile) => userFile.path.split("/")
    )
  );
  const syncFiles = /* @__PURE__ */ __name(async (dir = "") => {
    await syncEntities(
      dir,
      userFilesByPath.value,
      (file) => new UserFile(file.path, file.modified, file.size),
      (existingFile, file) => {
        existingFile.lastModified = file.modified;
        existingFile.size = file.size;
        existingFile.unload();
      }
    );
  }, "syncFiles");
  return {
    userFiles,
    modifiedFiles,
    loadedFiles,
    fileTree,
    syncFiles
  };
});
class Processor {
  static {
    __name(this, "Processor");
  }
  constructor(options3) {
    this.selfOptions = options3 || {};
    this.pipes = {};
  }
  options(options3) {
    if (options3) {
      this.selfOptions = options3;
    }
    return this.selfOptions;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  pipe(name, pipeArg) {
    let pipe = pipeArg;
    if (typeof name === "string") {
      if (typeof pipe === "undefined") {
        return this.pipes[name];
      } else {
        this.pipes[name] = pipe;
      }
    }
    if (name && name.name) {
      pipe = name;
      if (pipe.processor === this) {
        return pipe;
      }
      this.pipes[pipe.name] = pipe;
    }
    pipe.processor = this;
    return pipe;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  process(input, pipe) {
    let context = input;
    context.options = this.options();
    let nextPipe = pipe || input.pipe || "default";
    let lastPipe;
    while (nextPipe) {
      if (typeof context.nextAfterChildren !== "undefined") {
        context.next = context.nextAfterChildren;
        context.nextAfterChildren = null;
      }
      if (typeof nextPipe === "string") {
        nextPipe = this.pipe(nextPipe);
      }
      nextPipe.process(context);
      lastPipe = nextPipe;
      nextPipe = null;
      if (context) {
        if (context.next) {
          context = context.next;
          nextPipe = context.pipe || lastPipe;
        }
      }
    }
    return context.hasResult ? context.result : void 0;
  }
}
class Pipe {
  static {
    __name(this, "Pipe");
  }
  constructor(name) {
    this.name = name;
    this.filters = [];
  }
  process(input) {
    if (!this.processor) {
      throw new Error("add this pipe to a processor before using it");
    }
    const debug = this.debug;
    const length = this.filters.length;
    const context = input;
    for (let index2 = 0; index2 < length; index2++) {
      const filter4 = this.filters[index2];
      if (debug) {
        this.log(`filter: ${filter4.filterName}`);
      }
      filter4(context);
      if (typeof context === "object" && context.exiting) {
        context.exiting = false;
        break;
      }
    }
    if (!context.next && this.resultCheck) {
      this.resultCheck(context);
    }
  }
  log(msg) {
    console.log(`[jsondiffpatch] ${this.name} pipe, ${msg}`);
  }
  append(...args) {
    this.filters.push(...args);
    return this;
  }
  prepend(...args) {
    this.filters.unshift(...args);
    return this;
  }
  indexOf(filterName) {
    if (!filterName) {
      throw new Error("a filter name is required");
    }
    for (let index2 = 0; index2 < this.filters.length; index2++) {
      const filter4 = this.filters[index2];
      if (filter4.filterName === filterName) {
        return index2;
      }
    }
    throw new Error(`filter not found: ${filterName}`);
  }
  list() {
    return this.filters.map((f) => f.filterName);
  }
  after(filterName, ...params) {
    const index2 = this.indexOf(filterName);
    this.filters.splice(index2 + 1, 0, ...params);
    return this;
  }
  before(filterName, ...params) {
    const index2 = this.indexOf(filterName);
    this.filters.splice(index2, 0, ...params);
    return this;
  }
  replace(filterName, ...params) {
    const index2 = this.indexOf(filterName);
    this.filters.splice(index2, 1, ...params);
    return this;
  }
  remove(filterName) {
    const index2 = this.indexOf(filterName);
    this.filters.splice(index2, 1);
    return this;
  }
  clear() {
    this.filters.length = 0;
    return this;
  }
  shouldHaveResult(should) {
    if (should === false) {
      this.resultCheck = null;
      return;
    }
    if (this.resultCheck) {
      return;
    }
    this.resultCheck = (context) => {
      if (!context.hasResult) {
        console.log(context);
        const error = new Error(`${this.name} failed`);
        error.noResult = true;
        throw error;
      }
    };
    return this;
  }
}
class Context {
  static {
    __name(this, "Context");
  }
  setResult(result) {
    this.result = result;
    this.hasResult = true;
    return this;
  }
  exit() {
    this.exiting = true;
    return this;
  }
  push(child, name) {
    child.parent = this;
    if (typeof name !== "undefined") {
      child.childName = name;
    }
    child.root = this.root || this;
    child.options = child.options || this.options;
    if (!this.children) {
      this.children = [child];
      this.nextAfterChildren = this.next || null;
      this.next = child;
    } else {
      this.children[this.children.length - 1].next = child;
      this.children.push(child);
    }
    child.next = this;
    return this;
  }
}
function cloneRegExp(re) {
  const regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
  return new RegExp(regexMatch[1], regexMatch[2]);
}
__name(cloneRegExp, "cloneRegExp");
function clone$2(arg) {
  if (typeof arg !== "object") {
    return arg;
  }
  if (arg === null) {
    return null;
  }
  if (Array.isArray(arg)) {
    return arg.map(clone$2);
  }
  if (arg instanceof Date) {
    return new Date(arg.getTime());
  }
  if (arg instanceof RegExp) {
    return cloneRegExp(arg);
  }
  const cloned = {};
  for (const name in arg) {
    if (Object.prototype.hasOwnProperty.call(arg, name)) {
      cloned[name] = clone$2(arg[name]);
    }
  }
  return cloned;
}
__name(clone$2, "clone$2");
class DiffContext extends Context {
  static {
    __name(this, "DiffContext");
  }
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
    this.pipe = "diff";
  }
  setResult(result) {
    if (this.options.cloneDiffValues && typeof result === "object") {
      const clone2 = typeof this.options.cloneDiffValues === "function" ? this.options.cloneDiffValues : clone$2;
      if (typeof result[0] === "object") {
        result[0] = clone2(result[0]);
      }
      if (typeof result[1] === "object") {
        result[1] = clone2(result[1]);
      }
    }
    return super.setResult(result);
  }
}
class PatchContext extends Context {
  static {
    __name(this, "PatchContext");
  }
  constructor(left, delta2) {
    super();
    this.left = left;
    this.delta = delta2;
    this.pipe = "patch";
  }
}
class ReverseContext extends Context {
  static {
    __name(this, "ReverseContext");
  }
  constructor(delta2) {
    super();
    this.delta = delta2;
    this.pipe = "reverse";
  }
}
const diffFilter$3 = /* @__PURE__ */ __name(function trivialMatchesDiffFilter(context) {
  if (context.left === context.right) {
    context.setResult(void 0).exit();
    return;
  }
  if (typeof context.left === "undefined") {
    if (typeof context.right === "function") {
      throw new Error("functions are not supported");
    }
    context.setResult([context.right]).exit();
    return;
  }
  if (typeof context.right === "undefined") {
    context.setResult([context.left, 0, 0]).exit();
    return;
  }
  if (typeof context.left === "function" || typeof context.right === "function") {
    throw new Error("functions are not supported");
  }
  context.leftType = context.left === null ? "null" : typeof context.left;
  context.rightType = context.right === null ? "null" : typeof context.right;
  if (context.leftType !== context.rightType) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === "boolean" || context.leftType === "number") {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === "object") {
    context.leftIsArray = Array.isArray(context.left);
  }
  if (context.rightType === "object") {
    context.rightIsArray = Array.isArray(context.right);
  }
  if (context.leftIsArray !== context.rightIsArray) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.left instanceof RegExp) {
    if (context.right instanceof RegExp) {
      context.setResult([context.left.toString(), context.right.toString()]).exit();
    } else {
      context.setResult([context.left, context.right]).exit();
    }
  }
}, "trivialMatchesDiffFilter");
diffFilter$3.filterName = "trivial";
const patchFilter$3 = /* @__PURE__ */ __name(function trivialMatchesPatchFilter(context) {
  if (typeof context.delta === "undefined") {
    context.setResult(context.left).exit();
    return;
  }
  context.nested = !Array.isArray(context.delta);
  if (context.nested) {
    return;
  }
  const nonNestedDelta = context.delta;
  if (nonNestedDelta.length === 1) {
    context.setResult(nonNestedDelta[0]).exit();
    return;
  }
  if (nonNestedDelta.length === 2) {
    if (context.left instanceof RegExp) {
      const regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(nonNestedDelta[1]);
      if (regexArgs) {
        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
        return;
      }
    }
    context.setResult(nonNestedDelta[1]).exit();
    return;
  }
  if (nonNestedDelta.length === 3 && nonNestedDelta[2] === 0) {
    context.setResult(void 0).exit();
  }
}, "trivialMatchesPatchFilter");
patchFilter$3.filterName = "trivial";
const reverseFilter$3 = /* @__PURE__ */ __name(function trivialReferseFilter(context) {
  if (typeof context.delta === "undefined") {
    context.setResult(context.delta).exit();
    return;
  }
  context.nested = !Array.isArray(context.delta);
  if (context.nested) {
    return;
  }
  const nonNestedDelta = context.delta;
  if (nonNestedDelta.length === 1) {
    context.setResult([nonNestedDelta[0], 0, 0]).exit();
    return;
  }
  if (nonNestedDelta.length === 2) {
    context.setResult([nonNestedDelta[1], nonNestedDelta[0]]).exit();
    return;
  }
  if (nonNestedDelta.length === 3 && nonNestedDelta[2] === 0) {
    context.setResult([nonNestedDelta[0]]).exit();
  }
}, "trivialReferseFilter");
reverseFilter$3.filterName = "trivial";
const collectChildrenDiffFilter = /* @__PURE__ */ __name((context) => {
  if (!context || !context.children) {
    return;
  }
  const length = context.children.length;
  let child;
  let result = context.result;
  for (let index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    if (typeof child.result === "undefined") {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context.leftIsArray) {
    result._t = "a";
  }
  context.setResult(result).exit();
}, "collectChildrenDiffFilter");
collectChildrenDiffFilter.filterName = "collectChildren";
const objectsDiffFilter = /* @__PURE__ */ __name((context) => {
  if (context.leftIsArray || context.leftType !== "object") {
    return;
  }
  const left = context.left;
  const right = context.right;
  let name;
  let child;
  const propertyFilter = context.options.propertyFilter;
  for (name in left) {
    if (!Object.prototype.hasOwnProperty.call(left, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    child = new DiffContext(left[name], right[name]);
    context.push(child, name);
  }
  for (name in right) {
    if (!Object.prototype.hasOwnProperty.call(right, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    if (typeof left[name] === "undefined") {
      child = new DiffContext(void 0, right[name]);
      context.push(child, name);
    }
  }
  if (!context.children || context.children.length === 0) {
    context.setResult(void 0).exit();
    return;
  }
  context.exit();
}, "objectsDiffFilter");
objectsDiffFilter.filterName = "objects";
const patchFilter$2 = /* @__PURE__ */ __name(function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  const nestedDelta = context.delta;
  if (nestedDelta._t) {
    return;
  }
  const objectDelta = nestedDelta;
  let name;
  let child;
  for (name in objectDelta) {
    child = new PatchContext(context.left[name], objectDelta[name]);
    context.push(child, name);
  }
  context.exit();
}, "nestedPatchFilter");
patchFilter$2.filterName = "objects";
const collectChildrenPatchFilter$1 = /* @__PURE__ */ __name(function collectChildrenPatchFilter2(context) {
  if (!context || !context.children) {
    return;
  }
  const deltaWithChildren = context.delta;
  if (deltaWithChildren._t) {
    return;
  }
  const object = context.left;
  const length = context.children.length;
  let child;
  for (let index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    const property = child.childName;
    if (Object.prototype.hasOwnProperty.call(context.left, property) && child.result === void 0) {
      delete object[property];
    } else if (object[property] !== child.result) {
      object[property] = child.result;
    }
  }
  context.setResult(object).exit();
}, "collectChildrenPatchFilter");
collectChildrenPatchFilter$1.filterName = "collectChildren";
const reverseFilter$2 = /* @__PURE__ */ __name(function nestedReverseFilter(context) {
  if (!context.nested) {
    return;
  }
  const nestedDelta = context.delta;
  if (nestedDelta._t) {
    return;
  }
  const objectDelta = context.delta;
  let name;
  let child;
  for (name in objectDelta) {
    child = new ReverseContext(objectDelta[name]);
    context.push(child, name);
  }
  context.exit();
}, "nestedReverseFilter");
reverseFilter$2.filterName = "objects";
const collectChildrenReverseFilter$1 = /* @__PURE__ */ __name((context) => {
  if (!context || !context.children) {
    return;
  }
  const deltaWithChildren = context.delta;
  if (deltaWithChildren._t) {
    return;
  }
  const length = context.children.length;
  let child;
  const delta2 = {};
  for (let index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    const property = child.childName;
    if (delta2[property] !== child.result) {
      delta2[property] = child.result;
    }
  }
  context.setResult(delta2).exit();
}, "collectChildrenReverseFilter$1");
collectChildrenReverseFilter$1.filterName = "collectChildren";
const defaultMatch = /* @__PURE__ */ __name(function(array1, array2, index1, index2) {
  return array1[index1] === array2[index2];
}, "defaultMatch");
const lengthMatrix = /* @__PURE__ */ __name(function(array1, array2, match, context) {
  const len1 = array1.length;
  const len2 = array2.length;
  let x2, y2;
  const matrix = new Array(len1 + 1);
  for (x2 = 0; x2 < len1 + 1; x2++) {
    matrix[x2] = new Array(len2 + 1);
    for (y2 = 0; y2 < len2 + 1; y2++) {
      matrix[x2][y2] = 0;
    }
  }
  matrix.match = match;
  for (x2 = 1; x2 < len1 + 1; x2++) {
    for (y2 = 1; y2 < len2 + 1; y2++) {
      if (match(array1, array2, x2 - 1, y2 - 1, context)) {
        matrix[x2][y2] = matrix[x2 - 1][y2 - 1] + 1;
      } else {
        matrix[x2][y2] = Math.max(matrix[x2 - 1][y2], matrix[x2][y2 - 1]);
      }
    }
  }
  return matrix;
}, "lengthMatrix");
const backtrack = /* @__PURE__ */ __name(function(matrix, array1, array2, context) {
  let index1 = array1.length;
  let index2 = array2.length;
  const subsequence = {
    sequence: [],
    indices1: [],
    indices2: []
  };
  while (index1 !== 0 && index2 !== 0) {
    const sameLetter = matrix.match(array1, array2, index1 - 1, index2 - 1, context);
    if (sameLetter) {
      subsequence.sequence.unshift(array1[index1 - 1]);
      subsequence.indices1.unshift(index1 - 1);
      subsequence.indices2.unshift(index2 - 1);
      --index1;
      --index2;
    } else {
      const valueAtMatrixAbove = matrix[index1][index2 - 1];
      const valueAtMatrixLeft = matrix[index1 - 1][index2];
      if (valueAtMatrixAbove > valueAtMatrixLeft) {
        --index2;
      } else {
        --index1;
      }
    }
  }
  return subsequence;
}, "backtrack");
const get = /* @__PURE__ */ __name(function(array1, array2, match, context) {
  const innerContext = context || {};
  const matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);
  return backtrack(matrix, array1, array2, innerContext);
}, "get");
const lcs = {
  get
};
const ARRAY_MOVE = 3;
function arraysHaveMatchByRef(array1, array2, len1, len2) {
  for (let index1 = 0; index1 < len1; index1++) {
    const val1 = array1[index1];
    for (let index2 = 0; index2 < len2; index2++) {
      const val2 = array2[index2];
      if (index1 !== index2 && val1 === val2) {
        return true;
      }
    }
  }
}
__name(arraysHaveMatchByRef, "arraysHaveMatchByRef");
function matchItems(array1, array2, index1, index2, context) {
  const value1 = array1[index1];
  const value22 = array2[index2];
  if (value1 === value22) {
    return true;
  }
  if (typeof value1 !== "object" || typeof value22 !== "object") {
    return false;
  }
  const objectHash = context.objectHash;
  if (!objectHash) {
    return context.matchByPosition && index1 === index2;
  }
  context.hashCache1 = context.hashCache1 || [];
  let hash1 = context.hashCache1[index1];
  if (typeof hash1 === "undefined") {
    context.hashCache1[index1] = hash1 = objectHash(value1, index1);
  }
  if (typeof hash1 === "undefined") {
    return false;
  }
  context.hashCache2 = context.hashCache2 || [];
  let hash2 = context.hashCache2[index2];
  if (typeof hash2 === "undefined") {
    context.hashCache2[index2] = hash2 = objectHash(value22, index2);
  }
  if (typeof hash2 === "undefined") {
    return false;
  }
  return hash1 === hash2;
}
__name(matchItems, "matchItems");
const diffFilter$2 = /* @__PURE__ */ __name(function arraysDiffFilter(context) {
  if (!context.leftIsArray) {
    return;
  }
  const matchContext = {
    objectHash: context.options && context.options.objectHash,
    matchByPosition: context.options && context.options.matchByPosition
  };
  let commonHead = 0;
  let commonTail = 0;
  let index2;
  let index1;
  let index22;
  const array1 = context.left;
  const array2 = context.right;
  const len1 = array1.length;
  const len2 = array2.length;
  let child;
  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== "boolean") {
    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
  }
  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {
    index2 = commonHead;
    child = new DiffContext(array1[index2], array2[index2]);
    context.push(child, index2);
    commonHead++;
  }
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
    index1 = len1 - 1 - commonTail;
    index22 = len2 - 1 - commonTail;
    child = new DiffContext(array1[index1], array2[index22]);
    context.push(child, index22);
    commonTail++;
  }
  let result;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      context.setResult(void 0).exit();
      return;
    }
    result = result || {
      _t: "a"
    };
    for (index2 = commonHead; index2 < len2 - commonTail; index2++) {
      result[index2] = [array2[index2]];
    }
    context.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    result = result || {
      _t: "a"
    };
    for (index2 = commonHead; index2 < len1 - commonTail; index2++) {
      result[`_${index2}`] = [array1[index2], 0, 0];
    }
    context.setResult(result).exit();
    return;
  }
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;
  const trimmed1 = array1.slice(commonHead, len1 - commonTail);
  const trimmed2 = array2.slice(commonHead, len2 - commonTail);
  const seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);
  const removedItems = [];
  result = result || {
    _t: "a"
  };
  for (index2 = commonHead; index2 < len1 - commonTail; index2++) {
    if (seq.indices1.indexOf(index2 - commonHead) < 0) {
      result[`_${index2}`] = [array1[index2], 0, 0];
      removedItems.push(index2);
    }
  }
  let detectMove = true;
  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
    detectMove = false;
  }
  let includeValueOnMove = false;
  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }
  const removedItemsLength = removedItems.length;
  for (index2 = commonHead; index2 < len2 - commonTail; index2++) {
    const indexOnArray2 = seq.indices2.indexOf(index2 - commonHead);
    if (indexOnArray2 < 0) {
      let isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (let removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index2 - commonHead, matchContext)) {
            result[`_${index1}`].splice(1, 2, index2, ARRAY_MOVE);
            if (!includeValueOnMove) {
              result[`_${index1}`][0] = "";
            }
            index22 = index2;
            child = new DiffContext(array1[index1], array2[index22]);
            context.push(child, index22);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        result[index2] = [array2[index2]];
      }
    } else {
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index22 = seq.indices2[indexOnArray2] + commonHead;
      child = new DiffContext(array1[index1], array2[index22]);
      context.push(child, index22);
    }
  }
  context.setResult(result).exit();
}, "arraysDiffFilter");
diffFilter$2.filterName = "arrays";
const compare = {
  numerically(a, b) {
    return a - b;
  },
  numericallyBy(name) {
    return (a, b) => a[name] - b[name];
  }
};
const patchFilter$1 = /* @__PURE__ */ __name(function nestedPatchFilter2(context) {
  if (!context.nested) {
    return;
  }
  const nestedDelta = context.delta;
  if (nestedDelta._t !== "a") {
    return;
  }
  let index2;
  let index1;
  const delta2 = nestedDelta;
  const array = context.left;
  let toRemove = [];
  let toInsert = [];
  const toModify = [];
  for (index2 in delta2) {
    if (index2 !== "_t") {
      if (index2[0] === "_") {
        const removedOrMovedIndex = index2;
        if (delta2[removedOrMovedIndex][2] === 0 || delta2[removedOrMovedIndex][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index2.slice(1), 10));
        } else {
          throw new Error(`only removal or move can be applied at original array indices, invalid diff type: ${delta2[removedOrMovedIndex][2]}`);
        }
      } else {
        const numberIndex = index2;
        if (delta2[numberIndex].length === 1) {
          toInsert.push({
            index: parseInt(numberIndex, 10),
            value: delta2[numberIndex][0]
          });
        } else {
          toModify.push({
            index: parseInt(numberIndex, 10),
            delta: delta2[numberIndex]
          });
        }
      }
    }
  }
  toRemove = toRemove.sort(compare.numerically);
  for (index2 = toRemove.length - 1; index2 >= 0; index2--) {
    index1 = toRemove[index2];
    const indexDiff = delta2[`_${index1}`];
    const removedValue = array.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }
  toInsert = toInsert.sort(compare.numericallyBy("index"));
  const toInsertLength = toInsert.length;
  for (index2 = 0; index2 < toInsertLength; index2++) {
    const insertion = toInsert[index2];
    array.splice(insertion.index, 0, insertion.value);
  }
  const toModifyLength = toModify.length;
  let child;
  if (toModifyLength > 0) {
    for (index2 = 0; index2 < toModifyLength; index2++) {
      const modification = toModify[index2];
      child = new PatchContext(array[modification.index], modification.delta);
      context.push(child, modification.index);
    }
  }
  if (!context.children) {
    context.setResult(array).exit();
    return;
  }
  context.exit();
}, "nestedPatchFilter");
patchFilter$1.filterName = "arrays";
const collectChildrenPatchFilter = /* @__PURE__ */ __name(function collectChildrenPatchFilter3(context) {
  if (!context || !context.children) {
    return;
  }
  const deltaWithChildren = context.delta;
  if (deltaWithChildren._t !== "a") {
    return;
  }
  const array = context.left;
  const length = context.children.length;
  let child;
  for (let index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    const arrayIndex = child.childName;
    array[arrayIndex] = child.result;
  }
  context.setResult(array).exit();
}, "collectChildrenPatchFilter");
collectChildrenPatchFilter.filterName = "arraysCollectChildren";
const reverseFilter$1 = /* @__PURE__ */ __name(function arraysReverseFilter(context) {
  if (!context.nested) {
    const nonNestedDelta = context.delta;
    if (nonNestedDelta[2] === ARRAY_MOVE) {
      const arrayMoveDelta = nonNestedDelta;
      context.newName = `_${arrayMoveDelta[1]}`;
      context.setResult([
        arrayMoveDelta[0],
        parseInt(context.childName.substring(1), 10),
        ARRAY_MOVE
      ]).exit();
    }
    return;
  }
  const nestedDelta = context.delta;
  if (nestedDelta._t !== "a") {
    return;
  }
  const arrayDelta = nestedDelta;
  let name;
  let child;
  for (name in arrayDelta) {
    if (name === "_t") {
      continue;
    }
    child = new ReverseContext(arrayDelta[name]);
    context.push(child, name);
  }
  context.exit();
}, "arraysReverseFilter");
reverseFilter$1.filterName = "arrays";
const reverseArrayDeltaIndex = /* @__PURE__ */ __name((delta2, index2, itemDelta) => {
  if (typeof index2 === "string" && index2[0] === "_") {
    return parseInt(index2.substring(1), 10);
  } else if (Array.isArray(itemDelta) && itemDelta[2] === 0) {
    return `_${index2}`;
  }
  let reverseIndex = +index2;
  for (const deltaIndex in delta2) {
    const deltaItem = delta2[deltaIndex];
    if (Array.isArray(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        const moveFromIndex = parseInt(deltaIndex.substring(1), 10);
        const moveToIndex = deltaItem[1];
        if (moveToIndex === +index2) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        const deleteIndex = parseInt(deltaIndex.substring(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && parseInt(deltaIndex, 10) <= reverseIndex) {
        reverseIndex--;
      }
    }
  }
  return reverseIndex;
}, "reverseArrayDeltaIndex");
const collectChildrenReverseFilter = /* @__PURE__ */ __name((context) => {
  if (!context || !context.children) {
    return;
  }
  const deltaWithChildren = context.delta;
  if (deltaWithChildren._t !== "a") {
    return;
  }
  const arrayDelta = deltaWithChildren;
  const length = context.children.length;
  let child;
  const delta2 = {
    _t: "a"
  };
  for (let index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    let name = child.newName;
    if (typeof name === "undefined") {
      name = reverseArrayDeltaIndex(arrayDelta, child.childName, child.result);
    }
    if (delta2[name] !== child.result) {
      delta2[name] = child.result;
    }
  }
  context.setResult(delta2).exit();
}, "collectChildrenReverseFilter");
collectChildrenReverseFilter.filterName = "arraysCollectChildren";
const diffFilter$1 = /* @__PURE__ */ __name(function datesDiffFilter(context) {
  if (context.left instanceof Date) {
    if (context.right instanceof Date) {
      if (context.left.getTime() !== context.right.getTime()) {
        context.setResult([context.left, context.right]);
      } else {
        context.setResult(void 0);
      }
    } else {
      context.setResult([context.left, context.right]);
    }
    context.exit();
  } else if (context.right instanceof Date) {
    context.setResult([context.left, context.right]).exit();
  }
}, "datesDiffFilter");
diffFilter$1.filterName = "dates";
const TEXT_DIFF = 2;
const DEFAULT_MIN_LENGTH = 60;
let cachedDiffPatch = null;
function getDiffMatchPatch(options3, required) {
  var _a;
  if (!cachedDiffPatch) {
    let instance;
    if ((_a = options3 === null || options3 === void 0 ? void 0 : options3.textDiff) === null || _a === void 0 ? void 0 : _a.diffMatchPatch) {
      instance = new options3.textDiff.diffMatchPatch();
    } else {
      if (!required) {
        return null;
      }
      const error = new Error("The diff-match-patch library was not provided. Pass the library in through the options or use the `jsondiffpatch/with-text-diffs` entry-point.");
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: /* @__PURE__ */ __name(function(txt1, txt2) {
        return instance.patch_toText(instance.patch_make(txt1, txt2));
      }, "diff"),
      patch: /* @__PURE__ */ __name(function(txt1, patch2) {
        const results = instance.patch_apply(instance.patch_fromText(patch2), txt1);
        for (let i2 = 0; i2 < results[1].length; i2++) {
          if (!results[1][i2]) {
            const error = new Error("text patch failed");
            error.textPatchFailed = true;
          }
        }
        return results[0];
      }, "patch")
    };
  }
  return cachedDiffPatch;
}
__name(getDiffMatchPatch, "getDiffMatchPatch");
const diffFilter = /* @__PURE__ */ __name(function textsDiffFilter(context) {
  if (context.leftType !== "string") {
    return;
  }
  const left = context.left;
  const right = context.right;
  const minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;
  if (left.length < minLength || right.length < minLength) {
    context.setResult([left, right]).exit();
    return;
  }
  const diffMatchPatch = getDiffMatchPatch(context.options);
  if (!diffMatchPatch) {
    context.setResult([left, right]).exit();
    return;
  }
  const diff2 = diffMatchPatch.diff;
  context.setResult([diff2(left, right), 0, TEXT_DIFF]).exit();
}, "textsDiffFilter");
diffFilter.filterName = "texts";
const patchFilter = /* @__PURE__ */ __name(function textsPatchFilter(context) {
  if (context.nested) {
    return;
  }
  const nonNestedDelta = context.delta;
  if (nonNestedDelta[2] !== TEXT_DIFF) {
    return;
  }
  const textDiffDelta = nonNestedDelta;
  const patch2 = getDiffMatchPatch(context.options, true).patch;
  context.setResult(patch2(context.left, textDiffDelta[0])).exit();
}, "textsPatchFilter");
patchFilter.filterName = "texts";
const textDeltaReverse = /* @__PURE__ */ __name(function(delta2) {
  let i2;
  let l;
  let line;
  let lineTmp;
  let header2 = null;
  const headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
  let lineHeader;
  const lines = delta2.split("\n");
  for (i2 = 0, l = lines.length; i2 < l; i2++) {
    line = lines[i2];
    const lineStart = line.slice(0, 1);
    if (lineStart === "@") {
      header2 = headerRegex.exec(line);
      lineHeader = i2;
      lines[lineHeader] = "@@ -" + header2[3] + "," + header2[4] + " +" + header2[1] + "," + header2[2] + " @@";
    } else if (lineStart === "+") {
      lines[i2] = "-" + lines[i2].slice(1);
      if (lines[i2 - 1].slice(0, 1) === "+") {
        lineTmp = lines[i2];
        lines[i2] = lines[i2 - 1];
        lines[i2 - 1] = lineTmp;
      }
    } else if (lineStart === "-") {
      lines[i2] = "+" + lines[i2].slice(1);
    }
  }
  return lines.join("\n");
}, "textDeltaReverse");
const reverseFilter = /* @__PURE__ */ __name(function textsReverseFilter(context) {
  if (context.nested) {
    return;
  }
  const nonNestedDelta = context.delta;
  if (nonNestedDelta[2] !== TEXT_DIFF) {
    return;
  }
  const textDiffDelta = nonNestedDelta;
  context.setResult([textDeltaReverse(textDiffDelta[0]), 0, TEXT_DIFF]).exit();
}, "textsReverseFilter");
reverseFilter.filterName = "texts";
class DiffPatcher {
  static {
    __name(this, "DiffPatcher");
  }
  constructor(options3) {
    this.processor = new Processor(options3);
    this.processor.pipe(new Pipe("diff").append(collectChildrenDiffFilter, diffFilter$3, diffFilter$1, diffFilter, objectsDiffFilter, diffFilter$2).shouldHaveResult());
    this.processor.pipe(new Pipe("patch").append(collectChildrenPatchFilter$1, collectChildrenPatchFilter, patchFilter$3, patchFilter, patchFilter$2, patchFilter$1).shouldHaveResult());
    this.processor.pipe(new Pipe("reverse").append(collectChildrenReverseFilter$1, collectChildrenReverseFilter, reverseFilter$3, reverseFilter, reverseFilter$2, reverseFilter$1).shouldHaveResult());
  }
  options(options3) {
    return this.processor.options(options3);
  }
  diff(left, right) {
    return this.processor.process(new DiffContext(left, right));
  }
  patch(left, delta2) {
    return this.processor.process(new PatchContext(left, delta2));
  }
  reverse(delta2) {
    return this.processor.process(new ReverseContext(delta2));
  }
  unpatch(right, delta2) {
    return this.patch(right, this.reverse(delta2));
  }
  clone(value3) {
    return clone$2(value3);
  }
}
function dateReviver(key, value3) {
  let parts2;
  if (typeof value3 === "string") {
    parts2 = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(value3);
    if (parts2) {
      return new Date(Date.UTC(+parts2[1], +parts2[2] - 1, +parts2[3], +parts2[4], +parts2[5], +parts2[6], +(parts2[7] || 0)));
    }
  }
  return value3;
}
__name(dateReviver, "dateReviver");
function create(options3) {
  return new DiffPatcher(options3);
}
__name(create, "create");
let defaultInstance;
function diff(left, right) {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.diff(left, right);
}
__name(diff, "diff");
function patch(left, delta2) {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.patch(left, delta2);
}
__name(patch, "patch");
function unpatch(right, delta2) {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.unpatch(right, delta2);
}
__name(unpatch, "unpatch");
function reverse(delta2) {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.reverse(delta2);
}
__name(reverse, "reverse");
function clone$1(value3) {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.clone(value3);
}
__name(clone$1, "clone$1");
var loglevel$1 = { exports: {} };
var loglevel = loglevel$1.exports;
(function(module) {
  (function(root23, definition) {
    "use strict";
    if (false) {
      (void 0)(definition);
    } else if (module.exports) {
      module.exports = definition();
    } else {
      root23.log = definition();
    }
  })(commonjsGlobal, function() {
    "use strict";
    var noop2 = /* @__PURE__ */ __name(function() {
    }, "noop");
    var undefinedType2 = "undefined";
    var isIE = typeof window !== undefinedType2 && typeof window.navigator !== undefinedType2 && /Trident\/|MSIE /.test(window.navigator.userAgent);
    var logMethods = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ];
    var _loggersByName = {};
    var defaultLogger = null;
    function bindMethod(obj, methodName) {
      var method = obj[methodName];
      if (typeof method.bind === "function") {
        return method.bind(obj);
      } else {
        try {
          return Function.prototype.bind.call(method, obj);
        } catch (e) {
          return function() {
            return Function.prototype.apply.apply(method, [obj, arguments]);
          };
        }
      }
    }
    __name(bindMethod, "bindMethod");
    function traceForIE() {
      if (console.log) {
        if (console.log.apply) {
          console.log.apply(console, arguments);
        } else {
          Function.prototype.apply.apply(console.log, [console, arguments]);
        }
      }
      if (console.trace) console.trace();
    }
    __name(traceForIE, "traceForIE");
    function realMethod(methodName) {
      if (methodName === "debug") {
        methodName = "log";
      }
      if (typeof console === undefinedType2) {
        return false;
      } else if (methodName === "trace" && isIE) {
        return traceForIE;
      } else if (console[methodName] !== void 0) {
        return bindMethod(console, methodName);
      } else if (console.log !== void 0) {
        return bindMethod(console, "log");
      } else {
        return noop2;
      }
    }
    __name(realMethod, "realMethod");
    function replaceLoggingMethods() {
      var level = this.getLevel();
      for (var i2 = 0; i2 < logMethods.length; i2++) {
        var methodName = logMethods[i2];
        this[methodName] = i2 < level ? noop2 : this.methodFactory(methodName, level, this.name);
      }
      this.log = this.debug;
      if (typeof console === undefinedType2 && level < this.levels.SILENT) {
        return "No console available for logging";
      }
    }
    __name(replaceLoggingMethods, "replaceLoggingMethods");
    function enableLoggingWhenConsoleArrives(methodName) {
      return function() {
        if (typeof console !== undefinedType2) {
          replaceLoggingMethods.call(this);
          this[methodName].apply(this, arguments);
        }
      };
    }
    __name(enableLoggingWhenConsoleArrives, "enableLoggingWhenConsoleArrives");
    function defaultMethodFactory(methodName, _level, _loggerName) {
      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
    }
    __name(defaultMethodFactory, "defaultMethodFactory");
    function Logger(name, factory) {
      var self2 = this;
      var inheritedLevel;
      var defaultLevel;
      var userLevel;
      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = void 0;
      }
      function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || "silent").toUpperCase();
        if (typeof window === undefinedType2 || !storageKey) return;
        try {
          window.localStorage[storageKey] = levelName;
          return;
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
        } catch (ignore) {
        }
      }
      __name(persistLevelIfPossible, "persistLevelIfPossible");
      function getPersistedLevel() {
        var storedLevel;
        if (typeof window === undefinedType2 || !storageKey) return;
        try {
          storedLevel = window.localStorage[storageKey];
        } catch (ignore) {
        }
        if (typeof storedLevel === undefinedType2) {
          try {
            var cookie = window.document.cookie;
            var cookieName = encodeURIComponent(storageKey);
            var location2 = cookie.indexOf(cookieName + "=");
            if (location2 !== -1) {
              storedLevel = /^([^;]+)/.exec(
                cookie.slice(location2 + cookieName.length + 1)
              )[1];
            }
          } catch (ignore) {
          }
        }
        if (self2.levels[storedLevel] === void 0) {
          storedLevel = void 0;
        }
        return storedLevel;
      }
      __name(getPersistedLevel, "getPersistedLevel");
      function clearPersistedLevel() {
        if (typeof window === undefinedType2 || !storageKey) return;
        try {
          window.localStorage.removeItem(storageKey);
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
        } catch (ignore) {
        }
      }
      __name(clearPersistedLevel, "clearPersistedLevel");
      function normalizeLevel(input) {
        var level = input;
        if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
          level = self2.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
          return level;
        } else {
          throw new TypeError("log.setLevel() called with invalid level: " + input);
        }
      }
      __name(normalizeLevel, "normalizeLevel");
      self2.name = name;
      self2.levels = {
        "TRACE": 0,
        "DEBUG": 1,
        "INFO": 2,
        "WARN": 3,
        "ERROR": 4,
        "SILENT": 5
      };
      self2.methodFactory = factory || defaultMethodFactory;
      self2.getLevel = function() {
        if (userLevel != null) {
          return userLevel;
        } else if (defaultLevel != null) {
          return defaultLevel;
        } else {
          return inheritedLevel;
        }
      };
      self2.setLevel = function(level, persist) {
        userLevel = normalizeLevel(level);
        if (persist !== false) {
          persistLevelIfPossible(userLevel);
        }
        return replaceLoggingMethods.call(self2);
      };
      self2.setDefaultLevel = function(level) {
        defaultLevel = normalizeLevel(level);
        if (!getPersistedLevel()) {
          self2.setLevel(level, false);
        }
      };
      self2.resetLevel = function() {
        userLevel = null;
        clearPersistedLevel();
        replaceLoggingMethods.call(self2);
      };
      self2.enableAll = function(persist) {
        self2.setLevel(self2.levels.TRACE, persist);
      };
      self2.disableAll = function(persist) {
        self2.setLevel(self2.levels.SILENT, persist);
      };
      self2.rebuild = function() {
        if (defaultLogger !== self2) {
          inheritedLevel = normalizeLevel(defaultLogger.getLevel());
        }
        replaceLoggingMethods.call(self2);
        if (defaultLogger === self2) {
          for (var childName in _loggersByName) {
            _loggersByName[childName].rebuild();
          }
        }
      };
      inheritedLevel = normalizeLevel(
        defaultLogger ? defaultLogger.getLevel() : "WARN"
      );
      var initialLevel = getPersistedLevel();
      if (initialLevel != null) {
        userLevel = normalizeLevel(initialLevel);
      }
      replaceLoggingMethods.call(self2);
    }
    __name(Logger, "Logger");
    defaultLogger = new Logger();
    defaultLogger.getLogger = /* @__PURE__ */ __name(function getLogger(name) {
      if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
        throw new TypeError("You must supply a name when creating a logger.");
      }
      var logger2 = _loggersByName[name];
      if (!logger2) {
        logger2 = _loggersByName[name] = new Logger(
          name,
          defaultLogger.methodFactory
        );
      }
      return logger2;
    }, "getLogger");
    var _log = typeof window !== undefinedType2 ? window.log : void 0;
    defaultLogger.noConflict = function() {
      if (typeof window !== undefinedType2 && window.log === defaultLogger) {
        window.log = _log;
      }
      return defaultLogger;
    };
    defaultLogger.getLoggers = /* @__PURE__ */ __name(function getLoggers() {
      return _loggersByName;
    }, "getLoggers");
    defaultLogger["default"] = defaultLogger;
    return defaultLogger;
  });
})(loglevel$1);
var loglevelExports = loglevel$1.exports;
const log = /* @__PURE__ */ getDefaultExportFromCjs(loglevelExports);
function clone(obj) {
  try {
    if (typeof structuredClone !== "undefined") {
      return structuredClone(obj);
    }
  } catch (error) {
  }
  return JSON.parse(JSON.stringify(obj));
}
__name(clone, "clone");
const logger = log.getLogger("ChangeTracker");
logger.setLevel("info");
class ChangeTracker {
  static {
    __name(this, "ChangeTracker");
  }
  constructor(workflow, initialState) {
    this.workflow = workflow;
    this.initialState = initialState;
    this.activeState = initialState;
  }
  static MAX_HISTORY = 50;
  /**
   * The active state of the workflow.
   */
  activeState;
  undoQueue = [];
  redoQueue = [];
  changeCount = 0;
  /**
   * Whether the redo/undo restoring is in progress.
   */
  restoringState = false;
  ds;
  nodeOutputs;
  static app;
  get app() {
    return ChangeTracker.app;
  }
  /**
   * Save the current state as the initial state.
   */
  reset(state) {
    if (this.restoringState) return;
    logger.debug("Reset State");
    this.activeState = state ?? this.activeState;
    this.initialState = clone(this.activeState);
  }
  store() {
    this.ds = {
      scale: this.app.canvas.ds.scale,
      offset: [this.app.canvas.ds.offset[0], this.app.canvas.ds.offset[1]]
    };
  }
  restore() {
    if (this.ds) {
      this.app.canvas.ds.scale = this.ds.scale;
      this.app.canvas.ds.offset = this.ds.offset;
    }
    if (this.nodeOutputs) {
      this.app.nodeOutputs = this.nodeOutputs;
    }
  }
  updateModified() {
    const workflow = useWorkflowStore().getWorkflowByPath(this.workflow.path);
    if (workflow) {
      workflow.isModified = !ChangeTracker.graphEqual(
        this.initialState,
        this.activeState
      );
      if (workflow.isModified) {
        const diff2 = ChangeTracker.graphDiff(
          this.initialState,
          this.activeState
        );
        logger.debug("Graph diff:", diff2);
      }
    }
  }
  checkState() {
    if (!this.app.graph || this.changeCount) return;
    const currentState = this.app.graph.serialize();
    if (!this.activeState) {
      this.activeState = clone(currentState);
      return;
    }
    if (!ChangeTracker.graphEqual(this.activeState, currentState)) {
      this.undoQueue.push(this.activeState);
      if (this.undoQueue.length > ChangeTracker.MAX_HISTORY) {
        this.undoQueue.shift();
      }
      logger.debug("Diff detected. Undo queue length:", this.undoQueue.length);
      this.activeState = clone(currentState);
      this.redoQueue.length = 0;
      api.dispatchEvent(
        new CustomEvent("graphChanged", { detail: this.activeState })
      );
      this.updateModified();
    }
  }
  async updateState(source, target) {
    const prevState = source.pop();
    if (prevState) {
      target.push(this.activeState);
      this.restoringState = true;
      try {
        await this.app.loadGraphData(prevState, false, false, this.workflow, {
          showMissingModelsDialog: false,
          showMissingNodesDialog: false
        });
        this.activeState = prevState;
        this.updateModified();
      } finally {
        this.restoringState = false;
      }
    }
  }
  async undo() {
    await this.updateState(this.undoQueue, this.redoQueue);
    logger.debug(
      "Undo. Undo queue length:",
      this.undoQueue.length,
      "Redo queue length:",
      this.redoQueue.length
    );
  }
  async redo() {
    await this.updateState(this.redoQueue, this.undoQueue);
    logger.debug(
      "Redo. Undo queue length:",
      this.undoQueue.length,
      "Redo queue length:",
      this.redoQueue.length
    );
  }
  async undoRedo(e) {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "y" || e.key == "Z") {
        await this.redo();
        return true;
      } else if (e.key === "z") {
        await this.undo();
        return true;
      }
    }
  }
  beforeChange() {
    this.changeCount++;
  }
  afterChange() {
    if (!--this.changeCount) {
      this.checkState();
    }
  }
  static init(app2) {
    const getCurrentChangeTracker = /* @__PURE__ */ __name(() => useWorkflowStore().activeWorkflow?.changeTracker, "getCurrentChangeTracker");
    const checkState = /* @__PURE__ */ __name(() => getCurrentChangeTracker()?.checkState(), "checkState");
    ChangeTracker.app = app2;
    let keyIgnored = false;
    window.addEventListener(
      "keydown",
      (e) => {
        if (e.repeat) return;
        const activeEl = document.activeElement;
        requestAnimationFrame(async () => {
          let bindInputEl = null;
          if (!app2.ui.autoQueueEnabled || app2.ui.autoQueueMode === "instant") {
            if (activeEl?.tagName === "INPUT" || activeEl && "type" in activeEl && activeEl.type === "textarea") {
              return;
            }
            bindInputEl = activeEl;
          }
          keyIgnored = e.key === "Control" || e.key === "Shift" || e.key === "Alt" || e.key === "Meta";
          if (keyIgnored) return;
          const changeTracker = getCurrentChangeTracker();
          if (!changeTracker) return;
          if (await changeTracker.undoRedo(e)) return;
          if (ChangeTracker.bindInput(app2, bindInputEl)) return;
          logger.debug("checkState on keydown");
          changeTracker.checkState();
        });
      },
      true
    );
    window.addEventListener("keyup", (e) => {
      if (keyIgnored) {
        keyIgnored = false;
        logger.debug("checkState on keyup");
        checkState();
      }
    });
    window.addEventListener("mouseup", () => {
      logger.debug("checkState on mouseup");
      checkState();
    });
    api.addEventListener("promptQueued", () => {
      logger.debug("checkState on promptQueued");
      checkState();
    });
    api.addEventListener("graphCleared", () => {
      logger.debug("checkState on graphCleared");
      checkState();
    });
    const processMouseUp = LGraphCanvas.prototype.processMouseUp;
    LGraphCanvas.prototype.processMouseUp = function(e) {
      const v2 = processMouseUp.apply(this, [e]);
      logger.debug("checkState on processMouseUp");
      checkState();
      return v2;
    };
    const processMouseDown = LGraphCanvas.prototype.processMouseDown;
    LGraphCanvas.prototype.processMouseDown = function(e) {
      const v2 = processMouseDown.apply(this, [e]);
      logger.debug("checkState on processMouseDown");
      checkState();
      return v2;
    };
    const prompt = LGraphCanvas.prototype.prompt;
    LGraphCanvas.prototype.prompt = function(title, value3, callback, event2) {
      const extendedCallback = /* @__PURE__ */ __name((v2) => {
        callback(v2);
        checkState();
      }, "extendedCallback");
      logger.debug("checkState on prompt");
      return prompt.apply(this, [title, value3, extendedCallback, event2]);
    };
    const close4 = LiteGraph.ContextMenu.prototype.close;
    LiteGraph.ContextMenu.prototype.close = function(e) {
      const v2 = close4.apply(this, [e]);
      logger.debug("checkState on contextMenuClose");
      checkState();
      return v2;
    };
    const onNodeAdded = LiteGraph.LGraph.prototype.onNodeAdded;
    LiteGraph.LGraph.prototype.onNodeAdded = function(node3) {
      const v2 = onNodeAdded?.apply(this, [node3]);
      if (!app2?.configuringGraph) {
        logger.debug("checkState on onNodeAdded");
        checkState();
      }
      return v2;
    };
    document.addEventListener("litegraph:canvas", (e) => {
      const detail = e.detail;
      if (detail.subType === "before-change") {
        getCurrentChangeTracker()?.beforeChange();
      } else if (detail.subType === "after-change") {
        getCurrentChangeTracker()?.afterChange();
      }
    });
    api.addEventListener("executed", (e) => {
      const detail = e.detail;
      const workflow = useExecutionStore().queuedPrompts[detail.prompt_id]?.workflow;
      const changeTracker = workflow?.changeTracker;
      if (!changeTracker) return;
      changeTracker.nodeOutputs ??= {};
      const nodeOutputs = changeTracker.nodeOutputs;
      const output = nodeOutputs[detail.node];
      if (detail.merge && output) {
        for (const k in detail.output ?? {}) {
          const v2 = output[k];
          if (v2 instanceof Array) {
            output[k] = v2.concat(detail.output[k]);
          } else {
            output[k] = detail.output[k];
          }
        }
      } else {
        nodeOutputs[detail.node] = detail.output;
      }
    });
  }
  static bindInput(app2, activeEl) {
    if (!activeEl || activeEl.tagName === "CANVAS" || activeEl.tagName === "BODY") {
      return false;
    }
    for (const evt of ["change", "input", "blur"]) {
      const htmlElement = activeEl;
      if (`on${evt}` in htmlElement) {
        const listener = /* @__PURE__ */ __name(() => {
          useWorkflowStore().activeWorkflow?.changeTracker?.checkState?.();
          htmlElement.removeEventListener(evt, listener);
        }, "listener");
        htmlElement.addEventListener(evt, listener);
        return true;
      }
    }
    return false;
  }
  static graphEqual(a, b) {
    if (a === b) return true;
    if (typeof a == "object" && a && typeof b == "object" && b) {
      if (!_.isEqualWith(a.nodes, b.nodes, (arrA, arrB) => {
        if (Array.isArray(arrA) && Array.isArray(arrB)) {
          return _.isEqual(new Set(arrA), new Set(arrB));
        }
      })) {
        return false;
      }
      if (!_.isEqual(a.extra?.reroutes, b.extra?.reroutes)) return false;
      for (const key of ["links", "reroutes", "groups"]) {
        if (!_.isEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  static graphDiff(a, b) {
    function sortGraphNodes(graph) {
      return {
        links: graph.links,
        groups: graph.groups,
        nodes: graph.nodes.sort((a2, b2) => {
          if (typeof a2.id === "number" && typeof b2.id === "number") {
            return a2.id - b2.id;
          }
          return 0;
        })
      };
    }
    __name(sortGraphNodes, "sortGraphNodes");
    return diff(sortGraphNodes(a), sortGraphNodes(b));
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.changeTracker = window.comfyAPI.changeTracker || {};
window.comfyAPI.changeTracker.ChangeTracker = ChangeTracker;
class ComfyWorkflow extends UserFile {
  static {
    __name(this, "ComfyWorkflow");
  }
  static basePath = "workflows/";
  /**
   * The change tracker for the workflow. Non-reactive raw object.
   */
  changeTracker = null;
  /**
   * Whether the workflow has been modified comparing to the initial state.
   */
  _isModified = false;
  /**
   * @param options The path, modified, and size of the workflow.
   * Note: path is the full path, including the 'workflows/' prefix.
   */
  constructor(options3) {
    super(options3.path, options3.modified, options3.size);
  }
  get key() {
    return this.path.substring(ComfyWorkflow.basePath.length);
  }
  get activeState() {
    return this.changeTracker?.activeState ?? null;
  }
  get initialState() {
    return this.changeTracker?.initialState ?? null;
  }
  get isLoaded() {
    return this.changeTracker !== null;
  }
  get isModified() {
    return this._isModified;
  }
  set isModified(value3) {
    this._isModified = value3;
  }
  /**
   * Load the workflow content from remote storage. Directly returns the loaded
   * workflow if the content is already loaded.
   *
   * @param force Whether to force loading the content even if it is already loaded.
   * @returns this
   */
  async load({
    force = false
  } = {}) {
    await super.load({ force });
    if (!force && this.isLoaded) return this;
    if (!this.originalContent) {
      throw new Error("[ASSERT] Workflow content should be loaded");
    }
    console.debug("load and start tracking of workflow", this.path);
    this.changeTracker = markRaw(
      new ChangeTracker(
        this,
        /* initialState= */
        JSON.parse(this.originalContent)
      )
    );
    return this;
  }
  unload() {
    console.debug("unload workflow", this.path);
    this.changeTracker = null;
    super.unload();
  }
  async save() {
    this.content = JSON.stringify(this.activeState);
    const ret = await super.save({ force: true });
    this.changeTracker?.reset();
    this.isModified = false;
    return ret;
  }
  /**
   * Save the workflow as a new file.
   * @param path The path to save the workflow to. Note: with 'workflows/' prefix.
   * @returns this
   */
  async saveAs(path) {
    this.content = JSON.stringify(this.activeState);
    return await super.saveAs(path);
  }
}
const useWorkflowStore = /* @__PURE__ */ defineStore("workflow", () => {
  const detachWorkflow = /* @__PURE__ */ __name((workflow) => {
    delete workflowLookup.value[workflow.path];
    const index2 = openWorkflowPaths.value.indexOf(workflow.path);
    if (index2 !== -1) {
      openWorkflowPaths.value = openWorkflowPaths.value.filter(
        (path) => path !== workflow.path
      );
    }
    return index2;
  }, "detachWorkflow");
  const attachWorkflow = /* @__PURE__ */ __name((workflow, openIndex = -1) => {
    workflowLookup.value[workflow.path] = workflow;
    if (openIndex !== -1) {
      openWorkflowPaths.value.splice(openIndex, 0, workflow.path);
    }
  }, "attachWorkflow");
  const activeWorkflow = ref(null);
  const isActive = /* @__PURE__ */ __name((workflow) => activeWorkflow.value?.path === workflow.path, "isActive");
  const workflowLookup = ref({});
  const workflows = computed(
    () => Object.values(workflowLookup.value)
  );
  const getWorkflowByPath = /* @__PURE__ */ __name((path) => workflowLookup.value[path] ?? null, "getWorkflowByPath");
  const openWorkflowPaths = ref([]);
  const openWorkflowPathSet = computed(() => new Set(openWorkflowPaths.value));
  const openWorkflows = computed(
    () => openWorkflowPaths.value.map((path) => workflowLookup.value[path])
  );
  const isOpen = /* @__PURE__ */ __name((workflow) => openWorkflowPathSet.value.has(workflow.path), "isOpen");
  const openWorkflow = /* @__PURE__ */ __name(async (workflow) => {
    if (isActive(workflow)) return workflow;
    if (!openWorkflowPaths.value.includes(workflow.path)) {
      openWorkflowPaths.value.push(workflow.path);
    }
    const loadedWorkflow = await workflow.load();
    activeWorkflow.value = loadedWorkflow;
    console.debug("[workflowStore] open workflow", workflow.path);
    return loadedWorkflow;
  }, "openWorkflow");
  const getUnconflictedPath = /* @__PURE__ */ __name((basePath) => {
    const { directory, filename, suffix: suffix2 } = getPathDetails(basePath);
    let counter = 2;
    let newPath = basePath;
    while (workflowLookup.value[newPath]) {
      newPath = `${directory}/${filename} (${counter}).${suffix2}`;
      counter++;
    }
    return newPath;
  }, "getUnconflictedPath");
  const createTemporary = /* @__PURE__ */ __name((path, workflowData) => {
    const fullPath = getUnconflictedPath(
      ComfyWorkflow.basePath + (path ?? "Unsaved Workflow.json")
    );
    const workflow = new ComfyWorkflow({
      path: fullPath,
      modified: Date.now(),
      size: -1
    });
    workflow.originalContent = workflow.content = workflowData ? JSON.stringify(workflowData) : defaultGraphJSON;
    workflowLookup.value[workflow.path] = workflow;
    return workflow;
  }, "createTemporary");
  const closeWorkflow = /* @__PURE__ */ __name(async (workflow) => {
    openWorkflowPaths.value = openWorkflowPaths.value.filter(
      (path) => path !== workflow.path
    );
    if (workflow.isTemporary) {
      delete workflowLookup.value[workflow.path];
    } else {
      workflow.unload();
    }
    console.debug("[workflowStore] close workflow", workflow.path);
  }, "closeWorkflow");
  const openedWorkflowIndexShift = /* @__PURE__ */ __name((shift) => {
    const index2 = openWorkflowPaths.value.indexOf(
      activeWorkflow.value?.path ?? ""
    );
    if (index2 !== -1) {
      const length = openWorkflows.value.length;
      const nextIndex = (index2 + shift + length) % length;
      const nextWorkflow = openWorkflows.value[nextIndex];
      return nextWorkflow ?? null;
    }
    return null;
  }, "openedWorkflowIndexShift");
  const persistedWorkflows = computed(
    () => Array.from(workflows.value).filter((workflow) => workflow.isPersisted)
  );
  const syncWorkflows = /* @__PURE__ */ __name(async (dir = "") => {
    await syncEntities(
      dir ? "workflows/" + dir : "workflows",
      workflowLookup.value,
      (file) => new ComfyWorkflow({
        path: file.path,
        modified: file.modified,
        size: file.size
      }),
      (existingWorkflow, file) => {
        existingWorkflow.lastModified = file.modified;
        existingWorkflow.size = file.size;
        existingWorkflow.unload();
      },
      /* exclude */
      (workflow) => workflow.isTemporary
    );
  }, "syncWorkflows");
  const bookmarkStore = useWorkflowBookmarkStore();
  const bookmarkedWorkflows = computed(
    () => workflows.value.filter(
      (workflow) => bookmarkStore.isBookmarked(workflow.path)
    )
  );
  const modifiedWorkflows = computed(
    () => workflows.value.filter((workflow) => workflow.isModified)
  );
  const isBusy = ref(false);
  const renameWorkflow = /* @__PURE__ */ __name(async (workflow, newPath) => {
    isBusy.value = true;
    try {
      const oldPath = workflow.path;
      const wasBookmarked = bookmarkStore.isBookmarked(oldPath);
      const openIndex = detachWorkflow(workflow);
      try {
        await workflow.rename(newPath);
      } finally {
        attachWorkflow(workflow, openIndex);
      }
      if (wasBookmarked) {
        bookmarkStore.setBookmarked(oldPath, false);
        bookmarkStore.setBookmarked(newPath, true);
      }
    } finally {
      isBusy.value = false;
    }
  }, "renameWorkflow");
  const deleteWorkflow = /* @__PURE__ */ __name(async (workflow) => {
    isBusy.value = true;
    try {
      await workflow.delete();
      if (bookmarkStore.isBookmarked(workflow.path)) {
        bookmarkStore.setBookmarked(workflow.path, false);
      }
      delete workflowLookup.value[workflow.path];
    } finally {
      isBusy.value = false;
    }
  }, "deleteWorkflow");
  const saveWorkflow = /* @__PURE__ */ __name(async (workflow) => {
    isBusy.value = true;
    try {
      const openIndex = detachWorkflow(workflow);
      try {
        await workflow.save();
      } finally {
        attachWorkflow(workflow, openIndex);
      }
    } finally {
      isBusy.value = false;
    }
  }, "saveWorkflow");
  return {
    activeWorkflow,
    isActive,
    openWorkflows,
    openedWorkflowIndexShift,
    openWorkflow,
    isOpen,
    isBusy,
    closeWorkflow,
    createTemporary,
    renameWorkflow,
    deleteWorkflow,
    saveWorkflow,
    workflows,
    bookmarkedWorkflows,
    persistedWorkflows,
    modifiedWorkflows,
    getWorkflowByPath,
    syncWorkflows
  };
});
const useWorkflowBookmarkStore = /* @__PURE__ */ defineStore("workflowBookmark", () => {
  const bookmarks = ref(/* @__PURE__ */ new Set());
  const isBookmarked = /* @__PURE__ */ __name((path) => bookmarks.value.has(path), "isBookmarked");
  const loadBookmarks = /* @__PURE__ */ __name(async () => {
    const resp = await api.getUserData("workflows/.index.json");
    if (resp.status === 200) {
      const info = await resp.json();
      bookmarks.value = new Set(info?.favorites ?? []);
    }
  }, "loadBookmarks");
  const saveBookmarks = /* @__PURE__ */ __name(async () => {
    await api.storeUserData("workflows/.index.json", {
      favorites: Array.from(bookmarks.value)
    });
  }, "saveBookmarks");
  const setBookmarked = /* @__PURE__ */ __name((path, value3) => {
    if (bookmarks.value.has(path) === value3) return;
    if (value3) {
      bookmarks.value.add(path);
    } else {
      bookmarks.value.delete(path);
    }
    saveBookmarks();
  }, "setBookmarked");
  const toggleBookmarked = /* @__PURE__ */ __name((path) => {
    setBookmarked(path, !bookmarks.value.has(path));
  }, "toggleBookmarked");
  return {
    isBookmarked,
    loadBookmarks,
    saveBookmarks,
    setBookmarked,
    toggleBookmarked
  };
});
async function getFilename(defaultName) {
  if (useSettingStore().get("Comfy.PromptFilename")) {
    let filename = await showPromptDialog({
      title: "Export Workflow",
      message: "Enter the filename:",
      defaultValue: defaultName
    });
    if (!filename) return null;
    if (!filename.toLowerCase().endsWith(".json")) {
      filename += ".json";
    }
    return filename;
  }
  return defaultName;
}
__name(getFilename, "getFilename");
const workflowService = {
  /**
   * Export the current workflow as a JSON file
   * @param filename The filename to save the workflow as
   * @param promptProperty The property of the prompt to export
   */
  async exportWorkflow(filename, promptProperty) {
    const workflow = useWorkflowStore().activeWorkflow;
    if (workflow?.path) {
      filename = workflow.filename;
    }
    const p2 = await app$1.graphToPrompt();
    const json = JSON.stringify(p2[promptProperty], null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const file = await getFilename(filename);
    if (!file) return;
    downloadBlob(file, blob);
  },
  /**
   * Save a workflow as a new file
   * @param workflow The workflow to save
   */
  async saveWorkflowAs(workflow) {
    const newFilename = await showPromptDialog({
      title: "Save workflow",
      message: "Enter the filename:",
      defaultValue: workflow.filename
    });
    if (!newFilename) return;
    const newPath = workflow.directory + "/" + appendJsonExt(newFilename);
    const newKey = newPath.substring(ComfyWorkflow.basePath.length);
    if (workflow.isTemporary) {
      await this.renameWorkflow(workflow, newPath);
      await useWorkflowStore().saveWorkflow(workflow);
    } else {
      const tempWorkflow = useWorkflowStore().createTemporary(
        newKey,
        workflow.activeState
      );
      await this.openWorkflow(tempWorkflow);
      await useWorkflowStore().saveWorkflow(tempWorkflow);
    }
  },
  /**
   * Save a workflow
   * @param workflow The workflow to save
   */
  async saveWorkflow(workflow) {
    if (workflow.isTemporary) {
      await this.saveWorkflowAs(workflow);
    } else {
      await useWorkflowStore().saveWorkflow(workflow);
    }
  },
  /**
   * Load the default workflow
   */
  async loadDefaultWorkflow() {
    await app$1.loadGraphData(defaultGraph);
  },
  /**
   * Load a blank workflow
   */
  async loadBlankWorkflow() {
    await app$1.loadGraphData(blankGraph);
  },
  async openWorkflow(workflow) {
    if (useWorkflowStore().isActive(workflow)) return;
    const loadFromRemote = !workflow.isLoaded;
    if (loadFromRemote) {
      await workflow.load();
    }
    await app$1.loadGraphData(
      toRaw(workflow.activeState),
      /* clean=*/
      true,
      /* restore_view=*/
      true,
      workflow,
      {
        showMissingModelsDialog: loadFromRemote,
        showMissingNodesDialog: loadFromRemote
      }
    );
  },
  /**
   * Close a workflow with confirmation if there are unsaved changes
   * @param workflow The workflow to close
   * @returns true if the workflow was closed, false if the user cancelled
   */
  async closeWorkflow(workflow, options3 = { warnIfUnsaved: true }) {
    if (!workflow.isLoaded) {
      return;
    }
    if (workflow.isModified && options3.warnIfUnsaved) {
      const res = await ComfyAsyncDialog.prompt({
        title: "Save Changes?",
        message: `Do you want to save changes to "${workflow.path}" before closing?`,
        actions: ["Yes", "No", "Cancel"]
      });
      if (res === "Yes") {
        await this.saveWorkflow(workflow);
      } else if (res === "Cancel") {
        return;
      }
    }
    const workflowStore = useWorkflowStore();
    if (workflowStore.openWorkflows.length === 1) {
      await this.loadDefaultWorkflow();
    }
    if (workflowStore.isActive(workflow)) {
      await this.loadNextOpenedWorkflow();
    }
    await workflowStore.closeWorkflow(workflow);
  },
  async renameWorkflow(workflow, newPath) {
    await useWorkflowStore().renameWorkflow(workflow, newPath);
  },
  async deleteWorkflow(workflow) {
    const workflowStore = useWorkflowStore();
    if (workflowStore.isOpen(workflow)) {
      await this.closeWorkflow(workflow);
    }
    await workflowStore.deleteWorkflow(workflow);
  },
  /**
   * This method is called before loading a new graph.
   * There are 3 major functions that loads a new graph to the graph editor:
   * 1. loadGraphData
   * 2. loadApiJson
   * 3. importA1111
   *
   * This function is used to save the current workflow states before loading
   * a new graph.
   */
  beforeLoadNewGraph() {
    const workflowStore = useWorkspaceStore().workflow;
    const activeWorkflow = workflowStore.activeWorkflow;
    if (activeWorkflow) {
      activeWorkflow.changeTracker.store();
    }
  },
  /**
   * Set the active workflow after the new graph is loaded.
   *
   * The call relationship is
   * workflowService.openWorkflow -> app.loadGraphData -> workflowService.afterLoadNewGraph
   * app.loadApiJson -> workflowService.afterLoadNewGraph
   * app.importA1111 -> workflowService.afterLoadNewGraph
   *
   * @param value The value to set as the active workflow.
   * @param workflowData The initial workflow data loaded to the graph editor.
   */
  async afterLoadNewGraph(value3, workflowData) {
    const workflowStore = useWorkspaceStore().workflow;
    if (typeof value3 === "string") {
      const workflow = workflowStore.getWorkflowByPath(
        ComfyWorkflow.basePath + appendJsonExt(value3)
      );
      if (workflow?.isPersisted) {
        const loadedWorkflow2 = await workflowStore.openWorkflow(workflow);
        loadedWorkflow2.changeTracker.restore();
        loadedWorkflow2.changeTracker.reset(workflowData);
        return;
      }
    }
    if (value3 === null || typeof value3 === "string") {
      const path = value3;
      const tempWorkflow = workflowStore.createTemporary(
        path ? appendJsonExt(path) : void 0,
        workflowData
      );
      await workflowStore.openWorkflow(tempWorkflow);
      return;
    }
    const loadedWorkflow = await workflowStore.openWorkflow(value3);
    loadedWorkflow.changeTracker.reset(workflowData);
    loadedWorkflow.changeTracker.restore();
  },
  /**
   * Insert the given workflow into the current graph editor.
   */
  async insertWorkflow(workflow) {
    const loadedWorkflow = await workflow.load();
    const data22 = loadedWorkflow.initialState;
    const old = localStorage.getItem("litegrapheditor_clipboard");
    const graph = new LGraph(data22);
    const canvasElement = document.createElement("canvas");
    const canvas = new LGraphCanvas(canvasElement, graph, {
      skip_events: true,
      skip_render: true
    });
    canvas.selectNodes();
    canvas.copyToClipboard();
    app$1.canvas.pasteFromClipboard();
    if (old !== null) {
      localStorage.setItem("litegrapheditor_clipboard", old);
    }
  },
  async loadNextOpenedWorkflow() {
    const nextWorkflow = useWorkflowStore().openedWorkflowIndexShift(1);
    if (nextWorkflow) {
      await this.openWorkflow(nextWorkflow);
    }
  },
  async loadPreviousOpenedWorkflow() {
    const previousWorkflow = useWorkflowStore().openedWorkflowIndexShift(-1);
    if (previousWorkflow) {
      await this.openWorkflow(previousWorkflow);
    }
  }
};
function serialise(nodes, graph) {
  const serialisable = {
    nodes: [],
    links: []
  };
  let index2 = 0;
  const cloneable = [];
  for (const node3 of nodes) {
    if (node3.clonable === false) continue;
    node3._relative_id = index2++;
    cloneable.push(node3);
  }
  for (const node3 of cloneable) {
    const cloned = node3.clone();
    if (!cloned) {
      console.warn("node type not found: " + node3.type);
      continue;
    }
    serialisable.nodes.push(cloned.serialize());
    if (!node3.inputs?.length) continue;
    for (const input of node3.inputs) {
      if (!input || input.link == null) continue;
      const link = graph.links.get(input.link);
      if (!link) continue;
      const outNode = graph.getNodeById(link.origin_id);
      if (!outNode) continue;
      serialisable.links.push([
        outNode._relative_id,
        link.origin_slot,
        node3._relative_id,
        link.target_slot,
        outNode.id
      ]);
    }
  }
  return JSON.stringify(serialisable);
}
__name(serialise, "serialise");
function deserialiseAndCreate(data22, canvas) {
  if (!data22) return;
  const { graph, graph_mouse } = canvas;
  canvas.emitBeforeChange();
  graph.beforeChange();
  const deserialised = JSON.parse(data22);
  const topLeft = [Infinity, Infinity];
  for (const { pos: pos2 } of deserialised.nodes) {
    if (topLeft[0] > pos2[0]) topLeft[0] = pos2[0];
    if (topLeft[1] > pos2[1]) topLeft[1] = pos2[1];
  }
  if (!Number.isFinite(topLeft[0]) || !Number.isFinite(topLeft[1])) {
    topLeft[0] = graph_mouse[0];
    topLeft[1] = graph_mouse[1];
  }
  const nodes = [];
  for (const info of deserialised.nodes) {
    const node3 = LiteGraph.createNode(info.type);
    if (!node3) continue;
    node3.configure(info);
    node3.pos[0] += graph_mouse[0] - topLeft[0];
    node3.pos[1] += graph_mouse[1] - topLeft[1];
    graph.add(node3, true);
    nodes.push(node3);
  }
  for (const info of deserialised.links) {
    const relativeId = info[0];
    const outNode = relativeId != null ? nodes[relativeId] : void 0;
    const inNode = nodes[info[2]];
    if (outNode && inNode) outNode.connect(info[1], inNode, info[3]);
    else console.warn("Warning, nodes missing on pasting");
  }
  canvas.selectNodes(nodes);
  graph.afterChange();
  canvas.emitAfterChange();
}
__name(deserialiseAndCreate, "deserialiseAndCreate");
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.vintageClipboard = window.comfyAPI.vintageClipboard || {};
window.comfyAPI.vintageClipboard.serialise = serialise;
window.comfyAPI.vintageClipboard.deserialiseAndCreate = deserialiseAndCreate;
const ANIM_PREVIEW_WIDGET = "$$comfy_animation_preview";
function sanitizeNodeName(string) {
  let entityMap = {
    "&": "",
    "<": "",
    ">": "",
    '"': "",
    "'": "",
    "`": "",
    "=": ""
  };
  return String(string).replace(/[&<>"'`=]/g, /* @__PURE__ */ __name(function fromEntityMap(s) {
    return entityMap[s];
  }, "fromEntityMap"));
}
__name(sanitizeNodeName, "sanitizeNodeName");
class ComfyApp {
  static {
    __name(this, "ComfyApp");
  }
  /**
   * List of entries to queue
   * @type {{number: number, batchCount: number}[]}
   */
  #queueItems = [];
  /**
   * If the queue is currently being processed
   * @type {boolean}
   */
  #processingQueue = false;
  /**
   * Content Clipboard
   * @type {serialized node object}
   */
  static clipspace = null;
  static clipspace_invalidate_handler = null;
  static open_maskeditor = null;
  static clipspace_return_node = null;
  // Force vite to import utils.ts as part of index.
  // Force import of DraggableList.
  static utils = {
    applyTextReplacements,
    addStylesheet,
    DraggableList
  };
  vueAppReady;
  ui;
  logging;
  extensions;
  extensionManager;
  _nodeOutputs;
  nodePreviewImages;
  graph;
  enableWorkflowViewRestore;
  canvas;
  dragOverNode;
  canvasEl;
  // x, y, scale
  zoom_drag_start;
  lastNodeErrors;
  lastExecutionError;
  progress;
  configuringGraph;
  isNewUserSession;
  storageLocation;
  multiUserServer;
  ctx;
  bodyTop;
  bodyLeft;
  bodyRight;
  bodyBottom;
  canvasContainer;
  menu;
  bypassBgColor;
  // Set by Comfy.Clipspace extension
  openClipspace = /* @__PURE__ */ __name(() => {
  }, "openClipspace");
  /**
   * @deprecated Use useExecutionStore().executingNodeId instead
   */
  get runningNodeId() {
    return useExecutionStore().executingNodeId;
  }
  /**
   * @deprecated Use useWorkspaceStore().shiftDown instead
   */
  get shiftDown() {
    return useWorkspaceStore().shiftDown;
  }
  /**
   * @deprecated Use useWidgetStore().widgets instead
   */
  get widgets() {
    if (this.vueAppReady) {
      return useWidgetStore().widgets;
    }
    return ComfyWidgets;
  }
  constructor() {
    this.vueAppReady = false;
    this.ui = new ComfyUI(this);
    this.logging = new ComfyLogging(this);
    this.bodyTop = $el("div.comfyui-body-top", { parent: document.body });
    this.bodyLeft = $el("div.comfyui-body-left", { parent: document.body });
    this.bodyRight = $el("div.comfyui-body-right", { parent: document.body });
    this.bodyBottom = $el("div.comfyui-body-bottom", { parent: document.body });
    this.canvasContainer = $el("div.graph-canvas-container", {
      parent: document.body
    });
    this.menu = new ComfyAppMenu(this);
    this.bypassBgColor = "#FF00FF";
    this.extensions = [];
    this.nodeOutputs = {};
    this.nodePreviewImages = {};
  }
  get nodeOutputs() {
    return this._nodeOutputs;
  }
  set nodeOutputs(value3) {
    this._nodeOutputs = value3;
    this.#invokeExtensions("onNodeOutputsUpdated", value3);
  }
  getPreviewFormatParam() {
    let preview_format = this.ui.settings.getSettingValue("Comfy.PreviewFormat");
    if (preview_format) return `&preview=${preview_format}`;
    else return "";
  }
  getRandParam() {
    return "&rand=" + Math.random();
  }
  static isImageNode(node3) {
    return node3.imgs || node3 && node3.widgets && node3.widgets.findIndex((obj) => obj.name === "image") >= 0;
  }
  static onClipspaceEditorSave() {
    if (ComfyApp.clipspace_return_node) {
      ComfyApp.pasteFromClipspace(ComfyApp.clipspace_return_node);
    }
  }
  static onClipspaceEditorClosed() {
    ComfyApp.clipspace_return_node = null;
  }
  static copyToClipspace(node3) {
    var widgets = null;
    if (node3.widgets) {
      widgets = node3.widgets.map(({ type, name, value: value3 }) => ({
        type,
        name,
        value: value3
      }));
    }
    var imgs = void 0;
    var orig_imgs = void 0;
    if (node3.imgs != void 0) {
      imgs = [];
      orig_imgs = [];
      for (let i2 = 0; i2 < node3.imgs.length; i2++) {
        imgs[i2] = new Image();
        imgs[i2].src = node3.imgs[i2].src;
        orig_imgs[i2] = imgs[i2];
      }
    }
    var selectedIndex = 0;
    if (node3.imageIndex) {
      selectedIndex = node3.imageIndex;
    }
    ComfyApp.clipspace = {
      widgets,
      imgs,
      original_imgs: orig_imgs,
      images: node3.images,
      selectedIndex,
      img_paste_mode: "selected"
      // reset to default im_paste_mode state on copy action
    };
    ComfyApp.clipspace_return_node = null;
    if (ComfyApp.clipspace_invalidate_handler) {
      ComfyApp.clipspace_invalidate_handler();
    }
  }
  static pasteFromClipspace(node3) {
    if (ComfyApp.clipspace) {
      if (ComfyApp.clipspace.imgs && node3.imgs) {
        if (node3.images && ComfyApp.clipspace.images) {
          if (ComfyApp.clipspace["img_paste_mode"] == "selected") {
            node3.images = [
              ComfyApp.clipspace.images[ComfyApp.clipspace["selectedIndex"]]
            ];
          } else {
            node3.images = ComfyApp.clipspace.images;
          }
          if (app$1.nodeOutputs[node3.id + ""])
            app$1.nodeOutputs[node3.id + ""].images = node3.images;
        }
        if (ComfyApp.clipspace.imgs) {
          if (ComfyApp.clipspace["img_paste_mode"] == "selected") {
            const img = new Image();
            img.src = ComfyApp.clipspace.imgs[ComfyApp.clipspace["selectedIndex"]].src;
            node3.imgs = [img];
            node3.imageIndex = 0;
          } else {
            const imgs = [];
            for (let i2 = 0; i2 < ComfyApp.clipspace.imgs.length; i2++) {
              imgs[i2] = new Image();
              imgs[i2].src = ComfyApp.clipspace.imgs[i2].src;
              node3.imgs = imgs;
            }
          }
        }
      }
      if (node3.widgets) {
        if (ComfyApp.clipspace.images) {
          const clip_image = ComfyApp.clipspace.images[ComfyApp.clipspace["selectedIndex"]];
          const index2 = node3.widgets.findIndex((obj) => obj.name === "image");
          if (index2 >= 0) {
            if (node3.widgets[index2].type != "image" && typeof node3.widgets[index2].value == "string" && clip_image.filename) {
              node3.widgets[index2].value = (clip_image.subfolder ? clip_image.subfolder + "/" : "") + clip_image.filename + (clip_image.type ? ` [${clip_image.type}]` : "");
            } else {
              node3.widgets[index2].value = clip_image;
            }
          }
        }
        if (ComfyApp.clipspace.widgets) {
          ComfyApp.clipspace.widgets.forEach(({ type, name, value: value3 }) => {
            const prop2 = Object.values(node3.widgets).find(
              // @ts-expect-errorg
              (obj) => obj.type === type && obj.name === name
            );
            if (prop2 && prop2.type != "button") {
              if (
                // @ts-expect-error
                prop2.type != "image" && // @ts-expect-error
                typeof prop2.value == "string" && value3.filename
              ) {
                prop2.value = (value3.subfolder ? value3.subfolder + "/" : "") + value3.filename + (value3.type ? ` [${value3.type}]` : "");
              } else {
                prop2.value = value3;
                prop2.callback(value3);
              }
            }
          });
        }
      }
      app$1.graph.setDirtyCanvas(true);
    }
  }
  get enabledExtensions() {
    if (!this.vueAppReady) {
      return this.extensions;
    }
    return useExtensionStore().enabledExtensions;
  }
  /**
   * Invoke an extension callback
   * @param {keyof ComfyExtension} method The extension callback to execute
   * @param  {any[]} args Any arguments to pass to the callback
   * @returns
   */
  #invokeExtensions(method, ...args) {
    let results = [];
    for (const ext of this.enabledExtensions) {
      if (method in ext) {
        try {
          results.push(ext[method](...args, this));
        } catch (error) {
          console.error(
            `Error calling extension '${ext.name}' method '${method}'`,
            { error },
            { extension: ext },
            { args }
          );
        }
      }
    }
    return results;
  }
  /**
   * Invoke an async extension callback
   * Each callback will be invoked concurrently
   * @param {string} method The extension callback to execute
   * @param  {...any} args Any arguments to pass to the callback
   * @returns
   */
  async #invokeExtensionsAsync(method, ...args) {
    return await Promise.all(
      this.enabledExtensions.map(async (ext) => {
        if (method in ext) {
          try {
            return await ext[method](...args, this);
          } catch (error) {
            console.error(
              `Error calling extension '${ext.name}' method '${method}'`,
              { error },
              { extension: ext },
              { args }
            );
          }
        }
      })
    );
  }
  #addRestoreWorkflowView() {
    const serialize = LGraph$1.prototype.serialize;
    const self2 = this;
    LGraph$1.prototype.serialize = function() {
      const workflow = serialize.apply(this, arguments);
      if (self2.enableWorkflowViewRestore.value) {
        if (!workflow.extra) {
          workflow.extra = {};
        }
        workflow.extra.ds = {
          scale: self2.canvas.ds.scale,
          offset: self2.canvas.ds.offset
        };
      } else if (workflow.extra?.ds) {
        delete workflow.extra.ds;
      }
      return workflow;
    };
    this.enableWorkflowViewRestore = this.ui.settings.addSetting({
      id: "Comfy.EnableWorkflowViewRestore",
      category: ["Comfy", "Workflow", "EnableWorkflowViewRestore"],
      name: "Save and restore canvas position and zoom level in workflows",
      type: "boolean",
      defaultValue: true
    });
  }
  /**
   * Adds special context menu handling for nodes
   * e.g. this adds Open Image functionality for nodes that show images
   * @param {*} node The node to add the menu handler
   */
  #addNodeContextMenuHandler(node3) {
    function getCopyImageOption(img) {
      if (typeof window.ClipboardItem === "undefined") return [];
      return [
        {
          content: "Copy Image",
          callback: /* @__PURE__ */ __name(async () => {
            const url = new URL(img.src);
            url.searchParams.delete("preview");
            const writeImage = /* @__PURE__ */ __name(async (blob) => {
              await navigator.clipboard.write([
                new ClipboardItem({
                  [blob.type]: blob
                })
              ]);
            }, "writeImage");
            try {
              const data22 = await fetch(url);
              const blob = await data22.blob();
              try {
                await writeImage(blob);
              } catch (error) {
                if (blob.type !== "image/png") {
                  const canvas = $el("canvas", {
                    width: img.naturalWidth,
                    height: img.naturalHeight
                  });
                  const ctx = canvas.getContext("2d");
                  let image;
                  if (typeof window.createImageBitmap === "undefined") {
                    image = new Image();
                    const p2 = new Promise((resolve2, reject2) => {
                      image.onload = resolve2;
                      image.onerror = reject2;
                    }).finally(() => {
                      URL.revokeObjectURL(image.src);
                    });
                    image.src = URL.createObjectURL(blob);
                    await p2;
                  } else {
                    image = await createImageBitmap(blob);
                  }
                  try {
                    ctx.drawImage(image, 0, 0);
                    canvas.toBlob(writeImage, "image/png");
                  } finally {
                    if (typeof image.close === "function") {
                      image.close();
                    }
                  }
                  return;
                }
                throw error;
              }
            } catch (error) {
              useToastStore().addAlert(
                "Error copying image: " + (error.message ?? error)
              );
            }
          }, "callback")
        }
      ];
    }
    __name(getCopyImageOption, "getCopyImageOption");
    node3.prototype.getExtraMenuOptions = function(_2, options3) {
      if (this.imgs) {
        let img;
        if (this.imageIndex != null) {
          img = this.imgs[this.imageIndex];
        } else if (this.overIndex != null) {
          img = this.imgs[this.overIndex];
        }
        if (img) {
          options3.unshift(
            {
              content: "Open Image",
              callback: /* @__PURE__ */ __name(() => {
                let url = new URL(img.src);
                url.searchParams.delete("preview");
                window.open(url, "_blank");
              }, "callback")
            },
            ...getCopyImageOption(img),
            {
              content: "Save Image",
              callback: /* @__PURE__ */ __name(() => {
                const a = document.createElement("a");
                let url = new URL(img.src);
                url.searchParams.delete("preview");
                a.href = url.toString();
                a.setAttribute(
                  "download",
                  new URLSearchParams(url.search).get("filename")
                );
                document.body.append(a);
                a.click();
                requestAnimationFrame(() => a.remove());
              }, "callback")
            }
          );
        }
      }
      options3.push({
        content: "Bypass",
        callback: /* @__PURE__ */ __name((obj) => {
          if (this.mode === 4) this.mode = 0;
          else this.mode = 4;
          this.graph.change();
        }, "callback")
      });
      if (!ComfyApp.clipspace_return_node) {
        options3.push({
          content: "Copy (Clipspace)",
          callback: /* @__PURE__ */ __name((obj) => {
            ComfyApp.copyToClipspace(this);
          }, "callback")
        });
        if (ComfyApp.clipspace != null) {
          options3.push({
            content: "Paste (Clipspace)",
            callback: /* @__PURE__ */ __name(() => {
              ComfyApp.pasteFromClipspace(this);
            }, "callback")
          });
        }
        if (ComfyApp.isImageNode(this)) {
          options3.push({
            content: "Open in MaskEditor",
            callback: /* @__PURE__ */ __name((obj) => {
              ComfyApp.copyToClipspace(this);
              ComfyApp.clipspace_return_node = this;
              ComfyApp.open_maskeditor();
            }, "callback")
          });
        }
      }
    };
  }
  #addNodeKeyHandler(node3) {
    const app2 = this;
    const origNodeOnKeyDown = node3.prototype.onKeyDown;
    node3.prototype.onKeyDown = function(e) {
      if (origNodeOnKeyDown && origNodeOnKeyDown.apply(this, e) === false) {
        return false;
      }
      if (this.flags.collapsed || !this.imgs || this.imageIndex === null) {
        return;
      }
      let handled = false;
      if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
        if (e.key === "ArrowLeft") {
          this.imageIndex -= 1;
        } else if (e.key === "ArrowRight") {
          this.imageIndex += 1;
        }
        this.imageIndex %= this.imgs.length;
        if (this.imageIndex < 0) {
          this.imageIndex = this.imgs.length + this.imageIndex;
        }
        handled = true;
      } else if (e.key === "Escape") {
        this.imageIndex = null;
        handled = true;
      }
      if (handled === true) {
        e.preventDefault();
        e.stopImmediatePropagation();
        return false;
      }
    };
  }
  /**
   * Adds Custom drawing logic for nodes
   * e.g. Draws images and handles thumbnail navigation on nodes that output images
   * @param {*} node The node to add the draw handler
   */
  #addDrawBackgroundHandler(node3) {
    const app2 = this;
    function getImageTop(node22) {
      let shiftY;
      if (node22.imageOffset != null) {
        shiftY = node22.imageOffset;
      } else {
        if (node22.widgets?.length) {
          const w2 = node22.widgets[node22.widgets.length - 1];
          shiftY = w2.last_y;
          if (w2.computeSize) {
            shiftY += w2.computeSize()[1] + 4;
          } else if (w2.computedHeight) {
            shiftY += w2.computedHeight;
          } else {
            shiftY += LiteGraph.NODE_WIDGET_HEIGHT + 4;
          }
        } else {
          shiftY = node22.computeSize()[1];
        }
      }
      return shiftY;
    }
    __name(getImageTop, "getImageTop");
    node3.prototype.setSizeForImage = function(force) {
      if (!force && this.animatedImages) return;
      if (this.inputHeight || this.freeWidgetSpace > 210) {
        this.setSize(this.size);
        return;
      }
      const minHeight = getImageTop(this) + 220;
      if (this.size[1] < minHeight) {
        this.setSize([this.size[0], minHeight]);
      }
    };
    function unsafeDrawBackground(ctx) {
      if (!this.flags.collapsed) {
        let imgURLs = [];
        let imagesChanged = false;
        const output = app2.nodeOutputs[this.id + ""];
        if (output?.images) {
          this.animatedImages = output?.animated?.find(Boolean);
          if (this.images !== output.images) {
            this.images = output.images;
            imagesChanged = true;
            imgURLs = imgURLs.concat(
              output.images.map((params) => {
                return api.apiURL(
                  "/view?" + new URLSearchParams(params).toString() + (this.animatedImages ? "" : app2.getPreviewFormatParam()) + app2.getRandParam()
                );
              })
            );
          }
        }
        const preview2 = app2.nodePreviewImages[this.id + ""];
        if (this.preview !== preview2) {
          this.preview = preview2;
          imagesChanged = true;
          if (preview2 != null) {
            imgURLs.push(preview2);
          }
        }
        if (imagesChanged) {
          this.imageIndex = null;
          if (imgURLs.length > 0) {
            Promise.all(
              imgURLs.map((src) => {
                return new Promise((r) => {
                  const img = new Image();
                  img.onload = () => r(img);
                  img.onerror = () => r(null);
                  img.src = src;
                });
              })
            ).then((imgs) => {
              if ((!output || this.images === output.images) && (!preview2 || this.preview === preview2)) {
                this.imgs = imgs.filter(Boolean);
                this.setSizeForImage?.();
                app2.graph.setDirtyCanvas(true);
              }
            });
          } else {
            this.imgs = null;
          }
        }
        const is_all_same_aspect_ratio = /* @__PURE__ */ __name((imgs) => {
          let ratio2 = imgs[0].naturalWidth / imgs[0].naturalHeight;
          for (let i2 = 1; i2 < imgs.length; i2++) {
            let this_ratio = imgs[i2].naturalWidth / imgs[i2].naturalHeight;
            if (ratio2 != this_ratio) return false;
          }
          return true;
        }, "is_all_same_aspect_ratio");
        if (this.imgs?.length) {
          const widgetIdx = this.widgets?.findIndex(
            (w2) => w2.name === ANIM_PREVIEW_WIDGET
          );
          if (this.animatedImages) {
            if (widgetIdx > -1) {
              const widget = this.widgets[widgetIdx];
              widget.options.host.updateImages(this.imgs);
            } else {
              const host = createImageHost(this);
              this.setSizeForImage(true);
              const widget = this.addDOMWidget(
                ANIM_PREVIEW_WIDGET,
                "img",
                host.el,
                {
                  host,
                  getHeight: host.getHeight,
                  onDraw: host.onDraw,
                  hideOnZoom: false
                }
              );
              widget.serializeValue = () => void 0;
              widget.options.host.updateImages(this.imgs);
            }
            return;
          }
          if (widgetIdx > -1) {
            this.widgets[widgetIdx].onRemove?.();
            this.widgets.splice(widgetIdx, 1);
          }
          const canvas = app2.graph.list_of_graphcanvas[0];
          const mouse = canvas.graph_mouse;
          if (!canvas.pointer_is_down && this.pointerDown) {
            if (mouse[0] === this.pointerDown.pos[0] && mouse[1] === this.pointerDown.pos[1]) {
              this.imageIndex = this.pointerDown.index;
            }
            this.pointerDown = null;
          }
          let imageIndex = this.imageIndex;
          const numImages = this.imgs.length;
          if (numImages === 1 && !imageIndex) {
            this.imageIndex = imageIndex = 0;
          }
          const top = getImageTop(this);
          var shiftY = top;
          let dw = this.size[0];
          let dh = this.size[1];
          dh -= shiftY;
          if (imageIndex == null) {
            var cellWidth, cellHeight, shiftX, cell_padding, cols;
            const compact_mode = is_all_same_aspect_ratio(this.imgs);
            if (!compact_mode) {
              cell_padding = 2;
              const largestDimension = this.imgs.reduce(
                (acc, current) => Math.max(acc, current.naturalWidth, current.naturalHeight),
                0
              );
              const fakeImgs = [];
              fakeImgs.length = this.imgs.length;
              fakeImgs[0] = {
                naturalWidth: largestDimension,
                naturalHeight: largestDimension
              };
              ({ cellWidth, cellHeight, cols, shiftX } = calculateImageGrid(
                fakeImgs,
                dw,
                dh
              ));
            } else {
              cell_padding = 0;
              ({ cellWidth, cellHeight, cols, shiftX } = calculateImageGrid(
                this.imgs,
                dw,
                dh
              ));
            }
            let anyHovered = false;
            this.imageRects = [];
            for (let i2 = 0; i2 < numImages; i2++) {
              const img = this.imgs[i2];
              const row = Math.floor(i2 / cols);
              const col = i2 % cols;
              const x2 = col * cellWidth + shiftX;
              const y2 = row * cellHeight + shiftY;
              if (!anyHovered) {
                anyHovered = LiteGraph.isInsideRectangle(
                  mouse[0],
                  mouse[1],
                  x2 + this.pos[0],
                  y2 + this.pos[1],
                  cellWidth,
                  cellHeight
                );
                if (anyHovered) {
                  this.overIndex = i2;
                  let value3 = 110;
                  if (canvas.pointer_is_down) {
                    if (!this.pointerDown || this.pointerDown.index !== i2) {
                      this.pointerDown = { index: i2, pos: [...mouse] };
                    }
                    value3 = 125;
                  }
                  ctx.filter = `contrast(${value3}%) brightness(${value3}%)`;
                  canvas.canvas.style.cursor = "pointer";
                }
              }
              this.imageRects.push([x2, y2, cellWidth, cellHeight]);
              let wratio = cellWidth / img.width;
              let hratio = cellHeight / img.height;
              var ratio = Math.min(wratio, hratio);
              let imgHeight = ratio * img.height;
              let imgY = row * cellHeight + shiftY + (cellHeight - imgHeight) / 2;
              let imgWidth = ratio * img.width;
              let imgX = col * cellWidth + shiftX + (cellWidth - imgWidth) / 2;
              ctx.drawImage(
                img,
                imgX + cell_padding,
                imgY + cell_padding,
                imgWidth - cell_padding * 2,
                imgHeight - cell_padding * 2
              );
              if (!compact_mode) {
                ctx.strokeStyle = "#8F8F8F";
                ctx.lineWidth = 1;
                ctx.strokeRect(
                  x2 + cell_padding,
                  y2 + cell_padding,
                  cellWidth - cell_padding * 2,
                  cellHeight - cell_padding * 2
                );
              }
              ctx.filter = "none";
            }
            if (!anyHovered) {
              this.pointerDown = null;
              this.overIndex = null;
            }
          } else {
            let w2 = this.imgs[imageIndex].naturalWidth;
            let h2 = this.imgs[imageIndex].naturalHeight;
            const scaleX = dw / w2;
            const scaleY = dh / h2;
            const scale = Math.min(scaleX, scaleY, 1);
            w2 *= scale;
            h2 *= scale;
            let x2 = (dw - w2) / 2;
            let y2 = (dh - h2) / 2 + shiftY;
            ctx.drawImage(this.imgs[imageIndex], x2, y2, w2, h2);
            const drawButton = /* @__PURE__ */ __name((x22, y22, sz, text) => {
              const hovered = LiteGraph.isInsideRectangle(
                mouse[0],
                mouse[1],
                x22 + this.pos[0],
                y22 + this.pos[1],
                sz,
                sz
              );
              let fill = "#333";
              let textFill = "#fff";
              let isClicking = false;
              if (hovered) {
                canvas.canvas.style.cursor = "pointer";
                if (canvas.pointer_is_down) {
                  fill = "#1e90ff";
                  isClicking = true;
                } else {
                  fill = "#eee";
                  textFill = "#000";
                }
              } else {
                this.pointerWasDown = null;
              }
              ctx.fillStyle = fill;
              ctx.beginPath();
              ctx.roundRect(x22, y22, sz, sz, [4]);
              ctx.fill();
              ctx.fillStyle = textFill;
              ctx.font = "12px Arial";
              ctx.textAlign = "center";
              ctx.fillText(text, x22 + 15, y22 + 20);
              return isClicking;
            }, "drawButton");
            if (numImages > 1) {
              if (drawButton(
                dw - 40,
                dh + top - 40,
                30,
                `${this.imageIndex + 1}/${numImages}`
              )) {
                let i2 = this.imageIndex + 1 >= numImages ? 0 : this.imageIndex + 1;
                if (!this.pointerDown || !this.pointerDown.index === i2) {
                  this.pointerDown = { index: i2, pos: [...mouse] };
                }
              }
              if (drawButton(dw - 40, top + 10, 30, `x`)) {
                if (!this.pointerDown || !this.pointerDown.index === null) {
                  this.pointerDown = { index: null, pos: [...mouse] };
                }
              }
            }
          }
        }
      }
    }
    __name(unsafeDrawBackground, "unsafeDrawBackground");
    node3.prototype.onDrawBackground = function(ctx) {
      try {
        unsafeDrawBackground.call(this, ctx);
      } catch (error) {
        console.error("Error drawing node background", error);
      }
    };
  }
  /**
   * Adds a handler allowing drag+drop of files onto the window to load workflows
   */
  #addDropHandler() {
    document.addEventListener("drop", async (event2) => {
      event2.preventDefault();
      event2.stopPropagation();
      const n = this.dragOverNode;
      this.dragOverNode = null;
      if (n && n.onDragDrop && await n.onDragDrop(event2)) {
        return;
      }
      if (event2.dataTransfer.files.length && event2.dataTransfer.files[0].type !== "image/bmp") {
        await this.handleFile(event2.dataTransfer.files[0]);
      } else {
        const validTypes = ["text/uri-list", "text/x-moz-url"];
        const match = [...event2.dataTransfer.types].find(
          (t) => validTypes.find((v2) => t === v2)
        );
        if (match) {
          const uri = event2.dataTransfer.getData(match)?.split("\n")?.[0];
          if (uri) {
            await this.handleFile(await (await fetch(uri)).blob());
          }
        }
      }
    });
    this.canvasEl.addEventListener("dragleave", async () => {
      if (this.dragOverNode) {
        this.dragOverNode = null;
        this.graph.setDirtyCanvas(false, true);
      }
    });
    this.canvasEl.addEventListener(
      "dragover",
      (e) => {
        this.canvas.adjustMouseEvent(e);
        const node3 = this.graph.getNodeOnPos(e.canvasX, e.canvasY);
        if (node3) {
          if (node3.onDragOver && node3.onDragOver(e)) {
            this.dragOverNode = node3;
            requestAnimationFrame(() => {
              this.graph.setDirtyCanvas(false, true);
            });
            return;
          }
        }
        this.dragOverNode = null;
      },
      false
    );
  }
  /**
   * Adds a handler on paste that extracts and loads images or workflows from pasted JSON data
   */
  #addPasteHandler() {
    document.addEventListener("paste", async (e) => {
      if (this.shiftDown) return;
      let data22 = e.clipboardData || window.clipboardData;
      const items2 = data22.items;
      for (const item2 of items2) {
        if (item2.type.startsWith("image/")) {
          var imageNode = null;
          if (this.canvas.current_node && this.canvas.current_node.is_selected && ComfyApp.isImageNode(this.canvas.current_node)) {
            imageNode = this.canvas.current_node;
          }
          if (!imageNode) {
            const newNode = LiteGraph.createNode("LoadImage");
            newNode.pos = [...this.canvas.graph_mouse];
            imageNode = this.graph.add(newNode);
            this.graph.change();
          }
          const blob = item2.getAsFile();
          imageNode.pasteFile(blob);
          return;
        }
      }
      data22 = data22.getData("text/plain");
      let workflow = null;
      try {
        data22 = data22.slice(data22.indexOf("{"));
        workflow = JSON.parse(data22);
      } catch (err) {
        try {
          data22 = data22.slice(data22.indexOf("workflow\n"));
          data22 = data22.slice(data22.indexOf("{"));
          workflow = JSON.parse(data22);
        } catch (error) {
          workflow = null;
        }
      }
      if (workflow && workflow.version && workflow.nodes && workflow.extra) {
        await this.loadGraphData(workflow);
      } else {
        if (e.target instanceof HTMLTextAreaElement && e.target.type === "textarea" || e.target instanceof HTMLInputElement && e.target.type === "text") {
          return;
        }
        this.canvas.pasteFromClipboard();
      }
    });
  }
  /**
   * Adds a handler on copy that serializes selected nodes to JSON
   */
  #addCopyHandler() {
    document.addEventListener("copy", (e) => {
      if (!(e.target instanceof Element)) {
        return;
      }
      if (e.target instanceof HTMLTextAreaElement && e.target.type === "textarea" || e.target instanceof HTMLInputElement && e.target.type === "text") {
        return;
      }
      const isTargetInGraph = e.target.classList.contains("litegraph") || e.target.classList.contains("graph-canvas-container");
      if (isTargetInGraph && this.canvas.selected_nodes) {
        this.canvas.copyToClipboard();
        e.clipboardData.setData("text", " ");
        e.preventDefault();
        e.stopImmediatePropagation();
        return false;
      }
    });
  }
  /**
   * Handle mouse
   *
   * Move group by header
   */
  #addProcessMouseHandler() {
    const self2 = this;
    const origProcessMouseDown = LGraphCanvas.prototype.processMouseDown;
    LGraphCanvas.prototype.processMouseDown = function(e) {
      if (e.ctrlKey && e.shiftKey && e.buttons) {
        self2.zoom_drag_start = [e.x, e.y, this.ds.scale];
        return;
      }
      const res = origProcessMouseDown.apply(this, arguments);
      return res;
    };
    const origProcessMouseMove = LGraphCanvas.prototype.processMouseMove;
    LGraphCanvas.prototype.processMouseMove = function(e) {
      if (e.ctrlKey && e.shiftKey && self2.zoom_drag_start) {
        if (!e.buttons) {
          self2.zoom_drag_start = null;
          return;
        }
        let deltaY = e.y - self2.zoom_drag_start[1];
        let startScale = self2.zoom_drag_start[2];
        let scale = startScale - deltaY / 100;
        this.ds.changeScale(scale, [
          self2.zoom_drag_start[0],
          self2.zoom_drag_start[1]
        ]);
        this.graph.change();
        return;
      }
      return origProcessMouseMove.apply(this, arguments);
    };
  }
  /**
   * Handle keypress
   */
  #addProcessKeyHandler() {
    const origProcessKey = LGraphCanvas.prototype.processKey;
    LGraphCanvas.prototype.processKey = function(e) {
      if (!this.graph) {
        return;
      }
      var block_default = false;
      if (e.target instanceof Element && e.target.localName == "input") {
        return;
      }
      if (e.type == "keydown" && !e.repeat) {
        const keyCombo = KeyComboImpl.fromEvent(e);
        const keybindingStore = useKeybindingStore();
        const keybinding = keybindingStore.getKeybinding(keyCombo);
        if (keybinding && keybinding.targetSelector === "#graph-canvas") {
          useCommandStore().execute(keybinding.commandId);
          block_default = true;
        }
        if (e.key === "c" && (e.metaKey || e.ctrlKey)) {
          return true;
        }
        if ((e.key === "v" || e.key == "V") && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
          return true;
        }
      }
      this.graph.change();
      if (block_default) {
        e.preventDefault();
        e.stopImmediatePropagation();
        return false;
      }
      return origProcessKey.apply(this, arguments);
    };
  }
  /**
   * Draws group header bar
   */
  #addDrawGroupsHandler() {
    const self2 = this;
    const origDrawGroups = LGraphCanvas.prototype.drawGroups;
    LGraphCanvas.prototype.drawGroups = function(canvas, ctx) {
      if (!this.graph) {
        return;
      }
      var groups = this.graph.groups;
      ctx.save();
      ctx.globalAlpha = 0.7 * this.editor_alpha;
      for (var i2 = 0; i2 < groups.length; ++i2) {
        var group = groups[i2];
        if (!LiteGraph.overlapBounding(this.visible_area, group._bounding)) {
          continue;
        }
        ctx.fillStyle = group.color || "#335";
        ctx.strokeStyle = group.color || "#335";
        var pos2 = group._pos;
        var size2 = group._size;
        ctx.globalAlpha = 0.25 * this.editor_alpha;
        ctx.beginPath();
        var font_size = group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
        ctx.rect(pos2[0] + 0.5, pos2[1] + 0.5, size2[0], font_size * 1.4);
        ctx.fill();
        ctx.globalAlpha = this.editor_alpha;
      }
      ctx.restore();
      const res = origDrawGroups.apply(this, arguments);
      return res;
    };
  }
  /**
   * Draws node highlights (executing, drag drop) and progress bar
   */
  #addDrawNodeHandler() {
    const origDrawNodeShape = LGraphCanvas.prototype.drawNodeShape;
    const self2 = this;
    LGraphCanvas.prototype.drawNodeShape = function(node3, ctx, size2, fgcolor, bgcolor, selected2) {
      const res = origDrawNodeShape.apply(this, arguments);
      const nodeErrors = self2.lastNodeErrors?.[node3.id];
      let color = null;
      let lineWidth = 1;
      if (node3.id === +self2.runningNodeId) {
        color = "#0f0";
      } else if (self2.dragOverNode && node3.id === self2.dragOverNode.id) {
        color = "dodgerblue";
      } else if (nodeErrors?.errors) {
        color = "red";
        lineWidth = 2;
      } else if (self2.lastExecutionError && +self2.lastExecutionError.node_id === node3.id) {
        color = "#f0f";
        lineWidth = 2;
      }
      if (color) {
        const shape = node3._shape || node3.constructor.shape || LiteGraph.ROUND_SHAPE;
        ctx.lineWidth = lineWidth;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        if (shape == LiteGraph.BOX_SHAPE)
          ctx.rect(
            -6,
            -6 - LiteGraph.NODE_TITLE_HEIGHT,
            12 + size2[0] + 1,
            12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT
          );
        else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE && node3.flags.collapsed)
          ctx.roundRect(
            -6,
            -6 - LiteGraph.NODE_TITLE_HEIGHT,
            12 + size2[0] + 1,
            12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT,
            this.round_radius * 2
          );
        else if (shape == LiteGraph.CARD_SHAPE)
          ctx.roundRect(
            -6,
            -6 - LiteGraph.NODE_TITLE_HEIGHT,
            12 + size2[0] + 1,
            12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT,
            [this.round_radius * 2, this.round_radius * 2, 2, 2]
          );
        else if (shape == LiteGraph.CIRCLE_SHAPE)
          ctx.arc(
            size2[0] * 0.5,
            size2[1] * 0.5,
            size2[0] * 0.5 + 6,
            0,
            Math.PI * 2
          );
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.strokeStyle = fgcolor;
        ctx.globalAlpha = 1;
      }
      if (self2.progress && node3.id === +self2.runningNodeId) {
        ctx.fillStyle = "green";
        ctx.fillRect(
          0,
          0,
          size2[0] * (self2.progress.value / self2.progress.max),
          6
        );
        ctx.fillStyle = bgcolor;
      }
      if (nodeErrors) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "red";
        for (const error of nodeErrors.errors) {
          if (error.extra_info && error.extra_info.input_name) {
            const inputIndex = node3.findInputSlot(error.extra_info.input_name);
            if (inputIndex !== -1) {
              let pos2 = node3.getConnectionPos(true, inputIndex);
              ctx.beginPath();
              ctx.arc(
                pos2[0] - node3.pos[0],
                pos2[1] - node3.pos[1],
                12,
                0,
                2 * Math.PI,
                false
              );
              ctx.stroke();
            }
          }
        }
      }
      return res;
    };
    const origDrawNode = LGraphCanvas.prototype.drawNode;
    LGraphCanvas.prototype.drawNode = function(node3, ctx) {
      const editor_alpha = this.editor_alpha;
      const old_color = node3.color;
      const old_bgcolor = node3.bgcolor;
      if (node3.mode === 2) {
        this.editor_alpha = 0.4;
      }
      let bgColor;
      if (node3.mode === 4) {
        bgColor = app$1.bypassBgColor;
        this.editor_alpha = 0.2;
      } else {
        bgColor = old_bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;
      }
      const adjustments = {};
      const opacity = useSettingStore().get("Comfy.Node.Opacity");
      if (opacity) adjustments.opacity = opacity;
      if (useSettingStore().get("Comfy.ColorPalette") === "light") {
        adjustments.lightness = 0.5;
        if (old_color) {
          node3.color = adjustColor(old_color, { lightness: 0.5 });
        }
      }
      node3.bgcolor = adjustColor(bgColor, adjustments);
      const res = origDrawNode.apply(this, arguments);
      this.editor_alpha = editor_alpha;
      node3.color = old_color;
      node3.bgcolor = old_bgcolor;
      return res;
    };
  }
  /**
   * Handles updates from the API socket
   */
  #addApiUpdateHandlers() {
    api.addEventListener(
      "status",
      ({ detail }) => {
        this.ui.setStatus(detail);
      }
    );
    api.addEventListener("progress", ({ detail }) => {
      this.progress = detail;
      this.graph.setDirtyCanvas(true, false);
    });
    api.addEventListener("executing", ({ detail }) => {
      this.progress = null;
      this.graph.setDirtyCanvas(true, false);
      delete this.nodePreviewImages[this.runningNodeId];
    });
    api.addEventListener("executed", ({ detail }) => {
      const output = this.nodeOutputs[detail.display_node || detail.node];
      if (detail.merge && output) {
        for (const k in detail.output ?? {}) {
          const v2 = output[k];
          if (v2 instanceof Array) {
            output[k] = v2.concat(detail.output[k]);
          } else {
            output[k] = detail.output[k];
          }
        }
      } else {
        this.nodeOutputs[detail.display_node || detail.node] = detail.output;
      }
      const node3 = this.graph.getNodeById(detail.display_node || detail.node);
      if (node3) {
        if (node3.onExecuted) node3.onExecuted(detail.output);
      }
    });
    api.addEventListener("execution_start", ({ detail }) => {
      this.lastExecutionError = null;
      this.graph.nodes.forEach((node3) => {
        if (node3.onExecutionStart)
          node3.onExecutionStart();
      });
    });
    api.addEventListener("execution_error", ({ detail }) => {
      this.lastExecutionError = detail;
      showExecutionErrorDialog(detail);
      this.canvas.draw(true, true);
    });
    api.addEventListener("b_preview", ({ detail }) => {
      const id3 = this.runningNodeId;
      if (id3 == null) return;
      const blob = detail;
      const blobUrl = URL.createObjectURL(blob);
      this.nodePreviewImages[id3] = [blobUrl];
    });
    api.init();
  }
  #addConfigureHandler() {
    const app2 = this;
    const configure = LGraph$1.prototype.configure;
    LGraph$1.prototype.configure = function() {
      app2.configuringGraph = true;
      try {
        return configure.apply(this, arguments);
      } finally {
        app2.configuringGraph = false;
      }
    };
  }
  #addWidgetLinkHandling() {
    app$1.canvas.getWidgetLinkType = function(widget, node3) {
      const nodeDefStore = useNodeDefStore();
      const nodeDef = nodeDefStore.nodeDefsByName[node3.type];
      const input = nodeDef.input.getInput(widget.name);
      return input?.type;
    };
    document.addEventListener(
      "litegraph:canvas",
      async (e) => {
        if (e.detail.subType === "connectingWidgetLink") {
          const { convertToInput } = await __vitePreload(async () => {
            const { convertToInput: convertToInput2 } = await import("./widgetInputs-BJ21PG7d.js");
            return { convertToInput: convertToInput2 };
          }, true ? [] : void 0, import.meta.url);
          const { node: node3, link, widget } = e.detail;
          if (!node3 || !link || !widget) return;
          const nodeData = node3.constructor.nodeData;
          if (!nodeData) return;
          const all3 = {
            ...nodeData?.input?.required,
            ...nodeData?.input?.optional
          };
          const inputSpec2 = all3[widget.name];
          if (!inputSpec2) return;
          const input = convertToInput(node3, widget, inputSpec2);
          if (!input) return;
          const originNode = link.node;
          originNode.connect(link.slot, node3, node3.inputs.lastIndexOf(input));
        }
      }
    );
  }
  #addAfterConfigureHandler() {
    const app2 = this;
    const onConfigure = app2.graph.onConfigure;
    app2.graph.onConfigure = function() {
      for (const node3 of app2.graph.nodes) {
        node3.onGraphConfigured?.();
      }
      const r = onConfigure?.apply(this, arguments);
      for (const node3 of app2.graph.nodes) {
        node3.onAfterGraphConfigured?.();
      }
      return r;
    };
  }
  /**
   * Loads all extensions from the API into the window in parallel
   */
  async #loadExtensions() {
    useExtensionStore().loadDisabledExtensionNames();
    const extensions = await api.getExtensions();
    this.logging.addEntry("Comfy.App", "debug", { Extensions: extensions });
    await __vitePreload(() => import("./index-B1vRdV2i.js"), true ? __vite__mapDeps([5,6,7]) : void 0, import.meta.url);
    await Promise.all(
      extensions.filter((extension) => !extension.includes("extensions/core")).map(async (ext) => {
        try {
          await import(
            /* @vite-ignore */
            api.fileURL(ext)
          );
        } catch (error) {
          console.error("Error loading extension", ext, error);
        }
      })
    );
  }
  async #migrateSettings() {
    this.isNewUserSession = true;
    const settings = Object.keys(this.ui.settings).reduce((p2, n) => {
      const v2 = localStorage[`Comfy.Settings.${n}`];
      if (v2) {
        try {
          p2[n] = JSON.parse(v2);
        } catch (error) {
        }
      }
      return p2;
    }, {});
    await api.storeSettings(settings);
  }
  async #setUser() {
    const userConfig = await api.getUserConfig();
    this.storageLocation = userConfig.storage;
    if (typeof userConfig.migrated == "boolean") {
      if (!userConfig.migrated && this.storageLocation === "server") {
        await this.#migrateSettings();
      }
      return;
    }
    this.multiUserServer = true;
    let user = localStorage["Comfy.userId"];
    const users = userConfig.users ?? {};
    if (!user || !users[user]) {
      if (this.vueAppReady) useWorkspaceStore().spinner = false;
      const { UserSelectionScreen } = await __vitePreload(async () => {
        const { UserSelectionScreen: UserSelectionScreen2 } = await import("./userSelection-BSkuSZyR.js");
        return { UserSelectionScreen: UserSelectionScreen2 };
      }, true ? __vite__mapDeps([8,9]) : void 0, import.meta.url);
      this.ui.menuContainer.style.display = "none";
      const { userId, username, created: created3 } = await new UserSelectionScreen().show(users, user);
      this.ui.menuContainer.style.display = "";
      user = userId;
      localStorage["Comfy.userName"] = username;
      localStorage["Comfy.userId"] = user;
      if (created3) {
        api.user = user;
        await this.#migrateSettings();
      }
    }
    api.user = user;
    this.ui.settings.addSetting({
      id: "Comfy.SwitchUser",
      name: "Switch User",
      type: /* @__PURE__ */ __name((name) => {
        let currentUser = localStorage["Comfy.userName"];
        if (currentUser) {
          currentUser = ` (${currentUser})`;
        }
        return $el("tr", [
          $el("td", [
            $el("label", {
              textContent: name
            })
          ]),
          $el("td", [
            $el("button", {
              textContent: name + (currentUser ?? ""),
              onclick: /* @__PURE__ */ __name(() => {
                delete localStorage["Comfy.userId"];
                delete localStorage["Comfy.userName"];
                window.location.reload();
              }, "onclick")
            })
          ])
        ]);
      }, "type"),
      // TODO: Is that the correct default value?
      defaultValue: void 0
    });
  }
  /**
   * Set up the app on the page
   */
  async setup(canvasEl) {
    this.canvasEl = canvasEl;
    this.ui.menuContainer.style.display = "block";
    await this.#setUser();
    this.resizeCanvas();
    await Promise.all([
      useWorkspaceStore().workflow.syncWorkflows(),
      this.ui.settings.load()
    ]);
    await this.#loadExtensions();
    this.#addProcessMouseHandler();
    this.#addProcessKeyHandler();
    this.#addConfigureHandler();
    this.#addApiUpdateHandlers();
    this.#addRestoreWorkflowView();
    this.graph = new LGraph$1();
    this.#addAfterConfigureHandler();
    this.canvas = new LGraphCanvas(canvasEl, this.graph);
    this.canvas.state = shallowReactive(this.canvas.state);
    this.ctx = canvasEl.getContext("2d");
    LiteGraph.alt_drag_do_clone_nodes = true;
    this.graph.start();
    this.resizeCanvas();
    window.addEventListener("resize", () => this.resizeCanvas());
    const ro = new ResizeObserver(() => this.resizeCanvas());
    ro.observe(this.bodyTop);
    ro.observe(this.bodyLeft);
    ro.observe(this.bodyRight);
    ro.observe(this.bodyBottom);
    await this.#invokeExtensionsAsync("init");
    await this.registerNodes();
    initWidgets(this);
    let restored = false;
    try {
      const loadWorkflow = /* @__PURE__ */ __name(async (json) => {
        if (json) {
          const workflow = JSON.parse(json);
          const workflowName = getStorageValue("Comfy.PreviousWorkflow");
          await this.loadGraphData(workflow, true, true, workflowName);
          return true;
        }
      }, "loadWorkflow");
      const clientId = api.initialClientId ?? api.clientId;
      restored = clientId && await loadWorkflow(
        sessionStorage.getItem(`workflow:${clientId}`)
      ) || await loadWorkflow(localStorage.getItem("workflow"));
    } catch (err) {
      console.error("Error loading previous workflow", err);
    }
    if (!restored) {
      await this.loadGraphData();
    }
    setInterval(() => {
      const workflow = JSON.stringify(this.serializeGraph());
      localStorage.setItem("workflow", workflow);
      if (api.clientId) {
        sessionStorage.setItem(`workflow:${api.clientId}`, workflow);
      }
    }, 1e3);
    this.#addDrawNodeHandler();
    this.#addDrawGroupsHandler();
    this.#addDropHandler();
    this.#addCopyHandler();
    this.#addPasteHandler();
    this.#addWidgetLinkHandling();
    await this.#invokeExtensionsAsync("setup");
  }
  resizeCanvas() {
    const scale = Math.max(window.devicePixelRatio, 1);
    this.canvasEl.height = this.canvasEl.width = NaN;
    const { width: width2, height } = this.canvasEl.getBoundingClientRect();
    this.canvasEl.width = Math.round(width2 * scale);
    this.canvasEl.height = Math.round(height * scale);
    this.canvasEl.getContext("2d").scale(scale, scale);
    this.canvas?.draw(true, true);
  }
  updateVueAppNodeDefs(defs) {
    const rawDefs = Object.fromEntries(
      Object.entries(LiteGraph.registered_node_types).map(([name, node3]) => [
        name,
        {
          name,
          display_name: name,
          category: node3.category || "__frontend_only__",
          input: { required: {}, optional: {} },
          output: [],
          output_name: [],
          output_is_list: [],
          python_module: "custom_nodes.frontend_only",
          description: `Frontend only node for ${name}`
        }
      ])
    );
    const allNodeDefs = {
      ...rawDefs,
      ...defs,
      ...SYSTEM_NODE_DEFS
    };
    const nodeDefStore = useNodeDefStore();
    const nodeDefArray = Object.values(allNodeDefs);
    this.#invokeExtensions("beforeRegisterVueAppNodeDefs", nodeDefArray, this);
    nodeDefStore.updateNodeDefs(nodeDefArray);
  }
  /**
   * Registers nodes with the graph
   */
  async registerNodes() {
    const defs = await api.getNodeDefs({
      validate: useSettingStore().get("Comfy.Validation.NodeDefs")
    });
    await this.registerNodesFromDefs(defs);
    await this.#invokeExtensionsAsync("registerCustomNodes");
    if (this.vueAppReady) {
      this.updateVueAppNodeDefs(defs);
    }
  }
  /**
   * Remove the impl after groupNode jest tests are removed.
   * @deprecated Use useWidgetStore().getWidgetType instead
   */
  getWidgetType(inputData, inputName) {
    const type = inputData[0];
    if (Array.isArray(type)) {
      return "COMBO";
    } else if (`${type}:${inputName}` in this.widgets) {
      return `${type}:${inputName}`;
    } else if (type in this.widgets) {
      return type;
    } else {
      return null;
    }
  }
  async registerNodeDef(nodeId, nodeData) {
    const self2 = this;
    const node3 = class ComfyNode extends LGraphNode {
      static {
        __name(this, "ComfyNode");
      }
      static comfyClass = nodeData.name;
      // TODO: change to "title?" once litegraph.d.ts has been updated
      static title = nodeData.display_name || nodeData.name;
      static nodeData = nodeData;
      static category;
      constructor(title) {
        super(title);
        const requiredInputs = nodeData.input.required;
        var inputs = nodeData["input"]["required"];
        if (nodeData["input"]["optional"] != void 0) {
          inputs = Object.assign(
            {},
            nodeData["input"]["required"],
            nodeData["input"]["optional"]
          );
        }
        const config2 = { minWidth: 1, minHeight: 1 };
        for (const inputName in inputs) {
          const _inputData = inputs[inputName];
          const type = _inputData[0];
          const options3 = _inputData[1] ?? {};
          const inputData = [type, options3];
          const inputIsRequired = requiredInputs && inputName in requiredInputs;
          let widgetCreated = true;
          const widgetType = self2.getWidgetType(inputData, inputName);
          if (widgetType) {
            if (widgetType === "COMBO") {
              Object.assign(
                config2,
                self2.widgets.COMBO(this, inputName, inputData, app$1) || {}
              );
            } else {
              Object.assign(
                config2,
                self2.widgets[widgetType](this, inputName, inputData, app$1) || {}
              );
            }
          } else {
            const inputOptions = inputIsRequired ? {} : { shape: LiteGraph.SlotShape.HollowCircle };
            this.addInput(inputName, type, inputOptions);
            widgetCreated = false;
          }
          if (widgetCreated && config2?.widget) {
            config2.widget.options ??= {};
            if (!inputIsRequired) {
              config2.widget.options.inputIsOptional = true;
            }
            if (inputData[1]?.forceInput) {
              config2.widget.options.forceInput = true;
            }
            if (inputData[1]?.defaultInput) {
              config2.widget.options.defaultInput = true;
            }
            if (inputData[1]?.advanced) {
              config2.widget.advanced = true;
            }
            if (inputData[1]?.hidden) {
              config2.widget.hidden = true;
            }
          }
        }
        for (const o in nodeData["output"]) {
          let output = nodeData["output"][o];
          if (output instanceof Array) output = "COMBO";
          const outputName = nodeData["output_name"][o] || output;
          const outputIsList = nodeData["output_is_list"][o];
          const outputOptions = outputIsList ? { shape: LiteGraph.GRID_SHAPE } : {};
          this.addOutput(outputName, output, outputOptions);
        }
        const s = this.computeSize();
        s[0] = Math.max(config2.minWidth, s[0] * 1.5);
        s[1] = Math.max(config2.minHeight, s[1]);
        this.size = s;
        this.serialize_widgets = true;
        app$1.#invokeExtensionsAsync("nodeCreated", this);
      }
      configure(data22) {
        const merge2 = /* @__PURE__ */ __name((current, incoming) => {
          const result = { ...incoming };
          if (current.widget === void 0 && incoming.widget !== void 0) {
            this.inputs.push(current);
            return incoming;
          }
          for (const key of ["name", "type", "shape"]) {
            if (current[key] !== void 0) {
              result[key] = current[key];
            }
          }
          return result;
        }, "merge");
        for (const field of ["inputs", "outputs"]) {
          const slots = data22[field] ?? [];
          data22[field] = slots.map(
            (slot, i2) => merge2(this[field][i2] ?? {}, slot)
          );
        }
        super.configure(data22);
      }
    };
    node3.prototype.comfyClass = nodeData.name;
    this.#addNodeContextMenuHandler(node3);
    this.#addDrawBackgroundHandler(node3);
    this.#addNodeKeyHandler(node3);
    await this.#invokeExtensionsAsync("beforeRegisterNodeDef", node3, nodeData);
    LiteGraph.registerNodeType(nodeId, node3);
    node3.category = nodeData.category;
  }
  async registerNodesFromDefs(defs) {
    await this.#invokeExtensionsAsync("addCustomNodeDefs", defs);
    for (const nodeId in defs) {
      this.registerNodeDef(nodeId, defs[nodeId]);
    }
  }
  loadTemplateData(templateData) {
    if (!templateData?.templates) {
      return;
    }
    const old = localStorage.getItem("litegrapheditor_clipboard");
    var maxY, nodeBottom, node3;
    for (const template of templateData.templates) {
      if (!template?.data) {
        continue;
      }
      const data22 = JSON.parse(template.data);
      if (!data22.reroutes) {
        deserialiseAndCreate(template.data, app$1.canvas);
      } else {
        localStorage.setItem("litegrapheditor_clipboard", template.data);
        app$1.canvas.pasteFromClipboard();
      }
      maxY = false;
      for (const i2 in app$1.canvas.selected_nodes) {
        node3 = app$1.canvas.selected_nodes[i2];
        nodeBottom = node3.pos[1] + node3.size[1];
        if (maxY === false || nodeBottom > maxY) {
          maxY = nodeBottom;
        }
      }
      app$1.canvas.graph_mouse[1] = maxY + 50;
    }
    localStorage.setItem("litegrapheditor_clipboard", old);
  }
  #showMissingNodesError(missingNodeTypes) {
    if (useSettingStore().get("Comfy.Workflow.ShowMissingNodesWarning")) {
      showLoadWorkflowWarning({ missingNodeTypes });
    }
    this.logging.addEntry("Comfy.App", "warn", {
      MissingNodes: missingNodeTypes
    });
  }
  #showMissingModelsError(missingModels, paths) {
    if (useSettingStore().get("Comfy.Workflow.ShowMissingModelsWarning")) {
      showMissingModelsWarning({
        missingModels,
        paths
      });
    }
    this.logging.addEntry("Comfy.App", "warn", {
      MissingModels: missingModels
    });
  }
  async loadGraphData(graphData, clean = true, restore_view = true, workflow = null, { showMissingNodesDialog = true, showMissingModelsDialog = true } = {}) {
    if (clean !== false) {
      this.clean();
    }
    let reset_invalid_values = false;
    if (!graphData) {
      graphData = defaultGraph;
      reset_invalid_values = true;
    }
    if (typeof structuredClone === "undefined") {
      graphData = JSON.parse(JSON.stringify(graphData));
    } else {
      graphData = structuredClone(graphData);
    }
    if (useSettingStore().get("Comfy.Validation.Workflows")) {
      const validatedGraphData = await validateComfyWorkflow(
        graphData,
        /* onError=*/
        (err) => {
          useToastStore().addAlert(err);
        }
      );
      graphData = validatedGraphData ?? graphData;
    }
    workflowService.beforeLoadNewGraph();
    const missingNodeTypes = [];
    const missingModels = [];
    await this.#invokeExtensionsAsync(
      "beforeConfigureGraph",
      graphData,
      missingNodeTypes
      // TODO: missingModels
    );
    for (let n of graphData.nodes) {
      if (n.type == "T2IAdapterLoader") n.type = "ControlNetLoader";
      if (n.type == "ConditioningAverage ") n.type = "ConditioningAverage";
      if (n.type == "SDV_img2vid_Conditioning")
        n.type = "SVD_img2vid_Conditioning";
      if (!(n.type in LiteGraph.registered_node_types)) {
        missingNodeTypes.push(n.type);
        n.type = sanitizeNodeName(n.type);
      }
    }
    if (graphData.models && useSettingStore().get("Comfy.Workflow.ShowMissingModelsWarning")) {
      for (const m of graphData.models) {
        const models_available = await useModelStore().getLoadedModelFolder(
          m.directory
        );
        if (models_available === null) {
          m.directory_invalid = true;
          missingModels.push(m);
        } else if (!(m.name in models_available.models)) {
          missingModels.push(m);
        }
      }
    }
    try {
      this.graph.configure(graphData);
      if (restore_view && this.enableWorkflowViewRestore.value && graphData.extra?.ds) {
        this.canvas.ds.offset = graphData.extra.ds.offset;
        this.canvas.ds.scale = graphData.extra.ds.scale;
      }
    } catch (error) {
      let errorHint = [];
      const filename = error.fileName || (error.stack || "").match(/(\/extensions\/.*\.js)/)?.[1];
      const pos2 = (filename || "").indexOf("/extensions/");
      if (pos2 > -1) {
        errorHint.push(
          $el("span", {
            textContent: "This may be due to the following script:"
          }),
          $el("br"),
          $el("span", {
            style: {
              fontWeight: "bold"
            },
            textContent: filename.substring(pos2)
          })
        );
      }
      this.ui.dialog.show(
        $el("div", [
          $el("p", {
            textContent: "Loading aborted due to error reloading workflow data"
          }),
          $el("pre", {
            style: { padding: "5px", backgroundColor: "rgba(255,0,0,0.2)" },
            textContent: error.toString()
          }),
          $el("pre", {
            style: {
              padding: "5px",
              color: "#ccc",
              fontSize: "10px",
              maxHeight: "50vh",
              overflow: "auto",
              backgroundColor: "rgba(0,0,0,0.2)"
            },
            textContent: error.stack || "No stacktrace available"
          }),
          ...errorHint
        ]).outerHTML
      );
      return;
    }
    for (const node3 of this.graph.nodes) {
      const size2 = node3.computeSize();
      size2[0] = Math.max(node3.size[0], size2[0]);
      size2[1] = Math.max(node3.size[1], size2[1]);
      node3.size = size2;
      if (node3.widgets) {
        for (let widget of node3.widgets) {
          if (node3.type == "KSampler" || node3.type == "KSamplerAdvanced") {
            if (widget.name == "sampler_name") {
              if (typeof widget.value === "string" && widget.value.startsWith("sample_")) {
                widget.value = widget.value.slice(7);
              }
            }
          }
          if (node3.type == "KSampler" || node3.type == "KSamplerAdvanced" || node3.type == "PrimitiveNode") {
            if (widget.name == "control_after_generate") {
              if (widget.value === true) {
                widget.value = "randomize";
              } else if (widget.value === false) {
                widget.value = "fixed";
              }
            }
          }
          if (reset_invalid_values) {
            if (widget.type == "combo") {
              if (!widget.options.values.includes(widget.value) && widget.options.values.length > 0) {
                widget.value = widget.options.values[0];
              }
            }
          }
        }
      }
      this.#invokeExtensions("loadedGraphNode", node3);
    }
    if (missingNodeTypes.length && showMissingNodesDialog) {
      this.#showMissingNodesError(missingNodeTypes);
    }
    if (missingModels.length && showMissingModelsDialog) {
      const paths = await api.getFolderPaths();
      this.#showMissingModelsError(missingModels, paths);
    }
    await this.#invokeExtensionsAsync("afterConfigureGraph", missingNodeTypes);
    await workflowService.afterLoadNewGraph(workflow, this.graph.serialize());
    requestAnimationFrame(() => {
      this.graph.setDirtyCanvas(true, true);
    });
  }
  /**
   * Serializes a graph using preferred user settings.
   * @param graph The litegraph to serialize.
   * @returns A serialized graph (aka workflow) with preferred user settings.
   */
  serializeGraph(graph = this.graph) {
    const sortNodes = useSettingStore().get("Comfy.Workflow.SortNodeIdOnSave");
    return graph.serialize({ sortNodes });
  }
  /**
   * Converts the current graph workflow for sending to the API.
   * Note: Node widgets are updated before serialization to prepare queueing.
   * @returns The workflow and node links
   */
  async graphToPrompt(graph = this.graph, clean = true) {
    for (const outerNode of this.graph.computeExecutionOrder(false)) {
      if (outerNode.widgets) {
        for (const widget of outerNode.widgets) {
          widget.beforeQueued?.();
        }
      }
      const innerNodes = outerNode["getInnerNodes"] ? outerNode["getInnerNodes"]() : [outerNode];
      for (const node3 of innerNodes) {
        if (node3.isVirtualNode) {
          if (node3.applyToGraph) {
            node3.applyToGraph();
          }
        }
      }
    }
    const workflow = this.serializeGraph(graph);
    const output = {};
    for (const outerNode of graph.computeExecutionOrder(false)) {
      const skipNode = outerNode.mode === 2 || outerNode.mode === 4;
      const innerNodes = !skipNode && outerNode["getInnerNodes"] ? outerNode["getInnerNodes"]() : [outerNode];
      for (const node3 of innerNodes) {
        if (node3.isVirtualNode) {
          continue;
        }
        if (node3.mode === 2 || node3.mode === 4) {
          continue;
        }
        const inputs = {};
        const widgets = node3.widgets;
        if (widgets) {
          for (const i2 in widgets) {
            const widget = widgets[i2];
            if (!widget.options || widget.options.serialize !== false) {
              inputs[widget.name] = widget.serializeValue ? await widget.serializeValue(node3, i2) : widget.value;
            }
          }
        }
        for (let i2 in node3.inputs) {
          let parent = node3.getInputNode(i2);
          if (parent) {
            let link = node3.getInputLink(i2);
            while (parent.mode === 4 || parent.isVirtualNode) {
              let found = false;
              if (parent.isVirtualNode) {
                link = parent.getInputLink(link.origin_slot);
                if (link) {
                  parent = parent.getInputNode(link.target_slot);
                  if (parent) {
                    found = true;
                  }
                }
              } else if (link && parent.mode === 4) {
                let all_inputs = [link.origin_slot];
                if (parent.inputs) {
                  all_inputs = all_inputs.concat(Object.keys(parent.inputs));
                  for (let parent_input in all_inputs) {
                    parent_input = all_inputs[parent_input];
                    if (parent.inputs[parent_input]?.type === node3.inputs[i2].type) {
                      link = parent.getInputLink(parent_input);
                      if (link) {
                        parent = parent.getInputNode(parent_input);
                      }
                      found = true;
                      break;
                    }
                  }
                }
              }
              if (!found) {
                break;
              }
            }
            if (link) {
              if (parent?.updateLink) {
                link = parent.updateLink(link);
              }
              if (link) {
                inputs[node3.inputs[i2].name] = [
                  String(link.origin_id),
                  parseInt(link.origin_slot)
                ];
              }
            }
          }
        }
        let node_data = {
          inputs,
          class_type: node3.comfyClass
        };
        if (this.ui.settings.getSettingValue("Comfy.DevMode")) {
          node_data["_meta"] = {
            title: node3.title
          };
        }
        output[String(node3.id)] = node_data;
      }
    }
    if (clean) {
      for (const o in output) {
        for (const i2 in output[o].inputs) {
          if (Array.isArray(output[o].inputs[i2]) && output[o].inputs[i2].length === 2 && !output[output[o].inputs[i2][0]]) {
            delete output[o].inputs[i2];
          }
        }
      }
    }
    return { workflow, output };
  }
  #formatPromptError(error) {
    if (error == null) {
      return "(unknown error)";
    } else if (typeof error === "string") {
      return error;
    } else if (error.stack && error.message) {
      return error.toString();
    } else if (error.response) {
      let message2 = error.response.error.message;
      if (error.response.error.details)
        message2 += ": " + error.response.error.details;
      for (const [nodeID, nodeError] of Object.entries(
        error.response.node_errors
      )) {
        message2 += "\n" + nodeError.class_type + ":";
        for (const errorReason of nodeError.errors) {
          message2 += "\n    - " + errorReason.message + ": " + errorReason.details;
        }
      }
      return message2;
    }
    return "(unknown error)";
  }
  async queuePrompt(number2, batchCount = 1) {
    this.#queueItems.push({ number: number2, batchCount });
    if (this.#processingQueue) {
      return;
    }
    this.#processingQueue = true;
    this.lastNodeErrors = null;
    try {
      while (this.#queueItems.length) {
        ;
        ({ number: number2, batchCount } = this.#queueItems.pop());
        for (let i2 = 0; i2 < batchCount; i2++) {
          const p2 = await this.graphToPrompt();
          try {
            const res = await api.queuePrompt(number2, p2);
            this.lastNodeErrors = res.node_errors;
            if (this.lastNodeErrors.length > 0) {
              this.canvas.draw(true, true);
            } else {
              try {
                useExecutionStore().storePrompt({
                  id: res.prompt_id,
                  nodes: Object.keys(p2.output),
                  workflow: useWorkspaceStore().workflow.activeWorkflow
                });
              } catch (error) {
              }
            }
          } catch (error) {
            const formattedError = this.#formatPromptError(error);
            this.ui.dialog.show(formattedError);
            if (error.response) {
              this.lastNodeErrors = error.response.node_errors;
              this.canvas.draw(true, true);
            }
            break;
          }
          for (const n of p2.workflow.nodes) {
            const node3 = this.graph.getNodeById(n.id);
            if (node3.widgets) {
              for (const widget of node3.widgets) {
                if (widget.afterQueued) {
                  widget.afterQueued();
                }
              }
            }
          }
          this.canvas.draw(true, true);
          await this.ui.queue.update();
        }
      }
    } finally {
      this.#processingQueue = false;
    }
    api.dispatchEvent(
      new CustomEvent("promptQueued", { detail: { number: number2, batchCount } })
    );
    return !this.lastNodeErrors;
  }
  showErrorOnFileLoad(file) {
    this.ui.dialog.show(
      $el("div", [
        $el("p", { textContent: `Unable to find workflow in ${file.name}` })
      ]).outerHTML
    );
  }
  /**
   * Loads workflow data from the specified file
   * @param {File} file
   */
  async handleFile(file) {
    const removeExt = /* @__PURE__ */ __name((f) => {
      if (!f) return f;
      const p2 = f.lastIndexOf(".");
      if (p2 === -1) return f;
      return f.substring(0, p2);
    }, "removeExt");
    const fileName = removeExt(file.name);
    if (file.type === "image/png") {
      const pngInfo = await getPngMetadata(file);
      if (pngInfo?.workflow) {
        await this.loadGraphData(
          JSON.parse(pngInfo.workflow),
          true,
          true,
          fileName
        );
      } else if (pngInfo?.prompt) {
        this.loadApiJson(JSON.parse(pngInfo.prompt), fileName);
      } else if (pngInfo?.parameters) {
        workflowService.beforeLoadNewGraph();
        importA1111(this.graph, pngInfo.parameters);
        workflowService.afterLoadNewGraph(fileName, this.serializeGraph());
      } else {
        this.showErrorOnFileLoad(file);
      }
    } else if (file.type === "image/webp") {
      const pngInfo = await getWebpMetadata(file);
      const workflow = pngInfo?.workflow || pngInfo?.Workflow;
      const prompt = pngInfo?.prompt || pngInfo?.Prompt;
      if (workflow) {
        this.loadGraphData(JSON.parse(workflow), true, true, fileName);
      } else if (prompt) {
        this.loadApiJson(JSON.parse(prompt), fileName);
      } else {
        this.showErrorOnFileLoad(file);
      }
    } else if (file.type === "audio/flac" || file.type === "audio/x-flac") {
      const pngInfo = await getFlacMetadata(file);
      const workflow = pngInfo?.workflow || pngInfo?.Workflow;
      const prompt = pngInfo?.prompt || pngInfo?.Prompt;
      if (workflow) {
        this.loadGraphData(JSON.parse(workflow), true, true, fileName);
      } else if (prompt) {
        this.loadApiJson(JSON.parse(prompt), fileName);
      } else {
        this.showErrorOnFileLoad(file);
      }
    } else if (file.type === "application/json" || file.name?.endsWith(".json")) {
      const reader = new FileReader();
      reader.onload = async () => {
        const readerResult = reader.result;
        const jsonContent = JSON.parse(readerResult);
        if (jsonContent?.templates) {
          this.loadTemplateData(jsonContent);
        } else if (this.isApiJson(jsonContent)) {
          this.loadApiJson(jsonContent, fileName);
        } else {
          await this.loadGraphData(
            JSON.parse(readerResult),
            true,
            false,
            fileName
          );
        }
      };
      reader.readAsText(file);
    } else if (file.name?.endsWith(".latent") || file.name?.endsWith(".safetensors")) {
      const info = await getLatentMetadata(file);
      if (info.workflow) {
        await this.loadGraphData(
          // @ts-expect-error
          JSON.parse(info.workflow),
          true,
          true,
          fileName
        );
      } else if (info.prompt) {
        this.loadApiJson(JSON.parse(info.prompt));
      } else {
        this.showErrorOnFileLoad(file);
      }
    } else {
      this.showErrorOnFileLoad(file);
    }
  }
  isApiJson(data22) {
    return Object.values(data22).every((v2) => v2.class_type);
  }
  loadApiJson(apiData, fileName) {
    workflowService.beforeLoadNewGraph();
    const missingNodeTypes = Object.values(apiData).filter(
      // @ts-expect-error
      (n) => !LiteGraph.registered_node_types[n.class_type]
    );
    if (missingNodeTypes.length) {
      this.#showMissingNodesError(
        // @ts-expect-error
        missingNodeTypes.map((t) => t.class_type)
      );
      return;
    }
    const ids = Object.keys(apiData);
    app$1.graph.clear();
    for (const id3 of ids) {
      const data22 = apiData[id3];
      const node3 = LiteGraph.createNode(data22.class_type);
      node3.id = isNaN(+id3) ? id3 : +id3;
      node3.title = data22._meta?.title ?? node3.title;
      app$1.graph.add(node3);
    }
    for (const id3 of ids) {
      const data22 = apiData[id3];
      const node3 = app$1.graph.getNodeById(id3);
      for (const input in data22.inputs ?? {}) {
        const value3 = data22.inputs[input];
        if (value3 instanceof Array) {
          const [fromId, fromSlot] = value3;
          const fromNode = app$1.graph.getNodeById(fromId);
          let toSlot = node3.inputs?.findIndex((inp) => inp.name === input);
          if (toSlot == null || toSlot === -1) {
            try {
              const widget = node3.widgets?.find((w2) => w2.name === input);
              if (widget && node3.convertWidgetToInput?.(widget)) {
                toSlot = node3.inputs?.length - 1;
              }
            } catch (error) {
            }
          }
          if (toSlot != null || toSlot !== -1) {
            fromNode.connect(fromSlot, node3, toSlot);
          }
        } else {
          const widget = node3.widgets?.find((w2) => w2.name === input);
          if (widget) {
            widget.value = value3;
            widget.callback?.(value3);
          }
        }
      }
    }
    app$1.graph.arrange();
    for (const id3 of ids) {
      const data22 = apiData[id3];
      const node3 = app$1.graph.getNodeById(id3);
      for (const input in data22.inputs ?? {}) {
        const value3 = data22.inputs[input];
        if (value3 instanceof Array) {
          const [fromId, fromSlot] = value3;
          const fromNode = app$1.graph.getNodeById(fromId);
          let toSlot = node3.inputs?.findIndex((inp) => inp.name === input);
          if (toSlot == null || toSlot === -1) {
            try {
              const widget = node3.widgets?.find((w2) => w2.name === input);
              if (widget && node3.convertWidgetToInput?.(widget)) {
                toSlot = node3.inputs?.length - 1;
              }
            } catch (error) {
            }
          }
          if (toSlot != null || toSlot !== -1) {
            fromNode.connect(fromSlot, node3, toSlot);
          }
        } else {
          const widget = node3.widgets?.find((w2) => w2.name === input);
          if (widget) {
            widget.value = value3;
            widget.callback?.(value3);
          }
        }
      }
    }
    app$1.graph.arrange();
    workflowService.afterLoadNewGraph(fileName, this.serializeGraph());
  }
  /**
   * Registers a Comfy web extension with the app
   * @param {ComfyExtension} extension
   */
  registerExtension(extension) {
    if (this.vueAppReady) {
      useExtensionStore().registerExtension(extension);
    } else {
      this.extensions.push(extension);
    }
  }
  /**
   * Refresh combo list on whole nodes
   */
  async refreshComboInNodes() {
    const requestToastMessage = {
      severity: "info",
      summary: "Update",
      detail: "Update requested"
    };
    if (this.vueAppReady) {
      useToastStore().add(requestToastMessage);
    }
    const defs = await api.getNodeDefs({
      validate: useSettingStore().get("Comfy.Validation.NodeDefs")
    });
    for (const nodeId in defs) {
      this.registerNodeDef(nodeId, defs[nodeId]);
    }
    for (let nodeNum in this.graph.nodes) {
      const node3 = this.graph.nodes[nodeNum];
      const def2 = defs[node3.type];
      node3.refreshComboInNode?.(defs);
      if (!def2) continue;
      for (const widgetNum in node3.widgets) {
        const widget = node3.widgets[widgetNum];
        if (widget.type == "combo" && def2["input"]["required"][widget.name] !== void 0) {
          widget.options.values = def2["input"]["required"][widget.name][0];
        }
      }
    }
    await this.#invokeExtensionsAsync("refreshComboInNodes", defs);
    if (this.vueAppReady) {
      this.updateVueAppNodeDefs(defs);
      useToastStore().remove(requestToastMessage);
      useToastStore().add({
        severity: "success",
        summary: "Updated",
        detail: "Node definitions updated",
        life: 1e3
      });
    }
  }
  resetView() {
    app$1.canvas.ds.scale = 1;
    app$1.canvas.ds.offset = [0, 0];
    app$1.graph.setDirtyCanvas(true, true);
  }
  /**
   * Clean current state
   */
  clean() {
    this.nodeOutputs = {};
    this.nodePreviewImages = {};
    this.lastNodeErrors = null;
    this.lastExecutionError = null;
  }
  addNodeOnGraph(nodeDef, options3 = {}) {
    const node3 = LiteGraph.createNode(
      nodeDef.name,
      nodeDef.display_name,
      options3
    );
    this.graph.add(node3);
    return node3;
  }
  clientPosToCanvasPos(pos2) {
    const rect = this.canvasContainer.getBoundingClientRect();
    const containerOffsets = [rect.left, rect.top];
    return _.zip(pos2, this.canvas.ds.offset, containerOffsets).map(
      ([p2, o1, o2]) => (p2 - o2) / this.canvas.ds.scale - o1
    );
  }
  canvasPosToClientPos(pos2) {
    const rect = this.canvasContainer.getBoundingClientRect();
    const containerOffsets = [rect.left, rect.top];
    return _.zip(pos2, this.canvas.ds.offset, containerOffsets).map(
      ([p2, o1, o2]) => (p2 + o1) * this.canvas.ds.scale + o2
    );
  }
  getCanvasCenter() {
    const dpi = Math.max(window.devicePixelRatio ?? 1, 1);
    const [x2, y2, w2, h2] = app$1.canvas.ds.visible_area;
    return [x2 + w2 / dpi / 2, y2 + h2 / dpi / 2];
  }
  goToNode(nodeId) {
    const graphNode = this.graph.getNodeById(nodeId);
    if (!graphNode) return;
    this.canvas.animateToBounds(graphNode.boundingRect);
  }
}
const app$1 = new ComfyApp();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.app = window.comfyAPI.app || {};
window.comfyAPI.app.ANIM_PREVIEW_WIDGET = ANIM_PREVIEW_WIDGET;
window.comfyAPI.app.ComfyApp = ComfyApp;
window.comfyAPI.app.app = app$1;
const useTitleEditorStore = /* @__PURE__ */ defineStore("titleEditor", () => {
  const titleEditorTarget = shallowRef(null);
  return {
    titleEditorTarget
  };
});
const useCanvasStore = /* @__PURE__ */ defineStore("canvas", () => {
  const canvas = shallowRef(null);
  return {
    canvas
  };
});
function useErrorHandling() {
  const toast = useToastStore();
  const { t } = useI18n();
  const toastErrorHandler = /* @__PURE__ */ __name((error) => {
    toast.add({
      severity: "error",
      summary: t("error"),
      detail: error.message,
      life: 3e3
    });
  }, "toastErrorHandler");
  const wrapWithErrorHandling = /* @__PURE__ */ __name((action, errorHandler, finallyHandler) => (...args) => {
    try {
      return action(...args);
    } catch (e) {
      ;
      (errorHandler ?? toastErrorHandler)(e);
    } finally {
      finallyHandler?.();
    }
  }, "wrapWithErrorHandling");
  const wrapWithErrorHandlingAsync = /* @__PURE__ */ __name((action, errorHandler, finallyHandler) => async (...args) => {
    try {
      return await action(...args);
    } catch (e) {
      ;
      (errorHandler ?? toastErrorHandler)(e);
    } finally {
      finallyHandler?.();
    }
  }, "wrapWithErrorHandlingAsync");
  return { wrapWithErrorHandling, wrapWithErrorHandlingAsync };
}
__name(useErrorHandling, "useErrorHandling");
class ComfyCommandImpl {
  static {
    __name(this, "ComfyCommandImpl");
  }
  id;
  function;
  _label;
  _icon;
  _tooltip;
  _menubarLabel;
  versionAdded;
  constructor(command) {
    this.id = command.id;
    this.function = command.function;
    this._label = command.label;
    this._icon = command.icon;
    this._tooltip = command.tooltip;
    this._menubarLabel = command.menubarLabel ?? command.label;
    this.versionAdded = command.versionAdded;
  }
  get label() {
    return typeof this._label === "function" ? this._label() : this._label;
  }
  get icon() {
    return typeof this._icon === "function" ? this._icon() : this._icon;
  }
  get tooltip() {
    return typeof this._tooltip === "function" ? this._tooltip() : this._tooltip;
  }
  get menubarLabel() {
    return typeof this._menubarLabel === "function" ? this._menubarLabel() : this._menubarLabel;
  }
  get keybinding() {
    return useKeybindingStore().getKeybindingByCommandId(this.id);
  }
}
const getTracker = /* @__PURE__ */ __name(() => useWorkflowStore()?.activeWorkflow?.changeTracker, "getTracker");
const getSelectedNodes = /* @__PURE__ */ __name(() => {
  const selectedNodes = app$1.canvas.selected_nodes;
  const result = [];
  if (selectedNodes) {
    for (const i2 in selectedNodes) {
      const node3 = selectedNodes[i2];
      result.push(node3);
    }
  }
  return result;
}, "getSelectedNodes");
const toggleSelectedNodesMode = /* @__PURE__ */ __name((mode2) => {
  getSelectedNodes().forEach((node3) => {
    if (node3.mode === mode2) {
      node3.mode = 0;
    } else {
      node3.mode = mode2;
    }
  });
}, "toggleSelectedNodesMode");
const useCommandStore = /* @__PURE__ */ defineStore("command", () => {
  const settingStore = useSettingStore();
  const commandsById = ref({});
  const commands = computed(() => Object.values(commandsById.value));
  const registerCommand = /* @__PURE__ */ __name((command) => {
    if (commandsById.value[command.id]) {
      console.warn(`Command ${command.id} already registered`);
    }
    commandsById.value[command.id] = new ComfyCommandImpl(command);
  }, "registerCommand");
  const commandDefinitions = [
    {
      id: "Comfy.NewBlankWorkflow",
      icon: "pi pi-plus",
      label: "New Blank Workflow",
      menubarLabel: "New",
      function: /* @__PURE__ */ __name(() => workflowService.loadBlankWorkflow(), "function")
    },
    {
      id: "Comfy.OpenWorkflow",
      icon: "pi pi-folder-open",
      label: "Open Workflow",
      menubarLabel: "Open",
      function: /* @__PURE__ */ __name(() => {
        app$1.ui.loadFile();
      }, "function")
    },
    {
      id: "Comfy.LoadDefaultWorkflow",
      icon: "pi pi-code",
      label: "Load Default Workflow",
      function: /* @__PURE__ */ __name(() => workflowService.loadDefaultWorkflow(), "function")
    },
    {
      id: "Comfy.SaveWorkflow",
      icon: "pi pi-save",
      label: "Save Workflow",
      menubarLabel: "Save",
      function: /* @__PURE__ */ __name(async () => {
        const workflow = useWorkflowStore().activeWorkflow;
        if (!workflow) return;
        await workflowService.saveWorkflow(workflow);
      }, "function")
    },
    {
      id: "Comfy.SaveWorkflowAs",
      icon: "pi pi-save",
      label: "Save Workflow As",
      menubarLabel: "Save As",
      function: /* @__PURE__ */ __name(async () => {
        const workflow = useWorkflowStore().activeWorkflow;
        if (!workflow) return;
        await workflowService.saveWorkflowAs(workflow);
      }, "function")
    },
    {
      id: "Comfy.ExportWorkflow",
      icon: "pi pi-download",
      label: "Export Workflow",
      menubarLabel: "Export",
      function: /* @__PURE__ */ __name(() => {
        workflowService.exportWorkflow("workflow", "workflow");
      }, "function")
    },
    {
      id: "Comfy.ExportWorkflowAPI",
      icon: "pi pi-download",
      label: "Export Workflow (API Format)",
      menubarLabel: "Export (API)",
      function: /* @__PURE__ */ __name(() => {
        workflowService.exportWorkflow("workflow_api", "output");
      }, "function")
    },
    {
      id: "Comfy.Undo",
      icon: "pi pi-undo",
      label: "Undo",
      function: /* @__PURE__ */ __name(async () => {
        await getTracker()?.undo?.();
      }, "function")
    },
    {
      id: "Comfy.Redo",
      icon: "pi pi-refresh",
      label: "Redo",
      function: /* @__PURE__ */ __name(async () => {
        await getTracker()?.redo?.();
      }, "function")
    },
    {
      id: "Comfy.ClearWorkflow",
      icon: "pi pi-trash",
      label: "Clear Workflow",
      function: /* @__PURE__ */ __name(() => {
        if (!settingStore.get("Comfy.ComfirmClear") || confirm("Clear workflow?")) {
          app$1.clean();
          app$1.graph.clear();
          api.dispatchEvent(new CustomEvent("graphCleared"));
        }
      }, "function")
    },
    {
      id: "Comfy.Canvas.ResetView",
      icon: "pi pi-expand",
      label: "Reset View",
      function: /* @__PURE__ */ __name(() => {
        app$1.resetView();
      }, "function")
    },
    {
      id: "Comfy.OpenClipspace",
      icon: "pi pi-clipboard",
      label: "Clipspace",
      function: /* @__PURE__ */ __name(() => {
        app$1.openClipspace();
      }, "function")
    },
    {
      id: "Comfy.RefreshNodeDefinitions",
      icon: "pi pi-refresh",
      label: "Refresh Node Definitions",
      function: /* @__PURE__ */ __name(async () => {
        await app$1.refreshComboInNodes();
      }, "function")
    },
    {
      id: "Comfy.Interrupt",
      icon: "pi pi-stop",
      label: "Interrupt",
      function: /* @__PURE__ */ __name(async () => {
        await api.interrupt();
        useToastStore().add({
          severity: "info",
          summary: "Interrupted",
          detail: "Execution has been interrupted",
          life: 1e3
        });
      }, "function")
    },
    {
      id: "Comfy.ClearPendingTasks",
      icon: "pi pi-stop",
      label: "Clear Pending Tasks",
      function: /* @__PURE__ */ __name(async () => {
        await useQueueStore().clear(["queue"]);
        useToastStore().add({
          severity: "info",
          summary: "Confirmed",
          detail: "Pending tasks deleted",
          life: 3e3
        });
      }, "function")
    },
    {
      id: "Comfy.BrowseTemplates",
      icon: "pi pi-folder-open",
      label: "Browse Templates",
      function: showTemplateWorkflowsDialog
    },
    {
      id: "Comfy.Canvas.ZoomIn",
      icon: "pi pi-plus",
      label: "Zoom In",
      function: /* @__PURE__ */ __name(() => {
        const ds = app$1.canvas.ds;
        ds.changeScale(
          ds.scale * 1.1,
          ds.element ? [ds.element.width / 2, ds.element.height / 2] : void 0
        );
        app$1.canvas.setDirty(true, true);
      }, "function")
    },
    {
      id: "Comfy.Canvas.ZoomOut",
      icon: "pi pi-minus",
      label: "Zoom Out",
      function: /* @__PURE__ */ __name(() => {
        const ds = app$1.canvas.ds;
        ds.changeScale(
          ds.scale / 1.1,
          ds.element ? [ds.element.width / 2, ds.element.height / 2] : void 0
        );
        app$1.canvas.setDirty(true, true);
      }, "function")
    },
    {
      id: "Comfy.Canvas.FitView",
      icon: "pi pi-expand",
      label: "Fit view to selected nodes",
      function: /* @__PURE__ */ __name(() => app$1.canvas.fitViewToSelectionAnimated(), "function")
    },
    {
      id: "Comfy.Canvas.ToggleLock",
      icon: "pi pi-lock",
      label: "Toggle Lock",
      function: /* @__PURE__ */ __name(() => {
        app$1.canvas["read_only"] = !app$1.canvas["read_only"];
      }, "function")
    },
    {
      id: "Comfy.Canvas.ToggleLinkVisibility",
      icon: "pi pi-eye",
      label: "Toggle Link Visibility",
      versionAdded: "1.3.6",
      function: (() => {
        let lastLinksRenderMode = LiteGraph.SPLINE_LINK;
        return () => {
          const currentMode = settingStore.get("Comfy.LinkRenderMode");
          if (currentMode === LiteGraph.HIDDEN_LINK) {
            settingStore.set("Comfy.LinkRenderMode", lastLinksRenderMode);
          } else {
            lastLinksRenderMode = currentMode;
            settingStore.set("Comfy.LinkRenderMode", LiteGraph.HIDDEN_LINK);
          }
        };
      })()
    },
    {
      id: "Comfy.QueuePrompt",
      icon: "pi pi-play",
      label: "Queue Prompt",
      versionAdded: "1.3.7",
      function: /* @__PURE__ */ __name(() => {
        const batchCount = useQueueSettingsStore().batchCount;
        app$1.queuePrompt(0, batchCount);
      }, "function")
    },
    {
      id: "Comfy.QueuePromptFront",
      icon: "pi pi-play",
      label: "Queue Prompt (Front)",
      versionAdded: "1.3.7",
      function: /* @__PURE__ */ __name(() => {
        const batchCount = useQueueSettingsStore().batchCount;
        app$1.queuePrompt(-1, batchCount);
      }, "function")
    },
    {
      id: "Comfy.ShowSettingsDialog",
      icon: "pi pi-cog",
      label: "Settings",
      versionAdded: "1.3.7",
      function: /* @__PURE__ */ __name(() => {
        showSettingsDialog();
      }, "function")
    },
    {
      id: "Comfy.Graph.GroupSelectedNodes",
      icon: "pi pi-sitemap",
      label: "Group Selected Nodes",
      versionAdded: "1.3.7",
      function: /* @__PURE__ */ __name(() => {
        const { canvas } = app$1;
        if (!canvas.selectedItems?.size) {
          useToastStore().add({
            severity: "error",
            summary: "Nothing to group",
            detail: "Please select the nodes (or other groups) to create a group for",
            life: 3e3
          });
          return;
        }
        const group = new LGraphGroup();
        const padding = useSettingStore().get(
          "Comfy.GroupSelectedNodes.Padding"
        );
        group.resizeTo(canvas.selectedItems, padding);
        canvas.graph.add(group);
        useTitleEditorStore().titleEditorTarget = group;
      }, "function")
    },
    {
      id: "Workspace.NextOpenedWorkflow",
      icon: "pi pi-step-forward",
      label: "Next Opened Workflow",
      versionAdded: "1.3.9",
      function: /* @__PURE__ */ __name(() => {
        workflowService.loadNextOpenedWorkflow();
      }, "function")
    },
    {
      id: "Workspace.PreviousOpenedWorkflow",
      icon: "pi pi-step-backward",
      label: "Previous Opened Workflow",
      versionAdded: "1.3.9",
      function: /* @__PURE__ */ __name(() => {
        workflowService.loadPreviousOpenedWorkflow();
      }, "function")
    },
    {
      id: "Comfy.Canvas.ToggleSelectedNodes.Mute",
      icon: "pi pi-volume-off",
      label: "Mute/Unmute Selected Nodes",
      versionAdded: "1.3.11",
      function: /* @__PURE__ */ __name(() => {
        toggleSelectedNodesMode(2);
      }, "function")
    },
    {
      id: "Comfy.Canvas.ToggleSelectedNodes.Bypass",
      icon: "pi pi-shield",
      label: "Bypass/Unbypass Selected Nodes",
      versionAdded: "1.3.11",
      function: /* @__PURE__ */ __name(() => {
        toggleSelectedNodesMode(4);
      }, "function")
    },
    {
      id: "Comfy.Canvas.ToggleSelectedNodes.Pin",
      icon: "pi pi-pin",
      label: "Pin/Unpin Selected Nodes",
      versionAdded: "1.3.11",
      function: /* @__PURE__ */ __name(() => {
        getSelectedNodes().forEach((node3) => {
          node3.pin(!node3.pinned);
        });
      }, "function")
    },
    {
      id: "Comfy.Canvas.ToggleSelected.Pin",
      icon: "pi pi-pin",
      label: "Pin/Unpin Selected Items",
      versionAdded: "1.3.33",
      function: /* @__PURE__ */ __name(() => {
        for (const item2 of app$1.canvas.selectedItems) {
          if (item2 instanceof LGraphNode || item2 instanceof LGraphGroup) {
            item2.pin(!item2.pinned);
          }
        }
      }, "function")
    },
    {
      id: "Comfy.Canvas.ToggleSelectedNodes.Collapse",
      icon: "pi pi-minus",
      label: "Collapse/Expand Selected Nodes",
      versionAdded: "1.3.11",
      function: /* @__PURE__ */ __name(() => {
        getSelectedNodes().forEach((node3) => {
          node3.collapse();
        });
      }, "function")
    },
    {
      id: "Comfy.ToggleTheme",
      icon: "pi pi-moon",
      label: "Toggle Theme",
      versionAdded: "1.3.12",
      function: /* @__PURE__ */ (() => {
        let previousDarkTheme = "dark";
        const isDarkMode = /* @__PURE__ */ __name((themeId) => themeId !== "light", "isDarkMode");
        return () => {
          const currentTheme = settingStore.get("Comfy.ColorPalette");
          if (isDarkMode(currentTheme)) {
            previousDarkTheme = currentTheme;
            settingStore.set("Comfy.ColorPalette", "light");
          } else {
            settingStore.set("Comfy.ColorPalette", previousDarkTheme);
          }
        };
      })()
    },
    {
      id: "Workspace.ToggleBottomPanel",
      icon: "pi pi-list",
      label: "Toggle Bottom Panel",
      versionAdded: "1.3.22",
      function: /* @__PURE__ */ __name(() => {
        useBottomPanelStore().toggleBottomPanel();
      }, "function")
    },
    {
      id: "Workspace.ToggleFocusMode",
      icon: "pi pi-eye",
      label: "Toggle Focus Mode",
      versionAdded: "1.3.27",
      function: /* @__PURE__ */ __name(() => {
        useWorkspaceStore().toggleFocusMode();
      }, "function")
    }
  ];
  commandDefinitions.forEach(registerCommand);
  const getCommand = /* @__PURE__ */ __name((command) => {
    return commandsById.value[command];
  }, "getCommand");
  const { wrapWithErrorHandlingAsync } = useErrorHandling();
  const execute = /* @__PURE__ */ __name(async (commandId, errorHandler) => {
    const command = getCommand(commandId);
    if (command) {
      await wrapWithErrorHandlingAsync(command.function, errorHandler)();
    } else {
      throw new Error(`Command ${commandId} not found`);
    }
  }, "execute");
  const isRegistered = /* @__PURE__ */ __name((command) => {
    return !!commandsById.value[command];
  }, "isRegistered");
  const loadExtensionCommands = /* @__PURE__ */ __name((extension) => {
    if (extension.commands) {
      for (const command of extension.commands) {
        registerCommand(command);
      }
    }
  }, "loadExtensionCommands");
  return {
    commands,
    execute,
    getCommand,
    registerCommand,
    isRegistered,
    loadExtensionCommands
  };
});
var theme$c = /* @__PURE__ */ __name(function theme25(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-tree {\n    background: ".concat(dt2("tree.background"), ";\n    color: ").concat(dt2("tree.color"), ";\n    padding: ").concat(dt2("tree.padding"), ";\n}\n\n.p-tree-root-children,\n.p-tree-node-children {\n    display: flex;\n    list-style-type: none;\n    flex-direction: column;\n    margin: 0;\n    gap: ").concat(dt2("tree.gap"), ";\n}\n\n.p-tree-root-children {\n    padding: ").concat(dt2("tree.gap"), " 0 0 0;\n}\n\n.p-tree-node-children {\n    padding: ").concat(dt2("tree.gap"), " 0 0 ").concat(dt2("tree.indent"), ";\n}\n\n.p-tree-node {\n    padding: 0;\n    outline: 0 none;\n}\n\n.p-tree-node-content {\n    border-radius: ").concat(dt2("tree.node.border.radius"), ";\n    padding: ").concat(dt2("tree.node.padding"), ";\n    display: flex;\n    align-items: center;\n    outline-color: transparent;\n    color: ").concat(dt2("tree.node.color"), ";\n    gap: ").concat(dt2("tree.node.gap"), ";\n    transition: background ").concat(dt2("tree.transition.duration"), ", color ").concat(dt2("tree.transition.duration"), ", outline-color ").concat(dt2("tree.transition.duration"), ", box-shadow ").concat(dt2("tree.transition.duration"), ";\n}\n\n.p-tree-node:focus-visible > .p-tree-node-content {\n    box-shadow: ").concat(dt2("tree.node.focus.ring.shadow"), ";\n    outline: ").concat(dt2("tree.node.focus.ring.width"), " ").concat(dt2("tree.node.focus.ring.style"), " ").concat(dt2("tree.node.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("tree.node.focus.ring.offset"), ";\n}\n\n.p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover {\n    background: ").concat(dt2("tree.node.hover.background"), ";\n    color: ").concat(dt2("tree.node.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover .p-tree-node-icon {\n    color: ").concat(dt2("tree.node.icon.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected {\n    background: ").concat(dt2("tree.node.selected.background"), ";\n    color: ").concat(dt2("tree.node.selected.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button {\n    color: inherit;\n}\n\n.p-tree-node-toggle-button {\n    cursor: pointer;\n    user-select: none;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    flex-shrink: 0;\n    width: ").concat(dt2("tree.node.toggle.button.size"), ";\n    height: ").concat(dt2("tree.node.toggle.button.size"), ";\n    color: ").concat(dt2("tree.node.toggle.button.color"), ";\n    border: 0 none;\n    background: transparent;\n    border-radius: ").concat(dt2("tree.node.toggle.button.border.radius"), ";\n    transition: background ").concat(dt2("tree.transition.duration"), ", color ").concat(dt2("tree.transition.duration"), ", border-color ").concat(dt2("tree.transition.duration"), ", outline-color ").concat(dt2("tree.transition.duration"), ", box-shadow ").concat(dt2("tree.transition.duration"), ";\n    outline-color: transparent;\n    padding: 0;\n}\n\n.p-tree-node-toggle-button:enabled:hover {\n    background: ").concat(dt2("tree.node.toggle.button.hover.background"), ";\n    color: ").concat(dt2("tree.node.toggle.button.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button:hover {\n    background: ").concat(dt2("tree.node.toggle.button.selected.hover.background"), ";\n    color: ").concat(dt2("tree.node.toggle.button.selected.hover.color"), ";\n}\n\n.p-tree-root {\n    overflow: auto;\n}\n\n.p-tree-node-selectable {\n    cursor: pointer;\n    user-select: none;\n}\n\n.p-tree-node-leaf > .p-tree-node-content .p-tree-node-toggle-button {\n    visibility: hidden;\n}\n\n.p-tree-node-icon {\n    color: ").concat(dt2("tree.node.icon.color"), ";\n    transition: color ").concat(dt2("tree.transition.duration"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-icon {\n    color: ").concat(dt2("tree.node.icon.selected.color"), ";\n}\n\n.p-tree-filter-input {\n    width: 100%;\n}\n\n.p-tree-loading {\n    position: relative;\n    height: 100%;\n}\n\n.p-tree-loading-icon {\n    font-size: ").concat(dt2("tree.loading.icon.size"), ";\n    width: ").concat(dt2("tree.loading.icon.size"), ";\n    height: ").concat(dt2("tree.loading.icon.size"), ";\n}\n\n.p-tree .p-tree-mask {\n    position: absolute;\n    z-index: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-tree-flex-scrollable {\n    display: flex;\n    flex: 1;\n    height: 100%;\n    flex-direction: column;\n}\n\n.p-tree-flex-scrollable .p-tree-root {\n    flex: 1;\n}\n");
}, "theme");
var classes$c = {
  root: /* @__PURE__ */ __name(function root17(_ref2) {
    var props = _ref2.props;
    return ["p-tree p-component", {
      "p-tree-selectable": props.selectionMode != null,
      "p-tree-loading": props.loading,
      "p-tree-flex-scrollable": props.scrollHeight === "flex"
    }];
  }, "root"),
  mask: "p-tree-mask p-overlay-mask",
  loadingIcon: "p-tree-loading-icon",
  pcFilterInput: "p-tree-filter-input",
  wrapper: "p-tree-root",
  //TODO: discuss
  rootChildren: "p-tree-root-children",
  node: /* @__PURE__ */ __name(function node2(_ref3) {
    var instance = _ref3.instance;
    return ["p-tree-node", {
      "p-tree-node-leaf": instance.leaf
    }];
  }, "node"),
  nodeContent: /* @__PURE__ */ __name(function nodeContent(_ref4) {
    var instance = _ref4.instance;
    return ["p-tree-node-content", instance.node.styleClass, {
      "p-tree-node-selectable": instance.selectable,
      "p-tree-node-selected": instance.checkboxMode && instance.$parentInstance.highlightOnSelect ? instance.checked : instance.selected
    }];
  }, "nodeContent"),
  nodeToggleButton: "p-tree-node-toggle-button",
  nodeToggleIcon: "p-tree-node-toggle-icon",
  nodeCheckbox: "p-tree-node-checkbox",
  nodeIcon: "p-tree-node-icon",
  nodeLabel: "p-tree-node-label",
  nodeChildren: "p-tree-node-children"
};
var TreeStyle = BaseStyle.extend({
  name: "tree",
  theme: theme$c,
  classes: classes$c
});
var script$k = {
  name: "MinusIcon",
  "extends": script$X
};
var _hoisted_1$A = /* @__PURE__ */ createBaseVNode("path", {
  d: "M13.2222 7.77778H0.777778C0.571498 7.77778 0.373667 7.69584 0.227806 7.54998C0.0819442 7.40412 0 7.20629 0 7.00001C0 6.79373 0.0819442 6.5959 0.227806 6.45003C0.373667 6.30417 0.571498 6.22223 0.777778 6.22223H13.2222C13.4285 6.22223 13.6263 6.30417 13.7722 6.45003C13.9181 6.5959 14 6.79373 14 7.00001C14 7.20629 13.9181 7.40412 13.7722 7.54998C13.6263 7.69584 13.4285 7.77778 13.2222 7.77778Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$p = [_hoisted_1$A];
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$p, 16);
}
__name(render$j, "render$j");
script$k.render = render$j;
var theme$b = /* @__PURE__ */ __name(function theme26(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-checkbox {\n    position: relative;\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    width: ".concat(dt2("checkbox.width"), ";\n    height: ").concat(dt2("checkbox.height"), ";\n}\n\n.p-checkbox-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border: 1px solid transparent;\n    border-radius: ").concat(dt2("checkbox.border.radius"), ";\n}\n\n.p-checkbox-box {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: ").concat(dt2("checkbox.border.radius"), ";\n    border: 1px solid ").concat(dt2("checkbox.border.color"), ";\n    background: ").concat(dt2("checkbox.background"), ";\n    width: ").concat(dt2("checkbox.width"), ";\n    height: ").concat(dt2("checkbox.height"), ";\n    transition: background ").concat(dt2("checkbox.transition.duration"), ", color ").concat(dt2("checkbox.transition.duration"), ", border-color ").concat(dt2("checkbox.transition.duration"), ", box-shadow ").concat(dt2("checkbox.transition.duration"), ", outline-color ").concat(dt2("checkbox.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt2("checkbox.shadow"), ";\n}\n\n.p-checkbox-icon {\n    transition-duration: ").concat(dt2("checkbox.transition.duration"), ";\n    color: ").concat(dt2("checkbox.icon.color"), ";\n    font-size: ").concat(dt2("checkbox.icon.size"), ";\n    width: ").concat(dt2("checkbox.icon.size"), ";\n    height: ").concat(dt2("checkbox.icon.size"), ";\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    border-color: ").concat(dt2("checkbox.hover.border.color"), ";\n}\n\n.p-checkbox-checked .p-checkbox-box {\n    border-color: ").concat(dt2("checkbox.checked.border.color"), ";\n    background: ").concat(dt2("checkbox.checked.background"), ";\n}\n\n.p-checkbox-checked .p-checkbox-icon {\n    color: ").concat(dt2("checkbox.icon.checked.color"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    background: ").concat(dt2("checkbox.checked.hover.background"), ";\n    border-color: ").concat(dt2("checkbox.checked.hover.border.color"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-icon {\n    color: ").concat(dt2("checkbox.icon.checked.hover.color"), ";\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n    border-color: ").concat(dt2("checkbox.focus.border.color"), ";\n    box-shadow: ").concat(dt2("checkbox.focus.ring.shadow"), ";\n    outline: ").concat(dt2("checkbox.focus.ring.width"), " ").concat(dt2("checkbox.focus.ring.style"), " ").concat(dt2("checkbox.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("checkbox.focus.ring.offset"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n    border-color: ").concat(dt2("checkbox.checked.focus.border.color"), ";\n}\n\n.p-checkbox.p-invalid > .p-checkbox-box {\n    border-color: ").concat(dt2("checkbox.invalid.border.color"), ";\n}\n\n.p-checkbox.p-variant-filled .p-checkbox-box {\n    background: ").concat(dt2("checkbox.filled.background"), ";\n}\n\n.p-checkbox-checked.p-variant-filled .p-checkbox-box {\n    background: ").concat(dt2("checkbox.checked.background"), ";\n}\n\n.p-checkbox-checked.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    background: ").concat(dt2("checkbox.checked.hover.background"), ";\n}\n\n.p-checkbox.p-disabled {\n    opacity: 1;\n}\n\n.p-checkbox.p-disabled .p-checkbox-box {\n    background: ").concat(dt2("checkbox.disabled.background"), ";\n    border-color: ").concat(dt2("checkbox.checked.disabled.border.color"), ";\n}\n\n.p-checkbox.p-disabled .p-checkbox-box .p-checkbox-icon {\n    color: ").concat(dt2("checkbox.icon.disabled.color"), ";\n}\n");
}, "theme");
var classes$b = {
  root: /* @__PURE__ */ __name(function root18(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-checkbox p-component", {
      "p-checkbox-checked": instance.checked,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled"
    }];
  }, "root"),
  box: "p-checkbox-box",
  input: "p-checkbox-input",
  icon: "p-checkbox-icon"
};
var CheckboxStyle = BaseStyle.extend({
  name: "checkbox",
  theme: theme$b,
  classes: classes$b
});
var script$1$b = {
  name: "BaseCheckbox",
  "extends": script$Y,
  props: {
    value: null,
    modelValue: null,
    binary: Boolean,
    name: {
      type: String,
      "default": null
    },
    indeterminate: {
      type: Boolean,
      "default": false
    },
    trueValue: {
      type: null,
      "default": true
    },
    falseValue: {
      type: null,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    required: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: CheckboxStyle,
  provide: /* @__PURE__ */ __name(function provide27() {
    return {
      $pcCheckbox: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$5(r) {
  return _arrayWithoutHoles$5(r) || _iterableToArray$5(r) || _unsupportedIterableToArray$8(r) || _nonIterableSpread$5();
}
__name(_toConsumableArray$5, "_toConsumableArray$5");
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$5, "_nonIterableSpread$5");
function _unsupportedIterableToArray$8(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$8(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$8(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$8, "_unsupportedIterableToArray$8");
function _iterableToArray$5(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$5, "_iterableToArray$5");
function _arrayWithoutHoles$5(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$8(r);
}
__name(_arrayWithoutHoles$5, "_arrayWithoutHoles$5");
function _arrayLikeToArray$8(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$8, "_arrayLikeToArray$8");
var script$j = {
  name: "Checkbox",
  "extends": script$1$b,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "update:indeterminate"],
  data: /* @__PURE__ */ __name(function data11() {
    return {
      d_indeterminate: this.indeterminate
    };
  }, "data"),
  watch: {
    indeterminate: /* @__PURE__ */ __name(function indeterminate2(newValue) {
      this.d_indeterminate = newValue;
    }, "indeterminate")
  },
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions5(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          checked: this.checked,
          indeterminate: this.d_indeterminate,
          disabled: this.disabled
        }
      });
    }, "getPTOptions"),
    onChange: /* @__PURE__ */ __name(function onChange2(event2) {
      var _this = this;
      if (!this.disabled && !this.readonly) {
        var newModelValue;
        if (this.binary) {
          newModelValue = this.d_indeterminate ? this.trueValue : this.checked ? this.falseValue : this.trueValue;
        } else {
          if (this.checked || this.d_indeterminate) newModelValue = this.modelValue.filter(function(val) {
            return !equals(val, _this.value);
          });
          else newModelValue = this.modelValue ? [].concat(_toConsumableArray$5(this.modelValue), [this.value]) : [this.value];
        }
        if (this.d_indeterminate) {
          this.d_indeterminate = false;
          this.$emit("update:indeterminate", this.d_indeterminate);
        }
        this.$emit("update:modelValue", newModelValue);
        this.$emit("change", event2);
      }
    }, "onChange"),
    onFocus: /* @__PURE__ */ __name(function onFocus4(event2) {
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur4(event2) {
      this.$emit("blur", event2);
    }, "onBlur")
  },
  computed: {
    checked: /* @__PURE__ */ __name(function checked2() {
      return this.d_indeterminate ? false : this.binary ? this.modelValue === this.trueValue : contains(this.value, this.modelValue);
    }, "checked")
  },
  components: {
    CheckIcon: script$V,
    MinusIcon: script$k
  }
};
var _hoisted_1$z = ["data-p-checked", "data-p-indeterminate", "data-p-disabled"];
var _hoisted_2$o = ["id", "value", "name", "checked", "tabindex", "disabled", "readonly", "required", "aria-labelledby", "aria-label", "aria-invalid", "aria-checked"];
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_MinusIcon = resolveComponent("MinusIcon");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.checked,
    "data-p-indeterminate": $data.d_indeterminate || void 0,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("input", mergeProps({
    id: _ctx.inputId,
    type: "checkbox",
    "class": [_ctx.cx("input"), _ctx.inputClass],
    style: _ctx.inputStyle,
    value: _ctx.value,
    name: _ctx.name,
    checked: $options.checked,
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    required: _ctx.required,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-invalid": _ctx.invalid || void 0,
    "aria-checked": $data.d_indeterminate ? "mixed" : void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("input")), null, 16, _hoisted_2$o), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("box")
  }, $options.getPTOptions("box")), [renderSlot(_ctx.$slots, "icon", {
    checked: $options.checked,
    indeterminate: $data.d_indeterminate,
    "class": normalizeClass(_ctx.cx("icon"))
  }, function() {
    return [$options.checked ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
      key: 0,
      "class": _ctx.cx("icon")
    }, $options.getPTOptions("icon")), null, 16, ["class"])) : $data.d_indeterminate ? (openBlock(), createBlock(_component_MinusIcon, mergeProps({
      key: 1,
      "class": _ctx.cx("icon")
    }, $options.getPTOptions("icon")), null, 16, ["class"])) : createCommentVNode("", true)];
  })], 16)], 16, _hoisted_1$z);
}
__name(render$i, "render$i");
script$j.render = render$i;
var script$2$2 = {
  name: "BaseTree",
  "extends": script$Y,
  props: {
    value: {
      type: null,
      "default": null
    },
    expandedKeys: {
      type: null,
      "default": null
    },
    selectionKeys: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    metaKeySelection: {
      type: Boolean,
      "default": false
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    loadingMode: {
      type: String,
      "default": "mask"
    },
    filter: {
      type: Boolean,
      "default": false
    },
    filterBy: {
      type: String,
      "default": "label"
    },
    filterMode: {
      type: String,
      "default": "lenient"
    },
    filterPlaceholder: {
      type: String,
      "default": null
    },
    filterLocale: {
      type: String,
      "default": void 0
    },
    highlightOnSelect: {
      type: Boolean,
      "default": false
    },
    scrollHeight: {
      type: String,
      "default": null
    },
    level: {
      type: Number,
      "default": 0
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: TreeStyle,
  provide: /* @__PURE__ */ __name(function provide28() {
    return {
      $pcTree: this,
      $parentInstance: this
    };
  }, "provide")
};
function _typeof$1$2(o) {
  "@babel/helpers - typeof";
  return _typeof$1$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$2(o);
}
__name(_typeof$1$2, "_typeof$1$2");
function _createForOfIteratorHelper$1$1(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$1$1(r)) || e) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$1$1, "_createForOfIteratorHelper$1$1");
function ownKeys$1$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$1$1, "ownKeys$1$1");
function _objectSpread$1$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1$1(Object(t), true).forEach(function(r2) {
      _defineProperty$1$2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$1$1, "_objectSpread$1$1");
function _defineProperty$1$2(e, r, t) {
  return (r = _toPropertyKey$1$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$1$2, "_defineProperty$1$2");
function _toPropertyKey$1$2(t) {
  var i2 = _toPrimitive$1$2(t, "string");
  return "symbol" == _typeof$1$2(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1$2, "_toPropertyKey$1$2");
function _toPrimitive$1$2(t, r) {
  if ("object" != _typeof$1$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$1$2, "_toPrimitive$1$2");
function _toConsumableArray$1$1(r) {
  return _arrayWithoutHoles$1$1(r) || _iterableToArray$1$1(r) || _unsupportedIterableToArray$1$1(r) || _nonIterableSpread$1$1();
}
__name(_toConsumableArray$1$1, "_toConsumableArray$1$1");
function _nonIterableSpread$1$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$1$1, "_nonIterableSpread$1$1");
function _unsupportedIterableToArray$1$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1$1(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$1$1, "_unsupportedIterableToArray$1$1");
function _iterableToArray$1$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$1$1, "_iterableToArray$1$1");
function _arrayWithoutHoles$1$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$1$1(r);
}
__name(_arrayWithoutHoles$1$1, "_arrayWithoutHoles$1$1");
function _arrayLikeToArray$1$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$1$1, "_arrayLikeToArray$1$1");
var script$1$a = {
  name: "TreeNode",
  hostName: "Tree",
  "extends": script$Y,
  emits: ["node-toggle", "node-click", "checkbox-change"],
  props: {
    node: {
      type: null,
      "default": null
    },
    expandedKeys: {
      type: null,
      "default": null
    },
    loadingMode: {
      type: String,
      "default": "mask"
    },
    selectionKeys: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    templates: {
      type: null,
      "default": null
    },
    level: {
      type: Number,
      "default": null
    },
    index: null
  },
  nodeTouched: false,
  toggleClicked: false,
  mounted: /* @__PURE__ */ __name(function mounted10() {
    this.setAllNodesTabIndexes();
  }, "mounted"),
  methods: {
    toggle: /* @__PURE__ */ __name(function toggle() {
      this.$emit("node-toggle", this.node);
      this.toggleClicked = true;
    }, "toggle"),
    label: /* @__PURE__ */ __name(function label3(node3) {
      return typeof node3.label === "function" ? node3.label() : node3.label;
    }, "label"),
    onChildNodeToggle: /* @__PURE__ */ __name(function onChildNodeToggle(node3) {
      this.$emit("node-toggle", node3);
    }, "onChildNodeToggle"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions6(key) {
      return this.ptm(key, {
        context: {
          index: this.index,
          expanded: this.expanded,
          selected: this.selected,
          checked: this.checked,
          leaf: this.leaf
        }
      });
    }, "getPTOptions"),
    onClick: /* @__PURE__ */ __name(function onClick(event2) {
      if (this.toggleClicked || getAttribute(event2.target, '[data-pc-section="nodetogglebutton"]') || getAttribute(event2.target.parentElement, '[data-pc-section="nodetogglebutton"]')) {
        this.toggleClicked = false;
        return;
      }
      if (this.isCheckboxSelectionMode()) {
        if (this.node.selectable != false) {
          this.toggleCheckbox();
        }
      } else {
        this.$emit("node-click", {
          originalEvent: event2,
          nodeTouched: this.nodeTouched,
          node: this.node
        });
      }
      this.nodeTouched = false;
    }, "onClick"),
    onChildNodeClick: /* @__PURE__ */ __name(function onChildNodeClick(event2) {
      this.$emit("node-click", event2);
    }, "onChildNodeClick"),
    onTouchEnd: /* @__PURE__ */ __name(function onTouchEnd() {
      this.nodeTouched = true;
    }, "onTouchEnd"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown5(event2) {
      if (!this.isSameNode(event2)) return;
      switch (event2.code) {
        case "Tab":
          this.onTabKey(event2);
          break;
        case "ArrowDown":
          this.onArrowDown(event2);
          break;
        case "ArrowUp":
          this.onArrowUp(event2);
          break;
        case "ArrowRight":
          this.onArrowRight(event2);
          break;
        case "ArrowLeft":
          this.onArrowLeft(event2);
          break;
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.onEnterKey(event2);
          break;
      }
    }, "onKeyDown"),
    onArrowDown: /* @__PURE__ */ __name(function onArrowDown(event2) {
      var nodeElement = event2.target.getAttribute("data-pc-section") === "nodetogglebutton" ? event2.target.closest('[role="treeitem"]') : event2.target;
      var listElement = nodeElement.children[1];
      if (listElement) {
        this.focusRowChange(nodeElement, listElement.children[0]);
      } else {
        if (nodeElement.nextElementSibling) {
          this.focusRowChange(nodeElement, nodeElement.nextElementSibling);
        } else {
          var nextSiblingAncestor = this.findNextSiblingOfAncestor(nodeElement);
          if (nextSiblingAncestor) {
            this.focusRowChange(nodeElement, nextSiblingAncestor);
          }
        }
      }
      event2.preventDefault();
    }, "onArrowDown"),
    onArrowUp: /* @__PURE__ */ __name(function onArrowUp(event2) {
      var nodeElement = event2.target;
      if (nodeElement.previousElementSibling) {
        this.focusRowChange(nodeElement, nodeElement.previousElementSibling, this.findLastVisibleDescendant(nodeElement.previousElementSibling));
      } else {
        var parentNodeElement = this.getParentNodeElement(nodeElement);
        if (parentNodeElement) {
          this.focusRowChange(nodeElement, parentNodeElement);
        }
      }
      event2.preventDefault();
    }, "onArrowUp"),
    onArrowRight: /* @__PURE__ */ __name(function onArrowRight(event2) {
      var _this = this;
      if (this.leaf || this.expanded) return;
      event2.currentTarget.tabIndex = -1;
      this.$emit("node-toggle", this.node);
      this.$nextTick(function() {
        _this.onArrowDown(event2);
      });
    }, "onArrowRight"),
    onArrowLeft: /* @__PURE__ */ __name(function onArrowLeft(event2) {
      var togglerElement = findSingle(event2.currentTarget, '[data-pc-section="nodetogglebutton"]');
      if (this.level === 0 && !this.expanded) {
        return false;
      }
      if (this.expanded && !this.leaf) {
        togglerElement.click();
        return false;
      }
      var target = this.findBeforeClickableNode(event2.currentTarget);
      if (target) {
        this.focusRowChange(event2.currentTarget, target);
      }
    }, "onArrowLeft"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey3(event2) {
      this.setTabIndexForSelectionMode(event2, this.nodeTouched);
      this.onClick(event2);
      event2.preventDefault();
    }, "onEnterKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey2() {
      this.setAllNodesTabIndexes();
    }, "onTabKey"),
    setAllNodesTabIndexes: /* @__PURE__ */ __name(function setAllNodesTabIndexes() {
      var nodes = find(this.$refs.currentNode.closest('[data-pc-section="rootchildren"]'), '[role="treeitem"]');
      var hasSelectedNode = _toConsumableArray$1$1(nodes).some(function(node3) {
        return node3.getAttribute("aria-selected") === "true" || node3.getAttribute("aria-checked") === "true";
      });
      _toConsumableArray$1$1(nodes).forEach(function(node3) {
        node3.tabIndex = -1;
      });
      if (hasSelectedNode) {
        var selectedNodes = _toConsumableArray$1$1(nodes).filter(function(node3) {
          return node3.getAttribute("aria-selected") === "true" || node3.getAttribute("aria-checked") === "true";
        });
        selectedNodes[0].tabIndex = 0;
        return;
      }
      _toConsumableArray$1$1(nodes)[0].tabIndex = 0;
    }, "setAllNodesTabIndexes"),
    setTabIndexForSelectionMode: /* @__PURE__ */ __name(function setTabIndexForSelectionMode(event2, nodeTouched) {
      if (this.selectionMode !== null) {
        var elements = _toConsumableArray$1$1(find(this.$refs.currentNode.parentElement, '[role="treeitem"]'));
        event2.currentTarget.tabIndex = nodeTouched === false ? -1 : 0;
        if (elements.every(function(element) {
          return element.tabIndex === -1;
        })) {
          elements[0].tabIndex = 0;
        }
      }
    }, "setTabIndexForSelectionMode"),
    focusRowChange: /* @__PURE__ */ __name(function focusRowChange(firstFocusableRow, currentFocusedRow, lastVisibleDescendant) {
      firstFocusableRow.tabIndex = "-1";
      currentFocusedRow.tabIndex = "0";
      this.focusNode(lastVisibleDescendant || currentFocusedRow);
    }, "focusRowChange"),
    findBeforeClickableNode: /* @__PURE__ */ __name(function findBeforeClickableNode(node3) {
      var parentListElement = node3.closest("ul").closest("li");
      if (parentListElement) {
        var prevNodeButton = findSingle(parentListElement, "button");
        if (prevNodeButton && prevNodeButton.style.visibility !== "hidden") {
          return parentListElement;
        }
        return this.findBeforeClickableNode(node3.previousElementSibling);
      }
      return null;
    }, "findBeforeClickableNode"),
    toggleCheckbox: /* @__PURE__ */ __name(function toggleCheckbox() {
      var _selectionKeys = this.selectionKeys ? _objectSpread$1$1({}, this.selectionKeys) : {};
      var _check = !this.checked;
      this.propagateDown(this.node, _check, _selectionKeys);
      this.$emit("checkbox-change", {
        node: this.node,
        check: _check,
        selectionKeys: _selectionKeys
      });
    }, "toggleCheckbox"),
    propagateDown: /* @__PURE__ */ __name(function propagateDown(node3, check, selectionKeys) {
      if (check && node3.selectable != false) selectionKeys[node3.key] = {
        checked: true,
        partialChecked: false
      };
      else delete selectionKeys[node3.key];
      if (node3.children && node3.children.length) {
        var _iterator = _createForOfIteratorHelper$1$1(node3.children), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var child = _step.value;
            this.propagateDown(child, check, selectionKeys);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, "propagateDown"),
    propagateUp: /* @__PURE__ */ __name(function propagateUp(event2) {
      var check = event2.check;
      var _selectionKeys = _objectSpread$1$1({}, event2.selectionKeys);
      var checkedChildCount = 0;
      var childPartialSelected = false;
      var _iterator2 = _createForOfIteratorHelper$1$1(this.node.children), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var child = _step2.value;
          if (_selectionKeys[child.key] && _selectionKeys[child.key].checked) checkedChildCount++;
          else if (_selectionKeys[child.key] && _selectionKeys[child.key].partialChecked) childPartialSelected = true;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (check && checkedChildCount === this.node.children.length) {
        _selectionKeys[this.node.key] = {
          checked: true,
          partialChecked: false
        };
      } else {
        if (!check) {
          delete _selectionKeys[this.node.key];
        }
        if (childPartialSelected || checkedChildCount > 0 && checkedChildCount !== this.node.children.length) _selectionKeys[this.node.key] = {
          checked: false,
          partialChecked: true
        };
        else delete _selectionKeys[this.node.key];
      }
      this.$emit("checkbox-change", {
        node: event2.node,
        check: event2.check,
        selectionKeys: _selectionKeys
      });
    }, "propagateUp"),
    onChildCheckboxChange: /* @__PURE__ */ __name(function onChildCheckboxChange(event2) {
      this.$emit("checkbox-change", event2);
    }, "onChildCheckboxChange"),
    findNextSiblingOfAncestor: /* @__PURE__ */ __name(function findNextSiblingOfAncestor(nodeElement) {
      var parentNodeElement = this.getParentNodeElement(nodeElement);
      if (parentNodeElement) {
        if (parentNodeElement.nextElementSibling) return parentNodeElement.nextElementSibling;
        else return this.findNextSiblingOfAncestor(parentNodeElement);
      } else {
        return null;
      }
    }, "findNextSiblingOfAncestor"),
    findLastVisibleDescendant: /* @__PURE__ */ __name(function findLastVisibleDescendant(nodeElement) {
      var childrenListElement = nodeElement.children[1];
      if (childrenListElement) {
        var lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];
        return this.findLastVisibleDescendant(lastChildElement);
      } else {
        return nodeElement;
      }
    }, "findLastVisibleDescendant"),
    getParentNodeElement: /* @__PURE__ */ __name(function getParentNodeElement(nodeElement) {
      var parentNodeElement = nodeElement.parentElement.parentElement;
      return getAttribute(parentNodeElement, "role") === "treeitem" ? parentNodeElement : null;
    }, "getParentNodeElement"),
    focusNode: /* @__PURE__ */ __name(function focusNode(element) {
      element.focus();
    }, "focusNode"),
    isCheckboxSelectionMode: /* @__PURE__ */ __name(function isCheckboxSelectionMode() {
      return this.selectionMode === "checkbox";
    }, "isCheckboxSelectionMode"),
    isSameNode: /* @__PURE__ */ __name(function isSameNode(event2) {
      return event2.currentTarget && (event2.currentTarget.isSameNode(event2.target) || event2.currentTarget.isSameNode(event2.target.closest('[role="treeitem"]')));
    }, "isSameNode")
  },
  computed: {
    hasChildren: /* @__PURE__ */ __name(function hasChildren() {
      return this.node.children && this.node.children.length > 0;
    }, "hasChildren"),
    expanded: /* @__PURE__ */ __name(function expanded() {
      return this.expandedKeys && this.expandedKeys[this.node.key] === true;
    }, "expanded"),
    leaf: /* @__PURE__ */ __name(function leaf() {
      return this.node.leaf === false ? false : !(this.node.children && this.node.children.length);
    }, "leaf"),
    selectable: /* @__PURE__ */ __name(function selectable() {
      return this.node.selectable === false ? false : this.selectionMode != null;
    }, "selectable"),
    selected: /* @__PURE__ */ __name(function selected() {
      return this.selectionMode && this.selectionKeys ? this.selectionKeys[this.node.key] === true : false;
    }, "selected"),
    checkboxMode: /* @__PURE__ */ __name(function checkboxMode() {
      return this.selectionMode === "checkbox" && this.node.selectable !== false;
    }, "checkboxMode"),
    checked: /* @__PURE__ */ __name(function checked3() {
      return this.selectionKeys ? this.selectionKeys[this.node.key] && this.selectionKeys[this.node.key].checked : false;
    }, "checked"),
    partialChecked: /* @__PURE__ */ __name(function partialChecked() {
      return this.selectionKeys ? this.selectionKeys[this.node.key] && this.selectionKeys[this.node.key].partialChecked : false;
    }, "partialChecked"),
    ariaChecked: /* @__PURE__ */ __name(function ariaChecked() {
      return this.selectionMode === "single" || this.selectionMode === "multiple" ? this.selected : void 0;
    }, "ariaChecked"),
    ariaSelected: /* @__PURE__ */ __name(function ariaSelected() {
      return this.checkboxMode ? this.checked : void 0;
    }, "ariaSelected")
  },
  components: {
    Checkbox: script$j,
    ChevronDownIcon: script$B,
    ChevronRightIcon: script$q,
    CheckIcon: script$V,
    MinusIcon: script$k,
    SpinnerIcon: script$Q
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$1$2 = ["aria-label", "aria-selected", "aria-expanded", "aria-setsize", "aria-posinset", "aria-level", "aria-checked", "tabindex"];
var _hoisted_2$n = ["data-p-selected", "data-p-selectable"];
function render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_Checkbox = resolveComponent("Checkbox");
  var _component_TreeNode = resolveComponent("TreeNode", true);
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("li", mergeProps({
    ref: "currentNode",
    "class": _ctx.cx("node"),
    role: "treeitem",
    "aria-label": $options.label($props.node),
    "aria-selected": $options.ariaSelected,
    "aria-expanded": $options.expanded,
    "aria-setsize": $props.node.children ? $props.node.children.length : 0,
    "aria-posinset": $props.index + 1,
    "aria-level": $props.level,
    "aria-checked": $options.ariaChecked,
    tabindex: $props.index === 0 ? 0 : -1,
    onKeydown: _cache[4] || (_cache[4] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    })
  }, $props.level === 1 ? $options.getPTOptions("node") : _ctx.ptm("nodeChildren")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("nodeContent"),
    onClick: _cache[2] || (_cache[2] = function() {
      return $options.onClick && $options.onClick.apply($options, arguments);
    }),
    onTouchend: _cache[3] || (_cache[3] = function() {
      return $options.onTouchEnd && $options.onTouchEnd.apply($options, arguments);
    }),
    style: $props.node.style
  }, $options.getPTOptions("nodeContent"), {
    "data-p-selected": $options.checkboxMode ? $options.checked : $options.selected,
    "data-p-selectable": $options.selectable
  }), [withDirectives((openBlock(), createElementBlock("button", mergeProps({
    type: "button",
    "class": _ctx.cx("nodeToggleButton"),
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.toggle && $options.toggle.apply($options, arguments);
    }),
    tabindex: "-1"
  }, $options.getPTOptions("nodeToggleButton")), [$props.node.loading && $props.loadingMode === "icon" ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [$props.templates["nodetoggleicon"] || $props.templates["nodetogglericon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodetoggleicon"] || $props.templates["nodetogglericon"]), {
    key: 0,
    "class": normalizeClass(_ctx.cx("nodeToggleIcon"))
  }, null, 8, ["class"])) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
    key: 1,
    spin: "",
    "class": _ctx.cx("nodetogglericon")
  }, _ctx.ptm("nodeToggleIcon")), null, 16, ["class"]))], 64)) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [$props.templates["nodetoggleicon"] || $props.templates["togglericon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodetoggleicon"] || $props.templates["togglericon"]), {
    key: 0,
    node: $props.node,
    expanded: $options.expanded,
    "class": normalizeClass(_ctx.cx("nodeToggleIcon"))
  }, null, 8, ["node", "expanded", "class"])) : $options.expanded ? (openBlock(), createBlock(resolveDynamicComponent($props.node.expandedIcon ? "span" : "ChevronDownIcon"), mergeProps({
    key: 1,
    "class": _ctx.cx("nodeToggleIcon")
  }, $options.getPTOptions("nodeToggleIcon")), null, 16, ["class"])) : (openBlock(), createBlock(resolveDynamicComponent($props.node.collapsedIcon ? "span" : "ChevronRightIcon"), mergeProps({
    key: 2,
    "class": _ctx.cx("nodeToggleIcon")
  }, $options.getPTOptions("nodeToggleIcon")), null, 16, ["class"]))], 64))], 16)), [[_directive_ripple]]), $options.checkboxMode ? (openBlock(), createBlock(_component_Checkbox, {
    key: 0,
    modelValue: $options.checked,
    binary: true,
    indeterminate: $options.partialChecked,
    "class": normalizeClass(_ctx.cx("nodeCheckbox")),
    tabindex: -1,
    unstyled: _ctx.unstyled,
    pt: $options.getPTOptions("nodeCheckbox"),
    "data-p-partialchecked": $options.partialChecked
  }, {
    icon: withCtx(function(slotProps) {
      return [$props.templates["checkboxicon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["checkboxicon"]), {
        key: 0,
        checked: slotProps.checked,
        partialChecked: $options.partialChecked,
        "class": normalizeClass(slotProps["class"])
      }, null, 8, ["checked", "partialChecked", "class"])) : createCommentVNode("", true)];
    }),
    _: 1
  }, 8, ["modelValue", "indeterminate", "class", "unstyled", "pt", "data-p-partialchecked"])) : createCommentVNode("", true), $props.templates["nodeicon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodeicon"]), mergeProps({
    key: 1,
    node: $props.node,
    "class": [_ctx.cx("nodeIcon")]
  }, $options.getPTOptions("nodeIcon")), null, 16, ["node", "class"])) : (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    "class": [_ctx.cx("nodeIcon"), $props.node.icon]
  }, $options.getPTOptions("nodeIcon")), null, 16)), createBaseVNode("span", mergeProps({
    "class": _ctx.cx("nodeLabel")
  }, $options.getPTOptions("nodeLabel"), {
    onKeydown: _cache[1] || (_cache[1] = withModifiers(function() {
    }, ["stop"]))
  }), [$props.templates[$props.node.type] || $props.templates["default"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates[$props.node.type] || $props.templates["default"]), {
    key: 0,
    node: $props.node,
    selected: $options.checkboxMode ? $options.checked : $options.selected
  }, null, 8, ["node", "selected"])) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [createTextVNode(toDisplayString$1($options.label($props.node)), 1)], 64))], 16)], 16, _hoisted_2$n), $options.hasChildren && $options.expanded ? (openBlock(), createElementBlock("ul", mergeProps({
    key: 0,
    "class": _ctx.cx("nodeChildren"),
    role: "group"
  }, _ctx.ptm("nodeChildren")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.node.children, function(childNode) {
    return openBlock(), createBlock(_component_TreeNode, {
      key: childNode.key,
      node: childNode,
      templates: $props.templates,
      level: $props.level + 1,
      loadingMode: $props.loadingMode,
      expandedKeys: $props.expandedKeys,
      onNodeToggle: $options.onChildNodeToggle,
      onNodeClick: $options.onChildNodeClick,
      selectionMode: $props.selectionMode,
      selectionKeys: $props.selectionKeys,
      onCheckboxChange: $options.propagateUp,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["node", "templates", "level", "loadingMode", "expandedKeys", "onNodeToggle", "onNodeClick", "selectionMode", "selectionKeys", "onCheckboxChange", "unstyled", "pt"]);
  }), 128))], 16)) : createCommentVNode("", true)], 16, _hoisted_1$1$2);
}
__name(render$1$2, "render$1$2");
script$1$a.render = render$1$2;
function _typeof$7(o) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$7(o);
}
__name(_typeof$7, "_typeof$7");
function _createForOfIteratorHelper$3(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$7(r)) || e) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$3, "_createForOfIteratorHelper$3");
function _toConsumableArray$4(r) {
  return _arrayWithoutHoles$4(r) || _iterableToArray$4(r) || _unsupportedIterableToArray$7(r) || _nonIterableSpread$4();
}
__name(_toConsumableArray$4, "_toConsumableArray$4");
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$4, "_nonIterableSpread$4");
function _unsupportedIterableToArray$7(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$7(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$7(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$7, "_unsupportedIterableToArray$7");
function _iterableToArray$4(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$4, "_iterableToArray$4");
function _arrayWithoutHoles$4(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$7(r);
}
__name(_arrayWithoutHoles$4, "_arrayWithoutHoles$4");
function _arrayLikeToArray$7(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$7, "_arrayLikeToArray$7");
function ownKeys$9(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$9, "ownKeys$9");
function _objectSpread$9(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$9(Object(t), true).forEach(function(r2) {
      _defineProperty$7(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$9, "_objectSpread$9");
function _defineProperty$7(e, r, t) {
  return (r = _toPropertyKey$6(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$7, "_defineProperty$7");
function _toPropertyKey$6(t) {
  var i2 = _toPrimitive$6(t, "string");
  return "symbol" == _typeof$7(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$6, "_toPropertyKey$6");
function _toPrimitive$6(t, r) {
  if ("object" != _typeof$7(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$7(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$6, "_toPrimitive$6");
var script$i = {
  name: "Tree",
  "extends": script$2$2,
  inheritAttrs: false,
  emits: ["node-expand", "node-collapse", "update:expandedKeys", "update:selectionKeys", "node-select", "node-unselect", "filter"],
  data: /* @__PURE__ */ __name(function data12() {
    return {
      d_expandedKeys: this.expandedKeys || {},
      filterValue: null
    };
  }, "data"),
  watch: {
    expandedKeys: /* @__PURE__ */ __name(function expandedKeys(newValue) {
      this.d_expandedKeys = newValue;
    }, "expandedKeys")
  },
  methods: {
    onNodeToggle: /* @__PURE__ */ __name(function onNodeToggle(node3) {
      var key = node3.key;
      if (this.d_expandedKeys[key]) {
        delete this.d_expandedKeys[key];
        this.$emit("node-collapse", node3);
      } else {
        this.d_expandedKeys[key] = true;
        this.$emit("node-expand", node3);
      }
      this.d_expandedKeys = _objectSpread$9({}, this.d_expandedKeys);
      this.$emit("update:expandedKeys", this.d_expandedKeys);
    }, "onNodeToggle"),
    onNodeClick: /* @__PURE__ */ __name(function onNodeClick(event2) {
      if (this.selectionMode != null && event2.node.selectable !== false) {
        var metaSelection = event2.nodeTouched ? false : this.metaKeySelection;
        var _selectionKeys = metaSelection ? this.handleSelectionWithMetaKey(event2) : this.handleSelectionWithoutMetaKey(event2);
        this.$emit("update:selectionKeys", _selectionKeys);
      }
    }, "onNodeClick"),
    onCheckboxChange: /* @__PURE__ */ __name(function onCheckboxChange(event2) {
      this.$emit("update:selectionKeys", event2.selectionKeys);
      if (event2.check) this.$emit("node-select", event2.node);
      else this.$emit("node-unselect", event2.node);
    }, "onCheckboxChange"),
    handleSelectionWithMetaKey: /* @__PURE__ */ __name(function handleSelectionWithMetaKey(event2) {
      var originalEvent = event2.originalEvent;
      var node3 = event2.node;
      var metaKey = originalEvent.metaKey || originalEvent.ctrlKey;
      var selected2 = this.isNodeSelected(node3);
      var _selectionKeys;
      if (selected2 && metaKey) {
        if (this.isSingleSelectionMode()) {
          _selectionKeys = {};
        } else {
          _selectionKeys = _objectSpread$9({}, this.selectionKeys);
          delete _selectionKeys[node3.key];
        }
        this.$emit("node-unselect", node3);
      } else {
        if (this.isSingleSelectionMode()) {
          _selectionKeys = {};
        } else if (this.isMultipleSelectionMode()) {
          _selectionKeys = !metaKey ? {} : this.selectionKeys ? _objectSpread$9({}, this.selectionKeys) : {};
        }
        _selectionKeys[node3.key] = true;
        this.$emit("node-select", node3);
      }
      return _selectionKeys;
    }, "handleSelectionWithMetaKey"),
    handleSelectionWithoutMetaKey: /* @__PURE__ */ __name(function handleSelectionWithoutMetaKey(event2) {
      var node3 = event2.node;
      var selected2 = this.isNodeSelected(node3);
      var _selectionKeys;
      if (this.isSingleSelectionMode()) {
        if (selected2) {
          _selectionKeys = {};
          this.$emit("node-unselect", node3);
        } else {
          _selectionKeys = {};
          _selectionKeys[node3.key] = true;
          this.$emit("node-select", node3);
        }
      } else {
        if (selected2) {
          _selectionKeys = _objectSpread$9({}, this.selectionKeys);
          delete _selectionKeys[node3.key];
          this.$emit("node-unselect", node3);
        } else {
          _selectionKeys = this.selectionKeys ? _objectSpread$9({}, this.selectionKeys) : {};
          _selectionKeys[node3.key] = true;
          this.$emit("node-select", node3);
        }
      }
      return _selectionKeys;
    }, "handleSelectionWithoutMetaKey"),
    isSingleSelectionMode: /* @__PURE__ */ __name(function isSingleSelectionMode() {
      return this.selectionMode === "single";
    }, "isSingleSelectionMode"),
    isMultipleSelectionMode: /* @__PURE__ */ __name(function isMultipleSelectionMode() {
      return this.selectionMode === "multiple";
    }, "isMultipleSelectionMode"),
    isNodeSelected: /* @__PURE__ */ __name(function isNodeSelected(node3) {
      return this.selectionMode && this.selectionKeys ? this.selectionKeys[node3.key] === true : false;
    }, "isNodeSelected"),
    isChecked: /* @__PURE__ */ __name(function isChecked(node3) {
      return this.selectionKeys ? this.selectionKeys[node3.key] && this.selectionKeys[node3.key].checked : false;
    }, "isChecked"),
    isNodeLeaf: /* @__PURE__ */ __name(function isNodeLeaf(node3) {
      return node3.leaf === false ? false : !(node3.children && node3.children.length);
    }, "isNodeLeaf"),
    onFilterKeydown: /* @__PURE__ */ __name(function onFilterKeydown(event2) {
      if (event2.code === "Enter" || event2.code === "NumpadEnter") {
        event2.preventDefault();
      }
      this.$emit("filter", {
        originalEvent: event2,
        value: event2.target.value
      });
    }, "onFilterKeydown"),
    findFilteredNodes: /* @__PURE__ */ __name(function findFilteredNodes(node3, paramsWithoutNode) {
      if (node3) {
        var matched = false;
        if (node3.children) {
          var childNodes = _toConsumableArray$4(node3.children);
          node3.children = [];
          var _iterator = _createForOfIteratorHelper$3(childNodes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var childNode = _step.value;
              var copyChildNode = _objectSpread$9({}, childNode);
              if (this.isFilterMatched(copyChildNode, paramsWithoutNode)) {
                matched = true;
                node3.children.push(copyChildNode);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        if (matched) {
          return true;
        }
      }
    }, "findFilteredNodes"),
    isFilterMatched: /* @__PURE__ */ __name(function isFilterMatched(node3, _ref) {
      var searchFields3 = _ref.searchFields, filterText = _ref.filterText, strict = _ref.strict;
      var matched = false;
      var _iterator2 = _createForOfIteratorHelper$3(searchFields3), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var field = _step2.value;
          var fieldValue = String(resolveFieldData(node3, field)).toLocaleLowerCase(this.filterLocale);
          if (fieldValue.indexOf(filterText) > -1) {
            matched = true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (!matched || strict && !this.isNodeLeaf(node3)) {
        matched = this.findFilteredNodes(node3, {
          searchFields: searchFields3,
          filterText,
          strict
        }) || matched;
      }
      return matched;
    }, "isFilterMatched")
  },
  computed: {
    filteredValue: /* @__PURE__ */ __name(function filteredValue() {
      var filteredNodes = [];
      var searchFields3 = this.filterBy.split(",");
      var filterText = this.filterValue.trim().toLocaleLowerCase(this.filterLocale);
      var strict = this.filterMode === "strict";
      var _iterator3 = _createForOfIteratorHelper$3(this.value), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var node3 = _step3.value;
          var _node = _objectSpread$9({}, node3);
          var paramsWithoutNode = {
            searchFields: searchFields3,
            filterText,
            strict
          };
          if (strict && (this.findFilteredNodes(_node, paramsWithoutNode) || this.isFilterMatched(_node, paramsWithoutNode)) || !strict && (this.isFilterMatched(_node, paramsWithoutNode) || this.findFilteredNodes(_node, paramsWithoutNode))) {
            filteredNodes.push(_node);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return filteredNodes;
    }, "filteredValue"),
    valueToRender: /* @__PURE__ */ __name(function valueToRender() {
      if (this.filterValue && this.filterValue.trim().length > 0) return this.filteredValue;
      else return this.value;
    }, "valueToRender")
  },
  components: {
    TreeNode: script$1$a,
    InputText: script$R,
    InputIcon: script$S,
    IconField: script$T,
    SearchIcon: script$U,
    SpinnerIcon: script$Q
  }
};
var _hoisted_1$y = ["aria-labelledby", "aria-label"];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_TreeNode = resolveComponent("TreeNode");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.loading && _ctx.loadingMode === "mask" ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("mask")
  }, _ctx.ptm("mask")), [renderSlot(_ctx.$slots, "loadingicon", {
    "class": normalizeClass(_ctx.cx("loadingIcon"))
  }, function() {
    return [_ctx.loadingIcon ? (openBlock(), createElementBlock("i", mergeProps({
      key: 0,
      "class": [_ctx.cx("loadingIcon"), "pi-spin", _ctx.loadingIcon]
    }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
      key: 1,
      spin: "",
      "class": _ctx.cx("loadingIcon")
    }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
  })], 16)) : createCommentVNode("", true), _ctx.filter ? (openBlock(), createBlock(_component_IconField, {
    key: 1,
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcFilterContainer")
  }, {
    "default": withCtx(function() {
      return [createVNode(_component_InputText, {
        modelValue: $data.filterValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function($event) {
          return $data.filterValue = $event;
        }),
        autocomplete: "off",
        "class": normalizeClass(_ctx.cx("pcFilter")),
        placeholder: _ctx.filterPlaceholder,
        unstyled: _ctx.unstyled,
        onKeydown: $options.onFilterKeydown,
        pt: _ctx.ptm("pcFilter")
      }, null, 8, ["modelValue", "class", "placeholder", "unstyled", "onKeydown", "pt"]), createVNode(_component_InputIcon, {
        unstyled: _ctx.unstyled,
        pt: _ctx.ptm("pcFilterIconContainer")
      }, {
        "default": withCtx(function() {
          return [renderSlot(_ctx.$slots, _ctx.$slots.filtericon ? "filtericon" : "searchicon", {
            "class": normalizeClass(_ctx.cx("filterIcon"))
          }, function() {
            return [createVNode(_component_SearchIcon, mergeProps({
              "class": _ctx.cx("filterIcon")
            }, _ctx.ptm("filterIcon")), null, 16, ["class"])];
          })];
        }),
        _: 3
      }, 8, ["unstyled", "pt"])];
    }),
    _: 3
  }, 8, ["unstyled", "pt"])) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("wrapper"),
    style: {
      maxHeight: _ctx.scrollHeight
    }
  }, _ctx.ptm("wrapper")), [createBaseVNode("ul", mergeProps({
    "class": _ctx.cx("rootChildren"),
    role: "tree",
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel
  }, _ctx.ptm("rootChildren")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.valueToRender, function(node3, index2) {
    return openBlock(), createBlock(_component_TreeNode, {
      key: node3.key,
      node: node3,
      templates: _ctx.$slots,
      level: _ctx.level + 1,
      index: index2,
      expandedKeys: $data.d_expandedKeys,
      onNodeToggle: $options.onNodeToggle,
      onNodeClick: $options.onNodeClick,
      selectionMode: _ctx.selectionMode,
      selectionKeys: _ctx.selectionKeys,
      onCheckboxChange: $options.onCheckboxChange,
      loadingMode: _ctx.loadingMode,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["node", "templates", "level", "index", "expandedKeys", "onNodeToggle", "onNodeClick", "selectionMode", "selectionKeys", "onCheckboxChange", "loadingMode", "unstyled", "pt"]);
  }), 128))], 16, _hoisted_1$y)], 16)], 16);
}
__name(render$h, "render$h");
script$i.render = render$h;
var theme$a = /* @__PURE__ */ __name(function theme27(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-contextmenu {\n    background: ".concat(dt2("contextmenu.background"), ";\n    color: ").concat(dt2("contextmenu.color"), ";\n    border: 1px solid ").concat(dt2("contextmenu.border.color"), ";\n    border-radius: ").concat(dt2("contextmenu.border.radius"), ";\n    box-shadow: ").concat(dt2("contextmenu.shadow"), ";\n    min-width: 12.5rem;\n}\n\n.p-contextmenu-root-list,\n.p-contextmenu-submenu {\n    margin: 0;\n    padding: ").concat(dt2("contextmenu.list.padding"), ";\n    list-style: none;\n    outline: 0 none;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt2("contextmenu.list.gap"), ";\n}\n\n.p-contextmenu-submenu {\n    position: absolute;\n    display: flex;\n    flex-direction: column;\n    min-width: 100%;\n    z-index: 1;\n    background: ").concat(dt2("contextmenu.background"), ";\n    color: ").concat(dt2("contextmenu.color"), ";\n    border: 1px solid ").concat(dt2("contextmenu.border.color"), ";\n    border-radius: ").concat(dt2("contextmenu.border.radius"), ";\n    box-shadow: ").concat(dt2("contextmenu.shadow"), ";\n}\n\n.p-contextmenu-item {\n    position: relative;\n}\n\n.p-contextmenu-item-content {\n    transition: background ").concat(dt2("contextmenu.transition.duration"), ", color ").concat(dt2("contextmenu.transition.duration"), ";\n    border-radius: ").concat(dt2("contextmenu.item.border.radius"), ";\n    color: ").concat(dt2("contextmenu.item.color"), ";\n}\n\n.p-contextmenu-item-link {\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    text-decoration: none;\n    overflow: hidden;\n    position: relative;\n    color: inherit;\n    padding: ").concat(dt2("contextmenu.item.padding"), ";\n    gap: ").concat(dt2("contextmenu.item.gap"), ";\n    user-select: none;\n}\n\n.p-contextmenu-item-label {\n    line-height: 1;\n}\n\n.p-contextmenu-item-icon {\n    color: ").concat(dt2("contextmenu.item.icon.color"), ";\n}\n\n.p-contextmenu-submenu-icon {\n    color: ").concat(dt2("contextmenu.submenu.icon.color"), ";\n    margin-left: auto;\n    font-size: ").concat(dt2("contextmenu.submenu.icon.size"), ";\n    width: ").concat(dt2("contextmenu.submenu.icon.size"), ";\n    height: ").concat(dt2("contextmenu.submenu.icon.size"), ";\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content {\n    color: ").concat(dt2("contextmenu.item.focus.color"), ";\n    background: ").concat(dt2("contextmenu.item.focus.background"), ";\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content .p-contextmenu-item-icon {\n    color: ").concat(dt2("contextmenu.item.icon.focus.color"), ";\n}\n\n.p-contextmenu-item.p-focus > .p-contextmenu-item-content .p-contextmenu-submenu-icon {\n    color: ").concat(dt2("contextmenu.submenu.icon.focus.color"), ";\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover {\n    color: ").concat(dt2("contextmenu.item.focus.color"), ";\n    background: ").concat(dt2("contextmenu.item.focus.background"), ";\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover .p-contextmenu-item-icon {\n    color: ").concat(dt2("contextmenu.item.icon.focus.color"), ";\n}\n\n.p-contextmenu-item:not(.p-disabled) > .p-contextmenu-item-content:hover .p-contextmenu-submenu-icon {\n    color: ").concat(dt2("contextmenu.submenu.icon.focus.color"), ";\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content {\n    color: ").concat(dt2("contextmenu.item.active.color"), ";\n    background: ").concat(dt2("contextmenu.item.active.background"), ";\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content .p-contextmenu-item-icon {\n    color: ").concat(dt2("contextmenu.item.icon.active.color"), ";\n}\n\n.p-contextmenu-item-active > .p-contextmenu-item-content .p-contextmenu-submenu-icon {\n    color: ").concat(dt2("contextmenu.submenu.icon.active.color"), ";\n}\n\n.p-contextmenu-separator {\n    border-top: 1px solid  ").concat(dt2("contextmenu.separator.border.color"), ";\n}\n\n.p-contextmenu-enter-from,\n.p-contextmenu-leave-active {\n    opacity: 0;\n}\n\n.p-contextmenu-enter-active {\n    transition: opacity 250ms;\n}\n");
}, "theme");
var classes$a = {
  root: "p-contextmenu p-component",
  rootList: "p-contextmenu-root-list",
  item: /* @__PURE__ */ __name(function item(_ref2) {
    var instance = _ref2.instance, processedItem = _ref2.processedItem;
    return ["p-contextmenu-item", {
      "p-contextmenu-item-active": instance.isItemActive(processedItem),
      "p-focus": instance.isItemFocused(processedItem),
      "p-disabled": instance.isItemDisabled(processedItem)
    }];
  }, "item"),
  itemContent: "p-contextmenu-item-content",
  itemLink: "p-contextmenu-item-link",
  itemIcon: "p-contextmenu-item-icon",
  itemLabel: "p-contextmenu-item-label",
  submenuIcon: "p-contextmenu-submenu-icon",
  submenu: "p-contextmenu-submenu",
  separator: "p-contextmenu-separator"
};
var ContextMenuStyle = BaseStyle.extend({
  name: "contextmenu",
  theme: theme$a,
  classes: classes$a
});
var script$h = {
  name: "AngleRightIcon",
  "extends": script$X
};
var _hoisted_1$x = /* @__PURE__ */ createBaseVNode("path", {
  d: "M5.25 11.1728C5.14929 11.1694 5.05033 11.1455 4.9592 11.1025C4.86806 11.0595 4.78666 10.9984 4.72 10.9228C4.57955 10.7822 4.50066 10.5916 4.50066 10.3928C4.50066 10.1941 4.57955 10.0035 4.72 9.86283L7.72 6.86283L4.72 3.86283C4.66067 3.71882 4.64765 3.55991 4.68275 3.40816C4.71785 3.25642 4.79932 3.11936 4.91585 3.01602C5.03238 2.91268 5.17819 2.84819 5.33305 2.83149C5.4879 2.81479 5.64411 2.84671 5.78 2.92283L9.28 6.42283C9.42045 6.56346 9.49934 6.75408 9.49934 6.95283C9.49934 7.15158 9.42045 7.34221 9.28 7.48283L5.78 10.9228C5.71333 10.9984 5.63193 11.0595 5.5408 11.1025C5.44966 11.1455 5.35071 11.1694 5.25 11.1728Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$m = [_hoisted_1$x];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$m, 16);
}
__name(render$g, "render$g");
script$h.render = render$g;
var script$2$1 = {
  name: "BaseContextMenu",
  "extends": script$Y,
  props: {
    model: {
      type: Array,
      "default": null
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    global: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: ContextMenuStyle,
  provide: /* @__PURE__ */ __name(function provide29() {
    return {
      $pcContextMenu: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$1$9 = {
  name: "ContextMenuSub",
  hostName: "ContextMenu",
  "extends": script$Y,
  emits: ["item-click", "item-mouseenter", "item-mousemove"],
  props: {
    items: {
      type: Array,
      "default": null
    },
    menuId: {
      type: String,
      "default": null
    },
    focusedItemId: {
      type: String,
      "default": null
    },
    root: {
      type: Boolean,
      "default": false
    },
    visible: {
      type: Boolean,
      "default": false
    },
    level: {
      type: Number,
      "default": 0
    },
    templates: {
      type: Object,
      "default": null
    },
    activeItemPath: {
      type: Object,
      "default": null
    },
    tabindex: {
      type: Number,
      "default": 0
    }
  },
  methods: {
    getItemId: /* @__PURE__ */ __name(function getItemId(processedItem) {
      return "".concat(this.menuId, "_").concat(processedItem.key);
    }, "getItemId"),
    getItemKey: /* @__PURE__ */ __name(function getItemKey(processedItem) {
      return this.getItemId(processedItem);
    }, "getItemKey"),
    getItemProp: /* @__PURE__ */ __name(function getItemProp(processedItem, name, params) {
      return processedItem && processedItem.item ? resolve(processedItem.item[name], params) : void 0;
    }, "getItemProp"),
    getItemLabel: /* @__PURE__ */ __name(function getItemLabel(processedItem) {
      return this.getItemProp(processedItem, "label");
    }, "getItemLabel"),
    getItemLabelId: /* @__PURE__ */ __name(function getItemLabelId(processedItem) {
      return "".concat(this.menuId, "_").concat(processedItem.key, "_label");
    }, "getItemLabelId"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions7(key, processedItem, index2) {
      return this.ptm(key, {
        context: {
          item: processedItem.item,
          active: this.isItemActive(processedItem),
          focused: this.isItemFocused(processedItem),
          disabled: this.isItemDisabled(processedItem),
          index: index2
        }
      });
    }, "getPTOptions"),
    isItemActive: /* @__PURE__ */ __name(function isItemActive(processedItem) {
      return this.activeItemPath.some(function(path) {
        return path.key === processedItem.key;
      });
    }, "isItemActive"),
    isItemVisible: /* @__PURE__ */ __name(function isItemVisible(processedItem) {
      return this.getItemProp(processedItem, "visible") !== false;
    }, "isItemVisible"),
    isItemDisabled: /* @__PURE__ */ __name(function isItemDisabled(processedItem) {
      return this.getItemProp(processedItem, "disabled");
    }, "isItemDisabled"),
    isItemFocused: /* @__PURE__ */ __name(function isItemFocused(processedItem) {
      return this.focusedItemId === this.getItemId(processedItem);
    }, "isItemFocused"),
    isItemGroup: /* @__PURE__ */ __name(function isItemGroup(processedItem) {
      return isNotEmpty(processedItem.items);
    }, "isItemGroup"),
    onItemClick: /* @__PURE__ */ __name(function onItemClick(event2, processedItem) {
      this.getItemProp(processedItem, "command", {
        originalEvent: event2,
        item: processedItem.item
      });
      this.$emit("item-click", {
        originalEvent: event2,
        processedItem,
        isFocus: true
      });
    }, "onItemClick"),
    onItemMouseEnter: /* @__PURE__ */ __name(function onItemMouseEnter(event2, processedItem) {
      this.$emit("item-mouseenter", {
        originalEvent: event2,
        processedItem
      });
    }, "onItemMouseEnter"),
    onItemMouseMove: /* @__PURE__ */ __name(function onItemMouseMove(event2, processedItem) {
      this.$emit("item-mousemove", {
        originalEvent: event2,
        processedItem,
        isFocus: true
      });
    }, "onItemMouseMove"),
    getAriaSetSize: /* @__PURE__ */ __name(function getAriaSetSize() {
      var _this = this;
      return this.items.filter(function(processedItem) {
        return _this.isItemVisible(processedItem) && !_this.getItemProp(processedItem, "separator");
      }).length;
    }, "getAriaSetSize"),
    getAriaPosInset: /* @__PURE__ */ __name(function getAriaPosInset3(index2) {
      var _this2 = this;
      return index2 - this.items.slice(0, index2).filter(function(processedItem) {
        return _this2.isItemVisible(processedItem) && _this2.getItemProp(processedItem, "separator");
      }).length + 1;
    }, "getAriaPosInset"),
    onEnter: /* @__PURE__ */ __name(function onEnter() {
      nestedPosition(this.$refs.container, this.level);
    }, "onEnter"),
    getMenuItemProps: /* @__PURE__ */ __name(function getMenuItemProps(processedItem, index2) {
      return {
        action: mergeProps({
          "class": this.cx("itemLink"),
          tabindex: -1,
          "aria-hidden": true
        }, this.getPTOptions("itemLink", processedItem, index2)),
        icon: mergeProps({
          "class": [this.cx("itemIcon"), this.getItemProp(processedItem, "icon")]
        }, this.getPTOptions("itemIcon", processedItem, index2)),
        label: mergeProps({
          "class": this.cx("itemLabel")
        }, this.getPTOptions("itemLabel", processedItem, index2)),
        submenuicon: mergeProps({
          "class": this.cx("submenuIcon")
        }, this.getPTOptions("submenuicon", processedItem, index2))
      };
    }, "getMenuItemProps")
  },
  components: {
    AngleRightIcon: script$h
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$w = ["tabindex"];
var _hoisted_2$l = ["id", "aria-label", "aria-disabled", "aria-expanded", "aria-haspopup", "aria-level", "aria-setsize", "aria-posinset", "data-p-active", "data-p-focused", "data-p-disabled"];
var _hoisted_3$c = ["onClick", "onMouseenter", "onMousemove"];
var _hoisted_4$8 = ["href", "target"];
var _hoisted_5$6 = ["id"];
var _hoisted_6$5 = ["id"];
function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_AngleRightIcon = resolveComponent("AngleRightIcon");
  var _component_ContextMenuSub = resolveComponent("ContextMenuSub", true);
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createBlock(Transition, mergeProps({
    name: "p-contextmenusub",
    onEnter: $options.onEnter
  }, _ctx.ptm("menu.transition")), {
    "default": withCtx(function() {
      return [($props.root ? true : $props.visible) ? (openBlock(), createElementBlock("ul", mergeProps({
        key: 0,
        ref: "container",
        tabindex: $props.tabindex
      }, _ctx.ptm("rootList")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.items, function(processedItem, index2) {
        return openBlock(), createElementBlock(Fragment, {
          key: $options.getItemKey(processedItem)
        }, [$options.isItemVisible(processedItem) && !$options.getItemProp(processedItem, "separator") ? (openBlock(), createElementBlock("li", mergeProps({
          key: 0,
          id: $options.getItemId(processedItem),
          style: $options.getItemProp(processedItem, "style"),
          "class": [_ctx.cx("item", {
            processedItem
          }), $options.getItemProp(processedItem, "class")],
          role: "menuitem",
          "aria-label": $options.getItemLabel(processedItem),
          "aria-disabled": $options.isItemDisabled(processedItem) || void 0,
          "aria-expanded": $options.isItemGroup(processedItem) ? $options.isItemActive(processedItem) : void 0,
          "aria-haspopup": $options.isItemGroup(processedItem) && !$options.getItemProp(processedItem, "to") ? "menu" : void 0,
          "aria-level": $props.level + 1,
          "aria-setsize": $options.getAriaSetSize(),
          "aria-posinset": $options.getAriaPosInset(index2),
          ref_for: true
        }, $options.getPTOptions("item", processedItem, index2), {
          "data-p-active": $options.isItemActive(processedItem),
          "data-p-focused": $options.isItemFocused(processedItem),
          "data-p-disabled": $options.isItemDisabled(processedItem)
        }), [createBaseVNode("div", mergeProps({
          "class": _ctx.cx("itemContent"),
          onClick: /* @__PURE__ */ __name(function onClick3($event) {
            return $options.onItemClick($event, processedItem);
          }, "onClick"),
          onMouseenter: /* @__PURE__ */ __name(function onMouseenter($event) {
            return $options.onItemMouseEnter($event, processedItem);
          }, "onMouseenter"),
          onMousemove: /* @__PURE__ */ __name(function onMousemove($event) {
            return $options.onItemMouseMove($event, processedItem);
          }, "onMousemove"),
          ref_for: true
        }, $options.getPTOptions("itemContent", processedItem, index2)), [!$props.templates.item ? withDirectives((openBlock(), createElementBlock("a", mergeProps({
          key: 0,
          href: $options.getItemProp(processedItem, "url"),
          "class": _ctx.cx("itemLink"),
          target: $options.getItemProp(processedItem, "target"),
          tabindex: "-1",
          ref_for: true
        }, $options.getPTOptions("itemLink", processedItem, index2)), [$props.templates.itemicon ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.itemicon), {
          key: 0,
          item: processedItem.item,
          "class": normalizeClass(_ctx.cx("itemIcon"))
        }, null, 8, ["item", "class"])) : $options.getItemProp(processedItem, "icon") ? (openBlock(), createElementBlock("span", mergeProps({
          key: 1,
          "class": [_ctx.cx("itemIcon"), $options.getItemProp(processedItem, "icon")],
          ref_for: true
        }, $options.getPTOptions("itemIcon", processedItem, index2)), null, 16)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
          id: $options.getItemLabelId(processedItem),
          "class": _ctx.cx("itemLabel"),
          ref_for: true
        }, $options.getPTOptions("itemLabel", processedItem, index2)), toDisplayString$1($options.getItemLabel(processedItem)), 17, _hoisted_5$6), $options.getItemProp(processedItem, "items") ? (openBlock(), createElementBlock(Fragment, {
          key: 2
        }, [$props.templates.submenuicon ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.submenuicon), {
          key: 0,
          active: $options.isItemActive(processedItem),
          "class": normalizeClass(_ctx.cx("submenuIcon"))
        }, null, 8, ["active", "class"])) : (openBlock(), createBlock(_component_AngleRightIcon, mergeProps({
          key: 1,
          "class": _ctx.cx("submenuIcon"),
          ref_for: true
        }, $options.getPTOptions("submenuicon", processedItem, index2)), null, 16, ["class"]))], 64)) : createCommentVNode("", true)], 16, _hoisted_4$8)), [[_directive_ripple]]) : (openBlock(), createBlock(resolveDynamicComponent($props.templates.item), {
          key: 1,
          item: processedItem.item,
          hasSubmenu: $options.getItemProp(processedItem, "items"),
          label: $options.getItemLabel(processedItem),
          props: $options.getMenuItemProps(processedItem, index2)
        }, null, 8, ["item", "hasSubmenu", "label", "props"]))], 16, _hoisted_3$c), $options.isItemVisible(processedItem) && $options.isItemGroup(processedItem) ? (openBlock(), createBlock(_component_ContextMenuSub, mergeProps({
          key: 0,
          id: $options.getItemId(processedItem) + "_list",
          role: "menu",
          "class": _ctx.cx("submenu"),
          menuId: $props.menuId,
          focusedItemId: $props.focusedItemId,
          items: processedItem.items,
          templates: $props.templates,
          activeItemPath: $props.activeItemPath,
          level: $props.level + 1,
          visible: $options.isItemActive(processedItem) && $options.isItemGroup(processedItem),
          pt: _ctx.pt,
          unstyled: _ctx.unstyled,
          onItemClick: _cache[0] || (_cache[0] = function($event) {
            return _ctx.$emit("item-click", $event);
          }),
          onItemMouseenter: _cache[1] || (_cache[1] = function($event) {
            return _ctx.$emit("item-mouseenter", $event);
          }),
          onItemMousemove: _cache[2] || (_cache[2] = function($event) {
            return _ctx.$emit("item-mousemove", $event);
          }),
          "aria-labelledby": $options.getItemLabelId(processedItem),
          ref_for: true
        }, _ctx.ptm("submenu")), null, 16, ["id", "class", "menuId", "focusedItemId", "items", "templates", "activeItemPath", "level", "visible", "pt", "unstyled", "aria-labelledby"])) : createCommentVNode("", true)], 16, _hoisted_2$l)) : createCommentVNode("", true), $options.isItemVisible(processedItem) && $options.getItemProp(processedItem, "separator") ? (openBlock(), createElementBlock("li", mergeProps({
          key: 1,
          id: $options.getItemId(processedItem),
          style: $options.getItemProp(processedItem, "style"),
          "class": [_ctx.cx("separator"), $options.getItemProp(processedItem, "class")],
          role: "separator",
          ref_for: true
        }, _ctx.ptm("separator")), null, 16, _hoisted_6$5)) : createCommentVNode("", true)], 64);
      }), 128))], 16, _hoisted_1$w)) : createCommentVNode("", true)];
    }),
    _: 1
  }, 16, ["onEnter"]);
}
__name(render$1$1, "render$1$1");
script$1$9.render = render$1$1;
var script$g = {
  name: "ContextMenu",
  "extends": script$2$1,
  inheritAttrs: false,
  emits: ["focus", "blur", "show", "hide", "before-show", "before-hide"],
  target: null,
  outsideClickListener: null,
  resizeListener: null,
  documentContextMenuListener: null,
  pageX: null,
  pageY: null,
  container: null,
  list: null,
  data: /* @__PURE__ */ __name(function data13() {
    return {
      id: this.$attrs.id,
      focused: false,
      focusedItemInfo: {
        index: -1,
        level: 0,
        parentKey: ""
      },
      activeItemPath: [],
      visible: false,
      submenuVisible: false
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId6(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    activeItemPath: /* @__PURE__ */ __name(function activeItemPath(newPath) {
      if (isNotEmpty(newPath)) {
        this.bindOutsideClickListener();
        this.bindResizeListener();
      } else if (!this.visible) {
        this.unbindOutsideClickListener();
        this.unbindResizeListener();
      }
    }, "activeItemPath")
  },
  mounted: /* @__PURE__ */ __name(function mounted11() {
    this.id = this.id || UniqueComponentId();
    if (this.global) {
      this.bindDocumentContextMenuListener();
    }
  }, "mounted"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount5() {
    this.unbindResizeListener();
    this.unbindOutsideClickListener();
    this.unbindDocumentContextMenuListener();
    if (this.container && this.autoZIndex) {
      ZIndex.clear(this.container);
    }
    this.target = null;
    this.container = null;
  }, "beforeUnmount"),
  methods: {
    getItemProp: /* @__PURE__ */ __name(function getItemProp2(item2, name) {
      return item2 ? resolve(item2[name]) : void 0;
    }, "getItemProp"),
    getItemLabel: /* @__PURE__ */ __name(function getItemLabel2(item2) {
      return this.getItemProp(item2, "label");
    }, "getItemLabel"),
    isItemDisabled: /* @__PURE__ */ __name(function isItemDisabled2(item2) {
      return this.getItemProp(item2, "disabled");
    }, "isItemDisabled"),
    isItemVisible: /* @__PURE__ */ __name(function isItemVisible2(item2) {
      return this.getItemProp(item2, "visible") !== false;
    }, "isItemVisible"),
    isItemGroup: /* @__PURE__ */ __name(function isItemGroup2(item2) {
      return isNotEmpty(this.getItemProp(item2, "items"));
    }, "isItemGroup"),
    isItemSeparator: /* @__PURE__ */ __name(function isItemSeparator(item2) {
      return this.getItemProp(item2, "separator");
    }, "isItemSeparator"),
    getProccessedItemLabel: /* @__PURE__ */ __name(function getProccessedItemLabel(processedItem) {
      return processedItem ? this.getItemLabel(processedItem.item) : void 0;
    }, "getProccessedItemLabel"),
    isProccessedItemGroup: /* @__PURE__ */ __name(function isProccessedItemGroup(processedItem) {
      return processedItem && isNotEmpty(processedItem.items);
    }, "isProccessedItemGroup"),
    toggle: /* @__PURE__ */ __name(function toggle2(event2) {
      this.visible ? this.hide() : this.show(event2);
    }, "toggle"),
    show: /* @__PURE__ */ __name(function show2(event2) {
      this.$emit("before-show");
      this.activeItemPath = [];
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ""
      };
      focus(this.list);
      this.pageX = event2.pageX;
      this.pageY = event2.pageY;
      this.visible ? this.position() : this.visible = true;
      event2.stopPropagation();
      event2.preventDefault();
    }, "show"),
    hide: /* @__PURE__ */ __name(function hide2() {
      this.$emit("before-hide");
      this.visible = false;
      this.activeItemPath = [];
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ""
      };
    }, "hide"),
    onFocus: /* @__PURE__ */ __name(function onFocus5(event2) {
      this.focused = true;
      this.focusedItemInfo = this.focusedItemInfo.index !== -1 ? this.focusedItemInfo : {
        index: -1,
        level: 0,
        parentKey: ""
      };
      this.$emit("focus", event2);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur5(event2) {
      this.focused = false;
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ""
      };
      this.searchValue = "";
      this.$emit("blur", event2);
    }, "onBlur"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown6(event2) {
      var metaKey = event2.metaKey || event2.ctrlKey;
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "ArrowLeft":
          this.onArrowLeftKey(event2);
          break;
        case "ArrowRight":
          this.onArrowRightKey(event2);
          break;
        case "Home":
          this.onHomeKey(event2);
          break;
        case "End":
          this.onEndKey(event2);
          break;
        case "Space":
          this.onSpaceKey(event2);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2);
          break;
        case "PageDown":
        case "PageUp":
        case "Backspace":
        case "ShiftLeft":
        case "ShiftRight":
          break;
        default:
          if (!metaKey && isPrintableCharacter(event2.key)) {
            this.searchItems(event2, event2.key);
          }
          break;
      }
    }, "onKeyDown"),
    onItemChange: /* @__PURE__ */ __name(function onItemChange(event2) {
      var processedItem = event2.processedItem, isFocus = event2.isFocus;
      if (isEmpty(processedItem)) return;
      var index2 = processedItem.index, key = processedItem.key, level = processedItem.level, parentKey = processedItem.parentKey, items2 = processedItem.items;
      var grouped = isNotEmpty(items2);
      var activeItemPath2 = this.activeItemPath.filter(function(p2) {
        return p2.parentKey !== parentKey && p2.parentKey !== key;
      });
      if (grouped) {
        activeItemPath2.push(processedItem);
        this.submenuVisible = true;
      }
      this.focusedItemInfo = {
        index: index2,
        level,
        parentKey
      };
      this.activeItemPath = activeItemPath2;
      isFocus && focus(this.list);
    }, "onItemChange"),
    onItemClick: /* @__PURE__ */ __name(function onItemClick2(event2) {
      var processedItem = event2.processedItem;
      var grouped = this.isProccessedItemGroup(processedItem);
      var selected2 = this.isSelected(processedItem);
      if (selected2) {
        var index2 = processedItem.index, key = processedItem.key, level = processedItem.level, parentKey = processedItem.parentKey;
        this.activeItemPath = this.activeItemPath.filter(function(p2) {
          return key !== p2.key && key.startsWith(p2.key);
        });
        this.focusedItemInfo = {
          index: index2,
          level,
          parentKey
        };
        focus(this.list);
      } else {
        grouped ? this.onItemChange(event2) : this.hide();
      }
    }, "onItemClick"),
    onItemMouseEnter: /* @__PURE__ */ __name(function onItemMouseEnter2(event2) {
      this.onItemChange(event2);
    }, "onItemMouseEnter"),
    onItemMouseMove: /* @__PURE__ */ __name(function onItemMouseMove2(event2) {
      if (this.focused) {
        this.changeFocusedItemIndex(event2, event2.processedItem.index);
      }
    }, "onItemMouseMove"),
    onArrowDownKey: /* @__PURE__ */ __name(function onArrowDownKey3(event2) {
      var itemIndex = this.focusedItemInfo.index !== -1 ? this.findNextItemIndex(this.focusedItemInfo.index) : this.findFirstFocusedItemIndex();
      this.changeFocusedItemIndex(event2, itemIndex);
      event2.preventDefault();
    }, "onArrowDownKey"),
    onArrowUpKey: /* @__PURE__ */ __name(function onArrowUpKey3(event2) {
      if (event2.altKey) {
        if (this.focusedItemInfo.index !== -1) {
          var processedItem = this.visibleItems[this.focusedItemInfo.index];
          var grouped = this.isProccessedItemGroup(processedItem);
          !grouped && this.onItemChange({
            originalEvent: event2,
            processedItem
          });
        }
        this.popup && this.hide();
        event2.preventDefault();
      } else {
        var itemIndex = this.focusedItemInfo.index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo.index) : this.findLastFocusedItemIndex();
        this.changeFocusedItemIndex(event2, itemIndex);
        event2.preventDefault();
      }
    }, "onArrowUpKey"),
    onArrowLeftKey: /* @__PURE__ */ __name(function onArrowLeftKey3(event2) {
      var _this = this;
      var processedItem = this.visibleItems[this.focusedItemInfo.index];
      var parentItem = this.activeItemPath.find(function(p2) {
        return p2.key === processedItem.parentKey;
      });
      var root23 = isEmpty(processedItem.parent);
      if (!root23) {
        this.focusedItemInfo = {
          index: -1,
          parentKey: parentItem ? parentItem.parentKey : ""
        };
        this.searchValue = "";
        this.onArrowDownKey(event2);
      }
      this.activeItemPath = this.activeItemPath.filter(function(p2) {
        return p2.parentKey !== _this.focusedItemInfo.parentKey;
      });
      event2.preventDefault();
    }, "onArrowLeftKey"),
    onArrowRightKey: /* @__PURE__ */ __name(function onArrowRightKey(event2) {
      var processedItem = this.visibleItems[this.focusedItemInfo.index];
      var grouped = this.isProccessedItemGroup(processedItem);
      if (grouped) {
        this.onItemChange({
          originalEvent: event2,
          processedItem
        });
        this.focusedItemInfo = {
          index: -1,
          parentKey: processedItem.key
        };
        this.searchValue = "";
        this.onArrowDownKey(event2);
      }
      event2.preventDefault();
    }, "onArrowRightKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey3(event2) {
      this.changeFocusedItemIndex(event2, this.findFirstItemIndex());
      event2.preventDefault();
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey3(event2) {
      this.changeFocusedItemIndex(event2, this.findLastItemIndex());
      event2.preventDefault();
    }, "onEndKey"),
    onEnterKey: /* @__PURE__ */ __name(function onEnterKey4(event2) {
      if (this.focusedItemInfo.index !== -1) {
        var element = findSingle(this.list, 'li[id="'.concat("".concat(this.focusedItemIdx), '"]'));
        var anchorElement = element && findSingle(element, '[data-pc-section="itemlink"]');
        anchorElement ? anchorElement.click() : element && element.click();
        var processedItem = this.visibleItems[this.focusedItemInfo.index];
        var grouped = this.isProccessedItemGroup(processedItem);
        !grouped && (this.focusedItemInfo.index = this.findFirstFocusedItemIndex());
      }
      event2.preventDefault();
    }, "onEnterKey"),
    onSpaceKey: /* @__PURE__ */ __name(function onSpaceKey3(event2) {
      this.onEnterKey(event2);
    }, "onSpaceKey"),
    onEscapeKey: /* @__PURE__ */ __name(function onEscapeKey2(event2) {
      this.hide();
      !this.popup && (this.focusedItemInfo.index = this.findFirstFocusedItemIndex());
      event2.preventDefault();
    }, "onEscapeKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey3(event2) {
      if (this.focusedItemInfo.index !== -1) {
        var processedItem = this.visibleItems[this.focusedItemInfo.index];
        var grouped = this.isProccessedItemGroup(processedItem);
        !grouped && this.onItemChange({
          originalEvent: event2,
          processedItem
        });
      }
      this.hide();
    }, "onTabKey"),
    onEnter: /* @__PURE__ */ __name(function onEnter2(el) {
      addStyle(el, {
        position: "absolute"
      });
      this.position();
      if (this.autoZIndex) {
        ZIndex.set("menu", el, this.baseZIndex + this.$primevue.config.zIndex.menu);
      }
    }, "onEnter"),
    onAfterEnter: /* @__PURE__ */ __name(function onAfterEnter() {
      this.bindOutsideClickListener();
      this.bindResizeListener();
      this.$emit("show");
      focus(this.list);
    }, "onAfterEnter"),
    onLeave: /* @__PURE__ */ __name(function onLeave() {
      this.$emit("hide");
      this.container = null;
    }, "onLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave(el) {
      if (this.autoZIndex) {
        ZIndex.clear(el);
      }
      this.unbindOutsideClickListener();
      this.unbindResizeListener();
    }, "onAfterLeave"),
    position: /* @__PURE__ */ __name(function position() {
      var left = this.pageX + 1;
      var top = this.pageY + 1;
      var width2 = this.container.offsetParent ? this.container.offsetWidth : getHiddenElementOuterWidth(this.container);
      var height = this.container.offsetParent ? this.container.offsetHeight : getHiddenElementOuterHeight(this.container);
      var viewport = getViewport();
      if (left + width2 - document.body.scrollLeft > viewport.width) {
        left -= width2;
      }
      if (top + height - document.body.scrollTop > viewport.height) {
        top -= height;
      }
      if (left < document.body.scrollLeft) {
        left = document.body.scrollLeft;
      }
      if (top < document.body.scrollTop) {
        top = document.body.scrollTop;
      }
      this.container.style.left = left + "px";
      this.container.style.top = top + "px";
    }, "position"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener2() {
      var _this2 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          var isOutsideContainer = _this2.container && !_this2.container.contains(event2.target);
          var isOutsideTarget = _this2.visible ? !(_this2.target && (_this2.target === event2.target || _this2.target.contains(event2.target))) : true;
          if (isOutsideContainer && isOutsideTarget) {
            _this2.hide();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener2() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener3() {
      var _this3 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this3.visible && !isTouchDevice()) {
            _this3.hide();
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener3() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    bindDocumentContextMenuListener: /* @__PURE__ */ __name(function bindDocumentContextMenuListener() {
      var _this4 = this;
      if (!this.documentContextMenuListener) {
        this.documentContextMenuListener = function(event2) {
          event2.button === 2 && _this4.show(event2);
        };
        document.addEventListener("contextmenu", this.documentContextMenuListener);
      }
    }, "bindDocumentContextMenuListener"),
    unbindDocumentContextMenuListener: /* @__PURE__ */ __name(function unbindDocumentContextMenuListener() {
      if (this.documentContextMenuListener) {
        document.removeEventListener("contextmenu", this.documentContextMenuListener);
        this.documentContextMenuListener = null;
      }
    }, "unbindDocumentContextMenuListener"),
    isItemMatched: /* @__PURE__ */ __name(function isItemMatched(processedItem) {
      var _this$getProccessedIt;
      return this.isValidItem(processedItem) && ((_this$getProccessedIt = this.getProccessedItemLabel(processedItem)) === null || _this$getProccessedIt === void 0 ? void 0 : _this$getProccessedIt.toLocaleLowerCase().startsWith(this.searchValue.toLocaleLowerCase()));
    }, "isItemMatched"),
    isValidItem: /* @__PURE__ */ __name(function isValidItem(processedItem) {
      return !!processedItem && !this.isItemDisabled(processedItem.item) && !this.isItemSeparator(processedItem.item) && this.isItemVisible(processedItem.item);
    }, "isValidItem"),
    isValidSelectedItem: /* @__PURE__ */ __name(function isValidSelectedItem(processedItem) {
      return this.isValidItem(processedItem) && this.isSelected(processedItem);
    }, "isValidSelectedItem"),
    isSelected: /* @__PURE__ */ __name(function isSelected3(processedItem) {
      return this.activeItemPath.some(function(p2) {
        return p2.key === processedItem.key;
      });
    }, "isSelected"),
    findFirstItemIndex: /* @__PURE__ */ __name(function findFirstItemIndex() {
      var _this5 = this;
      return this.visibleItems.findIndex(function(processedItem) {
        return _this5.isValidItem(processedItem);
      });
    }, "findFirstItemIndex"),
    findLastItemIndex: /* @__PURE__ */ __name(function findLastItemIndex() {
      var _this6 = this;
      return findLastIndex(this.visibleItems, function(processedItem) {
        return _this6.isValidItem(processedItem);
      });
    }, "findLastItemIndex"),
    findNextItemIndex: /* @__PURE__ */ __name(function findNextItemIndex(index2) {
      var _this7 = this;
      var matchedItemIndex = index2 < this.visibleItems.length - 1 ? this.visibleItems.slice(index2 + 1).findIndex(function(processedItem) {
        return _this7.isValidItem(processedItem);
      }) : -1;
      return matchedItemIndex > -1 ? matchedItemIndex + index2 + 1 : index2;
    }, "findNextItemIndex"),
    findPrevItemIndex: /* @__PURE__ */ __name(function findPrevItemIndex(index2) {
      var _this8 = this;
      var matchedItemIndex = index2 > 0 ? findLastIndex(this.visibleItems.slice(0, index2), function(processedItem) {
        return _this8.isValidItem(processedItem);
      }) : -1;
      return matchedItemIndex > -1 ? matchedItemIndex : index2;
    }, "findPrevItemIndex"),
    findSelectedItemIndex: /* @__PURE__ */ __name(function findSelectedItemIndex() {
      var _this9 = this;
      return this.visibleItems.findIndex(function(processedItem) {
        return _this9.isValidSelectedItem(processedItem);
      });
    }, "findSelectedItemIndex"),
    findFirstFocusedItemIndex: /* @__PURE__ */ __name(function findFirstFocusedItemIndex() {
      var selectedIndex = this.findSelectedItemIndex();
      return selectedIndex < 0 ? this.findFirstItemIndex() : selectedIndex;
    }, "findFirstFocusedItemIndex"),
    findLastFocusedItemIndex: /* @__PURE__ */ __name(function findLastFocusedItemIndex() {
      var selectedIndex = this.findSelectedItemIndex();
      return selectedIndex < 0 ? this.findLastItemIndex() : selectedIndex;
    }, "findLastFocusedItemIndex"),
    searchItems: /* @__PURE__ */ __name(function searchItems(event2, _char) {
      var _this10 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var itemIndex = -1;
      var matched = false;
      if (this.focusedItemInfo.index !== -1) {
        itemIndex = this.visibleItems.slice(this.focusedItemInfo.index).findIndex(function(processedItem) {
          return _this10.isItemMatched(processedItem);
        });
        itemIndex = itemIndex === -1 ? this.visibleItems.slice(0, this.focusedItemInfo.index).findIndex(function(processedItem) {
          return _this10.isItemMatched(processedItem);
        }) : itemIndex + this.focusedItemInfo.index;
      } else {
        itemIndex = this.visibleItems.findIndex(function(processedItem) {
          return _this10.isItemMatched(processedItem);
        });
      }
      if (itemIndex !== -1) {
        matched = true;
      }
      if (itemIndex === -1 && this.focusedItemInfo.index === -1) {
        itemIndex = this.findFirstFocusedItemIndex();
      }
      if (itemIndex !== -1) {
        this.changeFocusedItemIndex(event2, itemIndex);
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this10.searchValue = "";
        _this10.searchTimeout = null;
      }, 500);
      return matched;
    }, "searchItems"),
    changeFocusedItemIndex: /* @__PURE__ */ __name(function changeFocusedItemIndex(event2, index2) {
      if (this.focusedItemInfo.index !== index2) {
        this.focusedItemInfo.index = index2;
        this.scrollInView();
      }
    }, "changeFocusedItemIndex"),
    scrollInView: /* @__PURE__ */ __name(function scrollInView6() {
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      var id3 = index2 !== -1 ? "".concat(this.id, "_").concat(index2) : this.focusedItemIdx;
      var element = findSingle(this.list, 'li[id="'.concat(id3, '"]'));
      if (element) {
        element.scrollIntoView && element.scrollIntoView({
          block: "nearest",
          inline: "start"
        });
      }
    }, "scrollInView"),
    createProcessedItems: /* @__PURE__ */ __name(function createProcessedItems(items2) {
      var _this11 = this;
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var parent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var parentKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      var processedItems2 = [];
      items2 && items2.forEach(function(item2, index2) {
        var key = (parentKey !== "" ? parentKey + "_" : "") + index2;
        var newItem = {
          item: item2,
          index: index2,
          level,
          key,
          parent,
          parentKey
        };
        newItem["items"] = _this11.createProcessedItems(item2.items, level + 1, newItem, key);
        processedItems2.push(newItem);
      });
      return processedItems2;
    }, "createProcessedItems"),
    containerRef: /* @__PURE__ */ __name(function containerRef(el) {
      this.container = el;
    }, "containerRef"),
    listRef: /* @__PURE__ */ __name(function listRef3(el) {
      this.list = el ? el.$el : void 0;
    }, "listRef")
  },
  computed: {
    processedItems: /* @__PURE__ */ __name(function processedItems() {
      return this.createProcessedItems(this.model || []);
    }, "processedItems"),
    visibleItems: /* @__PURE__ */ __name(function visibleItems() {
      var _this12 = this;
      var processedItem = this.activeItemPath.find(function(p2) {
        return p2.key === _this12.focusedItemInfo.parentKey;
      });
      return processedItem ? processedItem.items : this.processedItems;
    }, "visibleItems"),
    focusedItemIdx: /* @__PURE__ */ __name(function focusedItemIdx() {
      return this.focusedItemInfo.index !== -1 ? "".concat(this.id).concat(isNotEmpty(this.focusedItemInfo.parentKey) ? "_" + this.focusedItemInfo.parentKey : "", "_").concat(this.focusedItemInfo.index) : null;
    }, "focusedItemIdx")
  },
  components: {
    ContextMenuSub: script$1$9,
    Portal: script$z
  }
};
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_ContextMenuSub = resolveComponent("ContextMenuSub");
  var _component_Portal = resolveComponent("Portal");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-contextmenu",
        onEnter: $options.onEnter,
        onAfterEnter: $options.onAfterEnter,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.visible ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            "class": _ctx.cx("root")
          }, _ctx.ptmi("root")), [createVNode(_component_ContextMenuSub, {
            ref: $options.listRef,
            id: $data.id + "_list",
            "class": normalizeClass(_ctx.cx("rootList")),
            role: "menubar",
            root: true,
            tabindex: _ctx.tabindex,
            "aria-orientation": "vertical",
            "aria-activedescendant": $data.focused ? $options.focusedItemIdx : void 0,
            menuId: $data.id,
            focusedItemId: $data.focused ? $options.focusedItemIdx : void 0,
            items: $options.processedItems,
            templates: _ctx.$slots,
            activeItemPath: $data.activeItemPath,
            "aria-labelledby": _ctx.ariaLabelledby,
            "aria-label": _ctx.ariaLabel,
            level: 0,
            visible: $data.submenuVisible,
            pt: _ctx.pt,
            unstyled: _ctx.unstyled,
            onFocus: $options.onFocus,
            onBlur: $options.onBlur,
            onKeydown: $options.onKeyDown,
            onItemClick: $options.onItemClick,
            onItemMouseenter: $options.onItemMouseEnter,
            onItemMousemove: $options.onItemMouseMove
          }, null, 8, ["id", "class", "tabindex", "aria-activedescendant", "menuId", "focusedItemId", "items", "templates", "activeItemPath", "aria-labelledby", "aria-label", "visible", "pt", "unstyled", "onFocus", "onBlur", "onKeydown", "onItemClick", "onItemMouseenter", "onItemMousemove"])], 16)) : createCommentVNode("", true)];
        }),
        _: 1
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 1
  }, 8, ["appendTo"]);
}
__name(render$f, "render$f");
script$g.render = render$f;
const _withScopeId$c = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-d670c40f"), n = n(), popScopeId(), n), "_withScopeId$c");
const _hoisted_1$v = { class: "editable-text" };
const _hoisted_2$k = { key: 0 };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "EditableText",
  props: {
    modelValue: {},
    isEditing: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "edit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const inputValue = ref(props.modelValue);
    const inputRef = ref(null);
    const blurInputElement = /* @__PURE__ */ __name(() => {
      inputRef.value?.$el.blur();
    }, "blurInputElement");
    const finishEditing = /* @__PURE__ */ __name(() => {
      emit2("edit", inputValue.value);
    }, "finishEditing");
    watch(
      () => props.isEditing,
      (newVal) => {
        if (newVal) {
          inputValue.value = props.modelValue;
          nextTick(() => {
            if (!inputRef.value) return;
            const fileName = inputValue.value.includes(".") ? inputValue.value.split(".").slice(0, -1).join(".") : inputValue.value;
            const start2 = 0;
            const end = fileName.length;
            const inputElement = inputRef.value.$el;
            inputElement.setSelectionRange?.(start2, end);
          });
        }
      },
      { immediate: true }
    );
    const vFocus = {
      mounted: /* @__PURE__ */ __name((el) => el.focus(), "mounted")
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$v, [
        !props.isEditing ? (openBlock(), createElementBlock("span", _hoisted_2$k, toDisplayString$1(_ctx.modelValue), 1)) : withDirectives((openBlock(), createBlock(unref(script$R), {
          key: 1,
          type: "text",
          size: "small",
          fluid: "",
          modelValue: inputValue.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue.value = $event),
          ref_key: "inputRef",
          ref: inputRef,
          onKeyup: withKeys(blurInputElement, ["enter"]),
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          pt: {
            root: {
              onBlur: finishEditing
            }
          }
        }, null, 8, ["modelValue", "pt"])), [
          [vFocus]
        ])
      ]);
    };
  }
});
const EditableText = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-d670c40f"]]);
function _arrayWithHoles$1(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles$1, "_arrayWithHoles$1");
function _iterableToArrayLimit$1(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit$1, "_iterableToArrayLimit$1");
function _arrayLikeToArray$6(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$6, "_arrayLikeToArray$6");
function _unsupportedIterableToArray$6(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$6(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$6(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$6, "_unsupportedIterableToArray$6");
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest$1, "_nonIterableRest$1");
function _slicedToArray$1(r, e) {
  return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$6(r, e) || _nonIterableRest$1();
}
__name(_slicedToArray$1, "_slicedToArray$1");
var dist = {};
var bind$1 = {};
"use strict";
Object.defineProperty(bind$1, "__esModule", { value: true });
var bind_2 = bind$1.bind = void 0;
function bind(target, _a) {
  var type = _a.type, listener = _a.listener, options3 = _a.options;
  target.addEventListener(type, listener, options3);
  return /* @__PURE__ */ __name(function unbind2() {
    target.removeEventListener(type, listener, options3);
  }, "unbind");
}
__name(bind, "bind");
bind_2 = bind$1.bind = bind;
var bindAll$1 = {};
"use strict";
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2))
        t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(bindAll$1, "__esModule", { value: true });
var bindAll_2 = bindAll$1.bindAll = void 0;
var bind_1 = bind$1;
function toOptions(value3) {
  if (typeof value3 === "undefined") {
    return void 0;
  }
  if (typeof value3 === "boolean") {
    return {
      capture: value3
    };
  }
  return value3;
}
__name(toOptions, "toOptions");
function getBinding(original, sharedOptions) {
  if (sharedOptions == null) {
    return original;
  }
  var binding = __assign(__assign({}, original), { options: __assign(__assign({}, toOptions(sharedOptions)), toOptions(original.options)) });
  return binding;
}
__name(getBinding, "getBinding");
function bindAll(target, bindings, sharedOptions) {
  var unbinds = bindings.map(function(original) {
    var binding = getBinding(original, sharedOptions);
    return (0, bind_1.bind)(target, binding);
  });
  return /* @__PURE__ */ __name(function unbindAll() {
    unbinds.forEach(function(unbind2) {
      return unbind2();
    });
  }, "unbindAll");
}
__name(bindAll, "bindAll");
bindAll_2 = bindAll$1.bindAll = bindAll;
(function(exports) {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindAll = exports.bind = void 0;
  var bind_12 = bind$1;
  Object.defineProperty(exports, "bind", { enumerable: true, get: /* @__PURE__ */ __name(function() {
    return bind_12.bind;
  }, "get") });
  var bind_all_1 = bindAll$1;
  Object.defineProperty(exports, "bindAll", { enumerable: true, get: /* @__PURE__ */ __name(function() {
    return bind_all_1.bindAll;
  }, "get") });
})(dist);
const index$1m = /* @__PURE__ */ getDefaultExportFromCjs(dist);
var honeyPotDataAttribute = "data-pdnd-honey-pot";
function isHoneyPotElement(target) {
  return target instanceof Element && target.hasAttribute(honeyPotDataAttribute);
}
__name(isHoneyPotElement, "isHoneyPotElement");
function getElementFromPointWithoutHoneypot(client) {
  var _document$elementsFro = document.elementsFromPoint(client.x, client.y), _document$elementsFro2 = _slicedToArray$1(_document$elementsFro, 2), top = _document$elementsFro2[0], second = _document$elementsFro2[1];
  if (!top) {
    return null;
  }
  if (isHoneyPotElement(top)) {
    return second !== null && second !== void 0 ? second : null;
  }
  return top;
}
__name(getElementFromPointWithoutHoneypot, "getElementFromPointWithoutHoneypot");
function _typeof$6(o) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$6(o);
}
__name(_typeof$6, "_typeof$6");
function toPrimitive(t, r) {
  if ("object" != _typeof$6(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(toPrimitive, "toPrimitive");
function toPropertyKey(t) {
  var i2 = toPrimitive(t, "string");
  return "symbol" == _typeof$6(i2) ? i2 : i2 + "";
}
__name(toPropertyKey, "toPropertyKey");
function _defineProperty$6(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
__name(_defineProperty$6, "_defineProperty$6");
var maxZIndex = 2147483647;
function ownKeys$8(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$8, "ownKeys$8");
function _objectSpread$8(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$8(Object(t), true).forEach(function(r2) {
      _defineProperty$6(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$8, "_objectSpread$8");
var honeyPotSize = 2;
var halfHoneyPotSize = honeyPotSize / 2;
function floorToClosestPixel(point) {
  return {
    x: Math.floor(point.x),
    y: Math.floor(point.y)
  };
}
__name(floorToClosestPixel, "floorToClosestPixel");
function pullBackByHalfHoneyPotSize(point) {
  return {
    x: point.x - halfHoneyPotSize,
    y: point.y - halfHoneyPotSize
  };
}
__name(pullBackByHalfHoneyPotSize, "pullBackByHalfHoneyPotSize");
function preventGoingBackwardsOffScreen(point) {
  return {
    x: Math.max(point.x, 0),
    y: Math.max(point.y, 0)
  };
}
__name(preventGoingBackwardsOffScreen, "preventGoingBackwardsOffScreen");
function preventGoingForwardsOffScreen(point) {
  return {
    x: Math.min(point.x, window.innerWidth - honeyPotSize),
    y: Math.min(point.y, window.innerHeight - honeyPotSize)
  };
}
__name(preventGoingForwardsOffScreen, "preventGoingForwardsOffScreen");
function getHoneyPotRectFor(_ref) {
  var client = _ref.client;
  var point = preventGoingForwardsOffScreen(preventGoingBackwardsOffScreen(pullBackByHalfHoneyPotSize(floorToClosestPixel(client))));
  return DOMRect.fromRect({
    x: point.x,
    y: point.y,
    width: honeyPotSize,
    height: honeyPotSize
  });
}
__name(getHoneyPotRectFor, "getHoneyPotRectFor");
function getRectStyles(_ref2) {
  var clientRect = _ref2.clientRect;
  return {
    left: "".concat(clientRect.left, "px"),
    top: "".concat(clientRect.top, "px"),
    width: "".concat(clientRect.width, "px"),
    height: "".concat(clientRect.height, "px")
  };
}
__name(getRectStyles, "getRectStyles");
function isWithin(_ref3) {
  var client = _ref3.client, clientRect = _ref3.clientRect;
  return (
    // is within horizontal bounds
    client.x >= clientRect.x && client.x <= clientRect.x + clientRect.width && // is within vertical bounds
    client.y >= clientRect.y && client.y <= clientRect.y + clientRect.height
  );
}
__name(isWithin, "isWithin");
function mountHoneyPot(_ref4) {
  var initial = _ref4.initial;
  var element = document.createElement("div");
  element.setAttribute(honeyPotDataAttribute, "true");
  var clientRect = getHoneyPotRectFor({
    client: initial
  });
  Object.assign(element.style, _objectSpread$8(_objectSpread$8({
    // Setting a background color explicitly to avoid any inherited styles.
    // Looks like this could be `opacity: 0`, but worried that _might_
    // cause the element to be ignored on some platforms.
    // When debugging, set backgroundColor to something like "red".
    backgroundColor: "transparent",
    position: "fixed",
    // Being explicit to avoid inheriting styles
    padding: 0,
    margin: 0,
    boxSizing: "border-box"
  }, getRectStyles({
    clientRect
  })), {}, {
    // We want this element to absorb pointer events,
    // it's kind of the whole point 
    pointerEvents: "auto",
    // Want to make sure the honey pot is top of everything else.
    // Don't need to worry about native drag previews, as they will
    // have been rendered (and removed) before the honey pot is rendered
    zIndex: maxZIndex
  }));
  document.body.appendChild(element);
  var unbindPointerMove = dist.bind(window, {
    type: "pointermove",
    listener: /* @__PURE__ */ __name(function listener(event2) {
      var client = {
        x: event2.clientX,
        y: event2.clientY
      };
      clientRect = getHoneyPotRectFor({
        client
      });
      Object.assign(element.style, getRectStyles({
        clientRect
      }));
    }, "listener"),
    // using capture so we are less likely to be impacted by event stopping
    options: {
      capture: true
    }
  });
  return /* @__PURE__ */ __name(function finish(_ref5) {
    var current = _ref5.current;
    unbindPointerMove();
    if (isWithin({
      client: current,
      clientRect
    })) {
      element.remove();
      return;
    }
    function cleanup() {
      unbindPostDragEvents();
      element.remove();
    }
    __name(cleanup, "cleanup");
    var unbindPostDragEvents = dist.bindAll(window, [
      {
        type: "pointerdown",
        listener: cleanup
      },
      {
        type: "pointermove",
        listener: cleanup
      },
      {
        type: "focusin",
        listener: cleanup
      },
      {
        type: "focusout",
        listener: cleanup
      },
      // a 'pointerdown' should happen before 'dragstart', but just being super safe
      {
        type: "dragstart",
        listener: cleanup
      },
      // if the user has dragged something out of the window
      // and then is dragging something back into the window
      // the first events we will see are "dragenter" (and then "dragover").
      // So if we see any of these we need to clear the post drag fix.
      {
        type: "dragenter",
        listener: cleanup
      },
      {
        type: "dragover",
        listener: cleanup
      }
      // Not adding a "wheel" event listener, as "wheel" by itself does not
      // resolve the bug.
    ], {
      // Using `capture` so less likely to be impacted by other code stopping events
      capture: true
    });
  }, "finish");
}
__name(mountHoneyPot, "mountHoneyPot");
function makeHoneyPotFix() {
  var latestPointerMove = null;
  function bindEvents3() {
    latestPointerMove = null;
    return dist.bind(window, {
      type: "pointermove",
      listener: /* @__PURE__ */ __name(function listener(event2) {
        latestPointerMove = {
          x: event2.clientX,
          y: event2.clientY
        };
      }, "listener"),
      // listening for pointer move in capture phase
      // so we are less likely to be impacted by events being stopped.
      options: {
        capture: true
      }
    });
  }
  __name(bindEvents3, "bindEvents");
  function getOnPostDispatch() {
    var finish = null;
    return /* @__PURE__ */ __name(function onPostEvent(_ref6) {
      var eventName = _ref6.eventName, payload = _ref6.payload;
      if (eventName === "onDragStart") {
        var _latestPointerMove;
        var input = payload.location.initial.input;
        var initial = (_latestPointerMove = latestPointerMove) !== null && _latestPointerMove !== void 0 ? _latestPointerMove : {
          x: input.clientX,
          y: input.clientY
        };
        finish = mountHoneyPot({
          initial
        });
      }
      if (eventName === "onDrop") {
        var _finish;
        var _input = payload.location.current.input;
        (_finish = finish) === null || _finish === void 0 || _finish({
          current: {
            x: _input.clientX,
            y: _input.clientY
          }
        });
        finish = null;
        latestPointerMove = null;
      }
    }, "onPostEvent");
  }
  __name(getOnPostDispatch, "getOnPostDispatch");
  return {
    bindEvents: bindEvents3,
    getOnPostDispatch
  };
}
__name(makeHoneyPotFix, "makeHoneyPotFix");
function _arrayWithoutHoles$3(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$6(r);
}
__name(_arrayWithoutHoles$3, "_arrayWithoutHoles$3");
function _iterableToArray$3(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$3, "_iterableToArray$3");
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$3, "_nonIterableSpread$3");
function _toConsumableArray$3(r) {
  return _arrayWithoutHoles$3(r) || _iterableToArray$3(r) || _unsupportedIterableToArray$6(r) || _nonIterableSpread$3();
}
__name(_toConsumableArray$3, "_toConsumableArray$3");
function once(fn) {
  var cache2 = null;
  return /* @__PURE__ */ __name(function wrapped() {
    if (!cache2) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var result = fn.apply(this, args);
      cache2 = {
        result
      };
    }
    return cache2.result;
  }, "wrapped");
}
__name(once, "once");
var isFirefox = once(/* @__PURE__ */ __name(function isFirefox2() {
  if (false) {
    return false;
  }
  return navigator.userAgent.includes("Firefox");
}, "isFirefox2"));
var isSafari = once(/* @__PURE__ */ __name(function isSafari2() {
  if (false) {
    return false;
  }
  var _navigator2 = navigator, userAgent = _navigator2.userAgent;
  return userAgent.includes("AppleWebKit") && !userAgent.includes("Chrome");
}, "isSafari2"));
var symbols = {
  isLeavingWindow: Symbol("leaving"),
  isEnteringWindow: Symbol("entering")
};
function isEnteringWindowInSafari(_ref) {
  var dragEnter = _ref.dragEnter;
  if (!isSafari()) {
    return false;
  }
  return dragEnter.hasOwnProperty(symbols.isEnteringWindow);
}
__name(isEnteringWindowInSafari, "isEnteringWindowInSafari");
function isLeavingWindowInSafari(_ref2) {
  var dragLeave = _ref2.dragLeave;
  if (!isSafari()) {
    return false;
  }
  return dragLeave.hasOwnProperty(symbols.isLeavingWindow);
}
__name(isLeavingWindowInSafari, "isLeavingWindowInSafari");
(/* @__PURE__ */ __name(function fixSafari() {
  if (typeof window === "undefined") {
    return;
  }
  if (false) {
    return;
  }
  if (!isSafari()) {
    return;
  }
  function getInitialState() {
    return {
      enterCount: 0,
      isOverWindow: false
    };
  }
  __name(getInitialState, "getInitialState");
  var state = getInitialState();
  function resetState() {
    state = getInitialState();
  }
  __name(resetState, "resetState");
  dist.bindAll(
    window,
    [{
      type: "dragstart",
      listener: /* @__PURE__ */ __name(function listener() {
        state.enterCount = 0;
        state.isOverWindow = true;
      }, "listener")
    }, {
      type: "drop",
      listener: resetState
    }, {
      type: "dragend",
      listener: resetState
    }, {
      type: "dragenter",
      listener: /* @__PURE__ */ __name(function listener(event2) {
        if (!state.isOverWindow && state.enterCount === 0) {
          event2[symbols.isEnteringWindow] = true;
        }
        state.isOverWindow = true;
        state.enterCount++;
      }, "listener")
    }, {
      type: "dragleave",
      listener: /* @__PURE__ */ __name(function listener(event2) {
        state.enterCount--;
        if (state.isOverWindow && state.enterCount === 0) {
          event2[symbols.isLeavingWindow] = true;
          state.isOverWindow = false;
        }
      }, "listener")
    }],
    // using `capture: true` so that adding event listeners
    // in bubble phase will have the correct symbols
    {
      capture: true
    }
  );
}, "fixSafari"))();
function isNodeLike(target) {
  return "nodeName" in target;
}
__name(isNodeLike, "isNodeLike");
function isFromAnotherWindow(eventTarget) {
  return isNodeLike(eventTarget) && eventTarget.ownerDocument !== document;
}
__name(isFromAnotherWindow, "isFromAnotherWindow");
function isLeavingWindow(_ref) {
  var dragLeave = _ref.dragLeave;
  var type = dragLeave.type, relatedTarget = dragLeave.relatedTarget;
  if (type !== "dragleave") {
    return false;
  }
  if (isSafari()) {
    return isLeavingWindowInSafari({
      dragLeave
    });
  }
  if (relatedTarget == null) {
    return true;
  }
  if (isFirefox()) {
    return isFromAnotherWindow(relatedTarget);
  }
  return relatedTarget instanceof HTMLIFrameElement;
}
__name(isLeavingWindow, "isLeavingWindow");
function getBindingsForBrokenDrags(_ref) {
  var onDragEnd3 = _ref.onDragEnd;
  return [
    // ## Detecting drag ending for removed draggables
    //
    // If a draggable element is removed during a drag and the user drops:
    // 1. if over a valid drop target: we get a "drop" event to know the drag is finished
    // 2. if not over a valid drop target (or cancelled): we get nothing
    // The "dragend" event will not fire on the source draggable if it has been
    // removed from the DOM.
    // So we need to figure out if a drag operation has finished by looking at other events
    // We can do this by looking at other events
    // ### First detection: "pointermove" events
    // 1. "pointermove" events cannot fire during a drag and drop operation
    // according to the spec. So if we get a "pointermove" it means that
    // the drag and drop operations has finished. So if we get a "pointermove"
    // we know that the drag is over
    // 2.  Drag and drop operations are _supposed_ to suppress
    // other pointer events. However, firefox will allow a few
    // pointer event to get through after a drag starts.
    // The most I've seen is 3
    {
      type: "pointermove",
      listener: /* @__PURE__ */ function() {
        var callCount = 0;
        return /* @__PURE__ */ __name(function listener() {
          if (callCount < 20) {
            callCount++;
            return;
          }
          onDragEnd3();
        }, "listener");
      }()
    },
    // ### Second detection: "pointerdown" events
    // If we receive this event then we know that a drag operation has finished
    // and potentially another one is about to start.
    // Note: `pointerdown` fires on all browsers / platforms before "dragstart"
    {
      type: "pointerdown",
      listener: onDragEnd3
    }
  ];
}
__name(getBindingsForBrokenDrags, "getBindingsForBrokenDrags");
function getInput(event2) {
  return {
    altKey: event2.altKey,
    button: event2.button,
    buttons: event2.buttons,
    ctrlKey: event2.ctrlKey,
    metaKey: event2.metaKey,
    shiftKey: event2.shiftKey,
    clientX: event2.clientX,
    clientY: event2.clientY,
    pageX: event2.pageX,
    pageY: event2.pageY
  };
}
__name(getInput, "getInput");
var rafSchd = /* @__PURE__ */ __name(function rafSchd2(fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = /* @__PURE__ */ __name(function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  }, "wrapperFn");
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
}, "rafSchd");
var scheduleOnDrag = rafSchd(function(fn) {
  return fn();
});
var dragStart = /* @__PURE__ */ function() {
  var scheduled = null;
  function schedule(fn) {
    var frameId = requestAnimationFrame(function() {
      scheduled = null;
      fn();
    });
    scheduled = {
      frameId,
      fn
    };
  }
  __name(schedule, "schedule");
  function flush() {
    if (scheduled) {
      cancelAnimationFrame(scheduled.frameId);
      scheduled.fn();
      scheduled = null;
    }
  }
  __name(flush, "flush");
  return {
    schedule,
    flush
  };
}();
function makeDispatch(_ref) {
  var source = _ref.source, initial = _ref.initial, dispatchEvent = _ref.dispatchEvent;
  var previous = {
    dropTargets: []
  };
  function safeDispatch(args) {
    dispatchEvent(args);
    previous = {
      dropTargets: args.payload.location.current.dropTargets
    };
  }
  __name(safeDispatch, "safeDispatch");
  var dispatch = {
    start: /* @__PURE__ */ __name(function start2(_ref2) {
      var nativeSetDragImage = _ref2.nativeSetDragImage;
      var location2 = {
        current: initial,
        previous,
        initial
      };
      safeDispatch({
        eventName: "onGenerateDragPreview",
        payload: {
          source,
          location: location2,
          nativeSetDragImage
        }
      });
      dragStart.schedule(function() {
        safeDispatch({
          eventName: "onDragStart",
          payload: {
            source,
            location: location2
          }
        });
      });
    }, "start"),
    dragUpdate: /* @__PURE__ */ __name(function dragUpdate(_ref3) {
      var current = _ref3.current;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDropTargetChange",
        payload: {
          source,
          location: {
            initial,
            previous,
            current
          }
        }
      });
    }, "dragUpdate"),
    drag: /* @__PURE__ */ __name(function drag(_ref4) {
      var current = _ref4.current;
      scheduleOnDrag(function() {
        dragStart.flush();
        var location2 = {
          initial,
          previous,
          current
        };
        safeDispatch({
          eventName: "onDrag",
          payload: {
            source,
            location: location2
          }
        });
      });
    }, "drag"),
    drop: /* @__PURE__ */ __name(function drop(_ref5) {
      var current = _ref5.current, updatedSourcePayload = _ref5.updatedSourcePayload;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDrop",
        payload: {
          source: updatedSourcePayload !== null && updatedSourcePayload !== void 0 ? updatedSourcePayload : source,
          location: {
            current,
            previous,
            initial
          }
        }
      });
    }, "drop")
  };
  return dispatch;
}
__name(makeDispatch, "makeDispatch");
var globalState = {
  isActive: false
};
function canStart() {
  return !globalState.isActive;
}
__name(canStart, "canStart");
function getNativeSetDragImage(event2) {
  if (event2.dataTransfer) {
    return event2.dataTransfer.setDragImage.bind(event2.dataTransfer);
  }
  return null;
}
__name(getNativeSetDragImage, "getNativeSetDragImage");
function hasHierarchyChanged(_ref) {
  var current = _ref.current, next2 = _ref.next;
  if (current.length !== next2.length) {
    return true;
  }
  for (var i2 = 0; i2 < current.length; i2++) {
    if (current[i2].element !== next2[i2].element) {
      return true;
    }
  }
  return false;
}
__name(hasHierarchyChanged, "hasHierarchyChanged");
function start(_ref2) {
  var event2 = _ref2.event, dragType = _ref2.dragType, getDropTargetsOver = _ref2.getDropTargetsOver, dispatchEvent = _ref2.dispatchEvent;
  if (!canStart()) {
    return;
  }
  var initial = getStartLocation({
    event: event2,
    dragType,
    getDropTargetsOver
  });
  globalState.isActive = true;
  var state = {
    current: initial
  };
  setDropEffectOnEvent({
    event: event2,
    current: initial.dropTargets
  });
  var dispatch = makeDispatch({
    source: dragType.payload,
    dispatchEvent,
    initial
  });
  function updateState(next2) {
    var hasChanged2 = hasHierarchyChanged({
      current: state.current.dropTargets,
      next: next2.dropTargets
    });
    state.current = next2;
    if (hasChanged2) {
      dispatch.dragUpdate({
        current: state.current
      });
    }
  }
  __name(updateState, "updateState");
  function onUpdateEvent(event3) {
    var input = getInput(event3);
    var target = isHoneyPotElement(event3.target) ? getElementFromPointWithoutHoneypot({
      x: input.clientX,
      y: input.clientY
    }) : event3.target;
    var nextDropTargets = getDropTargetsOver({
      target,
      input,
      source: dragType.payload,
      current: state.current.dropTargets
    });
    if (nextDropTargets.length) {
      event3.preventDefault();
      setDropEffectOnEvent({
        event: event3,
        current: nextDropTargets
      });
    }
    updateState({
      dropTargets: nextDropTargets,
      input
    });
  }
  __name(onUpdateEvent, "onUpdateEvent");
  function cancel() {
    if (state.current.dropTargets.length) {
      updateState({
        dropTargets: [],
        input: state.current.input
      });
    }
    dispatch.drop({
      current: state.current,
      updatedSourcePayload: null
    });
    finish();
  }
  __name(cancel, "cancel");
  function finish() {
    globalState.isActive = false;
    unbindEvents3();
  }
  __name(finish, "finish");
  var unbindEvents3 = dist.bindAll(
    window,
    [{
      //  Note: we are repurposing the `dragover` event as our `drag` event
      // this is because firefox does not publish pointer coordinates during
      // a `drag` event, but does for every other type of drag event
      // `dragover` fires on all elements that are being dragged over
      // Because we are binding to `window` - our `dragover` is effectively the same as a `drag`
      // 
      type: "dragover",
      listener: /* @__PURE__ */ __name(function listener(event3) {
        onUpdateEvent(event3);
        dispatch.drag({
          current: state.current
        });
      }, "listener")
    }, {
      type: "dragenter",
      listener: onUpdateEvent
    }, {
      type: "dragleave",
      listener: /* @__PURE__ */ __name(function listener(event3) {
        if (!isLeavingWindow({
          dragLeave: event3
        })) {
          return;
        }
        updateState({
          input: state.current.input,
          dropTargets: []
        });
        if (dragType.startedFrom === "external") {
          cancel();
        }
      }, "listener")
    }, {
      // A "drop" can only happen if the browser allowed the drop
      type: "drop",
      listener: /* @__PURE__ */ __name(function listener(event3) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event3)
        };
        if (!state.current.dropTargets.length) {
          cancel();
          return;
        }
        event3.preventDefault();
        setDropEffectOnEvent({
          event: event3,
          current: state.current.dropTargets
        });
        dispatch.drop({
          current: state.current,
          // When dropping something native, we need to extract the latest
          // `.items` from the "drop" event as it is now accessible
          updatedSourcePayload: dragType.type === "external" ? dragType.getDropPayload(event3) : null
        });
        finish();
      }, "listener")
    }, {
      // "dragend" fires when on the drag source (eg a draggable element)
      // when the drag is finished.
      // "dragend" will fire after "drop" (if there was a successful drop)
      // "dragend" does not fire if the draggable source has been removed during the drag
      // or for external drag sources (eg files)
      // This "dragend" listener will not fire if there was a successful drop
      // as we will have already removed the event listener
      type: "dragend",
      listener: /* @__PURE__ */ __name(function listener(event3) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event3)
        };
        cancel();
      }, "listener")
    }].concat(_toConsumableArray$3(getBindingsForBrokenDrags({
      onDragEnd: cancel
    }))),
    // Once we have started a managed drag operation it is important that we see / own all drag events
    // We got one adoption bug pop up where some code was stopping (`event.stopPropagation()`)
    // all "drop" events in the bubble phase on the `document.body`.
    // This meant that we never saw the "drop" event.
    {
      capture: true
    }
  );
  dispatch.start({
    nativeSetDragImage: getNativeSetDragImage(event2)
  });
}
__name(start, "start");
function setDropEffectOnEvent(_ref3) {
  var _current$;
  var event2 = _ref3.event, current = _ref3.current;
  var innerMost = (_current$ = current[0]) === null || _current$ === void 0 ? void 0 : _current$.dropEffect;
  if (innerMost != null && event2.dataTransfer) {
    event2.dataTransfer.dropEffect = innerMost;
  }
}
__name(setDropEffectOnEvent, "setDropEffectOnEvent");
function getStartLocation(_ref4) {
  var event2 = _ref4.event, dragType = _ref4.dragType, getDropTargetsOver = _ref4.getDropTargetsOver;
  var input = getInput(event2);
  if (dragType.startedFrom === "external") {
    return {
      input,
      dropTargets: []
    };
  }
  var dropTargets = getDropTargetsOver({
    input,
    source: dragType.payload,
    target: event2.target,
    current: []
  });
  return {
    input,
    dropTargets
  };
}
__name(getStartLocation, "getStartLocation");
var lifecycle = {
  canStart,
  start
};
var ledger = /* @__PURE__ */ new Map();
function registerUsage(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount;
  var entry = ledger.get(typeKey);
  if (entry) {
    entry.usageCount++;
    return entry;
  }
  var initial = {
    typeKey,
    unmount: mount2(),
    usageCount: 1
  };
  ledger.set(typeKey, initial);
  return initial;
}
__name(registerUsage, "registerUsage");
function register(args) {
  var entry = registerUsage(args);
  return /* @__PURE__ */ __name(function unregister() {
    entry.usageCount--;
    if (entry.usageCount > 0) {
      return;
    }
    entry.unmount();
    ledger.delete(args.typeKey);
  }, "unregister");
}
__name(register, "register");
function combine() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return /* @__PURE__ */ __name(function cleanup() {
    fns.forEach(function(fn) {
      return fn();
    });
  }, "cleanup");
}
__name(combine, "combine");
function addAttribute(element, _ref) {
  var attribute = _ref.attribute, value3 = _ref.value;
  element.setAttribute(attribute, value3);
  return function() {
    return element.removeAttribute(attribute);
  };
}
__name(addAttribute, "addAttribute");
function ownKeys$7(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$7, "ownKeys$7");
function _objectSpread$7(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$7(Object(t), true).forEach(function(r2) {
      _defineProperty$6(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$7, "_objectSpread$7");
function _createForOfIteratorHelper$2(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$5(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F2");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e2"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e2"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$2, "_createForOfIteratorHelper$2");
function _unsupportedIterableToArray$5(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$5(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$5(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$5, "_unsupportedIterableToArray$5");
function _arrayLikeToArray$5(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$5, "_arrayLikeToArray$5");
function copyReverse(array) {
  return array.slice(0).reverse();
}
__name(copyReverse, "copyReverse");
function makeDropTarget(_ref) {
  var typeKey = _ref.typeKey, defaultDropEffect = _ref.defaultDropEffect;
  var registry = /* @__PURE__ */ new WeakMap();
  var dropTargetDataAtt = "data-drop-target-for-".concat(typeKey);
  var dropTargetSelector = "[".concat(dropTargetDataAtt, "]");
  function addToRegistry2(args) {
    registry.set(args.element, args);
    return function() {
      return registry.delete(args.element);
    };
  }
  __name(addToRegistry2, "addToRegistry");
  function dropTargetForConsumers(args) {
    if (false) {
      var existing = registry.get(args.element);
      if (existing) {
        console.warn("You have already registered a [".concat(typeKey, "] dropTarget on the same element"), {
          existing,
          proposed: args
        });
      }
      if (args.element instanceof HTMLIFrameElement) {
        console.warn("\n            We recommend not registering <iframe> elements as drop targets\n            as it can result in some strange browser event ordering.\n          ".replace(/\s{2,}/g, " ").trim());
      }
    }
    return combine(addAttribute(args.element, {
      attribute: dropTargetDataAtt,
      value: "true"
    }), addToRegistry2(args));
  }
  __name(dropTargetForConsumers, "dropTargetForConsumers");
  function getActualDropTargets(_ref2) {
    var _args$getData, _args$getData2, _args$getDropEffect, _args$getDropEffect2;
    var source = _ref2.source, target = _ref2.target, input = _ref2.input, _ref2$result = _ref2.result, result = _ref2$result === void 0 ? [] : _ref2$result;
    if (target == null) {
      return result;
    }
    if (!(target instanceof Element)) {
      if (target instanceof Node) {
        return getActualDropTargets({
          source,
          target: target.parentElement,
          input,
          result
        });
      }
      return result;
    }
    var closest = target.closest(dropTargetSelector);
    if (closest == null) {
      return result;
    }
    var args = registry.get(closest);
    if (args == null) {
      return result;
    }
    var feedback = {
      input,
      source,
      element: args.element
    };
    if (args.canDrop && !args.canDrop(feedback)) {
      return getActualDropTargets({
        source,
        target: args.element.parentElement,
        input,
        result
      });
    }
    var data22 = (_args$getData = (_args$getData2 = args.getData) === null || _args$getData2 === void 0 ? void 0 : _args$getData2.call(args, feedback)) !== null && _args$getData !== void 0 ? _args$getData : {};
    var dropEffect = (_args$getDropEffect = (_args$getDropEffect2 = args.getDropEffect) === null || _args$getDropEffect2 === void 0 ? void 0 : _args$getDropEffect2.call(args, feedback)) !== null && _args$getDropEffect !== void 0 ? _args$getDropEffect : defaultDropEffect;
    var record = {
      data: data22,
      element: args.element,
      dropEffect,
      // we are collecting _actual_ drop targets, so these are
      // being applied _not_ due to stickiness
      isActiveDueToStickiness: false
    };
    return getActualDropTargets({
      source,
      target: args.element.parentElement,
      input,
      // Using bubble ordering. Same ordering as `event.getPath()`
      result: [].concat(_toConsumableArray$3(result), [record])
    });
  }
  __name(getActualDropTargets, "getActualDropTargets");
  function notifyCurrent(_ref3) {
    var eventName = _ref3.eventName, payload = _ref3.payload;
    var _iterator = _createForOfIteratorHelper$2(payload.location.current.dropTargets), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _entry$eventName;
        var record = _step.value;
        var entry = registry.get(record.element);
        var args = _objectSpread$7(_objectSpread$7({}, payload), {}, {
          self: record
        });
        entry === null || entry === void 0 || (_entry$eventName = entry[eventName]) === null || _entry$eventName === void 0 || _entry$eventName.call(
          entry,
          // I cannot seem to get the types right here.
          // TS doesn't seem to like that one event can need `nativeSetDragImage`
          // @ts-expect-error
          args
        );
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  __name(notifyCurrent, "notifyCurrent");
  var actions = {
    onGenerateDragPreview: notifyCurrent,
    onDrag: notifyCurrent,
    onDragStart: notifyCurrent,
    onDrop: notifyCurrent,
    onDropTargetChange: /* @__PURE__ */ __name(function onDropTargetChange(_ref4) {
      var payload = _ref4.payload;
      var isCurrent = new Set(payload.location.current.dropTargets.map(function(record2) {
        return record2.element;
      }));
      var visited = /* @__PURE__ */ new Set();
      var _iterator2 = _createForOfIteratorHelper$2(payload.location.previous.dropTargets), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _entry$onDropTargetCh;
          var record = _step2.value;
          visited.add(record.element);
          var entry = registry.get(record.element);
          var isOver = isCurrent.has(record.element);
          var args = _objectSpread$7(_objectSpread$7({}, payload), {}, {
            self: record
          });
          entry === null || entry === void 0 || (_entry$onDropTargetCh = entry.onDropTargetChange) === null || _entry$onDropTargetCh === void 0 || _entry$onDropTargetCh.call(entry, args);
          if (!isOver) {
            var _entry$onDragLeave;
            entry === null || entry === void 0 || (_entry$onDragLeave = entry.onDragLeave) === null || _entry$onDragLeave === void 0 || _entry$onDragLeave.call(entry, args);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper$2(payload.location.current.dropTargets), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _entry$onDropTargetCh2, _entry$onDragEnter;
          var _record = _step3.value;
          if (visited.has(_record.element)) {
            continue;
          }
          var _args = _objectSpread$7(_objectSpread$7({}, payload), {}, {
            self: _record
          });
          var _entry = registry.get(_record.element);
          _entry === null || _entry === void 0 || (_entry$onDropTargetCh2 = _entry.onDropTargetChange) === null || _entry$onDropTargetCh2 === void 0 || _entry$onDropTargetCh2.call(_entry, _args);
          _entry === null || _entry === void 0 || (_entry$onDragEnter = _entry.onDragEnter) === null || _entry$onDragEnter === void 0 || _entry$onDragEnter.call(_entry, _args);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }, "onDropTargetChange")
  };
  function dispatchEvent(args) {
    actions[args.eventName](args);
  }
  __name(dispatchEvent, "dispatchEvent");
  function getIsOver(_ref5) {
    var source = _ref5.source, target = _ref5.target, input = _ref5.input, current = _ref5.current;
    var actual = getActualDropTargets({
      source,
      target,
      input
    });
    if (actual.length >= current.length) {
      return actual;
    }
    var lastCaptureOrdered = copyReverse(current);
    var actualCaptureOrdered = copyReverse(actual);
    var resultCaptureOrdered = [];
    for (var index2 = 0; index2 < lastCaptureOrdered.length; index2++) {
      var _argsForLast$getIsSti;
      var last = lastCaptureOrdered[index2];
      var fresh = actualCaptureOrdered[index2];
      if (fresh != null) {
        resultCaptureOrdered.push(fresh);
        continue;
      }
      var parent = resultCaptureOrdered[index2 - 1];
      var lastParent = lastCaptureOrdered[index2 - 1];
      if ((parent === null || parent === void 0 ? void 0 : parent.element) !== (lastParent === null || lastParent === void 0 ? void 0 : lastParent.element)) {
        break;
      }
      var argsForLast = registry.get(last.element);
      if (!argsForLast) {
        break;
      }
      var feedback = {
        input,
        source,
        element: argsForLast.element
      };
      if (argsForLast.canDrop && !argsForLast.canDrop(feedback)) {
        break;
      }
      if (!((_argsForLast$getIsSti = argsForLast.getIsSticky) !== null && _argsForLast$getIsSti !== void 0 && _argsForLast$getIsSti.call(argsForLast, feedback))) {
        break;
      }
      resultCaptureOrdered.push(_objectSpread$7(_objectSpread$7({}, last), {}, {
        // making it clear to consumers this drop target is active due to stickiness
        isActiveDueToStickiness: true
      }));
    }
    return copyReverse(resultCaptureOrdered);
  }
  __name(getIsOver, "getIsOver");
  return {
    dropTargetForConsumers,
    getIsOver,
    dispatchEvent
  };
}
__name(makeDropTarget, "makeDropTarget");
function _createForOfIteratorHelper$1(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$4(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper$1, "_createForOfIteratorHelper$1");
function _unsupportedIterableToArray$4(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$4(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$4, "_unsupportedIterableToArray$4");
function _arrayLikeToArray$4(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$4, "_arrayLikeToArray$4");
function ownKeys$6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$6, "ownKeys$6");
function _objectSpread$6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$6(Object(t), true).forEach(function(r2) {
      _defineProperty$6(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$6, "_objectSpread$6");
function makeMonitor() {
  var registry = /* @__PURE__ */ new Set();
  var dragging = null;
  function tryAddToActive(monitor) {
    if (!dragging) {
      return;
    }
    if (!monitor.canMonitor || monitor.canMonitor(dragging.canMonitorArgs)) {
      dragging.active.add(monitor);
    }
  }
  __name(tryAddToActive, "tryAddToActive");
  function monitorForConsumers(args) {
    var entry = _objectSpread$6({}, args);
    registry.add(entry);
    tryAddToActive(entry);
    return /* @__PURE__ */ __name(function cleanup() {
      registry.delete(entry);
      if (dragging) {
        dragging.active.delete(entry);
      }
    }, "cleanup");
  }
  __name(monitorForConsumers, "monitorForConsumers");
  function dispatchEvent(_ref) {
    var eventName = _ref.eventName, payload = _ref.payload;
    if (eventName === "onGenerateDragPreview") {
      dragging = {
        canMonitorArgs: {
          initial: payload.location.initial,
          source: payload.source
        },
        active: /* @__PURE__ */ new Set()
      };
      var _iterator = _createForOfIteratorHelper$1(registry), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var monitor = _step.value;
          tryAddToActive(monitor);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    if (!dragging) {
      return;
    }
    var active3 = Array.from(dragging.active);
    for (var _i = 0, _active = active3; _i < _active.length; _i++) {
      var _monitor = _active[_i];
      if (dragging.active.has(_monitor)) {
        var _monitor$eventName;
        (_monitor$eventName = _monitor[eventName]) === null || _monitor$eventName === void 0 || _monitor$eventName.call(_monitor, payload);
      }
    }
    if (eventName === "onDrop") {
      dragging.active.clear();
      dragging = null;
    }
  }
  __name(dispatchEvent, "dispatchEvent");
  return {
    dispatchEvent,
    monitorForConsumers
  };
}
__name(makeMonitor, "makeMonitor");
function makeAdapter(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount, dispatchEventToSource2 = _ref.dispatchEventToSource, onPostDispatch = _ref.onPostDispatch, defaultDropEffect = _ref.defaultDropEffect;
  var monitorAPI = makeMonitor();
  var dropTargetAPI = makeDropTarget({
    typeKey,
    defaultDropEffect
  });
  function dispatchEvent(args) {
    dispatchEventToSource2 === null || dispatchEventToSource2 === void 0 || dispatchEventToSource2(args);
    dropTargetAPI.dispatchEvent(args);
    monitorAPI.dispatchEvent(args);
    onPostDispatch === null || onPostDispatch === void 0 || onPostDispatch(args);
  }
  __name(dispatchEvent, "dispatchEvent");
  function start2(_ref2) {
    var event2 = _ref2.event, dragType = _ref2.dragType;
    lifecycle.start({
      event: event2,
      dragType,
      getDropTargetsOver: dropTargetAPI.getIsOver,
      dispatchEvent
    });
  }
  __name(start2, "start");
  function registerUsage2() {
    function mountAdapter() {
      var api2 = {
        canStart: lifecycle.canStart,
        start: start2
      };
      return mount2(api2);
    }
    __name(mountAdapter, "mountAdapter");
    return register({
      typeKey,
      mount: mountAdapter
    });
  }
  __name(registerUsage2, "registerUsage");
  return {
    registerUsage: registerUsage2,
    dropTarget: dropTargetAPI.dropTargetForConsumers,
    monitor: monitorAPI.monitorForConsumers
  };
}
__name(makeAdapter, "makeAdapter");
var isAndroid = once(/* @__PURE__ */ __name(function isAndroid2() {
  return navigator.userAgent.toLocaleLowerCase().includes("android");
}, "isAndroid"));
var androidFallbackText = "pdnd:android-fallback";
var textMediaType = "text/plain";
var URLMediaType = "text/uri-list";
var elementAdapterNativeDataKey = "application/vnd.pdnd";
var draggableRegistry = /* @__PURE__ */ new WeakMap();
function addToRegistry(args) {
  draggableRegistry.set(args.element, args);
  return /* @__PURE__ */ __name(function cleanup() {
    draggableRegistry.delete(args.element);
  }, "cleanup");
}
__name(addToRegistry, "addToRegistry");
var honeyPotFix = makeHoneyPotFix();
var adapter = makeAdapter({
  typeKey: "element",
  defaultDropEffect: "move",
  mount: /* @__PURE__ */ __name(function mount(api2) {
    return combine(honeyPotFix.bindEvents(), dist.bind(document, {
      type: "dragstart",
      listener: /* @__PURE__ */ __name(function listener(event2) {
        var _entry$dragHandle, _entry$getInitialData, _entry$getInitialData2, _entry$dragHandle2, _entry$getInitialData3, _entry$getInitialData4;
        if (!api2.canStart(event2)) {
          return;
        }
        if (event2.defaultPrevented) {
          return;
        }
        if (!event2.dataTransfer) {
          if (false) {
            console.warn("\n              It appears as though you have are not testing DragEvents correctly.\n\n              - If you are unit testing, ensure you have polyfilled DragEvent.\n              - If you are browser testing, ensure you are dispatching drag events correctly.\n\n              Please see our testing guides for more information:\n              https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n            ".replace(/ {2}/g, ""));
          }
          return;
        }
        var target = event2.target;
        if (!(target instanceof HTMLElement)) {
          return null;
        }
        var entry = draggableRegistry.get(target);
        if (!entry) {
          return null;
        }
        var input = getInput(event2);
        var feedback = {
          element: entry.element,
          dragHandle: (_entry$dragHandle = entry.dragHandle) !== null && _entry$dragHandle !== void 0 ? _entry$dragHandle : null,
          input
        };
        if (entry.canDrag && !entry.canDrag(feedback)) {
          event2.preventDefault();
          return null;
        }
        if (entry.dragHandle) {
          var over = getElementFromPointWithoutHoneypot({
            x: input.clientX,
            y: input.clientY
          });
          if (!entry.dragHandle.contains(over)) {
            event2.preventDefault();
            return null;
          }
        }
        var nativeData = (_entry$getInitialData = (_entry$getInitialData2 = entry.getInitialDataForExternal) === null || _entry$getInitialData2 === void 0 ? void 0 : _entry$getInitialData2.call(entry, feedback)) !== null && _entry$getInitialData !== void 0 ? _entry$getInitialData : null;
        if (nativeData) {
          for (var _i = 0, _Object$entries = Object.entries(nativeData); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2), key = _Object$entries$_i[0], data22 = _Object$entries$_i[1];
            event2.dataTransfer.setData(key, data22 !== null && data22 !== void 0 ? data22 : "");
          }
        }
        if (isAndroid() && !event2.dataTransfer.types.includes(textMediaType) && !event2.dataTransfer.types.includes(URLMediaType)) {
          event2.dataTransfer.setData(textMediaType, androidFallbackText);
        }
        event2.dataTransfer.setData(elementAdapterNativeDataKey, "");
        var payload = {
          element: entry.element,
          dragHandle: (_entry$dragHandle2 = entry.dragHandle) !== null && _entry$dragHandle2 !== void 0 ? _entry$dragHandle2 : null,
          data: (_entry$getInitialData3 = (_entry$getInitialData4 = entry.getInitialData) === null || _entry$getInitialData4 === void 0 ? void 0 : _entry$getInitialData4.call(entry, feedback)) !== null && _entry$getInitialData3 !== void 0 ? _entry$getInitialData3 : {}
        };
        var dragType = {
          type: "element",
          payload,
          startedFrom: "internal"
        };
        api2.start({
          event: event2,
          dragType
        });
      }, "listener")
    }));
  }, "mount"),
  dispatchEventToSource: /* @__PURE__ */ __name(function dispatchEventToSource(_ref) {
    var _draggableRegistry$ge, _draggableRegistry$ge2;
    var eventName = _ref.eventName, payload = _ref.payload;
    (_draggableRegistry$ge = draggableRegistry.get(payload.source.element)) === null || _draggableRegistry$ge === void 0 || (_draggableRegistry$ge2 = _draggableRegistry$ge[eventName]) === null || _draggableRegistry$ge2 === void 0 || _draggableRegistry$ge2.call(
      _draggableRegistry$ge,
      // I cannot seem to get the types right here.
      // TS doesn't seem to like that one event can need `nativeSetDragImage`
      // @ts-expect-error
      payload
    );
  }, "dispatchEventToSource"),
  onPostDispatch: honeyPotFix.getOnPostDispatch()
});
var dropTargetForElements = adapter.dropTarget;
var monitorForElements = adapter.monitor;
function draggable(args) {
  if (false) {
    if (args.dragHandle && !args.element.contains(args.dragHandle)) {
      console.warn("Drag handle element must be contained in draggable element", {
        element: args.element,
        dragHandle: args.dragHandle
      });
    }
  }
  if (false) {
    var existing = draggableRegistry.get(args.element);
    if (existing) {
      console.warn("You have already registered a `draggable` on the same element", {
        existing,
        proposed: args
      });
    }
  }
  return combine(
    // making the draggable register the adapter rather than drop targets
    // this is because you *must* have a draggable element to start a drag
    // but you _might_ not have any drop targets immediately
    // (You might create drop targets async)
    adapter.registerUsage(),
    addToRegistry(args),
    addAttribute(args.element, {
      attribute: "draggable",
      value: "true"
    })
  );
}
__name(draggable, "draggable");
function usePragmaticDroppable(dropTargetElement, options3) {
  let cleanup = /* @__PURE__ */ __name(() => {
  }, "cleanup");
  onMounted(() => {
    const element = typeof dropTargetElement === "function" ? dropTargetElement() : dropTargetElement;
    if (!element) {
      return;
    }
    cleanup = dropTargetForElements({
      element,
      ...options3
    });
  });
  onBeforeUnmount(() => {
    cleanup();
  });
}
__name(usePragmaticDroppable, "usePragmaticDroppable");
function usePragmaticDraggable(draggableElement, options3) {
  let cleanup = /* @__PURE__ */ __name(() => {
  }, "cleanup");
  onMounted(() => {
    const element = typeof draggableElement === "function" ? draggableElement() : draggableElement;
    if (!element) {
      return;
    }
    cleanup = draggable({
      element,
      ...options3
    });
  });
  onBeforeUnmount(() => {
    cleanup();
  });
}
__name(usePragmaticDraggable, "usePragmaticDraggable");
const _withScopeId$b = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-d8fc59be"), n = n(), popScopeId(), n), "_withScopeId$b");
const _hoisted_1$u = { class: "node-content" };
const _hoisted_2$j = { class: "node-label" };
const _hoisted_3$b = { class: "node-actions" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "TreeExplorerTreeNode",
  props: {
    node: {}
  },
  emits: ["itemDropped", "dragStart", "dragEnd"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const nodeBadgeText = computed(() => {
      if (props.node.leaf) {
        return "";
      }
      if (props.node.badgeText !== void 0 && props.node.badgeText !== null) {
        return props.node.badgeText;
      }
      return props.node.totalLeaves.toString();
    });
    const showNodeBadgeText = computed(() => nodeBadgeText.value !== "");
    const labelEditable = computed(() => !!props.node.handleRename);
    const renameEditingNode = inject("renameEditingNode");
    const isEditing = computed(
      () => labelEditable.value && renameEditingNode.value?.key === props.node.key
    );
    const errorHandling = useErrorHandling();
    const handleRename = errorHandling.wrapWithErrorHandlingAsync(
      async (newName) => {
        await props.node.handleRename(props.node, newName);
      },
      props.node.handleError,
      () => {
        renameEditingNode.value = null;
      }
    );
    const container = ref(null);
    const canDrop = ref(false);
    const treeNodeElementGetter = /* @__PURE__ */ __name(() => container.value?.closest(".p-tree-node-content"), "treeNodeElementGetter");
    if (props.node.draggable) {
      usePragmaticDraggable(treeNodeElementGetter, {
        getInitialData: /* @__PURE__ */ __name(() => {
          return {
            type: "tree-explorer-node",
            data: props.node
          };
        }, "getInitialData"),
        onDragStart: /* @__PURE__ */ __name(() => emit2("dragStart", props.node), "onDragStart"),
        onDrop: /* @__PURE__ */ __name(() => emit2("dragEnd", props.node), "onDrop")
      });
    }
    if (props.node.droppable) {
      usePragmaticDroppable(treeNodeElementGetter, {
        onDrop: /* @__PURE__ */ __name(async (event2) => {
          const dndData = event2.source.data;
          if (dndData.type === "tree-explorer-node") {
            await props.node.handleDrop?.(props.node, dndData);
            canDrop.value = false;
            emit2("itemDropped", props.node, dndData.data);
          }
        }, "onDrop"),
        onDragEnter: /* @__PURE__ */ __name((event2) => {
          const dndData = event2.source.data;
          if (dndData.type === "tree-explorer-node") {
            canDrop.value = true;
          }
        }, "onDragEnter"),
        onDragLeave: /* @__PURE__ */ __name(() => {
          canDrop.value = false;
        }, "onDragLeave")
      });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          "tree-node",
          {
            "can-drop": canDrop.value,
            "tree-folder": !props.node.leaf,
            "tree-leaf": props.node.leaf
          }
        ]),
        ref_key: "container",
        ref: container
      }, [
        createBaseVNode("div", _hoisted_1$u, [
          createBaseVNode("span", _hoisted_2$j, [
            renderSlot(_ctx.$slots, "before-label", {
              node: props.node
            }, void 0, true),
            createVNode(EditableText, {
              modelValue: _ctx.node.label,
              isEditing: isEditing.value,
              onEdit: unref(handleRename)
            }, null, 8, ["modelValue", "isEditing", "onEdit"]),
            renderSlot(_ctx.$slots, "after-label", {
              node: props.node
            }, void 0, true)
          ]),
          showNodeBadgeText.value ? (openBlock(), createBlock(unref(script$N), {
            key: 0,
            value: nodeBadgeText.value,
            severity: "secondary",
            class: "leaf-count-badge"
          }, null, 8, ["value"])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_3$b, [
          renderSlot(_ctx.$slots, "actions", {
            node: props.node
          }, void 0, true)
        ])
      ], 2);
    };
  }
});
const TreeExplorerTreeNode = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-d8fc59be"]]);
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "TreeExplorer",
  props: /* @__PURE__ */ mergeModels({
    roots: {},
    class: {}
  }, {
    "expandedKeys": {},
    "expandedKeysModifiers": {},
    "selectionKeys": {},
    "selectionKeysModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["nodeClick", "nodeDelete", "contextMenu"], ["update:expandedKeys", "update:selectionKeys"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const expandedKeys2 = useModel(__props, "expandedKeys");
    provide("expandedKeys", expandedKeys2);
    const selectionKeys = useModel(__props, "selectionKeys");
    provide("selectionKeys", selectionKeys);
    const storeSelectionKeys = selectionKeys.value !== void 0;
    const props = __props;
    const emit2 = __emit;
    const renderedRoots = computed(() => {
      return props.roots.map(fillNodeInfo);
    });
    const getTreeNodeIcon = /* @__PURE__ */ __name((node3) => {
      if (node3.getIcon) {
        const icon2 = node3.getIcon(node3);
        if (icon2) {
          return icon2;
        }
      } else if (node3.icon) {
        return node3.icon;
      }
      if (node3.leaf) {
        return "pi pi-file";
      }
      const isExpanded = expandedKeys2.value[node3.key];
      return isExpanded ? "pi pi-folder-open" : "pi pi-folder";
    }, "getTreeNodeIcon");
    const fillNodeInfo = /* @__PURE__ */ __name((node3) => {
      const children = node3.children?.map(fillNodeInfo);
      const totalLeaves = node3.leaf ? 1 : children.reduce((acc, child) => acc + child.totalLeaves, 0);
      return {
        ...node3,
        icon: getTreeNodeIcon(node3),
        children,
        type: node3.leaf ? "node" : "folder",
        totalLeaves,
        badgeText: node3.getBadgeText ? node3.getBadgeText(node3) : null
      };
    }, "fillNodeInfo");
    const onNodeContentClick = /* @__PURE__ */ __name(async (e, node3) => {
      if (!storeSelectionKeys) {
        selectionKeys.value = {};
      }
      if (node3.handleClick) {
        await node3.handleClick(node3, e);
      }
      emit2("nodeClick", node3, e);
    }, "onNodeContentClick");
    const menu = ref(null);
    const menuTargetNode = ref(null);
    provide("menuTargetNode", menuTargetNode);
    const extraMenuItems = computed(() => {
      return menuTargetNode.value?.contextMenuItems ? typeof menuTargetNode.value.contextMenuItems === "function" ? menuTargetNode.value.contextMenuItems(menuTargetNode.value) : menuTargetNode.value.contextMenuItems : [];
    });
    const renameEditingNode = ref(null);
    provide("renameEditingNode", renameEditingNode);
    const { t } = useI18n();
    const renameCommand = /* @__PURE__ */ __name((node3) => {
      renameEditingNode.value = node3;
    }, "renameCommand");
    const deleteCommand = /* @__PURE__ */ __name(async (node3) => {
      await node3.handleDelete?.(node3);
      emit2("nodeDelete", node3);
    }, "deleteCommand");
    const menuItems = computed(
      () => [
        {
          label: t("rename"),
          icon: "pi pi-file-edit",
          command: /* @__PURE__ */ __name(() => renameCommand(menuTargetNode.value), "command"),
          visible: menuTargetNode.value?.handleRename !== void 0
        },
        {
          label: t("delete"),
          icon: "pi pi-trash",
          command: /* @__PURE__ */ __name(() => deleteCommand(menuTargetNode.value), "command"),
          visible: menuTargetNode.value?.handleDelete !== void 0,
          isAsync: true
          // The delete command can be async
        },
        ...extraMenuItems.value
      ].map((menuItem) => ({
        ...menuItem,
        command: wrapCommandWithErrorHandler(menuItem.command, {
          isAsync: menuItem.isAsync ?? false
        })
      }))
    );
    const handleContextMenu = /* @__PURE__ */ __name((node3, e) => {
      menuTargetNode.value = node3;
      emit2("contextMenu", node3, e);
      if (menuItems.value.filter((item2) => item2.visible).length > 0) {
        menu.value?.show(e);
      }
    }, "handleContextMenu");
    const errorHandling = useErrorHandling();
    const wrapCommandWithErrorHandler = /* @__PURE__ */ __name((command, { isAsync: isAsync2 = false }) => {
      return isAsync2 ? errorHandling.wrapWithErrorHandlingAsync(
        command,
        menuTargetNode.value?.handleError
      ) : errorHandling.wrapWithErrorHandling(
        command,
        menuTargetNode.value?.handleError
      );
    }, "wrapCommandWithErrorHandler");
    __expose({
      renameCommand,
      deleteCommand
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(script$i), {
          class: normalizeClass(["tree-explorer py-0 px-2 2xl:px-4", props.class]),
          expandedKeys: expandedKeys2.value,
          "onUpdate:expandedKeys": _cache[0] || (_cache[0] = ($event) => expandedKeys2.value = $event),
          selectionKeys: selectionKeys.value,
          "onUpdate:selectionKeys": _cache[1] || (_cache[1] = ($event) => selectionKeys.value = $event),
          value: renderedRoots.value,
          selectionMode: "single",
          pt: {
            nodeLabel: "tree-explorer-node-label",
            nodeContent: /* @__PURE__ */ __name(({ props: props2 }) => ({
              onClick: /* @__PURE__ */ __name((e) => onNodeContentClick(e, props2.node), "onClick"),
              onContextmenu: /* @__PURE__ */ __name((e) => handleContextMenu(props2.node, e), "onContextmenu")
            }), "nodeContent"),
            nodeToggleButton: /* @__PURE__ */ __name(() => ({
              onClick: /* @__PURE__ */ __name((e) => {
                e.stopImmediatePropagation();
              }, "onClick")
            }), "nodeToggleButton")
          }
        }, {
          folder: withCtx(({ node: node3 }) => [
            renderSlot(_ctx.$slots, "folder", { node: node3 }, () => [
              createVNode(TreeExplorerTreeNode, { node: node3 }, null, 8, ["node"])
            ], true)
          ]),
          node: withCtx(({ node: node3 }) => [
            renderSlot(_ctx.$slots, "node", { node: node3 }, () => [
              createVNode(TreeExplorerTreeNode, { node: node3 }, null, 8, ["node"])
            ], true)
          ]),
          _: 3
        }, 8, ["class", "expandedKeys", "selectionKeys", "value", "pt"]),
        createVNode(unref(script$g), {
          ref_key: "menu",
          ref: menu,
          model: menuItems.value
        }, null, 8, ["model"])
      ], 64);
    };
  }
});
const TreeExplorer = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-b7c3d32e"]]);
var theme$9 = /* @__PURE__ */ __name(function theme28(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-toolbar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-wrap: wrap;\n    padding: ".concat(dt2("toolbar.padding"), ";\n    background: ").concat(dt2("toolbar.background"), ";\n    border: 1px solid ").concat(dt2("toolbar.border.color"), ";\n    color: ").concat(dt2("toolbar.color"), ";\n    border-radius: ").concat(dt2("toolbar.border.radius"), ";\n    gap: ").concat(dt2("toolbar.gap"), ";\n}\n\n.p-toolbar-start,\n.p-toolbar-center,\n.p-toolbar-end {\n    display: flex;\n    align-items: center;\n}\n");
}, "theme");
var classes$9 = {
  root: "p-toolbar p-component",
  start: "p-toolbar-start",
  center: "p-toolbar-center",
  end: "p-toolbar-end"
};
var ToolbarStyle = BaseStyle.extend({
  name: "toolbar",
  theme: theme$9,
  classes: classes$9
});
var script$1$8 = {
  name: "BaseToolbar",
  "extends": script$Y,
  props: {
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: ToolbarStyle,
  provide: /* @__PURE__ */ __name(function provide30() {
    return {
      $pcToolbar: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$f = {
  name: "Toolbar",
  "extends": script$1$8,
  inheritAttrs: false
};
var _hoisted_1$t = ["aria-labelledby"];
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "toolbar",
    "aria-labelledby": _ctx.ariaLabelledby
  }, _ctx.ptmi("root")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("start")
  }, _ctx.ptm("start")), [renderSlot(_ctx.$slots, "start")], 16), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("center")
  }, _ctx.ptm("center")), [renderSlot(_ctx.$slots, "center")], 16), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("end")
  }, _ctx.ptm("end")), [renderSlot(_ctx.$slots, "end")], 16)], 16, _hoisted_1$t);
}
__name(render$e, "render$e");
script$f.render = render$e;
const _withScopeId$a = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-100ab5c6"), n = n(), popScopeId(), n), "_withScopeId$a");
const _hoisted_1$s = { class: "comfy-vue-side-bar-header" };
const _hoisted_2$i = { class: "text-sm" };
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "SidebarTabTemplate",
  props: {
    title: {},
    class: {}
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["comfy-vue-side-bar-container flex flex-col h-full", props.class])
      }, [
        createBaseVNode("div", _hoisted_1$s, [
          createVNode(unref(script$f), { class: "flex-shrink-0 border-x-0 border-t-0 rounded-none px-2 py-1 min-h-8" }, {
            start: withCtx(() => [
              createBaseVNode("span", _hoisted_2$i, toDisplayString$1(props.title.toUpperCase()), 1)
            ]),
            end: withCtx(() => [
              renderSlot(_ctx.$slots, "tool-buttons", {}, void 0, true)
            ]),
            _: 3
          }),
          renderSlot(_ctx.$slots, "header", {}, void 0, true)
        ]),
        createVNode(unref(script$F), { class: "comfy-vue-side-bar-body flex-grow h-0" }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "body", {}, void 0, true)
          ]),
          _: 3
        })
      ], 2);
    };
  }
});
const SidebarTabTemplate = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-100ab5c6"]]);
const _withScopeId$9 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-32e6c4d9"), n = n(), popScopeId(), n), "_withScopeId$9");
const _hoisted_1$r = { class: "model_preview" };
const _hoisted_2$h = { class: "model_preview_title" };
const _hoisted_3$a = { class: "model_preview_top_container" };
const _hoisted_4$7 = { class: "model_preview_filename" };
const _hoisted_5$5 = {
  key: 0,
  class: "model_preview_architecture"
};
const _hoisted_6$4 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("span", { class: "model_preview_prefix" }, "Architecture: ", -1));
const _hoisted_7$3 = {
  key: 1,
  class: "model_preview_author"
};
const _hoisted_8$2 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("span", { class: "model_preview_prefix" }, "Author: ", -1));
const _hoisted_9$2 = {
  key: 0,
  class: "model_preview_image"
};
const _hoisted_10$2 = ["src"];
const _hoisted_11$2 = {
  key: 1,
  class: "model_preview_usage_hint"
};
const _hoisted_12$1 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("span", { class: "model_preview_prefix" }, "Usage hint: ", -1));
const _hoisted_13$1 = {
  key: 2,
  class: "model_preview_trigger_phrase"
};
const _hoisted_14 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("span", { class: "model_preview_prefix" }, "Trigger phrase: ", -1));
const _hoisted_15 = {
  key: 3,
  class: "model_preview_description"
};
const _hoisted_16 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("span", { class: "model_preview_prefix" }, "Description: ", -1));
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "ModelPreview",
  props: {
    modelDef: {
      type: ComfyModelDef,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const modelDef = props.modelDef;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$r, [
        createBaseVNode("div", _hoisted_2$h, toDisplayString$1(unref(modelDef).title), 1),
        createBaseVNode("div", _hoisted_3$a, [
          createBaseVNode("div", _hoisted_4$7, toDisplayString$1(unref(modelDef).file_name), 1),
          unref(modelDef).architecture_id ? (openBlock(), createElementBlock("div", _hoisted_5$5, [
            _hoisted_6$4,
            createTextVNode(" " + toDisplayString$1(unref(modelDef).architecture_id), 1)
          ])) : createCommentVNode("", true),
          unref(modelDef).author ? (openBlock(), createElementBlock("div", _hoisted_7$3, [
            _hoisted_8$2,
            createTextVNode(" " + toDisplayString$1(unref(modelDef).author), 1)
          ])) : createCommentVNode("", true)
        ]),
        unref(modelDef).image ? (openBlock(), createElementBlock("div", _hoisted_9$2, [
          createBaseVNode("img", {
            src: unref(modelDef).image
          }, null, 8, _hoisted_10$2)
        ])) : createCommentVNode("", true),
        unref(modelDef).usage_hint ? (openBlock(), createElementBlock("div", _hoisted_11$2, [
          _hoisted_12$1,
          createTextVNode(" " + toDisplayString$1(unref(modelDef).usage_hint), 1)
        ])) : createCommentVNode("", true),
        unref(modelDef).trigger_phrase ? (openBlock(), createElementBlock("div", _hoisted_13$1, [
          _hoisted_14,
          createTextVNode(" " + toDisplayString$1(unref(modelDef).trigger_phrase), 1)
        ])) : createCommentVNode("", true),
        unref(modelDef).description ? (openBlock(), createElementBlock("div", _hoisted_15, [
          _hoisted_16,
          createTextVNode(" " + toDisplayString$1(unref(modelDef).description), 1)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const ModelPreview = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-32e6c4d9"]]);
const _withScopeId$8 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-be871f15"), n = n(), popScopeId(), n), "_withScopeId$8");
const _hoisted_1$q = {
  key: 0,
  class: "model-lib-model-icon-container"
};
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "ModelTreeLeaf",
  props: {
    node: {}
  },
  setup(__props) {
    const props = __props;
    const modelDef = computed(() => props.node.data);
    const previewRef = ref(null);
    const modelPreviewStyle = ref({
      position: "absolute",
      top: "0px",
      left: "0px"
    });
    const settingStore = useSettingStore();
    const sidebarLocation = computed(
      () => settingStore.get("Comfy.Sidebar.Location")
    );
    const handleModelHover = /* @__PURE__ */ __name(async () => {
      const hoverTarget = modelContentElement.value;
      const targetRect = hoverTarget.getBoundingClientRect();
      const previewHeight = previewRef.value?.$el.offsetHeight || 0;
      const availableSpaceBelow = window.innerHeight - targetRect.bottom;
      modelPreviewStyle.value.top = previewHeight > availableSpaceBelow ? `${Math.max(0, targetRect.top - (previewHeight - availableSpaceBelow) - 20)}px` : `${targetRect.top - 40}px`;
      if (sidebarLocation.value === "left") {
        modelPreviewStyle.value.left = `${targetRect.right}px`;
      } else {
        modelPreviewStyle.value.left = `${targetRect.left - 400}px`;
      }
      modelDef.value.load();
    }, "handleModelHover");
    const container = ref(null);
    const modelContentElement = ref(null);
    const isHovered = ref(false);
    const showPreview = computed(() => {
      return isHovered.value && modelDef.value && modelDef.value.has_loaded_metadata && (modelDef.value.author || modelDef.value.simplified_file_name != modelDef.value.title || modelDef.value.description || modelDef.value.usage_hint || modelDef.value.trigger_phrase || modelDef.value.image);
    });
    const handleMouseEnter = /* @__PURE__ */ __name(async () => {
      isHovered.value = true;
      await nextTick();
      handleModelHover();
    }, "handleMouseEnter");
    const handleMouseLeave = /* @__PURE__ */ __name(() => {
      isHovered.value = false;
    }, "handleMouseLeave");
    onMounted(() => {
      modelContentElement.value = container.value?.closest(".p-tree-node-content");
      modelContentElement.value?.addEventListener("mouseenter", handleMouseEnter);
      modelContentElement.value?.addEventListener("mouseleave", handleMouseLeave);
      modelDef.value.load();
    });
    onUnmounted(() => {
      modelContentElement.value?.removeEventListener("mouseenter", handleMouseEnter);
      modelContentElement.value?.removeEventListener("mouseleave", handleMouseLeave);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container,
        class: "model-lib-node-container h-full w-full"
      }, [
        createVNode(TreeExplorerTreeNode, { node: _ctx.node }, {
          "before-label": withCtx(() => [
            modelDef.value && modelDef.value.image ? (openBlock(), createElementBlock("span", _hoisted_1$q, [
              createBaseVNode("span", {
                class: "model-lib-model-icon",
                style: normalizeStyle({ backgroundImage: `url(${modelDef.value.image})` })
              }, null, 4)
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["node"]),
        showPreview.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: "#model-library-model-preview-container"
        }, [
          createBaseVNode("div", {
            class: "model-lib-model-preview",
            style: normalizeStyle(modelPreviewStyle.value)
          }, [
            createVNode(ModelPreview, {
              ref_key: "previewRef",
              ref: previewRef,
              modelDef: modelDef.value
            }, null, 8, ["modelDef"])
          ], 4)
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});
const ModelTreeLeaf = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-be871f15"]]);
const _hoisted_1$p = { class: "flex flex-col" };
const _hoisted_2$g = { key: 0 };
const _hoisted_3$9 = {
  key: 1,
  class: "mt-2 flex flex-row items-center gap-2"
};
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "DownloadItem",
  props: {
    download: {}
  },
  setup(__props) {
    const { t } = useI18n();
    const electronDownloadStore = useElectronDownloadStore();
    const props = __props;
    const getDownloadLabel = /* @__PURE__ */ __name((savePath, filename) => {
      let parts2 = (savePath ?? "").split("/");
      parts2 = parts2.length === 1 ? parts2[0].split("\\") : parts2;
      const name = parts2.pop();
      const dir = parts2.pop();
      return `${dir}/${name}`;
    }, "getDownloadLabel");
    const triggerCancelDownload = /* @__PURE__ */ __name(() => electronDownloadStore.cancel(props.download.url), "triggerCancelDownload");
    const triggerPauseDownload = /* @__PURE__ */ __name(() => electronDownloadStore.pause(props.download.url), "triggerPauseDownload");
    const triggerResumeDownload = /* @__PURE__ */ __name(() => electronDownloadStore.resume(props.download.url), "triggerResumeDownload");
    const handleRemoveDownload = /* @__PURE__ */ __name(() => {
      electronDownloadStore.$patch((state) => {
        state.downloads = state.downloads.filter(
          ({ url }) => url !== props.download.url
        );
        state.hasChanged = true;
      });
    }, "handleRemoveDownload");
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        createBaseVNode("div", null, toDisplayString$1(getDownloadLabel(_ctx.download.savePath)), 1),
        ["cancelled", "error"].includes(_ctx.download.status) ? (openBlock(), createElementBlock("div", _hoisted_2$g, [
          createVNode(unref(script$t), {
            class: "h-6 text-sm font-light bg-red-700 mt-2",
            removable: "",
            onRemove: handleRemoveDownload
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(unref(t)("electronFileDownload.cancelled")), 1)
            ]),
            _: 1
          })
        ])) : createCommentVNode("", true),
        ["in_progress", "paused", "completed"].includes(_ctx.download.status) ? (openBlock(), createElementBlock("div", _hoisted_3$9, [
          createVNode(unref(script$K), {
            class: "flex-1",
            value: Number((_ctx.download.progress * 100).toFixed(1))
          }, null, 8, ["value"]),
          _ctx.download.status === "in_progress" ? withDirectives((openBlock(), createBlock(unref(script$M), {
            key: 0,
            class: "file-action-button w-[22px] h-[22px]",
            size: "small",
            rounded: "",
            onClick: triggerPauseDownload,
            icon: "pi pi-pause"
          }, null, 512)), [
            [
              _directive_tooltip,
              unref(t)("electronFileDownload.pause"),
              void 0,
              { top: true }
            ]
          ]) : createCommentVNode("", true),
          _ctx.download.status === "paused" ? withDirectives((openBlock(), createBlock(unref(script$M), {
            key: 1,
            class: "file-action-button w-[22px] h-[22px]",
            size: "small",
            rounded: "",
            onClick: triggerResumeDownload,
            icon: "pi pi-play"
          }, null, 512)), [
            [
              _directive_tooltip,
              unref(t)("electronFileDownload.resume"),
              void 0,
              { top: true }
            ]
          ]) : createCommentVNode("", true),
          ["in_progress", "paused"].includes(_ctx.download.status) ? withDirectives((openBlock(), createBlock(unref(script$M), {
            key: 2,
            class: "file-action-button w-[22px] h-[22px] p-red",
            size: "small",
            rounded: "",
            severity: "danger",
            onClick: triggerCancelDownload,
            icon: "pi pi-times-circle"
          }, null, 512)), [
            [
              _directive_tooltip,
              unref(t)("electronFileDownload.cancel"),
              void 0,
              { top: true }
            ]
          ]) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$o = {
  key: 0,
  class: "mx-6 mb-4"
};
const _hoisted_2$f = { class: "text-lg my-4" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "ElectronDownloadItems",
  setup(__props) {
    const electronDownloadStore = useElectronDownloadStore();
    const { downloads } = storeToRefs(electronDownloadStore);
    return (_ctx, _cache) => {
      return unref(downloads).length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$o, [
        createBaseVNode("div", _hoisted_2$f, toDisplayString$1(_ctx.$t("electronFileDownload.inProgress")), 1),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(downloads), (download2) => {
          return openBlock(), createBlock(_sfc_main$l, {
            key: download2.url,
            download: download2
          }, null, 8, ["download"]);
        }), 128))
      ])) : createCommentVNode("", true);
    };
  }
});
class ModelNodeProvider {
  static {
    __name(this, "ModelNodeProvider");
  }
  /** The node definition to use for this model. */
  nodeDef;
  /** The node input key for where to inside the model name. */
  key;
  constructor(nodeDef, key) {
    this.nodeDef = nodeDef;
    this.key = key;
  }
}
const useModelToNodeStore = /* @__PURE__ */ defineStore("modelToNode", () => {
  const modelToNodeMap = ref({});
  const nodeDefStore = useNodeDefStore();
  const haveDefaultsLoaded = ref(false);
  function getNodeProvider(modelType) {
    registerDefaults();
    return modelToNodeMap.value[modelType]?.[0];
  }
  __name(getNodeProvider, "getNodeProvider");
  function getAllNodeProviders(modelType) {
    registerDefaults();
    return modelToNodeMap.value[modelType] ?? [];
  }
  __name(getAllNodeProviders, "getAllNodeProviders");
  function registerNodeProvider(modelType, nodeProvider) {
    registerDefaults();
    if (!modelToNodeMap.value[modelType]) {
      modelToNodeMap.value[modelType] = [];
    }
    modelToNodeMap.value[modelType].push(nodeProvider);
  }
  __name(registerNodeProvider, "registerNodeProvider");
  function quickRegister(modelType, nodeClass, key) {
    registerNodeProvider(
      modelType,
      new ModelNodeProvider(nodeDefStore.nodeDefsByName[nodeClass], key)
    );
  }
  __name(quickRegister, "quickRegister");
  function registerDefaults() {
    if (haveDefaultsLoaded.value) {
      return;
    }
    if (Object.keys(nodeDefStore.nodeDefsByName).length === 0) {
      return;
    }
    haveDefaultsLoaded.value = true;
    quickRegister("checkpoints", "CheckpointLoaderSimple", "ckpt_name");
    quickRegister("checkpoints", "ImageOnlyCheckpointLoader", "ckpt_name");
    quickRegister("loras", "LoraLoader", "lora_name");
    quickRegister("loras", "LoraLoaderModelOnly", "lora_name");
    quickRegister("vae", "VAELoader", "vae_name");
    quickRegister("controlnet", "ControlNetLoader", "control_net_name");
  }
  __name(registerDefaults, "registerDefaults");
  return {
    modelToNodeMap,
    getNodeProvider,
    getAllNodeProviders,
    registerNodeProvider,
    quickRegister,
    registerDefaults
  };
});
function useTreeExpansion(expandedKeys2) {
  const toggleNode = /* @__PURE__ */ __name((node3) => {
    if (node3.key && typeof node3.key === "string") {
      if (node3.key in expandedKeys2.value) {
        delete expandedKeys2.value[node3.key];
      } else {
        expandedKeys2.value[node3.key] = true;
      }
    }
  }, "toggleNode");
  const toggleNodeRecursive = /* @__PURE__ */ __name((node3) => {
    if (node3.key && typeof node3.key === "string") {
      if (node3.key in expandedKeys2.value) {
        collapseNode(node3);
      } else {
        expandNode(node3);
      }
    }
  }, "toggleNodeRecursive");
  const expandNode = /* @__PURE__ */ __name((node3) => {
    if (node3.key && typeof node3.key === "string" && node3.children && node3.children.length) {
      expandedKeys2.value[node3.key] = true;
      for (const child of node3.children) {
        expandNode(child);
      }
    }
  }, "expandNode");
  const collapseNode = /* @__PURE__ */ __name((node3) => {
    if (node3.key && typeof node3.key === "string" && node3.children && node3.children.length) {
      delete expandedKeys2.value[node3.key];
      for (const child of node3.children) {
        collapseNode(child);
      }
    }
  }, "collapseNode");
  const toggleNodeOnEvent = /* @__PURE__ */ __name((e, node3) => {
    if (e.ctrlKey) {
      toggleNodeRecursive(node3);
    } else {
      toggleNode(node3);
    }
  }, "toggleNodeOnEvent");
  return {
    toggleNode,
    toggleNodeRecursive,
    expandNode,
    collapseNode,
    toggleNodeOnEvent
  };
}
__name(useTreeExpansion, "useTreeExpansion");
const _withScopeId$7 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-827f7782"), n = n(), popScopeId(), n), "_withScopeId$7");
const _hoisted_1$n = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("div", { id: "model-library-model-preview-container" }, null, -1));
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "ModelLibrarySidebarTab",
  setup(__props) {
    const modelStore = useModelStore();
    const modelToNodeStore = useModelToNodeStore();
    const settingStore = useSettingStore();
    const searchQuery = ref("");
    const expandedKeys2 = ref({});
    const { expandNode, toggleNodeOnEvent } = useTreeExpansion(expandedKeys2);
    const filteredModels = ref([]);
    const handleSearch = /* @__PURE__ */ __name(async (query) => {
      if (!query) {
        filteredModels.value = [];
        expandedKeys2.value = {};
        return;
      }
      await modelStore.loadModels();
      const search2 = query.toLocaleLowerCase();
      filteredModels.value = modelStore.models.filter((model) => {
        return model.searchable.includes(search2);
      });
      nextTick(() => {
        expandNode(root23.value);
      });
    }, "handleSearch");
    const root23 = computed(() => {
      const allNodes = searchQuery.value ? filteredModels.value : [...modelStore.modelFolders, ...modelStore.models];
      return buildTree(
        allNodes,
        (modelOrFolder) => modelOrFolder.key.split("/")
      );
    });
    const renderedRoot = computed(() => {
      const nameFormat = settingStore.get("Comfy.ModelLibrary.NameFormat");
      const fillNodeInfo = /* @__PURE__ */ __name((node3) => {
        const children = node3.children?.map(fillNodeInfo);
        const model = node3.leaf && node3.data ? node3.data : null;
        const folder = !node3.leaf && node3.data ? node3.data : null;
        return {
          key: node3.key,
          label: model ? nameFormat === "title" ? model.title : model.simplified_file_name : node3.label,
          leaf: node3.leaf,
          data: node3.data,
          getIcon: /* @__PURE__ */ __name(() => {
            if (model) {
              return model.image ? "pi pi-image" : "pi pi-file";
            }
            if (folder) {
              return folder.state === ResourceState.Loading ? "pi pi-spin pi-spinner" : "pi pi-folder";
            }
            return "pi pi-folder";
          }, "getIcon"),
          getBadgeText: /* @__PURE__ */ __name(() => {
            if (!folder) {
              return null;
            }
            return folder.state === ResourceState.Loaded ? null : "";
          }, "getBadgeText"),
          children,
          draggable: node3.leaf,
          handleClick: /* @__PURE__ */ __name((node22, e) => {
            if (node22.leaf) {
              const provider = modelToNodeStore.getNodeProvider(model.directory);
              if (provider) {
                const node32 = app$1.addNodeOnGraph(provider.nodeDef, {
                  pos: app$1.getCanvasCenter()
                });
                const widget = node32.widgets.find(
                  (widget2) => widget2.name === provider.key
                );
                if (widget) {
                  widget.value = model.file_name;
                }
              }
            } else {
              toggleNodeOnEvent(e, node22);
            }
          }, "handleClick")
        };
      }, "fillNodeInfo");
      return fillNodeInfo(root23.value);
    });
    watch(
      toRef$1(expandedKeys2, "value"),
      (newExpandedKeys) => {
        Object.entries(newExpandedKeys).forEach(([key, isExpanded]) => {
          if (isExpanded) {
            const folderPath = key.split("/").slice(1).join("/");
            if (folderPath && !folderPath.includes("/")) {
              modelStore.getLoadedModelFolder(folderPath);
            }
          }
        });
      },
      { deep: true }
    );
    onMounted(async () => {
      if (settingStore.get("Comfy.ModelLibrary.AutoLoadAll")) {
        await modelStore.loadModels();
      }
    });
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(SidebarTabTemplate, {
          title: _ctx.$t("sideToolbar.modelLibrary"),
          class: "bg-[var(--p-tree-background)]"
        }, {
          "tool-buttons": withCtx(() => [
            withDirectives(createVNode(unref(script$M), {
              icon: "pi pi-refresh",
              onClick: unref(modelStore).loadModelFolders,
              severity: "secondary",
              text: ""
            }, null, 8, ["onClick"]), [
              [
                _directive_tooltip,
                _ctx.$t("refresh"),
                void 0,
                { bottom: true }
              ]
            ]),
            withDirectives(createVNode(unref(script$M), {
              icon: "pi pi-cloud-download",
              onClick: unref(modelStore).loadModels,
              severity: "secondary",
              text: ""
            }, null, 8, ["onClick"]), [
              [
                _directive_tooltip,
                _ctx.$t("loadAllFolders"),
                void 0,
                { bottom: true }
              ]
            ])
          ]),
          header: withCtx(() => [
            createVNode(SearchBox, {
              class: "model-lib-search-box p-2 2xl:p-4",
              modelValue: searchQuery.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
              placeholder: _ctx.$t("searchModels") + "...",
              onSearch: handleSearch
            }, null, 8, ["modelValue", "placeholder"])
          ]),
          body: withCtx(() => [
            unref(isElectron)() ? (openBlock(), createBlock(_sfc_main$k, { key: 0 })) : createCommentVNode("", true),
            createVNode(TreeExplorer, {
              class: "model-lib-tree-explorer",
              roots: renderedRoot.value.children,
              expandedKeys: expandedKeys2.value,
              "onUpdate:expandedKeys": _cache[1] || (_cache[1] = ($event) => expandedKeys2.value = $event)
            }, {
              node: withCtx(({ node: node3 }) => [
                createVNode(ModelTreeLeaf, { node: node3 }, null, 8, ["node"])
              ]),
              _: 1
            }, 8, ["roots", "expandedKeys"])
          ]),
          _: 1
        }, 8, ["title"]),
        _hoisted_1$n
      ], 64);
    };
  }
});
const ModelLibrarySidebarTab = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-827f7782"]]);
const useModelLibrarySidebarTab = /* @__PURE__ */ __name(() => {
  const { t } = useI18n();
  return {
    id: "model-library",
    icon: "pi pi-box",
    title: t("sideToolbar.modelLibrary"),
    tooltip: t("sideToolbar.modelLibrary"),
    component: markRaw(ModelLibrarySidebarTab),
    type: "vue"
  };
}, "useModelLibrarySidebarTab");
var FocusTrapStyle = BaseStyle.extend({
  name: "focustrap-directive"
});
var BaseFocusTrap = BaseDirective.extend({
  style: FocusTrapStyle
});
function _typeof$5(o) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$5(o);
}
__name(_typeof$5, "_typeof$5");
function ownKeys$5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$5, "ownKeys$5");
function _objectSpread$5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$5(Object(t), true).forEach(function(r2) {
      _defineProperty$5(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$5, "_objectSpread$5");
function _defineProperty$5(e, r, t) {
  return (r = _toPropertyKey$5(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$5, "_defineProperty$5");
function _toPropertyKey$5(t) {
  var i2 = _toPrimitive$5(t, "string");
  return "symbol" == _typeof$5(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$5, "_toPropertyKey$5");
function _toPrimitive$5(t, r) {
  if ("object" != _typeof$5(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$5, "_toPrimitive$5");
var FocusTrap = BaseFocusTrap.extend("focustrap", {
  mounted: /* @__PURE__ */ __name(function mounted12(el, binding) {
    var _ref = binding.value || {}, disabled2 = _ref.disabled;
    if (!disabled2) {
      this.createHiddenFocusableElements(el, binding);
      this.bind(el, binding);
      this.autoElementFocus(el, binding);
    }
    el.setAttribute("data-pd-focustrap", true);
    this.$el = el;
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated6(el, binding) {
    var _ref2 = binding.value || {}, disabled2 = _ref2.disabled;
    disabled2 && this.unbind(el);
  }, "updated"),
  unmounted: /* @__PURE__ */ __name(function unmounted4(el) {
    this.unbind(el);
  }, "unmounted"),
  methods: {
    getComputedSelector: /* @__PURE__ */ __name(function getComputedSelector(selector) {
      return ':not(.p-hidden-focusable):not([data-p-hidden-focusable="true"])'.concat(selector !== null && selector !== void 0 ? selector : "");
    }, "getComputedSelector"),
    bind: /* @__PURE__ */ __name(function bind2(el, binding) {
      var _this = this;
      var _ref3 = binding.value || {}, onFocusIn = _ref3.onFocusIn, onFocusOut = _ref3.onFocusOut;
      el.$_pfocustrap_mutationobserver = new MutationObserver(function(mutationList) {
        mutationList.forEach(function(mutation) {
          if (mutation.type === "childList" && !el.contains(document.activeElement)) {
            var _findNextFocusableElement = /* @__PURE__ */ __name(function findNextFocusableElement(_el) {
              var focusableElement = isFocusableElement(_el) ? isFocusableElement(_el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) ? _el : getFirstFocusableElement(el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) : getFirstFocusableElement(_el);
              return isNotEmpty(focusableElement) ? focusableElement : _el.nextSibling && _findNextFocusableElement(_el.nextSibling);
            }, "findNextFocusableElement");
            focus(_findNextFocusableElement(mutation.nextSibling));
          }
        });
      });
      el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_mutationobserver.observe(el, {
        childList: true
      });
      el.$_pfocustrap_focusinlistener = function(event2) {
        return onFocusIn && onFocusIn(event2);
      };
      el.$_pfocustrap_focusoutlistener = function(event2) {
        return onFocusOut && onFocusOut(event2);
      };
      el.addEventListener("focusin", el.$_pfocustrap_focusinlistener);
      el.addEventListener("focusout", el.$_pfocustrap_focusoutlistener);
    }, "bind"),
    unbind: /* @__PURE__ */ __name(function unbind(el) {
      el.$_pfocustrap_mutationobserver && el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_focusinlistener && el.removeEventListener("focusin", el.$_pfocustrap_focusinlistener) && (el.$_pfocustrap_focusinlistener = null);
      el.$_pfocustrap_focusoutlistener && el.removeEventListener("focusout", el.$_pfocustrap_focusoutlistener) && (el.$_pfocustrap_focusoutlistener = null);
    }, "unbind"),
    autoFocus: /* @__PURE__ */ __name(function autoFocus(options3) {
      this.autoElementFocus(this.$el, {
        value: _objectSpread$5(_objectSpread$5({}, options3), {}, {
          autoFocus: true
        })
      });
    }, "autoFocus"),
    autoElementFocus: /* @__PURE__ */ __name(function autoElementFocus(el, binding) {
      var _ref4 = binding.value || {}, _ref4$autoFocusSelect = _ref4.autoFocusSelector, autoFocusSelector = _ref4$autoFocusSelect === void 0 ? "" : _ref4$autoFocusSelect, _ref4$firstFocusableS = _ref4.firstFocusableSelector, firstFocusableSelector = _ref4$firstFocusableS === void 0 ? "" : _ref4$firstFocusableS, _ref4$autoFocus = _ref4.autoFocus, autoFocus2 = _ref4$autoFocus === void 0 ? false : _ref4$autoFocus;
      var focusableElement = getFirstFocusableElement(el, "[autofocus]".concat(this.getComputedSelector(autoFocusSelector)));
      autoFocus2 && !focusableElement && (focusableElement = getFirstFocusableElement(el, this.getComputedSelector(firstFocusableSelector)));
      focus(focusableElement);
    }, "autoElementFocus"),
    onFirstHiddenElementFocus: /* @__PURE__ */ __name(function onFirstHiddenElementFocus(event2) {
      var _this$$el;
      var currentTarget = event2.currentTarget, relatedTarget = event2.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_lasthiddenfocusableelement || !((_this$$el = this.$el) !== null && _this$$el !== void 0 && _this$$el.contains(relatedTarget)) ? getFirstFocusableElement(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_lasthiddenfocusableelement;
      focus(focusableElement);
    }, "onFirstHiddenElementFocus"),
    onLastHiddenElementFocus: /* @__PURE__ */ __name(function onLastHiddenElementFocus(event2) {
      var _this$$el2;
      var currentTarget = event2.currentTarget, relatedTarget = event2.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_firsthiddenfocusableelement || !((_this$$el2 = this.$el) !== null && _this$$el2 !== void 0 && _this$$el2.contains(relatedTarget)) ? getLastFocusableElement(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_firsthiddenfocusableelement;
      focus(focusableElement);
    }, "onLastHiddenElementFocus"),
    createHiddenFocusableElements: /* @__PURE__ */ __name(function createHiddenFocusableElements(el, binding) {
      var _this2 = this;
      var _ref5 = binding.value || {}, _ref5$tabIndex = _ref5.tabIndex, tabIndex = _ref5$tabIndex === void 0 ? 0 : _ref5$tabIndex, _ref5$firstFocusableS = _ref5.firstFocusableSelector, firstFocusableSelector = _ref5$firstFocusableS === void 0 ? "" : _ref5$firstFocusableS, _ref5$lastFocusableSe = _ref5.lastFocusableSelector, lastFocusableSelector = _ref5$lastFocusableSe === void 0 ? "" : _ref5$lastFocusableSe;
      var createFocusableElement = /* @__PURE__ */ __name(function createFocusableElement2(onFocus7) {
        return createElement("span", {
          "class": "p-hidden-accessible p-hidden-focusable",
          tabIndex,
          role: "presentation",
          "aria-hidden": true,
          "data-p-hidden-accessible": true,
          "data-p-hidden-focusable": true,
          onFocus: onFocus7 === null || onFocus7 === void 0 ? void 0 : onFocus7.bind(_this2)
        });
      }, "createFocusableElement");
      var firstFocusableElement = createFocusableElement(this.onFirstHiddenElementFocus);
      var lastFocusableElement = createFocusableElement(this.onLastHiddenElementFocus);
      firstFocusableElement.$_pfocustrap_lasthiddenfocusableelement = lastFocusableElement;
      firstFocusableElement.$_pfocustrap_focusableselector = firstFocusableSelector;
      firstFocusableElement.setAttribute("data-pc-section", "firstfocusableelement");
      lastFocusableElement.$_pfocustrap_firsthiddenfocusableelement = firstFocusableElement;
      lastFocusableElement.$_pfocustrap_focusableselector = lastFocusableSelector;
      lastFocusableElement.setAttribute("data-pc-section", "lastfocusableelement");
      el.prepend(firstFocusableElement);
      el.append(lastFocusableElement);
    }, "createHiddenFocusableElements")
  }
});
var theme$8 = /* @__PURE__ */ __name(function theme29(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-popover {\n    margin-top: ".concat(dt2("popover.gutter"), ";\n    background: ").concat(dt2("popover.background"), ";\n    color: ").concat(dt2("popover.color"), ";\n    border: 1px solid ").concat(dt2("popover.border.color"), ";\n    border-radius: ").concat(dt2("popover.border.radius"), ";\n    box-shadow: ").concat(dt2("popover.shadow"), ";\n}\n\n.p-popover-content {\n    padding: ").concat(dt2("popover.content.padding"), ";\n}\n\n.p-popover-flipped {\n    margin-top: calc(").concat(dt2("popover.gutter"), " * -1);\n    margin-bottom: ").concat(dt2("popover.gutter"), ";\n}\n\n.p-popover-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-popover-leave-to {\n    opacity: 0;\n}\n\n.p-popover-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-popover-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n.p-popover:after,\n.p-popover:before {\n    bottom: 100%;\n    left: calc(").concat(dt2("popover.arrow.offset"), " + ").concat(dt2("popover.arrow.left"), ');\n    content: " ";\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none;\n}\n\n.p-popover:after {\n    border-width: calc(').concat(dt2("popover.gutter"), " - 2px);\n    margin-left: calc(-1 * (").concat(dt2("popover.gutter"), " - 2px));\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt2("popover.background"), ";\n}\n\n.p-popover:before {\n    border-width: ").concat(dt2("popover.gutter"), ";\n    margin-left: calc(-1 * ").concat(dt2("popover.gutter"), ");\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt2("popover.border.color"), ";\n}\n\n.p-popover-flipped:after,\n.p-popover-flipped:before {\n    bottom: auto;\n    top: 100%;\n}\n\n.p-popover.p-popover-flipped:after {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt2("popover.background"), ";\n}\n\n.p-popover.p-popover-flipped:before {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt2("popover.border.color"), ";\n}\n");
}, "theme");
var classes$8 = {
  root: "p-popover p-component",
  content: "p-popover-content"
};
var PopoverStyle = BaseStyle.extend({
  name: "popover",
  theme: theme$8,
  classes: classes$8
});
var script$1$7 = {
  name: "BasePopover",
  "extends": script$Y,
  props: {
    dismissable: {
      type: Boolean,
      "default": true
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    closeOnEscape: {
      type: Boolean,
      "default": true
    }
  },
  style: PopoverStyle,
  provide: /* @__PURE__ */ __name(function provide31() {
    return {
      $pcPopover: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$e = {
  name: "Popover",
  "extends": script$1$7,
  inheritAttrs: false,
  emits: ["show", "hide"],
  data: /* @__PURE__ */ __name(function data14() {
    return {
      visible: false
    };
  }, "data"),
  watch: {
    dismissable: {
      immediate: true,
      handler: /* @__PURE__ */ __name(function handler4(newValue) {
        if (newValue) {
          this.bindOutsideClickListener();
        } else {
          this.unbindOutsideClickListener();
        }
      }, "handler")
    }
  },
  selfClick: false,
  target: null,
  eventTarget: null,
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  container: null,
  styleElement: null,
  overlayEventListener: null,
  documentKeydownListener: null,
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount6() {
    if (this.dismissable) {
      this.unbindOutsideClickListener();
    }
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    this.destroyStyle();
    this.unbindResizeListener();
    this.target = null;
    if (this.container && this.autoZIndex) {
      ZIndex.clear(this.container);
    }
    if (this.overlayEventListener) {
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
    }
    this.container = null;
  }, "beforeUnmount"),
  mounted: /* @__PURE__ */ __name(function mounted13() {
    if (this.breakpoints) {
      this.createStyle();
    }
  }, "mounted"),
  methods: {
    toggle: /* @__PURE__ */ __name(function toggle3(event2, target) {
      if (this.visible) this.hide();
      else this.show(event2, target);
    }, "toggle"),
    show: /* @__PURE__ */ __name(function show3(event2, target) {
      this.visible = true;
      this.eventTarget = event2.currentTarget;
      this.target = target || event2.currentTarget;
    }, "show"),
    hide: /* @__PURE__ */ __name(function hide3() {
      this.visible = false;
    }, "hide"),
    onContentClick: /* @__PURE__ */ __name(function onContentClick() {
      this.selfClick = true;
    }, "onContentClick"),
    onEnter: /* @__PURE__ */ __name(function onEnter3(el) {
      var _this = this;
      this.container.setAttribute(this.attributeSelector, "");
      addStyle(el, {
        position: "absolute",
        top: "0",
        left: "0"
      });
      this.alignOverlay();
      if (this.dismissable) {
        this.bindOutsideClickListener();
      }
      this.bindScrollListener();
      this.bindResizeListener();
      if (this.autoZIndex) {
        ZIndex.set("overlay", el, this.baseZIndex + this.$primevue.config.zIndex.overlay);
      }
      this.overlayEventListener = function(e) {
        if (_this.container.contains(e.target)) {
          _this.selfClick = true;
        }
      };
      this.focus();
      OverlayEventBus.on("overlay-click", this.overlayEventListener);
      this.$emit("show");
      if (this.closeOnEscape) {
        this.bindDocumentKeyDownListener();
      }
    }, "onEnter"),
    onLeave: /* @__PURE__ */ __name(function onLeave2() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.unbindDocumentKeyDownListener();
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
      this.$emit("hide");
    }, "onLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave2(el) {
      if (this.autoZIndex) {
        ZIndex.clear(el);
      }
    }, "onAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay3() {
      absolutePosition(this.container, this.target, false);
      var containerOffset = getOffset(this.container);
      var targetOffset = getOffset(this.target);
      var arrowLeft = 0;
      if (containerOffset.left < targetOffset.left) {
        arrowLeft = targetOffset.left - containerOffset.left;
      }
      this.container.style.setProperty($dt("popover.arrow.left").name, "".concat(arrowLeft, "px"));
      if (containerOffset.top < targetOffset.top) {
        this.container.setAttribute("data-p-popover-flipped", "true");
        !this.isUnstyled && addClass(this.container, "p-popover-flipped");
      }
    }, "alignOverlay"),
    onContentKeydown: /* @__PURE__ */ __name(function onContentKeydown(event2) {
      if (event2.code === "Escape" && this.closeOnEscape) {
        this.hide();
        focus(this.target);
      }
    }, "onContentKeydown"),
    onButtonKeydown: /* @__PURE__ */ __name(function onButtonKeydown(event2) {
      switch (event2.code) {
        case "ArrowDown":
        case "ArrowUp":
        case "ArrowLeft":
        case "ArrowRight":
          event2.preventDefault();
      }
    }, "onButtonKeydown"),
    focus: /* @__PURE__ */ __name(function focus2() {
      var focusTarget = this.container.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus();
      }
    }, "focus"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown7(event2) {
      if (event2.code === "Escape" && this.closeOnEscape) {
        this.visible = false;
      }
    }, "onKeyDown"),
    bindDocumentKeyDownListener: /* @__PURE__ */ __name(function bindDocumentKeyDownListener() {
      if (!this.documentKeydownListener) {
        this.documentKeydownListener = this.onKeyDown.bind(this);
        window.document.addEventListener("keydown", this.documentKeydownListener);
      }
    }, "bindDocumentKeyDownListener"),
    unbindDocumentKeyDownListener: /* @__PURE__ */ __name(function unbindDocumentKeyDownListener() {
      if (this.documentKeydownListener) {
        window.document.removeEventListener("keydown", this.documentKeydownListener);
        this.documentKeydownListener = null;
      }
    }, "unbindDocumentKeyDownListener"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener3() {
      var _this2 = this;
      if (!this.outsideClickListener && isClient$1()) {
        this.outsideClickListener = function(event2) {
          if (_this2.visible && !_this2.selfClick && !_this2.isTargetClicked(event2)) {
            _this2.visible = false;
          }
          _this2.selfClick = false;
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener3() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
        this.selfClick = false;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener2() {
      var _this3 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, function() {
          if (_this3.visible) {
            _this3.visible = false;
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener2() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener4() {
      var _this4 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this4.visible && !isTouchDevice()) {
            _this4.visible = false;
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener4() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    isTargetClicked: /* @__PURE__ */ __name(function isTargetClicked(event2) {
      return this.eventTarget && (this.eventTarget === event2.target || this.eventTarget.contains(event2.target));
    }, "isTargetClicked"),
    containerRef: /* @__PURE__ */ __name(function containerRef2(el) {
      this.container = el;
    }, "containerRef"),
    createStyle: /* @__PURE__ */ __name(function createStyle() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-popover[").concat(this.attributeSelector, "] {\n                                width: ").concat(this.breakpoints[breakpoint], " !important;\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    }, "createStyle"),
    destroyStyle: /* @__PURE__ */ __name(function destroyStyle() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    }, "destroyStyle"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick2(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.target
      });
    }, "onOverlayClick")
  },
  computed: {
    attributeSelector: /* @__PURE__ */ __name(function attributeSelector() {
      return UniqueComponentId();
    }, "attributeSelector")
  },
  directives: {
    focustrap: FocusTrap,
    ripple: Ripple
  },
  components: {
    Portal: script$z
  }
};
var _hoisted_1$m = ["aria-modal"];
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-popover",
        onEnter: $options.onEnter,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            role: "dialog",
            "aria-modal": $data.visible,
            onClick: _cache[3] || (_cache[3] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            "class": _ctx.cx("root")
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            closeCallback: $options.hide,
            keydownCallback: /* @__PURE__ */ __name(function keydownCallback(event2) {
              return $options.onButtonKeydown(event2);
            }, "keydownCallback")
          }) : (openBlock(), createElementBlock("div", mergeProps({
            key: 1,
            "class": _ctx.cx("content"),
            onClick: _cache[0] || (_cache[0] = function() {
              return $options.onContentClick && $options.onContentClick.apply($options, arguments);
            }),
            onMousedown: _cache[1] || (_cache[1] = function() {
              return $options.onContentClick && $options.onContentClick.apply($options, arguments);
            }),
            onKeydown: _cache[2] || (_cache[2] = function() {
              return $options.onContentKeydown && $options.onContentKeydown.apply($options, arguments);
            })
          }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "default")], 16))], 16, _hoisted_1$m)), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"]);
}
__name(render$d, "render$d");
script$e.render = render$d;
const colorPalettes = {
  dark: {
    id: "dark",
    name: "Dark (Default)",
    colors: {
      node_slot: {
        CLIP: "#FFD500",
        // bright yellow
        CLIP_VISION: "#A8DADC",
        // light blue-gray
        CLIP_VISION_OUTPUT: "#ad7452",
        // rusty brown-orange
        CONDITIONING: "#FFA931",
        // vibrant orange-yellow
        CONTROL_NET: "#6EE7B7",
        // soft mint green
        IMAGE: "#64B5F6",
        // bright sky blue
        LATENT: "#FF9CF9",
        // light pink-purple
        MASK: "#81C784",
        // muted green
        MODEL: "#B39DDB",
        // light lavender-purple
        STYLE_MODEL: "#C2FFAE",
        // light green-yellow
        VAE: "#FF6E6E",
        // bright red
        NOISE: "#B0B0B0",
        // gray
        GUIDER: "#66FFFF",
        // cyan
        SAMPLER: "#ECB4B4",
        // very soft red
        SIGMAS: "#CDFFCD",
        // soft lime green
        TAESD: "#DCC274"
        // cheesecake
      },
      litegraph_base: {
        BACKGROUND_IMAGE: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=",
        CLEAR_BACKGROUND_COLOR: "#222",
        NODE_TITLE_COLOR: "#999",
        NODE_SELECTED_TITLE_COLOR: "#FFF",
        NODE_TEXT_SIZE: 14,
        NODE_TEXT_COLOR: "#AAA",
        NODE_SUBTEXT_SIZE: 12,
        NODE_DEFAULT_COLOR: "#333",
        NODE_DEFAULT_BGCOLOR: "#353535",
        NODE_DEFAULT_BOXCOLOR: "#666",
        NODE_DEFAULT_SHAPE: "box",
        NODE_BOX_OUTLINE_COLOR: "#FFF",
        NODE_BYPASS_BGCOLOR: "#FF00FF",
        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
        DEFAULT_GROUP_FONT: 24,
        WIDGET_BGCOLOR: "#222",
        WIDGET_OUTLINE_COLOR: "#666",
        WIDGET_TEXT_COLOR: "#DDD",
        WIDGET_SECONDARY_TEXT_COLOR: "#999",
        LINK_COLOR: "#9A9",
        EVENT_LINK_COLOR: "#A86",
        CONNECTING_LINK_COLOR: "#AFA",
        BADGE_FG_COLOR: "#FFF",
        BADGE_BG_COLOR: "#0F1F0F"
      },
      comfy_base: {
        "fg-color": "#fff",
        "bg-color": "#202020",
        "comfy-menu-bg": "#353535",
        "comfy-input-bg": "#222",
        "input-text": "#ddd",
        "descrip-text": "#999",
        "drag-text": "#ccc",
        "error-text": "#ff4444",
        "border-color": "#4e4e4e",
        "tr-even-bg-color": "#222",
        "tr-odd-bg-color": "#353535",
        "content-bg": "#4e4e4e",
        "content-fg": "#fff",
        "content-hover-bg": "#222",
        "content-hover-fg": "#fff"
      }
    }
  },
  light: {
    id: "light",
    name: "Light",
    colors: {
      node_slot: {
        CLIP: "#FFA726",
        // orange
        CLIP_VISION: "#5C6BC0",
        // indigo
        CLIP_VISION_OUTPUT: "#8D6E63",
        // brown
        CONDITIONING: "#EF5350",
        // red
        CONTROL_NET: "#66BB6A",
        // green
        IMAGE: "#42A5F5",
        // blue
        LATENT: "#AB47BC",
        // purple
        MASK: "#9CCC65",
        // light green
        MODEL: "#7E57C2",
        // deep purple
        STYLE_MODEL: "#D4E157",
        // lime
        VAE: "#FF7043"
        // deep orange
      },
      litegraph_base: {
        BACKGROUND_IMAGE: "data:image/gif;base64,R0lGODlhZABkALMAAAAAAP///+vr6+rq6ujo6Ofn5+bm5uXl5d3d3f///wAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAkALAAAAABkAGQAAAT/UMhJq7046827HkcoHkYxjgZhnGG6si5LqnIM0/fL4qwwIMAg0CAsEovBIxKhRDaNy2GUOX0KfVFrssrNdpdaqTeKBX+dZ+jYvEaTf+y4W66mC8PUdrE879f9d2mBeoNLfH+IhYBbhIx2jkiHiomQlGKPl4uZe3CaeZifnnijgkESBqipqqusra6vsLGys62SlZO4t7qbuby7CLa+wqGWxL3Gv3jByMOkjc2lw8vOoNSi0czAncXW3Njdx9Pf48/Z4Kbbx+fQ5evZ4u3k1fKR6cn03vHlp7T9/v8A/8Gbp4+gwXoFryXMB2qgwoMMHyKEqA5fxX322FG8tzBcRnMW/zlulPbRncmQGidKjMjyYsOSKEF2FBlJQMCbOHP6c9iSZs+UnGYCdbnSo1CZI5F64kn0p1KnTH02nSoV3dGTV7FFHVqVq1dtWcMmVQZTbNGu72zqXMuW7danVL+6e4t1bEy6MeueBYLXrNO5Ze36jQtWsOG97wIj1vt3St/DjTEORss4nNq2mDP3e7w4r1bFkSET5hy6s2TRlD2/mSxXtSHQhCunXo26NevCpmvD/UU6tuullzULH76q92zdZG/Ltv1a+W+osI/nRmyc+fRi1Xdbh+68+0vv10dH3+77KD/i6IdnX669/frn5Zsjh4/2PXju8+8bzc9/6fj27LFnX11/+IUnXWl7BJfegm79FyB9JOl3oHgSklefgxAC+FmFGpqHIYcCfkhgfCohSKKJVo044YUMttggiBkmp6KFXw1oII24oYhjiDByaKOOHcp3Y5BD/njikSkO+eBREQAAOw==",
        CLEAR_BACKGROUND_COLOR: "lightgray",
        NODE_TITLE_COLOR: "#222",
        NODE_SELECTED_TITLE_COLOR: "#000",
        NODE_TEXT_SIZE: 14,
        NODE_TEXT_COLOR: "#444",
        NODE_SUBTEXT_SIZE: 12,
        NODE_DEFAULT_COLOR: "#F7F7F7",
        NODE_DEFAULT_BGCOLOR: "#F5F5F5",
        NODE_DEFAULT_BOXCOLOR: "#CCC",
        NODE_DEFAULT_SHAPE: "box",
        NODE_BOX_OUTLINE_COLOR: "#000",
        NODE_BYPASS_BGCOLOR: "#FF00FF",
        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.1)",
        DEFAULT_GROUP_FONT: 24,
        WIDGET_BGCOLOR: "#D4D4D4",
        WIDGET_OUTLINE_COLOR: "#999",
        WIDGET_TEXT_COLOR: "#222",
        WIDGET_SECONDARY_TEXT_COLOR: "#555",
        LINK_COLOR: "#4CAF50",
        EVENT_LINK_COLOR: "#FF9800",
        CONNECTING_LINK_COLOR: "#2196F3",
        BADGE_FG_COLOR: "#000",
        BADGE_BG_COLOR: "#FFF"
      },
      comfy_base: {
        "fg-color": "#222",
        "bg-color": "#DDD",
        "comfy-menu-bg": "#F5F5F5",
        "comfy-input-bg": "#C9C9C9",
        "input-text": "#222",
        "descrip-text": "#444",
        "drag-text": "#555",
        "error-text": "#F44336",
        "border-color": "#888",
        "tr-even-bg-color": "#f9f9f9",
        "tr-odd-bg-color": "#fff",
        "content-bg": "#e0e0e0",
        "content-fg": "#222",
        "content-hover-bg": "#adadad",
        "content-hover-fg": "#222"
      }
    }
  },
  solarized: {
    id: "solarized",
    name: "Solarized",
    colors: {
      node_slot: {
        CLIP: "#2AB7CA",
        // light blue
        CLIP_VISION: "#6c71c4",
        // blue violet
        CLIP_VISION_OUTPUT: "#859900",
        // olive green
        CONDITIONING: "#d33682",
        // magenta
        CONTROL_NET: "#d1ffd7",
        // light mint green
        IMAGE: "#5940bb",
        // deep blue violet
        LATENT: "#268bd2",
        // blue
        MASK: "#CCC9E7",
        // light purple-gray
        MODEL: "#dc322f",
        // red
        STYLE_MODEL: "#1a998a",
        // teal
        UPSCALE_MODEL: "#054A29",
        // dark green
        VAE: "#facfad"
        // light pink-orange
      },
      litegraph_base: {
        NODE_TITLE_COLOR: "#fdf6e3",
        // Base3
        NODE_SELECTED_TITLE_COLOR: "#A9D400",
        NODE_TEXT_SIZE: 14,
        NODE_TEXT_COLOR: "#657b83",
        // Base00
        NODE_SUBTEXT_SIZE: 12,
        NODE_DEFAULT_COLOR: "#094656",
        NODE_DEFAULT_BGCOLOR: "#073642",
        // Base02
        NODE_DEFAULT_BOXCOLOR: "#839496",
        // Base0
        NODE_DEFAULT_SHAPE: "box",
        NODE_BOX_OUTLINE_COLOR: "#fdf6e3",
        // Base3
        NODE_BYPASS_BGCOLOR: "#FF00FF",
        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
        DEFAULT_GROUP_FONT: 24,
        WIDGET_BGCOLOR: "#002b36",
        // Base03
        WIDGET_OUTLINE_COLOR: "#839496",
        // Base0
        WIDGET_TEXT_COLOR: "#fdf6e3",
        // Base3
        WIDGET_SECONDARY_TEXT_COLOR: "#93a1a1",
        // Base1
        LINK_COLOR: "#2aa198",
        // Solarized Cyan
        EVENT_LINK_COLOR: "#268bd2",
        // Solarized Blue
        CONNECTING_LINK_COLOR: "#859900"
        // Solarized Green
      },
      comfy_base: {
        "fg-color": "#fdf6e3",
        // Base3
        "bg-color": "#002b36",
        // Base03
        "comfy-menu-bg": "#073642",
        // Base02
        "comfy-input-bg": "#002b36",
        // Base03
        "input-text": "#93a1a1",
        // Base1
        "descrip-text": "#586e75",
        // Base01
        "drag-text": "#839496",
        // Base0
        "error-text": "#dc322f",
        // Solarized Red
        "border-color": "#657b83",
        // Base00
        "tr-even-bg-color": "#002b36",
        "tr-odd-bg-color": "#073642",
        "content-bg": "#657b83",
        "content-fg": "#fdf6e3",
        "content-hover-bg": "#002b36",
        "content-hover-fg": "#fdf6e3"
      }
    }
  },
  arc: {
    id: "arc",
    name: "Arc",
    colors: {
      node_slot: {
        BOOLEAN: "",
        CLIP: "#eacb8b",
        CLIP_VISION: "#A8DADC",
        CLIP_VISION_OUTPUT: "#ad7452",
        CONDITIONING: "#cf876f",
        CONTROL_NET: "#00d78d",
        CONTROL_NET_WEIGHTS: "",
        FLOAT: "",
        GLIGEN: "",
        IMAGE: "#80a1c0",
        IMAGEUPLOAD: "",
        INT: "",
        LATENT: "#b38ead",
        LATENT_KEYFRAME: "",
        MASK: "#a3bd8d",
        MODEL: "#8978a7",
        SAMPLER: "",
        SIGMAS: "",
        STRING: "",
        STYLE_MODEL: "#C2FFAE",
        T2I_ADAPTER_WEIGHTS: "",
        TAESD: "#DCC274",
        TIMESTEP_KEYFRAME: "",
        UPSCALE_MODEL: "",
        VAE: "#be616b"
      },
      litegraph_base: {
        BACKGROUND_IMAGE: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVR4nO3YMUoDARgF4RfxBqZI6/0vZqFn0MYtrLIQMFN8U6V4LAtD+Jm9XG/v30OGl2e/AP7yevz4+vx45nvgF/+QGITEICQGITEIiUFIjNNC3q43u3/YnRJyPOzeQ+0e220nhRzReC8e7R7bbdvl+Jal1Bs46jEIiUFIDEJiEBKDkBhKPbZT6qHdptRTu02p53DUYxASg5AYhMQgJAYhMZR6bKfUQ7tNqad2m1LP4ajHICQGITEIiUFIDEJiKPXYTqmHdptST+02pZ7DUY9BSAxCYhASg5AYhMRQ6rGdUg/tNqWe2m1KPYejHoOQGITEICQGITEIiaHUYzulHtptSj2125R6Dkc9BiExCIlBSAxCYhASQ6nHdko9tNuUemq3KfUcjnoMQmIQEoOQGITEICSGUo/tlHpotyn11G5T6jkc9RiExCAkBiExCIlBSAylHtsp9dBuU+qp3abUczjqMQiJQUgMQmIQEoOQGITE+AHFISNQrFTGuwAAAABJRU5ErkJggg==",
        CLEAR_BACKGROUND_COLOR: "#2b2f38",
        NODE_TITLE_COLOR: "#b2b7bd",
        NODE_SELECTED_TITLE_COLOR: "#FFF",
        NODE_TEXT_SIZE: 14,
        NODE_TEXT_COLOR: "#AAA",
        NODE_SUBTEXT_SIZE: 12,
        NODE_DEFAULT_COLOR: "#2b2f38",
        NODE_DEFAULT_BGCOLOR: "#242730",
        NODE_DEFAULT_BOXCOLOR: "#6e7581",
        NODE_DEFAULT_SHAPE: "box",
        NODE_BOX_OUTLINE_COLOR: "#FFF",
        NODE_BYPASS_BGCOLOR: "#FF00FF",
        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
        DEFAULT_GROUP_FONT: 22,
        WIDGET_BGCOLOR: "#2b2f38",
        WIDGET_OUTLINE_COLOR: "#6e7581",
        WIDGET_TEXT_COLOR: "#DDD",
        WIDGET_SECONDARY_TEXT_COLOR: "#b2b7bd",
        LINK_COLOR: "#9A9",
        EVENT_LINK_COLOR: "#A86",
        CONNECTING_LINK_COLOR: "#AFA"
      },
      comfy_base: {
        "fg-color": "#fff",
        "bg-color": "#2b2f38",
        "comfy-menu-bg": "#242730",
        "comfy-input-bg": "#2b2f38",
        "input-text": "#ddd",
        "descrip-text": "#b2b7bd",
        "drag-text": "#ccc",
        "error-text": "#ff4444",
        "border-color": "#6e7581",
        "tr-even-bg-color": "#2b2f38",
        "tr-odd-bg-color": "#242730",
        "content-bg": "#6e7581",
        "content-fg": "#fff",
        "content-hover-bg": "#2b2f38",
        "content-hover-fg": "#fff"
      }
    }
  },
  nord: {
    id: "nord",
    name: "Nord",
    colors: {
      node_slot: {
        BOOLEAN: "",
        CLIP: "#eacb8b",
        CLIP_VISION: "#A8DADC",
        CLIP_VISION_OUTPUT: "#ad7452",
        CONDITIONING: "#cf876f",
        CONTROL_NET: "#00d78d",
        CONTROL_NET_WEIGHTS: "",
        FLOAT: "",
        GLIGEN: "",
        IMAGE: "#80a1c0",
        IMAGEUPLOAD: "",
        INT: "",
        LATENT: "#b38ead",
        LATENT_KEYFRAME: "",
        MASK: "#a3bd8d",
        MODEL: "#8978a7",
        SAMPLER: "",
        SIGMAS: "",
        STRING: "",
        STYLE_MODEL: "#C2FFAE",
        T2I_ADAPTER_WEIGHTS: "",
        TAESD: "#DCC274",
        TIMESTEP_KEYFRAME: "",
        UPSCALE_MODEL: "",
        VAE: "#be616b"
      },
      litegraph_base: {
        BACKGROUND_IMAGE: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFu2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMy0xMS0xM1QwMDoxODowMiswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjMtMTEtMTVUMDE6MjA6NDUrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjMtMTEtMTVUMDE6MjA6NDUrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjUwNDFhMmZjLTEzNzQtMTk0ZC1hZWY4LTYxMzM1MTVmNjUwMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyMzFiMTBiMC1iNGZiLTAyNGUtYjEyZS0zMDUzMDNjZDA3YzgiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoyMzFiMTBiMC1iNGZiLTAyNGUtYjEyZS0zMDUzMDNjZDA3YzgiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzMWIxMGIwLWI0ZmItMDI0ZS1iMTJlLTMwNTMwM2NkMDdjOCIgc3RFdnQ6d2hlbj0iMjAyMy0xMS0xM1QwMDoxODowMiswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1MDQxYTJmYy0xMzc0LTE5NGQtYWVmOC02MTMzNTE1ZjY1MDAiIHN0RXZ0OndoZW49IjIwMjMtMTEtMTVUMDE6MjA6NDUrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz73jWg/AAAAyUlEQVR42u3WKwoAIBRFQRdiMb1idv9Lsxn9gEFw4Dbb8JCTojbbXEJwjJVL2HKwYMGCBQuWLbDmjr+9zrBGjHl1WVcvy2DBggULFizTWQpewSt4HzwsgwULFiwFr7MUvMtS8D54WLBgGSxYCl7BK3iXZbBgwYIFC5bpLAWv4BW8Dx6WwYIFC5aC11kK3mUpeB88LFiwDBYsBa/gFbzLMliwYMGCBct0loJX8AreBw/LYMGCBUvB6ywF77IUvA8eFixYBgsWrNfWAZPltufdad+1AAAAAElFTkSuQmCC",
        CLEAR_BACKGROUND_COLOR: "#212732",
        NODE_TITLE_COLOR: "#999",
        NODE_SELECTED_TITLE_COLOR: "#e5eaf0",
        NODE_TEXT_SIZE: 14,
        NODE_TEXT_COLOR: "#bcc2c8",
        NODE_SUBTEXT_SIZE: 12,
        NODE_DEFAULT_COLOR: "#2e3440",
        NODE_DEFAULT_BGCOLOR: "#161b22",
        NODE_DEFAULT_BOXCOLOR: "#545d70",
        NODE_DEFAULT_SHAPE: "box",
        NODE_BOX_OUTLINE_COLOR: "#e5eaf0",
        NODE_BYPASS_BGCOLOR: "#FF00FF",
        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
        DEFAULT_GROUP_FONT: 24,
        WIDGET_BGCOLOR: "#2e3440",
        WIDGET_OUTLINE_COLOR: "#545d70",
        WIDGET_TEXT_COLOR: "#bcc2c8",
        WIDGET_SECONDARY_TEXT_COLOR: "#999",
        LINK_COLOR: "#9A9",
        EVENT_LINK_COLOR: "#A86",
        CONNECTING_LINK_COLOR: "#AFA"
      },
      comfy_base: {
        "fg-color": "#e5eaf0",
        "bg-color": "#2e3440",
        "comfy-menu-bg": "#161b22",
        "comfy-input-bg": "#2e3440",
        "input-text": "#bcc2c8",
        "descrip-text": "#999",
        "drag-text": "#ccc",
        "error-text": "#ff4444",
        "border-color": "#545d70",
        "tr-even-bg-color": "#2e3440",
        "tr-odd-bg-color": "#161b22",
        "content-bg": "#545d70",
        "content-fg": "#e5eaf0",
        "content-hover-bg": "#2e3440",
        "content-hover-fg": "#e5eaf0"
      }
    }
  },
  github: {
    id: "github",
    name: "Github",
    colors: {
      node_slot: {
        BOOLEAN: "",
        CLIP: "#eacb8b",
        CLIP_VISION: "#A8DADC",
        CLIP_VISION_OUTPUT: "#ad7452",
        CONDITIONING: "#cf876f",
        CONTROL_NET: "#00d78d",
        CONTROL_NET_WEIGHTS: "",
        FLOAT: "",
        GLIGEN: "",
        IMAGE: "#80a1c0",
        IMAGEUPLOAD: "",
        INT: "",
        LATENT: "#b38ead",
        LATENT_KEYFRAME: "",
        MASK: "#a3bd8d",
        MODEL: "#8978a7",
        SAMPLER: "",
        SIGMAS: "",
        STRING: "",
        STYLE_MODEL: "#C2FFAE",
        T2I_ADAPTER_WEIGHTS: "",
        TAESD: "#DCC274",
        TIMESTEP_KEYFRAME: "",
        UPSCALE_MODEL: "",
        VAE: "#be616b"
      },
      litegraph_base: {
        BACKGROUND_IMAGE: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGlmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMy0xMS0xM1QwMDoxODowMiswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjMtMTEtMTVUMDI6MDQ6NTkrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjMtMTEtMTVUMDI6MDQ6NTkrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmIyYzRhNjA5LWJmYTctYTg0MC1iOGFlLTk3MzE2ZjM1ZGIyNyIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjk0ZmNlZGU4LTE1MTctZmQ0MC04ZGU3LWYzOTgxM2E3ODk5ZiIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjIzMWIxMGIwLWI0ZmItMDI0ZS1iMTJlLTMwNTMwM2NkMDdjOCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MjMxYjEwYjAtYjRmYi0wMjRlLWIxMmUtMzA1MzAzY2QwN2M4IiBzdEV2dDp3aGVuPSIyMDIzLTExLTEzVDAwOjE4OjAyKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ4OWY1NzlmLTJkNjUtZWQ0Zi04OTg0LTA4NGE2MGE1ZTMzNSIgc3RFdnQ6d2hlbj0iMjAyMy0xMS0xNVQwMjowNDo1OSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiMmM0YTYwOS1iZmE3LWE4NDAtYjhhZS05NzMxNmYzNWRiMjciIHN0RXZ0OndoZW49IjIwMjMtMTEtMTVUMDI6MDQ6NTkrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4OTe6GAAAAx0lEQVR42u3WMQoAIQxFwRzJys77X8vSLiRgITif7bYbgrwYc/mKXyBoY4VVBgsWLFiwYFmOlTv+9jfDOjHmr8u6eVkGCxYsWLBgmc5S8ApewXvgYRksWLBgKXidpeBdloL3wMOCBctgwVLwCl7BuyyDBQsWLFiwTGcpeAWv4D3wsAwWLFiwFLzOUvAuS8F74GHBgmWwYCl4Ba/gXZbBggULFixYprMUvIJX8B54WAYLFixYCl5nKXiXpeA98LBgwTJYsGC9tg1o8f4TTtqzNQAAAABJRU5ErkJggg==",
        CLEAR_BACKGROUND_COLOR: "#040506",
        NODE_TITLE_COLOR: "#999",
        NODE_SELECTED_TITLE_COLOR: "#e5eaf0",
        NODE_TEXT_SIZE: 14,
        NODE_TEXT_COLOR: "#bcc2c8",
        NODE_SUBTEXT_SIZE: 12,
        NODE_DEFAULT_COLOR: "#161b22",
        NODE_DEFAULT_BGCOLOR: "#13171d",
        NODE_DEFAULT_BOXCOLOR: "#30363d",
        NODE_DEFAULT_SHAPE: "box",
        NODE_BOX_OUTLINE_COLOR: "#e5eaf0",
        NODE_BYPASS_BGCOLOR: "#FF00FF",
        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
        DEFAULT_GROUP_FONT: 24,
        WIDGET_BGCOLOR: "#161b22",
        WIDGET_OUTLINE_COLOR: "#30363d",
        WIDGET_TEXT_COLOR: "#bcc2c8",
        WIDGET_SECONDARY_TEXT_COLOR: "#999",
        LINK_COLOR: "#9A9",
        EVENT_LINK_COLOR: "#A86",
        CONNECTING_LINK_COLOR: "#AFA"
      },
      comfy_base: {
        "fg-color": "#e5eaf0",
        "bg-color": "#161b22",
        "comfy-menu-bg": "#13171d",
        "comfy-input-bg": "#161b22",
        "input-text": "#bcc2c8",
        "descrip-text": "#999",
        "drag-text": "#ccc",
        "error-text": "#ff4444",
        "border-color": "#30363d",
        "tr-even-bg-color": "#161b22",
        "tr-odd-bg-color": "#13171d",
        "content-bg": "#30363d",
        "content-fg": "#e5eaf0",
        "content-hover-bg": "#161b22",
        "content-hover-fg": "#e5eaf0"
      }
    }
  }
};
const id = "Comfy.ColorPalette";
const idCustomColorPalettes = "Comfy.CustomColorPalettes";
const defaultColorPaletteId = "dark";
const els = {
  select: null
};
const getCustomColorPalettes = /* @__PURE__ */ __name(() => {
  return app$1.ui.settings.getSettingValue(idCustomColorPalettes, {});
}, "getCustomColorPalettes");
const setCustomColorPalettes = /* @__PURE__ */ __name((customColorPalettes) => {
  return app$1.ui.settings.setSettingValue(
    idCustomColorPalettes,
    customColorPalettes
  );
}, "setCustomColorPalettes");
const defaultColorPalette = colorPalettes[defaultColorPaletteId];
const getColorPalette = /* @__PURE__ */ __name((colorPaletteId) => {
  if (!colorPaletteId) {
    colorPaletteId = app$1.ui.settings.getSettingValue(id, defaultColorPaletteId);
  }
  if (colorPaletteId.startsWith("custom_")) {
    colorPaletteId = colorPaletteId.substr(7);
    let customColorPalettes = getCustomColorPalettes();
    if (customColorPalettes[colorPaletteId]) {
      return customColorPalettes[colorPaletteId];
    }
  }
  return colorPalettes[colorPaletteId];
}, "getColorPalette");
const setColorPalette = /* @__PURE__ */ __name((colorPaletteId) => {
  app$1.ui.settings.setSettingValue(id, colorPaletteId);
}, "setColorPalette");
app$1.registerExtension({
  name: id,
  init() {
    LGraphCanvas.prototype.updateBackground = function(image, clearBackgroundColor) {
      this._bg_img = new Image();
      this._bg_img.name = image;
      this._bg_img.src = image;
      this._bg_img.onload = () => {
        this.draw(true, true);
      };
      this.background_image = image;
      this.clear_background = true;
      this.clear_background_color = clearBackgroundColor;
      this._pattern = null;
    };
  },
  addCustomNodeDefs(node_defs) {
    const sortObjectKeys = /* @__PURE__ */ __name((unordered) => {
      return Object.keys(unordered).sort().reduce((obj, key) => {
        obj[key] = unordered[key];
        return obj;
      }, {});
    }, "sortObjectKeys");
    function getSlotTypes() {
      var types = [];
      const defs = node_defs;
      for (const nodeId in defs) {
        const nodeData = defs[nodeId];
        var inputs = nodeData["input"]["required"];
        if (nodeData["input"]["optional"] !== void 0) {
          inputs = Object.assign(
            {},
            nodeData["input"]["required"],
            nodeData["input"]["optional"]
          );
        }
        for (const inputName in inputs) {
          const inputData = inputs[inputName];
          const type = inputData[0];
          if (!Array.isArray(type)) {
            types.push(type);
          }
        }
        for (const o in nodeData["output"]) {
          const output = nodeData["output"][o];
          types.push(output);
        }
      }
      return types;
    }
    __name(getSlotTypes, "getSlotTypes");
    function completeColorPalette(colorPalette) {
      var types = getSlotTypes();
      for (const type of types) {
        if (!colorPalette.colors.node_slot[type]) {
          colorPalette.colors.node_slot[type] = "";
        }
      }
      colorPalette.colors.node_slot = sortObjectKeys(
        colorPalette.colors.node_slot
      );
      return colorPalette;
    }
    __name(completeColorPalette, "completeColorPalette");
    const getColorPaletteTemplate = /* @__PURE__ */ __name(async () => {
      let colorPalette = {
        id: "my_color_palette_unique_id",
        name: "My Color Palette",
        colors: {
          node_slot: {},
          litegraph_base: {},
          comfy_base: {}
        }
      };
      const defaultColorPalette2 = colorPalettes[defaultColorPaletteId];
      for (const key in defaultColorPalette2.colors.litegraph_base) {
        if (!colorPalette.colors.litegraph_base[key]) {
          colorPalette.colors.litegraph_base[key] = "";
        }
      }
      for (const key in defaultColorPalette2.colors.comfy_base) {
        if (!colorPalette.colors.comfy_base[key]) {
          colorPalette.colors.comfy_base[key] = "";
        }
      }
      return completeColorPalette(colorPalette);
    }, "getColorPaletteTemplate");
    const addCustomColorPalette = /* @__PURE__ */ __name(async (colorPalette) => {
      if (typeof colorPalette !== "object") {
        useToastStore().addAlert("Invalid color palette.");
        return;
      }
      if (!colorPalette.id) {
        useToastStore().addAlert("Color palette missing id.");
        return;
      }
      if (!colorPalette.name) {
        useToastStore().addAlert("Color palette missing name.");
        return;
      }
      if (!colorPalette.colors) {
        useToastStore().addAlert("Color palette missing colors.");
        return;
      }
      if (colorPalette.colors.node_slot && typeof colorPalette.colors.node_slot !== "object") {
        useToastStore().addAlert("Invalid color palette colors.node_slot.");
        return;
      }
      const customColorPalettes = getCustomColorPalettes();
      customColorPalettes[colorPalette.id] = colorPalette;
      setCustomColorPalettes(customColorPalettes);
      for (const option3 of els.select.childNodes) {
        if (option3.value === "custom_" + colorPalette.id) {
          els.select.removeChild(option3);
        }
      }
      els.select.append(
        $el("option", {
          textContent: colorPalette.name + " (custom)",
          value: "custom_" + colorPalette.id,
          selected: true
        })
      );
      setColorPalette("custom_" + colorPalette.id);
      await loadColorPalette(colorPalette);
    }, "addCustomColorPalette");
    const deleteCustomColorPalette = /* @__PURE__ */ __name(async (colorPaletteId) => {
      const customColorPalettes = getCustomColorPalettes();
      delete customColorPalettes[colorPaletteId];
      setCustomColorPalettes(customColorPalettes);
      for (const opt of els.select.childNodes) {
        const option3 = opt;
        if (option3.value === defaultColorPaletteId) {
          option3.selected = true;
        }
        if (option3.value === "custom_" + colorPaletteId) {
          els.select.removeChild(option3);
        }
      }
      setColorPalette(defaultColorPaletteId);
      await loadColorPalette(getColorPalette());
    }, "deleteCustomColorPalette");
    const loadColorPalette = /* @__PURE__ */ __name(async (colorPalette) => {
      colorPalette = await completeColorPalette(colorPalette);
      if (colorPalette.colors) {
        if (colorPalette.colors.node_slot) {
          Object.assign(
            app$1.canvas.default_connection_color_byType,
            colorPalette.colors.node_slot
          );
          Object.assign(
            LGraphCanvas.link_type_colors,
            colorPalette.colors.node_slot
          );
        }
        if (colorPalette.colors.litegraph_base) {
          app$1.canvas.node_title_color = colorPalette.colors.litegraph_base.NODE_TITLE_COLOR;
          app$1.canvas.default_link_color = colorPalette.colors.litegraph_base.LINK_COLOR;
          for (const key in colorPalette.colors.litegraph_base) {
            if (colorPalette.colors.litegraph_base.hasOwnProperty(key) && LiteGraph.hasOwnProperty(key)) {
              LiteGraph[key] = colorPalette.colors.litegraph_base[key];
            }
          }
        }
        if (colorPalette.colors.comfy_base) {
          const rootStyle = document.documentElement.style;
          for (const key in colorPalette.colors.comfy_base) {
            rootStyle.setProperty(
              "--" + key,
              colorPalette.colors.comfy_base[key]
            );
          }
        }
        if (colorPalette.colors.litegraph_base.NODE_BYPASS_BGCOLOR) {
          app$1.bypassBgColor = colorPalette.colors.litegraph_base.NODE_BYPASS_BGCOLOR;
        }
        app$1.canvas.draw(true, true);
      }
    }, "loadColorPalette");
    const fileInput2 = $el("input", {
      type: "file",
      accept: ".json",
      style: { display: "none" },
      parent: document.body,
      onchange: /* @__PURE__ */ __name(() => {
        const file = fileInput2.files[0];
        if (file.type === "application/json" || file.name.endsWith(".json")) {
          const reader = new FileReader();
          reader.onload = async () => {
            await addCustomColorPalette(JSON.parse(reader.result));
          };
          reader.readAsText(file);
        }
      }, "onchange")
    });
    app$1.ui.settings.addSetting({
      id,
      category: ["Comfy", "ColorPalette"],
      name: "Color Palette",
      type: /* @__PURE__ */ __name((name, setter, value3) => {
        const options3 = [
          ...Object.values(colorPalettes).map(
            (c) => $el("option", {
              textContent: c.name,
              value: c.id,
              selected: c.id === value3
            })
          ),
          ...Object.values(getCustomColorPalettes()).map(
            (c) => $el("option", {
              textContent: `${c.name} (custom)`,
              value: `custom_${c.id}`,
              selected: `custom_${c.id}` === value3
            })
          )
        ];
        els.select = $el(
          "select",
          {
            style: {
              marginBottom: "0.15rem",
              width: "100%"
            },
            onchange: /* @__PURE__ */ __name((e) => {
              setter(e.target.value);
            }, "onchange")
          },
          options3
        );
        return $el("tr", [
          $el("td", [
            els.select,
            $el(
              "div",
              {
                style: {
                  display: "grid",
                  gap: "4px",
                  gridAutoFlow: "column"
                }
              },
              [
                $el("input", {
                  type: "button",
                  value: "Export",
                  onclick: /* @__PURE__ */ __name(async () => {
                    const colorPaletteId = app$1.ui.settings.getSettingValue(
                      id,
                      defaultColorPaletteId
                    );
                    const colorPalette = await completeColorPalette(
                      getColorPalette(colorPaletteId)
                    );
                    const json = JSON.stringify(colorPalette, null, 2);
                    const blob = new Blob([json], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = $el("a", {
                      href: url,
                      download: colorPaletteId + ".json",
                      style: { display: "none" },
                      parent: document.body
                    });
                    a.click();
                    setTimeout(function() {
                      a.remove();
                      window.URL.revokeObjectURL(url);
                    }, 0);
                  }, "onclick")
                }),
                $el("input", {
                  type: "button",
                  value: "Import",
                  onclick: /* @__PURE__ */ __name(() => {
                    fileInput2.click();
                  }, "onclick")
                }),
                $el("input", {
                  type: "button",
                  value: "Template",
                  onclick: /* @__PURE__ */ __name(async () => {
                    const colorPalette = await getColorPaletteTemplate();
                    const json = JSON.stringify(colorPalette, null, 2);
                    const blob = new Blob([json], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = $el("a", {
                      href: url,
                      download: "color_palette.json",
                      style: { display: "none" },
                      parent: document.body
                    });
                    a.click();
                    setTimeout(function() {
                      a.remove();
                      window.URL.revokeObjectURL(url);
                    }, 0);
                  }, "onclick")
                }),
                $el("input", {
                  type: "button",
                  value: "Delete",
                  onclick: /* @__PURE__ */ __name(async () => {
                    let colorPaletteId = app$1.ui.settings.getSettingValue(
                      id,
                      defaultColorPaletteId
                    );
                    if (colorPalettes[colorPaletteId]) {
                      useToastStore().addAlert(
                        "You cannot delete a built-in color palette."
                      );
                      return;
                    }
                    if (colorPaletteId.startsWith("custom_")) {
                      colorPaletteId = colorPaletteId.substr(7);
                    }
                    await deleteCustomColorPalette(colorPaletteId);
                  }, "onclick")
                })
              ]
            )
          ])
        ]);
      }, "type"),
      defaultValue: defaultColorPaletteId,
      async onChange(value3) {
        if (!value3) {
          return;
        }
        let palette = colorPalettes[value3];
        if (palette) {
          await loadColorPalette(palette);
        } else if (value3.startsWith("custom_")) {
          value3 = value3.substr(7);
          let customColorPalettes = getCustomColorPalettes();
          if (customColorPalettes[value3]) {
            palette = customColorPalettes[value3];
            await loadColorPalette(customColorPalettes[value3]);
          }
        }
        let { BACKGROUND_IMAGE, CLEAR_BACKGROUND_COLOR } = palette.colors.litegraph_base;
        if (BACKGROUND_IMAGE === void 0 || CLEAR_BACKGROUND_COLOR === void 0) {
          const base = colorPalettes["dark"].colors.litegraph_base;
          BACKGROUND_IMAGE = base.BACKGROUND_IMAGE;
          CLEAR_BACKGROUND_COLOR = base.CLEAR_BACKGROUND_COLOR;
        }
        app$1.canvas.updateBackground(BACKGROUND_IMAGE, CLEAR_BACKGROUND_COLOR);
      }
    });
  }
});
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.colorPalette = window.comfyAPI.colorPalette || {};
window.comfyAPI.colorPalette.defaultColorPalette = defaultColorPalette;
window.comfyAPI.colorPalette.getColorPalette = getColorPalette;
const _withScopeId$6 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-4b126b34"), n = n(), popScopeId(), n), "_withScopeId$6");
const _hoisted_1$l = { class: "_sb_node_preview" };
const _hoisted_2$e = { class: "_sb_table" };
const _hoisted_3$8 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_dot headdot" }, null, -1));
const _hoisted_4$6 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_preview_badge" }, "PREVIEW", -1));
const _hoisted_5$4 = { class: "_sb_col" };
const _hoisted_6$3 = { class: "_sb_col" };
const _hoisted_7$2 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col middle-column" }, null, -1));
const _hoisted_8$1 = { class: "_sb_col" };
const _hoisted_9$1 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col _sb_arrow" }, "", -1));
const _hoisted_10$1 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col middle-column" }, null, -1));
const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col _sb_arrow" }, "", -1));
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "NodePreview",
  props: {
    nodeDef: {
      type: ComfyNodeDefImpl,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const colors = getColorPalette()?.colors?.litegraph_base;
    const litegraphColors = colors ?? defaultColorPalette.colors.litegraph_base;
    const widgetStore = useWidgetStore();
    const nodeDef = props.nodeDef;
    const allInputDefs = nodeDef.input.all;
    const allOutputDefs = nodeDef.output.all;
    const slotInputDefs = allInputDefs.filter(
      (input) => !widgetStore.inputIsWidget(input)
    );
    const widgetInputDefs = allInputDefs.filter(
      (input) => widgetStore.inputIsWidget(input)
    );
    const truncateDefaultValue = /* @__PURE__ */ __name((value3, charLimit = 32) => {
      let stringValue;
      if (typeof value3 === "object" && value3 !== null) {
        stringValue = JSON.stringify(value3);
      } else if (Array.isArray(value3)) {
        stringValue = JSON.stringify(value3);
      } else if (typeof value3 === "string") {
        stringValue = value3;
      } else {
        stringValue = String(value3);
      }
      return _.truncate(stringValue, { length: charLimit });
    }, "truncateDefaultValue");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createBaseVNode("div", _hoisted_2$e, [
          createBaseVNode("div", {
            class: "node_header",
            style: normalizeStyle({
              backgroundColor: unref(litegraphColors).NODE_DEFAULT_COLOR,
              color: unref(litegraphColors).NODE_TITLE_COLOR
            })
          }, [
            _hoisted_3$8,
            createTextVNode(" " + toDisplayString$1(unref(nodeDef).display_name), 1)
          ], 4),
          _hoisted_4$6,
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(_).zip(unref(slotInputDefs), unref(allOutputDefs)), ([slotInput, slotOutput]) => {
            return openBlock(), createElementBlock("div", {
              class: "_sb_row slot_row",
              key: (slotInput?.name || "") + (slotOutput?.index.toString() || "")
            }, [
              createBaseVNode("div", _hoisted_5$4, [
                slotInput ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["_sb_dot", slotInput.type])
                }, null, 2)) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_6$3, toDisplayString$1(slotInput ? slotInput.name : ""), 1),
              _hoisted_7$2,
              createBaseVNode("div", {
                class: "_sb_col _sb_inherit",
                style: normalizeStyle({
                  color: unref(litegraphColors).NODE_TEXT_COLOR
                })
              }, toDisplayString$1(slotOutput ? slotOutput.name : ""), 5),
              createBaseVNode("div", _hoisted_8$1, [
                slotOutput ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["_sb_dot", slotOutput.type])
                }, null, 2)) : createCommentVNode("", true)
              ])
            ]);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(widgetInputDefs), (widgetInput) => {
            return openBlock(), createElementBlock("div", {
              class: "_sb_row _long_field",
              key: widgetInput.name
            }, [
              _hoisted_9$1,
              createBaseVNode("div", {
                class: "_sb_col",
                style: normalizeStyle({
                  color: unref(litegraphColors).WIDGET_SECONDARY_TEXT_COLOR
                })
              }, toDisplayString$1(widgetInput.name), 5),
              _hoisted_10$1,
              createBaseVNode("div", {
                class: "_sb_col _sb_inherit",
                style: normalizeStyle({ color: unref(litegraphColors).WIDGET_TEXT_COLOR })
              }, toDisplayString$1(truncateDefaultValue(widgetInput.default)), 5),
              _hoisted_11$1
            ]);
          }), 128))
        ]),
        unref(nodeDef).description ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "_sb_description",
          style: normalizeStyle({
            color: unref(litegraphColors).WIDGET_SECONDARY_TEXT_COLOR,
            backgroundColor: unref(litegraphColors).WIDGET_BGCOLOR
          })
        }, toDisplayString$1(unref(nodeDef).description), 5)) : createCommentVNode("", true)
      ]);
    };
  }
});
const NodePreview = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-4b126b34"]]);
const BOOKMARK_SETTING_ID = "Comfy.NodeLibrary.Bookmarks.V2";
const useNodeBookmarkStore = /* @__PURE__ */ defineStore("nodeBookmark", () => {
  const settingStore = useSettingStore();
  const nodeDefStore = useNodeDefStore();
  const migrateLegacyBookmarks = /* @__PURE__ */ __name(() => {
    const legacyBookmarks = settingStore.get("Comfy.NodeLibrary.Bookmarks");
    if (!legacyBookmarks.length) {
      return;
    }
    legacyBookmarks.forEach((bookmark) => {
      if (bookmark.endsWith("/")) {
        addBookmark(bookmark);
        return;
      }
      const category = bookmark.split("/").slice(0, -1).join("/");
      const displayName = bookmark.split("/").pop() ?? "";
      const nodeDef = nodeDefStore.nodeDefsByDisplayName[displayName];
      if (!nodeDef) return;
      addBookmark(`${category === "" ? "" : category + "/"}${nodeDef.name}`);
    });
    settingStore.set("Comfy.NodeLibrary.Bookmarks", []);
  }, "migrateLegacyBookmarks");
  const bookmarks = computed(
    () => settingStore.get(BOOKMARK_SETTING_ID)
  );
  const bookmarksSet = computed(() => new Set(bookmarks.value));
  const bookmarkedRoot = computed(
    () => buildBookmarkTree(bookmarks.value)
  );
  const isBookmarked = /* @__PURE__ */ __name((node3) => bookmarksSet.value.has(node3.nodePath) || bookmarksSet.value.has(node3.name), "isBookmarked");
  const toggleBookmark = /* @__PURE__ */ __name((node3) => {
    if (isBookmarked(node3)) {
      deleteBookmark(node3.nodePath);
      deleteBookmark(node3.name);
    } else {
      addBookmark(node3.name);
    }
  }, "toggleBookmark");
  const buildBookmarkTree = /* @__PURE__ */ __name((bookmarks2) => {
    const bookmarkNodes = bookmarks2.map((bookmark) => {
      if (bookmark.endsWith("/")) return createDummyFolderNodeDef(bookmark);
      const parts2 = bookmark.split("/");
      const name = parts2.pop() ?? "";
      const category = parts2.join("/");
      const srcNodeDef = nodeDefStore.nodeDefsByName[name];
      if (!srcNodeDef) {
        return null;
      }
      const nodeDef = _.clone(srcNodeDef);
      nodeDef.category = category;
      return nodeDef;
    }).filter((nodeDef) => nodeDef !== null);
    return buildNodeDefTree(bookmarkNodes);
  }, "buildBookmarkTree");
  const addBookmark = /* @__PURE__ */ __name((nodePath) => {
    settingStore.set(BOOKMARK_SETTING_ID, [...bookmarks.value, nodePath]);
  }, "addBookmark");
  const deleteBookmark = /* @__PURE__ */ __name((nodePath) => {
    settingStore.set(
      BOOKMARK_SETTING_ID,
      bookmarks.value.filter((b) => b !== nodePath)
    );
  }, "deleteBookmark");
  const addNewBookmarkFolder = /* @__PURE__ */ __name((parent) => {
    const parentPath = parent ? parent.nodePath : "";
    let newFolderPath = parentPath + "New Folder/";
    let suffix2 = 1;
    while (bookmarks.value.some((b) => b.startsWith(newFolderPath))) {
      newFolderPath = parentPath + `New Folder ${suffix2}/`;
      suffix2++;
    }
    addBookmark(newFolderPath);
    return newFolderPath;
  }, "addNewBookmarkFolder");
  const renameBookmarkFolder = /* @__PURE__ */ __name((folderNode, newName) => {
    if (!folderNode.isDummyFolder) {
      throw new Error("Cannot rename non-folder node");
    }
    if (newName.includes("/")) {
      throw new Error('Folder name cannot contain "/"');
    }
    const newNodePath = folderNode.category.split("/").slice(0, -1).concat(newName).join("/") + "/";
    if (newNodePath === folderNode.nodePath) {
      return;
    }
    if (bookmarks.value.some((b) => b.startsWith(newNodePath))) {
      throw new Error(`Folder name "${newNodePath}" already exists`);
    }
    settingStore.set(
      BOOKMARK_SETTING_ID,
      bookmarks.value.map(
        (b) => b.startsWith(folderNode.nodePath) ? b.replace(folderNode.nodePath, newNodePath) : b
      )
    );
    renameBookmarkCustomization(folderNode.nodePath, newNodePath);
  }, "renameBookmarkFolder");
  const deleteBookmarkFolder = /* @__PURE__ */ __name((folderNode) => {
    if (!folderNode.isDummyFolder) {
      throw new Error("Cannot delete non-folder node");
    }
    settingStore.set(
      BOOKMARK_SETTING_ID,
      bookmarks.value.filter(
        (b) => b !== folderNode.nodePath && !b.startsWith(folderNode.nodePath)
      )
    );
    deleteBookmarkCustomization(folderNode.nodePath);
  }, "deleteBookmarkFolder");
  const bookmarksCustomization = computed(() => settingStore.get("Comfy.NodeLibrary.BookmarksCustomization"));
  const updateBookmarkCustomization = /* @__PURE__ */ __name((nodePath, customization) => {
    const currentCustomization = bookmarksCustomization.value[nodePath] || {};
    const newCustomization = { ...currentCustomization, ...customization };
    if (newCustomization.icon === defaultBookmarkIcon) {
      delete newCustomization.icon;
    }
    if (newCustomization.color === defaultBookmarkColor) {
      delete newCustomization.color;
    }
    if (Object.keys(newCustomization).length === 0) {
      deleteBookmarkCustomization(nodePath);
    } else {
      settingStore.set("Comfy.NodeLibrary.BookmarksCustomization", {
        ...bookmarksCustomization.value,
        [nodePath]: newCustomization
      });
    }
  }, "updateBookmarkCustomization");
  const deleteBookmarkCustomization = /* @__PURE__ */ __name((nodePath) => {
    settingStore.set("Comfy.NodeLibrary.BookmarksCustomization", {
      ...bookmarksCustomization.value,
      [nodePath]: void 0
    });
  }, "deleteBookmarkCustomization");
  const renameBookmarkCustomization = /* @__PURE__ */ __name((oldNodePath, newNodePath) => {
    const updatedCustomization = { ...bookmarksCustomization.value };
    if (updatedCustomization[oldNodePath]) {
      updatedCustomization[newNodePath] = updatedCustomization[oldNodePath];
      delete updatedCustomization[oldNodePath];
    }
    settingStore.set(
      "Comfy.NodeLibrary.BookmarksCustomization",
      updatedCustomization
    );
  }, "renameBookmarkCustomization");
  const defaultBookmarkIcon = "pi-bookmark-fill";
  const defaultBookmarkColor = "#a1a1aa";
  return {
    bookmarks,
    bookmarkedRoot,
    isBookmarked,
    toggleBookmark,
    addBookmark,
    addNewBookmarkFolder,
    renameBookmarkFolder,
    deleteBookmarkFolder,
    bookmarksCustomization,
    updateBookmarkCustomization,
    deleteBookmarkCustomization,
    renameBookmarkCustomization,
    defaultBookmarkIcon,
    defaultBookmarkColor,
    migrateLegacyBookmarks
  };
});
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "NodeTreeLeaf",
  props: {
    node: {}
  },
  emits: ["toggle-bookmark"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const nodeDef = computed(() => props.node.data);
    const nodeBookmarkStore = useNodeBookmarkStore();
    const isBookmarked = computed(
      () => nodeBookmarkStore.isBookmarked(nodeDef.value)
    );
    const settingStore = useSettingStore();
    const sidebarLocation = computed(
      () => settingStore.get("Comfy.Sidebar.Location")
    );
    const emit2 = __emit;
    const toggleBookmark = /* @__PURE__ */ __name(() => {
      nodeBookmarkStore.toggleBookmark(nodeDef.value);
    }, "toggleBookmark");
    const previewRef = ref(null);
    const nodePreviewStyle = ref({
      position: "absolute",
      top: "0px",
      left: "0px"
    });
    const handleNodeHover = /* @__PURE__ */ __name(async () => {
      const hoverTarget = nodeContentElement.value;
      const targetRect = hoverTarget.getBoundingClientRect();
      const previewHeight = previewRef.value?.$el.offsetHeight || 0;
      const availableSpaceBelow = window.innerHeight - targetRect.bottom;
      nodePreviewStyle.value.top = previewHeight > availableSpaceBelow ? `${Math.max(0, targetRect.top - (previewHeight - availableSpaceBelow) - 20)}px` : `${targetRect.top - 40}px`;
      if (sidebarLocation.value === "left") {
        nodePreviewStyle.value.left = `${targetRect.right}px`;
      } else {
        nodePreviewStyle.value.left = `${targetRect.left - 400}px`;
      }
    }, "handleNodeHover");
    const container = ref(null);
    const nodeContentElement = ref(null);
    const isHovered = ref(false);
    const handleMouseEnter = /* @__PURE__ */ __name(async () => {
      isHovered.value = true;
      await nextTick();
      handleNodeHover();
    }, "handleMouseEnter");
    const handleMouseLeave = /* @__PURE__ */ __name(() => {
      isHovered.value = false;
    }, "handleMouseLeave");
    onMounted(() => {
      nodeContentElement.value = container.value?.closest(".p-tree-node-content");
      nodeContentElement.value?.addEventListener("mouseenter", handleMouseEnter);
      nodeContentElement.value?.addEventListener("mouseleave", handleMouseLeave);
    });
    onUnmounted(() => {
      nodeContentElement.value?.removeEventListener("mouseenter", handleMouseEnter);
      nodeContentElement.value?.removeEventListener("mouseleave", handleMouseLeave);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container,
        class: "node-lib-node-container"
      }, [
        createVNode(TreeExplorerTreeNode, { node: _ctx.node }, {
          "before-label": withCtx(() => [
            nodeDef.value.experimental ? (openBlock(), createBlock(unref(script$w), {
              key: 0,
              value: _ctx.$t("experimental"),
              severity: "primary"
            }, null, 8, ["value"])) : createCommentVNode("", true),
            nodeDef.value.deprecated ? (openBlock(), createBlock(unref(script$w), {
              key: 1,
              value: _ctx.$t("deprecated"),
              severity: "danger"
            }, null, 8, ["value"])) : createCommentVNode("", true)
          ]),
          actions: withCtx(() => [
            createVNode(unref(script$M), {
              class: "bookmark-button",
              size: "small",
              icon: isBookmarked.value ? "pi pi-bookmark-fill" : "pi pi-bookmark",
              text: "",
              severity: "secondary",
              onClick: withModifiers(toggleBookmark, ["stop"])
            }, null, 8, ["icon"])
          ]),
          _: 1
        }, 8, ["node"]),
        isHovered.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: "#node-library-node-preview-container"
        }, [
          createBaseVNode("div", {
            class: "node-lib-node-preview",
            style: normalizeStyle(nodePreviewStyle.value)
          }, [
            createVNode(NodePreview, {
              ref_key: "previewRef",
              ref: previewRef,
              nodeDef: nodeDef.value
            }, null, 8, ["nodeDef"])
          ], 4)
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});
const NodeTreeLeaf = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-90dfee08"]]);
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "NodeTreeFolder",
  props: {
    node: {}
  },
  setup(__props) {
    const props = __props;
    const nodeBookmarkStore = useNodeBookmarkStore();
    const customization = computed(() => {
      return nodeBookmarkStore.bookmarksCustomization[props.node.data.nodePath];
    });
    const treeNodeElement = ref(null);
    const iconElement = ref(null);
    let stopWatchCustomization = null;
    const container = ref(null);
    onMounted(() => {
      treeNodeElement.value = container.value?.closest(
        ".p-tree-node-content"
      );
      iconElement.value = treeNodeElement.value.querySelector(
        ":scope > .p-tree-node-icon"
      );
      updateIconColor();
      stopWatchCustomization = watch(customization, updateIconColor, { deep: true });
    });
    const updateIconColor = /* @__PURE__ */ __name(() => {
      if (iconElement.value && customization.value) {
        iconElement.value.style.color = customization.value.color;
      }
    }, "updateIconColor");
    onUnmounted(() => {
      if (stopWatchCustomization) {
        stopWatchCustomization();
      }
    });
    const expandedKeys2 = inject("expandedKeys");
    const handleItemDrop = /* @__PURE__ */ __name((node3) => {
      expandedKeys2.value[node3.key] = true;
    }, "handleItemDrop");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container,
        class: "node-lib-node-container"
      }, [
        createVNode(TreeExplorerTreeNode, {
          node: _ctx.node,
          onItemDropped: handleItemDrop
        }, null, 8, ["node"])
      ], 512);
    };
  }
});
var script$d = {
  name: "WindowMaximizeIcon",
  "extends": script$X
};
var _hoisted_1$k = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14ZM9.77805 7.42192C9.89013 7.534 10.0415 7.59788 10.2 7.59995C10.3585 7.59788 10.5099 7.534 10.622 7.42192C10.7341 7.30985 10.798 7.15844 10.8 6.99995V3.94242C10.8066 3.90505 10.8096 3.86689 10.8089 3.82843C10.8079 3.77159 10.7988 3.7157 10.7824 3.6623C10.756 3.55552 10.701 3.45698 10.622 3.37798C10.5099 3.2659 10.3585 3.20202 10.2 3.19995H7.00002C6.84089 3.19995 6.68828 3.26317 6.57576 3.37569C6.46324 3.48821 6.40002 3.64082 6.40002 3.79995C6.40002 3.95908 6.46324 4.11169 6.57576 4.22422C6.68828 4.33674 6.84089 4.39995 7.00002 4.39995H8.80006L6.19997 7.00005C6.10158 7.11005 6.04718 7.25246 6.04718 7.40005C6.04718 7.54763 6.10158 7.69004 6.19997 7.80005C6.30202 7.91645 6.44561 7.98824 6.59997 8.00005C6.75432 7.98824 6.89791 7.91645 6.99997 7.80005L9.60002 5.26841V6.99995C9.6021 7.15844 9.66598 7.30985 9.77805 7.42192ZM1.4 14H3.8C4.17066 13.9979 4.52553 13.8498 4.78763 13.5877C5.04973 13.3256 5.1979 12.9707 5.2 12.6V10.2C5.1979 9.82939 5.04973 9.47452 4.78763 9.21242C4.52553 8.95032 4.17066 8.80215 3.8 8.80005H1.4C1.02934 8.80215 0.674468 8.95032 0.412371 9.21242C0.150274 9.47452 0.00210008 9.82939 0 10.2V12.6C0.00210008 12.9707 0.150274 13.3256 0.412371 13.5877C0.674468 13.8498 1.02934 13.9979 1.4 14ZM1.25858 10.0586C1.29609 10.0211 1.34696 10 1.4 10H3.8C3.85304 10 3.90391 10.0211 3.94142 10.0586C3.97893 10.0961 4 10.147 4 10.2V12.6C4 12.6531 3.97893 12.704 3.94142 12.7415C3.90391 12.779 3.85304 12.8 3.8 12.8H1.4C1.34696 12.8 1.29609 12.779 1.25858 12.7415C1.22107 12.704 1.2 12.6531 1.2 12.6V10.2C1.2 10.147 1.22107 10.0961 1.25858 10.0586Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$d = [_hoisted_1$k];
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$d, 16);
}
__name(render$c, "render$c");
script$d.render = render$c;
var script$c = {
  name: "WindowMinimizeIcon",
  "extends": script$X
};
var _hoisted_1$j = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0ZM6.368 7.952C6.44137 7.98326 6.52025 7.99958 6.6 8H9.8C9.95913 8 10.1117 7.93678 10.2243 7.82426C10.3368 7.71174 10.4 7.55913 10.4 7.4C10.4 7.24087 10.3368 7.08826 10.2243 6.97574C10.1117 6.86321 9.95913 6.8 9.8 6.8H8.048L10.624 4.224C10.73 4.11026 10.7877 3.95982 10.7849 3.80438C10.7822 3.64894 10.7192 3.50063 10.6093 3.3907C10.4994 3.28077 10.3511 3.2178 10.1956 3.21506C10.0402 3.21232 9.88974 3.27002 9.776 3.376L7.2 5.952V4.2C7.2 4.04087 7.13679 3.88826 7.02426 3.77574C6.91174 3.66321 6.75913 3.6 6.6 3.6C6.44087 3.6 6.28826 3.66321 6.17574 3.77574C6.06321 3.88826 6 4.04087 6 4.2V7.4C6.00042 7.47975 6.01674 7.55862 6.048 7.632C6.07656 7.70442 6.11971 7.7702 6.17475 7.82524C6.2298 7.88029 6.29558 7.92344 6.368 7.952ZM1.4 8.80005H3.8C4.17066 8.80215 4.52553 8.95032 4.78763 9.21242C5.04973 9.47452 5.1979 9.82939 5.2 10.2V12.6C5.1979 12.9707 5.04973 13.3256 4.78763 13.5877C4.52553 13.8498 4.17066 13.9979 3.8 14H1.4C1.02934 13.9979 0.674468 13.8498 0.412371 13.5877C0.150274 13.3256 0.00210008 12.9707 0 12.6V10.2C0.00210008 9.82939 0.150274 9.47452 0.412371 9.21242C0.674468 8.95032 1.02934 8.80215 1.4 8.80005ZM3.94142 12.7415C3.97893 12.704 4 12.6531 4 12.6V10.2C4 10.147 3.97893 10.0961 3.94142 10.0586C3.90391 10.0211 3.85304 10 3.8 10H1.4C1.34696 10 1.29609 10.0211 1.25858 10.0586C1.22107 10.0961 1.2 10.147 1.2 10.2V12.6C1.2 12.6531 1.22107 12.704 1.25858 12.7415C1.29609 12.779 1.34696 12.8 1.4 12.8H3.8C3.85304 12.8 3.90391 12.779 3.94142 12.7415Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$c = [_hoisted_1$j];
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$c, 16);
}
__name(render$b, "render$b");
script$c.render = render$b;
var theme$7 = /* @__PURE__ */ __name(function theme30(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-dialog {\n    max-height: 90%;\n    transform: scale(1);\n    border-radius: ".concat(dt2("dialog.border.radius"), ";\n    box-shadow: ").concat(dt2("dialog.shadow"), ";\n    background: ").concat(dt2("dialog.background"), ";\n    border: 1px solid ").concat(dt2("dialog.border.color"), ";\n    color: ").concat(dt2("dialog.color"), ";\n}\n\n.p-dialog-content {\n    overflow-y: auto;\n    padding: ").concat(dt2("dialog.content.padding"), ";\n}\n\n.p-dialog-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-shrink: 0;\n    padding: ").concat(dt2("dialog.header.padding"), ";\n}\n\n.p-dialog-title {\n    font-weight: ").concat(dt2("dialog.title.font.weight"), ";\n    font-size: ").concat(dt2("dialog.title.font.size"), ";\n}\n\n.p-dialog-footer {\n    flex-shrink: 0;\n    padding: ").concat(dt2("dialog.footer.padding"), ";\n    display: flex;\n    justify-content: flex-end;\n    gap: ").concat(dt2("dialog.footer.gap"), ";\n}\n\n.p-dialog-header-actions {\n    display: flex;\n    align-items: center;\n    gap: ").concat(dt2("dialog.header.gap"), ";\n}\n.p-dialog-enter-active {\n    transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-dialog-leave-active {\n    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.p-dialog-enter-from,\n.p-dialog-leave-to {\n    opacity: 0;\n    transform: scale(0.7);\n}\n\n.p-dialog-top .p-dialog,\n.p-dialog-bottom .p-dialog,\n.p-dialog-left .p-dialog,\n.p-dialog-right .p-dialog,\n.p-dialog-topleft .p-dialog,\n.p-dialog-topright .p-dialog,\n.p-dialog-bottomleft .p-dialog,\n.p-dialog-bottomright .p-dialog {\n    margin: 0.75rem;\n    transform: translate3d(0px, 0px, 0px);\n}\n\n.p-dialog-top .p-dialog-enter-active,\n.p-dialog-top .p-dialog-leave-active,\n.p-dialog-bottom .p-dialog-enter-active,\n.p-dialog-bottom .p-dialog-leave-active,\n.p-dialog-left .p-dialog-enter-active,\n.p-dialog-left .p-dialog-leave-active,\n.p-dialog-right .p-dialog-enter-active,\n.p-dialog-right .p-dialog-leave-active,\n.p-dialog-topleft .p-dialog-enter-active,\n.p-dialog-topleft .p-dialog-leave-active,\n.p-dialog-topright .p-dialog-enter-active,\n.p-dialog-topright .p-dialog-leave-active,\n.p-dialog-bottomleft .p-dialog-enter-active,\n.p-dialog-bottomleft .p-dialog-leave-active,\n.p-dialog-bottomright .p-dialog-enter-active,\n.p-dialog-bottomright .p-dialog-leave-active {\n    transition: all 0.3s ease-out;\n}\n\n.p-dialog-top .p-dialog-enter-from,\n.p-dialog-top .p-dialog-leave-to {\n    transform: translate3d(0px, -100%, 0px);\n}\n\n.p-dialog-bottom .p-dialog-enter-from,\n.p-dialog-bottom .p-dialog-leave-to {\n    transform: translate3d(0px, 100%, 0px);\n}\n\n.p-dialog-left .p-dialog-enter-from,\n.p-dialog-left .p-dialog-leave-to,\n.p-dialog-topleft .p-dialog-enter-from,\n.p-dialog-topleft .p-dialog-leave-to,\n.p-dialog-bottomleft .p-dialog-enter-from,\n.p-dialog-bottomleft .p-dialog-leave-to {\n    transform: translate3d(-100%, 0px, 0px);\n}\n\n.p-dialog-right .p-dialog-enter-from,\n.p-dialog-right .p-dialog-leave-to,\n.p-dialog-topright .p-dialog-enter-from,\n.p-dialog-topright .p-dialog-leave-to,\n.p-dialog-bottomright .p-dialog-enter-from,\n.p-dialog-bottomright .p-dialog-leave-to {\n    transform: translate3d(100%, 0px, 0px);\n}\n\n.p-dialog-maximized {\n    width: 100vw !important;\n    height: 100vh !important;\n    top: 0px !important;\n    left: 0px !important;\n    max-height: 100%;\n    height: 100%;\n    border-radius: 0;\n}\n\n.p-dialog-maximized .p-dialog-content {\n    flex-grow: 1;\n}\n");
}, "theme");
var inlineStyles = {
  mask: /* @__PURE__ */ __name(function mask(_ref2) {
    var position2 = _ref2.position, modal = _ref2.modal;
    return {
      position: "fixed",
      height: "100%",
      width: "100%",
      left: 0,
      top: 0,
      display: "flex",
      justifyContent: position2 === "left" || position2 === "topleft" || position2 === "bottomleft" ? "flex-start" : position2 === "right" || position2 === "topright" || position2 === "bottomright" ? "flex-end" : "center",
      alignItems: position2 === "top" || position2 === "topleft" || position2 === "topright" ? "flex-start" : position2 === "bottom" || position2 === "bottomleft" || position2 === "bottomright" ? "flex-end" : "center",
      pointerEvents: modal ? "auto" : "none"
    };
  }, "mask"),
  root: {
    display: "flex",
    flexDirection: "column",
    pointerEvents: "auto"
  }
};
var classes$7 = {
  mask: /* @__PURE__ */ __name(function mask2(_ref3) {
    var props = _ref3.props;
    var positions = ["left", "right", "top", "topleft", "topright", "bottom", "bottomleft", "bottomright"];
    var pos2 = positions.find(function(item2) {
      return item2 === props.position;
    });
    return ["p-dialog-mask", {
      "p-overlay-mask p-overlay-mask-enter": props.modal
    }, pos2 ? "p-dialog-".concat(pos2) : ""];
  }, "mask"),
  root: /* @__PURE__ */ __name(function root19(_ref4) {
    var props = _ref4.props, instance = _ref4.instance;
    return ["p-dialog p-component", {
      "p-dialog-maximized": props.maximizable && instance.maximized
    }];
  }, "root"),
  header: "p-dialog-header",
  title: "p-dialog-title",
  headerActions: "p-dialog-header-actions",
  pcMaximizeButton: "p-dialog-maximize-button",
  pcCloseButton: "p-dialog-close-button",
  content: "p-dialog-content",
  footer: "p-dialog-footer"
};
var DialogStyle = BaseStyle.extend({
  name: "dialog",
  theme: theme$7,
  classes: classes$7,
  inlineStyles
});
var script$1$6 = {
  name: "BaseDialog",
  "extends": script$Y,
  props: {
    header: {
      type: null,
      "default": null
    },
    footer: {
      type: null,
      "default": null
    },
    visible: {
      type: Boolean,
      "default": false
    },
    modal: {
      type: Boolean,
      "default": null
    },
    contentStyle: {
      type: null,
      "default": null
    },
    contentClass: {
      type: String,
      "default": null
    },
    contentProps: {
      type: null,
      "default": null
    },
    maximizable: {
      type: Boolean,
      "default": false
    },
    dismissableMask: {
      type: Boolean,
      "default": false
    },
    closable: {
      type: Boolean,
      "default": true
    },
    closeOnEscape: {
      type: Boolean,
      "default": true
    },
    showHeader: {
      type: Boolean,
      "default": true
    },
    blockScroll: {
      type: Boolean,
      "default": false
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    position: {
      type: String,
      "default": "center"
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    draggable: {
      type: Boolean,
      "default": true
    },
    keepInViewport: {
      type: Boolean,
      "default": true
    },
    minX: {
      type: Number,
      "default": 0
    },
    minY: {
      type: Number,
      "default": 0
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    closeIcon: {
      type: String,
      "default": void 0
    },
    maximizeIcon: {
      type: String,
      "default": void 0
    },
    minimizeIcon: {
      type: String,
      "default": void 0
    },
    closeButtonProps: {
      type: Object,
      "default": /* @__PURE__ */ __name(function _default2() {
        return {
          severity: "secondary",
          text: true,
          rounded: true
        };
      }, "_default")
    },
    maximizeButtonProps: {
      type: Object,
      "default": /* @__PURE__ */ __name(function _default3() {
        return {
          severity: "secondary",
          text: true,
          rounded: true
        };
      }, "_default")
    },
    _instance: null
  },
  style: DialogStyle,
  provide: /* @__PURE__ */ __name(function provide32() {
    return {
      $pcDialog: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$b = {
  name: "Dialog",
  "extends": script$1$6,
  inheritAttrs: false,
  emits: ["update:visible", "show", "hide", "after-hide", "maximize", "unmaximize", "dragend"],
  provide: /* @__PURE__ */ __name(function provide33() {
    var _this = this;
    return {
      dialogRef: computed(function() {
        return _this._instance;
      })
    };
  }, "provide"),
  data: /* @__PURE__ */ __name(function data15() {
    return {
      id: this.$attrs.id,
      containerVisible: this.visible,
      maximized: false,
      focusableMax: null,
      focusableClose: null,
      target: null
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId7(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId")
  },
  documentKeydownListener: null,
  container: null,
  mask: null,
  content: null,
  headerContainer: null,
  footerContainer: null,
  maximizableButton: null,
  closeButton: null,
  styleElement: null,
  dragging: null,
  documentDragListener: null,
  documentDragEndListener: null,
  lastPageX: null,
  lastPageY: null,
  maskMouseDownTarget: null,
  updated: /* @__PURE__ */ __name(function updated7() {
    if (this.visible) {
      this.containerVisible = this.visible;
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount7() {
    this.unbindDocumentState();
    this.unbindGlobalListeners();
    this.destroyStyle();
    if (this.mask && this.autoZIndex) {
      ZIndex.clear(this.mask);
    }
    this.container = null;
    this.mask = null;
  }, "beforeUnmount"),
  mounted: /* @__PURE__ */ __name(function mounted14() {
    this.id = this.id || UniqueComponentId();
    if (this.breakpoints) {
      this.createStyle();
    }
  }, "mounted"),
  methods: {
    close: /* @__PURE__ */ __name(function close3() {
      this.$emit("update:visible", false);
    }, "close"),
    onBeforeEnter: /* @__PURE__ */ __name(function onBeforeEnter(el) {
      el.setAttribute(this.attributeSelector, "");
    }, "onBeforeEnter"),
    onEnter: /* @__PURE__ */ __name(function onEnter4() {
      this.$emit("show");
      this.target = document.activeElement;
      this.enableDocumentSettings();
      this.bindGlobalListeners();
      if (this.autoZIndex) {
        ZIndex.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
      }
    }, "onEnter"),
    onAfterEnter: /* @__PURE__ */ __name(function onAfterEnter2() {
      this.focus();
    }, "onAfterEnter"),
    onBeforeLeave: /* @__PURE__ */ __name(function onBeforeLeave() {
      if (this.modal) {
        !this.isUnstyled && addClass(this.mask, "p-overlay-mask-leave");
      }
    }, "onBeforeLeave"),
    onLeave: /* @__PURE__ */ __name(function onLeave3() {
      this.$emit("hide");
      focus(this.target);
      this.target = null;
      this.focusableClose = null;
      this.focusableMax = null;
    }, "onLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave3() {
      if (this.autoZIndex) {
        ZIndex.clear(this.mask);
      }
      this.containerVisible = false;
      this.unbindDocumentState();
      this.unbindGlobalListeners();
      this.$emit("after-hide");
    }, "onAfterLeave"),
    onMaskMouseDown: /* @__PURE__ */ __name(function onMaskMouseDown(event2) {
      this.maskMouseDownTarget = event2.target;
    }, "onMaskMouseDown"),
    onMaskMouseUp: /* @__PURE__ */ __name(function onMaskMouseUp() {
      if (this.dismissableMask && this.modal && this.mask === this.maskMouseDownTarget) {
        this.close();
      }
    }, "onMaskMouseUp"),
    focus: /* @__PURE__ */ __name(function focus$1() {
      var findFocusableElement = /* @__PURE__ */ __name(function findFocusableElement2(container) {
        return container && container.querySelector("[autofocus]");
      }, "findFocusableElement");
      var focusTarget = this.$slots.footer && findFocusableElement(this.footerContainer);
      if (!focusTarget) {
        focusTarget = this.$slots.header && findFocusableElement(this.headerContainer);
        if (!focusTarget) {
          focusTarget = this.$slots["default"] && findFocusableElement(this.content);
          if (!focusTarget) {
            if (this.maximizable) {
              this.focusableMax = true;
              focusTarget = this.maximizableButton;
            } else {
              this.focusableClose = true;
              focusTarget = this.closeButton;
            }
          }
        }
      }
      if (focusTarget) {
        focus(focusTarget, {
          focusVisible: true
        });
      }
    }, "focus$1"),
    maximize: /* @__PURE__ */ __name(function maximize(event2) {
      if (this.maximized) {
        this.maximized = false;
        this.$emit("unmaximize", event2);
      } else {
        this.maximized = true;
        this.$emit("maximize", event2);
      }
      if (!this.modal) {
        this.maximized ? blockBodyScroll() : unblockBodyScroll();
      }
    }, "maximize"),
    enableDocumentSettings: /* @__PURE__ */ __name(function enableDocumentSettings() {
      if (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) {
        blockBodyScroll();
      }
    }, "enableDocumentSettings"),
    unbindDocumentState: /* @__PURE__ */ __name(function unbindDocumentState() {
      if (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) {
        unblockBodyScroll();
      }
    }, "unbindDocumentState"),
    onKeyDown: /* @__PURE__ */ __name(function onKeyDown8(event2) {
      if (event2.code === "Escape" && this.closeOnEscape) {
        this.close();
      }
    }, "onKeyDown"),
    bindDocumentKeyDownListener: /* @__PURE__ */ __name(function bindDocumentKeyDownListener2() {
      if (!this.documentKeydownListener) {
        this.documentKeydownListener = this.onKeyDown.bind(this);
        window.document.addEventListener("keydown", this.documentKeydownListener);
      }
    }, "bindDocumentKeyDownListener"),
    unbindDocumentKeyDownListener: /* @__PURE__ */ __name(function unbindDocumentKeyDownListener2() {
      if (this.documentKeydownListener) {
        window.document.removeEventListener("keydown", this.documentKeydownListener);
        this.documentKeydownListener = null;
      }
    }, "unbindDocumentKeyDownListener"),
    containerRef: /* @__PURE__ */ __name(function containerRef3(el) {
      this.container = el;
    }, "containerRef"),
    maskRef: /* @__PURE__ */ __name(function maskRef(el) {
      this.mask = el;
    }, "maskRef"),
    contentRef: /* @__PURE__ */ __name(function contentRef2(el) {
      this.content = el;
    }, "contentRef"),
    headerContainerRef: /* @__PURE__ */ __name(function headerContainerRef(el) {
      this.headerContainer = el;
    }, "headerContainerRef"),
    footerContainerRef: /* @__PURE__ */ __name(function footerContainerRef(el) {
      this.footerContainer = el;
    }, "footerContainerRef"),
    maximizableRef: /* @__PURE__ */ __name(function maximizableRef(el) {
      this.maximizableButton = el ? el.$el : void 0;
    }, "maximizableRef"),
    closeButtonRef: /* @__PURE__ */ __name(function closeButtonRef(el) {
      this.closeButton = el ? el.$el : void 0;
    }, "closeButtonRef"),
    createStyle: /* @__PURE__ */ __name(function createStyle2() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-dialog[").concat(this.attributeSelector, "] {\n                                width: ").concat(this.breakpoints[breakpoint], " !important;\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    }, "createStyle"),
    destroyStyle: /* @__PURE__ */ __name(function destroyStyle2() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    }, "destroyStyle"),
    initDrag: /* @__PURE__ */ __name(function initDrag(event2) {
      if (event2.target.closest("div").getAttribute("data-pc-section") === "headeractions") {
        return;
      }
      if (this.draggable) {
        this.dragging = true;
        this.lastPageX = event2.pageX;
        this.lastPageY = event2.pageY;
        this.container.style.margin = "0";
        document.body.setAttribute("data-p-unselectable-text", "true");
        !this.isUnstyled && addStyle(document.body, {
          "user-select": "none"
        });
      }
    }, "initDrag"),
    bindGlobalListeners: /* @__PURE__ */ __name(function bindGlobalListeners() {
      if (this.draggable) {
        this.bindDocumentDragListener();
        this.bindDocumentDragEndListener();
      }
      if (this.closeOnEscape && this.closable) {
        this.bindDocumentKeyDownListener();
      }
    }, "bindGlobalListeners"),
    unbindGlobalListeners: /* @__PURE__ */ __name(function unbindGlobalListeners() {
      this.unbindDocumentDragListener();
      this.unbindDocumentDragEndListener();
      this.unbindDocumentKeyDownListener();
    }, "unbindGlobalListeners"),
    bindDocumentDragListener: /* @__PURE__ */ __name(function bindDocumentDragListener() {
      var _this2 = this;
      this.documentDragListener = function(event2) {
        if (_this2.dragging) {
          var width2 = getOuterWidth(_this2.container);
          var height = getOuterHeight(_this2.container);
          var deltaX = event2.pageX - _this2.lastPageX;
          var deltaY = event2.pageY - _this2.lastPageY;
          var offset = _this2.container.getBoundingClientRect();
          var leftPos = offset.left + deltaX;
          var topPos = offset.top + deltaY;
          var viewport = getViewport();
          var containerComputedStyle = getComputedStyle(_this2.container);
          var marginLeft = parseFloat(containerComputedStyle.marginLeft);
          var marginTop = parseFloat(containerComputedStyle.marginTop);
          _this2.container.style.position = "fixed";
          if (_this2.keepInViewport) {
            if (leftPos >= _this2.minX && leftPos + width2 < viewport.width) {
              _this2.lastPageX = event2.pageX;
              _this2.container.style.left = leftPos - marginLeft + "px";
            }
            if (topPos >= _this2.minY && topPos + height < viewport.height) {
              _this2.lastPageY = event2.pageY;
              _this2.container.style.top = topPos - marginTop + "px";
            }
          } else {
            _this2.lastPageX = event2.pageX;
            _this2.container.style.left = leftPos - marginLeft + "px";
            _this2.lastPageY = event2.pageY;
            _this2.container.style.top = topPos - marginTop + "px";
          }
        }
      };
      window.document.addEventListener("mousemove", this.documentDragListener);
    }, "bindDocumentDragListener"),
    unbindDocumentDragListener: /* @__PURE__ */ __name(function unbindDocumentDragListener() {
      if (this.documentDragListener) {
        window.document.removeEventListener("mousemove", this.documentDragListener);
        this.documentDragListener = null;
      }
    }, "unbindDocumentDragListener"),
    bindDocumentDragEndListener: /* @__PURE__ */ __name(function bindDocumentDragEndListener() {
      var _this3 = this;
      this.documentDragEndListener = function(event2) {
        if (_this3.dragging) {
          _this3.dragging = false;
          document.body.removeAttribute("data-p-unselectable-text");
          !_this3.isUnstyled && (document.body.style["user-select"] = "");
          _this3.$emit("dragend", event2);
        }
      };
      window.document.addEventListener("mouseup", this.documentDragEndListener);
    }, "bindDocumentDragEndListener"),
    unbindDocumentDragEndListener: /* @__PURE__ */ __name(function unbindDocumentDragEndListener() {
      if (this.documentDragEndListener) {
        window.document.removeEventListener("mouseup", this.documentDragEndListener);
        this.documentDragEndListener = null;
      }
    }, "unbindDocumentDragEndListener")
  },
  computed: {
    maximizeIconComponent: /* @__PURE__ */ __name(function maximizeIconComponent() {
      return this.maximized ? this.minimizeIcon ? "span" : "WindowMinimizeIcon" : this.maximizeIcon ? "span" : "WindowMaximizeIcon";
    }, "maximizeIconComponent"),
    ariaLabelledById: /* @__PURE__ */ __name(function ariaLabelledById() {
      return this.header != null || this.$attrs["aria-labelledby"] !== null ? this.id + "_header" : null;
    }, "ariaLabelledById"),
    closeAriaLabel: /* @__PURE__ */ __name(function closeAriaLabel2() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    }, "closeAriaLabel"),
    attributeSelector: /* @__PURE__ */ __name(function attributeSelector2() {
      return UniqueComponentId();
    }, "attributeSelector")
  },
  directives: {
    ripple: Ripple,
    focustrap: FocusTrap
  },
  components: {
    Button: script$M,
    Portal: script$z,
    WindowMinimizeIcon: script$c,
    WindowMaximizeIcon: script$d,
    TimesIcon: script$A
  }
};
function _typeof$4(o) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$4(o);
}
__name(_typeof$4, "_typeof$4");
function ownKeys$4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$4, "ownKeys$4");
function _objectSpread$4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$4(Object(t), true).forEach(function(r2) {
      _defineProperty$4(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$4, "_objectSpread$4");
function _defineProperty$4(e, r, t) {
  return (r = _toPropertyKey$4(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$4, "_defineProperty$4");
function _toPropertyKey$4(t) {
  var i2 = _toPrimitive$4(t, "string");
  return "symbol" == _typeof$4(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$4, "_toPropertyKey$4");
function _toPrimitive$4(t, r) {
  if ("object" != _typeof$4(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$4(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$4, "_toPrimitive$4");
var _hoisted_1$i = ["aria-labelledby", "aria-modal"];
var _hoisted_2$b = ["id"];
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Button = resolveComponent("Button");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [$data.containerVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.maskRef,
        "class": _ctx.cx("mask"),
        style: _ctx.sx("mask", true, {
          position: _ctx.position,
          modal: _ctx.modal
        }),
        onMousedown: _cache[1] || (_cache[1] = function() {
          return $options.onMaskMouseDown && $options.onMaskMouseDown.apply($options, arguments);
        }),
        onMouseup: _cache[2] || (_cache[2] = function() {
          return $options.onMaskMouseUp && $options.onMaskMouseUp.apply($options, arguments);
        })
      }, _ctx.ptm("mask")), [createVNode(Transition, mergeProps({
        name: "p-dialog",
        onBeforeEnter: $options.onBeforeEnter,
        onEnter: $options.onEnter,
        onAfterEnter: $options.onAfterEnter,
        onBeforeLeave: $options.onBeforeLeave,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave,
        appear: ""
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [_ctx.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            "class": _ctx.cx("root"),
            style: _ctx.sx("root"),
            role: "dialog",
            "aria-labelledby": $options.ariaLabelledById,
            "aria-modal": _ctx.modal
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            closeCallback: $options.close,
            maximizeCallback: /* @__PURE__ */ __name(function maximizeCallback(event2) {
              return $options.maximize(event2);
            }, "maximizeCallback")
          }) : (openBlock(), createElementBlock(Fragment, {
            key: 1
          }, [_ctx.showHeader ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.headerContainerRef,
            "class": _ctx.cx("header"),
            onMousedown: _cache[0] || (_cache[0] = function() {
              return $options.initDrag && $options.initDrag.apply($options, arguments);
            })
          }, _ctx.ptm("header")), [renderSlot(_ctx.$slots, "header", {
            "class": normalizeClass(_ctx.cx("title"))
          }, function() {
            return [_ctx.header ? (openBlock(), createElementBlock("span", mergeProps({
              key: 0,
              id: $options.ariaLabelledById,
              "class": _ctx.cx("title")
            }, _ctx.ptm("title")), toDisplayString$1(_ctx.header), 17, _hoisted_2$b)) : createCommentVNode("", true)];
          }), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("headerActions")
          }, _ctx.ptm("headerActions")), [_ctx.maximizable ? (openBlock(), createBlock(_component_Button, mergeProps({
            key: 0,
            ref: $options.maximizableRef,
            autofocus: $data.focusableMax,
            "class": _ctx.cx("pcMaximizeButton"),
            onClick: $options.maximize,
            tabindex: _ctx.maximizable ? "0" : "-1",
            unstyled: _ctx.unstyled
          }, _ctx.maximizeButtonProps, {
            pt: _ctx.ptm("pcMaximizeButton"),
            "data-pc-group-section": "headericon"
          }), {
            icon: withCtx(function(slotProps) {
              return [renderSlot(_ctx.$slots, "maximizeicon", {
                maximized: $data.maximized
              }, function() {
                return [(openBlock(), createBlock(resolveDynamicComponent($options.maximizeIconComponent), mergeProps({
                  "class": [slotProps["class"], $data.maximized ? _ctx.minimizeIcon : _ctx.maximizeIcon]
                }, _ctx.ptm("pcMaximizeButton")["icon"]), null, 16, ["class"]))];
              })];
            }),
            _: 3
          }, 16, ["autofocus", "class", "onClick", "tabindex", "unstyled", "pt"])) : createCommentVNode("", true), _ctx.closable ? (openBlock(), createBlock(_component_Button, mergeProps({
            key: 1,
            ref: $options.closeButtonRef,
            autofocus: $data.focusableClose,
            "class": _ctx.cx("pcCloseButton"),
            onClick: $options.close,
            "aria-label": $options.closeAriaLabel,
            unstyled: _ctx.unstyled
          }, _ctx.closeButtonProps, {
            pt: _ctx.ptm("pcCloseButton"),
            "data-pc-group-section": "headericon"
          }), {
            icon: withCtx(function(slotProps) {
              return [renderSlot(_ctx.$slots, "closeicon", {}, function() {
                return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon ? "span" : "TimesIcon"), mergeProps({
                  "class": [_ctx.closeIcon, slotProps["class"]]
                }, _ctx.ptm("pcCloseButton")["icon"]), null, 16, ["class"]))];
              })];
            }),
            _: 3
          }, 16, ["autofocus", "class", "onClick", "aria-label", "unstyled", "pt"])) : createCommentVNode("", true)], 16)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            ref: $options.contentRef,
            "class": [_ctx.cx("content"), _ctx.contentClass],
            style: _ctx.contentStyle
          }, _objectSpread$4(_objectSpread$4({}, _ctx.contentProps), _ctx.ptm("content"))), [renderSlot(_ctx.$slots, "default")], 16), _ctx.footer || _ctx.$slots.footer ? (openBlock(), createElementBlock("div", mergeProps({
            key: 1,
            ref: $options.footerContainerRef,
            "class": _ctx.cx("footer")
          }, _ctx.ptm("footer")), [renderSlot(_ctx.$slots, "footer", {}, function() {
            return [createTextVNode(toDisplayString$1(_ctx.footer), 1)];
          })], 16)) : createCommentVNode("", true)], 64))], 16, _hoisted_1$i)), [[_directive_focustrap, {
            disabled: !_ctx.modal
          }]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])], 16)) : createCommentVNode("", true)];
    }),
    _: 3
  }, 8, ["appendTo"]);
}
__name(render$a, "render$a");
script$b.render = render$a;
var theme$6 = /* @__PURE__ */ __name(function theme31(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-togglebutton {\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    color: ".concat(dt2("togglebutton.color"), ";\n    background: ").concat(dt2("togglebutton.background"), ";\n    border: 1px solid ").concat(dt2("togglebutton.border.color"), ";\n    padding: ").concat(dt2("togglebutton.padding"), ";\n    font-size: 1rem;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    transition: background ").concat(dt2("togglebutton.transition.duration"), ", color ").concat(dt2("togglebutton.transition.duration"), ", border-color ").concat(dt2("togglebutton.transition.duration"), ",\n        outline-color ").concat(dt2("togglebutton.transition.duration"), ", box-shadow ").concat(dt2("togglebutton.transition.duration"), ";\n    border-radius: ").concat(dt2("togglebutton.border.radius"), ";\n    outline-color: transparent;\n    font-weight: ").concat(dt2("togglebutton.font.weight"), ";\n}\n\n.p-togglebutton-content {\n    position: relative;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    gap: ").concat(dt2("togglebutton.gap"), ';\n}\n\n.p-togglebutton-label,\n.p-togglebutton-icon {\n    position: relative;\n    transition: none;\n}\n\n.p-togglebutton::before {\n    content: "";\n    background: transparent;\n    transition: background ').concat(dt2("togglebutton.transition.duration"), ", color ").concat(dt2("togglebutton.transition.duration"), ", border-color ").concat(dt2("togglebutton.transition.duration"), ",\n            outline-color ").concat(dt2("togglebutton.transition.duration"), ", box-shadow ").concat(dt2("togglebutton.transition.duration"), ";\n    position: absolute;\n    left: ").concat(dt2("togglebutton.content.left"), ";\n    top: ").concat(dt2("togglebutton.content.top"), ";\n    width: calc(100% - calc(2 *  ").concat(dt2("togglebutton.content.left"), "));\n    height: calc(100% - calc(2 *  ").concat(dt2("togglebutton.content.top"), "));\n    border-radius: ").concat(dt2("togglebutton.border.radius"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked::before {\n    background: ").concat(dt2("togglebutton.content.checked.background"), ";\n    box-shadow: ").concat(dt2("togglebutton.content.checked.shadow"), ";\n}\n\n.p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover {\n    background: ").concat(dt2("togglebutton.hover.background"), ";\n    color: ").concat(dt2("togglebutton.hover.color"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked {\n    background: ").concat(dt2("togglebutton.checked.background"), ";\n    border-color: ").concat(dt2("togglebutton.checked.border.color"), ";\n    color: ").concat(dt2("togglebutton.checked.color"), ";\n}\n\n.p-togglebutton:focus-visible {\n    box-shadow: ").concat(dt2("togglebutton.focus.ring.shadow"), ";\n    outline: ").concat(dt2("togglebutton.focus.ring.width"), " ").concat(dt2("togglebutton.focus.ring.style"), " ").concat(dt2("togglebutton.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("togglebutton.focus.ring.offset"), ";\n}\n\n.p-togglebutton.p-invalid {\n    border-color: ").concat(dt2("togglebutton.invalid.border.color"), ";\n}\n\n.p-togglebutton:disabled {\n    opacity: 1;\n    cursor: default;\n    background: ").concat(dt2("togglebutton.disabled.background"), ";\n    border-color: ").concat(dt2("togglebutton.disabled.border.color"), ";\n    color: ").concat(dt2("togglebutton.disabled.color"), ";\n}\n\n.p-togglebutton-icon {\n    color: ").concat(dt2("togglebutton.icon.color"), ";\n}\n\n.p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover .p-togglebutton-icon {\n    color: ").concat(dt2("togglebutton.icon.hover.color"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked .p-togglebutton-icon {\n    color: ").concat(dt2("togglebutton.icon.checked.color"), ";\n}\n\n.p-togglebutton:disabled .p-togglebutton-icon {\n    color: ").concat(dt2("togglebutton.icon.disabled.color"), ";\n}\n");
}, "theme");
var classes$6 = {
  root: /* @__PURE__ */ __name(function root20(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-togglebutton p-component", {
      "p-togglebutton-checked": instance.active,
      "p-invalid": props.invalid
    }];
  }, "root"),
  content: "p-togglebutton-content",
  icon: "p-togglebutton-icon",
  label: "p-togglebutton-label"
};
var ToggleButtonStyle = BaseStyle.extend({
  name: "togglebutton",
  theme: theme$6,
  classes: classes$6
});
var script$1$5 = {
  name: "BaseToggleButton",
  "extends": script$Y,
  props: {
    modelValue: Boolean,
    onIcon: String,
    offIcon: String,
    onLabel: {
      type: String,
      "default": "Yes"
    },
    offLabel: {
      type: String,
      "default": "No"
    },
    iconPos: {
      type: String,
      "default": "left"
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: ToggleButtonStyle,
  provide: /* @__PURE__ */ __name(function provide34() {
    return {
      $pcToggleButton: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$a = {
  name: "ToggleButton",
  "extends": script$1$5,
  inheritAttrs: false,
  emits: ["update:modelValue", "change"],
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions8(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          active: this.active,
          disabled: this.disabled
        }
      });
    }, "getPTOptions"),
    onChange: /* @__PURE__ */ __name(function onChange3(event2) {
      if (!this.disabled && !this.readonly) {
        this.$emit("update:modelValue", !this.modelValue);
        this.$emit("change", event2);
      }
    }, "onChange")
  },
  computed: {
    active: /* @__PURE__ */ __name(function active2() {
      return this.modelValue === true;
    }, "active"),
    hasLabel: /* @__PURE__ */ __name(function hasLabel() {
      return isNotEmpty(this.onLabel) && isNotEmpty(this.offLabel);
    }, "hasLabel"),
    label: /* @__PURE__ */ __name(function label4() {
      return this.hasLabel ? this.modelValue ? this.onLabel : this.offLabel : "&nbsp;";
    }, "label")
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$h = ["tabindex", "disabled", "aria-pressed", "data-p-checked", "data-p-disabled"];
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return withDirectives((openBlock(), createElementBlock("button", mergeProps({
    type: "button",
    "class": _ctx.cx("root"),
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    "aria-pressed": _ctx.modelValue,
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.active,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("span", mergeProps({
    "class": _ctx.cx("content")
  }, $options.getPTOptions("content")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [renderSlot(_ctx.$slots, "icon", {
      value: _ctx.modelValue,
      "class": normalizeClass(_ctx.cx("icon"))
    }, function() {
      return [_ctx.onIcon || _ctx.offIcon ? (openBlock(), createElementBlock("span", mergeProps({
        key: 0,
        "class": [_ctx.cx("icon"), _ctx.modelValue ? _ctx.onIcon : _ctx.offIcon]
      }, $options.getPTOptions("icon")), null, 16)) : createCommentVNode("", true)];
    }), createBaseVNode("span", mergeProps({
      "class": _ctx.cx("label")
    }, $options.getPTOptions("label")), toDisplayString$1($options.label), 17)];
  })], 16)], 16, _hoisted_1$h)), [[_directive_ripple]]);
}
__name(render$9, "render$9");
script$a.render = render$9;
var theme$5 = /* @__PURE__ */ __name(function theme32(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-selectbutton {\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    outline-color: transparent;\n    border-radius: ".concat(dt2("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton .p-togglebutton {\n    border-radius: 0;\n    border-width: 1px 1px 1px 0;\n}\n\n.p-selectbutton .p-togglebutton:focus-visible {\n    position: relative;\n    z-index: 1;\n}\n\n.p-selectbutton .p-togglebutton:first-child {\n    border-left-width: 1px;\n    border-top-left-radius: ").concat(dt2("selectbutton.border.radius"), ";\n    border-bottom-left-radius: ").concat(dt2("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton .p-togglebutton:last-child {\n    border-top-right-radius: ").concat(dt2("selectbutton.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt2("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton.p-invalid {\n    outline: 1px solid ").concat(dt2("selectbutton.invalid.border.color"), ";\n    outline-offset: 0;\n}\n");
}, "theme");
var classes$5 = {
  root: /* @__PURE__ */ __name(function root21(_ref2) {
    var props = _ref2.props;
    return ["p-selectbutton p-component", {
      "p-invalid": props.invalid
    }];
  }, "root")
};
var SelectButtonStyle = BaseStyle.extend({
  name: "selectbutton",
  theme: theme$5,
  classes: classes$5
});
var script$1$4 = {
  name: "BaseSelectButton",
  "extends": script$Y,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: null,
    optionValue: null,
    optionDisabled: null,
    multiple: Boolean,
    allowEmpty: {
      type: Boolean,
      "default": true
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: Boolean,
    dataKey: null,
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: SelectButtonStyle,
  provide: /* @__PURE__ */ __name(function provide35() {
    return {
      $pcSelectButton: this,
      $parentInstance: this
    };
  }, "provide")
};
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e) {
      t && (r = t);
      var _n = 0, F = /* @__PURE__ */ __name(function F2() {
      }, "F");
      return { s: F, n: /* @__PURE__ */ __name(function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
        throw r2;
      }, "e"), f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: /* @__PURE__ */ __name(function s() {
    t = t.call(r);
  }, "s"), n: /* @__PURE__ */ __name(function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, "n"), e: /* @__PURE__ */ __name(function e2(r2) {
    u = true, o = r2;
  }, "e"), f: /* @__PURE__ */ __name(function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  }, "f") };
}
__name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
function _toConsumableArray$2(r) {
  return _arrayWithoutHoles$2(r) || _iterableToArray$2(r) || _unsupportedIterableToArray$3(r) || _nonIterableSpread$2();
}
__name(_toConsumableArray$2, "_toConsumableArray$2");
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$2, "_nonIterableSpread$2");
function _unsupportedIterableToArray$3(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$3(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$3, "_unsupportedIterableToArray$3");
function _iterableToArray$2(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$2, "_iterableToArray$2");
function _arrayWithoutHoles$2(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$3(r);
}
__name(_arrayWithoutHoles$2, "_arrayWithoutHoles$2");
function _arrayLikeToArray$3(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$3, "_arrayLikeToArray$3");
var script$9 = {
  name: "SelectButton",
  "extends": script$1$4,
  inheritAttrs: false,
  emits: ["update:modelValue", "change"],
  methods: {
    getOptionLabel: /* @__PURE__ */ __name(function getOptionLabel3(option3) {
      return this.optionLabel ? resolveFieldData(option3, this.optionLabel) : option3;
    }, "getOptionLabel"),
    getOptionValue: /* @__PURE__ */ __name(function getOptionValue3(option3) {
      return this.optionValue ? resolveFieldData(option3, this.optionValue) : option3;
    }, "getOptionValue"),
    getOptionRenderKey: /* @__PURE__ */ __name(function getOptionRenderKey3(option3) {
      return this.dataKey ? resolveFieldData(option3, this.dataKey) : this.getOptionLabel(option3);
    }, "getOptionRenderKey"),
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions9(option3, key) {
      return this.ptm(key, {
        context: {
          active: this.isSelected(option3),
          disabled: this.isOptionDisabled(option3),
          option: option3
        }
      });
    }, "getPTOptions"),
    isOptionDisabled: /* @__PURE__ */ __name(function isOptionDisabled3(option3) {
      return this.optionDisabled ? resolveFieldData(option3, this.optionDisabled) : false;
    }, "isOptionDisabled"),
    onOptionSelect: /* @__PURE__ */ __name(function onOptionSelect3(event2, option3, index2) {
      var _this = this;
      if (this.disabled || this.isOptionDisabled(option3)) {
        return;
      }
      var selected2 = this.isSelected(option3);
      if (selected2 && !this.allowEmpty) {
        return;
      }
      var optionValue = this.getOptionValue(option3);
      var newValue;
      if (this.multiple) {
        if (selected2) newValue = this.modelValue.filter(function(val) {
          return !equals(val, optionValue, _this.equalityKey);
        });
        else newValue = this.modelValue ? [].concat(_toConsumableArray$2(this.modelValue), [optionValue]) : [optionValue];
      } else {
        newValue = selected2 ? null : optionValue;
      }
      this.focusedIndex = index2;
      this.$emit("update:modelValue", newValue);
      this.$emit("change", {
        event: event2,
        value: newValue
      });
    }, "onOptionSelect"),
    isSelected: /* @__PURE__ */ __name(function isSelected4(option3) {
      var selected2 = false;
      var optionValue = this.getOptionValue(option3);
      if (this.multiple) {
        if (this.modelValue) {
          var _iterator = _createForOfIteratorHelper(this.modelValue), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var val = _step.value;
              if (equals(val, optionValue, this.equalityKey)) {
                selected2 = true;
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      } else {
        selected2 = equals(this.modelValue, optionValue, this.equalityKey);
      }
      return selected2;
    }, "isSelected")
  },
  computed: {
    equalityKey: /* @__PURE__ */ __name(function equalityKey3() {
      return this.optionValue ? null : this.dataKey;
    }, "equalityKey")
  },
  directives: {
    ripple: Ripple
  },
  components: {
    ToggleButton: script$a
  }
};
var _hoisted_1$g = ["aria-labelledby"];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_ToggleButton = resolveComponent("ToggleButton");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "group",
    "aria-labelledby": _ctx.ariaLabelledby
  }, _ctx.ptmi("root")), [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, function(option3, index2) {
    return openBlock(), createBlock(_component_ToggleButton, {
      key: $options.getOptionRenderKey(option3),
      modelValue: $options.isSelected(option3),
      onLabel: $options.getOptionLabel(option3),
      offLabel: $options.getOptionLabel(option3),
      disabled: _ctx.disabled || $options.isOptionDisabled(option3),
      unstyled: _ctx.unstyled,
      onChange: /* @__PURE__ */ __name(function onChange4($event) {
        return $options.onOptionSelect($event, option3, index2);
      }, "onChange"),
      pt: _ctx.ptm("pcButton")
    }, createSlots({
      _: 2
    }, [_ctx.$slots.option ? {
      name: "default",
      fn: withCtx(function() {
        return [renderSlot(_ctx.$slots, "option", {
          option: option3,
          index: index2
        }, function() {
          return [createBaseVNode("span", mergeProps({
            ref_for: true
          }, _ctx.ptm("pcButton")["label"]), toDisplayString$1($options.getOptionLabel(option3)), 17)];
        })];
      }),
      key: "0"
    } : void 0]), 1032, ["modelValue", "onLabel", "offLabel", "disabled", "unstyled", "onChange", "pt"]);
  }), 128))], 16, _hoisted_1$g);
}
__name(render$8, "render$8");
script$9.render = render$8;
var theme$4 = /* @__PURE__ */ __name(function theme33(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-colorpicker {\n    display: inline-block;\n    position: relative;\n}\n\n.p-colorpicker-dragging {\n    cursor: pointer;\n}\n\n.p-colorpicker-preview {\n    width: ".concat(dt2("colorpicker.preview.width"), ";\n    height: ").concat(dt2("colorpicker.preview.height"), ";\n    padding: 0;\n    border: 0 none;\n    border-radius: ").concat(dt2("colorpicker.preview.border.radius"), ";\n    transition: background ").concat(dt2("colorpicker.transition.duration"), ", color ").concat(dt2("colorpicker.transition.duration"), ", border-color ").concat(dt2("colorpicker.transition.duration"), ", outline-color ").concat(dt2("colorpicker.transition.duration"), ", box-shadow ").concat(dt2("colorpicker.transition.duration"), ";\n    outline-color: transparent;\n    cursor: pointer;\n}\n\n.p-colorpicker-preview:enabled:focus-visible {\n    border-color: ").concat(dt2("colorpicker.preview.focus.border.color"), ";\n    box-shadow: ").concat(dt2("colorpicker.preview.focus.ring.shadow"), ";\n    outline: ").concat(dt2("colorpicker.preview.focus.ring.width"), " ").concat(dt2("colorpicker.preview.focus.ring.style"), " ").concat(dt2("colorpicker.preview.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("colorpicker.preview.focus.ring.offset"), ";\n}\n\n.p-colorpicker-panel {\n    background: ").concat(dt2("colorpicker.panel.background"), ";\n    border: 1px solid ").concat(dt2("colorpicker.panel.border.color"), ";\n    border-radius: ").concat(dt2("colorpicker.panel.border.radius"), ";\n    box-shadow: ").concat(dt2("colorpicker.panel.shadow"), ";\n    width: 193px;\n    height: 166px;\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n\n.p-colorpicker-panel-inline {\n    box-shadow: none;\n    position: static;\n}\n\n.p-colorpicker-content {\n    position: relative;\n}\n\n.p-colorpicker-color-selector {\n    width: 150px;\n    height: 150px;\n    top: 8px;\n    left: 8px;\n    position: absolute;\n}\n\n.p-colorpicker-color-background {\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(to top, #000 0%, rgba(0, 0, 0, 0) 100%), linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);\n}\n\n.p-colorpicker-color-handle {\n    position: absolute;\n    top: 0px;\n    left: 150px;\n    border-radius: 100%;\n    width: 10px;\n    height: 10px;\n    border-width: 1px;\n    border-style: solid;\n    margin: -5px 0 0 -5px;\n    cursor: pointer;\n    opacity: 0.85;\n    border-color: ").concat(dt2("colorpicker.handle.color"), ";\n}\n\n.p-colorpicker-hue {\n    width: 17px;\n    height: 150px;\n    top: 8px;\n    left: 167px;\n    position: absolute;\n    opacity: 0.85;\n    background: linear-gradient(0deg,\n        red 0,\n        #ff0 17%,\n        #0f0 33%,\n        #0ff 50%,\n        #00f 67%,\n        #f0f 83%,\n        red);\n}\n\n.p-colorpicker-hue-handle {\n    position: absolute;\n    top: 150px;\n    left: 0px;\n    width: 21px;\n    margin-left: -2px;\n    margin-top: -5px;\n    height: 10px;\n    border-width: 2px;\n    border-style: solid;\n    opacity: 0.85;\n    cursor: pointer;\n    border-color: ").concat(dt2("colorpicker.handle.color"), ";\n}\n");
}, "theme");
var classes$4 = {
  root: "p-colorpicker p-component",
  preview: /* @__PURE__ */ __name(function preview(_ref2) {
    var props = _ref2.props;
    return ["p-colorpicker-preview", {
      "p-disabled": props.disabled
    }];
  }, "preview"),
  panel: /* @__PURE__ */ __name(function panel(_ref3) {
    var props = _ref3.props;
    return ["p-colorpicker-panel", {
      "p-colorpicker-panel-inline": props.inline,
      "p-disabled": props.disabled
    }];
  }, "panel"),
  colorSelector: "p-colorpicker-color-selector",
  colorBackground: "p-colorpicker-color-background",
  colorHandle: "p-colorpicker-color-handle",
  hue: "p-colorpicker-hue",
  hueHandle: "p-colorpicker-hue-handle"
};
var ColorPickerStyle = BaseStyle.extend({
  name: "colorpicker",
  theme: theme$4,
  classes: classes$4
});
var script$1$3 = {
  name: "BaseColorPicker",
  "extends": script$Y,
  props: {
    modelValue: {
      type: null,
      "default": null
    },
    defaultColor: {
      type: null,
      "default": "ff0000"
    },
    inline: {
      type: Boolean,
      "default": false
    },
    format: {
      type: String,
      "default": "hex"
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: String,
      "default": null
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    inputId: {
      type: String,
      "default": null
    },
    panelClass: null
  },
  style: ColorPickerStyle,
  provide: /* @__PURE__ */ __name(function provide36() {
    return {
      $pcColorPicker: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$8 = {
  name: "ColorPicker",
  "extends": script$1$3,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "show", "hide"],
  data: /* @__PURE__ */ __name(function data16() {
    return {
      overlayVisible: false
    };
  }, "data"),
  hsbValue: null,
  outsideClickListener: null,
  documentMouseMoveListener: null,
  documentMouseUpListener: null,
  scrollHandler: null,
  resizeListener: null,
  hueDragging: null,
  colorDragging: null,
  selfUpdate: null,
  picker: null,
  colorSelector: null,
  colorHandle: null,
  hueView: null,
  hueHandle: null,
  watch: {
    modelValue: {
      immediate: true,
      handler: /* @__PURE__ */ __name(function handler5(newValue) {
        this.hsbValue = this.toHSB(newValue);
        if (this.selfUpdate) this.selfUpdate = false;
        else this.updateUI();
      }, "handler")
    }
  },
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount8() {
    this.unbindOutsideClickListener();
    this.unbindDragListeners();
    this.unbindResizeListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    if (this.picker && this.autoZIndex) {
      ZIndex.clear(this.picker);
    }
    this.clearRefs();
  }, "beforeUnmount"),
  mounted: /* @__PURE__ */ __name(function mounted15() {
    this.updateUI();
  }, "mounted"),
  methods: {
    pickColor: /* @__PURE__ */ __name(function pickColor(event2) {
      var rect = this.colorSelector.getBoundingClientRect();
      var top = rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);
      var left = rect.left + document.body.scrollLeft;
      var saturation = Math.floor(100 * Math.max(0, Math.min(150, (event2.pageX || event2.changedTouches[0].pageX) - left)) / 150);
      var brightness = Math.floor(100 * (150 - Math.max(0, Math.min(150, (event2.pageY || event2.changedTouches[0].pageY) - top))) / 150);
      this.hsbValue = this.validateHSB({
        h: this.hsbValue.h,
        s: saturation,
        b: brightness
      });
      this.selfUpdate = true;
      this.updateColorHandle();
      this.updateInput();
      this.updateModel(event2);
    }, "pickColor"),
    pickHue: /* @__PURE__ */ __name(function pickHue(event2) {
      var top = this.hueView.getBoundingClientRect().top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);
      this.hsbValue = this.validateHSB({
        h: Math.floor(360 * (150 - Math.max(0, Math.min(150, (event2.pageY || event2.changedTouches[0].pageY) - top))) / 150),
        s: 100,
        b: 100
      });
      this.selfUpdate = true;
      this.updateColorSelector();
      this.updateHue();
      this.updateModel(event2);
      this.updateInput();
    }, "pickHue"),
    updateModel: /* @__PURE__ */ __name(function updateModel5(event2) {
      var value3 = this.modelValue;
      switch (this.format) {
        case "hex":
          value3 = this.HSBtoHEX(this.hsbValue);
          break;
        case "rgb":
          value3 = this.HSBtoRGB(this.hsbValue);
          break;
        case "hsb":
          value3 = this.hsbValue;
          break;
      }
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        event: event2,
        value: value3
      });
    }, "updateModel"),
    updateColorSelector: /* @__PURE__ */ __name(function updateColorSelector() {
      if (this.colorSelector) {
        var hsbValue = this.validateHSB({
          h: this.hsbValue.h,
          s: 100,
          b: 100
        });
        this.colorSelector.style.backgroundColor = "#" + this.HSBtoHEX(hsbValue);
      }
    }, "updateColorSelector"),
    updateColorHandle: /* @__PURE__ */ __name(function updateColorHandle() {
      if (this.colorHandle) {
        this.colorHandle.style.left = Math.floor(150 * this.hsbValue.s / 100) + "px";
        this.colorHandle.style.top = Math.floor(150 * (100 - this.hsbValue.b) / 100) + "px";
      }
    }, "updateColorHandle"),
    updateHue: /* @__PURE__ */ __name(function updateHue() {
      if (this.hueHandle) {
        this.hueHandle.style.top = Math.floor(150 - 150 * this.hsbValue.h / 360) + "px";
      }
    }, "updateHue"),
    updateInput: /* @__PURE__ */ __name(function updateInput2() {
      if (this.$refs.input) {
        this.$refs.input.style.backgroundColor = "#" + this.HSBtoHEX(this.hsbValue);
      }
    }, "updateInput"),
    updateUI: /* @__PURE__ */ __name(function updateUI() {
      this.updateHue();
      this.updateColorHandle();
      this.updateInput();
      this.updateColorSelector();
    }, "updateUI"),
    validateHSB: /* @__PURE__ */ __name(function validateHSB(hsb) {
      return {
        h: Math.min(360, Math.max(0, hsb.h)),
        s: Math.min(100, Math.max(0, hsb.s)),
        b: Math.min(100, Math.max(0, hsb.b))
      };
    }, "validateHSB"),
    validateRGB: /* @__PURE__ */ __name(function validateRGB(rgb) {
      return {
        r: Math.min(255, Math.max(0, rgb.r)),
        g: Math.min(255, Math.max(0, rgb.g)),
        b: Math.min(255, Math.max(0, rgb.b))
      };
    }, "validateRGB"),
    validateHEX: /* @__PURE__ */ __name(function validateHEX(hex) {
      var len = 6 - hex.length;
      if (len > 0) {
        var o = [];
        for (var i2 = 0; i2 < len; i2++) {
          o.push("0");
        }
        o.push(hex);
        hex = o.join("");
      }
      return hex;
    }, "validateHEX"),
    HEXtoRGB: /* @__PURE__ */ __name(function HEXtoRGB(hex) {
      var hexValue = parseInt(hex.indexOf("#") > -1 ? hex.substring(1) : hex, 16);
      return {
        r: hexValue >> 16,
        g: (hexValue & 65280) >> 8,
        b: hexValue & 255
      };
    }, "HEXtoRGB"),
    HEXtoHSB: /* @__PURE__ */ __name(function HEXtoHSB(hex) {
      return this.RGBtoHSB(this.HEXtoRGB(hex));
    }, "HEXtoHSB"),
    RGBtoHSB: /* @__PURE__ */ __name(function RGBtoHSB(rgb) {
      var hsb = {
        h: 0,
        s: 0,
        b: 0
      };
      var min = Math.min(rgb.r, rgb.g, rgb.b);
      var max = Math.max(rgb.r, rgb.g, rgb.b);
      var delta2 = max - min;
      hsb.b = max;
      hsb.s = max !== 0 ? 255 * delta2 / max : 0;
      if (hsb.s !== 0) {
        if (rgb.r === max) {
          hsb.h = (rgb.g - rgb.b) / delta2;
        } else if (rgb.g === max) {
          hsb.h = 2 + (rgb.b - rgb.r) / delta2;
        } else {
          hsb.h = 4 + (rgb.r - rgb.g) / delta2;
        }
      } else {
        hsb.h = -1;
      }
      hsb.h *= 60;
      if (hsb.h < 0) {
        hsb.h += 360;
      }
      hsb.s *= 100 / 255;
      hsb.b *= 100 / 255;
      return hsb;
    }, "RGBtoHSB"),
    HSBtoRGB: /* @__PURE__ */ __name(function HSBtoRGB(hsb) {
      var rgb = {
        r: null,
        g: null,
        b: null
      };
      var h2 = Math.round(hsb.h);
      var s = Math.round(hsb.s * 255 / 100);
      var v2 = Math.round(hsb.b * 255 / 100);
      if (s === 0) {
        rgb = {
          r: v2,
          g: v2,
          b: v2
        };
      } else {
        var t1 = v2;
        var t2 = (255 - s) * v2 / 255;
        var t3 = (t1 - t2) * (h2 % 60) / 60;
        if (h2 === 360) h2 = 0;
        if (h2 < 60) {
          rgb.r = t1;
          rgb.b = t2;
          rgb.g = t2 + t3;
        } else if (h2 < 120) {
          rgb.g = t1;
          rgb.b = t2;
          rgb.r = t1 - t3;
        } else if (h2 < 180) {
          rgb.g = t1;
          rgb.r = t2;
          rgb.b = t2 + t3;
        } else if (h2 < 240) {
          rgb.b = t1;
          rgb.r = t2;
          rgb.g = t1 - t3;
        } else if (h2 < 300) {
          rgb.b = t1;
          rgb.g = t2;
          rgb.r = t2 + t3;
        } else if (h2 < 360) {
          rgb.r = t1;
          rgb.g = t2;
          rgb.b = t1 - t3;
        } else {
          rgb.r = 0;
          rgb.g = 0;
          rgb.b = 0;
        }
      }
      return {
        r: Math.round(rgb.r),
        g: Math.round(rgb.g),
        b: Math.round(rgb.b)
      };
    }, "HSBtoRGB"),
    RGBtoHEX: /* @__PURE__ */ __name(function RGBtoHEX(rgb) {
      var hex = [rgb.r.toString(16), rgb.g.toString(16), rgb.b.toString(16)];
      for (var key in hex) {
        if (hex[key].length === 1) {
          hex[key] = "0" + hex[key];
        }
      }
      return hex.join("");
    }, "RGBtoHEX"),
    HSBtoHEX: /* @__PURE__ */ __name(function HSBtoHEX(hsb) {
      return this.RGBtoHEX(this.HSBtoRGB(hsb));
    }, "HSBtoHEX"),
    toHSB: /* @__PURE__ */ __name(function toHSB(value3) {
      var hsb;
      if (value3) {
        switch (this.format) {
          case "hex":
            hsb = this.HEXtoHSB(value3);
            break;
          case "rgb":
            hsb = this.RGBtoHSB(value3);
            break;
          case "hsb":
            hsb = value3;
            break;
        }
      } else {
        hsb = this.HEXtoHSB(this.defaultColor);
      }
      return hsb;
    }, "toHSB"),
    onOverlayEnter: /* @__PURE__ */ __name(function onOverlayEnter2(el) {
      this.updateUI();
      this.alignOverlay();
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      if (this.autoZIndex) {
        ZIndex.set("overlay", el, this.baseZIndex, this.$primevue.config.zIndex.overlay);
      }
      this.$emit("show");
    }, "onOverlayEnter"),
    onOverlayLeave: /* @__PURE__ */ __name(function onOverlayLeave2() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.clearRefs();
      this.$emit("hide");
    }, "onOverlayLeave"),
    onOverlayAfterLeave: /* @__PURE__ */ __name(function onOverlayAfterLeave2(el) {
      if (this.autoZIndex) {
        ZIndex.clear(el);
      }
    }, "onOverlayAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay4() {
      if (this.appendTo === "self") relativePosition(this.picker, this.$refs.input);
      else absolutePosition(this.picker, this.$refs.input);
    }, "alignOverlay"),
    onInputClick: /* @__PURE__ */ __name(function onInputClick2() {
      if (this.disabled) {
        return;
      }
      this.overlayVisible = !this.overlayVisible;
    }, "onInputClick"),
    onInputKeydown: /* @__PURE__ */ __name(function onInputKeydown(event2) {
      switch (event2.code) {
        case "Space":
          this.overlayVisible = !this.overlayVisible;
          event2.preventDefault();
          break;
        case "Escape":
        case "Tab":
          this.overlayVisible = false;
          break;
      }
    }, "onInputKeydown"),
    onColorMousedown: /* @__PURE__ */ __name(function onColorMousedown(event2) {
      if (this.disabled) {
        return;
      }
      this.bindDragListeners();
      this.onColorDragStart(event2);
    }, "onColorMousedown"),
    onColorDragStart: /* @__PURE__ */ __name(function onColorDragStart(event2) {
      if (this.disabled) {
        return;
      }
      this.colorDragging = true;
      this.pickColor(event2);
      this.$el.setAttribute("p-colorpicker-dragging", "true");
      !this.isUnstyled && addClass(this.$el, "p-colorpicker-dragging");
      event2.preventDefault();
    }, "onColorDragStart"),
    onDrag: /* @__PURE__ */ __name(function onDrag2(event2) {
      if (this.colorDragging) {
        this.pickColor(event2);
        event2.preventDefault();
      }
      if (this.hueDragging) {
        this.pickHue(event2);
        event2.preventDefault();
      }
    }, "onDrag"),
    onDragEnd: /* @__PURE__ */ __name(function onDragEnd2() {
      this.colorDragging = false;
      this.hueDragging = false;
      this.$el.setAttribute("p-colorpicker-dragging", "false");
      !this.isUnstyled && removeClass(this.$el, "p-colorpicker-dragging");
      this.unbindDragListeners();
    }, "onDragEnd"),
    onHueMousedown: /* @__PURE__ */ __name(function onHueMousedown(event2) {
      if (this.disabled) {
        return;
      }
      this.bindDragListeners();
      this.onHueDragStart(event2);
    }, "onHueMousedown"),
    onHueDragStart: /* @__PURE__ */ __name(function onHueDragStart(event2) {
      if (this.disabled) {
        return;
      }
      this.hueDragging = true;
      this.pickHue(event2);
      !this.isUnstyled && addClass(this.$el, "p-colorpicker-dragging");
    }, "onHueDragStart"),
    isInputClicked: /* @__PURE__ */ __name(function isInputClicked(event2) {
      return this.$refs.input && this.$refs.input.isSameNode(event2.target);
    }, "isInputClicked"),
    bindDragListeners: /* @__PURE__ */ __name(function bindDragListeners2() {
      this.bindDocumentMouseMoveListener();
      this.bindDocumentMouseUpListener();
    }, "bindDragListeners"),
    unbindDragListeners: /* @__PURE__ */ __name(function unbindDragListeners2() {
      this.unbindDocumentMouseMoveListener();
      this.unbindDocumentMouseUpListener();
    }, "unbindDragListeners"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener4() {
      var _this = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this.overlayVisible && _this.picker && !_this.picker.contains(event2.target) && !_this.isInputClicked(event2)) {
            _this.overlayVisible = false;
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener4() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener3() {
      var _this2 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, function() {
          if (_this2.overlayVisible) {
            _this2.overlayVisible = false;
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener3() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener5() {
      var _this3 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this3.overlayVisible && !isTouchDevice()) {
            _this3.overlayVisible = false;
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener5() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    bindDocumentMouseMoveListener: /* @__PURE__ */ __name(function bindDocumentMouseMoveListener() {
      if (!this.documentMouseMoveListener) {
        this.documentMouseMoveListener = this.onDrag.bind(this);
        document.addEventListener("mousemove", this.documentMouseMoveListener);
      }
    }, "bindDocumentMouseMoveListener"),
    unbindDocumentMouseMoveListener: /* @__PURE__ */ __name(function unbindDocumentMouseMoveListener() {
      if (this.documentMouseMoveListener) {
        document.removeEventListener("mousemove", this.documentMouseMoveListener);
        this.documentMouseMoveListener = null;
      }
    }, "unbindDocumentMouseMoveListener"),
    bindDocumentMouseUpListener: /* @__PURE__ */ __name(function bindDocumentMouseUpListener() {
      if (!this.documentMouseUpListener) {
        this.documentMouseUpListener = this.onDragEnd.bind(this);
        document.addEventListener("mouseup", this.documentMouseUpListener);
      }
    }, "bindDocumentMouseUpListener"),
    unbindDocumentMouseUpListener: /* @__PURE__ */ __name(function unbindDocumentMouseUpListener() {
      if (this.documentMouseUpListener) {
        document.removeEventListener("mouseup", this.documentMouseUpListener);
        this.documentMouseUpListener = null;
      }
    }, "unbindDocumentMouseUpListener"),
    pickerRef: /* @__PURE__ */ __name(function pickerRef(el) {
      this.picker = el;
    }, "pickerRef"),
    colorSelectorRef: /* @__PURE__ */ __name(function colorSelectorRef(el) {
      this.colorSelector = el;
    }, "colorSelectorRef"),
    colorHandleRef: /* @__PURE__ */ __name(function colorHandleRef(el) {
      this.colorHandle = el;
    }, "colorHandleRef"),
    hueViewRef: /* @__PURE__ */ __name(function hueViewRef(el) {
      this.hueView = el;
    }, "hueViewRef"),
    hueHandleRef: /* @__PURE__ */ __name(function hueHandleRef(el) {
      this.hueHandle = el;
    }, "hueHandleRef"),
    clearRefs: /* @__PURE__ */ __name(function clearRefs() {
      this.picker = null;
      this.colorSelector = null;
      this.colorHandle = null;
      this.hueView = null;
      this.hueHandle = null;
    }, "clearRefs"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick3(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.$el
      });
    }, "onOverlayClick")
  },
  components: {
    Portal: script$z
  }
};
var _hoisted_1$f = ["id", "tabindex", "disabled"];
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [!_ctx.inline ? (openBlock(), createElementBlock("input", mergeProps({
    key: 0,
    ref: "input",
    id: _ctx.inputId,
    type: "text",
    "class": _ctx.cx("preview"),
    readonly: "readonly",
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onInputClick && $options.onInputClick.apply($options, arguments);
    }),
    onKeydown: _cache[1] || (_cache[1] = function() {
      return $options.onInputKeydown && $options.onInputKeydown.apply($options, arguments);
    })
  }, _ctx.ptm("preview")), null, 16, _hoisted_1$f)) : createCommentVNode("", true), createVNode(_component_Portal, {
    appendTo: _ctx.appendTo,
    disabled: _ctx.inline
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-connected-overlay",
        onEnter: $options.onOverlayEnter,
        onLeave: $options.onOverlayLeave,
        onAfterLeave: $options.onOverlayAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [(_ctx.inline ? true : $data.overlayVisible) ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.pickerRef,
            "class": [_ctx.cx("panel"), _ctx.panelClass],
            onClick: _cache[10] || (_cache[10] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            })
          }, _ctx.ptm("panel")), [createBaseVNode("div", mergeProps({
            "class": _ctx.cx("content")
          }, _ctx.ptm("content")), [createBaseVNode("div", mergeProps({
            ref: $options.colorSelectorRef,
            "class": _ctx.cx("colorSelector"),
            onMousedown: _cache[2] || (_cache[2] = function($event) {
              return $options.onColorMousedown($event);
            }),
            onTouchstart: _cache[3] || (_cache[3] = function($event) {
              return $options.onColorDragStart($event);
            }),
            onTouchmove: _cache[4] || (_cache[4] = function($event) {
              return $options.onDrag($event);
            }),
            onTouchend: _cache[5] || (_cache[5] = function($event) {
              return $options.onDragEnd();
            })
          }, _ctx.ptm("colorSelector")), [createBaseVNode("div", mergeProps({
            "class": _ctx.cx("colorBackground")
          }, _ctx.ptm("colorBackground")), [createBaseVNode("div", mergeProps({
            ref: $options.colorHandleRef,
            "class": _ctx.cx("colorHandle")
          }, _ctx.ptm("colorHandle")), null, 16)], 16)], 16), createBaseVNode("div", mergeProps({
            ref: $options.hueViewRef,
            "class": _ctx.cx("hue"),
            onMousedown: _cache[6] || (_cache[6] = function($event) {
              return $options.onHueMousedown($event);
            }),
            onTouchstart: _cache[7] || (_cache[7] = function($event) {
              return $options.onHueDragStart($event);
            }),
            onTouchmove: _cache[8] || (_cache[8] = function($event) {
              return $options.onDrag($event);
            }),
            onTouchend: _cache[9] || (_cache[9] = function($event) {
              return $options.onDragEnd();
            })
          }, _ctx.ptm("hue")), [createBaseVNode("div", mergeProps({
            ref: $options.hueHandleRef,
            "class": _ctx.cx("hueHandle")
          }, _ctx.ptm("hueHandle")), null, 16)], 16)], 16)], 16)) : createCommentVNode("", true)];
        }),
        _: 1
      }, 16, ["onEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 1
  }, 8, ["appendTo", "disabled"])], 16);
}
__name(render$7, "render$7");
script$8.render = render$7;
const _withScopeId$5 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-91077f2a"), n = n(), popScopeId(), n), "_withScopeId$5");
const _hoisted_1$e = { class: "p-fluid" };
const _hoisted_2$a = { class: "field icon-field" };
const _hoisted_3$7 = { for: "icon" };
const _hoisted_4$5 = { class: "field color-field" };
const _hoisted_5$3 = { for: "color" };
const _hoisted_6$2 = { class: "color-picker-container" };
const _hoisted_7$1 = {
  key: 1,
  class: "pi pi-palette",
  style: { fontSize: "1.2rem" }
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "CustomizationDialog",
  props: {
    modelValue: { type: Boolean },
    initialIcon: {},
    initialColor: {}
  },
  emits: ["update:modelValue", "confirm"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit2 = __emit;
    const visible = computed({
      get: /* @__PURE__ */ __name(() => props.modelValue, "get"),
      set: /* @__PURE__ */ __name((value3) => emit2("update:modelValue", value3), "set")
    });
    const nodeBookmarkStore = useNodeBookmarkStore();
    const iconOptions = [
      { name: t("bookmark"), value: nodeBookmarkStore.defaultBookmarkIcon },
      { name: t("folder"), value: "pi-folder" },
      { name: t("star"), value: "pi-star" },
      { name: t("heart"), value: "pi-heart" },
      { name: t("file"), value: "pi-file" },
      { name: t("inbox"), value: "pi-inbox" },
      { name: t("box"), value: "pi-box" },
      { name: t("briefcase"), value: "pi-briefcase" }
    ];
    const colorOptions = [
      { name: t("default"), value: nodeBookmarkStore.defaultBookmarkColor },
      { name: t("blue"), value: "#007bff" },
      { name: t("green"), value: "#28a745" },
      { name: t("red"), value: "#dc3545" },
      { name: t("pink"), value: "#e83e8c" },
      { name: t("yellow"), value: "#ffc107" },
      { name: t("custom"), value: "custom" }
    ];
    const defaultIcon = iconOptions.find(
      (option3) => option3.value === nodeBookmarkStore.defaultBookmarkIcon
    );
    const defaultColor = colorOptions.find(
      (option3) => option3.value === nodeBookmarkStore.defaultBookmarkColor
    );
    const selectedIcon = ref(defaultIcon);
    const selectedColor = ref(defaultColor);
    const finalColor = computed(
      () => selectedColor.value.value === "custom" ? `#${customColor.value}` : selectedColor.value.value
    );
    const customColor = ref("000000");
    const closeDialog = /* @__PURE__ */ __name(() => {
      visible.value = false;
    }, "closeDialog");
    const confirmCustomization = /* @__PURE__ */ __name(() => {
      emit2("confirm", selectedIcon.value.value, finalColor.value);
      closeDialog();
    }, "confirmCustomization");
    const resetCustomization = /* @__PURE__ */ __name(() => {
      selectedIcon.value = iconOptions.find((option3) => option3.value === props.initialIcon) || defaultIcon;
      const colorOption = colorOptions.find(
        (option3) => option3.value === props.initialColor
      );
      if (!props.initialColor) {
        selectedColor.value = defaultColor;
      } else if (!colorOption) {
        customColor.value = props.initialColor.replace("#", "");
        selectedColor.value = { name: "Custom", value: "custom" };
      } else {
        selectedColor.value = colorOption;
      }
    }, "resetCustomization");
    watch(
      () => props.modelValue,
      (newValue) => {
        if (newValue) {
          resetCustomization();
        }
      },
      { immediate: true }
    );
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createBlock(unref(script$b), {
        visible: visible.value,
        "onUpdate:visible": _cache[3] || (_cache[3] = ($event) => visible.value = $event),
        header: _ctx.$t("customizeFolder")
      }, {
        footer: withCtx(() => [
          createVNode(unref(script$M), {
            label: _ctx.$t("reset"),
            icon: "pi pi-refresh",
            onClick: resetCustomization,
            class: "p-button-text"
          }, null, 8, ["label"]),
          createVNode(unref(script$M), {
            label: _ctx.$t("confirm"),
            icon: "pi pi-check",
            onClick: confirmCustomization,
            autofocus: ""
          }, null, 8, ["label"])
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$e, [
            createBaseVNode("div", _hoisted_2$a, [
              createBaseVNode("label", _hoisted_3$7, toDisplayString$1(_ctx.$t("icon")), 1),
              createVNode(unref(script$9), {
                modelValue: selectedIcon.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedIcon.value = $event),
                options: iconOptions,
                optionLabel: "name",
                dataKey: "value"
              }, {
                option: withCtx((slotProps) => [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", slotProps.option.value, "mr-2"]),
                    style: normalizeStyle({ color: finalColor.value })
                  }, null, 6)
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            createVNode(unref(script$G)),
            createBaseVNode("div", _hoisted_4$5, [
              createBaseVNode("label", _hoisted_5$3, toDisplayString$1(_ctx.$t("color")), 1),
              createBaseVNode("div", _hoisted_6$2, [
                createVNode(unref(script$9), {
                  modelValue: selectedColor.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedColor.value = $event),
                  options: colorOptions,
                  optionLabel: "name",
                  dataKey: "value"
                }, {
                  option: withCtx((slotProps) => [
                    slotProps.option.value !== "custom" ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      style: normalizeStyle({
                        width: "20px",
                        height: "20px",
                        backgroundColor: slotProps.option.value,
                        borderRadius: "50%"
                      })
                    }, null, 4)) : withDirectives((openBlock(), createElementBlock("i", _hoisted_7$1, null, 512)), [
                      [_directive_tooltip, _ctx.$t("customColor")]
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                selectedColor.value.value === "custom" ? (openBlock(), createBlock(unref(script$8), {
                  key: 0,
                  modelValue: customColor.value,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => customColor.value = $event)
                }, null, 8, ["modelValue"])) : createCommentVNode("", true)
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible", "header"]);
    };
  }
});
const FolderCustomizationDialog = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-91077f2a"]]);
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "NodeBookmarkTreeExplorer",
  props: {
    filteredNodeDefs: {}
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const expandedKeys2 = ref({});
    const { expandNode, toggleNodeOnEvent } = useTreeExpansion(expandedKeys2);
    const nodeBookmarkStore = useNodeBookmarkStore();
    const bookmarkedRoot = computed(() => {
      const filterTree = /* @__PURE__ */ __name((node3) => {
        if (node3.leaf) {
          return props.filteredNodeDefs.some((def2) => def2.name === node3.data.name) ? node3 : null;
        }
        const filteredChildren = node3.children?.map(filterTree).filter((child) => child !== null);
        if (filteredChildren && filteredChildren.length > 0) {
          return {
            ...node3,
            children: filteredChildren
          };
        }
        return null;
      }, "filterTree");
      return props.filteredNodeDefs.length ? filterTree(nodeBookmarkStore.bookmarkedRoot) || {
        key: "root",
        label: "Root",
        children: []
      } : nodeBookmarkStore.bookmarkedRoot;
    });
    watch(
      () => props.filteredNodeDefs,
      (newValue) => {
        if (newValue.length) {
          nextTick(() => expandNode(bookmarkedRoot.value));
        }
      }
    );
    const { t } = useI18n();
    const extraMenuItems = /* @__PURE__ */ __name((menuTargetNode) => [
      {
        label: t("newFolder"),
        icon: "pi pi-folder-plus",
        command: /* @__PURE__ */ __name(() => {
          addNewBookmarkFolder(menuTargetNode);
        }, "command"),
        visible: !menuTargetNode?.leaf
      },
      {
        label: t("customize"),
        icon: "pi pi-palette",
        command: /* @__PURE__ */ __name(() => {
          const customization = nodeBookmarkStore.bookmarksCustomization[menuTargetNode.data.nodePath];
          initialIcon.value = customization?.icon || nodeBookmarkStore.defaultBookmarkIcon;
          initialColor.value = customization?.color || nodeBookmarkStore.defaultBookmarkColor;
          showCustomizationDialog.value = true;
          customizationTargetNodePath.value = menuTargetNode.data.nodePath;
        }, "command"),
        visible: !menuTargetNode?.leaf
      }
    ], "extraMenuItems");
    const renderedBookmarkedRoot = computed(
      () => {
        const fillNodeInfo = /* @__PURE__ */ __name((node3) => {
          const children = node3.children?.map(fillNodeInfo);
          const sortedChildren = children?.sort((a, b) => {
            if (a.leaf === b.leaf) {
              return a.label.localeCompare(b.label);
            }
            return a.leaf ? 1 : -1;
          });
          return {
            key: node3.key,
            label: node3.leaf ? node3.data.display_name : node3.label,
            leaf: node3.leaf,
            data: node3.data,
            getIcon: /* @__PURE__ */ __name((node22) => {
              if (node22.leaf) {
                return "pi pi-circle-fill";
              }
              const customization = nodeBookmarkStore.bookmarksCustomization[node22.data?.nodePath];
              return customization?.icon ? "pi " + customization.icon : "pi pi-bookmark-fill";
            }, "getIcon"),
            children: sortedChildren,
            draggable: node3.leaf,
            droppable: !node3.leaf,
            handleDrop: /* @__PURE__ */ __name((node22, data22) => {
              const nodeDefToAdd = data22.data.data;
              if (nodeBookmarkStore.isBookmarked(nodeDefToAdd)) {
                nodeBookmarkStore.toggleBookmark(nodeDefToAdd);
              }
              const folderNodeDef = node22.data;
              const nodePath = folderNodeDef.category + "/" + nodeDefToAdd.name;
              nodeBookmarkStore.addBookmark(nodePath);
            }, "handleDrop"),
            handleClick: /* @__PURE__ */ __name((node22, e) => {
              if (node22.leaf) {
                app$1.addNodeOnGraph(node22.data, { pos: app$1.getCanvasCenter() });
              } else {
                toggleNodeOnEvent(e, node22);
              }
            }, "handleClick"),
            contextMenuItems: extraMenuItems,
            ...node3.leaf ? {} : {
              handleRename,
              handleDelete: /* @__PURE__ */ __name((node22) => {
                nodeBookmarkStore.deleteBookmarkFolder(node22.data);
              }, "handleDelete")
            }
          };
        }, "fillNodeInfo");
        return fillNodeInfo(bookmarkedRoot.value);
      }
    );
    const treeExplorerRef = ref(null);
    const addNewBookmarkFolder = /* @__PURE__ */ __name((parent) => {
      const newFolderKey = "root/" + nodeBookmarkStore.addNewBookmarkFolder(parent?.data).slice(0, -1);
      nextTick(() => {
        treeExplorerRef.value?.renameCommand(
          findNodeByKey(
            renderedBookmarkedRoot.value,
            newFolderKey
          )
        );
        if (parent) {
          expandedKeys2.value[parent.key] = true;
        }
      });
    }, "addNewBookmarkFolder");
    __expose({
      addNewBookmarkFolder
    });
    const handleRename = /* @__PURE__ */ __name((node3, newName) => {
      if (node3.data && node3.data.isDummyFolder) {
        nodeBookmarkStore.renameBookmarkFolder(node3.data, newName);
      }
    }, "handleRename");
    const showCustomizationDialog = ref(false);
    const initialIcon = ref(nodeBookmarkStore.defaultBookmarkIcon);
    const initialColor = ref(nodeBookmarkStore.defaultBookmarkColor);
    const customizationTargetNodePath = ref("");
    const updateCustomization = /* @__PURE__ */ __name((icon2, color) => {
      if (customizationTargetNodePath.value) {
        nodeBookmarkStore.updateBookmarkCustomization(
          customizationTargetNodePath.value,
          { icon: icon2, color }
        );
      }
    }, "updateCustomization");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(TreeExplorer, {
          class: "node-lib-bookmark-tree-explorer",
          ref_key: "treeExplorerRef",
          ref: treeExplorerRef,
          roots: renderedBookmarkedRoot.value.children,
          expandedKeys: expandedKeys2.value
        }, {
          folder: withCtx(({ node: node3 }) => [
            createVNode(_sfc_main$g, { node: node3 }, null, 8, ["node"])
          ]),
          node: withCtx(({ node: node3 }) => [
            createVNode(NodeTreeLeaf, { node: node3 }, null, 8, ["node"])
          ]),
          _: 1
        }, 8, ["roots", "expandedKeys"]),
        createVNode(FolderCustomizationDialog, {
          modelValue: showCustomizationDialog.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showCustomizationDialog.value = $event),
          onConfirm: updateCustomization,
          initialIcon: initialIcon.value,
          initialColor: initialColor.value
        }, null, 8, ["modelValue", "initialIcon", "initialColor"])
      ], 64);
    };
  }
});
const _withScopeId$4 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-e7b35fd9"), n = n(), popScopeId(), n), "_withScopeId$4");
const _hoisted_1$d = { class: "_content" };
const _hoisted_2$9 = { class: "_footer" };
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "NodeSearchFilter",
  emits: ["addFilter"],
  setup(__props, { emit: __emit }) {
    const filters = computed(() => nodeDefStore.nodeSearchService.nodeFilters);
    const selectedFilter = ref();
    const filterValues = computed(() => selectedFilter.value?.fuseSearch.data ?? []);
    const selectedFilterValue = ref("");
    const nodeDefStore = useNodeDefStore();
    onMounted(() => {
      selectedFilter.value = nodeDefStore.nodeSearchService.nodeFilters[0];
      updateSelectedFilterValue();
    });
    const emit2 = __emit;
    const updateSelectedFilterValue = /* @__PURE__ */ __name(() => {
      if (filterValues.value.includes(selectedFilterValue.value)) {
        return;
      }
      selectedFilterValue.value = filterValues.value[0];
    }, "updateSelectedFilterValue");
    const submit = /* @__PURE__ */ __name(() => {
      emit2("addFilter", [
        selectedFilter.value,
        selectedFilterValue.value
      ]);
    }, "submit");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$d, [
          createVNode(unref(script$9), {
            class: "filter-type-select",
            modelValue: selectedFilter.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedFilter.value = $event),
            options: filters.value,
            allowEmpty: false,
            optionLabel: "name",
            onChange: updateSelectedFilterValue
          }, null, 8, ["modelValue", "options"]),
          createVNode(unref(script$y), {
            class: "filter-value-select",
            modelValue: selectedFilterValue.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedFilterValue.value = $event),
            options: filterValues.value,
            filter: ""
          }, null, 8, ["modelValue", "options"])
        ]),
        createBaseVNode("div", _hoisted_2$9, [
          createVNode(unref(script$M), {
            type: "button",
            label: _ctx.$t("add"),
            onClick: submit
          }, null, 8, ["label"])
        ])
      ], 64);
    };
  }
});
const NodeSearchFilter = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-e7b35fd9"]]);
const _hoisted_1$c = /* @__PURE__ */ createBaseVNode("div", { id: "node-library-node-preview-container" }, null, -1);
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "NodeLibrarySidebarTab",
  setup(__props) {
    const nodeDefStore = useNodeDefStore();
    const nodeBookmarkStore = useNodeBookmarkStore();
    const expandedKeys2 = ref({});
    const { expandNode, toggleNodeOnEvent } = useTreeExpansion(expandedKeys2);
    const nodeBookmarkTreeExplorerRef = ref(null);
    const searchFilter = ref(null);
    const alphabeticalSort = ref(false);
    const searchQuery = ref("");
    const root23 = computed(() => {
      const root24 = filteredRoot.value || nodeDefStore.nodeTree;
      return alphabeticalSort.value ? sortedTree(root24, { groupLeaf: true }) : root24;
    });
    const renderedRoot = computed(() => {
      const fillNodeInfo = /* @__PURE__ */ __name((node3) => {
        const children = node3.children?.map(fillNodeInfo);
        return {
          key: node3.key,
          label: node3.leaf ? node3.data.display_name : node3.label,
          leaf: node3.leaf,
          data: node3.data,
          getIcon: /* @__PURE__ */ __name((node22) => {
            if (node22.leaf) {
              return "pi pi-circle-fill";
            }
          }, "getIcon"),
          children,
          draggable: node3.leaf,
          handleClick: /* @__PURE__ */ __name((node22, e) => {
            if (node22.leaf) {
              app$1.addNodeOnGraph(node22.data, { pos: app$1.getCanvasCenter() });
            } else {
              toggleNodeOnEvent(e, node22);
            }
          }, "handleClick")
        };
      }, "fillNodeInfo");
      return fillNodeInfo(root23.value);
    });
    const filteredNodeDefs = ref([]);
    const filteredRoot = computed(() => {
      if (!filteredNodeDefs.value.length) {
        return null;
      }
      return buildNodeDefTree(filteredNodeDefs.value);
    });
    const filters = ref([]);
    const handleSearch = /* @__PURE__ */ __name((query) => {
      if (query.length === 0 && !filters.value.length) {
        filteredNodeDefs.value = [];
        expandedKeys2.value = {};
        return;
      }
      const f = filters.value.map((f2) => f2.filter);
      filteredNodeDefs.value = nodeDefStore.nodeSearchService.searchNode(
        query,
        f,
        {
          limit: 64
        },
        {
          matchWildcards: false
        }
      );
      nextTick(() => {
        expandNode(filteredRoot.value);
      });
    }, "handleSearch");
    const onAddFilter = /* @__PURE__ */ __name((filterAndValue) => {
      filters.value.push({
        filter: filterAndValue,
        badge: filterAndValue[0].invokeSequence.toUpperCase(),
        badgeClass: filterAndValue[0].invokeSequence + "-badge",
        text: filterAndValue[1],
        id: +/* @__PURE__ */ new Date()
      });
      handleSearch(searchQuery.value);
    }, "onAddFilter");
    const onRemoveFilter = /* @__PURE__ */ __name((filterAndValue) => {
      const index2 = filters.value.findIndex((f) => f === filterAndValue);
      if (index2 !== -1) {
        filters.value.splice(index2, 1);
      }
      handleSearch(searchQuery.value);
    }, "onRemoveFilter");
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(SidebarTabTemplate, {
          title: _ctx.$t("sideToolbar.nodeLibrary"),
          class: "bg-[var(--p-tree-background)]"
        }, {
          "tool-buttons": withCtx(() => [
            withDirectives(createVNode(unref(script$M), {
              class: "new-folder-button",
              icon: "pi pi-folder-plus",
              text: "",
              severity: "secondary",
              onClick: _cache[0] || (_cache[0] = ($event) => nodeBookmarkTreeExplorerRef.value?.addNewBookmarkFolder())
            }, null, 512), [
              [
                _directive_tooltip,
                _ctx.$t("newFolder"),
                void 0,
                { bottom: true }
              ]
            ]),
            withDirectives(createVNode(unref(script$M), {
              class: "sort-button",
              icon: alphabeticalSort.value ? "pi pi-sort-alpha-down" : "pi pi-sort-alt",
              text: "",
              severity: "secondary",
              onClick: _cache[1] || (_cache[1] = ($event) => alphabeticalSort.value = !alphabeticalSort.value)
            }, null, 8, ["icon"]), [
              [
                _directive_tooltip,
                _ctx.$t("sideToolbar.nodeLibraryTab.sortOrder"),
                void 0,
                { bottom: true }
              ]
            ])
          ]),
          header: withCtx(() => [
            createVNode(SearchBox, {
              class: "node-lib-search-box p-2 2xl:p-4",
              modelValue: searchQuery.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => searchQuery.value = $event),
              onSearch: handleSearch,
              onShowFilter: _cache[3] || (_cache[3] = ($event) => searchFilter.value.toggle($event)),
              onRemoveFilter,
              placeholder: _ctx.$t("searchNodes") + "...",
              "filter-icon": "pi pi-filter",
              filters: filters.value
            }, null, 8, ["modelValue", "placeholder", "filters"]),
            createVNode(unref(script$e), {
              ref_key: "searchFilter",
              ref: searchFilter,
              class: "ml-[-13px]"
            }, {
              default: withCtx(() => [
                createVNode(NodeSearchFilter, { onAddFilter })
              ]),
              _: 1
            }, 512)
          ]),
          body: withCtx(() => [
            createVNode(_sfc_main$e, {
              ref_key: "nodeBookmarkTreeExplorerRef",
              ref: nodeBookmarkTreeExplorerRef,
              "filtered-node-defs": filteredNodeDefs.value
            }, null, 8, ["filtered-node-defs"]),
            withDirectives(createVNode(unref(script$G), {
              type: "dashed",
              class: "m-2"
            }, null, 512), [
              [vShow, unref(nodeBookmarkStore).bookmarks.length > 0]
            ]),
            createVNode(TreeExplorer, {
              class: "node-lib-tree-explorer",
              roots: renderedRoot.value.children,
              expandedKeys: expandedKeys2.value,
              "onUpdate:expandedKeys": _cache[4] || (_cache[4] = ($event) => expandedKeys2.value = $event)
            }, {
              node: withCtx(({ node: node3 }) => [
                createVNode(NodeTreeLeaf, { node: node3 }, null, 8, ["node"])
              ]),
              _: 1
            }, 8, ["roots", "expandedKeys"])
          ]),
          _: 1
        }, 8, ["title"]),
        _hoisted_1$c
      ], 64);
    };
  }
});
const useNodeLibrarySidebarTab = /* @__PURE__ */ __name(() => {
  const { t } = useI18n();
  return {
    id: "node-library",
    icon: "pi pi-book",
    title: t("sideToolbar.nodeLibrary"),
    tooltip: t("sideToolbar.nodeLibrary"),
    component: markRaw(_sfc_main$c),
    type: "vue"
  };
}, "useNodeLibrarySidebarTab");
var PrimeVueConfirmSymbol = Symbol();
function useConfirm() {
  var PrimeVueConfirm = inject(PrimeVueConfirmSymbol);
  if (!PrimeVueConfirm) {
    throw new Error("No PrimeVue Confirmation provided!");
  }
  return PrimeVueConfirm;
}
__name(useConfirm, "useConfirm");
var ConfirmationEventBus = EventBus();
var theme$3 = /* @__PURE__ */ __name(function theme34(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-confirmpopup {\n    position: absolute;\n    margin-top: ".concat(dt2("confirmpopup.gutter"), ";\n    top: 0;\n    left: 0;\n    background: ").concat(dt2("confirmpopup.background"), ";\n    color: ").concat(dt2("confirmpopup.color"), ";\n    border: 1px solid ").concat(dt2("confirmpopup.border.color"), ";\n    border-radius: ").concat(dt2("confirmpopup.border.radius"), ";\n    box-shadow: ").concat(dt2("confirmpopup.shadow"), ";\n}\n\n.p-confirmpopup-content {\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt2("confirmpopup.content.padding"), ";\n    gap: ").concat(dt2("confirmpopup.content.gap"), ";\n}\n\n.p-confirmpopup-icon {\n    font-size: ").concat(dt2("confirmpopup.icon.size"), ";\n    width: ").concat(dt2("confirmpopup.icon.size"), ";\n    height: ").concat(dt2("confirmpopup.icon.size"), ";\n    color: ").concat(dt2("confirmpopup.icon.color"), ";\n}\n\n.p-confirmpopup-footer {\n    display: flex;\n    justify-content: flex-end;\n    gap: ").concat(dt2("confirmpopup.footer.gap"), ";\n    padding: ").concat(dt2("confirmpopup.footer.padding"), ";\n}\n\n.p-confirmpopup-footer button {\n    width: auto;\n}\n\n.p-confirmpopup-footer button:last-child {\n    margin: 0;\n}\n\n.p-confirmpopup-flipped {\n    margin-top: calc(").concat(dt2("confirmpopup.gutter"), " * -1);\n    margin-bottom: ").concat(dt2("confirmpopup.gutter"), ";\n}\n\n.p-confirmpopup-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-confirmpopup-leave-to {\n    opacity: 0;\n}\n\n.p-confirmpopup-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-confirmpopup-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n.p-confirmpopup:after,\n.p-confirmpopup:before {\n    bottom: 100%;\n    left: calc(").concat(dt2("confirmpopup.arrow.offset"), " + ").concat(dt2("confirmpopup.arrow.left"), ');\n    content: " ";\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none;\n}\n\n.p-confirmpopup:after {\n    border-width: calc(').concat(dt2("confirmpopup.gutter"), " - 2px);\n    margin-left: calc(-1 * (").concat(dt2("confirmpopup.gutter"), " - 2px));\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt2("confirmpopup.background"), ";\n}\n\n.p-confirmpopup:before {\n    border-width: ").concat(dt2("confirmpopup.gutter"), ";\n    margin-left: calc(-1 * ").concat(dt2("confirmpopup.gutter"), ");\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt2("confirmpopup.border.color"), ";\n}\n\n.p-confirmpopup-flipped:after,\n.p-confirmpopup-flipped:before {\n    bottom: auto;\n    top: 100%;\n}\n\n.p-confirmpopup-flipped:after {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt2("confirmpopup.background"), ";\n}\n\n.p-confirmpopup-flipped:before {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt2("confirmpopup.border.color"), ";\n}\n");
}, "theme");
var classes$3 = {
  root: "p-confirmpopup p-component",
  content: "p-confirmpopup-content",
  icon: "p-confirmpopup-icon",
  message: "p-confirmpopup-message",
  footer: "p-confirmpopup-footer",
  pcRejectButton: "p-confirmpopup-reject-button",
  pcAcceptButton: "p-confirmpopup-accept-button"
};
var ConfirmPopupStyle = BaseStyle.extend({
  name: "confirmpopup",
  theme: theme$3,
  classes: classes$3
});
var script$1$2 = {
  name: "BaseConfirmPopup",
  "extends": script$Y,
  props: {
    group: String
  },
  style: ConfirmPopupStyle,
  provide: /* @__PURE__ */ __name(function provide37() {
    return {
      $pcConfirmPopup: this,
      $parentInstance: this
    };
  }, "provide")
};
var script$7 = {
  name: "ConfirmPopup",
  "extends": script$1$2,
  inheritAttrs: false,
  data: /* @__PURE__ */ __name(function data17() {
    return {
      visible: false,
      confirmation: null,
      autoFocusAccept: null,
      autoFocusReject: null,
      target: null
    };
  }, "data"),
  target: null,
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  container: null,
  confirmListener: null,
  closeListener: null,
  mounted: /* @__PURE__ */ __name(function mounted16() {
    var _this = this;
    this.confirmListener = function(options3) {
      if (!options3) {
        return;
      }
      if (options3.group === _this.group) {
        _this.confirmation = options3;
        _this.target = options3.target;
        if (_this.confirmation.onShow) {
          _this.confirmation.onShow();
        }
        _this.visible = true;
      }
    };
    this.closeListener = function() {
      _this.visible = false;
      _this.confirmation = null;
    };
    ConfirmationEventBus.on("confirm", this.confirmListener);
    ConfirmationEventBus.on("close", this.closeListener);
  }, "mounted"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount9() {
    ConfirmationEventBus.off("confirm", this.confirmListener);
    ConfirmationEventBus.off("close", this.closeListener);
    this.unbindOutsideClickListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    this.unbindResizeListener();
    if (this.container) {
      ZIndex.clear(this.container);
      this.container = null;
    }
    this.target = null;
    this.confirmation = null;
  }, "beforeUnmount"),
  methods: {
    accept: /* @__PURE__ */ __name(function accept() {
      if (this.confirmation.accept) {
        this.confirmation.accept();
      }
      this.visible = false;
    }, "accept"),
    reject: /* @__PURE__ */ __name(function reject() {
      if (this.confirmation.reject) {
        this.confirmation.reject();
      }
      this.visible = false;
    }, "reject"),
    onHide: /* @__PURE__ */ __name(function onHide() {
      if (this.confirmation.onHide) {
        this.confirmation.onHide();
      }
      this.visible = false;
    }, "onHide"),
    onAcceptKeydown: /* @__PURE__ */ __name(function onAcceptKeydown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.accept();
        focus(this.target);
        event2.preventDefault();
      }
    }, "onAcceptKeydown"),
    onRejectKeydown: /* @__PURE__ */ __name(function onRejectKeydown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.reject();
        focus(this.target);
        event2.preventDefault();
      }
    }, "onRejectKeydown"),
    onEnter: /* @__PURE__ */ __name(function onEnter5(el) {
      this.autoFocusAccept = this.confirmation.defaultFocus === void 0 || this.confirmation.defaultFocus === "accept" ? true : false;
      this.autoFocusReject = this.confirmation.defaultFocus === "reject" ? true : false;
      this.target = document.activeElement;
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
    }, "onEnter"),
    onAfterEnter: /* @__PURE__ */ __name(function onAfterEnter3() {
      this.focus();
    }, "onAfterEnter"),
    onLeave: /* @__PURE__ */ __name(function onLeave4() {
      this.autoFocusAccept = null;
      this.autoFocusReject = null;
      focus(this.target);
      this.target = null;
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
    }, "onLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave4(el) {
      ZIndex.clear(el);
    }, "onAfterLeave"),
    alignOverlay: /* @__PURE__ */ __name(function alignOverlay5() {
      absolutePosition(this.container, this.target, false);
      var containerOffset = getOffset(this.container);
      var targetOffset = getOffset(this.target);
      var arrowLeft = 0;
      if (containerOffset.left < targetOffset.left) {
        arrowLeft = targetOffset.left - containerOffset.left;
      }
      this.container.style.setProperty($dt("confirmpopup.arrow.left").name, "".concat(arrowLeft, "px"));
      if (containerOffset.top < targetOffset.top) {
        this.container.setAttribute("data-p-confirmpopup-flipped", "true");
        !this.isUnstyled && addClass(this.container, "p-confirmpopup-flipped");
      }
    }, "alignOverlay"),
    bindOutsideClickListener: /* @__PURE__ */ __name(function bindOutsideClickListener5() {
      var _this2 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this2.visible && _this2.container && !_this2.container.contains(event2.target) && !_this2.isTargetClicked(event2)) {
            if (_this2.confirmation.onHide) {
              _this2.confirmation.onHide();
            }
            _this2.visible = false;
          } else {
            _this2.alignOverlay();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    }, "bindOutsideClickListener"),
    unbindOutsideClickListener: /* @__PURE__ */ __name(function unbindOutsideClickListener5() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    }, "unbindOutsideClickListener"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener4() {
      var _this3 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, function() {
          if (_this3.visible) {
            _this3.visible = false;
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener4() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    bindResizeListener: /* @__PURE__ */ __name(function bindResizeListener6() {
      var _this4 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this4.visible && !isTouchDevice()) {
            _this4.visible = false;
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    }, "bindResizeListener"),
    unbindResizeListener: /* @__PURE__ */ __name(function unbindResizeListener6() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }, "unbindResizeListener"),
    focus: /* @__PURE__ */ __name(function focus3() {
      var focusTarget = this.container.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus({
          preventScroll: true
        });
      }
    }, "focus"),
    isTargetClicked: /* @__PURE__ */ __name(function isTargetClicked2(event2) {
      return this.target && (this.target === event2.target || this.target.contains(event2.target));
    }, "isTargetClicked"),
    containerRef: /* @__PURE__ */ __name(function containerRef4(el) {
      this.container = el;
    }, "containerRef"),
    onOverlayClick: /* @__PURE__ */ __name(function onOverlayClick4(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.target
      });
    }, "onOverlayClick"),
    onOverlayKeydown: /* @__PURE__ */ __name(function onOverlayKeydown(event2) {
      if (event2.code === "Escape") {
        ConfirmationEventBus.emit("close", this.closeListener);
        focus(this.target);
      }
    }, "onOverlayKeydown")
  },
  computed: {
    message: /* @__PURE__ */ __name(function message() {
      return this.confirmation ? this.confirmation.message : null;
    }, "message"),
    acceptLabel: /* @__PURE__ */ __name(function acceptLabel() {
      if (this.confirmation) {
        var _confirmation$acceptP;
        var confirmation = this.confirmation;
        return confirmation.acceptLabel || ((_confirmation$acceptP = confirmation.acceptProps) === null || _confirmation$acceptP === void 0 ? void 0 : _confirmation$acceptP.label) || this.$primevue.config.locale.accept;
      }
      return this.$primevue.config.locale.accept;
    }, "acceptLabel"),
    rejectLabel: /* @__PURE__ */ __name(function rejectLabel() {
      if (this.confirmation) {
        var _confirmation$rejectP;
        var confirmation = this.confirmation;
        return confirmation.rejectLabel || ((_confirmation$rejectP = confirmation.rejectProps) === null || _confirmation$rejectP === void 0 ? void 0 : _confirmation$rejectP.label) || this.$primevue.config.locale.reject;
      }
      return this.$primevue.config.locale.reject;
    }, "rejectLabel"),
    acceptIcon: /* @__PURE__ */ __name(function acceptIcon() {
      var _this$confirmation;
      return this.confirmation ? this.confirmation.acceptIcon : (_this$confirmation = this.confirmation) !== null && _this$confirmation !== void 0 && _this$confirmation.acceptProps ? this.confirmation.acceptProps.icon : null;
    }, "acceptIcon"),
    rejectIcon: /* @__PURE__ */ __name(function rejectIcon() {
      var _this$confirmation2;
      return this.confirmation ? this.confirmation.rejectIcon : (_this$confirmation2 = this.confirmation) !== null && _this$confirmation2 !== void 0 && _this$confirmation2.rejectProps ? this.confirmation.rejectProps.icon : null;
    }, "rejectIcon")
  },
  components: {
    Button: script$M,
    Portal: script$z
  },
  directives: {
    focustrap: FocusTrap
  }
};
var _hoisted_1$b = ["aria-modal"];
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Button = resolveComponent("Button");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, null, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-confirmpopup",
        onEnter: $options.onEnter,
        onAfterEnter: $options.onAfterEnter,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          var _$data$confirmation$r, _$data$confirmation$r2, _$data$confirmation$a;
          return [$data.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            role: "alertdialog",
            "class": _ctx.cx("root"),
            "aria-modal": $data.visible,
            onClick: _cache[2] || (_cache[2] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            onKeydown: _cache[3] || (_cache[3] = function() {
              return $options.onOverlayKeydown && $options.onOverlayKeydown.apply($options, arguments);
            })
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            message: $data.confirmation,
            acceptCallback: $options.accept,
            rejectCallback: $options.reject
          }) : (openBlock(), createElementBlock(Fragment, {
            key: 1
          }, [!_ctx.$slots.message ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            "class": _ctx.cx("content")
          }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "icon", {}, function() {
            return [_ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), {
              key: 0,
              "class": normalizeClass(_ctx.cx("icon"))
            }, null, 8, ["class"])) : $data.confirmation.icon ? (openBlock(), createElementBlock("span", mergeProps({
              key: 1,
              "class": [$data.confirmation.icon, _ctx.cx("icon")]
            }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true)];
          }), createBaseVNode("span", mergeProps({
            "class": _ctx.cx("message")
          }, _ctx.ptm("message")), toDisplayString$1($data.confirmation.message), 17)], 16)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.message), {
            key: 1,
            message: $data.confirmation
          }, null, 8, ["message"])), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("footer")
          }, _ctx.ptm("footer")), [createVNode(_component_Button, mergeProps({
            "class": [_ctx.cx("pcRejectButton"), $data.confirmation.rejectClass],
            autofocus: $data.autoFocusReject,
            unstyled: _ctx.unstyled,
            size: ((_$data$confirmation$r = $data.confirmation.rejectProps) === null || _$data$confirmation$r === void 0 ? void 0 : _$data$confirmation$r.size) || "small",
            text: ((_$data$confirmation$r2 = $data.confirmation.rejectProps) === null || _$data$confirmation$r2 === void 0 ? void 0 : _$data$confirmation$r2.text) || false,
            onClick: _cache[0] || (_cache[0] = function($event) {
              return $options.reject();
            }),
            onKeydown: $options.onRejectKeydown
          }, $data.confirmation.rejectProps, {
            label: $options.rejectLabel,
            pt: _ctx.ptm("pcRejectButton")
          }), createSlots({
            _: 2
          }, [$options.rejectIcon || _ctx.$slots.rejecticon ? {
            name: "icon",
            fn: withCtx(function(iconProps) {
              return [renderSlot(_ctx.$slots, "rejecticon", {}, function() {
                return [createBaseVNode("span", mergeProps({
                  "class": [$options.rejectIcon, iconProps["class"]]
                }, _ctx.ptm("pcRejectButton")["icon"], {
                  "data-pc-section": "rejectbuttonicon"
                }), null, 16)];
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["class", "autofocus", "unstyled", "size", "text", "onKeydown", "label", "pt"]), createVNode(_component_Button, mergeProps({
            "class": [_ctx.cx("pcAcceptButton"), $data.confirmation.acceptClass],
            autofocus: $data.autoFocusAccept,
            unstyled: _ctx.unstyled,
            size: ((_$data$confirmation$a = $data.confirmation.acceptProps) === null || _$data$confirmation$a === void 0 ? void 0 : _$data$confirmation$a.size) || "small",
            onClick: _cache[1] || (_cache[1] = function($event) {
              return $options.accept();
            }),
            onKeydown: $options.onAcceptKeydown
          }, $data.confirmation.acceptProps, {
            label: $options.acceptLabel,
            pt: _ctx.ptm("pcAcceptButton")
          }), createSlots({
            _: 2
          }, [$options.acceptIcon || _ctx.$slots.accepticon ? {
            name: "icon",
            fn: withCtx(function(iconProps) {
              return [renderSlot(_ctx.$slots, "accepticon", {}, function() {
                return [createBaseVNode("span", mergeProps({
                  "class": [$options.acceptIcon, iconProps["class"]]
                }, _ctx.ptm("pcAcceptButton")["icon"], {
                  "data-pc-section": "acceptbuttonicon"
                }), null, 16)];
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["class", "autofocus", "unstyled", "size", "onKeydown", "label", "pt"])], 16)], 64))], 16, _hoisted_1$b)), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  });
}
__name(render$6, "render$6");
script$7.render = render$6;
const _withScopeId$3 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-9bc23daf"), n = n(), popScopeId(), n), "_withScopeId$3");
const _hoisted_1$a = ["src", "data-test"];
const _hoisted_2$8 = ["src"];
const _hoisted_3$6 = {
  key: 1,
  class: "broken-image-placeholder"
};
const _hoisted_4$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-image" }, null, -1));
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "ComfyImage",
  props: {
    src: {},
    class: {},
    contain: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const imageBroken = ref(false);
    const handleImageError = /* @__PURE__ */ __name((e) => {
      imageBroken.value = true;
    }, "handleImageError");
    const classArray = computed(() => {
      if (Array.isArray(props.class)) {
        return props.class;
      } else if (typeof props.class === "string") {
        return props.class.split(" ");
      } else if (typeof props.class === "object") {
        return Object.keys(props.class).filter((key) => props.class[key]);
      }
      return [];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        !imageBroken.value ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(["comfy-image-wrap", [{ contain: _ctx.contain }]])
        }, [
          _ctx.contain ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.src,
            onError: handleImageError,
            "data-test": _ctx.src,
            class: "comfy-image-blur",
            style: normalizeStyle({ "background-image": `url(${_ctx.src})` })
          }, null, 44, _hoisted_1$a)) : createCommentVNode("", true),
          createBaseVNode("img", {
            src: _ctx.src,
            onError: handleImageError,
            class: normalizeClass(["comfy-image-main", [...classArray.value]])
          }, null, 42, _hoisted_2$8)
        ], 2)) : createCommentVNode("", true),
        imageBroken.value ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
          _hoisted_4$4,
          createBaseVNode("span", null, toDisplayString$1(_ctx.$t("imageFailedToLoad")), 1)
        ])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const ComfyImage = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-9bc23daf"]]);
const _hoisted_1$9 = {
  controls: "",
  width: "100%",
  height: "100%"
};
const _hoisted_2$7 = ["src", "type"];
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "ResultVideo",
  props: {
    result: {}
  },
  setup(__props) {
    const props = __props;
    const settingStore = useSettingStore();
    const vhsAdvancedPreviews = computed(
      () => settingStore.get("VHS.AdvancedPreviews")
    );
    const url = computed(
      () => vhsAdvancedPreviews.value ? props.result.vhsAdvancedPreviewUrl : props.result.url
    );
    const htmlVideoType = computed(
      () => vhsAdvancedPreviews.value ? "video/webm" : props.result.htmlVideoType
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("video", _hoisted_1$9, [
        createBaseVNode("source", {
          src: url.value,
          type: htmlVideoType.value
        }, null, 8, _hoisted_2$7),
        createTextVNode(" " + toDisplayString$1(_ctx.$t("videoFailedToLoad")), 1)
      ]);
    };
  }
});
const _withScopeId$2 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-62b7731e"), n = n(), popScopeId(), n), "_withScopeId$2");
const _hoisted_1$8 = {
  key: 2,
  class: "task-result-preview"
};
const _hoisted_2$6 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-file" }, null, -1));
const _hoisted_3$5 = {
  key: 3,
  class: "preview-mask"
};
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "ResultItem",
  props: {
    result: {}
  },
  emits: ["preview"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const resultContainer = ref(null);
    const settingStore = useSettingStore();
    const imageFit = computed(
      () => settingStore.get("Comfy.Queue.ImageFit")
    );
    onMounted(() => {
      if (props.result.mediaType === "images") {
        resultContainer.value?.querySelectorAll("img").forEach((img) => {
          img.draggable = true;
        });
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "result-container",
        ref_key: "resultContainer",
        ref: resultContainer
      }, [
        _ctx.result.isImage ? (openBlock(), createBlock(ComfyImage, {
          key: 0,
          src: _ctx.result.url,
          class: "task-output-image",
          contain: imageFit.value === "contain"
        }, null, 8, ["src", "contain"])) : _ctx.result.isVideo ? (openBlock(), createBlock(_sfc_main$a, {
          key: 1,
          result: _ctx.result
        }, null, 8, ["result"])) : (openBlock(), createElementBlock("div", _hoisted_1$8, [
          _hoisted_2$6,
          createBaseVNode("span", null, toDisplayString$1(_ctx.result.mediaType), 1)
        ])),
        _ctx.result.supportsPreview ? (openBlock(), createElementBlock("div", _hoisted_3$5, [
          createVNode(unref(script$M), {
            icon: "pi pi-eye",
            severity: "secondary",
            onClick: _cache[0] || (_cache[0] = ($event) => emit2("preview", _ctx.result)),
            rounded: ""
          })
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});
const ResultItem = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-62b7731e"]]);
const _withScopeId$1 = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-28bce53e"), n = n(), popScopeId(), n), "_withScopeId$1");
const _hoisted_1$7 = { class: "task-result-preview" };
const _hoisted_2$5 = {
  key: 0,
  class: "pi pi-spin pi-spinner"
};
const _hoisted_3$4 = ["src"];
const _hoisted_4$3 = { key: 2 };
const _hoisted_5$2 = {
  key: 3,
  class: "pi pi-exclamation-triangle"
};
const _hoisted_6$1 = {
  key: 4,
  class: "pi pi-exclamation-circle"
};
const _hoisted_7 = { class: "task-item-details" };
const _hoisted_8 = { class: "tag-wrapper status-tag-group" };
const _hoisted_9 = ["innerHTML"];
const _hoisted_10 = {
  key: 0,
  class: "task-time"
};
const _hoisted_11 = {
  key: 1,
  class: "task-prompt-id"
};
const _hoisted_12 = { class: "tag-wrapper" };
const _hoisted_13 = { style: { "font-weight": "bold" } };
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "TaskItem",
  props: {
    task: {},
    isFlatTask: { type: Boolean }
  },
  emits: ["contextmenu", "preview", "task-output-length-clicked"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const flatOutputs = props.task.flatOutputs;
    const coverResult = flatOutputs.length ? props.task.previewOutput || flatOutputs[0] : null;
    const node3 = flatOutputs.length && props.task.workflow ? props.task.workflow.nodes.find(
      (n) => n.id == coverResult.nodeId
    ) ?? null : null;
    const progressPreviewBlobUrl = ref("");
    const emit2 = __emit;
    onMounted(() => {
      api.addEventListener("b_preview", onProgressPreviewReceived);
    });
    onUnmounted(() => {
      api.removeEventListener("b_preview", onProgressPreviewReceived);
    });
    const handleContextMenu = /* @__PURE__ */ __name((e) => {
      emit2("contextmenu", { task: props.task, event: e, node: node3 });
    }, "handleContextMenu");
    const handlePreview = /* @__PURE__ */ __name(() => {
      emit2("preview", props.task);
    }, "handlePreview");
    const handleOutputLengthClick = /* @__PURE__ */ __name(() => {
      emit2("task-output-length-clicked", props.task);
    }, "handleOutputLengthClick");
    const taskTagSeverity = /* @__PURE__ */ __name((status) => {
      switch (status) {
        case TaskItemDisplayStatus.Pending:
          return "secondary";
        case TaskItemDisplayStatus.Running:
          return "info";
        case TaskItemDisplayStatus.Completed:
          return "success";
        case TaskItemDisplayStatus.Failed:
          return "danger";
        case TaskItemDisplayStatus.Cancelled:
          return "warn";
      }
    }, "taskTagSeverity");
    const taskStatusText = /* @__PURE__ */ __name((status) => {
      switch (status) {
        case TaskItemDisplayStatus.Pending:
          return "Pending";
        case TaskItemDisplayStatus.Running:
          return '<i class="pi pi-spin pi-spinner" style="font-weight: bold"></i> Running';
        case TaskItemDisplayStatus.Completed:
          return '<i class="pi pi-check" style="font-weight: bold"></i>';
        case TaskItemDisplayStatus.Failed:
          return "Failed";
        case TaskItemDisplayStatus.Cancelled:
          return "Cancelled";
      }
    }, "taskStatusText");
    const formatTime = /* @__PURE__ */ __name((time) => {
      if (time === void 0) {
        return "";
      }
      return `${time.toFixed(2)}s`;
    }, "formatTime");
    const onProgressPreviewReceived = /* @__PURE__ */ __name(async ({ detail }) => {
      if (props.task.displayStatus === TaskItemDisplayStatus.Running) {
        progressPreviewBlobUrl.value = URL.createObjectURL(detail);
      }
    }, "onProgressPreviewReceived");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "task-item",
        onContextmenu: handleContextMenu
      }, [
        createBaseVNode("div", _hoisted_1$7, [
          _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Completed ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            unref(flatOutputs).length ? (openBlock(), createBlock(ResultItem, {
              key: 0,
              result: unref(coverResult),
              onPreview: handlePreview
            }, null, 8, ["result"])) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true),
          _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Running ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !progressPreviewBlobUrl.value ? (openBlock(), createElementBlock("i", _hoisted_2$5)) : (openBlock(), createElementBlock("img", {
              key: 1,
              src: progressPreviewBlobUrl.value,
              class: "progress-preview-img"
            }, null, 8, _hoisted_3$4))
          ], 64)) : _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Pending ? (openBlock(), createElementBlock("span", _hoisted_4$3, "...")) : _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Cancelled ? (openBlock(), createElementBlock("i", _hoisted_5$2)) : _ctx.task.displayStatus === unref(TaskItemDisplayStatus).Failed ? (openBlock(), createElementBlock("i", _hoisted_6$1)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_7, [
          createBaseVNode("div", _hoisted_8, [
            _ctx.isFlatTask && _ctx.task.isHistory ? (openBlock(), createBlock(unref(script$w), {
              key: 0,
              class: "node-name-tag"
            }, {
              default: withCtx(() => [
                createVNode(unref(script$M), {
                  class: "task-node-link",
                  label: `${unref(node3)?.type} (#${unref(node3)?.id})`,
                  link: "",
                  size: "small",
                  onClick: _cache[0] || (_cache[0] = ($event) => unref(app$1).goToNode(unref(node3)?.id))
                }, null, 8, ["label"])
              ]),
              _: 1
            })) : createCommentVNode("", true),
            createVNode(unref(script$w), {
              severity: taskTagSeverity(_ctx.task.displayStatus)
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  innerHTML: taskStatusText(_ctx.task.displayStatus)
                }, null, 8, _hoisted_9),
                _ctx.task.isHistory ? (openBlock(), createElementBlock("span", _hoisted_10, toDisplayString$1(formatTime(_ctx.task.executionTimeInSeconds)), 1)) : createCommentVNode("", true),
                _ctx.isFlatTask ? (openBlock(), createElementBlock("span", _hoisted_11, toDisplayString$1(_ctx.task.promptId.split("-")[0]), 1)) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["severity"])
          ]),
          createBaseVNode("div", _hoisted_12, [
            _ctx.task.isHistory && unref(flatOutputs).length > 1 ? (openBlock(), createBlock(unref(script$M), {
              key: 0,
              outlined: "",
              onClick: handleOutputLengthClick
            }, {
              default: withCtx(() => [
                createBaseVNode("span", _hoisted_13, toDisplayString$1(unref(flatOutputs).length), 1)
              ]),
              _: 1
            })) : createCommentVNode("", true)
          ])
        ])
      ], 32);
    };
  }
});
const TaskItem = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-28bce53e"]]);
var theme$2 = /* @__PURE__ */ __name(function theme35(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-galleria {\n    overflow: hidden;\n    border-style: solid;\n    border-width: ".concat(dt2("galleria.border.width"), ";\n    border-color: ").concat(dt2("galleria.border.color"), ";\n    border-radius: ").concat(dt2("galleria.border.radius"), ";\n}\n\n.p-galleria-content {\n    display: flex;\n    flex-direction: column;\n}\n\n.p-galleria-items-container {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n}\n\n.p-galleria-items {\n    position: relative;\n    display: flex;\n    height: 100%;\n}\n\n.p-galleria-nav-button {\n    position: absolute;\n    top: 50%;\n    display: inline-flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    background: ").concat(dt2("galleria.nav.button.background"), ";\n    color: ").concat(dt2("galleria.nav.button.color"), ";\n    width: ").concat(dt2("galleria.nav.button.size"), ";\n    height: ").concat(dt2("galleria.nav.button.size"), ";\n    transition: background ").concat(dt2("galleria.transition.duration"), ", color ").concat(dt2("galleria.transition.duration"), ", outline-color ").concat(dt2("galleria.transition.duration"), ", box-shadow ").concat(dt2("galleria.transition.duration"), ";\n    margin: calc(-1 * calc(").concat(dt2("galleria.nav.button.size"), ") / 2) ").concat(dt2("galleria.nav.button.gutter"), " 0 ").concat(dt2("galleria.nav.button.gutter"), ";\n    padding: 0;\n    user-select: none;\n    border: 0 none;\n    cursor: pointer;\n    outline-color: transparent;\n}\n\n.p-galleria-nav-button:not(.p-disabled):hover {\n    background: ").concat(dt2("galleria.nav.button.hover.background"), ";\n    color: ").concat(dt2("galleria.nav.button.hover.color"), ";\n}\n\n.p-galleria-nav-button:not(.p-disabled):focus-visible {\n    box-shadow: ").concat(dt2("galleria.nav.button.focus.ring.shadow"), ";\n    outline: ").concat(dt2("galleria.nav.button.focus.ring.width"), " ").concat(dt2("galleria.nav.button.focus.ring.style"), " ").concat(dt2("galleria.nav.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("galleria.nav.button.focus.ring.offset"), ";\n}\n\n.p-galleria-next-icon,\n.p-galleria-prev-icon {\n    font-size: ").concat(dt2("galleria.nav.icon.size"), ";\n    width: ").concat(dt2("galleria.nav.icon.size"), ";\n    height: ").concat(dt2("galleria.nav.icon.size"), ";\n}\n\n.p-galleria-prev-button {\n    border-radius: ").concat(dt2("galleria.nav.button.prev.border.radius"), ";\n    left: 0;\n}\n\n.p-galleria-next-button {\n    border-radius: ").concat(dt2("galleria.nav.button.next.border.radius"), ";\n    right: 0;\n}\n\n.p-galleria-item {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    width: 100%;\n}\n\n.p-galleria-hover-navigators .p-galleria-nav-button {\n    pointer-events: none;\n    opacity: 0;\n    transition: opacity ").concat(dt2("galleria.transition.duration"), " ease-in-out;\n}\n\n.p-galleria-hover-navigators .p-galleria-items-container:hover .p-galleria-nav-button {\n    pointer-events: all;\n    opacity: 1;\n}\n\n.p-galleria-hover-navigators .p-galleria-items-container:hover .p-galleria-nav-button.p-disabled {\n    pointer-events: none;\n}\n\n.p-galleria-caption {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    background: ").concat(dt2("galleria.caption.background"), ";\n    color: ").concat(dt2("galleria.caption.color"), ";\n    padding: ").concat(dt2("galleria.caption.padding"), ";\n}\n\n.p-galleria-thumbnails {\n    display: flex;\n    flex-direction: column;\n    overflow: auto;\n    flex-shrink: 0;\n}\n\n.p-galleria-thumbnail-nav-button {\n    align-self: center;\n    flex: 0 0 auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    position: relative;\n    margin: 0 ").concat(dt2("galleria.thumbnail.nav.button.gutter"), ";\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n    background: transparent;\n    color: ").concat(dt2("galleria.thumbnail.nav.button.color"), ";\n    width: ").concat(dt2("galleria.thumbnail.nav.button.size"), ";\n    height: ").concat(dt2("galleria.thumbnail.nav.button.size"), ";\n    transition: background ").concat(dt2("galleria.transition.duration"), ", color ").concat(dt2("galleria.transition.duration"), ", outline-color ").concat(dt2("galleria.transition.duration"), ";\n    outline-color: transparent;\n    border-radius: ").concat(dt2("galleria.thumbnail.nav.button.border.radius"), ";\n}\n\n.p-galleria-thumbnail-nav-button:hover {\n    background: ").concat(dt2("galleria.thumbnail.nav.button.hover.background"), ";\n    color: ").concat(dt2("galleria.thumbnail.nav.button.hover.color"), ";\n}\n\n.p-galleria-thumbnail-nav-button:focus-visible {\n    box-shadow: ").concat(dt2("galleria.thumbnail.nav.button.focus.ring.shadow"), ";\n    outline: ").concat(dt2("galleria.thumbnail.nav.button.focus.ring.width"), " ").concat(dt2("galleria.thumbnail.nav.button.focus.ring.style"), " ").concat(dt2("galleria.thumbnail.nav.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("galleria.thumbnail.nav.button.focus.ring.offset"), ";\n}\n\n.p-galleria-thumbnail-nav-button .p-galleria-thumbnail-next-icon,\n.p-galleria-thumbnail-nav-button .p-galleria-thumbnail-prev-icon {\n    font-size: ").concat(dt2("galleria.thumbnail.nav.button.icon.size"), ";\n    width: ").concat(dt2("galleria.thumbnail.nav.button.icon.size"), ";\n    height: ").concat(dt2("galleria.thumbnail.nav.button.icon.size"), ";\n}\n\n.p-galleria-thumbnails-content {\n    display: flex;\n    flex-direction: row;\n    background: ").concat(dt2("galleria.thumbnails.content.background"), ";\n    padding: ").concat(dt2("galleria.thumbnails.content.padding"), ";\n}\n\n.p-galleria-thumbnails-viewport {\n    overflow: hidden;\n    width: 100%;\n}\n\n.p-galleria-thumbnail-items {\n    display: flex;\n}\n\n.p-galleria-thumbnail-item {\n    overflow: auto;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    opacity: 0.5;\n}\n\n.p-galleria-thumbnail {\n    outline-color: transparent;\n}\n\n.p-galleria-thumbnail-item:hover {\n    opacity: 1;\n    transition: opacity 0.3s;\n}\n\n.p-galleria-thumbnail-item-current {\n    opacity: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-content,\n.p-galleria-thumbnails-right .p-galleria-content {\n    flex-direction: row;\n}\n\n.p-galleria-thumbnails-left .p-galleria-items-container,\n.p-galleria-thumbnails-right .p-galleria-items-container {\n    flex-direction: row;\n}\n\n.p-galleria-thumbnails-left .p-galleria-items-container,\n.p-galleria-thumbnails-top .p-galleria-items-container {\n    order: 2;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnails,\n.p-galleria-thumbnails-top .p-galleria-thumbnails {\n    order: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnails-content,\n.p-galleria-thumbnails-right .p-galleria-thumbnails-content {\n    flex-direction: column;\n    flex-grow: 1;\n}\n\n.p-galleria-thumbnails-left .p-galleria-thumbnail-items,\n.p-galleria-thumbnails-right .p-galleria-thumbnail-items {\n    flex-direction: column;\n    height: 100%;\n}\n\n.p-galleria-indicator-list {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: ").concat(dt2("galleria.indicator.list.padding"), ";\n    gap: ").concat(dt2("galleria.indicator.list.gap"), ";\n    margin: 0;\n    list-style: none;\n}\n\n.p-galleria-indicator-button {\n    display: inline-flex;\n    align-items: center;\n    background: ").concat(dt2("galleria.indicator.button.background"), ";\n    width: ").concat(dt2("galleria.indicator.button.width"), ";\n    height: ").concat(dt2("galleria.indicator.button.height"), ";\n    transition: background ").concat(dt2("galleria.transition.duration"), ", color ").concat(dt2("galleria.transition.duration"), ", outline-color ").concat(dt2("galleria.transition.duration"), ", box-shadow ").concat(dt2("galleria.transition.duration"), ";\n    outline-color: transparent;\n    border-radius: ").concat(dt2("galleria.indicator.button.border.radius"), ";\n    margin: 0;\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n}\n\n.p-galleria-indicator-button:hover {\n    background: ").concat(dt2("galleria.indicator.button.hover.background"), ";\n}\n\n.p-galleria-indicator-button:focus-visible {\n    box-shadow: ").concat(dt2("galleria.indicator.button.focus.ring.shadow"), ";\n    outline: ").concat(dt2("galleria.indicator.button.focus.ring.width"), " ").concat(dt2("galleria.indicator.button.focus.ring.style"), " ").concat(dt2("galleria.indicator.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("galleria.indicator.button.focus.ring.offset"), ";\n}\n\n.p-galleria-indicator-active .p-galleria-indicator-button {\n    background: ").concat(dt2("galleria.indicator.button.active.background"), ";\n}\n\n.p-galleria-indicators-left .p-galleria-items-container,\n.p-galleria-indicators-right .p-galleria-items-container {\n    flex-direction: row;\n    align-items: center;\n}\n\n.p-galleria-indicators-left .p-galleria-items,\n.p-galleria-indicators-top .p-galleria-items {\n    order: 2;\n}\n\n.p-galleria-indicators-left .p-galleria-indicator-list,\n.p-galleria-indicators-top .p-galleria-indicator-list {\n    order: 1;\n}\n\n.p-galleria-indicators-left .p-galleria-indicator-list,\n.p-galleria-indicators-right .p-galleria-indicator-list {\n    flex-direction: column;\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-list {\n    position: absolute;\n    display: flex;\n    z-index: 1;\n    background: ").concat(dt2("galleria.inset.indicator.list.background"), ";\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-button {\n    background: ").concat(dt2("galleria.inset.indicator.button.background"), ";\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-button:hover {\n    background: ").concat(dt2("galleria.inset.indicator.button.hover.background"), ";\n}\n\n.p-galleria-inset-indicators .p-galleria-indicator-active .p-galleria-indicator-button {\n    background: ").concat(dt2("galleria.inset.indicator.button.active.background"), ";\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-top .p-galleria-indicator-list {\n    top: 0;\n    left: 0;\n    width: 100%;\n    align-items: flex-start;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-right .p-galleria-indicator-list {\n    right: 0;\n    top: 0;\n    height: 100%;\n    align-items: flex-end;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-bottom .p-galleria-indicator-list {\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    align-items: flex-end;\n}\n\n.p-galleria-inset-indicators.p-galleria-indicators-left .p-galleria-indicator-list {\n    left: 0;\n    top: 0;\n    height: 100%;\n    align-items: flex-start;\n}\n\n.p-galleria-mask {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-galleria-close-button {\n    position: absolute;\n    top: 0;\n    right: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    margin: ").concat(dt2("galleria.close.button.gutter"), ";\n    background: ").concat(dt2("galleria.close.button.background"), ";\n    color: ").concat(dt2("galleria.close.button.color"), ";\n    width: ").concat(dt2("galleria.close.button.size"), ";\n    height: ").concat(dt2("galleria.close.button.size"), ";\n    padding: 0;\n    border: none;\n    user-select: none;\n    cursor: pointer;\n    border-radius: ").concat(dt2("galleria.close.button.border.radius"), ";\n    outline-color: transparent;\n    transition: background ").concat(dt2("galleria.transition.duration"), ", color ").concat(dt2("galleria.transition.duration"), ", outline-color ").concat(dt2("galleria.transition.duration"), ";\n}\n\n.p-galleria-close-icon {\n    font-size: ").concat(dt2("galleria.close.button.icon.size"), ";\n    width: ").concat(dt2("galleria.close.button.icon.size"), ";\n    height: ").concat(dt2("galleria.close.button.icon.size"), ";\n}\n\n.p-galleria-close-button:hover {\n    background: ").concat(dt2("galleria.close.button.hover.background"), ";\n    color: ").concat(dt2("galleria.close.button.hover.color"), ";\n}\n\n.p-galleria-close-button:focus-visible {\n    box-shadow: ").concat(dt2("galleria.close.button.focus.ring.shadow"), ";\n    outline: ").concat(dt2("galleria.close.button.focus.ring.width"), " ").concat(dt2("galleria.close.button.focus.ring.style"), " ").concat(dt2("galleria.close.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt2("galleria.close.button.focus.ring.offset"), ";\n}\n\n.p-galleria-mask .p-galleria-nav-button {\n    position: fixed;\n    top: 50%;\n}\n\n.p-galleria-enter-active {\n    transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-galleria-leave-active {\n    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.p-galleria-enter-from,\n.p-galleria-leave-to {\n    opacity: 0;\n    transform: scale(0.7);\n}\n\n.p-galleria-enter-active .p-galleria-nav-button {\n    opacity: 0;\n}\n\n.p-items-hidden .p-galleria-thumbnail-item {\n    visibility: hidden;\n}\n\n.p-items-hidden .p-galleria-thumbnail-item.p-galleria-thumbnail-item-active {\n    visibility: visible;\n}\n");
}, "theme");
var classes$2 = {
  mask: "p-galleria-mask p-overlay-mask p-overlay-mask-enter",
  root: /* @__PURE__ */ __name(function root22(_ref2) {
    var instance = _ref2.instance;
    var thumbnailsPosClass = instance.$attrs.showThumbnails && instance.getPositionClass("p-galleria-thumbnails", instance.$attrs.thumbnailsPosition);
    var indicatorPosClass = instance.$attrs.showIndicators && instance.getPositionClass("p-galleria-indicators", instance.$attrs.indicatorsPosition);
    return ["p-galleria p-component", {
      "p-galleria-fullscreen": instance.$attrs.fullScreen,
      "p-galleria-inset-indicators": instance.$attrs.showIndicatorsOnItem,
      "p-galleria-hover-navigators": instance.$attrs.showItemNavigatorsOnHover && !instance.$attrs.fullScreen
    }, thumbnailsPosClass, indicatorPosClass];
  }, "root"),
  closeButton: "p-galleria-close-button",
  closeIcon: "p-galleria-close-icon",
  header: "p-galleria-header",
  content: "p-galleria-content",
  footer: "p-galleria-footer",
  itemsContainer: "p-galleria-items-container",
  items: "p-galleria-items",
  prevButton: /* @__PURE__ */ __name(function prevButton(_ref3) {
    var instance = _ref3.instance;
    return ["p-galleria-prev-button p-galleria-nav-button", {
      "p-disabled": instance.isNavBackwardDisabled()
    }];
  }, "prevButton"),
  prevIcon: "p-galleria-prev-icon",
  item: "p-galleria-item",
  nextButton: /* @__PURE__ */ __name(function nextButton(_ref4) {
    var instance = _ref4.instance;
    return ["p-galleria-next-button p-galleria-nav-button", {
      "p-disabled": instance.isNavForwardDisabled()
    }];
  }, "nextButton"),
  nextIcon: "p-galleria-next-icon",
  caption: "p-galleria-caption",
  indicatorList: "p-galleria-indicator-list",
  indicator: /* @__PURE__ */ __name(function indicator(_ref5) {
    var instance = _ref5.instance, index2 = _ref5.index;
    return ["p-galleria-indicator", {
      "p-galleria-indicator-active": instance.isIndicatorItemActive(index2)
    }];
  }, "indicator"),
  indicatorButton: "p-galleria-indicator-button",
  thumbnails: "p-galleria-thumbnails",
  thumbnailContent: "p-galleria-thumbnails-content",
  thumbnailPrevButton: /* @__PURE__ */ __name(function thumbnailPrevButton(_ref6) {
    var instance = _ref6.instance;
    return ["p-galleria-thumbnail-prev-button p-galleria-thumbnail-nav-button", {
      "p-disabled": instance.isNavBackwardDisabled()
    }];
  }, "thumbnailPrevButton"),
  thumbnailPrevIcon: "p-galleria-thumbnail-prev-icon",
  thumbnailsViewport: "p-galleria-thumbnails-viewport",
  thumbnailItems: "p-galleria-thumbnail-items",
  thumbnailItem: /* @__PURE__ */ __name(function thumbnailItem(_ref7) {
    var instance = _ref7.instance, index2 = _ref7.index, activeIndex3 = _ref7.activeIndex;
    return ["p-galleria-thumbnail-item", {
      "p-galleria-thumbnail-item-current": activeIndex3 === index2,
      "p-galleria-thumbnail-item-active": instance.isItemActive(index2),
      "p-galleria-thumbnail-item-start": instance.firstItemAciveIndex() === index2,
      "p-galleria-thumbnail-item-end": instance.lastItemActiveIndex() === index2
    }];
  }, "thumbnailItem"),
  thumbnail: "p-galleria-thumbnail",
  thumbnailNextButton: /* @__PURE__ */ __name(function thumbnailNextButton(_ref8) {
    var instance = _ref8.instance;
    return ["p-galleria-thumbnail-next-button  p-galleria-thumbnail-nav-button", {
      "p-disabled": instance.isNavForwardDisabled()
    }];
  }, "thumbnailNextButton"),
  thumbnailNextIcon: "p-galleria-thumbnail-next-icon"
};
var GalleriaStyle = BaseStyle.extend({
  name: "galleria",
  theme: theme$2,
  classes: classes$2
});
var script$6 = {
  name: "ChevronUpIcon",
  "extends": script$X
};
var _hoisted_1$6 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M12.2097 10.4113C12.1057 10.4118 12.0027 10.3915 11.9067 10.3516C11.8107 10.3118 11.7237 10.2532 11.6506 10.1792L6.93602 5.46461L2.22139 10.1476C2.07272 10.244 1.89599 10.2877 1.71953 10.2717C1.54307 10.2556 1.3771 10.1808 1.24822 10.0593C1.11933 9.93766 1.035 9.77633 1.00874 9.6011C0.982477 9.42587 1.0158 9.2469 1.10338 9.09287L6.37701 3.81923C6.52533 3.6711 6.72639 3.58789 6.93602 3.58789C7.14565 3.58789 7.3467 3.6711 7.49502 3.81923L12.7687 9.09287C12.9168 9.24119 13 9.44225 13 9.65187C13 9.8615 12.9168 10.0626 12.7687 10.2109C12.616 10.3487 12.4151 10.4207 12.2097 10.4113Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$4 = [_hoisted_1$6];
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$4, 16);
}
__name(render$5, "render$5");
script$6.render = render$5;
var script$4 = {
  name: "BaseGalleria",
  "extends": script$Y,
  props: {
    id: {
      type: String,
      "default": null
    },
    value: {
      type: Array,
      "default": null
    },
    activeIndex: {
      type: Number,
      "default": 0
    },
    fullScreen: {
      type: Boolean,
      "default": false
    },
    visible: {
      type: Boolean,
      "default": false
    },
    numVisible: {
      type: Number,
      "default": 3
    },
    responsiveOptions: {
      type: Array,
      "default": null
    },
    showItemNavigators: {
      type: Boolean,
      "default": false
    },
    showThumbnailNavigators: {
      type: Boolean,
      "default": true
    },
    showItemNavigatorsOnHover: {
      type: Boolean,
      "default": false
    },
    changeItemOnIndicatorHover: {
      type: Boolean,
      "default": false
    },
    circular: {
      type: Boolean,
      "default": false
    },
    autoPlay: {
      type: Boolean,
      "default": false
    },
    transitionInterval: {
      type: Number,
      "default": 4e3
    },
    showThumbnails: {
      type: Boolean,
      "default": true
    },
    thumbnailsPosition: {
      type: String,
      "default": "bottom"
    },
    verticalThumbnailViewPortHeight: {
      type: String,
      "default": "300px"
    },
    showIndicators: {
      type: Boolean,
      "default": false
    },
    showIndicatorsOnItem: {
      type: Boolean,
      "default": false
    },
    indicatorsPosition: {
      type: String,
      "default": "bottom"
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    maskClass: {
      type: String,
      "default": null
    },
    containerStyle: {
      type: null,
      "default": null
    },
    containerClass: {
      type: null,
      "default": null
    },
    containerProps: {
      type: null,
      "default": null
    },
    prevButtonProps: {
      type: null,
      "default": null
    },
    nextButtonProps: {
      type: null,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaRoledescription: {
      type: String,
      "default": null
    }
  },
  style: GalleriaStyle,
  provide: /* @__PURE__ */ __name(function provide38() {
    return {
      $pcGalleria: this,
      $parentInstance: this
    };
  }, "provide")
};
function _toConsumableArray$1(r) {
  return _arrayWithoutHoles$1(r) || _iterableToArray$1(r) || _unsupportedIterableToArray$1(r) || _nonIterableSpread$1();
}
__name(_toConsumableArray$1, "_toConsumableArray$1");
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread$1, "_nonIterableSpread$1");
function _unsupportedIterableToArray$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$1, "_unsupportedIterableToArray$1");
function _iterableToArray$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray$1, "_iterableToArray$1");
function _arrayWithoutHoles$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$1(r);
}
__name(_arrayWithoutHoles$1, "_arrayWithoutHoles$1");
function _arrayLikeToArray$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$1, "_arrayLikeToArray$1");
var script$3 = {
  name: "GalleriaItem",
  hostName: "Galleria",
  "extends": script$Y,
  emits: ["start-slideshow", "stop-slideshow", "update:activeIndex"],
  props: {
    circular: {
      type: Boolean,
      "default": false
    },
    activeIndex: {
      type: Number,
      "default": 0
    },
    value: {
      type: Array,
      "default": null
    },
    showItemNavigators: {
      type: Boolean,
      "default": true
    },
    showIndicators: {
      type: Boolean,
      "default": true
    },
    slideShowActive: {
      type: Boolean,
      "default": true
    },
    changeItemOnIndicatorHover: {
      type: Boolean,
      "default": true
    },
    autoPlay: {
      type: Boolean,
      "default": false
    },
    templates: {
      type: null,
      "default": null
    },
    id: {
      type: String,
      "default": null
    }
  },
  mounted: /* @__PURE__ */ __name(function mounted17() {
    if (this.autoPlay) {
      this.$emit("start-slideshow");
    }
  }, "mounted"),
  methods: {
    getIndicatorPTOptions: /* @__PURE__ */ __name(function getIndicatorPTOptions(index2) {
      return {
        context: {
          highlighted: this.activeIndex === index2
        }
      };
    }, "getIndicatorPTOptions"),
    next: /* @__PURE__ */ __name(function next() {
      var nextItemIndex = this.activeIndex + 1;
      var activeIndex3 = this.circular && this.value.length - 1 === this.activeIndex ? 0 : nextItemIndex;
      this.$emit("update:activeIndex", activeIndex3);
    }, "next"),
    prev: /* @__PURE__ */ __name(function prev() {
      var prevItemIndex = this.activeIndex !== 0 ? this.activeIndex - 1 : 0;
      var activeIndex3 = this.circular && this.activeIndex === 0 ? this.value.length - 1 : prevItemIndex;
      this.$emit("update:activeIndex", activeIndex3);
    }, "prev"),
    stopSlideShow: /* @__PURE__ */ __name(function stopSlideShow() {
      if (this.slideShowActive && this.stopSlideShow) {
        this.$emit("stop-slideshow");
      }
    }, "stopSlideShow"),
    navBackward: /* @__PURE__ */ __name(function navBackward(e) {
      this.stopSlideShow();
      this.prev();
      if (e && e.cancelable) {
        e.preventDefault();
      }
    }, "navBackward"),
    navForward: /* @__PURE__ */ __name(function navForward(e) {
      this.stopSlideShow();
      this.next();
      if (e && e.cancelable) {
        e.preventDefault();
      }
    }, "navForward"),
    onIndicatorClick: /* @__PURE__ */ __name(function onIndicatorClick(index2) {
      this.stopSlideShow();
      this.$emit("update:activeIndex", index2);
    }, "onIndicatorClick"),
    onIndicatorMouseEnter: /* @__PURE__ */ __name(function onIndicatorMouseEnter(index2) {
      if (this.changeItemOnIndicatorHover) {
        this.stopSlideShow();
        this.$emit("update:activeIndex", index2);
      }
    }, "onIndicatorMouseEnter"),
    onIndicatorKeyDown: /* @__PURE__ */ __name(function onIndicatorKeyDown(event2, index2) {
      switch (event2.code) {
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.stopSlideShow();
          this.$emit("update:activeIndex", index2);
          event2.preventDefault();
          break;
        case "ArrowRight":
          this.onRightKey();
          break;
        case "ArrowLeft":
          this.onLeftKey();
          break;
        case "Home":
          this.onHomeKey();
          event2.preventDefault();
          break;
        case "End":
          this.onEndKey();
          event2.preventDefault();
          break;
        case "Tab":
          this.onTabKey();
          break;
        case "ArrowDown":
        case "ArrowUp":
        case "PageUp":
        case "PageDown":
          event2.preventDefault();
          break;
      }
    }, "onIndicatorKeyDown"),
    onRightKey: /* @__PURE__ */ __name(function onRightKey() {
      var indicators = _toConsumableArray$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      var activeIndex3 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex3, activeIndex3 + 1 === indicators.length ? indicators.length - 1 : activeIndex3 + 1);
    }, "onRightKey"),
    onLeftKey: /* @__PURE__ */ __name(function onLeftKey() {
      var activeIndex3 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex3, activeIndex3 - 1 <= 0 ? 0 : activeIndex3 - 1);
    }, "onLeftKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey4() {
      var activeIndex3 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex3, 0);
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey4() {
      var indicators = _toConsumableArray$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      var activeIndex3 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex3, indicators.length - 1);
    }, "onEndKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey4() {
      var indicators = _toConsumableArray$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      var highlightedIndex = indicators.findIndex(function(ind) {
        return getAttribute(ind, "data-p-active") === true;
      });
      var activeIndicator = findSingle(this.$refs.indicatorContent, '[data-pc-section="indicator"] > button[tabindex="0"]');
      var activeIndex3 = indicators.findIndex(function(ind) {
        return ind === activeIndicator.parentElement;
      });
      indicators[activeIndex3].children[0].tabIndex = "-1";
      indicators[highlightedIndex].children[0].tabIndex = "0";
    }, "onTabKey"),
    findFocusedIndicatorIndex: /* @__PURE__ */ __name(function findFocusedIndicatorIndex() {
      var indicators = _toConsumableArray$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      var activeIndicator = findSingle(this.$refs.indicatorContent, '[data-pc-section="indicator"] > button[tabindex="0"]');
      return indicators.findIndex(function(ind) {
        return ind === activeIndicator.parentElement;
      });
    }, "findFocusedIndicatorIndex"),
    changedFocusedIndicator: /* @__PURE__ */ __name(function changedFocusedIndicator(prevInd, nextInd) {
      var indicators = _toConsumableArray$1(find(this.$refs.indicatorContent, '[data-pc-section="indicator"]'));
      indicators[prevInd].children[0].tabIndex = "-1";
      indicators[nextInd].children[0].tabIndex = "0";
      indicators[nextInd].children[0].focus();
    }, "changedFocusedIndicator"),
    isIndicatorItemActive: /* @__PURE__ */ __name(function isIndicatorItemActive(index2) {
      return this.activeIndex === index2;
    }, "isIndicatorItemActive"),
    isNavBackwardDisabled: /* @__PURE__ */ __name(function isNavBackwardDisabled() {
      return !this.circular && this.activeIndex === 0;
    }, "isNavBackwardDisabled"),
    isNavForwardDisabled: /* @__PURE__ */ __name(function isNavForwardDisabled() {
      return !this.circular && this.activeIndex === this.value.length - 1;
    }, "isNavForwardDisabled"),
    ariaSlideNumber: /* @__PURE__ */ __name(function ariaSlideNumber(value3) {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.slideNumber.replace(/{slideNumber}/g, value3) : void 0;
    }, "ariaSlideNumber"),
    ariaPageLabel: /* @__PURE__ */ __name(function ariaPageLabel(value3) {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.pageLabel.replace(/{page}/g, value3) : void 0;
    }, "ariaPageLabel")
  },
  computed: {
    activeItem: /* @__PURE__ */ __name(function activeItem() {
      return this.value[this.activeIndex];
    }, "activeItem"),
    ariaSlideLabel: /* @__PURE__ */ __name(function ariaSlideLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.slide : void 0;
    }, "ariaSlideLabel")
  },
  components: {
    ChevronLeftIcon: script$r,
    ChevronRightIcon: script$q
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$3$1 = ["disabled"];
var _hoisted_2$2$1 = ["id", "aria-label", "aria-roledescription"];
var _hoisted_3$2 = ["disabled"];
var _hoisted_4$1 = ["aria-label", "aria-selected", "aria-controls", "onClick", "onMouseenter", "onKeydown", "data-p-active"];
var _hoisted_5$1 = ["tabindex"];
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("itemsContainer")
  }, _ctx.ptm("itemsContainer")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("items")
  }, _ctx.ptm("items")), [$props.showItemNavigators ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    type: "button",
    "class": _ctx.cx("prevButton"),
    onClick: _cache[0] || (_cache[0] = function($event) {
      return $options.navBackward($event);
    }),
    disabled: $options.isNavBackwardDisabled()
  }, _ctx.ptm("prevButton"), {
    "data-pc-group-section": "itemnavigator"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.previousitemicon || "ChevronLeftIcon"), mergeProps({
    "class": _ctx.cx("prevIcon")
  }, _ctx.ptm("prevIcon")), null, 16, ["class"]))], 16, _hoisted_1$3$1)), [[_directive_ripple]]) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    id: $props.id + "_item_" + $props.activeIndex,
    "class": _ctx.cx("item"),
    role: "group",
    "aria-label": $options.ariaSlideNumber($props.activeIndex + 1),
    "aria-roledescription": $options.ariaSlideLabel
  }, _ctx.ptm("item")), [$props.templates.item ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.item), {
    key: 0,
    item: $options.activeItem
  }, null, 8, ["item"])) : createCommentVNode("", true)], 16, _hoisted_2$2$1), $props.showItemNavigators ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 1,
    type: "button",
    "class": _ctx.cx("nextButton"),
    onClick: _cache[1] || (_cache[1] = function($event) {
      return $options.navForward($event);
    }),
    disabled: $options.isNavForwardDisabled()
  }, _ctx.ptm("nextButton"), {
    "data-pc-group-section": "itemnavigator"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.nextitemicon || "ChevronRightIcon"), mergeProps({
    "class": _ctx.cx("nextIcon")
  }, _ctx.ptm("nextIcon")), null, 16, ["class"]))], 16, _hoisted_3$2)), [[_directive_ripple]]) : createCommentVNode("", true), $props.templates["caption"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 2,
    "class": _ctx.cx("caption")
  }, _ctx.ptm("caption")), [$props.templates.caption ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.caption), {
    key: 0,
    item: $options.activeItem
  }, null, 8, ["item"])) : createCommentVNode("", true)], 16)) : createCommentVNode("", true)], 16), $props.showIndicators ? (openBlock(), createElementBlock("ul", mergeProps({
    key: 0,
    ref: "indicatorContent",
    "class": _ctx.cx("indicatorList")
  }, _ctx.ptm("indicatorList")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.value, function(item2, index2) {
    return openBlock(), createElementBlock("li", mergeProps({
      key: "p-galleria-indicator-".concat(index2),
      "class": _ctx.cx("indicator", {
        index: index2
      }),
      "aria-label": $options.ariaPageLabel(index2 + 1),
      "aria-selected": $props.activeIndex === index2,
      "aria-controls": $props.id + "_item_" + index2,
      onClick: /* @__PURE__ */ __name(function onClick3($event) {
        return $options.onIndicatorClick(index2);
      }, "onClick"),
      onMouseenter: /* @__PURE__ */ __name(function onMouseenter($event) {
        return $options.onIndicatorMouseEnter(index2);
      }, "onMouseenter"),
      onKeydown: /* @__PURE__ */ __name(function onKeydown3($event) {
        return $options.onIndicatorKeyDown($event, index2);
      }, "onKeydown"),
      ref_for: true
    }, _ctx.ptm("indicator", $options.getIndicatorPTOptions(index2)), {
      "data-p-active": $options.isIndicatorItemActive(index2)
    }), [!$props.templates["indicator"] ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      type: "button",
      tabindex: $props.activeIndex === index2 ? "0" : "-1",
      "class": _ctx.cx("indicatorButton"),
      ref_for: true
    }, _ctx.ptm("indicatorButton", $options.getIndicatorPTOptions(index2))), null, 16, _hoisted_5$1)) : createCommentVNode("", true), $props.templates.indicator ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.indicator), {
      key: 1,
      index: index2
    }, null, 8, ["index"])) : createCommentVNode("", true)], 16, _hoisted_4$1);
  }), 128))], 16)) : createCommentVNode("", true)], 16);
}
__name(render$3, "render$3");
script$3.render = render$3;
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$2(r) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread, "_nonIterableSpread");
function _unsupportedIterableToArray$2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray$2, "_unsupportedIterableToArray$2");
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
__name(_iterableToArray, "_iterableToArray");
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$2(r);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");
function _arrayLikeToArray$2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray$2, "_arrayLikeToArray$2");
var script$2 = {
  name: "GalleriaThumbnails",
  hostName: "Galleria",
  "extends": script$Y,
  emits: ["stop-slideshow", "update:activeIndex"],
  props: {
    containerId: {
      type: String,
      "default": null
    },
    value: {
      type: Array,
      "default": null
    },
    numVisible: {
      type: Number,
      "default": 3
    },
    activeIndex: {
      type: Number,
      "default": 0
    },
    isVertical: {
      type: Boolean,
      "default": false
    },
    slideShowActive: {
      type: Boolean,
      "default": false
    },
    circular: {
      type: Boolean,
      "default": false
    },
    responsiveOptions: {
      type: Array,
      "default": null
    },
    contentHeight: {
      type: String,
      "default": "300px"
    },
    showThumbnailNavigators: {
      type: Boolean,
      "default": true
    },
    templates: {
      type: null,
      "default": null
    },
    prevButtonProps: {
      type: null,
      "default": null
    },
    nextButtonProps: {
      type: null,
      "default": null
    }
  },
  startPos: null,
  thumbnailsStyle: null,
  sortedResponsiveOptions: null,
  data: /* @__PURE__ */ __name(function data18() {
    return {
      d_numVisible: this.numVisible,
      d_oldNumVisible: this.numVisible,
      d_activeIndex: this.activeIndex,
      d_oldActiveItemIndex: this.activeIndex,
      totalShiftedItems: 0,
      page: 0
    };
  }, "data"),
  watch: {
    numVisible: /* @__PURE__ */ __name(function numVisible(newValue, oldValue) {
      this.d_numVisible = newValue;
      this.d_oldNumVisible = oldValue;
    }, "numVisible"),
    activeIndex: /* @__PURE__ */ __name(function activeIndex2(newValue, oldValue) {
      this.d_activeIndex = newValue;
      this.d_oldActiveItemIndex = oldValue;
    }, "activeIndex")
  },
  mounted: /* @__PURE__ */ __name(function mounted18() {
    this.createStyle();
    this.calculatePosition();
    if (this.responsiveOptions) {
      this.bindDocumentListeners();
    }
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated8() {
    var totalShiftedItems = this.totalShiftedItems;
    if (this.d_oldNumVisible !== this.d_numVisible || this.d_oldActiveItemIndex !== this.d_activeIndex) {
      if (this.d_activeIndex <= this.getMedianItemIndex()) {
        totalShiftedItems = 0;
      } else if (this.value.length - this.d_numVisible + this.getMedianItemIndex() < this.d_activeIndex) {
        totalShiftedItems = this.d_numVisible - this.value.length;
      } else if (this.value.length - this.d_numVisible < this.d_activeIndex && this.d_numVisible % 2 === 0) {
        totalShiftedItems = this.d_activeIndex * -1 + this.getMedianItemIndex() + 1;
      } else {
        totalShiftedItems = this.d_activeIndex * -1 + this.getMedianItemIndex();
      }
      if (totalShiftedItems !== this.totalShiftedItems) {
        this.totalShiftedItems = totalShiftedItems;
      }
      this.$refs.itemsContainer.style.transform = this.isVertical ? "translate3d(0, ".concat(totalShiftedItems * (100 / this.d_numVisible), "%, 0)") : "translate3d(".concat(totalShiftedItems * (100 / this.d_numVisible), "%, 0, 0)");
      if (this.d_oldActiveItemIndex !== this.d_activeIndex) {
        document.body.setAttribute("data-p-items-hidden", "false");
        !this.isUnstyled && removeClass(this.$refs.itemsContainer, "p-items-hidden");
        this.$refs.itemsContainer.style.transition = "transform 500ms ease 0s";
      }
      this.d_oldActiveItemIndex = this.d_activeIndex;
      this.d_oldNumVisible = this.d_numVisible;
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount10() {
    if (this.responsiveOptions) {
      this.unbindDocumentListeners();
    }
    if (this.thumbnailsStyle) {
      this.thumbnailsStyle.parentNode.removeChild(this.thumbnailsStyle);
    }
  }, "beforeUnmount"),
  methods: {
    step: /* @__PURE__ */ __name(function step(dir) {
      var totalShiftedItems = this.totalShiftedItems + dir;
      if (dir < 0 && -1 * totalShiftedItems + this.d_numVisible > this.value.length - 1) {
        totalShiftedItems = this.d_numVisible - this.value.length;
      } else if (dir > 0 && totalShiftedItems > 0) {
        totalShiftedItems = 0;
      }
      if (this.circular) {
        if (dir < 0 && this.value.length - 1 === this.d_activeIndex) {
          totalShiftedItems = 0;
        } else if (dir > 0 && this.d_activeIndex === 0) {
          totalShiftedItems = this.d_numVisible - this.value.length;
        }
      }
      if (this.$refs.itemsContainer) {
        document.body.setAttribute("data-p-items-hidden", "false");
        !this.isUnstyled && removeClass(this.$refs.itemsContainer, "p-items-hidden");
        this.$refs.itemsContainer.style.transform = this.isVertical ? "translate3d(0, ".concat(totalShiftedItems * (100 / this.d_numVisible), "%, 0)") : "translate3d(".concat(totalShiftedItems * (100 / this.d_numVisible), "%, 0, 0)");
        this.$refs.itemsContainer.style.transition = "transform 500ms ease 0s";
      }
      this.totalShiftedItems = totalShiftedItems;
    }, "step"),
    stopSlideShow: /* @__PURE__ */ __name(function stopSlideShow2() {
      if (this.slideShowActive && this.stopSlideShow) {
        this.$emit("stop-slideshow");
      }
    }, "stopSlideShow"),
    getMedianItemIndex: /* @__PURE__ */ __name(function getMedianItemIndex() {
      var index2 = Math.floor(this.d_numVisible / 2);
      return this.d_numVisible % 2 ? index2 : index2 - 1;
    }, "getMedianItemIndex"),
    navBackward: /* @__PURE__ */ __name(function navBackward2(e) {
      this.stopSlideShow();
      var prevItemIndex = this.d_activeIndex !== 0 ? this.d_activeIndex - 1 : 0;
      var diff2 = prevItemIndex + this.totalShiftedItems;
      if (this.d_numVisible - diff2 - 1 > this.getMedianItemIndex() && (-1 * this.totalShiftedItems !== 0 || this.circular)) {
        this.step(1);
      }
      var activeIndex3 = this.circular && this.d_activeIndex === 0 ? this.value.length - 1 : prevItemIndex;
      this.$emit("update:activeIndex", activeIndex3);
      if (e.cancelable) {
        e.preventDefault();
      }
    }, "navBackward"),
    navForward: /* @__PURE__ */ __name(function navForward2(e) {
      this.stopSlideShow();
      var nextItemIndex = this.d_activeIndex === this.value.length - 1 ? this.value.length - 1 : this.d_activeIndex + 1;
      if (nextItemIndex + this.totalShiftedItems > this.getMedianItemIndex() && (-1 * this.totalShiftedItems < this.getTotalPageNumber() - 1 || this.circular)) {
        this.step(-1);
      }
      var activeIndex3 = this.circular && this.value.length - 1 === this.d_activeIndex ? 0 : nextItemIndex;
      this.$emit("update:activeIndex", activeIndex3);
      if (e.cancelable) {
        e.preventDefault();
      }
    }, "navForward"),
    onItemClick: /* @__PURE__ */ __name(function onItemClick3(index2) {
      this.stopSlideShow();
      var selectedItemIndex = index2;
      if (selectedItemIndex !== this.d_activeIndex) {
        var diff2 = selectedItemIndex + this.totalShiftedItems;
        var dir = 0;
        if (selectedItemIndex < this.d_activeIndex) {
          dir = this.d_numVisible - diff2 - 1 - this.getMedianItemIndex();
          if (dir > 0 && -1 * this.totalShiftedItems !== 0) {
            this.step(dir);
          }
        } else {
          dir = this.getMedianItemIndex() - diff2;
          if (dir < 0 && -1 * this.totalShiftedItems < this.getTotalPageNumber() - 1) {
            this.step(dir);
          }
        }
        this.$emit("update:activeIndex", selectedItemIndex);
      }
    }, "onItemClick"),
    onThumbnailKeydown: /* @__PURE__ */ __name(function onThumbnailKeydown(event2, index2) {
      if (event2.code === "Enter" || event2.code === "NumpadEnter" || event2.code === "Space") {
        this.onItemClick(index2);
        event2.preventDefault();
      }
      switch (event2.code) {
        case "ArrowRight":
          this.onRightKey();
          break;
        case "ArrowLeft":
          this.onLeftKey();
          break;
        case "Home":
          this.onHomeKey();
          event2.preventDefault();
          break;
        case "End":
          this.onEndKey();
          event2.preventDefault();
          break;
        case "ArrowUp":
        case "ArrowDown":
          event2.preventDefault();
          break;
        case "Tab":
          this.onTabKey();
          break;
      }
    }, "onThumbnailKeydown"),
    onRightKey: /* @__PURE__ */ __name(function onRightKey2() {
      var indicators = find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]');
      var activeIndex3 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex3, activeIndex3 + 1 === indicators.length ? indicators.length - 1 : activeIndex3 + 1);
    }, "onRightKey"),
    onLeftKey: /* @__PURE__ */ __name(function onLeftKey2() {
      var activeIndex3 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex3, activeIndex3 - 1 <= 0 ? 0 : activeIndex3 - 1);
    }, "onLeftKey"),
    onHomeKey: /* @__PURE__ */ __name(function onHomeKey5() {
      var activeIndex3 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex3, 0);
    }, "onHomeKey"),
    onEndKey: /* @__PURE__ */ __name(function onEndKey5() {
      var indicators = find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]');
      var activeIndex3 = this.findFocusedIndicatorIndex();
      this.changedFocusedIndicator(activeIndex3, indicators.length - 1);
    }, "onEndKey"),
    onTabKey: /* @__PURE__ */ __name(function onTabKey5() {
      var indicators = _toConsumableArray(find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]'));
      var highlightedIndex = indicators.findIndex(function(ind) {
        return getAttribute(ind, "data-p-active") === true;
      });
      var activeIndicator = findSingle(this.$refs.itemsContainer, '[tabindex="0"]');
      var activeIndex3 = indicators.findIndex(function(ind) {
        return ind === activeIndicator.parentElement;
      });
      indicators[activeIndex3].children[0].tabIndex = "-1";
      indicators[highlightedIndex].children[0].tabIndex = "0";
    }, "onTabKey"),
    findFocusedIndicatorIndex: /* @__PURE__ */ __name(function findFocusedIndicatorIndex2() {
      var indicators = _toConsumableArray(find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]'));
      var activeIndicator = findSingle(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"] > [tabindex="0"]');
      return indicators.findIndex(function(ind) {
        return ind === activeIndicator.parentElement;
      });
    }, "findFocusedIndicatorIndex"),
    changedFocusedIndicator: /* @__PURE__ */ __name(function changedFocusedIndicator2(prevInd, nextInd) {
      var indicators = find(this.$refs.itemsContainer, '[data-pc-section="thumbnailitem"]');
      indicators[prevInd].children[0].tabIndex = "-1";
      indicators[nextInd].children[0].tabIndex = "0";
      indicators[nextInd].children[0].focus();
    }, "changedFocusedIndicator"),
    onTransitionEnd: /* @__PURE__ */ __name(function onTransitionEnd(e) {
      if (this.$refs.itemsContainer && e.propertyName === "transform") {
        document.body.setAttribute("data-p-items-hidden", "true");
        !this.isUnstyled && addClass(this.$refs.itemsContainer, "p-items-hidden");
        this.$refs.itemsContainer.style.transition = "";
      }
    }, "onTransitionEnd"),
    onTouchStart: /* @__PURE__ */ __name(function onTouchStart(e) {
      var touchobj = e.changedTouches[0];
      this.startPos = {
        x: touchobj.pageX,
        y: touchobj.pageY
      };
    }, "onTouchStart"),
    onTouchMove: /* @__PURE__ */ __name(function onTouchMove(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
    }, "onTouchMove"),
    onTouchEnd: /* @__PURE__ */ __name(function onTouchEnd2(e) {
      var touchobj = e.changedTouches[0];
      if (this.isVertical) {
        this.changePageOnTouch(e, touchobj.pageY - this.startPos.y);
      } else {
        this.changePageOnTouch(e, touchobj.pageX - this.startPos.x);
      }
    }, "onTouchEnd"),
    changePageOnTouch: /* @__PURE__ */ __name(function changePageOnTouch(e, diff2) {
      if (diff2 < 0) {
        this.navForward(e);
      } else {
        this.navBackward(e);
      }
    }, "changePageOnTouch"),
    getTotalPageNumber: /* @__PURE__ */ __name(function getTotalPageNumber() {
      return this.value.length > this.d_numVisible ? this.value.length - this.d_numVisible + 1 : 0;
    }, "getTotalPageNumber"),
    createStyle: /* @__PURE__ */ __name(function createStyle3() {
      if (!this.thumbnailsStyle) {
        var _this$$primevue;
        this.thumbnailsStyle = document.createElement("style");
        this.thumbnailsStyle.type = "text/css";
        setAttribute(this.thumbnailsStyle, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.body.appendChild(this.thumbnailsStyle);
      }
      var innerHTML = "\n                #".concat(this.containerId, ' [data-pc-section="thumbnailitem"] {\n                    flex: 1 0 ').concat(100 / this.d_numVisible, "%\n                }\n            ");
      if (this.responsiveOptions && !this.isUnstyled) {
        this.sortedResponsiveOptions = _toConsumableArray(this.responsiveOptions);
        var comparer = localeComparator();
        this.sortedResponsiveOptions.sort(function(data1, data22) {
          var value1 = data1.breakpoint;
          var value22 = data22.breakpoint;
          return sort(value1, value22, -1, comparer);
        });
        for (var i2 = 0; i2 < this.sortedResponsiveOptions.length; i2++) {
          var res = this.sortedResponsiveOptions[i2];
          innerHTML += "\n                        @media screen and (max-width: ".concat(res.breakpoint, ") {\n                            #").concat(this.containerId, " .p-galleria-thumbnail-item {\n                                flex: 1 0 ").concat(100 / res.numVisible, "%\n                            }\n                        }\n                    ");
        }
      }
      this.thumbnailsStyle.innerHTML = innerHTML;
    }, "createStyle"),
    calculatePosition: /* @__PURE__ */ __name(function calculatePosition() {
      if (this.$refs.itemsContainer && this.sortedResponsiveOptions) {
        var windowWidth = window.innerWidth;
        var matchedResponsiveData = {
          numVisible: this.numVisible
        };
        for (var i2 = 0; i2 < this.sortedResponsiveOptions.length; i2++) {
          var res = this.sortedResponsiveOptions[i2];
          if (parseInt(res.breakpoint, 10) >= windowWidth) {
            matchedResponsiveData = res;
          }
        }
        if (this.d_numVisible !== matchedResponsiveData.numVisible) {
          this.d_numVisible = matchedResponsiveData.numVisible;
        }
      }
    }, "calculatePosition"),
    bindDocumentListeners: /* @__PURE__ */ __name(function bindDocumentListeners() {
      var _this = this;
      if (!this.documentResizeListener) {
        this.documentResizeListener = function() {
          _this.calculatePosition();
        };
        window.addEventListener("resize", this.documentResizeListener);
      }
    }, "bindDocumentListeners"),
    unbindDocumentListeners: /* @__PURE__ */ __name(function unbindDocumentListeners() {
      if (this.documentResizeListener) {
        window.removeEventListener("resize", this.documentResizeListener);
        this.documentResizeListener = null;
      }
    }, "unbindDocumentListeners"),
    isNavBackwardDisabled: /* @__PURE__ */ __name(function isNavBackwardDisabled2() {
      return !this.circular && this.d_activeIndex === 0 || this.value.length <= this.d_numVisible;
    }, "isNavBackwardDisabled"),
    isNavForwardDisabled: /* @__PURE__ */ __name(function isNavForwardDisabled2() {
      return !this.circular && this.d_activeIndex === this.value.length - 1 || this.value.length <= this.d_numVisible;
    }, "isNavForwardDisabled"),
    firstItemAciveIndex: /* @__PURE__ */ __name(function firstItemAciveIndex() {
      return this.totalShiftedItems * -1;
    }, "firstItemAciveIndex"),
    lastItemActiveIndex: /* @__PURE__ */ __name(function lastItemActiveIndex() {
      return this.firstItemAciveIndex() + this.d_numVisible - 1;
    }, "lastItemActiveIndex"),
    isItemActive: /* @__PURE__ */ __name(function isItemActive2(index2) {
      return this.firstItemAciveIndex() <= index2 && this.lastItemActiveIndex() >= index2;
    }, "isItemActive"),
    ariaPageLabel: /* @__PURE__ */ __name(function ariaPageLabel2(value3) {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.pageLabel.replace(/{page}/g, value3) : void 0;
    }, "ariaPageLabel")
  },
  computed: {
    ariaPrevButtonLabel: /* @__PURE__ */ __name(function ariaPrevButtonLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.prevPageLabel : void 0;
    }, "ariaPrevButtonLabel"),
    ariaNextButtonLabel: /* @__PURE__ */ __name(function ariaNextButtonLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.nextPageLabel : void 0;
    }, "ariaNextButtonLabel")
  },
  components: {
    ChevronLeftIcon: script$r,
    ChevronRightIcon: script$q,
    ChevronUpIcon: script$6,
    ChevronDownIcon: script$B
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
__name(_typeof$2, "_typeof$2");
function ownKeys$2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$2, "ownKeys$2");
function _objectSpread$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2(Object(t), true).forEach(function(r2) {
      _defineProperty$2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$2, "_objectSpread$2");
function _defineProperty$2(e, r, t) {
  return (r = _toPropertyKey$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$2, "_defineProperty$2");
function _toPropertyKey$2(t) {
  var i2 = _toPrimitive$2(t, "string");
  return "symbol" == _typeof$2(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$2, "_toPropertyKey$2");
function _toPrimitive$2(t, r) {
  if ("object" != _typeof$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$2, "_toPrimitive$2");
var _hoisted_1$2$1 = ["disabled", "aria-label"];
var _hoisted_2$1$1 = ["data-p-active", "aria-selected", "aria-controls", "onKeydown", "data-p-galleria-thumbnail-item-current", "data-p-galleria-thumbnail-item-active", "data-p-galleria-thumbnail-item-start", "data-p-galleria-thumbnail-item-end"];
var _hoisted_3$1$1 = ["tabindex", "aria-label", "aria-current", "onClick"];
var _hoisted_4$2 = ["disabled", "aria-label"];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("thumbnails")
  }, _ctx.ptm("thumbnails")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("thumbnailContent")
  }, _ctx.ptm("thumbnailContent")), [$props.showThumbnailNavigators ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    "class": _ctx.cx("thumbnailPrevButton"),
    disabled: $options.isNavBackwardDisabled(),
    type: "button",
    "aria-label": $options.ariaPrevButtonLabel,
    onClick: _cache[0] || (_cache[0] = function($event) {
      return $options.navBackward($event);
    })
  }, _objectSpread$2(_objectSpread$2({}, $props.prevButtonProps), _ctx.ptm("thumbnailPrevButton")), {
    "data-pc-group-section": "thumbnailnavigator"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.previousthumbnailicon || ($props.isVertical ? "ChevronUpIcon" : "ChevronLeftIcon")), mergeProps({
    "class": _ctx.cx("thumbnailPrevIcon")
  }, _ctx.ptm("thumbnailPrevIcon")), null, 16, ["class"]))], 16, _hoisted_1$2$1)), [[_directive_ripple]]) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("thumbnailsViewport"),
    style: {
      height: $props.isVertical ? $props.contentHeight : ""
    }
  }, _ctx.ptm("thumbnailsViewport")), [createBaseVNode("div", mergeProps({
    ref: "itemsContainer",
    "class": _ctx.cx("thumbnailItems"),
    role: "tablist",
    onTransitionend: _cache[1] || (_cache[1] = function($event) {
      return $options.onTransitionEnd($event);
    }),
    onTouchstart: _cache[2] || (_cache[2] = function($event) {
      return $options.onTouchStart($event);
    }),
    onTouchmove: _cache[3] || (_cache[3] = function($event) {
      return $options.onTouchMove($event);
    }),
    onTouchend: _cache[4] || (_cache[4] = function($event) {
      return $options.onTouchEnd($event);
    })
  }, _ctx.ptm("thumbnailItems")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.value, function(item2, index2) {
    return openBlock(), createElementBlock("div", mergeProps({
      key: "p-galleria-thumbnail-item-".concat(index2),
      "class": _ctx.cx("thumbnailItem", {
        index: index2,
        activeIndex: $props.activeIndex
      }),
      role: "tab",
      "data-p-active": $props.activeIndex === index2,
      "aria-selected": $props.activeIndex === index2,
      "aria-controls": $props.containerId + "_item_" + index2,
      onKeydown: /* @__PURE__ */ __name(function onKeydown3($event) {
        return $options.onThumbnailKeydown($event, index2);
      }, "onKeydown"),
      ref_for: true
    }, _ctx.ptm("thumbnailItem"), {
      "data-p-galleria-thumbnail-item-current": $props.activeIndex === index2,
      "data-p-galleria-thumbnail-item-active": $options.isItemActive(index2),
      "data-p-galleria-thumbnail-item-start": $options.firstItemAciveIndex() === index2,
      "data-p-galleria-thumbnail-item-end": $options.lastItemActiveIndex() === index2
    }), [createBaseVNode("div", mergeProps({
      "class": _ctx.cx("thumbnail"),
      tabindex: $props.activeIndex === index2 ? "0" : "-1",
      "aria-label": $options.ariaPageLabel(index2 + 1),
      "aria-current": $props.activeIndex === index2 ? "page" : void 0,
      onClick: /* @__PURE__ */ __name(function onClick3($event) {
        return $options.onItemClick(index2);
      }, "onClick"),
      ref_for: true
    }, _ctx.ptm("thumbnail")), [$props.templates.thumbnail ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.thumbnail), {
      key: 0,
      item: item2
    }, null, 8, ["item"])) : createCommentVNode("", true)], 16, _hoisted_3$1$1)], 16, _hoisted_2$1$1);
  }), 128))], 16)], 16), $props.showThumbnailNavigators ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 1,
    "class": _ctx.cx("thumbnailNextButton"),
    disabled: $options.isNavForwardDisabled(),
    type: "button",
    "aria-label": $options.ariaNextButtonLabel,
    onClick: _cache[5] || (_cache[5] = function($event) {
      return $options.navForward($event);
    })
  }, _objectSpread$2(_objectSpread$2({}, $props.nextButtonProps), _ctx.ptm("thumbnailNextButton")), {
    "data-pc-group-section": "thumbnailnavigator"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.nextthumbnailicon || ($props.isVertical ? "ChevronDownIcon" : "ChevronRightIcon")), mergeProps({
    "class": _ctx.cx("thumbnailNextIcon")
  }, _ctx.ptm("thumbnailNextIcon")), null, 16, ["class"]))], 16, _hoisted_4$2)), [[_directive_ripple]]) : createCommentVNode("", true)], 16)], 16);
}
__name(render$2, "render$2");
script$2.render = render$2;
function _typeof$1$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$1(o);
}
__name(_typeof$1$1, "_typeof$1$1");
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$1, "ownKeys$1");
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty$1$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$1, "_objectSpread$1");
function _defineProperty$1$1(e, r, t) {
  return (r = _toPropertyKey$1$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$1$1, "_defineProperty$1$1");
function _toPropertyKey$1$1(t) {
  var i2 = _toPrimitive$1$1(t, "string");
  return "symbol" == _typeof$1$1(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1$1, "_toPropertyKey$1$1");
function _toPrimitive$1$1(t, r) {
  if ("object" != _typeof$1$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$1$1, "_toPrimitive$1$1");
var script$1$1 = {
  name: "GalleriaContent",
  hostName: "Galleria",
  "extends": script$Y,
  inheritAttrs: false,
  interval: null,
  emits: ["activeitem-change", "mask-hide"],
  data: /* @__PURE__ */ __name(function data19() {
    return {
      id: this.$attrs.id || UniqueComponentId(),
      activeIndex: this.$attrs.activeIndex,
      numVisible: this.$attrs.numVisible,
      slideShowActive: false
    };
  }, "data"),
  watch: {
    "$attrs.id": /* @__PURE__ */ __name(function $attrsId8(newValue) {
      this.id = newValue || UniqueComponentId();
    }, "$attrsId"),
    "$attrs.value": /* @__PURE__ */ __name(function $attrsValue(newVal) {
      if (newVal && newVal.length < this.numVisible) {
        this.numVisible = newVal.length;
      }
    }, "$attrsValue"),
    "$attrs.activeIndex": /* @__PURE__ */ __name(function $attrsActiveIndex(newVal) {
      this.activeIndex = newVal;
    }, "$attrsActiveIndex"),
    "$attrs.numVisible": /* @__PURE__ */ __name(function $attrsNumVisible(newVal) {
      this.numVisible = newVal;
    }, "$attrsNumVisible"),
    "$attrs.autoPlay": /* @__PURE__ */ __name(function $attrsAutoPlay(newVal) {
      newVal ? this.startSlideShow() : this.stopSlideShow();
    }, "$attrsAutoPlay")
  },
  mounted: /* @__PURE__ */ __name(function mounted19() {
    this.id = this.id || UniqueComponentId();
  }, "mounted"),
  updated: /* @__PURE__ */ __name(function updated9() {
    this.$emit("activeitem-change", this.activeIndex);
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount11() {
    if (this.slideShowActive) {
      this.stopSlideShow();
    }
  }, "beforeUnmount"),
  methods: {
    getPTOptions: /* @__PURE__ */ __name(function getPTOptions10(key) {
      return this.ptm(key, {
        props: _objectSpread$1(_objectSpread$1({}, this.$attrs), {}, {
          pt: this.pt,
          unstyled: this.unstyled
        })
      });
    }, "getPTOptions"),
    isAutoPlayActive: /* @__PURE__ */ __name(function isAutoPlayActive() {
      return this.slideShowActive;
    }, "isAutoPlayActive"),
    startSlideShow: /* @__PURE__ */ __name(function startSlideShow() {
      var _this = this;
      this.interval = setInterval(function() {
        var activeIndex3 = _this.$attrs.circular && _this.$attrs.value.length - 1 === _this.activeIndex ? 0 : _this.activeIndex + 1;
        _this.activeIndex = activeIndex3;
      }, this.$attrs.transitionInterval);
      this.slideShowActive = true;
    }, "startSlideShow"),
    stopSlideShow: /* @__PURE__ */ __name(function stopSlideShow3() {
      if (this.interval) {
        clearInterval(this.interval);
      }
      this.slideShowActive = false;
    }, "stopSlideShow"),
    getPositionClass: /* @__PURE__ */ __name(function getPositionClass(preClassName, position2) {
      var positions = ["top", "left", "bottom", "right"];
      var pos2 = positions.find(function(item2) {
        return item2 === position2;
      });
      return pos2 ? "".concat(preClassName, "-").concat(pos2) : "";
    }, "getPositionClass"),
    isVertical: /* @__PURE__ */ __name(function isVertical3() {
      return this.$attrs.thumbnailsPosition === "left" || this.$attrs.thumbnailsPosition === "right";
    }, "isVertical")
  },
  computed: {
    closeAriaLabel: /* @__PURE__ */ __name(function closeAriaLabel3() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    }, "closeAriaLabel")
  },
  components: {
    GalleriaItem: script$3,
    GalleriaThumbnails: script$2,
    TimesIcon: script$A
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$3(o) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3(o);
}
__name(_typeof$3, "_typeof$3");
function ownKeys$3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys$3, "ownKeys$3");
function _objectSpread$3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$3(Object(t), true).forEach(function(r2) {
      _defineProperty$3(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread$3, "_objectSpread$3");
function _defineProperty$3(e, r, t) {
  return (r = _toPropertyKey$3(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$3, "_defineProperty$3");
function _toPropertyKey$3(t) {
  var i2 = _toPrimitive$3(t, "string");
  return "symbol" == _typeof$3(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$3, "_toPropertyKey$3");
function _toPrimitive$3(t, r) {
  if ("object" != _typeof$3(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$3(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$3, "_toPrimitive$3");
var _hoisted_1$1$1 = ["id", "aria-label", "aria-roledescription"];
var _hoisted_2$3 = ["aria-label"];
var _hoisted_3$3 = ["aria-live"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_GalleriaItem = resolveComponent("GalleriaItem");
  var _component_GalleriaThumbnails = resolveComponent("GalleriaThumbnails");
  var _directive_ripple = resolveDirective("ripple");
  return _ctx.$attrs.value && _ctx.$attrs.value.length > 0 ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    id: $data.id,
    role: "region",
    "class": [_ctx.cx("root"), _ctx.$attrs.containerClass],
    style: _ctx.$attrs.containerStyle,
    "aria-label": _ctx.$attrs.ariaLabel,
    "aria-roledescription": _ctx.$attrs.ariaRoledescription
  }, _objectSpread$3(_objectSpread$3({}, _ctx.$attrs.containerProps), $options.getPTOptions("root"))), [_ctx.$attrs.fullScreen ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    autofocus: "",
    type: "button",
    "class": _ctx.cx("closeButton"),
    "aria-label": $options.closeAriaLabel,
    onClick: _cache[0] || (_cache[0] = function($event) {
      return _ctx.$emit("mask-hide");
    })
  }, $options.getPTOptions("closeButton")), [(openBlock(), createBlock(resolveDynamicComponent(_ctx.$attrs.templates["closeicon"] || "TimesIcon"), mergeProps({
    "class": _ctx.cx("closeIcon")
  }, $options.getPTOptions("closeIcon")), null, 16, ["class"]))], 16, _hoisted_2$3)), [[_directive_ripple]]) : createCommentVNode("", true), _ctx.$attrs.templates && _ctx.$attrs.templates["header"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("header")
  }, $options.getPTOptions("header")), [(openBlock(), createBlock(resolveDynamicComponent(_ctx.$attrs.templates["header"])))], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("content"),
    "aria-live": _ctx.$attrs.autoPlay ? "polite" : "off"
  }, $options.getPTOptions("content")), [createVNode(_component_GalleriaItem, {
    id: $data.id,
    activeIndex: $data.activeIndex,
    "onUpdate:activeIndex": _cache[1] || (_cache[1] = function($event) {
      return $data.activeIndex = $event;
    }),
    slideShowActive: $data.slideShowActive,
    "onUpdate:slideShowActive": _cache[2] || (_cache[2] = function($event) {
      return $data.slideShowActive = $event;
    }),
    value: _ctx.$attrs.value,
    circular: _ctx.$attrs.circular,
    templates: _ctx.$attrs.templates,
    showIndicators: _ctx.$attrs.showIndicators,
    changeItemOnIndicatorHover: _ctx.$attrs.changeItemOnIndicatorHover,
    showItemNavigators: _ctx.$attrs.showItemNavigators,
    autoPlay: _ctx.$attrs.autoPlay,
    onStartSlideshow: $options.startSlideShow,
    onStopSlideshow: $options.stopSlideShow,
    pt: _ctx.pt,
    unstyled: _ctx.unstyled
  }, null, 8, ["id", "activeIndex", "slideShowActive", "value", "circular", "templates", "showIndicators", "changeItemOnIndicatorHover", "showItemNavigators", "autoPlay", "onStartSlideshow", "onStopSlideshow", "pt", "unstyled"]), _ctx.$attrs.showThumbnails ? (openBlock(), createBlock(_component_GalleriaThumbnails, {
    key: 0,
    activeIndex: $data.activeIndex,
    "onUpdate:activeIndex": _cache[3] || (_cache[3] = function($event) {
      return $data.activeIndex = $event;
    }),
    slideShowActive: $data.slideShowActive,
    "onUpdate:slideShowActive": _cache[4] || (_cache[4] = function($event) {
      return $data.slideShowActive = $event;
    }),
    containerId: $data.id,
    value: _ctx.$attrs.value,
    templates: _ctx.$attrs.templates,
    numVisible: $data.numVisible,
    responsiveOptions: _ctx.$attrs.responsiveOptions,
    circular: _ctx.$attrs.circular,
    isVertical: $options.isVertical(),
    contentHeight: _ctx.$attrs.verticalThumbnailViewPortHeight,
    showThumbnailNavigators: _ctx.$attrs.showThumbnailNavigators,
    prevButtonProps: _ctx.$attrs.prevButtonProps,
    nextButtonProps: _ctx.$attrs.nextButtonProps,
    onStopSlideshow: $options.stopSlideShow,
    pt: _ctx.pt,
    unstyled: _ctx.unstyled
  }, null, 8, ["activeIndex", "slideShowActive", "containerId", "value", "templates", "numVisible", "responsiveOptions", "circular", "isVertical", "contentHeight", "showThumbnailNavigators", "prevButtonProps", "nextButtonProps", "onStopSlideshow", "pt", "unstyled"])) : createCommentVNode("", true)], 16, _hoisted_3$3), _ctx.$attrs.templates && _ctx.$attrs.templates["footer"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 2,
    "class": _ctx.cx("footer")
  }, $options.getPTOptions("footer")), [(openBlock(), createBlock(resolveDynamicComponent(_ctx.$attrs.templates["footer"])))], 16)) : createCommentVNode("", true)], 16, _hoisted_1$1$1)) : createCommentVNode("", true);
}
__name(render$1, "render$1");
script$1$1.render = render$1;
var script$5 = {
  name: "Galleria",
  "extends": script$4,
  inheritAttrs: false,
  emits: ["update:activeIndex", "update:visible"],
  container: null,
  mask: null,
  data: /* @__PURE__ */ __name(function data20() {
    return {
      containerVisible: this.visible
    };
  }, "data"),
  updated: /* @__PURE__ */ __name(function updated10() {
    if (this.fullScreen && this.visible) {
      this.containerVisible = this.visible;
    }
  }, "updated"),
  beforeUnmount: /* @__PURE__ */ __name(function beforeUnmount12() {
    if (this.fullScreen) {
      unblockBodyScroll();
    }
    this.mask = null;
    if (this.container) {
      ZIndex.clear(this.container);
      this.container = null;
    }
  }, "beforeUnmount"),
  methods: {
    onBeforeEnter: /* @__PURE__ */ __name(function onBeforeEnter2(el) {
      ZIndex.set("modal", el, this.baseZIndex || this.$primevue.config.zIndex.modal);
    }, "onBeforeEnter"),
    onEnter: /* @__PURE__ */ __name(function onEnter6(el) {
      this.mask.style.zIndex = String(parseInt(el.style.zIndex, 10) - 1);
      blockBodyScroll();
      this.focus();
    }, "onEnter"),
    onBeforeLeave: /* @__PURE__ */ __name(function onBeforeLeave2() {
      !this.isUnstyled && addClass(this.mask, "p-overlay-mask-leave");
    }, "onBeforeLeave"),
    onAfterLeave: /* @__PURE__ */ __name(function onAfterLeave5(el) {
      ZIndex.clear(el);
      this.containerVisible = false;
      unblockBodyScroll();
    }, "onAfterLeave"),
    onActiveItemChange: /* @__PURE__ */ __name(function onActiveItemChange(index2) {
      if (this.activeIndex !== index2) {
        this.$emit("update:activeIndex", index2);
      }
    }, "onActiveItemChange"),
    maskHide: /* @__PURE__ */ __name(function maskHide() {
      this.$emit("update:visible", false);
    }, "maskHide"),
    containerRef: /* @__PURE__ */ __name(function containerRef5(el) {
      this.container = el;
    }, "containerRef"),
    maskRef: /* @__PURE__ */ __name(function maskRef2(el) {
      this.mask = el;
    }, "maskRef"),
    focus: /* @__PURE__ */ __name(function focus4() {
      var focusTarget = this.container.$el.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus();
      }
    }, "focus")
  },
  components: {
    GalleriaContent: script$1$1,
    Portal: script$z
  },
  directives: {
    focustrap: FocusTrap
  }
};
var _hoisted_1$5 = ["aria-modal"];
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_GalleriaContent = resolveComponent("GalleriaContent");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return _ctx.fullScreen ? (openBlock(), createBlock(_component_Portal, {
    key: 0
  }, {
    "default": withCtx(function() {
      return [$data.containerVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.maskRef,
        "class": [_ctx.cx("mask"), _ctx.maskClass],
        role: "dialog",
        "aria-modal": _ctx.fullScreen ? "true" : void 0
      }, _ctx.ptm("mask")), [createVNode(Transition, mergeProps({
        name: "p-galleria",
        onBeforeEnter: $options.onBeforeEnter,
        onEnter: $options.onEnter,
        onBeforeLeave: $options.onBeforeLeave,
        onAfterLeave: $options.onAfterLeave,
        appear: ""
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [_ctx.visible ? withDirectives((openBlock(), createBlock(_component_GalleriaContent, mergeProps({
            key: 0,
            ref: $options.containerRef,
            onMaskHide: $options.maskHide,
            templates: _ctx.$slots,
            onActiveitemChange: $options.onActiveItemChange,
            pt: _ctx.pt,
            unstyled: _ctx.unstyled
          }, _ctx.$props), null, 16, ["onMaskHide", "templates", "onActiveitemChange", "pt", "unstyled"])), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 1
      }, 16, ["onBeforeEnter", "onEnter", "onBeforeLeave", "onAfterLeave"])], 16, _hoisted_1$5)) : createCommentVNode("", true)];
    }),
    _: 1
  })) : (openBlock(), createBlock(_component_GalleriaContent, mergeProps({
    key: 1,
    templates: _ctx.$slots,
    onActiveitemChange: $options.onActiveItemChange,
    pt: _ctx.pt,
    unstyled: _ctx.unstyled
  }, _ctx.$props), null, 16, ["templates", "onActiveitemChange", "pt", "unstyled"]));
}
__name(render$4, "render$4");
script$5.render = render$4;
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "ResultGallery",
  props: {
    allGalleryItems: {},
    activeIndex: {}
  },
  emits: ["update:activeIndex"],
  setup(__props, { emit: __emit }) {
    const galleryVisible = ref(false);
    const emit2 = __emit;
    const props = __props;
    let maskMouseDownTarget = null;
    const onMaskMouseDown2 = /* @__PURE__ */ __name((event2) => {
      maskMouseDownTarget = event2.target;
    }, "onMaskMouseDown");
    const onMaskMouseUp2 = /* @__PURE__ */ __name((event2) => {
      const maskEl = document.querySelector("[data-mask]");
      if (galleryVisible.value && maskMouseDownTarget === event2.target && maskMouseDownTarget === maskEl) {
        galleryVisible.value = false;
        handleVisibilityChange(false);
      }
    }, "onMaskMouseUp");
    watch(
      () => props.activeIndex,
      (index2) => {
        if (index2 !== -1) {
          galleryVisible.value = true;
        }
      }
    );
    const handleVisibilityChange = /* @__PURE__ */ __name((visible) => {
      if (!visible) {
        emit2("update:activeIndex", -1);
      }
    }, "handleVisibilityChange");
    const handleActiveIndexChange = /* @__PURE__ */ __name((index2) => {
      emit2("update:activeIndex", index2);
    }, "handleActiveIndexChange");
    const handleKeyDown = /* @__PURE__ */ __name((event2) => {
      if (!galleryVisible.value) return;
      switch (event2.key) {
        case "ArrowLeft":
          navigateImage(-1);
          break;
        case "ArrowRight":
          navigateImage(1);
          break;
        case "Escape":
          galleryVisible.value = false;
          handleVisibilityChange(false);
          break;
      }
    }, "handleKeyDown");
    const navigateImage = /* @__PURE__ */ __name((direction) => {
      const newIndex = (props.activeIndex + direction + props.allGalleryItems.length) % props.allGalleryItems.length;
      emit2("update:activeIndex", newIndex);
    }, "navigateImage");
    onMounted(() => {
      window.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeyDown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$5), {
        visible: galleryVisible.value,
        "onUpdate:visible": [
          _cache[0] || (_cache[0] = ($event) => galleryVisible.value = $event),
          handleVisibilityChange
        ],
        activeIndex: _ctx.activeIndex,
        "onUpdate:activeIndex": handleActiveIndexChange,
        value: _ctx.allGalleryItems,
        showIndicators: false,
        changeItemOnIndicatorHover: "",
        showItemNavigators: "",
        fullScreen: "",
        circular: "",
        showThumbnails: false,
        pt: {
          mask: {
            onMousedown: onMaskMouseDown2,
            onMouseup: onMaskMouseUp2,
            "data-mask": true
          }
        }
      }, {
        item: withCtx(({ item: item2 }) => [
          item2.isImage ? (openBlock(), createBlock(ComfyImage, {
            key: item2.url,
            src: item2.url,
            contain: false,
            class: "galleria-image"
          }, null, 8, ["src"])) : item2.isVideo ? (openBlock(), createBlock(_sfc_main$a, {
            key: 1,
            result: item2
          }, null, 8, ["result"])) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["visible", "activeIndex", "value", "pt"]);
    };
  }
});
const _withScopeId = /* @__PURE__ */ __name((n) => (pushScopeId("data-v-93f5af09"), n = n(), popScopeId(), n), "_withScopeId");
const _hoisted_1$4 = { class: "queue-grid" };
const _hoisted_2$2 = { key: 1 };
const _hoisted_3$1 = { key: 2 };
const IMAGE_FIT = "Comfy.Queue.ImageFit";
const ITEMS_PER_PAGE = 8;
const SCROLL_THRESHOLD = 100;
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "QueueSidebarTab",
  setup(__props) {
    const confirm2 = useConfirm();
    const toast = useToast();
    const queueStore = useQueueStore();
    const settingStore = useSettingStore();
    const commandStore = useCommandStore();
    const { t } = useI18n();
    const isExpanded = ref(false);
    const visibleTasks = ref([]);
    const scrollContainer = ref(null);
    const loadMoreTrigger = ref(null);
    const galleryActiveIndex = ref(-1);
    const folderTask = ref(null);
    const isInFolderView = computed(() => folderTask.value !== null);
    const imageFit = computed(() => settingStore.get(IMAGE_FIT));
    const allTasks = computed(
      () => isInFolderView.value ? folderTask.value ? folderTask.value.flatten() : [] : isExpanded.value ? queueStore.flatTasks : queueStore.tasks
    );
    const allGalleryItems = computed(
      () => allTasks.value.flatMap((task) => {
        const previewOutput = task.previewOutput;
        return previewOutput ? [previewOutput] : [];
      })
    );
    const loadMoreItems = /* @__PURE__ */ __name(() => {
      const currentLength = visibleTasks.value.length;
      const newTasks = allTasks.value.slice(
        currentLength,
        currentLength + ITEMS_PER_PAGE
      );
      visibleTasks.value.push(...newTasks);
    }, "loadMoreItems");
    const checkAndLoadMore = /* @__PURE__ */ __name(() => {
      if (!scrollContainer.value) return;
      const { scrollHeight: scrollHeight2, scrollTop: scrollTop2, clientHeight } = scrollContainer.value;
      if (scrollHeight2 - scrollTop2 - clientHeight < SCROLL_THRESHOLD) {
        loadMoreItems();
      }
    }, "checkAndLoadMore");
    useInfiniteScroll(
      scrollContainer,
      () => {
        if (visibleTasks.value.length < allTasks.value.length) {
          loadMoreItems();
        }
      },
      { distance: SCROLL_THRESHOLD }
    );
    useResizeObserver(scrollContainer, () => {
      nextTick(() => {
        checkAndLoadMore();
      });
    });
    const updateVisibleTasks = /* @__PURE__ */ __name(() => {
      visibleTasks.value = allTasks.value.slice(0, ITEMS_PER_PAGE);
    }, "updateVisibleTasks");
    const toggleExpanded = /* @__PURE__ */ __name(() => {
      isExpanded.value = !isExpanded.value;
      updateVisibleTasks();
    }, "toggleExpanded");
    const removeTask = /* @__PURE__ */ __name((task) => {
      if (task.isRunning) {
        api.interrupt();
      }
      queueStore.delete(task);
    }, "removeTask");
    const removeAllTasks = /* @__PURE__ */ __name(async () => {
      await queueStore.clear();
    }, "removeAllTasks");
    const confirmRemoveAll = /* @__PURE__ */ __name((event2) => {
      confirm2.require({
        target: event2.currentTarget,
        message: "Do you want to delete all tasks?",
        icon: "pi pi-info-circle",
        rejectProps: {
          label: "Cancel",
          severity: "secondary",
          outlined: true
        },
        acceptProps: {
          label: "Delete",
          severity: "danger"
        },
        accept: /* @__PURE__ */ __name(async () => {
          await removeAllTasks();
          toast.add({
            severity: "info",
            summary: "Confirmed",
            detail: "Tasks deleted",
            life: 3e3
          });
        }, "accept")
      });
    }, "confirmRemoveAll");
    const onStatus = /* @__PURE__ */ __name(async () => {
      await queueStore.update();
      updateVisibleTasks();
    }, "onStatus");
    const menu = ref(null);
    const menuTargetTask = ref(null);
    const menuTargetNode = ref(null);
    const menuItems = computed(() => [
      {
        label: t("delete"),
        icon: "pi pi-trash",
        command: /* @__PURE__ */ __name(() => menuTargetTask.value && removeTask(menuTargetTask.value), "command"),
        disabled: isExpanded.value || isInFolderView.value
      },
      {
        label: t("loadWorkflow"),
        icon: "pi pi-file-export",
        command: /* @__PURE__ */ __name(() => menuTargetTask.value?.loadWorkflow(app$1), "command"),
        disabled: !menuTargetTask.value?.workflow
      },
      {
        label: t("goToNode"),
        icon: "pi pi-arrow-circle-right",
        command: /* @__PURE__ */ __name(() => app$1.goToNode(menuTargetNode.value?.id), "command"),
        visible: !!menuTargetNode.value
      }
    ]);
    const handleContextMenu = /* @__PURE__ */ __name(({
      task,
      event: event2,
      node: node3
    }) => {
      menuTargetTask.value = task;
      menuTargetNode.value = node3;
      menu.value?.show(event2);
    }, "handleContextMenu");
    const handlePreview = /* @__PURE__ */ __name((task) => {
      galleryActiveIndex.value = allGalleryItems.value.findIndex(
        (item2) => item2.url === task.previewOutput?.url
      );
    }, "handlePreview");
    const enterFolderView = /* @__PURE__ */ __name((task) => {
      folderTask.value = task;
      updateVisibleTasks();
    }, "enterFolderView");
    const exitFolderView = /* @__PURE__ */ __name(() => {
      folderTask.value = null;
      updateVisibleTasks();
    }, "exitFolderView");
    const toggleImageFit = /* @__PURE__ */ __name(() => {
      settingStore.set(IMAGE_FIT, imageFit.value === "cover" ? "contain" : "cover");
    }, "toggleImageFit");
    onMounted(() => {
      api.addEventListener("status", onStatus);
      queueStore.update();
    });
    onUnmounted(() => {
      api.removeEventListener("status", onStatus);
    });
    watch(
      allTasks,
      (newTasks) => {
        if (visibleTasks.value.length === 0 || visibleTasks.value.length > newTasks.length) {
          updateVisibleTasks();
        }
        nextTick(() => {
          checkAndLoadMore();
        });
      },
      { immediate: true }
    );
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(SidebarTabTemplate, {
          title: _ctx.$t("sideToolbar.queue")
        }, {
          "tool-buttons": withCtx(() => [
            withDirectives(createVNode(unref(script$M), {
              icon: imageFit.value === "cover" ? "pi pi-arrow-down-left-and-arrow-up-right-to-center" : "pi pi-arrow-up-right-and-arrow-down-left-from-center",
              text: "",
              severity: "secondary",
              onClick: toggleImageFit,
              class: "toggle-expanded-button"
            }, null, 8, ["icon"]), [
              [
                _directive_tooltip,
                _ctx.$t(`sideToolbar.queueTab.${imageFit.value}ImagePreview`),
                void 0,
                { bottom: true }
              ]
            ]),
            isInFolderView.value ? withDirectives((openBlock(), createBlock(unref(script$M), {
              key: 0,
              icon: "pi pi-arrow-left",
              text: "",
              severity: "secondary",
              onClick: exitFolderView,
              class: "back-button"
            }, null, 512)), [
              [
                _directive_tooltip,
                _ctx.$t("sideToolbar.queueTab.backToAllTasks"),
                void 0,
                { bottom: true }
              ]
            ]) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              withDirectives(createVNode(unref(script$M), {
                icon: isExpanded.value ? "pi pi-images" : "pi pi-image",
                text: "",
                severity: "secondary",
                onClick: toggleExpanded,
                class: "toggle-expanded-button"
              }, null, 8, ["icon"]), [
                [_directive_tooltip, _ctx.$t("sideToolbar.queueTab.showFlatList")]
              ]),
              unref(queueStore).hasPendingTasks ? withDirectives((openBlock(), createBlock(unref(script$M), {
                key: 0,
                icon: "pi pi-stop",
                severity: "danger",
                text: "",
                onClick: _cache[0] || (_cache[0] = () => unref(commandStore).execute("Comfy.ClearPendingTasks"))
              }, null, 512)), [
                [
                  _directive_tooltip,
                  _ctx.$t("sideToolbar.queueTab.clearPendingTasks"),
                  void 0,
                  { bottom: true }
                ]
              ]) : createCommentVNode("", true),
              createVNode(unref(script$M), {
                icon: "pi pi-trash",
                text: "",
                severity: "primary",
                onClick: _cache[1] || (_cache[1] = ($event) => confirmRemoveAll($event)),
                class: "clear-all-button"
              })
            ], 64))
          ]),
          body: withCtx(() => [
            visibleTasks.value.length > 0 ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_key: "scrollContainer",
              ref: scrollContainer,
              class: "scroll-container"
            }, [
              createBaseVNode("div", _hoisted_1$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleTasks.value, (task) => {
                  return openBlock(), createBlock(TaskItem, {
                    key: task.key,
                    task,
                    isFlatTask: isExpanded.value || isInFolderView.value,
                    onContextmenu: handleContextMenu,
                    onPreview: handlePreview,
                    onTaskOutputLengthClicked: _cache[2] || (_cache[2] = ($event) => enterFolderView($event))
                  }, null, 8, ["task", "isFlatTask"]);
                }), 128))
              ]),
              createBaseVNode("div", {
                ref_key: "loadMoreTrigger",
                ref: loadMoreTrigger,
                style: { "height": "1px" }
              }, null, 512)
            ], 512)) : unref(queueStore).isLoading ? (openBlock(), createElementBlock("div", _hoisted_2$2, [
              createVNode(unref(script$s), { style: { "width": "50px", "left": "50%", "transform": "translateX(-50%)" } })
            ])) : (openBlock(), createElementBlock("div", _hoisted_3$1, [
              createVNode(NoResultsPlaceholder, {
                icon: "pi pi-info-circle",
                title: _ctx.$t("noTasksFound"),
                message: _ctx.$t("noTasksFoundMessage")
              }, null, 8, ["title", "message"])
            ]))
          ]),
          _: 1
        }, 8, ["title"]),
        createVNode(unref(script$7)),
        createVNode(unref(script$g), {
          ref_key: "menu",
          ref: menu,
          model: menuItems.value
        }, null, 8, ["model"]),
        createVNode(_sfc_main$7, {
          activeIndex: galleryActiveIndex.value,
          "onUpdate:activeIndex": _cache[3] || (_cache[3] = ($event) => galleryActiveIndex.value = $event),
          allGalleryItems: allGalleryItems.value
        }, null, 8, ["activeIndex", "allGalleryItems"])
      ], 64);
    };
  }
});
const QueueSidebarTab = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-93f5af09"]]);
const useQueueSidebarTab = /* @__PURE__ */ __name(() => {
  const { t } = useI18n();
  const queuePendingTaskCountStore = useQueuePendingTaskCountStore();
  return {
    id: "queue",
    icon: "pi pi-history",
    iconBadge: /* @__PURE__ */ __name(() => {
      const value3 = queuePendingTaskCountStore.count.toString();
      return value3 === "0" ? null : value3;
    }, "iconBadge"),
    title: t("sideToolbar.queue"),
    tooltip: t("sideToolbar.queue"),
    component: markRaw(QueueSidebarTab),
    type: "vue"
  };
}, "useQueueSidebarTab");
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "WorkflowTreeLeaf",
  props: {
    node: {}
  },
  setup(__props) {
    const props = __props;
    const workflowBookmarkStore = useWorkflowBookmarkStore();
    const isBookmarked = computed(
      () => workflowBookmarkStore.isBookmarked(props.node.data.path)
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(TreeExplorerTreeNode, { node: _ctx.node }, {
        actions: withCtx(({ node: node3 }) => [
          createVNode(unref(script$M), {
            icon: isBookmarked.value ? "pi pi-bookmark-fill" : "pi pi-bookmark",
            text: "",
            severity: "secondary",
            size: "small",
            onClick: withModifiers(($event) => unref(workflowBookmarkStore).toggleBookmarked(node3.data.path), ["stop"])
          }, null, 8, ["icon", "onClick"])
        ]),
        _: 1
      }, 8, ["node"]);
    };
  }
});
const _hoisted_1$3 = {
  key: 0,
  class: "mr-2 shrink-0"
};
const _hoisted_2$1 = {
  key: 1,
  class: "ml-2 shrink-0"
};
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "TextDivider",
  props: {
    text: {},
    class: {},
    position: { default: "left" },
    align: { default: "center" },
    type: { default: "solid" },
    layout: { default: "horizontal" }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["flex items-center", props.class])
      }, [
        _ctx.position === "left" ? (openBlock(), createElementBlock("span", _hoisted_1$3, toDisplayString$1(_ctx.text), 1)) : createCommentVNode("", true),
        createVNode(unref(script$G), {
          align: _ctx.align,
          type: _ctx.type,
          layout: _ctx.layout,
          class: "flex-grow"
        }, null, 8, ["align", "type", "layout"]),
        _ctx.position === "right" ? (openBlock(), createElementBlock("span", _hoisted_2$1, toDisplayString$1(_ctx.text), 1)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
const _hoisted_1$2 = {
  key: 0,
  class: "comfyui-workflows-panel"
};
const _hoisted_2 = {
  key: 0,
  class: "comfyui-workflows-open"
};
const _hoisted_3 = { key: 0 };
const _hoisted_4 = { class: "comfyui-workflows-bookmarks" };
const _hoisted_5 = { class: "comfyui-workflows-browse" };
const _hoisted_6 = {
  key: 1,
  class: "comfyui-workflows-search-panel"
};
var WorkflowTreeType = /* @__PURE__ */ ((WorkflowTreeType2) => {
  WorkflowTreeType2["Open"] = "Open";
  WorkflowTreeType2["Bookmarks"] = "Bookmarks";
  WorkflowTreeType2["Browse"] = "Browse";
  return WorkflowTreeType2;
})(WorkflowTreeType || {});
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "WorkflowsSidebarTab",
  setup(__props) {
    const settingStore = useSettingStore();
    const workflowTabsPosition = computed(
      () => settingStore.get("Comfy.Workflow.WorkflowTabsPosition")
    );
    const searchQuery = ref("");
    const isSearching = computed(() => searchQuery.value.length > 0);
    const filteredWorkflows = ref([]);
    const filteredRoot = computed(() => {
      return buildWorkflowTree(filteredWorkflows.value);
    });
    const handleSearch = /* @__PURE__ */ __name((query) => {
      if (query.length === 0) {
        filteredWorkflows.value = [];
        expandedKeys2.value = {};
        return;
      }
      const lowerQuery = query.toLocaleLowerCase();
      filteredWorkflows.value = workflowStore.workflows.filter((workflow) => {
        return workflow.path.toLocaleLowerCase().includes(lowerQuery);
      });
      nextTick(() => {
        expandNode(filteredRoot.value);
      });
    }, "handleSearch");
    const commandStore = useCommandStore();
    const workflowStore = useWorkflowStore();
    const workspaceStore = useWorkspaceStore();
    const { t } = useI18n();
    const expandedKeys2 = ref({});
    const { expandNode, toggleNodeOnEvent } = useTreeExpansion(expandedKeys2);
    const handleCloseWorkflow = /* @__PURE__ */ __name((workflow) => {
      if (workflow) {
        workflowService.closeWorkflow(workflow, {
          warnIfUnsaved: !workspaceStore.shiftDown
        });
      }
    }, "handleCloseWorkflow");
    const buildWorkflowTree = /* @__PURE__ */ __name((workflows) => {
      return buildTree(
        workflows,
        (workflow) => workflow.key.split("/")
      );
    }, "buildWorkflowTree");
    const workflowsTree = computed(
      () => sortedTree(buildWorkflowTree(workflowStore.persistedWorkflows), {
        groupLeaf: true
      })
    );
    const bookmarkedWorkflowsTree = computed(
      () => buildTree(workflowStore.bookmarkedWorkflows, (workflow) => [workflow.key])
    );
    const openWorkflowsTree = computed(
      () => buildTree(workflowStore.openWorkflows, (workflow) => [workflow.key])
    );
    const renderTreeNode = /* @__PURE__ */ __name((node3, type) => {
      const children = node3.children?.map((child) => renderTreeNode(child, type));
      const workflow = node3.data;
      const handleClick = /* @__PURE__ */ __name((node22, e) => {
        if (node22.leaf) {
          workflowService.openWorkflow(workflow);
        } else {
          toggleNodeOnEvent(e, node22);
        }
      }, "handleClick");
      const actions = node3.leaf ? {
        handleClick,
        handleRename: /* @__PURE__ */ __name(async (node22, newName) => {
          const newPath = type === "Browse" ? workflow.directory + "/" + appendJsonExt(newName) : ComfyWorkflow.basePath + appendJsonExt(newName);
          await workflowService.renameWorkflow(workflow, newPath);
        }, "handleRename"),
        handleDelete: workflow.isTemporary ? void 0 : () => {
          workflowService.deleteWorkflow(workflow);
        },
        contextMenuItems: /* @__PURE__ */ __name((node22) => {
          return [
            {
              label: t("insert"),
              icon: "pi pi-file-export",
              command: /* @__PURE__ */ __name(() => {
                const workflow2 = node22.data;
                workflowService.insertWorkflow(workflow2);
              }, "command")
            }
          ];
        }, "contextMenuItems")
      } : { handleClick };
      return {
        key: node3.key,
        label: node3.label,
        leaf: node3.leaf,
        data: node3.data,
        children,
        ...actions
      };
    }, "renderTreeNode");
    const selectionKeys = computed(() => ({
      [`root/${workflowStore.activeWorkflow?.key}`]: true
    }));
    const workflowBookmarkStore = useWorkflowBookmarkStore();
    onMounted(async () => {
      await workflowBookmarkStore.loadBookmarks();
    });
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createBlock(SidebarTabTemplate, {
        title: _ctx.$t("sideToolbar.workflows"),
        class: "bg-[var(--p-tree-background)]"
      }, {
        "tool-buttons": withCtx(() => [
          withDirectives(createVNode(unref(script$M), {
            class: "browse-templates-button",
            icon: "pi pi-th-large",
            text: "",
            onClick: _cache[0] || (_cache[0] = () => unref(commandStore).execute("Comfy.BrowseTemplates"))
          }, null, 512), [
            [
              _directive_tooltip,
              _ctx.$t("sideToolbar.browseTemplates"),
              void 0,
              { bottom: true }
            ]
          ]),
          withDirectives(createVNode(unref(script$M), {
            class: "open-workflow-button",
            icon: "pi pi-folder-open",
            text: "",
            onClick: _cache[1] || (_cache[1] = () => unref(commandStore).execute("Comfy.OpenWorkflow"))
          }, null, 512), [
            [
              _directive_tooltip,
              _ctx.$t("sideToolbar.openWorkflow"),
              void 0,
              { bottom: true }
            ]
          ]),
          withDirectives(createVNode(unref(script$M), {
            class: "new-blank-workflow-button",
            icon: "pi pi-plus",
            onClick: _cache[2] || (_cache[2] = () => unref(commandStore).execute("Comfy.NewBlankWorkflow")),
            text: ""
          }, null, 512), [
            [
              _directive_tooltip,
              _ctx.$t("sideToolbar.newBlankWorkflow"),
              void 0,
              { bottom: true }
            ]
          ])
        ]),
        header: withCtx(() => [
          createVNode(SearchBox, {
            class: "workflows-search-box p-2 2xl:p-4",
            modelValue: searchQuery.value,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => searchQuery.value = $event),
            onSearch: handleSearch,
            placeholder: _ctx.$t("searchWorkflows") + "..."
          }, null, 8, ["modelValue", "placeholder"])
        ]),
        body: withCtx(() => [
          !isSearching.value ? (openBlock(), createElementBlock("div", _hoisted_1$2, [
            workflowTabsPosition.value === "Sidebar" ? (openBlock(), createElementBlock("div", _hoisted_2, [
              createVNode(_sfc_main$4, {
                text: "Open",
                type: "dashed",
                class: "ml-2"
              }),
              createVNode(TreeExplorer, {
                roots: renderTreeNode(
                  openWorkflowsTree.value,
                  "Open"
                  /* Open */
                ).children,
                selectionKeys: selectionKeys.value
              }, {
                node: withCtx(({ node: node3 }) => [
                  createVNode(TreeExplorerTreeNode, { node: node3 }, {
                    "before-label": withCtx(({ node: node22 }) => [
                      node22.data.isModified ? (openBlock(), createElementBlock("span", _hoisted_3, "*")) : createCommentVNode("", true)
                    ]),
                    actions: withCtx(({ node: node22 }) => [
                      createVNode(unref(script$M), {
                        icon: "pi pi-times",
                        text: "",
                        severity: unref(workspaceStore).shiftDown ? "danger" : "secondary",
                        size: "small",
                        onClick: withModifiers(($event) => handleCloseWorkflow(node22.data), ["stop"])
                      }, null, 8, ["severity", "onClick"])
                    ]),
                    _: 2
                  }, 1032, ["node"])
                ]),
                _: 1
              }, 8, ["roots", "selectionKeys"])
            ])) : createCommentVNode("", true),
            withDirectives(createBaseVNode("div", _hoisted_4, [
              createVNode(_sfc_main$4, {
                text: "Bookmarks",
                type: "dashed",
                class: "ml-2"
              }),
              createVNode(TreeExplorer, {
                roots: renderTreeNode(
                  bookmarkedWorkflowsTree.value,
                  "Bookmarks"
                  /* Bookmarks */
                ).children
              }, {
                node: withCtx(({ node: node3 }) => [
                  createVNode(_sfc_main$5, { node: node3 }, null, 8, ["node"])
                ]),
                _: 1
              }, 8, ["roots"])
            ], 512), [
              [vShow, unref(workflowStore).bookmarkedWorkflows.length > 0]
            ]),
            createBaseVNode("div", _hoisted_5, [
              createVNode(_sfc_main$4, {
                text: "Browse",
                type: "dashed",
                class: "ml-2"
              }),
              createVNode(TreeExplorer, {
                roots: renderTreeNode(
                  workflowsTree.value,
                  "Browse"
                  /* Browse */
                ).children,
                expandedKeys: expandedKeys2.value,
                "onUpdate:expandedKeys": _cache[4] || (_cache[4] = ($event) => expandedKeys2.value = $event)
              }, {
                node: withCtx(({ node: node3 }) => [
                  createVNode(_sfc_main$5, { node: node3 }, null, 8, ["node"])
                ]),
                _: 1
              }, 8, ["roots", "expandedKeys"])
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_6, [
            createVNode(TreeExplorer, {
              roots: renderTreeNode(
                filteredRoot.value,
                "Browse"
                /* Browse */
              ).children,
              expandedKeys: expandedKeys2.value,
              "onUpdate:expandedKeys": _cache[5] || (_cache[5] = ($event) => expandedKeys2.value = $event)
            }, {
              node: withCtx(({ node: node3 }) => [
                createVNode(_sfc_main$5, { node: node3 }, null, 8, ["node"])
              ]),
              _: 1
            }, 8, ["roots", "expandedKeys"])
          ]))
        ]),
        _: 1
      }, 8, ["title"]);
    };
  }
});
const useWorkflowsSidebarTab = /* @__PURE__ */ __name(() => {
  const { t } = useI18n();
  const settingStore = useSettingStore();
  const workflowStore = useWorkflowStore();
  return {
    id: "workflows",
    icon: "pi pi-folder-open",
    iconBadge: /* @__PURE__ */ __name(() => {
      if (settingStore.get("Comfy.Workflow.WorkflowTabsPosition") !== "Sidebar") {
        return null;
      }
      const value3 = workflowStore.openWorkflows.length.toString();
      return value3 === "0" ? null : value3;
    }, "iconBadge"),
    title: t("sideToolbar.workflows"),
    tooltip: t("sideToolbar.workflows"),
    component: markRaw(_sfc_main$3),
    type: "vue"
  };
}, "useWorkflowsSidebarTab");
const useSidebarTabStore = /* @__PURE__ */ defineStore("sidebarTab", () => {
  const sidebarTabs = ref([]);
  const activeSidebarTabId = ref(null);
  const activeSidebarTab = computed(() => {
    return sidebarTabs.value.find((tab) => tab.id === activeSidebarTabId.value) ?? null;
  });
  const toggleSidebarTab = /* @__PURE__ */ __name((tabId) => {
    activeSidebarTabId.value = activeSidebarTabId.value === tabId ? null : tabId;
  }, "toggleSidebarTab");
  const registerSidebarTab = /* @__PURE__ */ __name((tab) => {
    sidebarTabs.value = [...sidebarTabs.value, tab];
    useCommandStore().registerCommand({
      id: `Workspace.ToggleSidebarTab.${tab.id}`,
      icon: tab.icon,
      label: tab.tooltip,
      tooltip: tab.tooltip,
      versionAdded: "1.3.9",
      function: /* @__PURE__ */ __name(() => {
        toggleSidebarTab(tab.id);
      }, "function")
    });
  }, "registerSidebarTab");
  const unregisterSidebarTab = /* @__PURE__ */ __name((id3) => {
    const index2 = sidebarTabs.value.findIndex((tab) => tab.id === id3);
    if (index2 !== -1) {
      const tab = sidebarTabs.value[index2];
      if (tab.type === "custom" && tab.destroy) {
        tab.destroy();
      }
      const newSidebarTabs = [...sidebarTabs.value];
      newSidebarTabs.splice(index2, 1);
      sidebarTabs.value = newSidebarTabs;
    }
  }, "unregisterSidebarTab");
  const registerCoreSidebarTabs = /* @__PURE__ */ __name(() => {
    registerSidebarTab(useQueueSidebarTab());
    registerSidebarTab(useNodeLibrarySidebarTab());
    registerSidebarTab(useModelLibrarySidebarTab());
    registerSidebarTab(useWorkflowsSidebarTab());
  }, "registerCoreSidebarTabs");
  return {
    sidebarTabs,
    activeSidebarTabId,
    activeSidebarTab,
    toggleSidebarTab,
    registerSidebarTab,
    unregisterSidebarTab,
    registerCoreSidebarTabs
  };
});
const useWorkspaceStore = /* @__PURE__ */ defineStore("workspace", () => {
  const spinner = ref(false);
  const shiftDown = ref(false);
  const focusMode = ref(false);
  const toast = computed(() => useToastStore());
  const queueSettings = computed(() => useQueueSettingsStore());
  const command = computed(() => ({
    execute: useCommandStore().execute
  }));
  const sidebarTab = computed(() => useSidebarTabStore());
  const setting = computed(() => ({
    get: useSettingStore().get,
    set: useSettingStore().set
  }));
  const workflow = computed(() => useWorkflowStore());
  function registerSidebarTab(tab) {
    sidebarTab.value.registerSidebarTab(tab);
  }
  __name(registerSidebarTab, "registerSidebarTab");
  function unregisterSidebarTab(id3) {
    sidebarTab.value.unregisterSidebarTab(id3);
  }
  __name(unregisterSidebarTab, "unregisterSidebarTab");
  function getSidebarTabs() {
    return sidebarTab.value.sidebarTabs;
  }
  __name(getSidebarTabs, "getSidebarTabs");
  return {
    spinner,
    shiftDown,
    focusMode,
    toggleFocusMode: /* @__PURE__ */ __name(() => {
      focusMode.value = !focusMode.value;
    }, "toggleFocusMode"),
    toast,
    queueSettings,
    command,
    sidebarTab,
    setting,
    workflow,
    registerSidebarTab,
    unregisterSidebarTab,
    getSidebarTabs
  };
});
var theme$1 = /* @__PURE__ */ __name(function theme36(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-blockui {\n    position: relative;\n}\n\n.p-blockui-mask {\n    border-radius: ".concat(dt2("blockui.border.radius"), ";\n}\n\n.p-blockui-mask.p-overlay-mask {\n    position: absolute;\n}\n\n.p-blockui-mask-document.p-overlay-mask {\n    position: fixed;\n}\n");
}, "theme");
var classes$1 = {
  root: "p-blockui"
};
var BlockUIStyle = BaseStyle.extend({
  name: "blockui",
  theme: theme$1,
  classes: classes$1
});
var script$1 = {
  name: "BaseBlockUI",
  "extends": script$Y,
  props: {
    blocked: {
      type: Boolean,
      "default": false
    },
    fullScreen: {
      type: Boolean,
      "default": false
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    }
  },
  style: BlockUIStyle,
  provide: /* @__PURE__ */ __name(function provide39() {
    return {
      $pcBlockUI: this,
      $parentInstance: this
    };
  }, "provide")
};
var script = {
  name: "BlockUI",
  "extends": script$1,
  inheritAttrs: false,
  emits: ["block", "unblock"],
  mask: null,
  data: /* @__PURE__ */ __name(function data21() {
    return {
      isBlocked: false
    };
  }, "data"),
  watch: {
    blocked: /* @__PURE__ */ __name(function blocked(newValue) {
      if (newValue === true) this.block();
      else this.unblock();
    }, "blocked")
  },
  mounted: /* @__PURE__ */ __name(function mounted20() {
    if (this.blocked) {
      this.block();
    }
  }, "mounted"),
  methods: {
    block: /* @__PURE__ */ __name(function block() {
      var styleClass = "p-blockui-mask p-overlay-mask p-overlay-mask-enter";
      if (this.fullScreen) {
        styleClass += " p-blockui-mask-document";
        this.mask = createElement("div", {
          style: {
            position: "fixed",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          },
          "class": !this.isUnstyled && styleClass,
          "p-bind": this.ptm("mask")
        });
        document.body.appendChild(this.mask);
        blockBodyScroll();
        document.activeElement.blur();
      } else {
        this.mask = createElement("div", {
          style: {
            position: "absolute",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          },
          "class": !this.isUnstyled && styleClass,
          "p-bind": this.ptm("mask")
        });
        this.$refs.container.appendChild(this.mask);
      }
      if (this.autoZIndex) {
        ZIndex.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
      }
      this.isBlocked = true;
      this.$emit("block");
    }, "block"),
    unblock: /* @__PURE__ */ __name(function unblock() {
      var _this = this;
      !this.isUnstyled && addClass(this.mask, "p-overlay-mask-leave");
      if (hasCSSAnimation(this.mask) > 0) {
        this.mask.addEventListener("animationend", function() {
          _this.removeMask();
        });
      } else {
        this.removeMask();
      }
    }, "unblock"),
    removeMask: /* @__PURE__ */ __name(function removeMask() {
      ZIndex.clear(this.mask);
      if (this.fullScreen) {
        document.body.removeChild(this.mask);
        unblockBodyScroll();
      } else {
        var _this$$refs$container;
        (_this$$refs$container = this.$refs.container) === null || _this$$refs$container === void 0 || _this$$refs$container.removeChild(this.mask);
      }
      this.isBlocked = false;
      this.$emit("unblock");
    }, "removeMask")
  }
};
var _hoisted_1$1 = ["aria-busy"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root"),
    "aria-busy": $data.isBlocked
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16, _hoisted_1$1);
}
__name(render, "render");
script.render = render;
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "GlobalDialog",
  setup(__props) {
    const dialogStore = useDialogStore();
    const maximizable = computed(
      () => dialogStore.dialogComponentProps.maximizable ?? false
    );
    const maximized = ref(false);
    const onMaximize = /* @__PURE__ */ __name(() => {
      maximized.value = true;
    }, "onMaximize");
    const onUnmaximize = /* @__PURE__ */ __name(() => {
      maximized.value = false;
    }, "onUnmaximize");
    const contentProps = computed(
      () => maximizable.value ? {
        ...dialogStore.props,
        maximized: maximized.value
      } : dialogStore.props
    );
    const headerId = `dialog-${Math.random().toString(36).substr(2, 9)}`;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$b), {
        visible: unref(dialogStore).isVisible,
        "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => unref(dialogStore).isVisible = $event),
        class: "global-dialog",
        modal: "",
        closable: "",
        closeOnEscape: "",
        dismissableMask: "",
        maximizable: maximizable.value,
        maximized: maximized.value,
        onHide: unref(dialogStore).closeDialog,
        onMaximize,
        onUnmaximize,
        "aria-labelledby": headerId
      }, {
        header: withCtx(() => [
          unref(dialogStore).headerComponent ? (openBlock(), createBlock(resolveDynamicComponent(unref(dialogStore).headerComponent), {
            key: 0,
            id: headerId
          })) : (openBlock(), createElementBlock("h3", {
            key: 1,
            id: headerId
          }, toDisplayString$1(unref(dialogStore).title || " "), 1))
        ]),
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(unref(dialogStore).component), normalizeProps(guardReactiveProps(contentProps.value)), null, 16))
        ]),
        _: 1
      }, 8, ["visible", "maximizable", "maximized", "onHide"]);
    };
  }
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const workspaceStore = useWorkspaceStore();
    const isLoading = computed(() => workspaceStore.spinner);
    const handleKey = /* @__PURE__ */ __name((e) => {
      workspaceStore.shiftDown = e.shiftKey;
    }, "handleKey");
    useEventListener(window, "keydown", handleKey);
    useEventListener(window, "keyup", handleKey);
    onMounted(() => {
      window["__COMFYUI_FRONTEND_VERSION__"] = config.app_version;
      console.log("ComfyUI Front-end version:", config.app_version);
    });
    return (_ctx, _cache) => {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_router_view),
        isLoading.value ? (openBlock(), createBlock(unref(script$s), {
          key: 0,
          class: "absolute inset-0 flex justify-center items-center h-screen"
        })) : createCommentVNode("", true),
        createVNode(_sfc_main$2),
        createVNode(unref(script), {
          "full-screen": "",
          blocked: isLoading.value
        }, null, 8, ["blocked"])
      ], 64);
    };
  }
});
/*!
  * vue-router v4.4.3
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof document !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
__name(isESModule, "isESModule");
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value3 = params[key];
    newParams[key] = isArray(value3) ? value3.map(fn) : fn(value3);
  }
  return newParams;
}
__name(applyToParams, "applyToParams");
const noop = /* @__PURE__ */ __name(() => {
}, "noop");
const isArray = Array.isArray;
function warn(msg) {
  const args = Array.from(arguments).slice(1);
  console.warn.apply(console, ["[Vue Router warn]: " + msg].concat(args));
}
__name(warn, "warn");
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
__name(commonEncode, "commonEncode");
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
__name(encodeHash, "encodeHash");
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
__name(encodeQueryValue, "encodeQueryValue");
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
__name(encodeQueryKey, "encodeQueryKey");
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
__name(encodePath, "encodePath");
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
__name(encodeParam, "encodeParam");
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
__name(decode, "decode");
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = /* @__PURE__ */ __name((path) => path.replace(TRAILING_SLASH_RE, ""), "removeTrailingSlash");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash: decode(hash)
  };
}
__name(parseURL, "parseURL");
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
__name(stringifyURL, "stringifyURL");
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
__name(stripBase, "stripBase");
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
__name(isSameRouteLocation, "isSameRouteLocation");
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
__name(isSameRouteRecord, "isSameRouteRecord");
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
__name(isSameRouteLocationParams, "isSameRouteLocationParams");
function isSameRouteLocationParamsValue(a, b) {
  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
}
__name(isSameRouteLocationParamsValue, "isSameRouteLocationParamsValue");
function isEquivalentArray(a, b) {
  return isArray(b) ? a.length === b.length && a.every((value3, i2) => value3 === b[i2]) : a.length === 1 && a[0] === b;
}
__name(isEquivalentArray, "isEquivalentArray");
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (false) {
    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`);
    return to;
  }
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position2 = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position2 > 1)
        position2--;
    } else
      break;
  }
  return fromSegments.slice(0, position2).join("/") + "/" + toSegments.slice(toPosition).join("/");
}
__name(resolveRelativePath, "resolveRelativePath");
const START_LOCATION_NORMALIZED = {
  path: "/",
  // TODO: could we use a symbol in the future?
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
const START = "";
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
__name(normalizeBase, "normalizeBase");
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
__name(createHref, "createHref");
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
__name(getElementPosition, "getElementPosition");
const computeScrollPosition = /* @__PURE__ */ __name(() => ({
  left: window.scrollX,
  top: window.scrollY
}), "computeScrollPosition");
function scrollToPosition(position2) {
  let scrollToOptions;
  if ("el" in position2) {
    const positionEl = position2.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    if (false) {
      if (!isIdSelector || !document.getElementById(position2.el.slice(1))) {
        try {
          const foundEl = document.querySelector(position2.el);
          if (isIdSelector && foundEl) {
            warn(`The selector "${position2.el}" should be passed as "el: document.querySelector('${position2.el}')" because it starts with "#".`);
            return;
          }
        } catch (err) {
          warn(`The selector "${position2.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
          return;
        }
      }
    }
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position2);
  } else {
    scrollToOptions = position2;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
  }
}
__name(scrollToPosition, "scrollToPosition");
function getScrollKey(path, delta2) {
  const position2 = history.state ? history.state.position - delta2 : -1;
  return position2 + path;
}
__name(getScrollKey, "getScrollKey");
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
__name(saveScrollPosition, "saveScrollPosition");
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
__name(getSavedScrollPosition, "getSavedScrollPosition");
let createBaseLocation = /* @__PURE__ */ __name(() => location.protocol + "//" + location.host, "createBaseLocation");
function createCurrentLocation(base, location2) {
  const { pathname, search: search2, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search2 + hash;
}
__name(createCurrentLocation, "createCurrentLocation");
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = /* @__PURE__ */ __name(({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta2 = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta2 = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta: delta2,
        type: NavigationType.pop,
        direction: delta2 ? delta2 > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  }, "popStateHandler");
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  __name(pauseListeners, "pauseListeners");
  function listen(callback) {
    listeners.push(callback);
    const teardown = /* @__PURE__ */ __name(() => {
      const index2 = listeners.indexOf(callback);
      if (index2 > -1)
        listeners.splice(index2, 1);
    }, "teardown");
    teardowns.push(teardown);
    return teardown;
  }
  __name(listen, "listen");
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  __name(beforeUnloadListener, "beforeUnloadListener");
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  __name(destroy, "destroy");
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen,
    destroy
  };
}
__name(useHistoryListeners, "useHistoryListeners");
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
__name(buildState, "buildState");
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      if (false) {
        warn("Error with push/replace State", err);
      } else {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  __name(changeLocation, "changeLocation");
  function replace(to, data22) {
    const state = assign({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data22, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  __name(replace, "replace");
  function push(to, data22) {
    const currentState = assign(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    if (false) {
      warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://router.vuejs.org/guide/migration/#Usage-of-history-state`);
    }
    changeLocation(currentState.current, currentState, true);
    const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data22);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  __name(push, "push");
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
__name(useHistoryStateNavigation, "useHistoryStateNavigation");
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta2, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta2);
  }
  __name(go, "go");
  const routerHistory = assign({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: /* @__PURE__ */ __name(() => historyNavigation.location.value, "get")
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: /* @__PURE__ */ __name(() => historyNavigation.state.value, "get")
  });
  return routerHistory;
}
__name(createWebHistory, "createWebHistory");
function createMemoryHistory(base = "") {
  let listeners = [];
  let queue2 = [START];
  let position2 = 0;
  base = normalizeBase(base);
  function setLocation(location2) {
    position2++;
    if (position2 !== queue2.length) {
      queue2.splice(position2);
    }
    queue2.push(location2);
  }
  __name(setLocation, "setLocation");
  function triggerListeners(to, from, { direction, delta: delta2 }) {
    const info = {
      direction,
      delta: delta2,
      type: NavigationType.pop
    };
    for (const callback of listeners) {
      callback(to, from, info);
    }
  }
  __name(triggerListeners, "triggerListeners");
  const routerHistory = {
    // rewritten by Object.defineProperty
    location: START,
    // TODO: should be kept in queue
    state: {},
    base,
    createHref: createHref.bind(null, base),
    replace(to) {
      queue2.splice(position2--, 1);
      setLocation(to);
    },
    push(to, data22) {
      setLocation(to);
    },
    listen(callback) {
      listeners.push(callback);
      return () => {
        const index2 = listeners.indexOf(callback);
        if (index2 > -1)
          listeners.splice(index2, 1);
      };
    },
    destroy() {
      listeners = [];
      queue2 = [START];
      position2 = 0;
    },
    go(delta2, shouldTrigger = true) {
      const from = this.location;
      const direction = (
        // we are considering delta === 0 going forward, but in abstract mode
        // using 0 for the delta doesn't make sense like it does in html5 where
        // it reloads the page
        delta2 < 0 ? NavigationDirection.back : NavigationDirection.forward
      );
      position2 = Math.max(0, Math.min(position2 + delta2, queue2.length - 1));
      if (shouldTrigger) {
        triggerListeners(this.location, from, {
          direction,
          delta: delta2
        });
      }
    }
  };
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: /* @__PURE__ */ __name(() => queue2[position2], "get")
  });
  return routerHistory;
}
__name(createMemoryHistory, "createMemoryHistory");
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  if (false) {
    warn(`A hash base must end with a "#":
"${base}" should be "${base.replace(/#.*$/, "#")}".`);
  }
  return createWebHistory(base);
}
__name(createWebHashHistory, "createWebHashHistory");
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
__name(isRouteLocation, "isRouteLocation");
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
__name(isRouteName, "isRouteName");
const NavigationFailureSymbol = Symbol(false ? "navigation failure" : "");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
const ErrorTypeMessages = {
  [
    1
    /* ErrorTypes.MATCHER_NOT_FOUND */
  ]({ location: location2, currentLocation }) {
    return `No match for
 ${JSON.stringify(location2)}${currentLocation ? "\nwhile being at\n" + JSON.stringify(currentLocation) : ""}`;
  },
  [
    2
    /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
  ]({ from, to }) {
    return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
  },
  [
    4
    /* ErrorTypes.NAVIGATION_ABORTED */
  ]({ from, to }) {
    return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
  },
  [
    8
    /* ErrorTypes.NAVIGATION_CANCELLED */
  ]({ from, to }) {
    return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
  },
  [
    16
    /* ErrorTypes.NAVIGATION_DUPLICATED */
  ]({ from, to }) {
    return `Avoided redundant navigation to current location: "${from.fullPath}".`;
  }
};
function createRouterError(type, params) {
  if (false) {
    return assign(new Error(ErrorTypeMessages[type](params)), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  } else {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
__name(createRouterError, "createRouterError");
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
__name(isNavigationFailure, "isNavigationFailure");
const propertiesToLog = ["params", "query", "hash"];
function stringifyRoute(to) {
  if (typeof to === "string")
    return to;
  if (to.path != null)
    return to.path;
  const location2 = {};
  for (const key of propertiesToLog) {
    if (key in to)
      location2[key] = to[key];
  }
  return JSON.stringify(location2, null, 2);
}
__name(stringifyRoute, "stringifyRoute");
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options3 = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options3.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options3.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options3.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value: value3, repeatable, optional, regexp } = token;
        keys2.push({
          name: value3,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value3}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options3.strict && options3.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options3.strict)
    pattern += "/?";
  if (options3.end)
    pattern += "$";
  else if (options3.strict)
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options3.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i2 = 1; i2 < match.length; i2++) {
      const value3 = match[i2] || "";
      const key = keys2[i2 - 1];
      params[key.name] = value3 && key.repeatable ? value3.split("/") : value3;
    }
    return params;
  }
  __name(parse2, "parse");
  function stringify2(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value: value3, repeatable, optional } = token;
          const param = value3 in params ? params[value3] : "";
          if (isArray(param) && !repeatable) {
            throw new Error(`Provided param "${value3}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value3}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  __name(stringify2, "stringify");
  return {
    re,
    score,
    keys: keys2,
    parse: parse2,
    stringify: stringify2
  };
}
__name(tokensToParser, "tokensToParser");
function compareScoreArray(a, b) {
  let i2 = 0;
  while (i2 < a.length && i2 < b.length) {
    const diff2 = b[i2] - a[i2];
    if (diff2)
      return diff2;
    i2++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
__name(compareScoreArray, "compareScoreArray");
function comparePathParserScore(a, b) {
  let i2 = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp)
      return comp;
    i2++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
__name(comparePathParserScore, "comparePathParserScore");
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
__name(isLastScoreNegative, "isLastScoreNegative");
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(false ? `Route paths should start with a "/": "${path}" should be "/${path}".` : `Invalid path "${path}"`);
  }
  function crash(message2) {
    throw new Error(`ERR (${state})/"${buffer2}": ${message2}`);
  }
  __name(crash, "crash");
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  __name(finalizeSegment, "finalizeSegment");
  let i2 = 0;
  let char;
  let buffer2 = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer2)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer2
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer2,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer2 = "";
  }
  __name(consumeBuffer, "consumeBuffer");
  function addCharToBuffer() {
    buffer2 += char;
  }
  __name(addCharToBuffer, "addCharToBuffer");
  while (i2 < path.length) {
    char = path[i2++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer2) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer2}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
__name(tokenizePath, "tokenizePath");
function createRouteRecordMatcher(record, parent, options3) {
  const parser = tokensToParser(tokenizePath(record.path), options3);
  if (false) {
    const existingKeys = /* @__PURE__ */ new Set();
    for (const key of parser.keys) {
      if (existingKeys.has(key.name))
        warn(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
      existingKeys.add(key.name);
    }
  }
  const matcher = assign(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
__name(createRouteRecordMatcher, "createRouteRecordMatcher");
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  __name(getRecordMatcher, "getRecordMatcher");
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    if (false) {
      checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);
    }
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options3 = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      if (false) {
        throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\nSee more at https://router.vuejs.org/guide/migration/#Removed-star-or-catch-all-routes.');
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options3);
      if (false)
        checkMissingParamsInAbsolutePath(matcher, parent);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
        if (false) {
          checkSameParams(originalRecord, matcher);
        }
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (isMatchable(matcher)) {
        insertMatcher(matcher);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher;
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  __name(addRoute, "addRoute");
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index2 = matchers.indexOf(matcherRef);
      if (index2 > -1) {
        matchers.splice(index2, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  __name(removeRoute, "removeRoute");
  function getRoutes() {
    return matchers;
  }
  __name(getRoutes, "getRoutes");
  function insertMatcher(matcher) {
    const index2 = findInsertionIndex(matcher, matchers);
    matchers.splice(index2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  __name(insertMatcher, "insertMatcher");
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      if (false) {
        const invalidParams = Object.keys(location2.params || {}).filter((paramName) => !matcher.keys.find((k) => k.name === paramName));
        if (invalidParams.length) {
          warn(`Discarded invalid param(s) "${invalidParams.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
        }
      }
      name = matcher.record.name;
      params = assign(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // only keep optional params coming from a parent record
          matcher.keys.filter((k) => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k) => k.optional) : []).map((k) => k.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
      );
      path = matcher.stringify(params);
    } else if (location2.path != null) {
      path = location2.path;
      if (false) {
        warn(`The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`);
      }
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  __name(resolve2, "resolve");
  routes.forEach((route) => addRoute(route));
  function clearRoutes() {
    matchers.length = 0;
    matcherMap.clear();
  }
  __name(clearRoutes, "clearRoutes");
  return {
    addRoute,
    resolve: resolve2,
    removeRoute,
    clearRoutes,
    getRoutes,
    getRecordMatcher
  };
}
__name(createRouterMatcher, "createRouterMatcher");
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key of keys2) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
__name(paramsFromLocation, "paramsFromLocation");
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
__name(normalizeRouteRecord, "normalizeRouteRecord");
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "object" ? props[name] : props;
  }
  return propsObject;
}
__name(normalizeRecordProps, "normalizeRecordProps");
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
__name(isAliasRecord, "isAliasRecord");
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
__name(mergeMetaFields, "mergeMetaFields");
function mergeOptions(defaults2, partialOptions) {
  const options3 = {};
  for (const key in defaults2) {
    options3[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
  }
  return options3;
}
__name(mergeOptions, "mergeOptions");
function isSameParam(a, b) {
  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;
}
__name(isSameParam, "isSameParam");
function checkSameParams(a, b) {
  for (const key of a.keys) {
    if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))
      return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);
  }
  for (const key of b.keys) {
    if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))
      return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);
  }
}
__name(checkSameParams, "checkSameParams");
function checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {
  if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) {
    warn(`The route named "${String(parent.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
  }
}
__name(checkChildMissingNameWithEmptyPath, "checkChildMissingNameWithEmptyPath");
function checkMissingParamsInAbsolutePath(record, parent) {
  for (const key of parent.keys) {
    if (!record.keys.find(isSameParam.bind(null, key)))
      return warn(`Absolute path "${record.record.path}" must have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
  }
}
__name(checkMissingParamsInAbsolutePath, "checkMissingParamsInAbsolutePath");
function findInsertionIndex(matcher, matchers) {
  let lower = 0;
  let upper = matchers.length;
  while (lower !== upper) {
    const mid = lower + upper >> 1;
    const sortOrder = comparePathParserScore(matcher, matchers[mid]);
    if (sortOrder < 0) {
      upper = mid;
    } else {
      lower = mid + 1;
    }
  }
  const insertionAncestor = getInsertionAncestor(matcher);
  if (insertionAncestor) {
    upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
    if (false) {
      warn(`Finding ancestor route "${insertionAncestor.record.path}" failed for "${matcher.record.path}"`);
    }
  }
  return upper;
}
__name(findInsertionIndex, "findInsertionIndex");
function getInsertionAncestor(matcher) {
  let ancestor = matcher;
  while (ancestor = ancestor.parent) {
    if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
      return ancestor;
    }
  }
  return;
}
__name(getInsertionAncestor, "getInsertionAncestor");
function isMatchable({ record }) {
  return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
}
__name(isMatchable, "isMatchable");
function parseQuery(search2) {
  const query = {};
  if (search2 === "" || search2 === "?")
    return query;
  const hasLeadingIM = search2[0] === "?";
  const searchParams = (hasLeadingIM ? search2.slice(1) : search2).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value3 = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value3);
    } else {
      query[key] = value3;
    }
  }
  return query;
}
__name(parseQuery, "parseQuery");
function stringifyQuery(query) {
  let search2 = "";
  for (let key in query) {
    const value3 = query[key];
    key = encodeQueryKey(key);
    if (value3 == null) {
      if (value3 !== void 0) {
        search2 += (search2.length ? "&" : "") + key;
      }
      continue;
    }
    const values2 = isArray(value3) ? value3.map((v2) => v2 && encodeQueryValue(v2)) : [value3 && encodeQueryValue(value3)];
    values2.forEach((value22) => {
      if (value22 !== void 0) {
        search2 += (search2.length ? "&" : "") + key;
        if (value22 != null)
          search2 += "=" + value22;
      }
    });
  }
  return search2;
}
__name(stringifyQuery, "stringifyQuery");
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value3 = query[key];
    if (value3 !== void 0) {
      normalizedQuery[key] = isArray(value3) ? value3.map((v2) => v2 == null ? null : "" + v2) : value3 == null ? value3 : "" + value3;
    }
  }
  return normalizedQuery;
}
__name(normalizeQuery, "normalizeQuery");
const matchedRouteKey = Symbol(false ? "router view location matched" : "");
const viewDepthKey = Symbol(false ? "router view depth" : "");
const routerKey = Symbol(false ? "router" : "");
const routeLocationKey = Symbol(false ? "route location" : "");
const routerViewLocationKey = Symbol(false ? "router view location" : "");
function useCallbacks() {
  let handlers2 = [];
  function add2(handler6) {
    handlers2.push(handler6);
    return () => {
      const i2 = handlers2.indexOf(handler6);
      if (i2 > -1)
        handlers2.splice(i2, 1);
    };
  }
  __name(add2, "add");
  function reset() {
    handlers2 = [];
  }
  __name(reset, "reset");
  return {
    add: add2,
    list: /* @__PURE__ */ __name(() => handlers2.slice(), "list"),
    reset
  };
}
__name(useCallbacks, "useCallbacks");
function registerGuard(record, name, guard) {
  const removeFromList = /* @__PURE__ */ __name(() => {
    record[name].delete(guard);
  }, "removeFromList");
  onUnmounted(removeFromList);
  onDeactivated(removeFromList);
  onActivated(() => {
    record[name].add(guard);
  });
  record[name].add(guard);
}
__name(registerGuard, "registerGuard");
function onBeforeRouteLeave(leaveGuard) {
  if (false) {
    warn("getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function");
    return;
  }
  const activeRecord = inject(
    matchedRouteKey,
    // to avoid warning
    {}
  ).value;
  if (!activeRecord) {
    return;
  }
  registerGuard(activeRecord, "leaveGuards", leaveGuard);
}
__name(onBeforeRouteLeave, "onBeforeRouteLeave");
function onBeforeRouteUpdate(updateGuard) {
  if (false) {
    warn("getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function");
    return;
  }
  const activeRecord = inject(
    matchedRouteKey,
    // to avoid warning
    {}
  ).value;
  if (!activeRecord) {
    return;
  }
  registerGuard(activeRecord, "updateGuards", updateGuard);
}
__name(onBeforeRouteUpdate, "onBeforeRouteUpdate");
function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn) => fn()) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject2) => {
    const next2 = /* @__PURE__ */ __name((valid) => {
      if (valid === false) {
        reject2(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject2(valid);
      } else if (isRouteLocation(valid)) {
        reject2(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    }, "next");
    const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, false ? canOnlyBeCalledOnce(next2, to, from) : next2));
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next2);
    if (false) {
      const message2 = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ""}:
${guard.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
      if (typeof guardReturn === "object" && "then" in guardReturn) {
        guardCall = guardCall.then((resolvedValue) => {
          if (!next2._called) {
            warn(message2);
            return Promise.reject(new Error("Invalid navigation guard"));
          }
          return resolvedValue;
        });
      } else if (guardReturn !== void 0) {
        if (!next2._called) {
          warn(message2);
          reject2(new Error("Invalid navigation guard"));
          return;
        }
      }
    }
    guardCall.catch((err) => reject2(err));
  });
}
__name(guardToPromiseFn, "guardToPromiseFn");
function canOnlyBeCalledOnce(next2, to, from) {
  let called = 0;
  return function() {
    if (called++ === 1)
      warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
    next2._called = true;
    if (called === 1)
      next2.apply(null, arguments);
  };
}
__name(canOnlyBeCalledOnce, "canOnlyBeCalledOnce");
function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn) => fn()) {
  const guards = [];
  for (const record of matched) {
    if (false) {
      warn(`Record with path "${record.path}" is either missing a "component(s)" or "children" property.`);
    }
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (false) {
        if (!rawComponent || typeof rawComponent !== "object" && typeof rawComponent !== "function") {
          warn(`Component "${name}" in record with path "${record.path}" is not a valid component. Received "${String(rawComponent)}".`);
          throw new Error("Invalid route component");
        } else if ("then" in rawComponent) {
          warn(`Component "${name}" in record with path "${record.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
          const promise = rawComponent;
          rawComponent = /* @__PURE__ */ __name(() => promise, "rawComponent");
        } else if (rawComponent.__asyncLoader && // warn only once per component
        !rawComponent.__warnedDefineAsync) {
          rawComponent.__warnedDefineAsync = true;
          warn(`Component "${name}" in record with path "${record.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`);
        }
      }
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options3 = rawComponent.__vccOpts || rawComponent;
        const guard = options3[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
      } else {
        let componentPromise = rawComponent();
        if (false) {
          warn(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
          componentPromise = Promise.resolve(componentPromise);
        }
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options3 = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options3[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
        }));
      }
    }
  }
  return guards;
}
__name(extractComponentsGuards, "extractComponentsGuards");
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
__name(isRouteComponent, "isRouteComponent");
function loadRouteLocation(route) {
  return route.matched.every((record) => record.redirect) ? Promise.reject(new Error("Cannot load a route that redirects.")) : Promise.all(route.matched.map((record) => record.components && Promise.all(Object.keys(record.components).reduce((promises, name) => {
    const rawComponent = record.components[name];
    if (typeof rawComponent === "function" && !("displayName" in rawComponent)) {
      promises.push(rawComponent().then((resolved) => {
        if (!resolved)
          return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}". Ensure you passed a function that returns a promise.`));
        const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
        record.components[name] = resolvedComponent;
        return;
      }));
    }
    return promises;
  }, [])))).then(() => route);
}
__name(loadRouteLocation, "loadRouteLocation");
function useLink(props) {
  const router2 = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  let hasPrevious = false;
  let previousTo = null;
  const route = computed(() => {
    const to = unref(props.to);
    if (false) {
      if (!isRouteLocation(to)) {
        if (hasPrevious) {
          warn(`Invalid value for prop "to" in useLink()
- to:`, to, `
- previous to:`, previousTo, `
- props:`, props);
        } else {
          warn(`Invalid value for prop "to" in useLink()
- to:`, to, `
- props:`, props);
        }
      }
      previousTo = to;
      hasPrevious = true;
    }
    return router2.resolve(to);
  });
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index2 > -1)
      return index2;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router2[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop);
    }
    return Promise.resolve();
  }
  __name(navigate, "navigate");
  if (false) {
    const instance = getCurrentInstance();
    if (instance) {
      const linkContextDevtools = {
        route: route.value,
        isActive: isActive.value,
        isExactActive: isExactActive.value,
        error: null
      };
      instance.__vrl_devtools = instance.__vrl_devtools || [];
      instance.__vrl_devtools.push(linkContextDevtools);
      watchEffect(() => {
        linkContextDevtools.route = route.value;
        linkContextDevtools.isActive = isActive.value;
        linkContextDevtools.isExactActive = isExactActive.value;
        linkContextDevtools.error = isRouteLocation(unref(props.to)) ? null : 'Invalid "to" value';
      }, { flush: "post" });
    }
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
__name(useLink, "useLink");
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options: options3 } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options3.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options3.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
__name(guardEvent, "guardEvent");
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value3, i2) => value3 !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
__name(includesParams, "includesParams");
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
__name(getOriginalPath, "getOriginalPath");
const getLinkClass = /* @__PURE__ */ __name((propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass, "getLinkClass");
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props, { attrs: attrs3, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = /* @__PURE__ */ __name((vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      }, "onVnodeUnmounted");
      const component = h(ViewComponent, assign({}, routeProps, attrs3, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      if (false) {
        const info = {
          depth: depth.value,
          name: matchedRoute.name,
          path: matchedRoute.path,
          meta: matchedRoute.meta
        };
        const internalInstances = isArray(component.ref) ? component.ref.map((r) => r.i) : [component.ref.i];
        internalInstances.forEach((instance) => {
          instance.__vrv_devtools = info;
        });
      }
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data22) {
  if (!slot)
    return null;
  const slotContent = slot(data22);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
__name(normalizeSlot, "normalizeSlot");
const RouterView = RouterViewImpl;
function warnDeprecatedUsage() {
  const instance = getCurrentInstance();
  const parentName = instance.parent && instance.parent.type.name;
  const parentSubTreeType = instance.parent && instance.parent.subTree && instance.parent.subTree.type;
  if (parentName && (parentName === "KeepAlive" || parentName.includes("Transition")) && typeof parentSubTreeType === "object" && parentSubTreeType.name === "RouterView") {
    const comp = parentName === "KeepAlive" ? "keep-alive" : "transition";
    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${comp}>
    <component :is="Component" />
  </${comp}>
</router-view>`);
  }
}
__name(warnDeprecatedUsage, "warnDeprecatedUsage");
function formatRouteLocation(routeLocation, tooltip) {
  const copy = assign({}, routeLocation, {
    // remove variables that can contain vue instances
    matched: routeLocation.matched.map((matched) => omit(matched, ["instances", "children", "aliasOf"]))
  });
  return {
    _custom: {
      type: null,
      readOnly: true,
      display: routeLocation.fullPath,
      tooltip,
      value: copy
    }
  };
}
__name(formatRouteLocation, "formatRouteLocation");
function formatDisplay(display) {
  return {
    _custom: {
      display
    }
  };
}
__name(formatDisplay, "formatDisplay");
let routerId = 0;
function addDevtools(app2, router2, matcher) {
  if (router2.__hasDevtools)
    return;
  router2.__hasDevtools = true;
  const id3 = routerId++;
  setupDevtoolsPlugin({
    id: "org.vuejs.router" + (id3 ? "." + id3 : ""),
    label: "Vue Router",
    packageName: "vue-router",
    homepage: "https://router.vuejs.org",
    logo: "https://router.vuejs.org/logo.png",
    componentStateTypes: ["Routing"],
    app: app2
  }, (api2) => {
    if (typeof api2.now !== "function") {
      console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
    }
    api2.on.inspectComponent((payload, ctx) => {
      if (payload.instanceData) {
        payload.instanceData.state.push({
          type: "Routing",
          key: "$route",
          editable: false,
          value: formatRouteLocation(router2.currentRoute.value, "Current Route")
        });
      }
    });
    api2.on.visitComponentTree(({ treeNode: node3, componentInstance }) => {
      if (componentInstance.__vrv_devtools) {
        const info = componentInstance.__vrv_devtools;
        node3.tags.push({
          label: (info.name ? `${info.name.toString()}: ` : "") + info.path,
          textColor: 0,
          tooltip: "This component is rendered by &lt;router-view&gt;",
          backgroundColor: PINK_500
        });
      }
      if (isArray(componentInstance.__vrl_devtools)) {
        componentInstance.__devtoolsApi = api2;
        componentInstance.__vrl_devtools.forEach((devtoolsData) => {
          let label5 = devtoolsData.route.path;
          let backgroundColor = ORANGE_400;
          let tooltip = "";
          let textColor = 0;
          if (devtoolsData.error) {
            label5 = devtoolsData.error;
            backgroundColor = RED_100;
            textColor = RED_700;
          } else if (devtoolsData.isExactActive) {
            backgroundColor = LIME_500;
            tooltip = "This is exactly active";
          } else if (devtoolsData.isActive) {
            backgroundColor = BLUE_600;
            tooltip = "This link is active";
          }
          node3.tags.push({
            label: label5,
            textColor,
            tooltip,
            backgroundColor
          });
        });
      }
    });
    watch(router2.currentRoute, () => {
      refreshRoutesView();
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(routerInspectorId);
      api2.sendInspectorState(routerInspectorId);
    });
    const navigationsLayerId = "router:navigations:" + id3;
    api2.addTimelineLayer({
      id: navigationsLayerId,
      label: `Router${id3 ? " " + id3 : ""} Navigations`,
      color: 4237508
    });
    router2.onError((error, to) => {
      api2.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          title: "Error during Navigation",
          subtitle: to.fullPath,
          logType: "error",
          time: api2.now(),
          data: { error },
          groupId: to.meta.__navigationId
        }
      });
    });
    let navigationId = 0;
    router2.beforeEach((to, from) => {
      const data22 = {
        guard: formatDisplay("beforeEach"),
        from: formatRouteLocation(from, "Current Location during this navigation"),
        to: formatRouteLocation(to, "Target location")
      };
      Object.defineProperty(to.meta, "__navigationId", {
        value: navigationId++
      });
      api2.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          time: api2.now(),
          title: "Start of navigation",
          subtitle: to.fullPath,
          data: data22,
          groupId: to.meta.__navigationId
        }
      });
    });
    router2.afterEach((to, from, failure) => {
      const data22 = {
        guard: formatDisplay("afterEach")
      };
      if (failure) {
        data22.failure = {
          _custom: {
            type: Error,
            readOnly: true,
            display: failure ? failure.message : "",
            tooltip: "Navigation Failure",
            value: failure
          }
        };
        data22.status = formatDisplay("");
      } else {
        data22.status = formatDisplay("");
      }
      data22.from = formatRouteLocation(from, "Current Location during this navigation");
      data22.to = formatRouteLocation(to, "Target location");
      api2.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          title: "End of navigation",
          subtitle: to.fullPath,
          time: api2.now(),
          data: data22,
          logType: failure ? "warning" : "default",
          groupId: to.meta.__navigationId
        }
      });
    });
    const routerInspectorId = "router-inspector:" + id3;
    api2.addInspector({
      id: routerInspectorId,
      label: "Routes" + (id3 ? " " + id3 : ""),
      icon: "book",
      treeFilterPlaceholder: "Search routes"
    });
    function refreshRoutesView() {
      if (!activeRoutesPayload)
        return;
      const payload = activeRoutesPayload;
      let routes = matcher.getRoutes().filter((route) => !route.parent || // these routes have a parent with no component which will not appear in the view
      // therefore we still need to include them
      !route.parent.record.components);
      routes.forEach(resetMatchStateOnRouteRecord);
      if (payload.filter) {
        routes = routes.filter((route) => (
          // save matches state based on the payload
          isRouteMatching(route, payload.filter.toLowerCase())
        ));
      }
      routes.forEach((route) => markRouteRecordActive(route, router2.currentRoute.value));
      payload.rootNodes = routes.map(formatRouteRecordForInspector);
    }
    __name(refreshRoutesView, "refreshRoutesView");
    let activeRoutesPayload;
    api2.on.getInspectorTree((payload) => {
      activeRoutesPayload = payload;
      if (payload.app === app2 && payload.inspectorId === routerInspectorId) {
        refreshRoutesView();
      }
    });
    api2.on.getInspectorState((payload) => {
      if (payload.app === app2 && payload.inspectorId === routerInspectorId) {
        const routes = matcher.getRoutes();
        const route = routes.find((route2) => route2.record.__vd_id === payload.nodeId);
        if (route) {
          payload.state = {
            options: formatRouteRecordMatcherForStateInspector(route)
          };
        }
      }
    });
    api2.sendInspectorTree(routerInspectorId);
    api2.sendInspectorState(routerInspectorId);
  });
}
__name(addDevtools, "addDevtools");
function modifierForKey(key) {
  if (key.optional) {
    return key.repeatable ? "*" : "?";
  } else {
    return key.repeatable ? "+" : "";
  }
}
__name(modifierForKey, "modifierForKey");
function formatRouteRecordMatcherForStateInspector(route) {
  const { record } = route;
  const fields = [
    { editable: false, key: "path", value: record.path }
  ];
  if (record.name != null) {
    fields.push({
      editable: false,
      key: "name",
      value: record.name
    });
  }
  fields.push({ editable: false, key: "regexp", value: route.re });
  if (route.keys.length) {
    fields.push({
      editable: false,
      key: "keys",
      value: {
        _custom: {
          type: null,
          readOnly: true,
          display: route.keys.map((key) => `${key.name}${modifierForKey(key)}`).join(" "),
          tooltip: "Param keys",
          value: route.keys
        }
      }
    });
  }
  if (record.redirect != null) {
    fields.push({
      editable: false,
      key: "redirect",
      value: record.redirect
    });
  }
  if (route.alias.length) {
    fields.push({
      editable: false,
      key: "aliases",
      value: route.alias.map((alias) => alias.record.path)
    });
  }
  if (Object.keys(route.record.meta).length) {
    fields.push({
      editable: false,
      key: "meta",
      value: route.record.meta
    });
  }
  fields.push({
    key: "score",
    editable: false,
    value: {
      _custom: {
        type: null,
        readOnly: true,
        display: route.score.map((score) => score.join(", ")).join(" | "),
        tooltip: "Score used to sort routes",
        value: route.score
      }
    }
  });
  return fields;
}
__name(formatRouteRecordMatcherForStateInspector, "formatRouteRecordMatcherForStateInspector");
const PINK_500 = 15485081;
const BLUE_600 = 2450411;
const LIME_500 = 8702998;
const CYAN_400 = 2282478;
const ORANGE_400 = 16486972;
const DARK = 6710886;
const RED_100 = 16704226;
const RED_700 = 12131356;
function formatRouteRecordForInspector(route) {
  const tags = [];
  const { record } = route;
  if (record.name != null) {
    tags.push({
      label: String(record.name),
      textColor: 0,
      backgroundColor: CYAN_400
    });
  }
  if (record.aliasOf) {
    tags.push({
      label: "alias",
      textColor: 0,
      backgroundColor: ORANGE_400
    });
  }
  if (route.__vd_match) {
    tags.push({
      label: "matches",
      textColor: 0,
      backgroundColor: PINK_500
    });
  }
  if (route.__vd_exactActive) {
    tags.push({
      label: "exact",
      textColor: 0,
      backgroundColor: LIME_500
    });
  }
  if (route.__vd_active) {
    tags.push({
      label: "active",
      textColor: 0,
      backgroundColor: BLUE_600
    });
  }
  if (record.redirect) {
    tags.push({
      label: typeof record.redirect === "string" ? `redirect: ${record.redirect}` : "redirects",
      textColor: 16777215,
      backgroundColor: DARK
    });
  }
  let id3 = record.__vd_id;
  if (id3 == null) {
    id3 = String(routeRecordId++);
    record.__vd_id = id3;
  }
  return {
    id: id3,
    label: record.path,
    tags,
    children: route.children.map(formatRouteRecordForInspector)
  };
}
__name(formatRouteRecordForInspector, "formatRouteRecordForInspector");
let routeRecordId = 0;
const EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
function markRouteRecordActive(route, currentRoute) {
  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
  route.__vd_exactActive = route.__vd_active = isExactActive;
  if (!isExactActive) {
    route.__vd_active = currentRoute.matched.some((match) => isSameRouteRecord(match, route.record));
  }
  route.children.forEach((childRoute) => markRouteRecordActive(childRoute, currentRoute));
}
__name(markRouteRecordActive, "markRouteRecordActive");
function resetMatchStateOnRouteRecord(route) {
  route.__vd_match = false;
  route.children.forEach(resetMatchStateOnRouteRecord);
}
__name(resetMatchStateOnRouteRecord, "resetMatchStateOnRouteRecord");
function isRouteMatching(route, filter4) {
  const found = String(route.re).match(EXTRACT_REGEXP_RE);
  route.__vd_match = false;
  if (!found || found.length < 3) {
    return false;
  }
  const nonEndingRE = new RegExp(found[1].replace(/\$$/, ""), found[2]);
  if (nonEndingRE.test(filter4)) {
    route.children.forEach((child) => isRouteMatching(child, filter4));
    if (route.record.path !== "/" || filter4 === "/") {
      route.__vd_match = route.re.test(filter4);
      return true;
    }
    return false;
  }
  const path = route.record.path.toLowerCase();
  const decodedPath = decode(path);
  if (!filter4.startsWith("/") && (decodedPath.includes(filter4) || path.includes(filter4)))
    return true;
  if (decodedPath.startsWith(filter4) || path.startsWith(filter4))
    return true;
  if (route.record.name && String(route.record.name).includes(filter4))
    return true;
  return route.children.some((child) => isRouteMatching(child, filter4));
}
__name(isRouteMatching, "isRouteMatching");
function omit(obj, keys2) {
  const ret = {};
  for (const key in obj) {
    if (!keys2.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
__name(omit, "omit");
function createRouter(options3) {
  const matcher = createRouterMatcher(options3.routes, options3);
  const parseQuery$12 = options3.parseQuery || parseQuery;
  const stringifyQuery$1 = options3.stringifyQuery || stringifyQuery;
  const routerHistory = options3.history;
  if (false)
    throw new Error('Provide the "history" option when calling "createRouter()": https://router.vuejs.org/api/interfaces/RouterOptions.html#history');
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options3.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      if (false) {
        warn(`Parent route "${String(parentOrRoute)}" not found when adding child route`, route);
      }
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  __name(addRoute, "addRoute");
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    } else if (false) {
      warn(`Cannot remove non-existent route "${String(name)}"`);
    }
  }
  __name(removeRoute, "removeRoute");
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  __name(getRoutes, "getRoutes");
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  __name(hasRoute, "hasRoute");
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$12, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      if (false) {
        if (href2.startsWith("//"))
          warn(`Location "${rawLocation}" resolved to "${href2}". A resolved location cannot start with multiple slashes.`);
        else if (!matchedRoute2.matched.length) {
          warn(`No match found for location with path "${rawLocation}"`);
        }
      }
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    if (false) {
      warn(`router.resolve() was passed an invalid location. This will fail in production.
- Location:`, rawLocation);
      return resolve2({});
    }
    let matcherLocation;
    if (rawLocation.path != null) {
      if (false) {
        warn(`Path "${rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
      }
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$12, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    if (false) {
      warn(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
    }
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    if (false) {
      if (href.startsWith("//")) {
        warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
      } else if (!matchedRoute.matched.length) {
        warn(`No match found for location with path "${rawLocation.path != null ? rawLocation.path : rawLocation}"`);
      }
    }
    return assign({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  __name(resolve2, "resolve");
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$12, to, currentRoute.value.path) : assign({}, to);
  }
  __name(locationAsObject, "locationAsObject");
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  __name(checkCanceledNavigation, "checkCanceledNavigation");
  function push(to) {
    return pushWithRedirect(to);
  }
  __name(push, "push");
  function replace(to) {
    return push(assign(locationAsObject(to), { replace: true }));
  }
  __name(replace, "replace");
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      if (false) {
        warn(`Invalid redirect found:
${JSON.stringify(newTargetLocation, null, 2)}
 when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
        throw new Error("Invalid redirect");
      }
      return assign({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: newTargetLocation.path != null ? {} : to.params
      }, newTargetLocation);
    }
  }
  __name(handleRedirectRecord, "handleRedirectRecord");
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from = currentRoute.value;
    const data22 = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign({}, data22, shouldRedirect.state) : data22,
          force,
          replace: replace2
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          if (false) {
            warn(`Detected a possibly infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow.
 Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`);
            return Promise.reject(new Error("Infinite redirect in navigation guard"));
          }
          return pushWithRedirect(
            // keep options
            assign({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign({}, data22, failure2.to.state) : data22,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data22);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  __name(pushWithRedirect, "pushWithRedirect");
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  __name(checkCanceledNavigationAndReject, "checkCanceledNavigationAndReject");
  function runWithContext(fn) {
    const app2 = installedApps.values().next().value;
    return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
  }
  __name(runWithContext, "runWithContext");
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  __name(navigate, "navigate");
  function triggerAfterEach(to, from, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
  }
  __name(triggerAfterEach, "triggerAfterEach");
  function finalizeNavigation(toLocation, from, isPush, replace2, data22) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state && state.scroll
        }, data22));
      else
        routerHistory.push(toLocation.fullPath, data22);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  __name(finalizeNavigation, "finalizeNavigation");
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router2.listening)
        return;
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            error.to,
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  __name(setupListeners, "setupListeners");
  let readyHandlers = useCallbacks();
  let errorListeners = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorListeners.list();
    if (list.length) {
      list.forEach((handler6) => handler6(error, to, from));
    } else {
      if (false) {
        warn("uncaught error during route navigation:");
      }
      console.error(error);
    }
    return Promise.reject(error);
  }
  __name(triggerError, "triggerError");
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve22, reject2) => {
      readyHandlers.add([resolve22, reject2]);
    });
  }
  __name(isReady, "isReady");
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve22, reject2]) => err ? reject2(err) : resolve22());
      readyHandlers.reset();
    }
    return err;
  }
  __name(markAsReady, "markAsReady");
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options3;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position2) => position2 && scrollToPosition(position2)).catch((err) => triggerError(err, to, from));
  }
  __name(handleScroll, "handleScroll");
  const go = /* @__PURE__ */ __name((delta2) => routerHistory.go(delta2), "go");
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    clearRoutes: matcher.clearRoutes,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options: options3,
    push,
    replace,
    go,
    back: /* @__PURE__ */ __name(() => go(-1), "back"),
    forward: /* @__PURE__ */ __name(() => go(1), "forward"),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorListeners.add,
    isReady,
    install(app2) {
      const router22 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router22;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: /* @__PURE__ */ __name(() => unref(currentRoute), "get")
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
          if (false)
            warn("Unexpected error when starting the router:", err);
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key, {
          get: /* @__PURE__ */ __name(() => currentRoute.value[key], "get"),
          enumerable: true
        });
      }
      app2.provide(routerKey, router22);
      app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
      if (false) {
        addDevtools(app2, router22, matcher);
      }
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  __name(runGuardQueue, "runGuardQueue");
  return router2;
}
__name(createRouter, "createRouter");
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i2 = 0; i2 < len; i2++) {
    const recordFrom = from.matched[i2];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i2];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
__name(extractChangingRecords, "extractChangingRecords");
function useRouter() {
  return inject(routerKey);
}
__name(useRouter, "useRouter");
function useRoute(_name) {
  return inject(routeLocationKey);
}
__name(useRoute, "useRoute");
const _sfc_main = {};
const _hoisted_1 = { class: "w-full min-h-screen overflow-hidden relative" };
function _sfc_render(_ctx, _cache) {
  const _component_router_view = resolveComponent("router-view");
  return openBlock(), createElementBlock("main", _hoisted_1, [
    createVNode(_component_router_view)
  ]);
}
__name(_sfc_render, "_sfc_render");
const LayoutDefault = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const isFileProtocol = /* @__PURE__ */ __name(() => window.location.protocol === "file:", "isFileProtocol");
const guardElectronAccess = /* @__PURE__ */ __name((to, from, next2) => {
  if (isElectron()) {
    next2();
  } else {
    next2("/");
  }
}, "guardElectronAccess");
const router = createRouter({
  history: isFileProtocol() ? createWebHashHistory() : (
    // Base path must be specified to ensure correct relative paths
    // Example: For URL 'http://localhost:7801/ComfyBackendDirect',
    // we need this base path or assets will incorrectly resolve from 'http://localhost:7801/'
    createWebHistory(window.location.pathname)
  ),
  routes: [
    {
      path: "/",
      component: LayoutDefault,
      children: [
        {
          path: "",
          name: "GraphView",
          component: /* @__PURE__ */ __name(() => __vitePreload(() => import("./GraphView-BCOd0Zle.js"), true ? __vite__mapDeps([10,2,11]) : void 0, import.meta.url), "component")
        },
        {
          path: "server-start",
          name: "ServerStartView",
          component: /* @__PURE__ */ __name(() => __vitePreload(() => import("./ServerStartView-e57oVZ6V.js"), true ? __vite__mapDeps([12,13]) : void 0, import.meta.url), "component"),
          beforeEnter: guardElectronAccess
        },
        {
          path: "install",
          name: "InstallView",
          component: /* @__PURE__ */ __name(() => __vitePreload(() => import("./InstallView-D9ueAxrz.js"), true ? __vite__mapDeps([14,13,15]) : void 0, import.meta.url), "component"),
          beforeEnter: guardElectronAccess
        },
        {
          path: "welcome",
          name: "WelcomeView",
          component: /* @__PURE__ */ __name(() => __vitePreload(() => import("./WelcomeView-DT4bj-QV.js"), true ? __vite__mapDeps([16,17]) : void 0, import.meta.url), "component"),
          beforeEnter: guardElectronAccess
        }
      ]
    }
  ],
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition;
    } else {
      return { top: 0 };
    }
  }
});
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
__name(_typeof$1, "_typeof$1");
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys, "ownKeys");
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread, "_objectSpread");
function _defineProperty$1(e, r, t) {
  return (r = _toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty$1, "_defineProperty$1");
function _toPropertyKey$1(t) {
  var i2 = _toPrimitive$1(t, "string");
  return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey$1, "_toPropertyKey$1");
function _toPrimitive$1(t, r) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive$1, "_toPrimitive$1");
var defaultOptions = {
  ripple: false,
  inputStyle: null,
  inputVariant: null,
  locale: {
    startsWith: "Starts with",
    contains: "Contains",
    notContains: "Not contains",
    endsWith: "Ends with",
    equals: "Equals",
    notEquals: "Not equals",
    noFilter: "No Filter",
    lt: "Less than",
    lte: "Less than or equal to",
    gt: "Greater than",
    gte: "Greater than or equal to",
    dateIs: "Date is",
    dateIsNot: "Date is not",
    dateBefore: "Date is before",
    dateAfter: "Date is after",
    clear: "Clear",
    apply: "Apply",
    matchAll: "Match All",
    matchAny: "Match Any",
    addRule: "Add Rule",
    removeRule: "Remove Rule",
    accept: "Yes",
    reject: "No",
    choose: "Choose",
    upload: "Upload",
    cancel: "Cancel",
    completed: "Completed",
    pending: "Pending",
    fileSizeTypes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    chooseYear: "Choose Year",
    chooseMonth: "Choose Month",
    chooseDate: "Choose Date",
    prevDecade: "Previous Decade",
    nextDecade: "Next Decade",
    prevYear: "Previous Year",
    nextYear: "Next Year",
    prevMonth: "Previous Month",
    nextMonth: "Next Month",
    prevHour: "Previous Hour",
    nextHour: "Next Hour",
    prevMinute: "Previous Minute",
    nextMinute: "Next Minute",
    prevSecond: "Previous Second",
    nextSecond: "Next Second",
    am: "am",
    pm: "pm",
    today: "Today",
    weekHeader: "Wk",
    firstDayOfWeek: 0,
    showMonthAfterYear: false,
    dateFormat: "mm/dd/yy",
    weak: "Weak",
    medium: "Medium",
    strong: "Strong",
    passwordPrompt: "Enter a password",
    emptyFilterMessage: "No results found",
    searchMessage: "{0} results are available",
    selectionMessage: "{0} items selected",
    emptySelectionMessage: "No selected item",
    emptySearchMessage: "No results found",
    fileChosenMessage: "{0} files",
    noFileChosenMessage: "No file chosen",
    emptyMessage: "No available options",
    aria: {
      trueLabel: "True",
      falseLabel: "False",
      nullLabel: "Not Selected",
      star: "1 star",
      stars: "{star} stars",
      selectAll: "All items selected",
      unselectAll: "All items unselected",
      close: "Close",
      previous: "Previous",
      next: "Next",
      navigation: "Navigation",
      scrollTop: "Scroll Top",
      moveTop: "Move Top",
      moveUp: "Move Up",
      moveDown: "Move Down",
      moveBottom: "Move Bottom",
      moveToTarget: "Move to Target",
      moveToSource: "Move to Source",
      moveAllToTarget: "Move All to Target",
      moveAllToSource: "Move All to Source",
      pageLabel: "Page {page}",
      firstPageLabel: "First Page",
      lastPageLabel: "Last Page",
      nextPageLabel: "Next Page",
      prevPageLabel: "Previous Page",
      rowsPerPageLabel: "Rows per page",
      jumpToPageDropdownLabel: "Jump to Page Dropdown",
      jumpToPageInputLabel: "Jump to Page Input",
      selectRow: "Row Selected",
      unselectRow: "Row Unselected",
      expandRow: "Row Expanded",
      collapseRow: "Row Collapsed",
      showFilterMenu: "Show Filter Menu",
      hideFilterMenu: "Hide Filter Menu",
      filterOperator: "Filter Operator",
      filterConstraint: "Filter Constraint",
      editRow: "Row Edit",
      saveEdit: "Save Edit",
      cancelEdit: "Cancel Edit",
      listView: "List View",
      gridView: "Grid View",
      slide: "Slide",
      slideNumber: "{slideNumber}",
      zoomImage: "Zoom Image",
      zoomIn: "Zoom In",
      zoomOut: "Zoom Out",
      rotateRight: "Rotate Right",
      rotateLeft: "Rotate Left",
      listLabel: "Option List"
    }
  },
  filterMatchModeOptions: {
    text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
    numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
    date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
  },
  zIndex: {
    modal: 1100,
    overlay: 1e3,
    menu: 1e3,
    tooltip: 1100
  },
  theme: void 0,
  unstyled: false,
  pt: void 0,
  ptOptions: {
    mergeSections: true,
    mergeProps: false
  },
  csp: {
    nonce: void 0
  }
};
var PrimeVueSymbol = Symbol();
function usePrimeVue() {
  var PrimeVue2 = inject(PrimeVueSymbol);
  if (!PrimeVue2) {
    throw new Error("PrimeVue is not installed!");
  }
  return PrimeVue2;
}
__name(usePrimeVue, "usePrimeVue");
function setup(app2, options3) {
  var PrimeVue2 = {
    config: reactive(options3)
  };
  app2.config.globalProperties.$primevue = PrimeVue2;
  app2.provide(PrimeVueSymbol, PrimeVue2);
  clearConfig();
  setupConfig(app2, PrimeVue2);
  return PrimeVue2;
}
__name(setup, "setup");
var stopWatchers = [];
function clearConfig() {
  service_default.clear();
  stopWatchers.forEach(function(fn) {
    return fn === null || fn === void 0 ? void 0 : fn();
  });
  stopWatchers = [];
}
__name(clearConfig, "clearConfig");
function setupConfig(app2, PrimeVue2) {
  var isThemeChanged = ref(false);
  var loadCommonTheme = /* @__PURE__ */ __name(function loadCommonTheme2() {
    if (!config_default.isStyleNameLoaded("common")) {
      var _BaseStyle$getCommonT, _PrimeVue$config;
      var _ref = ((_BaseStyle$getCommonT = BaseStyle.getCommonTheme) === null || _BaseStyle$getCommonT === void 0 ? void 0 : _BaseStyle$getCommonT.call(BaseStyle)) || {}, primitive = _ref.primitive, semantic = _ref.semantic;
      var styleOptions = {
        nonce: (_PrimeVue$config = PrimeVue2.config) === null || _PrimeVue$config === void 0 || (_PrimeVue$config = _PrimeVue$config.csp) === null || _PrimeVue$config === void 0 ? void 0 : _PrimeVue$config.nonce
      };
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread({
        name: "primitive-variables"
      }, styleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread({
        name: "semantic-variables"
      }, styleOptions));
      BaseStyle.loadTheme(_objectSpread({
        name: "global-style"
      }, styleOptions));
      config_default.setLoadedStyleName("common");
    }
  }, "loadCommonTheme");
  service_default.on("theme:change", function(newTheme) {
    if (!isThemeChanged.value) {
      app2.config.globalProperties.$primevue.config.theme = newTheme;
      isThemeChanged.value = true;
    }
  });
  var stopConfigWatcher = watch(PrimeVue2.config, function(newValue, oldValue) {
    PrimeVueService.emit("config:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopRippleWatcher = watch(function() {
    return PrimeVue2.config.ripple;
  }, function(newValue, oldValue) {
    PrimeVueService.emit("config:ripple:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopThemeWatcher = watch(function() {
    return PrimeVue2.config.theme;
  }, function(newValue, oldValue) {
    if (!isThemeChanged.value) {
      config_default.setTheme(newValue);
    }
    if (!PrimeVue2.config.unstyled) {
      loadCommonTheme();
    }
    isThemeChanged.value = false;
    PrimeVueService.emit("config:theme:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopUnstyledWatcher = watch(function() {
    return PrimeVue2.config.unstyled;
  }, function(newValue, oldValue) {
    if (!newValue && PrimeVue2.config.theme) {
      loadCommonTheme();
    }
    PrimeVueService.emit("config:unstyled:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  stopWatchers.push(stopConfigWatcher);
  stopWatchers.push(stopRippleWatcher);
  stopWatchers.push(stopThemeWatcher);
  stopWatchers.push(stopUnstyledWatcher);
}
__name(setupConfig, "setupConfig");
var PrimeVue = {
  install: /* @__PURE__ */ __name(function install2(app2, options3) {
    var configOptions = mergeKeys(defaultOptions, options3);
    setup(app2, configOptions);
  }, "install")
};
var index$1l = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  panel: {
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}"
  },
  header: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{text.color}",
    padding: "1.125rem",
    fontWeight: "600",
    borderRadius: "0",
    borderWidth: "0",
    borderColor: "{content.border.color}",
    background: "{content.background}",
    hoverBackground: "{content.background}",
    activeBackground: "{content.background}",
    activeHoverBackground: "{content.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    toggleIcon: {
      color: "{text.muted.color}",
      hoverColor: "{text.color}",
      activeColor: "{text.color}",
      activeHoverColor: "{text.color}"
    },
    first: {
      topBorderRadius: "{content.border.radius}",
      borderWidth: "0"
    },
    last: {
      bottomBorderRadius: "{content.border.radius}",
      activeBottomBorderRadius: "0"
    }
  },
  content: {
    borderWidth: "0",
    borderColor: "{content.border.color}",
    background: "{content.background}",
    color: "{text.color}",
    padding: "0 1.125rem 1.125rem 1.125rem"
  }
};
var index$1k = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}"
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  dropdown: {
    width: "2.5rem",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.border.color}",
    activeBorderColor: "{form.field.border.color}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  colorScheme: {
    light: {
      dropdown: {
        background: "{surface.100}",
        hoverBackground: "{surface.200}",
        activeBackground: "{surface.300}",
        color: "{surface.600}",
        hoverColor: "{surface.700}",
        activeColor: "{surface.800}"
      }
    },
    dark: {
      dropdown: {
        background: "{surface.800}",
        hoverBackground: "{surface.700}",
        activeBackground: "{surface.600}",
        color: "{surface.300}",
        hoverColor: "{surface.200}",
        activeColor: "{surface.100}"
      }
    }
  }
};
var index$1j = {
  root: {
    width: "2rem",
    height: "2rem",
    fontSize: "1rem",
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}"
  },
  group: {
    borderColor: "{content.background}",
    offset: "-1rem"
  },
  lg: {
    width: "3rem",
    height: "3rem",
    fontSize: "1.5rem"
  },
  xl: {
    width: "4rem",
    height: "4rem",
    fontSize: "2rem"
  }
};
var index$1i = {
  root: {
    borderRadius: "{border.radius.md}",
    padding: "0 0.5rem",
    fontSize: "0.75rem",
    fontWeight: "700",
    minWidth: "1.5rem",
    height: "1.5rem"
  },
  dot: {
    size: "0.5rem"
  },
  sm: {
    fontSize: "0.625rem",
    minWidth: "1.25rem",
    height: "1.25rem"
  },
  lg: {
    fontSize: "0.875rem",
    minWidth: "1.75rem",
    height: "1.75rem"
  },
  xl: {
    fontSize: "1rem",
    minWidth: "2rem",
    height: "2rem"
  },
  colorScheme: {
    light: {
      primary: {
        background: "{primary.color}",
        color: "{primary.contrast.color}"
      },
      secondary: {
        background: "{surface.100}",
        color: "{surface.600}"
      },
      success: {
        background: "{green.500}",
        color: "{surface.0}"
      },
      info: {
        background: "{sky.500}",
        color: "{surface.0}"
      },
      warn: {
        background: "{orange.500}",
        color: "{surface.0}"
      },
      danger: {
        background: "{red.500}",
        color: "{surface.0}"
      },
      contrast: {
        background: "{surface.950}",
        color: "{surface.0}"
      }
    },
    dark: {
      primary: {
        background: "{primary.color}",
        color: "{primary.contrast.color}"
      },
      secondary: {
        background: "{surface.800}",
        color: "{surface.300}"
      },
      success: {
        background: "{green.400}",
        color: "{green.950}"
      },
      info: {
        background: "{sky.400}",
        color: "{sky.950}"
      },
      warn: {
        background: "{orange.400}",
        color: "{orange.950}"
      },
      danger: {
        background: "{red.400}",
        color: "{red.950}"
      },
      contrast: {
        background: "{surface.0}",
        color: "{surface.950}"
      }
    }
  }
};
var index$1h = {
  root: {
    borderRadius: "{content.border.radius}"
  }
};
var index$1g = {
  root: {
    padding: "1rem",
    background: "{content.background}",
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  item: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    borderRadius: "{content.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      hoverColor: "{navigation.item.icon.focus.color}"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  separator: {
    color: "{navigation.item.icon.color}"
  }
};
var index$1f = {
  root: {
    borderRadius: "{form.field.border.radius}",
    roundedBorderRadius: "2rem",
    gap: "0.5rem",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    iconOnlyWidth: "2.5rem",
    sm: {
      fontSize: "0.875rem",
      paddingX: "0.625rem",
      paddingY: "0.375rem"
    },
    lg: {
      fontSize: "1.125rem",
      paddingX: "0.875rem",
      paddingY: "0.625rem"
    },
    label: {
      fontWeight: "500"
    },
    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    },
    badgeSize: "1rem",
    transitionDuration: "{form.field.transition.duration}"
  },
  colorScheme: {
    light: {
      root: {
        primary: {
          background: "{primary.color}",
          hoverBackground: "{primary.hover.color}",
          activeBackground: "{primary.active.color}",
          borderColor: "{primary.color}",
          hoverBorderColor: "{primary.hover.color}",
          activeBorderColor: "{primary.active.color}",
          color: "{primary.contrast.color}",
          hoverColor: "{primary.contrast.color}",
          activeColor: "{primary.contrast.color}",
          focusRing: {
            color: "{primary.color}",
            shadow: "none"
          }
        },
        secondary: {
          background: "{surface.100}",
          hoverBackground: "{surface.200}",
          activeBackground: "{surface.300}",
          borderColor: "{surface.100}",
          hoverBorderColor: "{surface.200}",
          activeBorderColor: "{surface.300}",
          color: "{surface.600}",
          hoverColor: "{surface.700}",
          activeColor: "{surface.800}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        },
        info: {
          background: "{sky.500}",
          hoverBackground: "{sky.600}",
          activeBackground: "{sky.700}",
          borderColor: "{sky.500}",
          hoverBorderColor: "{sky.600}",
          activeBorderColor: "{sky.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{sky.500}",
            shadow: "none"
          }
        },
        success: {
          background: "{green.500}",
          hoverBackground: "{green.600}",
          activeBackground: "{green.700}",
          borderColor: "{green.500}",
          hoverBorderColor: "{green.600}",
          activeBorderColor: "{green.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        },
        warn: {
          background: "{orange.500}",
          hoverBackground: "{orange.600}",
          activeBackground: "{orange.700}",
          borderColor: "{orange.500}",
          hoverBorderColor: "{orange.600}",
          activeBorderColor: "{orange.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{orange.500}",
            shadow: "none"
          }
        },
        help: {
          background: "{purple.500}",
          hoverBackground: "{purple.600}",
          activeBackground: "{purple.700}",
          borderColor: "{purple.500}",
          hoverBorderColor: "{purple.600}",
          activeBorderColor: "{purple.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{purple.500}",
            shadow: "none"
          }
        },
        danger: {
          background: "{red.500}",
          hoverBackground: "{red.600}",
          activeBackground: "{red.700}",
          borderColor: "{red.500}",
          hoverBorderColor: "{red.600}",
          activeBorderColor: "{red.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        },
        contrast: {
          background: "{surface.950}",
          hoverBackground: "{surface.900}",
          activeBackground: "{surface.800}",
          borderColor: "{surface.950}",
          hoverBorderColor: "{surface.900}",
          activeBorderColor: "{surface.800}",
          color: "{surface.0}",
          hoverColor: "{surface.0}",
          activeColor: "{surface.0}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      },
      outlined: {
        primary: {
          hoverBackground: "{primary.50}",
          activeBackground: "{primary.100}",
          borderColor: "{primary.200}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{surface.500}"
        },
        success: {
          hoverBackground: "{green.50}",
          activeBackground: "{green.100}",
          borderColor: "{green.200}",
          color: "{green.500}"
        },
        info: {
          hoverBackground: "{sky.50}",
          activeBackground: "{sky.100}",
          borderColor: "{sky.200}",
          color: "{sky.500}"
        },
        warn: {
          hoverBackground: "{orange.50}",
          activeBackground: "{orange.100}",
          borderColor: "{orange.200}",
          color: "{orange.500}"
        },
        help: {
          hoverBackground: "{purple.50}",
          activeBackground: "{purple.100}",
          borderColor: "{purple.200}",
          color: "{purple.500}"
        },
        danger: {
          hoverBackground: "{red.50}",
          activeBackground: "{red.100}",
          borderColor: "{red.200}",
          color: "{red.500}"
        },
        contrast: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.700}",
          color: "{surface.950}"
        },
        plain: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{surface.700}"
        }
      },
      text: {
        primary: {
          hoverBackground: "{primary.50}",
          activeBackground: "{primary.100}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          color: "{surface.500}"
        },
        success: {
          hoverBackground: "{green.50}",
          activeBackground: "{green.100}",
          color: "{green.500}"
        },
        info: {
          hoverBackground: "{sky.50}",
          activeBackground: "{sky.100}",
          color: "{sky.500}"
        },
        warn: {
          hoverBackground: "{orange.50}",
          activeBackground: "{orange.100}",
          color: "{orange.500}"
        },
        help: {
          hoverBackground: "{purple.50}",
          activeBackground: "{purple.100}",
          color: "{purple.500}"
        },
        danger: {
          hoverBackground: "{red.50}",
          activeBackground: "{red.100}",
          color: "{red.500}"
        },
        plain: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          color: "{surface.700}"
        }
      },
      link: {
        color: "{primary.color}",
        hoverColor: "{primary.color}",
        activeColor: "{primary.color}"
      }
    },
    dark: {
      root: {
        primary: {
          background: "{primary.color}",
          hoverBackground: "{primary.hover.color}",
          activeBackground: "{primary.active.color}",
          borderColor: "{primary.color}",
          hoverBorderColor: "{primary.hover.color}",
          activeBorderColor: "{primary.active.color}",
          color: "{primary.contrast.color}",
          hoverColor: "{primary.contrast.color}",
          activeColor: "{primary.contrast.color}",
          focusRing: {
            color: "{primary.color}",
            shadow: "none"
          }
        },
        secondary: {
          background: "{surface.800}",
          hoverBackground: "{surface.700}",
          activeBackground: "{surface.600}",
          borderColor: "{surface.800}",
          hoverBorderColor: "{surface.700}",
          activeBorderColor: "{surface.600}",
          color: "{surface.300}",
          hoverColor: "{surface.200}",
          activeColor: "{surface.100}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        },
        info: {
          background: "{sky.400}",
          hoverBackground: "{sky.300}",
          activeBackground: "{sky.200}",
          borderColor: "{sky.400}",
          hoverBorderColor: "{sky.300}",
          activeBorderColor: "{sky.200}",
          color: "{sky.950}",
          hoverColor: "{sky.950}",
          activeColor: "{sky.950}",
          focusRing: {
            color: "{sky.400}",
            shadow: "none"
          }
        },
        success: {
          background: "{green.400}",
          hoverBackground: "{green.300}",
          activeBackground: "{green.200}",
          borderColor: "{green.400}",
          hoverBorderColor: "{green.300}",
          activeBorderColor: "{green.200}",
          color: "{green.950}",
          hoverColor: "{green.950}",
          activeColor: "{green.950}",
          focusRing: {
            color: "{green.400}",
            shadow: "none"
          }
        },
        warn: {
          background: "{orange.400}",
          hoverBackground: "{orange.300}",
          activeBackground: "{orange.200}",
          borderColor: "{orange.400}",
          hoverBorderColor: "{orange.300}",
          activeBorderColor: "{orange.200}",
          color: "{orange.950}",
          hoverColor: "{orange.950}",
          activeColor: "{orange.950}",
          focusRing: {
            color: "{orange.400}",
            shadow: "none"
          }
        },
        help: {
          background: "{purple.400}",
          hoverBackground: "{purple.300}",
          activeBackground: "{purple.200}",
          borderColor: "{purple.400}",
          hoverBorderColor: "{purple.300}",
          activeBorderColor: "{purple.200}",
          color: "{purple.950}",
          hoverColor: "{purple.950}",
          activeColor: "{purple.950}",
          focusRing: {
            color: "{purple.400}",
            shadow: "none"
          }
        },
        danger: {
          background: "{red.400}",
          hoverBackground: "{red.300}",
          activeBackground: "{red.200}",
          borderColor: "{red.400}",
          hoverBorderColor: "{red.300}",
          activeBorderColor: "{red.200}",
          color: "{red.950}",
          hoverColor: "{red.950}",
          activeColor: "{red.950}",
          focusRing: {
            color: "{red.400}",
            shadow: "none"
          }
        },
        contrast: {
          background: "{surface.0}",
          hoverBackground: "{surface.100}",
          activeBackground: "{surface.200}",
          borderColor: "{surface.0}",
          hoverBorderColor: "{surface.100}",
          activeBorderColor: "{surface.200}",
          color: "{surface.950}",
          hoverColor: "{surface.950}",
          activeColor: "{surface.950}",
          focusRing: {
            color: "{surface.0}",
            shadow: "none"
          }
        }
      },
      outlined: {
        primary: {
          hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
          borderColor: "{primary.700}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "rgba(255,255,255,0.04)",
          activeBackground: "rgba(255,255,255,0.16)",
          borderColor: "{surface.700}",
          color: "{surface.400}"
        },
        success: {
          hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
          borderColor: "{green.700}",
          color: "{green.400}"
        },
        info: {
          hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
          borderColor: "{sky.700}",
          color: "{sky.400}"
        },
        warn: {
          hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
          borderColor: "{orange.700}",
          color: "{orange.400}"
        },
        help: {
          hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)",
          borderColor: "{purple.700}",
          color: "{purple.400}"
        },
        danger: {
          hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)",
          borderColor: "{red.700}",
          color: "{red.400}"
        },
        contrast: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          borderColor: "{surface.500}",
          color: "{surface.0}"
        },
        plain: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          borderColor: "{surface.600}",
          color: "{surface.0}"
        }
      },
      text: {
        primary: {
          hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          color: "{surface.400}"
        },
        success: {
          hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
          color: "{green.400}"
        },
        info: {
          hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
          color: "{sky.400}"
        },
        warn: {
          hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
          color: "{orange.400}"
        },
        help: {
          hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)",
          color: "{purple.400}"
        },
        danger: {
          hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)",
          color: "{red.400}"
        },
        plain: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          color: "{surface.0}"
        }
      },
      link: {
        color: "{primary.color}",
        hoverColor: "{primary.color}",
        activeColor: "{primary.color}"
      }
    }
  }
};
var index$1e = {
  root: {
    background: "{content.background}",
    borderRadius: "{border.radius.xl}",
    color: "{content.color}",
    shadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
  },
  body: {
    padding: "1.25rem",
    gap: "0.5rem"
  },
  caption: {
    gap: "0.5rem"
  },
  title: {
    fontSize: "1.25rem",
    fontWeight: "500"
  },
  subtitle: {
    color: "{text.muted.color}"
  }
};
var index$1d = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  content: {
    gap: "0.25rem"
  },
  indicatorList: {
    padding: "1rem",
    gap: "0.5rem"
  },
  indicator: {
    width: "2rem",
    height: "0.5rem",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      indicator: {
        background: "{surface.200}",
        hoverBackground: "{surface.300}",
        activeBackground: "{primary.color}"
      }
    },
    dark: {
      indicator: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}",
        activeBackground: "{primary.color}"
      }
    }
  }
};
var index$1c = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}"
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}",
    icon: {
      color: "{list.option.icon.color}",
      focusColor: "{list.option.icon.focus.color}",
      size: "0.875rem"
    }
  }
};
var index$1b = {
  root: {
    borderRadius: "{border.radius.sm}",
    width: "1.25rem",
    height: "1.25rem",
    background: "{form.field.background}",
    checkedBackground: "{primary.color}",
    checkedHoverBackground: "{primary.hover.color}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.border.color}",
    checkedBorderColor: "{primary.color}",
    checkedHoverBorderColor: "{primary.hover.color}",
    checkedFocusBorderColor: "{primary.color}",
    checkedDisabledBorderColor: "{form.field.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    size: "0.875rem",
    color: "{form.field.color}",
    checkedColor: "{primary.contrast.color}",
    checkedHoverColor: "{primary.contrast.color}",
    disabledColor: "{form.field.disabled.color}"
  }
};
var index$1a = {
  root: {
    borderRadius: "16px",
    paddingX: "0.75rem",
    paddingY: "0.5rem",
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  image: {
    width: "2rem",
    height: "2rem"
  },
  icon: {
    size: "1rem"
  },
  removeIcon: {
    size: "1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.100}",
        color: "{surface.800}"
      },
      icon: {
        color: "{surface.800}"
      },
      removeIcon: {
        color: "{surface.800}"
      }
    },
    dark: {
      root: {
        background: "{surface.800}",
        color: "{surface.0}"
      },
      icon: {
        color: "{surface.0}"
      },
      removeIcon: {
        color: "{surface.0}"
      }
    }
  }
};
var index$19 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  preview: {
    width: "1.5rem",
    height: "1.5rem",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  panel: {
    shadow: "{overlay.popover.shadow}",
    borderRadius: "{overlay.popover.borderRadius}"
  },
  colorScheme: {
    light: {
      panel: {
        background: "{surface.800}",
        borderColor: "{surface.900}"
      },
      handle: {
        color: "{surface.0}"
      }
    },
    dark: {
      panel: {
        background: "{surface.900}",
        borderColor: "{surface.700}"
      },
      handle: {
        color: "{surface.0}"
      }
    }
  }
};
var index$18 = {
  icon: {
    size: "2rem",
    color: "{overlay.modal.color}"
  },
  content: {
    gap: "1rem"
  }
};
var index$17 = {
  root: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    color: "{overlay.popover.color}",
    borderRadius: "{overlay.popover.border.radius}",
    shadow: "{overlay.popover.shadow}",
    gutter: "10px",
    arrowOffset: "1.25rem"
  },
  content: {
    padding: "{overlay.popover.padding}",
    gap: "1rem"
  },
  icon: {
    size: "1.5rem",
    color: "{overlay.popover.color}"
  },
  footer: {
    gap: "0.5rem",
    padding: "0 {overlay.popover.padding} {overlay.popover.padding} {overlay.popover.padding}"
  }
};
var index$16 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$15 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  headerCell: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    gap: "0.5rem",
    padding: "0.75rem 1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  columnTitle: {
    fontWeight: "600"
  },
  row: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  bodyCell: {
    borderColor: "{datatable.border.color}",
    padding: "0.75rem 1rem"
  },
  footerCell: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    padding: "0.75rem 1rem"
  },
  columnFooter: {
    fontWeight: "600"
  },
  footer: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  dropPointColor: "{primary.color}",
  columnResizerWidth: "0.5rem",
  resizeIndicator: {
    width: "1px",
    color: "{primary.color}"
  },
  sortIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  loadingIcon: {
    size: "2rem"
  },
  rowToggleButton: {
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    selectedHoverColor: "{primary.color}",
    size: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  filter: {
    inlineGap: "0.5rem",
    overlaySelect: {
      background: "{overlay.select.background}",
      borderColor: "{overlay.select.border.color}",
      borderRadius: "{overlay.select.border.radius}",
      color: "{overlay.select.color}",
      shadow: "{overlay.select.shadow}"
    },
    overlayPopover: {
      background: "{overlay.popover.background}",
      borderColor: "{overlay.popover.border.color}",
      borderRadius: "{overlay.popover.border.radius}",
      color: "{overlay.popover.color}",
      shadow: "{overlay.popover.shadow}",
      padding: "{overlay.popover.padding}",
      gap: "0.5rem"
    },
    rule: {
      borderColor: "{content.border.color}"
    },
    constraintList: {
      padding: "{list.padding}",
      gap: "{list.gap}"
    },
    constraint: {
      focusBackground: "{list.option.focus.background}",
      selectedBackground: "{list.option.selected.background}",
      selectedFocusBackground: "{list.option.selected.focus.background}",
      color: "{list.option.color}",
      focusColor: "{list.option.focus.color}",
      selectedColor: "{list.option.selected.color}",
      selectedFocusColor: "{list.option.selected.focus.color}",
      separator: {
        borderColor: "{content.border.color}"
      },
      padding: "{list.option.padding}",
      borderRadius: "{list.option.border.radius}"
    }
  },
  paginatorTop: {
    borderColor: "{datatable.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{datatable.border.color}",
    borderWidth: "0 0 1px 0"
  },
  colorScheme: {
    light: {
      root: {
        borderColor: "{content.border.color}"
      },
      row: {
        stripedBackground: "{surface.50}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.100}"
      }
    },
    dark: {
      root: {
        borderColor: "{surface.800}"
      },
      row: {
        stripedBackground: "{surface.950}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.900}"
      }
    }
  }
};
var index$14 = {
  root: {
    borderColor: "transparent",
    borderWidth: "0",
    borderRadius: "0",
    padding: "0"
  },
  header: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem",
    borderRadius: "0"
  },
  content: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "transparent",
    borderWidth: "0",
    padding: "0",
    borderRadius: "0"
  },
  footer: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "{content.border.color}",
    borderWidth: "1px 0 0 0",
    padding: "0.75rem 1rem",
    borderRadius: "0"
  },
  paginatorTop: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{content.border.color}",
    borderWidth: "1px 0 0 0"
  }
};
var index$13 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  panel: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.popover.shadow}",
    padding: "{overlay.popover.padding}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    padding: "0 0 0.5rem 0",
    fontWeight: "500",
    gap: "0.5rem"
  },
  title: {
    gap: "0.5rem",
    fontWeight: "500"
  },
  dropdown: {
    width: "2.5rem",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.border.color}",
    activeBorderColor: "{form.field.border.color}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  inputIcon: {
    color: "{form.field.icon.color}"
  },
  selectMonth: {
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}"
  },
  selectYear: {
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}"
  },
  group: {
    borderColor: "{content.border.color}",
    gap: "{overlay.popover.padding}"
  },
  dayView: {
    margin: "0.5rem 0 0 0"
  },
  weekDay: {
    padding: "0.25rem",
    fontWeight: "500",
    color: "{content.color}"
  },
  date: {
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{primary.color}",
    rangeSelectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{primary.contrast.color}",
    rangeSelectedColor: "{highlight.color}",
    width: "2rem",
    height: "2rem",
    borderRadius: "50%",
    padding: "0.25rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  monthView: {
    margin: "0.5rem 0 0 0"
  },
  month: {
    borderRadius: "{content.border.radius}"
  },
  yearView: {
    margin: "0.5rem 0 0 0"
  },
  year: {
    borderRadius: "{content.border.radius}"
  },
  buttonbar: {
    padding: "0.5rem 0 0 0",
    borderColor: "{content.border.color}"
  },
  timePicker: {
    padding: "0.5rem 0 0 0",
    borderColor: "{content.border.color}",
    gap: "0.5rem",
    buttonGap: "0.25rem"
  },
  colorScheme: {
    light: {
      dropdown: {
        background: "{surface.100}",
        hoverBackground: "{surface.200}",
        activeBackground: "{surface.300}",
        color: "{surface.600}",
        hoverColor: "{surface.700}",
        activeColor: "{surface.800}"
      },
      today: {
        background: "{surface.200}",
        color: "{surface.900}"
      }
    },
    dark: {
      dropdown: {
        background: "{surface.800}",
        hoverBackground: "{surface.700}",
        activeBackground: "{surface.600}",
        color: "{surface.300}",
        hoverColor: "{surface.200}",
        activeColor: "{surface.100}"
      },
      today: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$12 = {
  root: {
    background: "{overlay.modal.background}",
    borderColor: "{overlay.modal.border.color}",
    color: "{overlay.modal.color}",
    borderRadius: "{overlay.modal.border.radius}",
    shadow: "{overlay.modal.shadow}"
  },
  header: {
    padding: "{overlay.modal.padding}",
    gap: "0.5rem"
  },
  title: {
    fontSize: "1.25rem",
    fontWeight: "600"
  },
  content: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
  },
  footer: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}",
    gap: "0.5rem"
  }
};
var index$11 = {
  root: {
    borderColor: "{content.border.color}"
  },
  content: {
    background: "{content.background}",
    color: "{text.color}"
  },
  horizontal: {
    margin: "1rem 0",
    padding: "0 1rem",
    content: {
      padding: "0 0.5rem"
    }
  },
  vertical: {
    margin: "0 1rem",
    padding: "0.5rem 0",
    content: {
      padding: "0.5rem 0"
    }
  }
};
var index$10 = {
  root: {
    background: "rgba(255, 255, 255, 0.1)",
    borderColor: "rgba(255, 255, 255, 0.2)",
    padding: "0.5rem",
    borderRadius: "{border.radius.xl}"
  },
  item: {
    borderRadius: "{content.border.radius}",
    padding: "0.5rem",
    size: "3rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$$ = {
  root: {
    background: "{overlay.modal.background}",
    borderColor: "{overlay.modal.border.color}",
    color: "{overlay.modal.color}",
    borderRadius: "{overlay.modal.border.radius}",
    shadow: "{overlay.modal.shadow}"
  },
  header: {
    padding: "{overlay.modal.padding}"
  },
  title: {
    fontSize: "1.5rem",
    fontWeight: "600"
  },
  content: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
  }
};
var index$_ = {
  toolbar: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}"
  },
  toolbarItem: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}",
    padding: "{list.padding}"
  },
  overlayOption: {
    focusBackground: "{list.option.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  content: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}"
  }
};
var index$Z = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    padding: "0 1.125rem 1.125rem 1.125rem",
    transitionDuration: "{transition.duration}"
  },
  legend: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    borderColor: "transparent",
    padding: "0.5rem 0.75rem",
    gap: "0.5rem",
    fontWeight: "600",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  toggleIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  content: {
    padding: "0"
  }
};
var index$Y = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "transparent",
    color: "{text.color}",
    padding: "1.125rem",
    borderWidth: "0",
    borderRadius: "0",
    gap: "0.5rem"
  },
  content: {
    highlightBorderColor: "{primary.color}",
    padding: "0 1.125rem 1.125rem 1.125rem"
  },
  file: {
    padding: "1rem",
    gap: "1rem",
    borderColor: "{content.border.color}",
    info: {
      gap: "0.5rem"
    }
  },
  progressbar: {
    height: "0.25rem"
  },
  basic: {
    gap: "0.5rem"
  }
};
var index$X = {
  root: {
    color: "{form.field.float.label.color}",
    focusColor: "{form.field.float.label.focus.color}",
    invalidColor: "{form.field.float.label.invalid.color}",
    transitionDuration: "0.2s"
  }
};
var index$W = {
  root: {
    borderWidth: "1px",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    transitionDuration: "{transition.duration}"
  },
  navButton: {
    background: "rgba(255, 255, 255, 0.1)",
    hoverBackground: "rgba(255, 255, 255, 0.2)",
    color: "{surface.100}",
    hoverColor: "{surface.0}",
    size: "3rem",
    gutter: "0.5rem",
    prev: {
      borderRadius: "50%"
    },
    next: {
      borderRadius: "50%"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  navIcon: {
    size: "1.5rem"
  },
  thumbnailsContent: {
    background: "{content.background}",
    padding: "1rem 0.25rem"
  },
  thumbnailNavButton: {
    size: "2rem",
    borderRadius: "{content.border.radius}",
    gutter: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  thumbnailNavButtonIcon: {
    size: "1rem"
  },
  caption: {
    background: "rgba(0, 0, 0, 0.5)",
    color: "{surface.100}",
    padding: "1rem"
  },
  indicatorList: {
    gap: "0.5rem",
    padding: "1rem"
  },
  indicatorButton: {
    width: "1rem",
    height: "1rem",
    activeBackground: "{primary.color}",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  insetIndicatorList: {
    background: "rgba(0, 0, 0, 0.5)"
  },
  insetIndicatorButton: {
    background: "rgba(255, 255, 255, 0.4)",
    hoverBackground: "rgba(255, 255, 255, 0.6)",
    activeBackground: "rgba(255, 255, 255, 0.9)"
  },
  mask: {
    background: "{mask.background}",
    color: "{mask.color}"
  },
  closeButton: {
    size: "3rem",
    gutter: "0.5rem",
    background: "rgba(255, 255, 255, 0.1)",
    hoverBackground: "rgba(255, 255, 255, 0.2)",
    color: "{surface.50}",
    hoverColor: "{surface.0}",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  closeButtonIcon: {
    size: "1.5rem"
  },
  colorScheme: {
    light: {
      thumbnailNavButton: {
        hoverBackground: "{surface.100}",
        color: "{surface.600}",
        hoverColor: "{surface.700}"
      },
      indicatorButton: {
        background: "{surface.200}",
        hoverBackground: "{surface.300}"
      }
    },
    dark: {
      thumbnailNavButton: {
        hoverBackground: "{surface.700}",
        color: "{surface.400}",
        hoverColor: "{surface.0}"
      },
      indicatorButton: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}"
      }
    }
  }
};
var index$V = {
  icon: {
    color: "{form.field.icon.color}"
  }
};
var index$U = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  preview: {
    icon: {
      size: "1.5rem"
    },
    mask: {
      background: "{mask.background}",
      color: "{mask.color}"
    }
  },
  toolbar: {
    position: {
      left: "auto",
      right: "1rem",
      top: "1rem",
      bottom: "auto"
    },
    blur: "8px",
    background: "rgba(255,255,255,0.1)",
    borderColor: "rgba(255,255,255,0.2)",
    borderWidth: "1px",
    borderRadius: "30px",
    padding: ".5rem",
    gap: "0.5rem"
  },
  action: {
    hoverBackground: "rgba(255,255,255,0.1)",
    color: "{surface.50}",
    hoverColor: "{surface.0}",
    size: "3rem",
    iconSize: "1.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$T = {
  root: {
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{content.border.radius}",
    gap: "0.5rem"
  },
  text: {
    fontWeight: "500"
  },
  icon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
      }
    },
    dark: {
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
      }
    }
  }
};
var index$S = {
  root: {
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{transition.duration}"
  },
  display: {
    hoverBackground: "{content.hover.background}",
    hoverColor: "{content.hover.color}"
  }
};
var index$R = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  colorScheme: {
    light: {
      chip: {
        focusBackground: "{surface.200}",
        color: "{surface.800}"
      }
    },
    dark: {
      chip: {
        focusBackground: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$Q = {
  addon: {
    background: "{form.field.background}",
    borderColor: "{form.field.border.color}",
    color: "{form.field.icon.color}",
    borderRadius: "{form.field.border.radius}"
  }
};
var index$P = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  button: {
    width: "2.5rem",
    borderRadius: "{form.field.border.radius}",
    verticalPadding: "{form.field.padding.y}"
  },
  colorScheme: {
    light: {
      button: {
        background: "transparent",
        hoverBackground: "{surface.100}",
        activeBackground: "{surface.200}",
        borderColor: "{form.field.border.color}",
        hoverBorderColor: "{form.field.border.color}",
        activeBorderColor: "{form.field.border.color}",
        color: "{surface.400}",
        hoverColor: "{surface.500}",
        activeColor: "{surface.600}"
      }
    },
    dark: {
      button: {
        background: "transparent",
        hoverBackground: "{surface.800}",
        activeBackground: "{surface.700}",
        borderColor: "{form.field.border.color}",
        hoverBorderColor: "{form.field.border.color}",
        activeBorderColor: "{form.field.border.color}",
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        activeColor: "{surface.200}"
      }
    }
  }
};
var index$O = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}",
    sm: {
      fontSize: "0.875rem",
      paddingX: "0.625rem",
      paddingY: "0.375rem"
    },
    lg: {
      fontSize: "1.125rem",
      paddingX: "0.875rem",
      paddingY: "0.625rem"
    }
  }
};
var index$N = {
  root: {
    transitionDuration: "{transition.duration}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  value: {
    background: "{primary.color}"
  },
  range: {
    background: "{content.border.color}"
  },
  text: {
    color: "{text.muted.color}"
  }
};
var index$M = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    shadow: "{form.field.shadow}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  checkmark: {
    color: "{list.option.color}",
    gutterStart: "-0.375rem",
    gutterEnd: "0.375rem"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  colorScheme: {
    light: {
      option: {
        stripedBackground: "{surface.50}"
      }
    },
    dark: {
      option: {
        stripedBackground: "{surface.900}"
      }
    }
  }
};
var index$L = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    verticalOrientation: {
      padding: "{navigation.list.padding}",
      gap: "0"
    },
    horizontalOrientation: {
      padding: "0.5rem 0.75rem"
    },
    transitionDuration: "{transition.duration}"
  },
  baseItem: {
    borderRadius: "{content.border.radius}",
    padding: "{navigation.item.padding}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  overlay: {
    padding: "0",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    shadow: "{overlay.navigation.shadow}",
    gap: "0.5rem"
  },
  submenu: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  },
  mobileButton: {
    borderRadius: "50%",
    size: "1.75rem",
    color: "{text.muted.color}",
    hoverColor: "{text.muted.hover.color}",
    hoverBackground: "{content.hover.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$K = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}"
    }
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background}",
    color: "{navigation.submenu.label.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$J = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    padding: "0.5rem 0.75rem",
    transitionDuration: "{transition.duration}"
  },
  baseItem: {
    borderRadius: "{content.border.radius}",
    padding: "{navigation.item.padding}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenu: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    mobileIndent: "1rem"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  },
  mobileButton: {
    borderRadius: "50%",
    size: "1.75rem",
    color: "{text.muted.color}",
    hoverColor: "{text.muted.hover.color}",
    hoverBackground: "{content.hover.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$I = {
  root: {
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    transitionDuration: "{transition.duration}"
  },
  content: {
    padding: "0.5rem 0.75rem",
    gap: "0.5rem"
  },
  text: {
    fontSize: "1rem",
    fontWeight: "500"
  },
  icon: {
    size: "1.125rem"
  },
  closeButton: {
    width: "1.75rem",
    height: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    }
  },
  closeIcon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{blue.100}",
          focusRing: {
            color: "{blue.600}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{green.100}",
          focusRing: {
            color: "{green.600}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{yellow.100}",
          focusRing: {
            color: "{yellow.600}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{red.100}",
          focusRing: {
            color: "{red.600}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.200}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.800}",
          focusRing: {
            color: "{surface.50}",
            shadow: "none"
          }
        }
      }
    },
    dark: {
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{blue.500}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{yellow.500}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.700}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.100}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      }
    }
  }
};
var index$H = {
  root: {
    borderRadius: "{content.border.radius}",
    gap: "1rem"
  },
  meters: {
    background: "{content.border.color}",
    size: "0.5rem"
  },
  label: {
    gap: "0.5rem"
  },
  labelMarker: {
    size: "0.5rem"
  },
  labelIcon: {
    size: "1rem"
  },
  labelList: {
    verticalGap: "0.5rem",
    horizontalGap: "1rem"
  }
};
var index$G = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}",
    gap: "0.5rem"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  }
};
var index$F = {
  root: {
    gap: "1.125rem"
  },
  controls: {
    gap: "0.5rem"
  }
};
var index$E = {
  root: {
    gutter: "0.75rem",
    transitionDuration: "{transition.duration}"
  },
  node: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    selectedColor: "{highlight.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.75rem 1rem",
    toggleablePadding: "0.75rem 1rem 1.25rem 1rem",
    borderRadius: "{content.border.radius}"
  },
  nodeToggleButton: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    borderColor: "{content.border.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    size: "1.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  connector: {
    color: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: "24px"
  }
};
var index$D = {
  root: {
    outline: {
      width: "2px",
      color: "{content.background}"
    }
  }
};
var index$C = {
  root: {
    padding: "0.5rem 1rem",
    gap: "0.25rem",
    borderRadius: "{content.border.radius}",
    background: "{content.background}",
    color: "{content.color}",
    transitionDuration: "{transition.duration}"
  },
  navButton: {
    background: "transparent",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedColor: "{highlight.color}",
    width: "2.5rem",
    height: "2.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  currentPageReport: {
    color: "{text.muted.color}"
  },
  jumpToPageInput: {
    maxWidth: "2.5rem"
  }
};
var index$B = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}"
  },
  header: {
    background: "transparent",
    color: "{text.color}",
    padding: "1.125rem",
    borderColor: "{content.border.color}",
    borderWidth: "0",
    borderRadius: "0"
  },
  toggleableHeader: {
    padding: "0.375rem 1.125rem"
  },
  title: {
    fontWeight: "600"
  },
  content: {
    padding: "0 1.125rem 1.125rem 1.125rem"
  },
  footer: {
    padding: "0 1.125rem 1.125rem 1.125rem"
  }
};
var index$A = {
  root: {
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  panel: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderWidth: "1px",
    color: "{content.color}",
    padding: "0.25rem 0.25rem",
    borderRadius: "{content.border.radius}",
    first: {
      borderWidth: "1px",
      topBorderRadius: "{content.border.radius}"
    },
    last: {
      borderWidth: "1px",
      bottomBorderRadius: "{content.border.radius}"
    }
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    gap: "0.5rem",
    padding: "{navigation.item.padding}",
    borderRadius: "{content.border.radius}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}"
    }
  },
  submenu: {
    indent: "1rem"
  },
  submenuIcon: {
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}"
  }
};
var index$z = {
  meter: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: ".75rem"
  },
  icon: {
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    borderRadius: "{overlay.popover.border.radius}",
    color: "{overlay.popover.color}",
    padding: "{overlay.popover.padding}",
    shadow: "{overlay.popover.shadow}"
  },
  content: {
    gap: "0.5rem"
  },
  colorScheme: {
    light: {
      strength: {
        weakBackground: "{red.500}",
        mediumBackground: "{amber.500}",
        strongBackground: "{green.500}"
      }
    },
    dark: {
      strength: {
        weakBackground: "{red.400}",
        mediumBackground: "{amber.400}",
        strongBackground: "{green.400}"
      }
    }
  }
};
var index$y = {
  root: {
    gap: "1.125rem"
  },
  controls: {
    gap: "0.5rem"
  }
};
var index$x = {
  root: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    color: "{overlay.popover.color}",
    borderRadius: "{overlay.popover.border.radius}",
    shadow: "{overlay.popover.shadow}",
    gutter: "10px",
    arrowOffset: "1.25rem"
  },
  content: {
    padding: "{overlay.popover.padding}"
  }
};
var index$w = {
  root: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: "1.25rem"
  },
  value: {
    background: "{primary.color}"
  },
  label: {
    color: "{primary.contrast.color}",
    fontSize: "0.75rem",
    fontWeight: "600"
  }
};
var index$v = {
  colorScheme: {
    light: {
      root: {
        "color.1": "{red.500}",
        "color.2": "{blue.500}",
        "color.3": "{green.500}",
        "color.4": "{yellow.500}"
      }
    },
    dark: {
      root: {
        "color.1": "{red.400}",
        "color.2": "{blue.400}",
        "color.3": "{green.400}",
        "color.4": "{yellow.400}"
      }
    }
  }
};
var index$u = {
  root: {
    width: "1.25rem",
    height: "1.25rem",
    background: "{form.field.background}",
    checkedBackground: "{primary.color}",
    checkedHoverBackground: "{primary.hover.color}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.border.color}",
    checkedBorderColor: "{primary.color}",
    checkedHoverBorderColor: "{primary.hover.color}",
    checkedFocusBorderColor: "{primary.color}",
    checkedDisabledBorderColor: "{form.field.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    size: "0.75rem",
    checkedColor: "{primary.contrast.color}",
    checkedHoverColor: "{primary.contrast.color}",
    disabledColor: "{form.field.disabled.color}"
  }
};
var index$t = {
  root: {
    gap: "0.25rem",
    transitionDuration: "{transition.duration}"
  },
  icon: {
    size: "1rem",
    color: "{text.muted.color}",
    hoverColor: "{primary.color}",
    activeColor: "{primary.color}"
  }
};
var index$s = {
  colorScheme: {
    light: {
      root: {
        background: "rgba(0,0,0,0.1)"
      }
    },
    dark: {
      root: {
        background: "rgba(255,255,255,0.3)"
      }
    }
  }
};
var index$r = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  bar: {
    size: "9px",
    borderRadius: "{border.radius.sm}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      bar: {
        background: "{surface.100}"
      }
    },
    dark: {
      bar: {
        background: "{surface.800}"
      }
    }
  }
};
var index$q = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  clearIcon: {
    color: "{form.field.icon.color}"
  },
  checkmark: {
    color: "{list.option.color}",
    gutterStart: "-0.375rem",
    gutterEnd: "0.375rem"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  }
};
var index$p = {
  root: {
    borderRadius: "{form.field.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        invalidBorderColor: "{form.field.invalid.border.color}"
      }
    },
    dark: {
      root: {
        invalidBorderColor: "{form.field.invalid.border.color}"
      }
    }
  }
};
var index$o = {
  root: {
    borderRadius: "{content.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.200}",
        animationBackground: "rgba(255,255,255,0.4)"
      }
    },
    dark: {
      root: {
        background: "rgba(255, 255, 255, 0.06)",
        animationBackground: "rgba(255, 255, 255, 0.04)"
      }
    }
  }
};
var index$n = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  track: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    size: "3px"
  },
  range: {
    background: "{primary.color}"
  },
  handle: {
    width: "20px",
    height: "20px",
    borderRadius: "50%",
    background: "{content.border.color}",
    hoverBackground: "{content.border.color}",
    content: {
      borderRadius: "50%",
      hoverBackground: "{content.background}",
      width: "16px",
      height: "16px",
      shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.08), 0px 1px 1px 0px rgba(0, 0, 0, 0.14)"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      handle: {
        contentBackground: "{surface.0}"
      }
    },
    dark: {
      handle: {
        contentBackground: "{surface.950}"
      }
    }
  }
};
var index$m = {
  root: {
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  }
};
var index$l = {
  root: {
    borderRadius: "{form.field.border.radius}",
    roundedBorderRadius: "2rem",
    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)"
  }
};
var index$k = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    transitionDuration: "{transition.duration}"
  },
  gutter: {
    background: "{content.border.color}"
  },
  handle: {
    size: "24px",
    background: "transparent",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$j = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  separator: {
    background: "{content.border.color}",
    activeBackground: "{primary.color}",
    margin: "0 0 0 1.625rem",
    size: "2px"
  },
  step: {
    padding: "0.5rem",
    gap: "1rem"
  },
  stepHeader: {
    padding: "0",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.5rem"
  },
  stepTitle: {
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    fontWeight: "500"
  },
  stepNumber: {
    background: "{content.background}",
    activeBackground: "{content.background}",
    borderColor: "{content.border.color}",
    activeBorderColor: "{content.border.color}",
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    size: "2rem",
    fontSize: "1.143rem",
    fontWeight: "500",
    borderRadius: "50%",
    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
  },
  steppanels: {
    padding: "0.875rem 0.5rem 1.125rem 0.5rem"
  },
  steppanel: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "0 0 0 1rem"
  }
};
var index$i = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  separator: {
    background: "{content.border.color}"
  },
  itemLink: {
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.5rem"
  },
  itemLabel: {
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    fontWeight: "500"
  },
  itemNumber: {
    background: "{content.background}",
    activeBackground: "{content.background}",
    borderColor: "{content.border.color}",
    activeBorderColor: "{content.border.color}",
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    size: "2rem",
    fontSize: "1.143rem",
    fontWeight: "500",
    borderRadius: "50%",
    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
  }
};
var index$h = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tablist: {
    borderWidth: "0 0 1px 0",
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  item: {
    background: "transparent",
    hoverBackground: "transparent",
    activeBackground: "transparent",
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}",
    hoverBorderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}",
    padding: "1rem 1.125rem",
    fontWeight: "600",
    margin: "0 0 -1px 0",
    gap: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  itemIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  activeBar: {
    height: "1px",
    bottom: "-1px",
    background: "{primary.color}"
  }
};
var index$g = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tablist: {
    borderWidth: "0 0 1px 0",
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  tab: {
    background: "transparent",
    hoverBackground: "transparent",
    activeBackground: "transparent",
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}",
    hoverBorderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}",
    padding: "1rem 1.125rem",
    fontWeight: "600",
    margin: "0 0 -1px 0",
    gap: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  tabpanel: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "0.875rem 1.125rem 1.125rem 1.125rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "inset {focus.ring.shadow}"
    }
  },
  navButton: {
    background: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    width: "2.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  activeBar: {
    height: "1px",
    bottom: "-1px",
    background: "{primary.color}"
  },
  colorScheme: {
    light: {
      navButton: {
        shadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
      }
    },
    dark: {
      navButton: {
        shadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
      }
    }
  }
};
var index$f = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tabList: {
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  tab: {
    borderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  tabPanel: {
    background: "{content.background}",
    color: "{content.color}"
  },
  navButton: {
    background: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}"
  },
  colorScheme: {
    light: {
      navButton: {
        shadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
      }
    },
    dark: {
      navButton: {
        shadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
      }
    }
  }
};
var index$e = {
  root: {
    fontSize: "0.875rem",
    fontWeight: "700",
    padding: "0.25rem 0.5rem",
    gap: "0.25rem",
    borderRadius: "{content.border.radius}",
    roundedBorderRadius: "{border.radius.xl}"
  },
  icon: {
    size: "0.75rem"
  },
  colorScheme: {
    light: {
      primary: {
        background: "{primary.100}",
        color: "{primary.700}"
      },
      secondary: {
        background: "{surface.100}",
        color: "{surface.600}"
      },
      success: {
        background: "{green.100}",
        color: "{green.700}"
      },
      info: {
        background: "{sky.100}",
        color: "{sky.700}"
      },
      warn: {
        background: "{orange.100}",
        color: "{orange.700}"
      },
      danger: {
        background: "{red.100}",
        color: "{red.700}"
      },
      contrast: {
        background: "{surface.950}",
        color: "{surface.0}"
      }
    },
    dark: {
      primary: {
        background: "color-mix(in srgb, {primary.500}, transparent 84%)",
        color: "{primary.300}"
      },
      secondary: {
        background: "{surface.800}",
        color: "{surface.300}"
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        color: "{green.300}"
      },
      info: {
        background: "color-mix(in srgb, {sky.500}, transparent 84%)",
        color: "{sky.300}"
      },
      warn: {
        background: "color-mix(in srgb, {orange.500}, transparent 84%)",
        color: "{orange.300}"
      },
      danger: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        color: "{red.300}"
      },
      contrast: {
        background: "{surface.0}",
        color: "{surface.950}"
      }
    }
  }
};
var index$d = {
  root: {
    background: "{form.field.background}",
    borderColor: "{form.field.border.color}",
    color: "{form.field.color}",
    height: "18rem",
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{form.field.border.radius}"
  },
  prompt: {
    gap: "0.25rem"
  },
  commandResponse: {
    margin: "2px 0"
  }
};
var index$c = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  }
};
var index$b = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$a = {
  event: {
    minHeight: "5rem"
  },
  horizontal: {
    eventContent: {
      padding: "1rem 0"
    }
  },
  vertical: {
    eventContent: {
      padding: "0 1rem"
    }
  },
  eventMarker: {
    size: "1.125rem",
    borderRadius: "50%",
    borderWidth: "2px",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    content: {
      borderRadius: "50%",
      size: "0.375rem",
      background: "{primary.color}",
      insetShadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
    }
  },
  eventConnector: {
    color: "{content.border.color}",
    size: "2px"
  }
};
var index$9 = {
  root: {
    width: "25rem",
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    transitionDuration: "{transition.duration}"
  },
  icon: {
    size: "1.125rem"
  },
  content: {
    padding: "{overlay.popover.padding}",
    gap: "0.5rem"
  },
  text: {
    gap: "0.5rem"
  },
  summary: {
    fontWeight: "500",
    fontSize: "1rem"
  },
  detail: {
    fontWeight: "500",
    fontSize: "0.875rem"
  },
  closeButton: {
    width: "1.75rem",
    height: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    }
  },
  closeIcon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      blur: "1.5px",
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{blue.100}",
          focusRing: {
            color: "{blue.600}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{green.100}",
          focusRing: {
            color: "{green.600}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{yellow.100}",
          focusRing: {
            color: "{yellow.600}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{red.100}",
          focusRing: {
            color: "{red.600}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.200}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.800}",
          focusRing: {
            color: "{surface.50}",
            shadow: "none"
          }
        }
      }
    },
    dark: {
      blur: "10px",
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{blue.500}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{yellow.500}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.700}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        detailColor: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.100}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      }
    }
  }
};
var index$8 = {
  root: {
    padding: "0.5rem 1rem",
    borderRadius: "{content.border.radius}",
    gap: "0.5rem",
    fontWeight: "500",
    disabledBackground: "{form.field.disabled.background}",
    disabledBorderColor: "{form.field.disabled.background}",
    disabledColor: "{form.field.disabled.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    disabledColor: "{form.field.disabled.color}"
  },
  content: {
    left: "0.25rem",
    top: "0.25rem",
    checkedShadow: "0px 1px 2px 0px rgba(0, 0, 0, 0.02), 0px 1px 2px 0px rgba(0, 0, 0, 0.04)"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.100}",
        checkedBackground: "{surface.100}",
        hoverBackground: "{surface.100}",
        borderColor: "{surface.100}",
        color: "{surface.500}",
        hoverColor: "{surface.700}",
        checkedColor: "{surface.900}",
        checkedBorderColor: "{surface.100}"
      },
      content: {
        checkedBackground: "{surface.0}"
      },
      icon: {
        color: "{surface.500}",
        hoverColor: "{surface.700}",
        checkedColor: "{surface.900}"
      }
    },
    dark: {
      root: {
        background: "{surface.950}",
        checkedBackground: "{surface.950}",
        hoverBackground: "{surface.950}",
        borderColor: "{surface.950}",
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        checkedColor: "{surface.0}",
        checkedBorderColor: "{surface.950}"
      },
      content: {
        checkedBackground: "{surface.800}"
      },
      icon: {
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        checkedColor: "{surface.0}"
      }
    }
  }
};
var index$7 = {
  root: {
    width: "2.5rem",
    height: "1.5rem",
    borderRadius: "30px",
    gap: "0.25rem",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    borderWidth: "1px",
    borderColor: "transparent",
    hoverBorderColor: "transparent",
    checkedBorderColor: "transparent",
    checkedHoverBorderColor: "transparent",
    invalidBorderColor: "{form.field.invalid.border.color}",
    transitionDuration: "{form.field.transition.duration}",
    slideDuration: "0.2s",
    disabledBackground: "{form.field.disabled.background}"
  },
  handle: {
    borderRadius: "50%",
    size: "1rem",
    disabledBackground: "{form.field.disabled.color}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.300}",
        hoverBackground: "{surface.400}",
        checkedBackground: "{primary.color}",
        checkedHoverBackground: "{primary.hover.color}"
      },
      handle: {
        background: "{surface.0}",
        hoverBackground: "{surface.0}",
        checkedBackground: "{surface.0}",
        checkedHoverBackground: "{surface.0}"
      }
    },
    dark: {
      root: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}",
        checkedBackground: "{primary.color}",
        checkedHoverBackground: "{primary.hover.color}"
      },
      handle: {
        background: "{surface.400}",
        hoverBackground: "{surface.300}",
        checkedBackground: "{surface.900}",
        checkedHoverBackground: "{surface.900}"
      }
    }
  }
};
var index$6 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    padding: "0.75rem"
  }
};
var index$5 = {
  root: {
    maxWidth: "12.5rem",
    gutter: "0.25rem",
    shadow: "{overlay.popover.shadow}",
    padding: "0.5rem 0.75rem",
    borderRadius: "{overlay.popover.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    },
    dark: {
      root: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$4 = {
  root: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "1rem",
    gap: "2px",
    indent: "1rem",
    transitionDuration: "{transition.duration}"
  },
  node: {
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{text.color}",
    hoverColor: "{text.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.25rem"
  },
  nodeIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedColor: "{highlight.color}"
  },
  nodeToggleButton: {
    borderRadius: "50%",
    size: "1.75rem",
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedHoverColor: "{primary.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  loadingIcon: {
    size: "2rem"
  }
};
var index$3 = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  tree: {
    padding: "{list.padding}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  }
};
var index$2 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  headerCell: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    gap: "0.5rem",
    padding: "0.75rem 1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  columnTitle: {
    fontWeight: "600"
  },
  row: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  bodyCell: {
    borderColor: "{treetable.border.color}",
    padding: "0.75rem 1rem",
    gap: "0.5rem"
  },
  footerCell: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    padding: "0.75rem 1rem"
  },
  columnFooter: {
    fontWeight: "600"
  },
  footer: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  columnResizerWidth: "0.5rem",
  resizeIndicator: {
    width: "1px",
    color: "{primary.color}"
  },
  sortIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  loadingIcon: {
    size: "2rem"
  },
  nodeToggleButton: {
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    selectedHoverColor: "{primary.color}",
    size: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  paginatorTop: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  colorScheme: {
    light: {
      root: {
        borderColor: "{content.border.color}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.100}"
      }
    },
    dark: {
      root: {
        borderColor: "{surface.800}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.900}"
      }
    }
  }
};
var index$1 = {
  loader: {
    mask: {
      background: "{content.background}",
      color: "{text.muted.color}"
    },
    icon: {
      size: "2rem"
    }
  }
};
var index = {
  primitive: {
    borderRadius: {
      none: "0",
      xs: "2px",
      sm: "4px",
      md: "6px",
      lg: "8px",
      xl: "12px"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    }
  },
  semantic: {
    transitionDuration: "0.2s",
    focusRing: {
      width: "1px",
      style: "solid",
      color: "{primary.color}",
      offset: "2px",
      shadow: "none"
    },
    disabledOpacity: "0.6",
    iconSize: "1rem",
    anchorGutter: "2px",
    primary: {
      50: "{emerald.50}",
      100: "{emerald.100}",
      200: "{emerald.200}",
      300: "{emerald.300}",
      400: "{emerald.400}",
      500: "{emerald.500}",
      600: "{emerald.600}",
      700: "{emerald.700}",
      800: "{emerald.800}",
      900: "{emerald.900}",
      950: "{emerald.950}"
    },
    formField: {
      paddingX: "0.75rem",
      paddingY: "0.5rem",
      borderRadius: "{border.radius.md}",
      focusRing: {
        width: "0",
        style: "none",
        color: "transparent",
        offset: "0",
        shadow: "none"
      },
      transitionDuration: "{transition.duration}"
    },
    list: {
      padding: "0.25rem 0.25rem",
      gap: "2px",
      header: {
        padding: "0.5rem 1rem 0.25rem 1rem"
      },
      option: {
        padding: "0.5rem 0.75rem",
        borderRadius: "{border.radius.sm}"
      },
      optionGroup: {
        padding: "0.5rem 0.75rem",
        fontWeight: "600"
      }
    },
    content: {
      borderRadius: "{border.radius.md}"
    },
    mask: {
      transitionDuration: "0.15s"
    },
    navigation: {
      list: {
        padding: "0.25rem 0.25rem",
        gap: "2px"
      },
      item: {
        padding: "0.5rem 0.75rem",
        borderRadius: "{border.radius.sm}",
        gap: "0.5rem"
      },
      submenuLabel: {
        padding: "0.5rem 0.75rem",
        fontWeight: "600"
      },
      submenuIcon: {
        size: "0.875rem"
      }
    },
    overlay: {
      select: {
        borderRadius: "{border.radius.md}",
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      },
      popover: {
        borderRadius: "{border.radius.md}",
        padding: "0.75rem",
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      },
      modal: {
        borderRadius: "{border.radius.xl}",
        padding: "1.25rem",
        shadow: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)"
      },
      navigation: {
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      }
    },
    colorScheme: {
      light: {
        surface: {
          0: "#ffffff",
          50: "{slate.50}",
          100: "{slate.100}",
          200: "{slate.200}",
          300: "{slate.300}",
          400: "{slate.400}",
          500: "{slate.500}",
          600: "{slate.600}",
          700: "{slate.700}",
          800: "{slate.800}",
          900: "{slate.900}",
          950: "{slate.950}"
        },
        primary: {
          color: "{primary.500}",
          contrastColor: "#ffffff",
          hoverColor: "{primary.600}",
          activeColor: "{primary.700}"
        },
        highlight: {
          background: "{primary.50}",
          focusBackground: "{primary.100}",
          color: "{primary.700}",
          focusColor: "{primary.800}"
        },
        mask: {
          background: "rgba(0,0,0,0.4)",
          color: "{surface.200}"
        },
        formField: {
          background: "{surface.0}",
          disabledBackground: "{surface.200}",
          filledBackground: "{surface.50}",
          filledFocusBackground: "{surface.50}",
          borderColor: "{surface.300}",
          hoverBorderColor: "{surface.400}",
          focusBorderColor: "{primary.color}",
          invalidBorderColor: "{red.400}",
          color: "{surface.700}",
          disabledColor: "{surface.500}",
          placeholderColor: "{surface.500}",
          floatLabelColor: "{surface.500}",
          floatLabelFocusColor: "{surface.500}",
          floatLabelInvalidColor: "{red.400}",
          iconColor: "{surface.400}",
          shadow: "0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)"
        },
        text: {
          color: "{surface.700}",
          hoverColor: "{surface.800}",
          mutedColor: "{surface.500}",
          hoverMutedColor: "{surface.600}"
        },
        content: {
          background: "{surface.0}",
          hoverBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{text.color}",
          hoverColor: "{text.hover.color}"
        },
        overlay: {
          select: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          },
          popover: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          },
          modal: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          }
        },
        list: {
          option: {
            focusBackground: "{surface.100}",
            selectedBackground: "{highlight.background}",
            selectedFocusBackground: "{highlight.focus.background}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            selectedColor: "{highlight.color}",
            selectedFocusColor: "{highlight.focus.color}",
            icon: {
              color: "{surface.400}",
              focusColor: "{surface.500}"
            }
          },
          optionGroup: {
            background: "transparent",
            color: "{text.muted.color}"
          }
        },
        navigation: {
          item: {
            focusBackground: "{surface.100}",
            activeBackground: "{surface.100}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            activeColor: "{text.hover.color}",
            icon: {
              color: "{surface.400}",
              focusColor: "{surface.500}",
              activeColor: "{surface.500}"
            }
          },
          submenuLabel: {
            background: "transparent",
            color: "{text.muted.color}"
          },
          submenuIcon: {
            color: "{surface.400}",
            focusColor: "{surface.500}",
            activeColor: "{surface.500}"
          }
        }
      },
      dark: {
        surface: {
          0: "#ffffff",
          50: "{zinc.50}",
          100: "{zinc.100}",
          200: "{zinc.200}",
          300: "{zinc.300}",
          400: "{zinc.400}",
          500: "{zinc.500}",
          600: "{zinc.600}",
          700: "{zinc.700}",
          800: "{zinc.800}",
          900: "{zinc.900}",
          950: "{zinc.950}"
        },
        primary: {
          color: "{primary.400}",
          contrastColor: "{surface.900}",
          hoverColor: "{primary.300}",
          activeColor: "{primary.200}"
        },
        highlight: {
          background: "color-mix(in srgb, {primary.400}, transparent 84%)",
          focusBackground: "color-mix(in srgb, {primary.400}, transparent 76%)",
          color: "rgba(255,255,255,.87)",
          focusColor: "rgba(255,255,255,.87)"
        },
        mask: {
          background: "rgba(0,0,0,0.6)",
          color: "{surface.200}"
        },
        formField: {
          background: "{surface.950}",
          disabledBackground: "{surface.700}",
          filledBackground: "{surface.800}",
          filledFocusBackground: "{surface.800}",
          borderColor: "{surface.700}",
          hoverBorderColor: "{surface.600}",
          focusBorderColor: "{primary.color}",
          invalidBorderColor: "{red.300}",
          color: "{surface.0}",
          disabledColor: "{surface.400}",
          placeholderColor: "{surface.400}",
          floatLabelColor: "{surface.400}",
          floatLabelFocusColor: "{surface.400}",
          floatLabelInvalidColor: "{red.300}",
          iconColor: "{surface.400}",
          shadow: "0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)"
        },
        text: {
          color: "{surface.0}",
          hoverColor: "{surface.0}",
          mutedColor: "{surface.400}",
          hoverMutedColor: "{surface.300}"
        },
        content: {
          background: "{surface.900}",
          hoverBackground: "{surface.800}",
          borderColor: "{surface.700}",
          color: "{text.color}",
          hoverColor: "{text.hover.color}"
        },
        overlay: {
          select: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          },
          popover: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          },
          modal: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          }
        },
        list: {
          option: {
            focusBackground: "{surface.800}",
            selectedBackground: "{highlight.background}",
            selectedFocusBackground: "{highlight.focus.background}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            selectedColor: "{highlight.color}",
            selectedFocusColor: "{highlight.focus.color}",
            icon: {
              color: "{surface.500}",
              focusColor: "{surface.400}"
            }
          },
          optionGroup: {
            background: "transparent",
            color: "{text.muted.color}"
          }
        },
        navigation: {
          item: {
            focusBackground: "{surface.800}",
            activeBackground: "{surface.800}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            activeColor: "{text.hover.color}",
            icon: {
              color: "{surface.500}",
              focusColor: "{surface.400}",
              activeColor: "{surface.400}"
            }
          },
          submenuLabel: {
            background: "transparent",
            color: "{text.muted.color}"
          },
          submenuIcon: {
            color: "{surface.500}",
            focusColor: "{surface.400}",
            activeColor: "{surface.400}"
          }
        }
      }
    }
  },
  components: {
    accordion: index$1l,
    autocomplete: index$1k,
    avatar: index$1j,
    badge: index$1i,
    blockui: index$1h,
    breadcrumb: index$1g,
    button: index$1f,
    datepicker: index$13,
    card: index$1e,
    carousel: index$1d,
    cascadeselect: index$1c,
    checkbox: index$1b,
    chip: index$1a,
    colorpicker: index$19,
    confirmdialog: index$18,
    confirmpopup: index$17,
    contextmenu: index$16,
    dataview: index$14,
    datatable: index$15,
    dialog: index$12,
    divider: index$11,
    dock: index$10,
    drawer: index$$,
    editor: index$_,
    fieldset: index$Z,
    fileupload: index$Y,
    floatlabel: index$X,
    galleria: index$W,
    iconfield: index$V,
    image: index$U,
    inlinemessage: index$T,
    inplace: index$S,
    inputchips: index$R,
    inputgroup: index$Q,
    inputnumber: index$P,
    inputtext: index$O,
    knob: index$N,
    listbox: index$M,
    megamenu: index$L,
    menu: index$K,
    menubar: index$J,
    message: index$I,
    metergroup: index$H,
    multiselect: index$G,
    orderlist: index$F,
    organizationchart: index$E,
    overlaybadge: index$D,
    popover: index$x,
    paginator: index$C,
    password: index$z,
    panel: index$B,
    panelmenu: index$A,
    picklist: index$y,
    progressbar: index$w,
    progressspinner: index$v,
    radiobutton: index$u,
    rating: index$t,
    scrollpanel: index$r,
    select: index$q,
    selectbutton: index$p,
    skeleton: index$o,
    slider: index$n,
    speeddial: index$m,
    splitter: index$k,
    splitbutton: index$l,
    stepper: index$j,
    steps: index$i,
    tabmenu: index$h,
    tabs: index$g,
    tabview: index$f,
    textarea: index$c,
    tieredmenu: index$b,
    tag: index$e,
    terminal: index$d,
    timeline: index$a,
    togglebutton: index$8,
    toggleswitch: index$7,
    tree: index$4,
    treeselect: index$3,
    treetable: index$2,
    toast: index$9,
    toolbar: index$6,
    virtualscroller: index$1
  },
  directives: {
    tooltip: index$5,
    ripple: index$s
  }
};
var ConfirmationService = {
  install: /* @__PURE__ */ __name(function install3(app2) {
    var ConfirmationService2 = {
      require: /* @__PURE__ */ __name(function require2(options3) {
        ConfirmationEventBus.emit("confirm", options3);
      }, "require"),
      close: /* @__PURE__ */ __name(function close4() {
        ConfirmationEventBus.emit("close");
      }, "close")
    };
    app2.config.globalProperties.$confirm = ConfirmationService2;
    app2.provide(PrimeVueConfirmSymbol, ConfirmationService2);
  }, "install")
};
var ToastEventBus = EventBus();
var ToastService = {
  install: /* @__PURE__ */ __name(function install4(app2) {
    var ToastService2 = {
      add: /* @__PURE__ */ __name(function add2(message2) {
        ToastEventBus.emit("add", message2);
      }, "add"),
      remove: /* @__PURE__ */ __name(function remove4(message2) {
        ToastEventBus.emit("remove", message2);
      }, "remove"),
      removeGroup: /* @__PURE__ */ __name(function removeGroup(group) {
        ToastEventBus.emit("remove-group", group);
      }, "removeGroup"),
      removeAllGroups: /* @__PURE__ */ __name(function removeAllGroups() {
        ToastEventBus.emit("remove-all-groups");
      }, "removeAllGroups")
    };
    app2.config.globalProperties.$toast = ToastService2;
    app2.provide(PrimeVueToastSymbol, ToastService2);
  }, "install")
};
var theme = /* @__PURE__ */ __name(function theme37(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-tooltip {\n    position: absolute;\n    display: none;\n    max-width: ".concat(dt2("tooltip.max.width"), ";\n}\n\n.p-tooltip-right,\n.p-tooltip-left {\n    padding: 0 ").concat(dt2("tooltip.gutter"), ";\n}\n\n.p-tooltip-top,\n.p-tooltip-bottom {\n    padding: ").concat(dt2("tooltip.gutter"), " 0;\n}\n\n.p-tooltip-text {\n    white-space: pre-line;\n    word-break: break-word;\n    background: ").concat(dt2("tooltip.background"), ";\n    color: ").concat(dt2("tooltip.color"), ";\n    padding: ").concat(dt2("tooltip.padding"), ";\n    box-shadow: ").concat(dt2("tooltip.shadow"), ";\n    border-radius: ").concat(dt2("tooltip.border.radius"), ";\n}\n\n.p-tooltip-arrow {\n    position: absolute;\n    width: 0;\n    height: 0;\n    border-color: transparent;\n    border-style: solid;\n    scale: 2;\n}\n\n.p-tooltip-right .p-tooltip-arrow {\n    margin-top: calc(-1 * ").concat(dt2("tooltip.gutter"), ");\n    border-width: ").concat(dt2("tooltip.gutter"), " ").concat(dt2("tooltip.gutter"), " ").concat(dt2("tooltip.gutter"), " 0;\n    border-right-color: ").concat(dt2("tooltip.background"), ";\n}\n\n.p-tooltip-left .p-tooltip-arrow {\n    margin-top: calc(-1 * ").concat(dt2("tooltip.gutter"), ");\n    border-width: ").concat(dt2("tooltip.gutter"), " 0 ").concat(dt2("tooltip.gutter"), " ").concat(dt2("tooltip.gutter"), ";\n    border-left-color: ").concat(dt2("tooltip.background"), ";\n}\n\n.p-tooltip-top .p-tooltip-arrow {\n    margin-left: calc(-1 * ").concat(dt2("tooltip.gutter"), ");\n    border-width: ").concat(dt2("tooltip.gutter"), " ").concat(dt2("tooltip.gutter"), " 0 ").concat(dt2("tooltip.gutter"), ";\n    border-top-color: ").concat(dt2("tooltip.background"), ";\n    border-bottom-color: ").concat(dt2("tooltip.background"), ";\n}\n\n.p-tooltip-bottom .p-tooltip-arrow {\n    margin-left: calc(-1 * ").concat(dt2("tooltip.gutter"), ");\n    border-width: 0 ").concat(dt2("tooltip.gutter"), " ").concat(dt2("tooltip.gutter"), " ").concat(dt2("tooltip.gutter"), ";\n    border-top-color: ").concat(dt2("tooltip.background"), ";\n    border-bottom-color: ").concat(dt2("tooltip.background"), ";\n}\n");
}, "theme");
var classes = {
  root: "p-tooltip p-component",
  arrow: "p-tooltip-arrow",
  text: "p-tooltip-text"
};
var TooltipStyle = BaseStyle.extend({
  name: "tooltip-directive",
  theme,
  classes
});
var BaseTooltip = BaseDirective.extend({
  style: TooltipStyle
});
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
__name(_slicedToArray, "_slicedToArray");
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest, "_nonIterableRest");
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit, "_iterableToArrayLimit");
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
__name(_arrayWithHoles, "_arrayWithHoles");
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
__name(_defineProperty, "_defineProperty");
function _toPropertyKey(t) {
  var i2 = _toPrimitive(t, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
__name(_toPropertyKey, "_toPropertyKey");
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive, "_toPrimitive");
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
__name(_typeof, "_typeof");
var Tooltip = BaseTooltip.extend("tooltip", {
  beforeMount: /* @__PURE__ */ __name(function beforeMount3(el, options3) {
    var _options$instance$$pr;
    var target = this.getTarget(el);
    target.$_ptooltipModifiers = this.getModifiers(options3);
    if (!options3.value) return;
    else if (typeof options3.value === "string") {
      target.$_ptooltipValue = options3.value;
      target.$_ptooltipDisabled = false;
      target.$_ptooltipEscape = true;
      target.$_ptooltipClass = null;
      target.$_ptooltipFitContent = true;
      target.$_ptooltipIdAttr = UniqueComponentId() + "_tooltip";
      target.$_ptooltipShowDelay = 0;
      target.$_ptooltipHideDelay = 0;
      target.$_ptooltipAutoHide = true;
    } else if (_typeof(options3.value) === "object" && options3.value) {
      if (isEmpty(options3.value.value) || options3.value.value.trim() === "") return;
      else {
        target.$_ptooltipValue = options3.value.value;
        target.$_ptooltipDisabled = !!options3.value.disabled === options3.value.disabled ? options3.value.disabled : false;
        target.$_ptooltipEscape = !!options3.value.escape === options3.value.escape ? options3.value.escape : true;
        target.$_ptooltipClass = options3.value["class"] || "";
        target.$_ptooltipFitContent = !!options3.value.fitContent === options3.value.fitContent ? options3.value.fitContent : true;
        target.$_ptooltipIdAttr = options3.value.id || UniqueComponentId() + "_tooltip";
        target.$_ptooltipShowDelay = options3.value.showDelay || 0;
        target.$_ptooltipHideDelay = options3.value.hideDelay || 0;
        target.$_ptooltipAutoHide = !!options3.value.autoHide === options3.value.autoHide ? options3.value.autoHide : true;
      }
    }
    target.$_ptooltipZIndex = (_options$instance$$pr = options3.instance.$primevue) === null || _options$instance$$pr === void 0 || (_options$instance$$pr = _options$instance$$pr.config) === null || _options$instance$$pr === void 0 || (_options$instance$$pr = _options$instance$$pr.zIndex) === null || _options$instance$$pr === void 0 ? void 0 : _options$instance$$pr.tooltip;
    this.bindEvents(target, options3);
    el.setAttribute("data-pd-tooltip", true);
  }, "beforeMount"),
  updated: /* @__PURE__ */ __name(function updated11(el, options3) {
    var target = this.getTarget(el);
    target.$_ptooltipModifiers = this.getModifiers(options3);
    this.unbindEvents(target);
    if (!options3.value) {
      return;
    }
    if (typeof options3.value === "string") {
      target.$_ptooltipValue = options3.value;
      target.$_ptooltipDisabled = false;
      target.$_ptooltipEscape = true;
      target.$_ptooltipClass = null;
      target.$_ptooltipIdAttr = target.$_ptooltipIdAttr || UniqueComponentId() + "_tooltip";
      target.$_ptooltipShowDelay = 0;
      target.$_ptooltipHideDelay = 0;
      target.$_ptooltipAutoHide = true;
      this.bindEvents(target, options3);
    } else if (_typeof(options3.value) === "object" && options3.value) {
      if (isEmpty(options3.value.value) || options3.value.value.trim() === "") {
        this.unbindEvents(target, options3);
        return;
      } else {
        target.$_ptooltipValue = options3.value.value;
        target.$_ptooltipDisabled = !!options3.value.disabled === options3.value.disabled ? options3.value.disabled : false;
        target.$_ptooltipEscape = !!options3.value.escape === options3.value.escape ? options3.value.escape : true;
        target.$_ptooltipClass = options3.value["class"] || "";
        target.$_ptooltipFitContent = !!options3.value.fitContent === options3.value.fitContent ? options3.value.fitContent : true;
        target.$_ptooltipIdAttr = options3.value.id || target.$_ptooltipIdAttr || UniqueComponentId() + "_tooltip";
        target.$_ptooltipShowDelay = options3.value.showDelay || 0;
        target.$_ptooltipHideDelay = options3.value.hideDelay || 0;
        target.$_ptooltipAutoHide = !!options3.value.autoHide === options3.value.autoHide ? options3.value.autoHide : true;
        this.bindEvents(target, options3);
      }
    }
  }, "updated"),
  unmounted: /* @__PURE__ */ __name(function unmounted5(el, options3) {
    var target = this.getTarget(el);
    this.remove(target);
    this.unbindEvents(target, options3);
    if (target.$_ptooltipScrollHandler) {
      target.$_ptooltipScrollHandler.destroy();
      target.$_ptooltipScrollHandler = null;
    }
  }, "unmounted"),
  timer: void 0,
  methods: {
    bindEvents: /* @__PURE__ */ __name(function bindEvents2(el, options3) {
      var _this = this;
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.focus) {
        el.$_focusevent = function(event2) {
          return _this.onFocus(event2, options3);
        };
        el.addEventListener("focus", el.$_focusevent);
        el.addEventListener("blur", this.onBlur.bind(this));
      } else {
        el.$_mouseenterevent = function(event2) {
          return _this.onMouseEnter(event2, options3);
        };
        el.addEventListener("mouseenter", el.$_mouseenterevent);
        el.addEventListener("mouseleave", this.onMouseLeave.bind(this));
        el.addEventListener("click", this.onClick.bind(this));
      }
      el.addEventListener("keydown", this.onKeydown.bind(this));
    }, "bindEvents"),
    unbindEvents: /* @__PURE__ */ __name(function unbindEvents2(el) {
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.focus) {
        el.removeEventListener("focus", el.$_focusevent);
        el.$_focusevent = null;
        el.removeEventListener("blur", this.onBlur.bind(this));
      } else {
        el.removeEventListener("mouseenter", el.$_mouseenterevent);
        el.$_mouseenterevent = null;
        el.removeEventListener("mouseleave", this.onMouseLeave.bind(this));
        el.removeEventListener("click", this.onClick.bind(this));
      }
      el.removeEventListener("keydown", this.onKeydown.bind(this));
    }, "unbindEvents"),
    bindScrollListener: /* @__PURE__ */ __name(function bindScrollListener5(el) {
      var _this2 = this;
      if (!el.$_ptooltipScrollHandler) {
        el.$_ptooltipScrollHandler = new ConnectedOverlayScrollHandler(el, function() {
          _this2.hide(el);
        });
      }
      el.$_ptooltipScrollHandler.bindScrollListener();
    }, "bindScrollListener"),
    unbindScrollListener: /* @__PURE__ */ __name(function unbindScrollListener5(el) {
      if (el.$_ptooltipScrollHandler) {
        el.$_ptooltipScrollHandler.unbindScrollListener();
      }
    }, "unbindScrollListener"),
    onMouseEnter: /* @__PURE__ */ __name(function onMouseEnter(event2, options3) {
      var el = event2.currentTarget;
      var showDelay = el.$_ptooltipShowDelay;
      this.show(el, options3, showDelay);
    }, "onMouseEnter"),
    onMouseLeave: /* @__PURE__ */ __name(function onMouseLeave(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      var autoHide = el.$_ptooltipAutoHide;
      if (!autoHide) {
        var valid = getAttribute(event2.target, "data-pc-name") === "tooltip" || getAttribute(event2.target, "data-pc-section") === "arrow" || getAttribute(event2.target, "data-pc-section") === "text" || getAttribute(event2.relatedTarget, "data-pc-name") === "tooltip" || getAttribute(event2.relatedTarget, "data-pc-section") === "arrow" || getAttribute(event2.relatedTarget, "data-pc-section") === "text";
        !valid && this.hide(el, hideDelay);
      } else {
        this.hide(el, hideDelay);
      }
    }, "onMouseLeave"),
    onFocus: /* @__PURE__ */ __name(function onFocus6(event2, options3) {
      var el = event2.currentTarget;
      var showDelay = el.$_ptooltipShowDelay;
      this.show(el, options3, showDelay);
    }, "onFocus"),
    onBlur: /* @__PURE__ */ __name(function onBlur6(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      this.hide(el, hideDelay);
    }, "onBlur"),
    onClick: /* @__PURE__ */ __name(function onClick2(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      this.hide(el, hideDelay);
    }, "onClick"),
    onKeydown: /* @__PURE__ */ __name(function onKeydown2(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      event2.code === "Escape" && this.hide(event2.currentTarget, hideDelay);
    }, "onKeydown"),
    tooltipActions: /* @__PURE__ */ __name(function tooltipActions(el, options3) {
      if (el.$_ptooltipDisabled || !isExist(el)) {
        return;
      }
      var tooltipElement = this.create(el, options3);
      this.align(el);
      !this.isUnstyled() && fadeIn(tooltipElement, 250);
      var $this = this;
      window.addEventListener("resize", /* @__PURE__ */ __name(function onWindowResize() {
        if (!isTouchDevice()) {
          $this.hide(el);
        }
        window.removeEventListener("resize", onWindowResize);
      }, "onWindowResize"));
      tooltipElement.addEventListener("mouseleave", /* @__PURE__ */ __name(function onTooltipLeave() {
        $this.hide(el);
        tooltipElement.removeEventListener("mouseleave", onTooltipLeave);
      }, "onTooltipLeave"));
      this.bindScrollListener(el);
      ZIndex.set("tooltip", tooltipElement, el.$_ptooltipZIndex);
    }, "tooltipActions"),
    show: /* @__PURE__ */ __name(function show4(el, options3, showDelay) {
      var _this3 = this;
      if (showDelay !== void 0) {
        this.timer = setTimeout(function() {
          return _this3.tooltipActions(el, options3);
        }, showDelay);
      } else {
        this.tooltipActions(el, options3);
      }
    }, "show"),
    tooltipRemoval: /* @__PURE__ */ __name(function tooltipRemoval(el) {
      this.remove(el);
      this.unbindScrollListener(el);
    }, "tooltipRemoval"),
    hide: /* @__PURE__ */ __name(function hide4(el, hideDelay) {
      var _this4 = this;
      clearTimeout(this.timer);
      if (hideDelay !== void 0) {
        setTimeout(function() {
          return _this4.tooltipRemoval(el);
        }, hideDelay);
      } else {
        this.tooltipRemoval(el);
      }
    }, "hide"),
    getTooltipElement: /* @__PURE__ */ __name(function getTooltipElement(el) {
      return document.getElementById(el.$_ptooltipId);
    }, "getTooltipElement"),
    create: /* @__PURE__ */ __name(function create2(el) {
      var modifiers = el.$_ptooltipModifiers;
      var tooltipArrow = createElement("div", {
        "class": !this.isUnstyled() && this.cx("arrow"),
        "p-bind": this.ptm("arrow", {
          context: modifiers
        })
      });
      var tooltipText = createElement("div", {
        "class": !this.isUnstyled() && this.cx("text"),
        "p-bind": this.ptm("text", {
          context: modifiers
        })
      });
      if (!el.$_ptooltipEscape) {
        tooltipText.innerHTML = el.$_ptooltipValue;
      } else {
        tooltipText.innerHTML = "";
        tooltipText.appendChild(document.createTextNode(el.$_ptooltipValue));
      }
      var container = createElement("div", _defineProperty(_defineProperty({
        id: el.$_ptooltipIdAttr,
        role: "tooltip",
        style: {
          display: "inline-block",
          width: el.$_ptooltipFitContent ? "fit-content" : void 0,
          pointerEvents: !this.isUnstyled() && el.$_ptooltipAutoHide && "none"
        },
        "class": [!this.isUnstyled() && this.cx("root"), el.$_ptooltipClass]
      }, this.$attrSelector, ""), "p-bind", this.ptm("root", {
        context: modifiers
      })), tooltipArrow, tooltipText);
      document.body.appendChild(container);
      el.$_ptooltipId = container.id;
      this.$el = container;
      return container;
    }, "create"),
    remove: /* @__PURE__ */ __name(function remove3(el) {
      if (el) {
        var tooltipElement = this.getTooltipElement(el);
        if (tooltipElement && tooltipElement.parentElement) {
          ZIndex.clear(tooltipElement);
          document.body.removeChild(tooltipElement);
        }
        el.$_ptooltipId = null;
      }
    }, "remove"),
    align: /* @__PURE__ */ __name(function align(el) {
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.top) {
        this.alignTop(el);
        if (this.isOutOfBounds(el)) {
          this.alignBottom(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
          }
        }
      } else if (modifiers.left) {
        this.alignLeft(el);
        if (this.isOutOfBounds(el)) {
          this.alignRight(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
            if (this.isOutOfBounds(el)) {
              this.alignBottom(el);
              if (this.isOutOfBounds(el)) {
                this.alignLeft(el);
              }
            }
          }
        }
      } else if (modifiers.bottom) {
        this.alignBottom(el);
        if (this.isOutOfBounds(el)) {
          this.alignTop(el);
          if (this.isOutOfBounds(el)) {
            this.alignBottom(el);
          }
        }
      } else {
        this.alignRight(el);
        if (this.isOutOfBounds(el)) {
          this.alignLeft(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
            if (this.isOutOfBounds(el)) {
              this.alignBottom(el);
              if (this.isOutOfBounds(el)) {
                this.alignRight(el);
              }
            }
          }
        }
      }
    }, "align"),
    getHostOffset: /* @__PURE__ */ __name(function getHostOffset(el) {
      var offset = el.getBoundingClientRect();
      var targetLeft = offset.left + getWindowScrollLeft();
      var targetTop = offset.top + getWindowScrollTop();
      return {
        left: targetLeft,
        top: targetTop
      };
    }, "getHostOffset"),
    alignRight: /* @__PURE__ */ __name(function alignRight(el) {
      this.preAlign(el, "right");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + getOuterWidth(el);
      var top = hostOffset.top + (getOuterHeight(el) - getOuterHeight(tooltipElement)) / 2;
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    }, "alignRight"),
    alignLeft: /* @__PURE__ */ __name(function alignLeft(el) {
      this.preAlign(el, "left");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left - getOuterWidth(tooltipElement);
      var top = hostOffset.top + (getOuterHeight(el) - getOuterHeight(tooltipElement)) / 2;
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    }, "alignLeft"),
    alignTop: /* @__PURE__ */ __name(function alignTop(el) {
      this.preAlign(el, "top");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + (getOuterWidth(el) - getOuterWidth(tooltipElement)) / 2;
      var top = hostOffset.top - getOuterHeight(tooltipElement);
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    }, "alignTop"),
    alignBottom: /* @__PURE__ */ __name(function alignBottom(el) {
      this.preAlign(el, "bottom");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + (getOuterWidth(el) - getOuterWidth(tooltipElement)) / 2;
      var top = hostOffset.top + getOuterHeight(el);
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    }, "alignBottom"),
    preAlign: /* @__PURE__ */ __name(function preAlign(el, position2) {
      var tooltipElement = this.getTooltipElement(el);
      tooltipElement.style.left = "-999px";
      tooltipElement.style.top = "-999px";
      removeClass(tooltipElement, "p-tooltip-".concat(tooltipElement.$_ptooltipPosition));
      !this.isUnstyled() && addClass(tooltipElement, "p-tooltip-".concat(position2));
      tooltipElement.$_ptooltipPosition = position2;
      tooltipElement.setAttribute("data-p-position", position2);
      var arrowElement = findSingle(tooltipElement, '[data-pc-section="arrow"]');
      arrowElement.style.top = position2 === "bottom" ? "0" : position2 === "right" || position2 === "left" || position2 !== "right" && position2 !== "left" && position2 !== "top" && position2 !== "bottom" ? "50%" : null;
      arrowElement.style.bottom = position2 === "top" ? "0" : null;
      arrowElement.style.left = position2 === "right" || position2 !== "right" && position2 !== "left" && position2 !== "top" && position2 !== "bottom" ? "0" : position2 === "top" || position2 === "bottom" ? "50%" : null;
      arrowElement.style.right = position2 === "left" ? "0" : null;
    }, "preAlign"),
    isOutOfBounds: /* @__PURE__ */ __name(function isOutOfBounds(el) {
      var tooltipElement = this.getTooltipElement(el);
      var offset = tooltipElement.getBoundingClientRect();
      var targetTop = offset.top;
      var targetLeft = offset.left;
      var width2 = getOuterWidth(tooltipElement);
      var height = getOuterHeight(tooltipElement);
      var viewport = getViewport();
      return targetLeft + width2 > viewport.width || targetLeft < 0 || targetTop < 0 || targetTop + height > viewport.height;
    }, "isOutOfBounds"),
    getTarget: /* @__PURE__ */ __name(function getTarget2(el) {
      return hasClass(el, "p-inputwrapper") ? findSingle(el, "input") : el;
    }, "getTarget"),
    getModifiers: /* @__PURE__ */ __name(function getModifiers(options3) {
      if (options3.modifiers && Object.keys(options3.modifiers).length) {
        return options3.modifiers;
      }
      if (options3.arg && _typeof(options3.arg) === "object") {
        return Object.entries(options3.arg).reduce(function(acc, _ref) {
          var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], val = _ref2[1];
          if (key === "event" || key === "position") acc[val] = true;
          return acc;
        }, {});
      }
      return {};
    }, "getModifiers")
  }
});
const ComfyUIPreset = definePreset(index, {
  semantic: {
    primary: index["primitive"].blue
  }
});
const app = createApp(_sfc_main$1);
const pinia = createPinia();
app.directive("tooltip", Tooltip);
app.use(router).use(PrimeVue, {
  theme: {
    preset: ComfyUIPreset,
    options: {
      prefix: "p",
      cssLayer: {
        name: "primevue",
        order: "primevue, tailwind-utilities"
      },
      // This is a workaround for the issue with the dark mode selector
      // https://github.com/primefaces/primevue/issues/5515
      darkModeSelector: ".dark-theme, :root:has(.dark-theme)"
    }
  }
}).use(ConfirmationService).use(ToastService).use(pinia).use(i18n).mount("#vue-app");
export {
  script$r as $,
  createBaseVNode as A,
  BaseStyle as B,
  normalizeClass as C,
  script$M as D,
  EditableText as E,
  useCommandStore as F,
  useDialogStore as G,
  SettingDialogContent as H,
  onBeforeUnmount as I,
  resolveDynamicComponent as J,
  useWorkspaceStore as K,
  LGraphGroup as L,
  useKeybindingStore as M,
  Fragment as N,
  renderList as O,
  pushScopeId as P,
  popScopeId as Q,
  script$Y as R,
  SettingDialogHeader as S,
  Teleport as T,
  getWidth as U,
  findSingle as V,
  getOuterHeight as W,
  getOffset as X,
  getOuterWidth as Y,
  getHeight as Z,
  _export_sfc as _,
  useTitleEditorStore as a,
  LGraph$1 as a$,
  script$q as a0,
  Ripple as a1,
  getAttribute as a2,
  focus as a3,
  equals as a4,
  useBottomPanelStore as a5,
  toDisplayString$1 as a6,
  script$J as a7,
  getVNodeProp as a8,
  isArray$3 as a9,
  script$w as aA,
  formatNumberWithSuffix as aB,
  NodeSourceType as aC,
  useI18n as aD,
  useNodeDefStore as aE,
  NodePreview as aF,
  NodeSearchFilter as aG,
  script$b as aH,
  SearchFilterChip as aI,
  watchEffect as aJ,
  toRaw as aK,
  LinkReleaseTriggerAction as aL,
  useEventListener as aM,
  nextTick as aN,
  getColorPalette as aO,
  BadgePosition as aP,
  LGraphBadge as aQ,
  _ as aR,
  defaultColorPalette as aS,
  NodeBadgeMode as aT,
  markRaw as aU,
  useModelToNodeStore as aV,
  useWorkflowStore as aW,
  setStorageValue as aX,
  usePragmaticDroppable as aY,
  ComfyNodeDefImpl as aZ,
  ComfyModelDef as a_,
  useSidebarTabStore as aa,
  vShow as ab,
  isNotEmpty as ac,
  UniqueComponentId as ad,
  ZIndex as ae,
  resolveFieldData as af,
  OverlayEventBus as ag,
  isEmpty as ah,
  addStyle as ai,
  relativePosition as aj,
  absolutePosition as ak,
  ConnectedOverlayScrollHandler as al,
  isTouchDevice as am,
  findLastIndex as an,
  script$R as ao,
  script$P as ap,
  script$z as aq,
  script$B as ar,
  script$Q as as,
  script$t as at,
  Transition as au,
  createSlots as av,
  createTextVNode as aw,
  useNodeFrequencyStore as ax,
  useNodeBookmarkStore as ay,
  highlightQuery as az,
  useCanvasStore as b,
  KeyComboImpl as b$,
  LLink as b0,
  DragAndScale as b1,
  LGraphCanvas as b2,
  ContextMenu as b3,
  ChangeTracker as b4,
  script$n as b5,
  script$V as b6,
  script$o as b7,
  script$u as b8,
  script$A as b9,
  watchDebounced as bA,
  inject as bB,
  useElementBounding as bC,
  lodashExports as bD,
  useEventBus as bE,
  provide as bF,
  script$G as bG,
  api as bH,
  i18n as bI,
  useModelStore as bJ,
  script$F as bK,
  electronAPI as bL,
  findIndexInList as bM,
  find as bN,
  useModel as bO,
  script$S as bP,
  script$T as bQ,
  script$m as bR,
  script$j as bS,
  script$x as bT,
  useRouter as bU,
  ComfyDialog as bV,
  $el as bW,
  ComfyApp as bX,
  DraggableList as bY,
  serialise as bZ,
  deserialiseAndCreate as b_,
  normalizeProps as ba,
  ToastEventBus as bb,
  setAttribute as bc,
  TransitionGroup as bd,
  useToast as be,
  useToastStore as bf,
  useExecutionStore as bg,
  useTitle as bh,
  withModifiers as bi,
  script$9 as bj,
  workflowService as bk,
  resolve as bl,
  script$h as bm,
  script$E as bn,
  isPrintableCharacter as bo,
  guardReactiveProps as bp,
  useMenuItemStore as bq,
  script$k as br,
  nestedPosition as bs,
  useQueueSettingsStore as bt,
  storeToRefs as bu,
  isRef as bv,
  script$C as bw,
  useQueuePendingTaskCountStore as bx,
  useLocalStorage as by,
  useDraggable as bz,
  app$1 as c,
  ComfyWidgets as c0,
  applyTextReplacements as c1,
  addValueControlWidgets as c2,
  FilterMatchMode as c3,
  SearchBox as c4,
  KeybindingImpl as c5,
  useExtensionStore as c6,
  script$X as c7,
  script$y as c8,
  getFirstFocusableElement as c9,
  invokeElementMethod as ca,
  getNextElementSibling as cb,
  getPreviousElementSibling as cc,
  _default as cd,
  FilterOperator as ce,
  FocusTrap as cf,
  withKeys as cg,
  getIndex as ch,
  isClickable as ci,
  clearSelection as cj,
  localeComparator as ck,
  sort as cl,
  FilterService as cm,
  exportCSV as cn,
  getHiddenElementOuterWidth as co,
  getHiddenElementOuterHeight as cp,
  reorderArray as cq,
  getWindowScrollTop as cr,
  removeClass as cs,
  addClass as ct,
  defineComponent as d,
  LGraphNode as e,
  onUnmounted as f,
  openBlock as g,
  createElementBlock as h,
  createVNode as i,
  createCommentVNode as j,
  LiteGraph as k,
  resolveComponent as l,
  mergeProps as m,
  normalizeStyle as n,
  onMounted as o,
  renderSlot as p,
  computed as q,
  ref as r,
  script$N as s,
  resolveDirective as t,
  useSettingStore as u,
  withDirectives as v,
  watch as w,
  createBlock as x,
  withCtx as y,
  unref as z
};
//# sourceMappingURL=index-B6dYHNhg.js.map
