const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-DJRcbqp_.js","assets/index-DjWyclij.css","assets/userSelection-BifVfRyx.js","assets/userSelection-BGzn1LuN.css"])))=>i.map(i=>d[i]);
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp2 = (obj, key, value3) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3;
var __spreadValues2 = (a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp2.call(b, prop2))
      __defNormalProp2(a, prop2, b[prop2]);
  if (__getOwnPropSymbols2)
    for (var prop2 of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop2))
        __defNormalProp2(a, prop2, b[prop2]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop2 in source)
    if (__hasOwnProp2.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols2)
    for (var prop2 of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum2.call(source, prop2))
        target[prop2] = source[prop2];
    }
  return target;
};
var __publicField2 = (obj, key, value3) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value3);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value3) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value3);
var __privateSet = (obj, member, value3, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value3) : member.set(obj, value3), value3);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value3) {
    __privateSet(obj, member, value3, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve8, reject2) => {
    var fulfilled = (value3) => {
      try {
        step(generator.next(value3));
      } catch (e) {
        reject2(e);
      }
    };
    var rejected = (value3) => {
      try {
        step(generator.throw(value3));
      } catch (e) {
        reject2(e);
      }
    };
    var step = (x2) => x2.done ? resolve8(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var _registered, _ComfyApi_instances, pollQueue_fn, createSocket_fn, postItem_fn, _buttons, _a, _ComfySettingsDialog_instances, dispatchChange_fn, _type, _text, _reverse, _enabled, _console, _over, _popupOpen, _ComfyPopup_instances, hide_fn, show_fn, _escHandler, _clickHandler, _internalQueueSize, _app, _ChangeTracker_instances, setApp_fn, _resolve, _activePromptId, _unsavedCount, _activeWorkflow, _ComfyWorkflowManager_instances, bindExecutionEvents_fn, _name, _path, _pathParts, _isFavorite, _ComfyWorkflow_instances, updatePath_fn, save_fn, _first, _updateProgress, _updateActive, _ComfyWorkflowsMenu_instances, bindEvents_fn, getMenuOptions_fn, getFavoriteMenuOptions_fn, _ComfyWorkflowsContent_instances, expandNode_fn, updateActive_fn, removeActive_fn, getFavoriteIcon_fn, getFavoriteOverIcon_fn, getFavoriteTooltip_fn, getFavoriteButton_fn, getDeleteButton_fn, getInsertButton_fn, getRenameButton_fn, getWorkflowElement_fn, createLeafNode_fn, createNode_fn, _options, _sizeBreak, _lastSizeBreaks, _sizeBreaks, _cachedInnerSize, _cacheTimeout, _queueItems, _processingQueue, _ComfyApp_instances, invokeExtensions_fn, invokeExtensionsAsync_fn, addRestoreWorkflowView_fn, addNodeContextMenuHandler_fn, addNodeKeyHandler_fn, addDrawBackgroundHandler_fn, addDropHandler_fn, addPasteHandler_fn, addCopyHandler_fn, addProcessMouseHandler_fn, addProcessKeyHandler_fn, addDrawGroupsHandler_fn, addDrawNodeHandler_fn, addApiUpdateHandlers_fn, addKeyboardHandler_fn, addConfigureHandler_fn, addAfterConfigureHandler_fn, loadExtensions_fn, migrateSettings_fn, setUser_fn, formatPromptError_fn, formatExecutionError_fn;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node3 of mutation.addedNodes) {
        if (node3.tagName === "LINK" && node3.rel === "modulepreload")
          processPreload(node3);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getDefaultExportFromNamespaceIfPresent(n) {
  return n && Object.prototype.hasOwnProperty.call(n, "default") ? n["default"] : n;
}
function getDefaultExportFromNamespaceIfNotNamed(n) {
  return n && Object.prototype.hasOwnProperty.call(n, "default") && Object.keys(n).length === 1 ? n["default"] : n;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var _Reflect = {};
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect$1;
(function(Reflect2) {
  (function(factory) {
    var root27 = typeof globalThis === "object" ? globalThis : typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
    var exporter = makeExporter(Reflect2);
    if (typeof root27.Reflect !== "undefined") {
      exporter = makeExporter(root27.Reflect, exporter);
    }
    factory(exporter, root27);
    if (typeof root27.Reflect === "undefined") {
      root27.Reflect = Reflect2;
    }
    function makeExporter(target, previous) {
      return function(key, value3) {
        Object.defineProperty(target, key, { configurable: true, writable: true, value: value3 });
        if (previous)
          previous(key, value3);
      };
    }
    function functionThis() {
      try {
        return Function("return this;")();
      } catch (_2) {
      }
    }
    function indirectEvalThis() {
      try {
        return (void 0, eval)("(function() { return this; })()");
      } catch (_2) {
      }
    }
    function sloppyModeThis() {
      return functionThis() || indirectEvalThis();
    }
  })(function(exporter, root27) {
    var hasOwn2 = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map2, key) {
        return hasOwn2.call(map2, key);
      } : function(map2, key) {
        return key in map2;
      },
      get: downLevel ? function(map2, key) {
        return hasOwn2.call(map2, key) ? map2[key] : void 0;
      } : function(map2, key) {
        return map2[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
    var metadataRegistry = GetOrCreateMetadataRegistry();
    var metadataProvider = CreateMetadataProvider(metadataRegistry);
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var provider = GetMetadataProvider(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
        var decorator = decorators[i2];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn3 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn3)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn3 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn3)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return;
      return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*Create*/
        true
      );
      provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys2 = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys2;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys2;
      if (ownKeys2.length <= 0)
        return parentKeys;
      var set2 = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys2; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set2.has(key);
        if (!hasKey) {
          set2.add(key);
          keys.push(key);
        }
      }
      for (var _a2 = 0, parentKeys_1 = parentKeys; _a2 < parentKeys_1.length; _a2++) {
        var key = parentKeys_1[_a2];
        var hasKey = set2.has(key);
        if (!hasKey) {
          set2.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O, P) {
      var provider = GetMetadataProvider(
        O,
        P,
        /*create*/
        false
      );
      if (!provider) {
        return [];
      }
      return provider.OrdinaryOwnMetadataKeys(O, P);
    }
    function Type2(x2) {
      if (x2 === null)
        return 1;
      switch (typeof x2) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x2 === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x2) {
      return x2 === void 0;
    }
    function IsNull(x2) {
      return x2 === null;
    }
    function IsSymbol(x2) {
      return typeof x2 === "symbol";
    }
    function IsObject(x2) {
      return typeof x2 === "object" ? x2 !== null : typeof x2 === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type2(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type2(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function SameValueZero(x2, y2) {
      return x2 === y2 || x2 !== x2 && y2 !== y2;
    }
    function GetMethod(V, P) {
      var func = V[P];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f = iterator["return"];
      if (f)
        f.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMetadataRegistry() {
      var fallback;
      if (!IsUndefined(registrySymbol) && typeof root27.Reflect !== "undefined" && !(registrySymbol in root27.Reflect) && typeof root27.Reflect.defineMetadata === "function") {
        fallback = CreateFallbackProvider(root27.Reflect);
      }
      var first4;
      var second;
      var rest;
      var targetProviderMap = new _WeakMap();
      var registry = {
        registerProvider,
        getProvider,
        setProvider
      };
      return registry;
      function registerProvider(provider) {
        if (!Object.isExtensible(registry)) {
          throw new Error("Cannot add provider to a frozen registry.");
        }
        switch (true) {
          case fallback === provider:
            break;
          case IsUndefined(first4):
            first4 = provider;
            break;
          case first4 === provider:
            break;
          case IsUndefined(second):
            second = provider;
            break;
          case second === provider:
            break;
          default:
            if (rest === void 0)
              rest = new _Set();
            rest.add(provider);
            break;
        }
      }
      function getProviderNoCache(O, P) {
        if (!IsUndefined(first4)) {
          if (first4.isProviderFor(O, P))
            return first4;
          if (!IsUndefined(second)) {
            if (second.isProviderFor(O, P))
              return first4;
            if (!IsUndefined(rest)) {
              var iterator = GetIterator(rest);
              while (true) {
                var next2 = IteratorStep(iterator);
                if (!next2) {
                  return void 0;
                }
                var provider = IteratorValue(next2);
                if (provider.isProviderFor(O, P)) {
                  IteratorClose(iterator);
                  return provider;
                }
              }
            }
          }
        }
        if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
          return fallback;
        }
        return void 0;
      }
      function getProvider(O, P) {
        var providerMap = targetProviderMap.get(O);
        var provider;
        if (!IsUndefined(providerMap)) {
          provider = providerMap.get(P);
        }
        if (!IsUndefined(provider)) {
          return provider;
        }
        provider = getProviderNoCache(O, P);
        if (!IsUndefined(provider)) {
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O, providerMap);
          }
          providerMap.set(P, provider);
        }
        return provider;
      }
      function hasProvider(provider) {
        if (IsUndefined(provider))
          throw new TypeError();
        return first4 === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
      }
      function setProvider(O, P, provider) {
        if (!hasProvider(provider)) {
          throw new Error("Metadata provider not registered.");
        }
        var existingProvider = getProvider(O, P);
        if (existingProvider !== provider) {
          if (!IsUndefined(existingProvider)) {
            return false;
          }
          var providerMap = targetProviderMap.get(O);
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O, providerMap);
          }
          providerMap.set(P, provider);
        }
        return true;
      }
    }
    function GetOrCreateMetadataRegistry() {
      var metadataRegistry2;
      if (!IsUndefined(registrySymbol) && IsObject(root27.Reflect) && Object.isExtensible(root27.Reflect)) {
        metadataRegistry2 = root27.Reflect[registrySymbol];
      }
      if (IsUndefined(metadataRegistry2)) {
        metadataRegistry2 = CreateMetadataRegistry();
      }
      if (!IsUndefined(registrySymbol) && IsObject(root27.Reflect) && Object.isExtensible(root27.Reflect)) {
        Object.defineProperty(root27.Reflect, registrySymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: metadataRegistry2
        });
      }
      return metadataRegistry2;
    }
    function CreateMetadataProvider(registry) {
      var metadata2 = new _WeakMap();
      var provider = {
        isProviderFor: function(O, P) {
          var targetMetadata = metadata2.get(O);
          if (IsUndefined(targetMetadata))
            return false;
          return targetMetadata.has(P);
        },
        OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
        OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
        OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
        OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
        OrdinaryDeleteMetadata
      };
      metadataRegistry.registerProvider(provider);
      return provider;
      function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = metadata2.get(O);
        var createdTargetMetadata = false;
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          metadata2.set(O, targetMetadata);
          createdTargetMetadata = true;
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P, metadataMap);
          if (!registry.setProvider(O, P, provider)) {
            targetMetadata.delete(P);
            if (createdTargetMetadata) {
              metadata2.delete(O);
            }
            throw new Error("Wrong provider for target.");
          }
        }
        return metadataMap;
      }
      function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      function OrdinaryOwnMetadataKeys2(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
          var next2 = IteratorStep(iterator);
          if (!next2) {
            keys.length = k;
            return keys;
          }
          var nextValue = IteratorValue(next2);
          try {
            keys[k] = nextValue;
          } catch (e) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e;
            }
          }
          k++;
        }
      }
      function OrdinaryDeleteMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(MetadataKey))
          return false;
        if (metadataMap.size === 0) {
          var targetMetadata = metadata2.get(O);
          if (!IsUndefined(targetMetadata)) {
            targetMetadata.delete(P);
            if (targetMetadata.size === 0) {
              metadata2.delete(targetMetadata);
            }
          }
        }
        return true;
      }
    }
    function CreateFallbackProvider(reflect) {
      var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
      var metadataOwner = new _WeakMap();
      var provider = {
        isProviderFor: function(O, P) {
          var metadataPropertySet = metadataOwner.get(O);
          if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
            return true;
          }
          if (getOwnMetadataKeys2(O, P).length) {
            if (IsUndefined(metadataPropertySet)) {
              metadataPropertySet = new _Set();
              metadataOwner.set(O, metadataPropertySet);
            }
            metadataPropertySet.add(P);
            return true;
          }
          return false;
        },
        OrdinaryDefineOwnMetadata: defineMetadata2,
        OrdinaryHasOwnMetadata: hasOwnMetadata2,
        OrdinaryGetOwnMetadata: getOwnMetadata2,
        OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
        OrdinaryDeleteMetadata: deleteMetadata2
      };
      return provider;
    }
    function GetMetadataProvider(O, P, Create) {
      var registeredProvider = metadataRegistry.getProvider(O, P);
      if (!IsUndefined(registeredProvider)) {
        return registeredProvider;
      }
      if (Create) {
        if (metadataRegistry.setProvider(O, P, metadataProvider)) {
          return metadataProvider;
        }
        throw new Error("Illegal state.");
      }
      return void 0;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values2, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values2;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index2 = this._index;
            if (index2 >= 0 && index2 < this._keys.length) {
              var result = this._selector(this._keys[index2], this._values[index2]);
              if (index2 + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value3) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value: value3, done: true };
          };
          return MapIterator2;
        }()
      );
      var Map2 = (
        /** @class */
        function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index2 = this._find(
              key,
              /*insert*/
              false
            );
            return index2 >= 0 ? this._values[index2] : void 0;
          };
          Map3.prototype.set = function(key, value3) {
            var index2 = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index2] = value3;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index2 = this._find(
              key,
              /*insert*/
              false
            );
            if (index2 >= 0) {
              var size2 = this._keys.length;
              for (var i2 = index2 + 1; i2 < size2; i2++) {
                this._keys[i2 - 1] = this._keys[i2];
                this._values[i2 - 1] = this._values[i2];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue2);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert2) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i2 = 0; i2 < this._keys.length; i2++) {
                if (SameValueZero(this._keys[i2], key)) {
                  this._cacheIndex = i2;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert2) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map3;
        }()
      );
      return Map2;
      function getKey(key, _2) {
        return key;
      }
      function getValue2(_2, value3) {
        return value3;
      }
      function getEntry(key, value3) {
        return [key, value3];
      }
    }
    function CreateSetPolyfill() {
      var Set2 = (
        /** @class */
        function() {
          function Set3() {
            this._map = new _Map();
          }
          Object.defineProperty(Set3.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set3.prototype.has = function(value3) {
            return this._map.has(value3);
          };
          Set3.prototype.add = function(value3) {
            return this._map.set(value3, value3), this;
          };
          Set3.prototype.delete = function(value3) {
            return this._map.delete(value3);
          };
          Set3.prototype.clear = function() {
            this._map.clear();
          };
          Set3.prototype.keys = function() {
            return this._map.keys();
          };
          Set3.prototype.values = function() {
            return this._map.keys();
          };
          Set3.prototype.entries = function() {
            return this._map.entries();
          };
          Set3.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set3;
        }()
      );
      return Set2;
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table2 = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table2 !== void 0 ? HashMap.has(table2, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table2 = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table2 !== void 0 ? HashMap.get(table2, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value3) {
            var table2 = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table2[this._key] = value3;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table2 = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table2 !== void 0 ? delete table2[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create2) {
        if (!hasOwn2.call(target, rootKey)) {
          if (!create2)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer2, size2) {
        for (var i2 = 0; i2 < size2; ++i2)
          buffer2[i2] = Math.random() * 255 | 0;
        return buffer2;
      }
      function GenRandomBytes(size2) {
        if (typeof Uint8Array === "function") {
          var array = new Uint8Array(size2);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(array);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(array);
          } else {
            FillRandomBytes(array, size2);
          }
          return array;
        }
        return FillRandomBytes(new Array(size2), size2);
      }
      function CreateUUID() {
        var data28 = GenRandomBytes(UUID_SIZE);
        data28[6] = data28[6] & 79 | 64;
        data28[8] = data28[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data28[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect$1 || (Reflect$1 = {}));
window["__COMFYUI_FRONTEND_VERSION__"] = "1.2.23";
console.log("ComfyUI Front-end version:", "1.2.23");
/**
* @vue/shared v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
}
const EMPTY_OBJ = false ? Object.freeze({}) : {};
const EMPTY_ARR = false ? Object.freeze([]) : [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove$1 = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$2 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$3 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isDate$2 = (val) => toTypeString$1(val) === "[object Date]";
const isRegExp$1 = (val) => toTypeString$1(val) === "[object RegExp]";
const isFunction$3 = (val) => typeof val === "function";
const isString$4 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$4 = (val) => val !== null && typeof val === "object";
const isPromise$2 = (val) => {
  return (isObject$4(val) || isFunction$3(val)) && isFunction$3(val.then) && isFunction$3(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value3) => objectToString$1.call(value3);
const toRawType = (value3) => {
  return toTypeString$1(value3).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$4(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize$1(str)}` : ``;
  return s;
});
const hasChanged = (value3, oldValue) => !Object.is(value3, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](...arg);
  }
};
const def = (obj, key, value3, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value: value3
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$4(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "HOISTED": -1,
  "-1": "HOISTED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};
const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;
const range = 2;
function generateCodeFrame$1(source, start2 = 0, end = source.length) {
  start2 = Math.max(0, Math.min(start2, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start2 > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
  lines = lines.filter((_2, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i2 = 0; i2 < lines.length; i2++) {
    count += lines[i2].length + (newlineSequences[i2] && newlineSequences[i2].length || 0);
    if (count >= start2) {
      for (let j = i2 - range; j <= i2 + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i2) {
          const pad = start2 - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start2
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i2) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function normalizeStyle(value3) {
  if (isArray$3(value3)) {
    const res = {};
    for (let i2 = 0; i2 < value3.length; i2++) {
      const item = value3[i2];
      const normalized = isString$4(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$4(value3) || isObject$4(value3)) {
    return value3;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString$4(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value3 = styles[key];
    if (isString$4(value3) || typeof value3 === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      ret += `${normalizedKey}:${value3};`;
    }
  }
  return ret;
}
function normalizeClass(value3) {
  let res = "";
  if (isString$4(value3)) {
    res = value3;
  } else if (isArray$3(value3)) {
    for (let i2 = 0; i2 < value3.length; i2++) {
      const normalized = normalizeClass(value3[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$4(value3)) {
    for (const name in value3) {
      if (value3[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString$4(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value3) {
  return !!value3 || value3 === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
function isRenderableAttrValue(value3) {
  if (value3 == null) {
    return false;
  }
  const type = typeof value3;
  return type === "string" || type === "number" || type === "boolean";
}
const escapeRE = /["'&<>]/;
function escapeHtml$1(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index2;
  let lastIndex = 0;
  for (index2 = match.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str.slice(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escaped;
  }
  return lastIndex !== index2 ? html + str.slice(lastIndex, index2) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a.length; i2++) {
    equal = looseEqual(a[i2], b[i2]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate$2(a);
  let bValidType = isDate$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol$1(a);
  bValidType = isSymbol$1(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$3(a);
  bValidType = isArray$3(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$4(a);
  bValidType = isObject$4(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val.__v_isRef === true);
};
const toDisplayString$1 = (val) => {
  return isString$4(val) ? val : val == null ? "" : isArray$3(val) || isObject$4(val) && (val.toString === objectToString$1 || !isFunction$3(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i2) => {
          entries[stringifySymbol(key, i2) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol$1(val)) {
    return stringifySymbol(val);
  } else if (isObject$4(val) && !isArray$3(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i2 = "") => {
  var _a2;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol$1(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i2})` : v2
  );
};
/**
* @vue/reactivity v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function warn$3(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (false) {
      warn$3(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l;
      for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (false) {
    warn$3(
      `onScopeDispose() is called when there is no active effect scope to be associated with.`
    );
  }
}
let activeEffect;
class ReactiveEffect {
  constructor(fn, trigger2, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i2 = 0; i2 < this._depsLength; i2++) {
        const dep = this.deps[i2];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v2) {
    this._dirtyLevel = v2 ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      this.onStop && this.onStop();
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
      cleanupDepEffect(effect2.deps[i2], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
function effect(fn, options3) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn, NOOP, () => {
    if (_effect.dirty) {
      _effect.run();
    }
  });
  if (options3) {
    extend(_effect, options3);
    if (options3.scope) recordEffectScope(_effect, options3.scope);
  }
  if (!options3 || !options3.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  var _a2;
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
    if (false) {
      (_a2 = effect2.onTrack) == null ? void 0 : _a2.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
    }
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  var _a2;
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      if (false) {
        (_a2 = effect2.onTrigger) == null ? void 0 : _a2.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
      }
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
const createDep = (cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(false ? "iterate" : "");
const MAP_KEY_ITERATE_KEY = Symbol(false ? "Map key iterate" : "");
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep,
      false ? {
        target,
        type,
        key
      } : void 0
    );
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$3(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4,
        false ? {
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        } : void 0
      );
    }
  }
  resetScheduling();
}
function getDepFromReactive(object, key) {
  const depsMap = targetMap.get(object);
  return depsMap && depsMap.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l = this.length; i2 < l; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  if (!isSymbol$1(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$3(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$2(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value3, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value3) && !isReadonly(value3)) {
        oldValue = toRaw(oldValue);
        value3 = toRaw(value3);
      }
      if (!isArray$3(target) && isRef(oldValue) && !isRef(value3)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value3;
          return true;
        }
      }
    }
    const hadKey = isArray$3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$2(target, key);
    const result = Reflect.set(target, key, value3, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value3);
      } else if (hasChanged(value3, oldValue)) {
        trigger(target, "set", key, value3, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$2(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$3(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (false) {
      warn$3(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (false) {
      warn$3(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value3) => value3;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value3) {
  value3 = toRaw(value3);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value3);
  if (!hadKey) {
    target.add(value3);
    trigger(target, "add", value3, value3);
  }
  return this;
}
function set$1(key, value3) {
  value3 = toRaw(value3);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value3);
  if (!hadKey) {
    trigger(target, "add", key, value3);
  } else if (hasChanged(value3, oldValue)) {
    trigger(target, "set", key, value3, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = false ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value3, key) => {
      return callback.call(thisArg, wrap(value3), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value3, done } = innerIterator.next();
        return done ? { value: value3, done } : {
          value: isPair ? [wrap(value3[0]), wrap(value3[1])] : wrap(value3),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (false) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn$3(
        `${capitalize$1(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$2(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    warn$3(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value3) {
  return value3["__v_skip"] || !Object.isExtensible(value3) ? 0 : targetTypeMap(toRawType(value3));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target)) {
    if (false) {
      warn$3(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value3) {
  if (isReadonly(value3)) {
    return isReactive(value3["__v_raw"]);
  }
  return !!(value3 && value3["__v_isReactive"]);
}
function isReadonly(value3) {
  return !!(value3 && value3["__v_isReadonly"]);
}
function isShallow(value3) {
  return !!(value3 && value3["__v_isShallow"]);
}
function isProxy(value3) {
  return value3 ? !!value3["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value3) {
  if (Object.isExtensible(value3)) {
    def(value3, "__v_skip", true);
  }
  return value3;
}
const toReactive = (value3) => isObject$4(value3) ? reactive(value3) : value3;
const toReadonly = (value3) => isObject$4(value3) ? readonly(value3) : value3;
const COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      if (false) {
        warn$3(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
      }
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v2) {
    this.effect.dirty = v2;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$3(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = false ? () => {
      warn$3("Write operation failed: computed value is readonly");
    } : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (false) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
function trackRefValue(ref2) {
  var _a2;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      ),
      false ? {
        target: ref2,
        type: "get",
        key: "value"
      } : void 0
    );
  }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel,
      false ? {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal,
        oldValue: oldVal
      } : void 0
    );
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value3) {
  return createRef(value3, false);
}
function shallowRef(value3) {
  return createRef(value3, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value3, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value3 : toRaw(value3);
    this._value = __v_isShallow ? value3 : toReactive(value3);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      const oldVal = this._rawValue;
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, 4, newVal, oldVal);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2, 4, false ? ref2.value : void 0);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue$1(source) {
  return isFunction$3(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value3, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value3)) {
      oldValue.value = value3;
      return true;
    } else {
      return Reflect.set(target, key, value3, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if (false) {
    warn$3(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray$3(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$3(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$4(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
const deferredComputed = computed$1;
const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw"
};
/**
* @vue/runtime-core v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a2, _b;
          return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last2 = normalizedStack[0];
    if (last2 && last2.vnode === currentVNode) {
      last2.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open2 = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close4 = `>` + postfix;
  return vnode.props ? [open2, ...formatProps(vnode.props), close4] : [open2 + close4];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value3, raw) {
  if (isString$4(value3)) {
    value3 = JSON.stringify(value3);
    return raw ? value3 : [`${key}=${value3}`];
  } else if (typeof value3 === "number" || typeof value3 === "boolean" || value3 == null) {
    return raw ? value3 : [`${key}=${value3}`];
  } else if (isRef(value3)) {
    value3 = formatProp(key, toRaw(value3.value), true);
    return raw ? value3 : [`${key}=Ref<`, value3, `>`];
  } else if (isFunction$3(value3)) {
    return [`${key}=fn${value3.name ? `<${value3.name}>` : ``}`];
  } else {
    value3 = toRaw(value3);
    return raw ? value3 : [`${key}=`, value3];
  }
}
function assertNumber(val, type) {
  if (true) return;
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$1(`${type} is NaN - the duration expression might be incorrect.`);
  }
}
const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "WATCH_GETTER": 2,
  "2": "WATCH_GETTER",
  "WATCH_CALLBACK": 3,
  "3": "WATCH_CALLBACK",
  "WATCH_CLEANUP": 4,
  "4": "WATCH_CLEANUP",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$3(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$2(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$3(fn)) {
    const values2 = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values2.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
    }
    return values2;
  } else if (false) {
    warn$1(
      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
    );
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = false ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      pauseTracking();
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (false) {
    const info = ErrorTypeStrings$1[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start2 = flushIndex + 1;
  let end = queue.length;
  while (start2 < end) {
    const middle = start2 + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
      start2 = middle + 1;
    } else {
      end = middle;
    }
  }
  return start2;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$3(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  if (false) {
    seen2 = seen2 || /* @__PURE__ */ new Map();
  }
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      if (false) {
        continue;
      }
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (false) {
      seen2 = seen2 || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (false) {
        continue;
      }
      if (cb.active !== false) cb();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre) return -1;
    if (b.pre && !a.pre) return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  if (false) {
    seen2 = seen2 || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = false ? (job) => checkRecursiveUpdates(seen2, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen2);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen2);
    }
  }
}
function checkRecursiveUpdates(seen2, fn) {
  if (!seen2.has(fn)) {
    seen2.set(fn, 1);
  } else {
    const count = seen2.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    } else {
      seen2.set(fn, count + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
if (false) {
  getGlobalThis$1().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id2 = instance.type.__hmrId;
  let record = map.get(id2);
  if (!record) {
    createRecord(id2, instance.type);
    record = map.get(id2);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id2, initialDef) {
  if (map.has(id2)) {
    return false;
  }
  map.set(id2, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id2, newRender) {
  const record = map.get(id2);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.effect.dirty = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id2, newComp) {
  const record = map.get(id2);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      instance.parent.effect.dirty = true;
      queueJob(() => {
        instance.parent.update();
        hmrDirtyComponents.delete(oldComp);
      });
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(
        normalizeClassComponent(instance.type)
      );
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id2, arg) => {
    try {
      return fn(id2, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}
let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event2, ...args) {
  if (devtools$1) {
    devtools$1.emit(event2, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event: event2, args });
  }
}
function setDevtoolsHook$1(hook, target) {
  var _a2, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event: event2, args }) => devtools$1.emit(event2, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app2, version2) {
  emit$1("app:init", app2, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app2) {
  emit$1("app:unmount", app2);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added"
  /* COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:updated"
  /* COMPONENT_UPDATED */
);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed"
  /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:start"
  /* PERFORMANCE_START */
);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:end"
  /* PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event2, params) {
  emit$1(
    "component:emit",
    component.appContext.app,
    component,
    event2,
    params
  );
}
function emit(instance, event2, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  if (false) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event2 in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event2) in propsOptions)) {
          warn$1(
            `Component emitted event "${event2}" but it is neither declared in the emits option nor as an "${toHandlerKey(event2)}" prop.`
          );
        }
      } else {
        const validator2 = emitsOptions[event2];
        if (isFunction$3(validator2)) {
          const isValid2 = validator2(...rawArgs);
          if (!isValid2) {
            warn$1(
              `Invalid event arguments: event validation failed for event "${event2}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event2.startsWith("update:");
  const modelArg = isModelListener2 && event2.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString$4(a) ? a.trim() : a);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (false) {
    devtoolsComponentEmit(instance, event2, args);
  }
  if (false) {
    const lowerCaseEvent = event2.toLowerCase();
    if (lowerCaseEvent !== event2 && props[toHandlerKey(lowerCaseEvent)]) {
      warn$1(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event2}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
          event2
        )}" instead of "${event2}".`
      );
    }
  }
  let handlerName;
  let handler8 = props[handlerName = toHandlerKey(event2)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event2))];
  if (!handler8 && isModelListener2) {
    handler8 = props[handlerName = toHandlerKey(hyphenate(event2))];
  }
  if (handler8) {
    callWithAsyncErrorHandling(
      handler8,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$3(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$4(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options3, key) {
  if (!options3 || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$2(options3, key[0].toLowerCase() + key.slice(1)) || hasOwn$2(options3, hyphenate(key)) || hasOwn$2(options3, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev2 = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev2;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id2) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (false) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs: attrs3,
    emit: emit2,
    render: render3,
    renderCache,
    props,
    data: data28,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev2 = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  if (false) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render3.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data28,
          ctx
        )
      );
      fallthroughAttrs = attrs3;
    } else {
      const render22 = Component;
      if (false) {
        markAttrsAccessed();
      }
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs3);
            },
            slots,
            emit: emit2
          } : { attrs: attrs3, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs3 : getFunctionalFallthrough(attrs3);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root27 = result;
  let setRoot = void 0;
  if (false) {
    [root27, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root27;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root27 = cloneVNode(root27, fallthroughAttrs, false, true);
      } else if (false) {
        const allAttrs = Object.keys(attrs3);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i2 = 0, l = allAttrs.length; i2 < l; i2++) {
          const key = allAttrs[i2];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$1(
            `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
          );
        }
        if (eventAttrs.length) {
          warn$1(
            `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
          );
        }
      }
    }
  }
  if (vnode.dirs) {
    if (false) {
      warn$1(
        `Runtime directive used on component with non-element root node. The directives will not function as intended.`
      );
    }
    root27 = cloneVNode(root27, null, false, true);
    root27.dirs = root27.dirs ? root27.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (false) {
      warn$1(
        `Component inside <Transition> renders non-element root node that cannot be animated.`
      );
    }
    root27.transition = vnode.transition;
  }
  if (false) {
    setRoot(root27);
  } else {
    result = root27;
  }
  setCurrentRenderingInstance(prev2);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren, false);
  if (!childRoot) {
    return [vnode, void 0];
  } else if (false) {
    return getChildRoot(childRoot);
  }
  const index2 = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index2] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode$1(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
          if (false) {
            return filterSingleRoot(singleRoot.children);
          }
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs3) => {
  let res;
  for (const key in attrs3) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs3[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs3, props) => {
  const res = {};
  for (const key in attrs3) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs3[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (false) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root27 = parent.subTree;
    if (root27.suspense && root27.suspense.activeBranch === vnode) {
      root27.el = vnode.el;
    }
    if (root27 === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$4(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve$1(instance[type] || Component[type], name) || // global registration
      resolve$1(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (false) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else if (false) {
    warn$1(
      `resolve${capitalize$1(type.slice(0, -1))} can only be used in render() or setup().`
    );
  }
}
function resolve$1(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$3(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement: createElement2 }
  } = rendererInternals;
  const hiddenContainer = createElement2("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement: createElement2 } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement2("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned$1 = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if (false) {
    hasWarned$1 = true;
    console[console.info ? "info" : "log"](
      `<Suspense> is an experimental feature and its API will likely change.`
    );
  }
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next2,
    o: { parentNode, remove: remove22 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  if (false) {
    assertNumber(timeout, `Suspense timeout`);
  }
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (false) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(
            `suspense.resolve() is called without a pending branch.`
          );
        }
        if (suspense.isUnmounted) {
          throw new Error(
            `suspense.resolve() is called on an already unmounted suspense boundary.`
          );
        }
      }
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next2(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
            anchor = next2(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next2(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next2(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        if (false) {
          pushWarningContext(vnode2);
        }
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next2(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove22(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (false) {
          popWarningContext();
        }
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node3, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node3.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node3,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block2;
  if (isFunction$3(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block2 = currentBlock;
      closeBlock();
    }
  }
  if (isArray$3(s)) {
    const singleChild = filterSingleRoot(s);
    if (false) {
      warn$1(`<Suspense> slots expect a single root node.`);
    }
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block2 && !s.dynamicChildren) {
    s.dynamicChildren = block2.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$3(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (false) {
    const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
    warn$1(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const createHook = (lifecycle2) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle2 === "sp") {
    injectHook(lifecycle2, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value3, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$3(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value3);
      }
      bindings.push({
        dir,
        instance,
        value: value3,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray$3(source) || isString$4(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l = source.length; i2 < l; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    if (false) {
      warn$1(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$4(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i2 = 0, l = keys.length; i2 < l; i2++) {
        const key = keys[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray$3(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options3, extraOptions) {
  return isFunction$3(options3) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options3.name }, extraOptions, { setup: options3 }))()
  ) : options3;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction$3(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load2();
  };
  const load2 = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve22, reject2) => {
          const userRetry = () => resolve22(retry());
          const userFail = () => reject2(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (false) {
        warn$1(
          `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
        );
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (false) {
        throw new Error(`Invalid async component load result: ${comp}`);
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load2,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load2().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load2().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.effect.dirty = true;
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref22, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref22;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default") props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (false) {
    warn$1(
      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
    );
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if (false) {
    warn$1(`v-on with no argument expects an object value.`);
    return ret;
  }
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i2) => {
  if (!i2) return null;
  if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => false ? shallowReadonly(i2.props) : i2.props,
    $attrs: (i2) => false ? shallowReadonly(i2.attrs) : i2.attrs,
    $slots: (i2) => false ? shallowReadonly(i2.slots) : i2.slots,
    $refs: (i2) => false ? shallowReadonly(i2.refs) : i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $emit: (i2) => i2.emit,
    $options: (i2) => true ? resolveMergedOptions(i2) : i2.type,
    $forceUpdate: (i2) => i2.f || (i2.f = () => {
      i2.effect.dirty = true;
      queueJob(i2.update);
    }),
    $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
    $watch: (i2) => true ? instanceWatch.bind(i2) : NOOP
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$2(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data: data28, props, accessCache, type, appContext } = instance;
    if (false) {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data28[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data28 !== EMPTY_OBJ && hasOwn$2(data28, key)) {
        accessCache[key] = 2;
        return data28[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$2(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      } else if (false) {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$2(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (false) {
      if (data28 !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn$2(data28, key)) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn$1(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value3) {
    const { data: data28, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value3;
      return true;
    } else if (false) {
      warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data28 !== EMPTY_OBJ && hasOwn$2(data28, key)) {
      data28[key] = value3;
      return true;
    } else if (hasOwn$2(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      if (false) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value: value3
        });
      } else {
        ctx[key] = value3;
      }
    }
    return true;
  },
  has({
    _: { data: data28, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data28 !== EMPTY_OBJ && hasOwn$2(data28, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$2(normalizedProps, key) || hasOwn$2(ctx, key) || hasOwn$2(publicPropertiesMap, key) || hasOwn$2(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$2(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (false) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend(
  {},
  PublicInstanceProxyHandlers,
  {
    get(target, key) {
      if (key === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_2, key) {
      const has2 = key[0] !== "_" && !isGloballyAllowed(key);
      if (false) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} should not start with _ which is a reserved prefix for Vue internals.`
        );
      }
      return has2;
    }
  }
);
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
const warnRuntimeUsage = (method) => warn$1(
  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function defineProps() {
  if (false) {
    warnRuntimeUsage(`defineProps`);
  }
  return null;
}
function defineEmits() {
  if (false) {
    warnRuntimeUsage(`defineEmits`);
  }
  return null;
}
function defineExpose(exposed) {
  if (false) {
    warnRuntimeUsage(`defineExpose`);
  }
}
function defineOptions(options3) {
  if (false) {
    warnRuntimeUsage(`defineOptions`);
  }
}
function defineSlots() {
  if (false) {
    warnRuntimeUsage(`defineSlots`);
  }
  return null;
}
function defineModel() {
  if (false) {
    warnRuntimeUsage("defineModel");
  }
}
function withDefaults(props, defaults) {
  if (false) {
    warnRuntimeUsage(`withDefaults`);
  }
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i2 = getCurrentInstance();
  if (false) {
    warn$1(`useContext() called without active instance.`);
  }
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function normalizePropsOrEmits(props) {
  return isArray$3(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if (isArray$3(opt) || isFunction$3(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else if (false) {
      warn$1(`props default key "${key}" has no corresponding declaration.`);
    }
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if (isArray$3(a) && isArray$3(b)) return a.concat(b);
  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if (false) {
    warn$1(
      `withAsyncContext called without active current instance. This is likely a bug.`
    );
  }
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise$2(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function createDuplicateChecker() {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache2[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache2[key]}.`);
    } else {
      cache2[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options3 = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options3.beforeCreate) {
    callHook$1(options3.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created: created3,
    beforeMount: beforeMount4,
    mounted: mounted24,
    beforeUpdate: beforeUpdate2,
    updated: updated13,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount: beforeUnmount15,
    destroyed,
    unmounted: unmounted7,
    render: render3,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options3;
  const checkDuplicateProperties = false ? createDuplicateChecker() : null;
  if (false) {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$3(methodHandler)) {
        if (false) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (false) {
          checkDuplicateProperties("Methods", key);
        }
      } else if (false) {
        warn$1(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if (false) {
      warn$1(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data28 = dataOptions.call(publicThis, publicThis);
    if (false) {
      warn$1(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!isObject$4(data28)) {
    } else {
      instance.data = reactive(data28);
      if (false) {
        for (const key in data28) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data28[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (false) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : false ? () => {
        warn$1(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      } : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v2) => c.value = v2
      });
      if (false) {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created3) {
    callHook$1(created3, instance, "c");
  }
  function registerLifecycleHook(register3, hook) {
    if (isArray$3(hook)) {
      hook.forEach((_hook3) => register3(_hook3.bind(publicThis)));
    } else if (hook) {
      register3(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount4);
  registerLifecycleHook(onMounted, mounted24);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate2);
  registerLifecycleHook(onUpdated, updated13);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount15);
  registerLifecycleHook(onUnmounted, unmounted7);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$3(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render3 && instance.render === NOOP) {
    instance.render = render3;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$3(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$4(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
    if (false) {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$3(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$4(raw)) {
    const handler8 = ctx[raw];
    if (isFunction$3(handler8)) {
      watch(getter, handler8);
    } else if (false) {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler8);
    }
  } else if (isFunction$3(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$4(raw)) {
    if (isArray$3(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler8 = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$3(handler8)) {
        watch(getter, handler8, raw);
      } else if (false) {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler8);
      }
    }
  } else if (false) {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$4(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$3(to) ? to.call(this, this) : to,
      isFunction$3(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$3(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$3(to) && isArray$3(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render3, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$3(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$4(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
        if (false) {
          warn$1(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin, ...options3) {
        if (installedPlugins.has(plugin)) {
        } else if (plugin && isFunction$3(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options3);
        } else if (isFunction$3(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options3);
        } else if (false) {
          warn$1(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app2;
      },
      mixin(mixin) {
        if (true) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (false) {
            warn$1(
              "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
            );
          }
        } else if (false) {
          warn$1("Mixins are only available in builds supporting Options API");
        }
        return app2;
      },
      component(name, component) {
        if (false) {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (false) {
          warn$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (false) {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (false) {
          warn$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          if (false) {
            warn$1(
              `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
            );
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (false) {
            context.reload = () => {
              render3(
                cloneVNode(vnode),
                rootContainer,
                namespace
              );
            };
          }
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render3(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          if (false) {
            app2._instance = vnode.component;
            devtoolsInitApp(app2, version);
          }
          return getComponentPublicInstance(vnode.component);
        } else if (false) {
          warn$1(
            `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
          );
        }
      },
      unmount() {
        if (isMounted) {
          render3(null, app2._container);
          if (false) {
            app2._instance = null;
            devtoolsUnmountApp(app2);
          }
          delete app2._container.__vue_app__;
        } else if (false) {
          warn$1(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value3) {
        if (false) {
          warn$1(
            `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
          );
        }
        context.provides[key] = value3;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value3) {
  if (!currentInstance) {
    if (false) {
      warn$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value3;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (false) {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else if (false) {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful3, isSSR = false) {
  const props = {};
  const attrs3 = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs3);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (false) {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful3) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs3;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs3;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId) return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs: attrs3,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options3] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value3 = rawProps[key];
        if (options3) {
          if (hasOwn$2(attrs3, key)) {
            if (value3 !== attrs3[key]) {
              attrs3[key] = value3;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options3,
              rawCurrentProps,
              camelizedKey,
              value3,
              instance,
              false
            );
          }
        } else {
          if (value3 !== attrs3[key]) {
            attrs3[key] = value3;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs3)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$2(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$2(rawProps, kebabKey))) {
        if (options3) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options3,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs3 !== rawCurrentProps) {
      for (const key in attrs3) {
        if (!rawProps || !hasOwn$2(rawProps, key) && true) {
          delete attrs3[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
  if (false) {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs3) {
  const [options3, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value3 = rawProps[key];
      let camelKey;
      if (options3 && hasOwn$2(options3, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value3;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value3;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs3) || value3 !== attrs3[key]) {
          attrs3[key] = value3;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options3,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$2(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options3, props, key, value3, instance, isAbsent) {
  const opt = options3[key];
  if (opt != null) {
    const hasDefault = hasOwn$2(opt, "default");
    if (hasDefault && value3 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$3(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value3 = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value3 = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value3 = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value3 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value3 === "" || value3 === hyphenate(key))) {
        value3 = true;
      }
    }
  }
  return value3;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$3(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      if (false) {
        warn$1(`props must be strings when using array syntax.`, raw[i2]);
      }
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (false) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop2 = normalized[normalizedKey] = isArray$3(opt) || isFunction$3(opt) ? { type: opt } : extend({}, opt);
        if (prop2) {
          const booleanIndex = getTypeIndex(Boolean, prop2.type);
          const stringIndex = getTypeIndex(String, prop2.type);
          prop2[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop2[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$2(prop2, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$4(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  } else if (false) {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$3(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$3(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options3 = instance.propsOptions[0];
  for (const key in options3) {
    let opt = options3[key];
    if (opt == null) continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
      false ? shallowReadonly(resolvedValues) : resolvedValues,
      !hasOwn$2(rawProps, key) && !hasOwn$2(rawProps, hyphenate(key))
    );
  }
}
function validateProp(name, value3, prop2, props, isAbsent) {
  const { type, required, validator: validator2, skipCheck } = prop2;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value3 == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid2 = false;
    const types = isArray$3(type) ? type : [type];
    const expectedTypes = [];
    for (let i2 = 0; i2 < types.length && !isValid2; i2++) {
      const { valid, expectedType } = assertType(value3, types[i2]);
      expectedTypes.push(expectedType || "");
      isValid2 = valid;
    }
    if (!isValid2) {
      warn$1(getInvalidTypeMessage(name, value3, expectedTypes));
      return;
    }
  }
  if (validator2 && !validator2(value3, props)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function assertType(value3, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value3;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value3 instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$4(value3);
  } else if (expectedType === "Array") {
    valid = isArray$3(value3);
  } else if (expectedType === "null") {
    valid = value3 === null;
  } else {
    valid = value3 instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value3, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message3 = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize$1).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value3);
  const expectedValue = styleValue(value3, expectedType);
  const receivedValue = styleValue(value3, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean$2(expectedType, receivedType)) {
    message3 += ` with value ${expectedValue}`;
  }
  message3 += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message3 += `with value ${receivedValue}.`;
  }
  return message3;
}
function styleValue(value3, type) {
  if (type === "String") {
    return `"${value3}"`;
  } else if (type === "Number") {
    return `${Number(value3)}`;
  } else {
    return `${value3}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean$2(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value3) => isArray$3(value3) ? value3.map(normalizeVNode) : [normalizeVNode(value3)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) {
      warn$1(
        `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
      );
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value3 = rawSlots[key];
    if (isFunction$3(value3)) {
      slots[key] = normalizeSlot(key, value3, ctx);
    } else if (value3 != null) {
      if (false) {
        warn$1(
          `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(value3);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if (false) {
    warn$1(
      `Non-function value encountered for default slot. Prefer function slots for better performance.`
    );
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      extend(slots, children);
      def(slots, "_", type, true);
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (false) {
        extend(slots, children);
        trigger(instance, "set", "$slots");
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$3(rawRef)) {
    rawRef.forEach(
      (r, i2) => setRef(
        r,
        oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value3 = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  if (false) {
    warn$1(
      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
    );
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref3) {
    if (isString$4(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$2(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$3(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value3, refs]);
  } else {
    const _isString = isString$4(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$2(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$3(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$3(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (hasOwn$2(setupState, ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value3;
          if (hasOwn$2(setupState, ref3)) {
            setupState[ref3] = value3;
          }
        } else if (_isRef) {
          ref3.value = value3;
          if (rawRef.k) refs[rawRef.k] = value3;
        } else if (false) {
          warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
        }
      };
      if (value3) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (false) {
      warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
    }
  }
}
let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
};
const isComment = (node3) => node3.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove22,
      insert: insert2,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node3) && node3.data === "[";
    const onMismatch = () => handleMismatch(
      node3,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref: ref3, shapeFlag, patchFlag } = vnode;
    let domType = node3.nodeType;
    vnode.el = node3;
    if (false) {
      def(node3, "__vnode", vnode, true);
      def(node3, "__vueParentComponent", parentComponent, true);
    }
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert2(vnode.el = createText(""), parentNode(node3), node3);
            nextNode = node3;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node3.data !== vnode.children) {
            logMismatchError();
            node3.data = vnode.children;
          }
          nextNode = nextSibling(node3);
        }
        break;
      case Comment:
        if (isTemplateNode(node3)) {
          nextNode = nextSibling(node3);
          replaceNode(
            vnode.el = node3.content.firstChild,
            node3,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node3);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node3 = nextSibling(node3);
          domType = node3.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node3;
          const needToAdoptContent = !vnode.children.length;
          for (let i2 = 0; i2 < vnode.staticCount; i2++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i2 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node3,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node3.tagName.toLowerCase()) && !isTemplateNode(node3)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node3,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node3);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node3);
          } else if (isComment(node3) && node3.data === "teleport start") {
            nextNode = locateClosingAnchor(node3, node3.data, "teleport end");
          } else {
            nextNode = nextSibling(node3);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node3.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node3;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node3,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node3,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node3)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else if (false) {
          warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next2 = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        let hasWarned2 = false;
        while (next2) {
          if (false) {
            warn$1(
              `Hydration children mismatch on`,
              el,
              `
Server rendered element contains more child nodes than client vdom.`
            );
            hasWarned2 = true;
          }
          logMismatchError();
          const cur = next2;
          next2 = next2.nextSibling;
          remove22(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          logMismatchError();
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (forcePatch || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (false) {
              logMismatchError();
            }
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === ".") {
              patchProp2(
                el,
                key,
                null,
                props[key],
                void 0,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node3, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned2 = false;
    for (let i2 = 0; i2 < l; i2++) {
      const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
      if (node3) {
        node3 = hydrateNode(
          node3,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text && !vnode.children) {
        insert2(vnode.el = createText(""), container);
      } else {
        if (false) {
          warn$1(
            `Hydration children mismatch on`,
            container,
            `
Server rendered element contains fewer child nodes than client vdom.`
          );
          hasWarned2 = true;
        }
        logMismatchError();
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node3;
  };
  const hydrateFragment = (node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node3);
    const next2 = hydrateChildren(
      nextSibling(node3),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next2 && isComment(next2) && next2.data === "]") {
      return nextSibling(vnode.anchor = next2);
    } else {
      logMismatchError();
      insert2(vnode.anchor = createComment(`]`), container, next2);
      return next2;
    }
  };
  const handleMismatch = (node3, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    logMismatchError();
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node3);
      while (true) {
        const next22 = nextSibling(node3);
        if (next22 && next22 !== end) {
          remove22(next22);
        } else {
          break;
        }
      }
    }
    const next2 = nextSibling(node3);
    const container = parentNode(node3);
    remove22(node3);
    patch(
      null,
      vnode,
      container,
      next2,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    return next2;
  };
  const locateClosingAnchor = (node3, open2 = "[", close4 = "]") => {
    let match = 0;
    while (node3) {
      node3 = nextSibling(node3);
      if (node3 && isComment(node3)) {
        if (node3.data === open2) match++;
        if (node3.data === close4) {
          if (match === 0) {
            return nextSibling(node3);
          } else {
            match--;
          }
        }
      }
    }
    return node3;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node3) => {
    return node3.nodeType === 1 && node3.tagName.toLowerCase() === "template";
  };
  return [hydrate2, hydrateNode];
}
function propHasMismatch(el, key, clientValue, vnode, instance) {
  let mismatchType;
  let mismatchKey;
  let actual;
  let expected;
  if (key === "class") {
    actual = el.getAttribute("class");
    expected = normalizeClass(clientValue);
    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
      mismatchType = mismatchKey = `class`;
    }
  } else if (key === "style") {
    actual = el.getAttribute("style") || "";
    expected = isString$4(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));
    const actualMap = toStyleMap(actual);
    const expectedMap = toStyleMap(expected);
    if (vnode.dirs) {
      for (const { dir, value: value3 } of vnode.dirs) {
        if (dir.name === "show" && !value3) {
          expectedMap.set("display", "none");
        }
      }
    }
    if (instance) {
      resolveCssVars(instance, vnode, expectedMap);
    }
    if (!isMapEqual(actualMap, expectedMap)) {
      mismatchType = mismatchKey = "style";
    }
  } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {
    if (isBooleanAttr(key)) {
      actual = el.hasAttribute(key);
      expected = includeBooleanAttr(clientValue);
    } else if (clientValue == null) {
      actual = el.hasAttribute(key);
      expected = false;
    } else {
      if (el.hasAttribute(key)) {
        actual = el.getAttribute(key);
      } else if (key === "value" && el.tagName === "TEXTAREA") {
        actual = el.value;
      } else {
        actual = false;
      }
      expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;
    }
    if (actual !== expected) {
      mismatchType = `attribute`;
      mismatchKey = key;
    }
  }
  if (mismatchType) {
    const format2 = (v2) => v2 === false ? `(not rendered)` : `${mismatchKey}="${v2}"`;
    const preSegment = `Hydration ${mismatchType} mismatch on`;
    const postSegment = `
  - rendered on server: ${format2(actual)}
  - expected on client: ${format2(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    {
      warn$1(preSegment, el, postSegment);
    }
    return true;
  }
  return false;
}
function toClassSet(str) {
  return new Set(str.trim().split(/\s+/));
}
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const s of a) {
    if (!b.has(s)) {
      return false;
    }
  }
  return true;
}
function toStyleMap(str) {
  const styleMap = /* @__PURE__ */ new Map();
  for (const item of str.split(";")) {
    let [key, value3] = item.split(":");
    key = key.trim();
    value3 = value3 && value3.trim();
    if (key && value3) {
      styleMap.set(key, value3);
    }
  }
  return styleMap;
}
function isMapEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value3] of a) {
    if (value3 !== b.get(key)) {
      return false;
    }
  }
  return true;
}
function resolveCssVars(instance, vnode, expectedMap) {
  const root27 = instance.subTree;
  if (instance.getCssVars && (vnode === root27 || root27 && root27.type === Fragment && root27.children.includes(vnode))) {
    const cssVars = instance.getCssVars();
    for (const key in cssVars) {
      expectedMap.set(`--${key}`, String(cssVars[key]));
    }
  }
  if (vnode === root27 && instance.parent) {
    resolveCssVars(instance.parent, instance.vnode, expectedMap);
  }
}
let supported$1;
let perf$1;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf$1.mark(`vue-${type}-${instance.uid}`);
  }
  if (false) {
    devtoolsPerfStart(instance, type, isSupported() ? perf$1.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf$1.mark(endTag);
    perf$1.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf$1.clearMarks(startTag);
    perf$1.clearMarks(endTag);
  }
  if (false) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf$1.now() : Date.now());
  }
}
function isSupported() {
  if (supported$1 !== void 0) {
    return supported$1;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported$1 = true;
    perf$1 = window.performance;
  } else {
    supported$1 = false;
  }
  return supported$1;
}
function initFeatureFlags$2() {
  const needWarn = [];
  if (false) {
    getGlobalThis$1().__VUE_OPTIONS_API__ = true;
  }
  if (false) {
    getGlobalThis$1().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (false) {
    getGlobalThis$1().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
  if (false) {
    const multi = needWarn.length > 1;
    console.warn(
      `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options3) {
  return baseCreateRenderer(options3);
}
function createHydrationRenderer(options3) {
  return baseCreateRenderer(options3, createHydrationFunctions);
}
function baseCreateRenderer(options3, createHydrationFns) {
  {
    initFeatureFlags$2();
  }
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  if (false) {
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options3;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = false ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        } else if (false) {
          patchStaticNode(n1, n2, container, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (false) {
          warn$1("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const patchStaticNode = (n1, n2, container, namespace) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace
      );
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next2;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostRemove(el);
      el = next2;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (false) {
      def(el, "__vnode", vnode, true);
      def(el, "__vueParentComponent", parentComponent, true);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (false) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    if (false) {
      el.__vnode = n2;
    }
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
      if (false) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev2 = oldProps[key];
            const next2 = newProps[key];
            if (next2 !== prev2 || key === "value") {
              hostPatchProp(
                el,
                key,
                prev2,
                next2,
                namespace,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        namespace
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next2 = newProps[key];
        const prev2 = oldProps[key];
        if (next2 !== prev2 && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev2,
            next2,
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (false) {
          traverseStaticChildren(n1, n2);
        } else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (false) {
      registerHMR(instance);
    }
    if (false) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (false) {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      if (false) {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
    if (false) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (false) {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (false) {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.effect.dirty = true;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (false) {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (false) {
              endMeasure(instance, `render`);
            }
            if (false) {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (false) {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (false) {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (false) {
            endMeasure(instance, `render`);
          }
          if (false) {
            startMeasure(instance, `patch`);
          }
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          if (false) {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (false) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next: next2, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next2) {
              next2.el = vnode.el;
              updateComponentPreRender(instance, next2, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next2;
        let vnodeHook;
        if (false) {
          pushWarningContext(next2 || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next2) {
          next2.el = vnode.el;
          updateComponentPreRender(instance, next2, optimized);
        } else {
          next2 = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next2, vnode);
        }
        toggleRecurse(instance, true);
        if (false) {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (false) {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (false) {
          startMeasure(instance, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        if (false) {
          endMeasure(instance, `patch`);
        }
        next2.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next2, vnode),
            parentSuspense
          );
        }
        if (false) {
          devtoolsComponentUpdated(instance);
        }
        if (false) {
          popWarningContext();
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      NOOP,
      () => queueJob(update2),
      instance.scope
      // track it in component's effect scope
    );
    const update2 = instance.update = () => {
      if (effect2.dirty) {
        effect2.run();
      }
    };
    update2.id = instance.uid;
    toggleRecurse(instance, true);
    if (false) {
      effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
      effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      update2.ownerInstance = instance;
    }
    update2();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          if (false) {
            warn$1(
              `Duplicate keys found during update:`,
              JSON.stringify(nextChild.key),
              `Make sure keys are unique.`
            );
          }
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove222 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove222();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove222, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      memoIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (memoIndex != null) {
      parentComponent.renderCache[memoIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove22(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove22 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (false) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove22(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next2;
    while (cur !== end) {
      next2 = hostNextSibling(cur);
      hostRemove(cur);
      cur = next2;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (false) {
      unregisterHMR(instance);
    }
    const { bum, scope, update: update2, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update2) {
      update2.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (false) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  let isFlushing2 = false;
  const render3 = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    if (!isFlushing2) {
      isFlushing2 = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing2 = false;
    }
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove22,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options3
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render3,
    hydrate: hydrate2,
    createApp: createAppAPI(render3, hydrate2)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, update: update2 }, allowed) {
  effect2.allowRecurse = update2.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$3(ch1) && isArray$3(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (false) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u, v2, c;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c = u + v2 >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v2 = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i2] = result[u - 1];
        }
        result[u] = i2;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i2 = 0; i2 < hooks.length; i2++) hooks[i2].active = false;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
    }
    return ctx;
  }
};
function watchEffect(effect2, options3) {
  return doWatch(effect2, null, options3);
}
function watchPostEffect(effect2, options3) {
  return doWatch(
    effect2,
    null,
    false ? extend({}, options3, { flush: "post" }) : { flush: "post" }
  );
}
function watchSyncEffect(effect2, options3) {
  return doWatch(
    effect2,
    null,
    false ? extend({}, options3, { flush: "sync" }) : { flush: "sync" }
  );
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options3) {
  if (false) {
    warn$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options3);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once: once2,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once2) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      unwatch();
    };
  }
  if (false) {
    warn$1(
      `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
    );
  }
  if (false) {
    if (immediate !== void 0) {
      warn$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once2 !== void 0) {
      warn$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const warnInvalidSource = (s) => {
    warn$1(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const instance = currentInstance;
  const reactiveGetter = (source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  );
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$3(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$3(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
      }
    });
  } else if (isFunction$3(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect2.onStop = void 0;
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active || !effect2.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance) job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = () => {
    effect2.stop();
    if (scope) {
      remove$1(scope.effects, effect2);
    }
  };
  if (false) {
    effect2.onTrack = onTrack;
    effect2.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  if (ssrCleanup) ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value3, options3) {
  const publicThis = this.proxy;
  const getter = isString$4(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$3(value3)) {
    cb = value3;
  } else {
    cb = value3.handler;
    options3 = value3;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options3);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value3, depth = Infinity, seen2) {
  if (depth <= 0 || !isObject$4(value3) || value3["__v_skip"]) {
    return value3;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value3)) {
    return value3;
  }
  seen2.add(value3);
  depth--;
  if (isRef(value3)) {
    traverse(value3.value, depth, seen2);
  } else if (isArray$3(value3)) {
    for (let i2 = 0; i2 < value3.length; i2++) {
      traverse(value3[i2], depth, seen2);
    }
  } else if (isSet(value3) || isMap(value3)) {
    value3.forEach((v2) => {
      traverse(v2, depth, seen2);
    });
  } else if (isPlainObject$2(value3)) {
    for (const key in value3) {
      traverse(value3[key], depth, seen2);
    }
    for (const key of Object.getOwnPropertySymbols(value3)) {
      if (Object.prototype.propertyIsEnumerable.call(value3, key)) {
        traverse(value3[key], depth, seen2);
      }
    }
  }
  return value3;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache2 = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    if (false) {
      instance.__v_cache = cache2;
    }
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement: createElement2 }
      }
    } = sharedContext;
    const storageContainer = createElement2("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (false) {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (false) {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter5) {
      cache2.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter5 || !filter5(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache2.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache2.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache2.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (false) {
          warn$1(`KeepAlive should contain exactly one component child.`);
        }
        current = null;
        return children;
      } else if (!isVNode$1(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache2.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray$3(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString$4(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp$1(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove$1(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if (false) {
              warn$1(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            child = c;
            hasFound = true;
            if (true) break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode: mode2 } = rawProps;
      if (false) {
        warn$1(`invalid <transition> mode: ${mode2}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode2 === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.effect.dirty = true;
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode2 === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode: mode2,
    persisted = false,
    onBeforeEnter: onBeforeEnter2,
    onEnter: onEnter4,
    onAfterEnter: onAfterEnter2,
    onEnterCancelled,
    onBeforeLeave: onBeforeLeave2,
    onLeave: onLeave4,
    onAfterLeave: onAfterLeave3,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$3(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode: mode2,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter2;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter2;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter4;
      let afterHook = onAfterEnter2;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter4;
          afterHook = onAfterAppear || onAfterEnter2;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove22) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove22();
      }
      callHook2(onBeforeLeave2, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove22();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave3, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave4) {
        callAsyncHook(onLeave4, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  if (!isKeepAlive(vnode)) {
    return vnode;
  }
  if (false) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$3(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$4(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      if (false) {
        warn$1(
          `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
        );
      }
      return target;
    }
  } else {
    if (false) {
      warn$1(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert: insert2, querySelector, createText, createComment }
    } = internals;
    const disabled2 = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (false) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el = false ? createComment("teleport start") : createText("");
      const mainAnchor = n2.anchor = false ? createComment("teleport end") : createText("");
      insert2(placeholder, container, anchor);
      insert2(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert2(targetAnchor, target);
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
      } else if (false) {
        warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
      }
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled2) {
        mount2(container, mainAnchor);
      } else if (target) {
        mount2(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled2) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          } else if (false) {
            warn$1(
              "Invalid Teleport target on update:",
              target,
              `(${typeof target})`
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert: insert2 }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert2(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert2(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert2(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node3, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node3),
          vnode,
          parentNode(node3),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node3);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node3 = vnode.children[0].el;
    while (node3 && node3 !== vnode.targetAnchor) {
      if (node3.nodeType === 1) node3.setAttribute("data-v-owner", ctx.uid);
      node3 = node3.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value3) {
  isBlockTreeEnabled += value3;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$1(value3) {
  return value3 ? value3.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (false) {
    n1.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(
    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
  );
};
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$4(ref3) || isRef(ref3) || isFunction$3(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$4(children) ? 8 : 16;
  }
  if (false) {
    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = false ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (false) {
      warn$1(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$4(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$4(style)) {
      if (isProxy(style) && !isArray$3(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$4(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$4(type) ? 4 : isFunction$3(type) ? 2 : 0;
  if (false) {
    type = toRaw(type);
    warn$1(
      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
      `
Component that was made reactive: `,
      type
    );
  }
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$3(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: false ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray$3(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text2 = " ", flag = 0) {
  return createVNode(Text, null, text2, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text2 = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$3(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$3(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$3(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (false) {
    instance.ctx = createDevRenderContext(instance);
  } else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis$1();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set2) => set2(v2));
      else setters[0](v2);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = (instance) => {
  const prev2 = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev2);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful3 = isStatefulComponent(instance);
  initProps(instance, props, isStateful3, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful3 ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a2;
  const Component = instance.type;
  if (false) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateComponentName(names[i2], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateDirectiveName(names[i2]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$1(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  if (false) {
    exposePropsOnRenderContext(instance);
  }
  const { setup: setup2 } = Component;
  if (setup2) {
    const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup2,
      instance,
      0,
      [
        false ? shallowReadonly(instance.props) : instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise$2(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (false) {
          const name = (_a2 = Component.name) != null ? _a2 : "Anonymous";
          warn$1(
            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
          );
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$3(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$4(setupResult)) {
    if (false) {
      warn$1(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    if (false) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    if (false) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (false) {
    warn$1(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
let compile$2;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$2 = _compile;
  installWithProxy = (i2) => {
    if (i2.render._rc) {
      i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$2;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$2 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (false) {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$2(template, finalCompilerOptions);
        if (false) {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (true) {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
  if (false) {
    if (!compile$2 && Component.template) {
      warn$1(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      );
    } else {
      warn$1(`Component is missing template or render function: `, Component);
    }
  }
}
const attrsProxyHandlers = false ? {
  get(target, key) {
    markAttrsAccessed();
    track(target, "get", "");
    return target[key];
  },
  set() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  },
  deleteProperty() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  }
} : {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function getSlotsProxy(instance) {
  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  }));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (false) {
      if (instance.exposed) {
        warn$1(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray$3(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn$1(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  };
  if (false) {
    let attrsProxy;
    return Object.freeze({
      get attrs() {
        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
      },
      get slots() {
        return getSlotsProxy(instance);
      },
      get emit() {
        return (event2, ...args) => instance.emit(event2, ...args);
      },
      expose
    });
  } else {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value3) {
  return isFunction$3(value3) && "__vccOpts" in value3;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (false) {
    const i2 = getCurrentInstance();
    if (i2 && i2.appContext.config.warnRecursiveComputed) {
      c._warnRecursive = true;
    }
  }
  return c;
};
function useModel(props, name, options3 = EMPTY_OBJ) {
  const i2 = getCurrentInstance();
  if (false) {
    warn$1(`useModel() called without active instance.`);
    return ref();
  }
  if (false) {
    warn$1(`useModel() called with prop "${name}" which is not declared.`);
    return ref();
  }
  const camelizedName = camelize(name);
  const hyphenatedName = hyphenate(name);
  const res = customRef((track2, trigger2) => {
    let localValue;
    watchSyncEffect(() => {
      const propValue = props[name];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger2();
      }
    });
    return {
      get() {
        track2();
        return options3.get ? options3.get(localValue) : localValue;
      },
      set(value3) {
        const rawProps = i2.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && hasChanged(value3, localValue)) {
          localValue = value3;
          trigger2();
        }
        i2.emit(`update:${name}`, options3.set ? options3.set(value3) : value3);
      }
    };
  });
  const modifierKey = name === "modelValue" ? "modelModifiers" : `${name}Modifiers`;
  res[Symbol.iterator] = () => {
    let i22 = 0;
    return {
      next() {
        if (i22 < 2) {
          return { value: i22++ ? props[modifierKey] || {} : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$4(propsOrChildren) && !isArray$3(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
function initCustomFormatter() {
  if (true) {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#1677ff" };
  const stringStyle = { style: "color:#f5222d" };
  const keywordStyle = { style: "color:#eb2f96" };
  const formatter = {
    header(obj) {
      if (!isObject$4(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue2(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue2(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue2(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed2 = extractKeys(instance, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = extend({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue2(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue2(v2, asRaw = true) {
    if (typeof v2 === "number") {
      return ["span", numberStyle, v2];
    } else if (typeof v2 === "string") {
      return ["span", stringStyle, JSON.stringify(v2)];
    } else if (typeof v2 === "boolean") {
      return ["span", keywordStyle, v2];
    } else if (isObject$4(v2)) {
      return ["object", { object: asRaw ? toRaw(v2) : v2 }];
    } else {
      return ["span", stringStyle, String(v2)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction$3(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray$3(opts) && opts.includes(key) || isObject$4(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v2) {
    if (isShallow(v2)) {
      return `ShallowRef`;
    }
    if (v2.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
function withMemo(memo, render3, cache2, index2) {
  const cached = cache2[index2];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render3();
  ret.memo = memo.slice();
  ret.memoIndex = index2;
  return cache2[index2] = ret;
}
function isMemoSame(cached, memo) {
  const prev2 = cached.memo;
  if (prev2.length != memo.length) {
    return false;
  }
  for (let i2 = 0; i2 < prev2.length; i2++) {
    if (hasChanged(prev2[i2], memo[i2])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.4.31";
const warn$2 = false ? warn$1 : NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1;
const devtools$2 = true ? devtools$1 : void 0;
const setDevtoolsHook = true ? setDevtoolsHook$1 : NOOP;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode$1,
  normalizeVNode,
  getComponentPublicInstance
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;
/**
* @vue/runtime-dom v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text2) => doc.createTextNode(text2),
  createComment: (text2) => doc.createComment(text2),
  setText: (node3, text2) => {
    node3.nodeValue = text2;
  },
  setElementText: (el, text2) => {
    el.textContent = text2;
  },
  parentNode: (node3) => node3.parentNode,
  nextSibling: (node3) => node3.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start2, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end || !(start2 = start2.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$3(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$3(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter: onBeforeEnter2,
    onEnter: onEnter4,
    onEnterCancelled,
    onLeave: onLeave4,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter2,
    onAppear = onEnter4,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter4;
      const resolve8 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve8]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve8);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter2, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve8 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      addTransitionClass(el, leaveActiveClass);
      forceReflow();
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave4)) {
          whenTransitionEnds(el, type, leaveDuration, resolve8);
        }
      });
      callHook(onLeave4, [el, resolve8]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$4(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  if (false) {
    assertNumber(res, "<transition> explicit duration");
  }
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve8) {
  const id2 = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el._endId) {
      resolve8();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve8();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value3, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value3 = (value3 ? [value3, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value3 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value3);
  } else {
    el.className = value3;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value: value3 }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value3) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value3);
    }
  },
  mounted(el, { value: value3 }, { transition }) {
    if (transition && value3) {
      transition.enter(el);
    }
  },
  updated(el, { value: value3, oldValue }, { transition }) {
    if (!value3 === !oldValue) return;
    if (transition) {
      if (value3) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value3);
    }
  },
  beforeUnmount(el, { value: value3 }) {
    setDisplay(el, value3);
  }
};
if (false) {
  vShow.name = "show";
}
function setDisplay(el, value3) {
  el.style.display = value3 ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value3;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value: value3 }) => {
    if (!value3) {
      return { style: { display: "none" } };
    }
  };
}
const CSS_VAR_TEXT = Symbol(false ? "CSS_VAR_TEXT" : "");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node3) => setVarsOnNode(node3, vars));
  };
  if (false) {
    instance.getCssVars = () => getter(instance.proxy);
  }
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  onMounted(() => {
    watchPostEffect(setVars);
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev2, next2) {
  const style = el.style;
  const isCssString = isString$4(next2);
  let hasControlledDisplay = false;
  if (next2 && !isCssString) {
    if (prev2) {
      if (!isString$4(prev2)) {
        for (const key in prev2) {
          if (next2[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev2.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next2[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next2) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next2[key]);
    }
  } else {
    if (isCssString) {
      if (prev2 !== next2) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next2 += ";" + cssVarText;
        }
        style.cssText = next2;
        hasControlledDisplay = displayRE.test(next2);
      }
    } else if (prev2) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$3(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null) val = "";
    if (false) {
      if (semicolonRE.test(val)) {
        warn$2(
          `Unexpected semicolon at the end of '${name}' style value: '${val}'`
        );
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value3, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value3 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value3);
    }
  } else {
    if (value3 == null || isBoolean2 && !includeBooleanAttr(value3)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol$1(value3) ? String(value3) : value3
      );
    }
  }
}
function patchDOMProp(el, key, value3, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value3 == null ? "" : value3;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value3 == null ? "" : String(value3);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value3 == null) {
      el.removeAttribute(key);
    }
    el._value = value3;
    return;
  }
  let needRemove = false;
  if (value3 === "" || value3 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value3 = includeBooleanAttr(value3);
    } else if (value3 == null && type === "string") {
      value3 = "";
      needRemove = true;
    } else if (type === "number") {
      value3 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value3;
  } catch (e) {
    if (false) {
      warn$2(
        `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value3} is invalid.`,
        e
      );
    }
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event2, handler8, options3) {
  el.addEventListener(event2, handler8, options3);
}
function removeEventListener(el, event2, handler8, options3) {
  el.removeEventListener(event2, handler8, options3);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = false ? sanitizeEventValue(nextValue, rawName) : nextValue;
  } else {
    const [name, options3] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        false ? sanitizeEventValue(nextValue, rawName) : nextValue,
        instance
      );
      addEventListener(el, name, invoker, options3);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options3);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options3;
  if (optionsModifierRE.test(name)) {
    options3 = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options3[m[0].toLowerCase()] = true;
    }
  }
  const event2 = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event2, options3];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function sanitizeEventValue(value3, propName) {
  if (isFunction$3(value3) || isArray$3(value3)) {
    return value3;
  }
  warn$2(
    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value3}.`
  );
  return NOOP;
}
function patchStopImmediatePropagation(e, value3) {
  if (isArray$3(value3)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value3.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value3;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value3, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$3(value3)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$4(value3)) {
    return false;
  }
  return key in el;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options3, extraOptions, hydrate2) {
  const Comp = /* @__PURE__ */ defineComponent(options3, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options3, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options3, extraOptions, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._ob = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      if (false) {
        warn$2(
          `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
        );
      }
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        render$18(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i2 = 0; i2 < this.attributes.length; i2++) {
      this._setAttr(this.attributes[i2].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve8 = (def2, isAsync2 = false) => {
      const { props, styles } = def2;
      let numberProps;
      if (props && !isArray$3(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync2) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve8(def2, true));
    } else {
      resolve8(this._def);
    }
  }
  _resolveProps(def2) {
    const { props } = def2;
    const declaredPropKeys = isArray$3(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value3 = this.hasAttribute(key) ? this.getAttribute(key) : void 0;
    const camelKey = camelize(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value3 = toNumber(value3);
    }
    this._setProp(camelKey, value3, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render$18(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        if (false) {
          instance.ceReload = (newStyles) => {
            if (this._styles) {
              this._styles.forEach((s) => this.shadowRoot.removeChild(s));
              this._styles.length = 0;
            }
            this._applyStyles(newStyles);
            this._instance = null;
            this._update();
          };
        }
        const dispatch = (event2, args) => {
          this.dispatchEvent(
            new CustomEvent(event2, {
              detail: args
            })
          );
        };
        instance.emit = (event2, ...args) => {
          dispatch(event2, args);
          if (hyphenate(event2) !== event2) {
            dispatch(hyphenate(event2), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css4) => {
        const s = document.createElement("style");
        s.textContent = css4;
        this.shadowRoot.appendChild(s);
        if (false) {
          (this._styles || (this._styles = [])).push(s);
        }
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        } else if (false) {
          warn$2(`<TransitionGroup> children must be keyed.`);
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root27, moveClass) {
  const clone2 = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
  clone2.style.display = "none";
  const container = root27.nodeType === 1 ? root27 : root27.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$3(fn) ? (value3) => invokeArrayFns(fn, value3) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value: value3 }) {
    el.value = value3 == null ? "" : value3;
  },
  beforeUpdate(el, { value: value3, oldValue, modifiers: { lazy, trim, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number2 || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value3 == null ? "" : value3;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value3 === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _2, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue3 = el._modelValue;
      const elementValue = getValue(el);
      const checked5 = el.checked;
      const assign2 = el[assignKey];
      if (isArray$3(modelValue3)) {
        const index2 = looseIndexOf(modelValue3, elementValue);
        const found = index2 !== -1;
        if (checked5 && !found) {
          assign2(modelValue3.concat(elementValue));
        } else if (!checked5 && found) {
          const filtered = [...modelValue3];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue3)) {
        const cloned = new Set(modelValue3);
        if (checked5) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked5));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value: value3, oldValue }, vnode) {
  el._modelValue = value3;
  if (isArray$3(value3)) {
    el.checked = looseIndexOf(value3, vnode.props.value) > -1;
  } else if (isSet(value3)) {
    el.checked = value3.has(vnode.props.value);
  } else if (value3 !== oldValue) {
    el.checked = looseEqual(value3, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value: value3 }, vnode) {
    el.checked = looseEqual(value3, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value: value3, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value3 !== oldValue) {
      el.checked = looseEqual(value3, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value: value3, modifiers: { number: number2 } }, vnode) {
    const isSetModel = isSet(value3);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number2 ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value: value3, modifiers: { number: number2 } }) {
    setSelected(el, value3);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value: value3, modifiers: { number: number2 } }) {
    if (!el._assigning) {
      setSelected(el, value3);
    }
  }
};
function setSelected(el, value3, number2) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray$3(value3);
  if (isMultiple && !isArrayValue && !isSet(value3)) {
    return;
  }
  for (let i2 = 0, l = el.options.length; i2 < l; i2++) {
    const option4 = el.options[i2];
    const optionValue = getValue(option4);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option4.selected = value3.some((v2) => String(v2) === String(optionValue));
        } else {
          option4.selected = looseIndexOf(value3, optionValue) > -1;
        }
      } else {
        option4.selected = value3.has(optionValue);
      }
    } else if (looseEqual(getValue(option4), value3)) {
      if (el.selectedIndex !== i2) el.selectedIndex = i2;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked5) {
  const key = checked5 ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked5;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value: value3 }) => ({ value: value3 });
  vModelRadio.getSSRProps = ({ value: value3 }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value3)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value: value3 }, vnode) => {
    if (isArray$3(value3)) {
      if (vnode.props && looseIndexOf(value3, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value3)) {
      if (vnode.props && value3.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value3) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event2, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event2, modifiers)) return;
    }
    return fn(event2, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache2 = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event2) => {
    if (!("key" in event2)) {
      return;
    }
    const eventKey = hyphenate(event2.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event2);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render$18 = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  if (false) {
    injectNativeTagCheck(app2);
    injectCompilerOptionsCheck(app2);
  }
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app2._component;
    if (!isFunction$3(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
const createSSRApp = (...args) => {
  const app2 = ensureHydrationRenderer().createApp(...args);
  if (false) {
    injectNativeTagCheck(app2);
    injectCompilerOptionsCheck(app2);
  }
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount2(container, true, resolveRootNamespace(container));
    }
  };
  return app2;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function injectNativeTagCheck(app2) {
  Object.defineProperty(app2.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app2) {
  if (isRuntimeOnly()) {
    const isCustomElement = app2.config.isCustomElement;
    Object.defineProperty(app2.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn$2(
          `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
        );
      }
    });
    const compilerOptions = app2.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app2.config, "compilerOptions", {
      get() {
        warn$2(msg);
        return compilerOptions;
      },
      set() {
        warn$2(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString$4(container)) {
    const res = document.querySelector(container);
    if (false) {
      warn$2(
        `Failed to mount app: mount target selector "${container}" returned null.`
      );
    }
    return res;
  }
  if (false) {
    warn$2(
      `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
    );
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
/**
* vue v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function initDev() {
  {
    initCustomFormatter();
  }
}
if (false) {
  initDev();
}
const compile$1 = () => {
  if (false) {
    warn$2(
      `Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
    );
  }
};
const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  DeprecationTypes,
  EffectScope,
  ErrorCodes,
  ErrorTypeStrings,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  TrackOpTypes,
  Transition,
  TransitionGroup,
  TriggerOpTypes,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize: capitalize$1,
  cloneVNode,
  compatUtils,
  compile: compile$1,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  devtools: devtools$2,
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode: isVNode$1,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render: render$18,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString: toDisplayString$1,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  toValue: toValue$1,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useModel,
  useSSRContext,
  useSlots,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn: warn$2,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value3) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3;
var __spreadValues$1 = (a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop2))
      __defNormalProp$2(a, prop2, b[prop2]);
  if (__getOwnPropSymbols$1)
    for (var prop2 of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop2))
        __defNormalProp$2(a, prop2, b[prop2]);
    }
  return a;
};
function isEmpty(value3) {
  return value3 === null || value3 === void 0 || value3 === "" || Array.isArray(value3) && value3.length === 0 || !(value3 instanceof Date) && typeof value3 === "object" && Object.keys(value3).length === 0;
}
function compare(value1, value22, comparator2, order = 1) {
  let result = -1;
  const emptyValue1 = isEmpty(value1);
  const emptyValue2 = isEmpty(value22);
  if (emptyValue1 && emptyValue2) result = 0;
  else if (emptyValue1) result = order;
  else if (emptyValue2) result = -order;
  else if (typeof value1 === "string" && typeof value22 === "string") result = comparator2(value1, value22);
  else result = value1 < value22 ? -1 : value1 > value22 ? 1 : 0;
  return result;
}
function deepEquals(obj1, obj2) {
  if (obj1 === obj2) return true;
  if (obj1 && obj2 && typeof obj1 == "object" && typeof obj2 == "object") {
    var arrObj1 = Array.isArray(obj1), arrObj2 = Array.isArray(obj2), i2, length, key;
    if (arrObj1 && arrObj2) {
      length = obj1.length;
      if (length != obj2.length) return false;
      for (i2 = length; i2-- !== 0; ) if (!deepEquals(obj1[i2], obj2[i2])) return false;
      return true;
    }
    if (arrObj1 != arrObj2) return false;
    var dateObj1 = obj1 instanceof Date, dateObj2 = obj2 instanceof Date;
    if (dateObj1 != dateObj2) return false;
    if (dateObj1 && dateObj2) return obj1.getTime() == obj2.getTime();
    var regexpObj1 = obj1 instanceof RegExp, regexpObj2 = obj2 instanceof RegExp;
    if (regexpObj1 != regexpObj2) return false;
    if (regexpObj1 && regexpObj2) return obj1.toString() == obj2.toString();
    var keys = Object.keys(obj1);
    length = keys.length;
    if (length !== Object.keys(obj2).length) return false;
    for (i2 = length; i2-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(obj2, keys[i2])) return false;
    for (i2 = length; i2-- !== 0; ) {
      key = keys[i2];
      if (!deepEquals(obj1[key], obj2[key])) return false;
    }
    return true;
  }
  return obj1 !== obj1 && obj2 !== obj2;
}
function isFunction$2(value3) {
  return !!(value3 && value3.constructor && value3.call && value3.apply);
}
function isNotEmpty(value3) {
  return !isEmpty(value3);
}
function resolveFieldData(data28, field2) {
  if (!data28 || !field2) {
    return null;
  }
  try {
    const value3 = data28[field2];
    if (isNotEmpty(value3)) return value3;
  } catch (e) {
  }
  if (Object.keys(data28).length) {
    if (isFunction$2(field2)) {
      return field2(data28);
    } else if (field2.indexOf(".") === -1) {
      return data28[field2];
    } else {
      let fields = field2.split(".");
      let value3 = data28;
      for (let i2 = 0, len = fields.length; i2 < len; ++i2) {
        if (value3 == null) {
          return null;
        }
        value3 = value3[fields[i2]];
      }
      return value3;
    }
  }
  return null;
}
function equals(obj1, obj2, field2) {
  if (field2) return resolveFieldData(obj1, field2) === resolveFieldData(obj2, field2);
  else return deepEquals(obj1, obj2);
}
function contains(value3, list) {
  if (value3 != null && list && list.length) {
    for (let val of list) {
      if (equals(value3, val)) return true;
    }
  }
  return false;
}
function filter(value3, fields, filterValue) {
  let filteredItems = [];
  if (value3) {
    for (let item of value3) {
      for (let field2 of fields) {
        if (String(resolveFieldData(item, field2)).toLowerCase().indexOf(filterValue.toLowerCase()) > -1) {
          filteredItems.push(item);
          break;
        }
      }
    }
  }
  return filteredItems;
}
function findIndexInList(value3, list) {
  let index2 = -1;
  if (list) {
    for (let i2 = 0; i2 < list.length; i2++) {
      if (list[i2] === value3) {
        index2 = i2;
        break;
      }
    }
  }
  return index2;
}
function findLast(arr, callback) {
  let item;
  if (isNotEmpty(arr)) {
    try {
      item = arr.findLast(callback);
    } catch (e) {
      item = [...arr].reverse().find(callback);
    }
  }
  return item;
}
function findLastIndex(arr, callback) {
  let index2 = -1;
  if (isNotEmpty(arr)) {
    try {
      index2 = arr.findLastIndex(callback);
    } catch (e) {
      index2 = arr.lastIndexOf([...arr].reverse().find(callback));
    }
  }
  return index2;
}
function isObject$3(value3, empty3 = true) {
  return value3 instanceof Object && value3.constructor === Object && (empty3 || Object.keys(value3).length !== 0);
}
function resolve(obj, ...params) {
  return isFunction$2(obj) ? obj(...params) : obj;
}
function isString$3(value3, empty3 = true) {
  return typeof value3 === "string" && (empty3 || value3 !== "");
}
function toFlatCase(str) {
  return isString$3(str) ? str.replace(/(-|_)/g, "").toLowerCase() : str;
}
function getKeyValue(obj, key = "", params = {}) {
  const fKeys = toFlatCase(key).split(".");
  const fKey = fKeys.shift();
  return fKey ? isObject$3(obj) ? getKeyValue(resolve(obj[Object.keys(obj).find((k) => toFlatCase(k) === fKey) || ""], params), fKeys.join("."), params) : void 0 : resolve(obj, params);
}
function insertIntoOrderedArray(item, index2, arr, sourceArr) {
  if (arr.length > 0) {
    let injected = false;
    for (let i2 = 0; i2 < arr.length; i2++) {
      let currentItemIndex = findIndexInList(arr[i2], sourceArr);
      if (currentItemIndex > index2) {
        arr.splice(i2, 0, item);
        injected = true;
        break;
      }
    }
    if (!injected) {
      arr.push(item);
    }
  } else {
    arr.push(item);
  }
}
function isArray$2(value3, empty3 = true) {
  return Array.isArray(value3) && (empty3 || value3.length !== 0);
}
function isDate$1(value3) {
  return value3 instanceof Date && value3.constructor === Date;
}
function isNumber$2(value3) {
  return isNotEmpty(value3) && !isNaN(value3);
}
function isPrintableCharacter(char = "") {
  return isNotEmpty(char) && char.length === 1 && !!char.match(/\S| /);
}
function localeComparator() {
  return new Intl.Collator(void 0, { numeric: true }).compare;
}
function matchRegex(str, regex) {
  if (regex) {
    const match = regex.test(str);
    regex.lastIndex = 0;
    return match;
  }
  return false;
}
function mergeKeys(...args) {
  const _mergeKeys = (target = {}, source = {}) => {
    const mergedObj = __spreadValues$1({}, target);
    Object.keys(source).forEach((key) => {
      if (isObject$3(source[key]) && key in target && isObject$3(target[key])) {
        mergedObj[key] = _mergeKeys(target[key], source[key]);
      } else {
        mergedObj[key] = source[key];
      }
    });
    return mergedObj;
  };
  return args.reduce((acc, obj, i2) => i2 === 0 ? obj : _mergeKeys(acc, obj), {});
}
function minifyCSS(css4) {
  return css4 ? css4.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":") : css4;
}
function nestedKeys(obj = {}, parentKey = "") {
  return Object.entries(obj).reduce((o, [key, value3]) => {
    const currentKey = parentKey ? `${parentKey}.${key}` : key;
    isObject$3(value3) ? o = o.concat(nestedKeys(value3, currentKey)) : o.push(currentKey);
    return o;
  }, []);
}
function removeAccents(str) {
  if (str && str.search(/[\xC0-\xFF]/g) > -1) {
    str = str.replace(/[\xC0-\xC5]/g, "A").replace(/[\xC6]/g, "AE").replace(/[\xC7]/g, "C").replace(/[\xC8-\xCB]/g, "E").replace(/[\xCC-\xCF]/g, "I").replace(/[\xD0]/g, "D").replace(/[\xD1]/g, "N").replace(/[\xD2-\xD6\xD8]/g, "O").replace(/[\xD9-\xDC]/g, "U").replace(/[\xDD]/g, "Y").replace(/[\xDE]/g, "P").replace(/[\xE0-\xE5]/g, "a").replace(/[\xE6]/g, "ae").replace(/[\xE7]/g, "c").replace(/[\xE8-\xEB]/g, "e").replace(/[\xEC-\xEF]/g, "i").replace(/[\xF1]/g, "n").replace(/[\xF2-\xF6\xF8]/g, "o").replace(/[\xF9-\xFC]/g, "u").replace(/[\xFE]/g, "p").replace(/[\xFD\xFF]/g, "y");
  }
  return str;
}
function reorderArray(value3, from, to) {
  if (value3 && from !== to) {
    if (to >= value3.length) {
      to %= value3.length;
      from %= value3.length;
    }
    value3.splice(to, 0, value3.splice(from, 1)[0]);
  }
}
function sort(value1, value22, order = 1, comparator2, nullSortOrder2 = 1) {
  const result = compare(value1, value22, comparator2, order);
  let finalSortOrder = order;
  if (isEmpty(value1) || isEmpty(value22)) {
    finalSortOrder = nullSortOrder2 === 1 ? order : nullSortOrder2;
  }
  return finalSortOrder * result;
}
function stringify$1(value3, indent = 2, currentIndent = 0) {
  const currentIndentStr = " ".repeat(currentIndent);
  const nextIndentStr = " ".repeat(currentIndent + indent);
  if (isArray$2(value3)) {
    return "[" + value3.map((v2) => stringify$1(v2, indent, currentIndent + indent)).join(", ") + "]";
  } else if (isDate$1(value3)) {
    return value3.toISOString();
  } else if (isFunction$2(value3)) {
    return value3.toString();
  } else if (isObject$3(value3)) {
    return "{\n" + Object.entries(value3).map(([k, v2]) => `${nextIndentStr}${k}: ${stringify$1(v2, indent, currentIndent + indent)}`).join(",\n") + `
${currentIndentStr}}`;
  } else {
    return JSON.stringify(value3);
  }
}
function toCapitalCase(str) {
  return isString$3(str, false) ? str[0].toUpperCase() + str.slice(1) : str;
}
function toKebabCase(str) {
  return isString$3(str) ? str.replace(/(_)/g, "-").replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "-" + c.toLowerCase()).toLowerCase() : str;
}
function toTokenKey$1(str) {
  return isString$3(str) ? str.replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "." + c.toLowerCase()).toLowerCase() : str;
}
function EventBus() {
  const allHandlers = /* @__PURE__ */ new Map();
  return {
    on(type, handler8) {
      let handlers = allHandlers.get(type);
      if (!handlers) handlers = [handler8];
      else handlers.push(handler8);
      allHandlers.set(type, handlers);
      return this;
    },
    off(type, handler8) {
      let handlers = allHandlers.get(type);
      if (handlers) {
        handlers.splice(handlers.indexOf(handler8) >>> 0, 1);
      }
      return this;
    },
    emit(type, evt) {
      let handlers = allHandlers.get(type);
      if (handlers) {
        handlers.slice().map((handler8) => {
          handler8(evt);
        });
      }
    },
    clear() {
      allHandlers.clear();
    }
  };
}
var __defProp$2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value3) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3;
var __spreadValues = (a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp.call(b, prop2))
      __defNormalProp$1(a, prop2, b[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop2))
        __defNormalProp$1(a, prop2, b[prop2]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop2 in source)
    if (__hasOwnProp.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum.call(source, prop2))
        target[prop2] = source[prop2];
    }
  return target;
};
function definePreset$1(...presets) {
  return mergeKeys(...presets);
}
var ThemeService$1 = EventBus();
var service_default = ThemeService$1;
function toTokenKey(str) {
  return isString$3(str) ? str.replace(/[A-Z]/g, (c, i2) => i2 === 0 ? c : "." + c.toLowerCase()).toLowerCase() : str;
}
function merge(value1, value22) {
  if (isArray$2(value1)) {
    value1.push(...value22 || []);
  } else if (isObject$3(value1)) {
    Object.assign(value1, value22);
  }
}
function toValue(value3) {
  return isObject$3(value3) && value3.hasOwnProperty("value") && value3.hasOwnProperty("type") ? value3.value : value3;
}
function toUnit(value3, variable = "") {
  const excludedProperties = ["opacity", "z-index", "line-height", "font-weight", "flex", "flex-grow", "flex-shrink", "order"];
  if (!excludedProperties.some((property) => variable.endsWith(property))) {
    const val = `${value3}`.trim();
    const valArr = val.split(" ");
    return valArr.map((v2) => isNumber$2(v2) ? `${v2}px` : v2).join(" ");
  }
  return value3;
}
function toNormalizePrefix(prefix2) {
  return prefix2.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
}
function toNormalizeVariable(prefix2 = "", variable = "") {
  return toNormalizePrefix(`${isString$3(prefix2, false) && isString$3(variable, false) ? `${prefix2}-` : prefix2}${variable}`);
}
function getVariableName(prefix2 = "", variable = "") {
  return `--${toNormalizeVariable(prefix2, variable)}`;
}
function getVariableValue(value3, variable = "", prefix2 = "", excludedKeyRegexes = [], fallback) {
  if (isString$3(value3)) {
    const regex = /{([^}]*)}/g;
    const val = value3.trim();
    if (matchRegex(val, regex)) {
      const _val = val.replaceAll(regex, (v2) => {
        const path = v2.replace(/{|}/g, "");
        const keys = path.split(".").filter((_v) => !excludedKeyRegexes.some((_r) => matchRegex(_v, _r)));
        return `var(${getVariableName(prefix2, toKebabCase(keys.join("-")))}${isNotEmpty(fallback) ? `, ${fallback}` : ""})`;
      });
      const calculationRegex = /(\d+\s+[\+\-\*\/]\s+\d+)/g;
      const cleanedVarRegex = /var\([^)]+\)/g;
      return matchRegex(_val.replace(cleanedVarRegex, "0"), calculationRegex) ? `calc(${_val})` : _val;
    }
    return toUnit(val, variable);
  } else if (isNumber$2(value3)) {
    return toUnit(value3, variable);
  }
  return void 0;
}
function getComputedValue(obj = {}, value3) {
  if (isString$3(value3)) {
    const regex = /{([^}]*)}/g;
    const val = value3.trim();
    return matchRegex(val, regex) ? val.replaceAll(regex, (v2) => getKeyValue(obj, v2.replace(/{|}/g, ""))) : val;
  } else if (isNumber$2(value3)) {
    return value3;
  }
  return void 0;
}
function setProperty(properties, key, value3) {
  if (isString$3(key, false)) {
    properties.push(`${key}:${value3};`);
  }
}
function getRule(selector, properties) {
  if (selector) {
    return `${selector}{${properties}}`;
  }
  return "";
}
function normalizeColor$1(color) {
  if (color.length === 4) {
    return `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;
  }
  return color;
}
function hexToRgb$2(hex) {
  var bigint = parseInt(hex.substring(1), 16);
  var r = bigint >> 16 & 255;
  var g = bigint >> 8 & 255;
  var b = bigint & 255;
  return { r, g, b };
}
function rgbToHex$2(r, g, b) {
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
var mix_default = (color1, color2, weight) => {
  color1 = normalizeColor$1(color1);
  color2 = normalizeColor$1(color2);
  var p2 = weight / 100;
  var w2 = p2 * 2 - 1;
  var w1 = (w2 + 1) / 2;
  var w22 = 1 - w1;
  var rgb1 = hexToRgb$2(color1);
  var rgb2 = hexToRgb$2(color2);
  var r = Math.round(rgb1.r * w1 + rgb2.r * w22);
  var g = Math.round(rgb1.g * w1 + rgb2.g * w22);
  var b = Math.round(rgb1.b * w1 + rgb2.b * w22);
  return rgbToHex$2(r, g, b);
};
var shade_default = (color, percent) => mix_default("#000000", color, percent);
var tint_default = (color, percent) => mix_default("#ffffff", color, percent);
var scales$1 = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
var palette_default = (color) => {
  if (/{([^}]*)}/g.test(color)) {
    const token = color.replace(/{|}/g, "");
    return scales$1.reduce((acc, scale) => (acc[scale] = `{${token}.${scale}}`, acc), {});
  }
  return typeof color === "string" ? scales$1.reduce((acc, scale, i2) => (acc[scale] = i2 <= 5 ? tint_default(color, (5 - i2) * 19) : shade_default(color, (i2 - 5) * 15), acc), {}) : color;
};
var $dt$1 = (tokenPath) => {
  var _a2;
  const theme36 = config_default.getTheme();
  const variable = dtwt$1(theme36, tokenPath, void 0, "variable");
  const name = (_a2 = variable.match(/--[\w-]+/g)) == null ? void 0 : _a2[0];
  const value3 = dtwt$1(theme36, tokenPath, void 0, "value");
  return {
    name,
    variable,
    value: value3
  };
};
var dt$1 = (...args) => {
  return dtwt$1(config_default.getTheme(), ...args);
};
var dtwt$1 = (theme36 = {}, tokenPath, fallback, type = "variable") => {
  if (tokenPath) {
    const { variable: VARIABLE, options: OPTIONS } = config_default.defaults || {};
    const { prefix: prefix2, transform: transform2 } = (theme36 == null ? void 0 : theme36.options) || OPTIONS || {};
    const regex = /{([^}]*)}/g;
    const token = matchRegex(tokenPath, regex) ? tokenPath : `{${tokenPath}}`;
    const isStrictTransform = type === "value" || transform2 === "strict";
    return isStrictTransform ? config_default.getTokenValue(tokenPath) : getVariableValue(token, void 0, prefix2, [VARIABLE.excludedKeyRegex], fallback);
  }
  return "";
};
function css$3(style) {
  return resolve(style, { dt: dt$1 });
}
var $t$1 = (theme36 = {}) => {
  let { preset: _preset, options: _options2 } = theme36;
  return {
    preset(value3) {
      _preset = _preset ? mergeKeys(_preset, value3) : value3;
      return this;
    },
    options(value3) {
      _options2 = _options2 ? __spreadValues(__spreadValues({}, _options2), value3) : value3;
      return this;
    },
    // features
    primaryPalette(primary) {
      const { semantic } = _preset || {};
      _preset = __spreadProps(__spreadValues({}, _preset), { semantic: __spreadProps(__spreadValues({}, semantic), { primary }) });
      return this;
    },
    surfacePalette(surface) {
      var _a2, _b;
      const { semantic } = _preset || {};
      const lightSurface = (surface == null ? void 0 : surface.hasOwnProperty("light")) ? surface == null ? void 0 : surface.light : surface;
      const darkSurface = (surface == null ? void 0 : surface.hasOwnProperty("dark")) ? surface == null ? void 0 : surface.dark : surface;
      const newColorScheme = {
        colorScheme: {
          light: __spreadValues(__spreadValues({}, (_a2 = semantic == null ? void 0 : semantic.colorScheme) == null ? void 0 : _a2.light), !!lightSurface && { surface: lightSurface }),
          dark: __spreadValues(__spreadValues({}, (_b = semantic == null ? void 0 : semantic.colorScheme) == null ? void 0 : _b.dark), !!darkSurface && { surface: darkSurface })
        }
      };
      _preset = __spreadProps(__spreadValues({}, _preset), { semantic: __spreadValues(__spreadValues({}, semantic), newColorScheme) });
      return this;
    },
    // actions
    define({ useDefaultPreset = false, useDefaultOptions = false } = {}) {
      return {
        preset: useDefaultPreset ? config_default.getPreset() : _preset,
        options: useDefaultOptions ? config_default.getOptions() : _options2
      };
    },
    update({ mergePresets = true, mergeOptions: mergeOptions2 = true } = {}) {
      const newTheme = {
        preset: mergePresets ? mergeKeys(config_default.getPreset(), _preset) : _preset,
        options: mergeOptions2 ? __spreadValues(__spreadValues({}, config_default.getOptions()), _options2) : _options2
      };
      config_default.setTheme(newTheme);
      return newTheme;
    },
    use(options3) {
      const newTheme = this.define(options3);
      config_default.setTheme(newTheme);
      return newTheme;
    }
  };
};
function toVariables_default(theme36, options3 = {}) {
  const VARIABLE = config_default.defaults.variable;
  const { prefix: prefix2 = VARIABLE.prefix, selector = VARIABLE.selector, excludedKeyRegex = VARIABLE.excludedKeyRegex } = options3;
  const _toVariables2 = (_theme, _prefix = "") => {
    return Object.entries(_theme).reduce(
      (acc, [key, value3]) => {
        const px = matchRegex(key, excludedKeyRegex) ? toNormalizeVariable(_prefix) : toNormalizeVariable(_prefix, toKebabCase(key));
        const v2 = toValue(value3);
        if (isObject$3(v2)) {
          const { variables: variables2, tokens: tokens2 } = _toVariables2(v2, px);
          merge(acc["tokens"], tokens2);
          merge(acc["variables"], variables2);
        } else {
          acc["tokens"].push((prefix2 ? px.replace(`${prefix2}-`, "") : px).replaceAll("-", "."));
          setProperty(acc["variables"], getVariableName(px), getVariableValue(v2, px, prefix2, [excludedKeyRegex]));
        }
        return acc;
      },
      { variables: [], tokens: [] }
    );
  };
  const { variables, tokens } = _toVariables2(theme36, prefix2);
  return {
    value: variables,
    tokens,
    declarations: variables.join(""),
    css: getRule(selector, variables.join(""))
  };
}
var themeUtils_default = {
  regex: {
    rules: {
      class: {
        pattern: /^\.([a-zA-Z][\w-]*)$/,
        resolve(value3) {
          return { type: "class", selector: value3, matched: this.pattern.test(value3.trim()) };
        }
      },
      attr: {
        pattern: /^\[(.*)\]$/,
        resolve(value3) {
          return { type: "attr", selector: `:root${value3}`, matched: this.pattern.test(value3.trim()) };
        }
      },
      media: {
        pattern: /^@media (.*)$/,
        resolve(value3) {
          return { type: "media", selector: `${value3}{:root{[CSS]}}`, matched: this.pattern.test(value3.trim()) };
        }
      },
      system: {
        pattern: /^system$/,
        resolve(value3) {
          return { type: "system", selector: "@media (prefers-color-scheme: dark){:root{[CSS]}}", matched: this.pattern.test(value3.trim()) };
        }
      },
      custom: {
        resolve(value3) {
          return { type: "custom", selector: value3, matched: true };
        }
      }
    },
    resolve(value3) {
      const rules = Object.keys(this.rules).filter((k) => k !== "custom").map((r) => this.rules[r]);
      return [value3].flat().map((v2) => {
        var _a2;
        return (_a2 = rules.map((r) => r.resolve(v2)).find((rr) => rr.matched)) != null ? _a2 : this.rules.custom.resolve(v2);
      });
    }
  },
  _toVariables(theme36, options3) {
    return toVariables_default(theme36, { prefix: options3 == null ? void 0 : options3.prefix });
  },
  getCommon({ name = "", theme: theme36 = {}, params, set: set2, defaults }) {
    var _c, _d, _e, _f;
    const { preset, options: options3 } = theme36;
    let primitive_css, primitive_tokens, semantic_css, semantic_tokens;
    if (isNotEmpty(preset)) {
      const { primitive, semantic } = preset;
      const _a2 = semantic || {}, { colorScheme } = _a2, sRest = __objRest(_a2, ["colorScheme"]);
      const _b = colorScheme || {}, { dark } = _b, csRest = __objRest(_b, ["dark"]);
      const prim_var = isNotEmpty(primitive) ? this._toVariables({ primitive }, options3) : {};
      const sRest_var = isNotEmpty(sRest) ? this._toVariables({ semantic: sRest }, options3) : {};
      const csRest_var = isNotEmpty(csRest) ? this._toVariables({ light: csRest }, options3) : {};
      const dark_var = isNotEmpty(dark) ? this._toVariables({ dark }, options3) : {};
      const [prim_css, prim_tokens] = [(_c = prim_var.declarations) != null ? _c : "", prim_var.tokens];
      const [sRest_css, sRest_tokens] = [(_d = sRest_var.declarations) != null ? _d : "", sRest_var.tokens || []];
      const [csRest_css, csRest_tokens] = [(_e = csRest_var.declarations) != null ? _e : "", csRest_var.tokens || []];
      const [dark_css, dark_tokens] = [(_f = dark_var.declarations) != null ? _f : "", dark_var.tokens || []];
      primitive_css = this.transformCSS(name, prim_css, "light", "variable", options3, set2, defaults);
      primitive_tokens = prim_tokens;
      const semantic_light_css = this.transformCSS(name, `${sRest_css}${csRest_css}color-scheme:light`, "light", "variable", options3, set2, defaults);
      const semantic_dark_css = this.transformCSS(name, `${dark_css}color-scheme:dark`, "dark", "variable", options3, set2, defaults);
      semantic_css = `${semantic_light_css}${semantic_dark_css}`;
      semantic_tokens = [.../* @__PURE__ */ new Set([...sRest_tokens, ...csRest_tokens, ...dark_tokens])];
    }
    return {
      primitive: {
        css: primitive_css,
        tokens: primitive_tokens
      },
      semantic: {
        css: semantic_css,
        tokens: semantic_tokens
      }
    };
  },
  getPreset({ name = "", preset = {}, options: options3, params, set: set2, defaults, selector }) {
    var _c, _d, _e;
    const _name2 = name.replace("-directive", "");
    const _a2 = preset, { colorScheme } = _a2, vRest = __objRest(_a2, ["colorScheme"]);
    const _b = colorScheme || {}, { dark } = _b, csRest = __objRest(_b, ["dark"]);
    const vRest_var = isNotEmpty(vRest) ? this._toVariables({ [_name2]: vRest }, options3) : {};
    const csRest_var = isNotEmpty(csRest) ? this._toVariables({ [_name2]: csRest }, options3) : {};
    const dark_var = isNotEmpty(dark) ? this._toVariables({ [_name2]: dark }, options3) : {};
    const [vRest_css, vRest_tokens] = [(_c = vRest_var.declarations) != null ? _c : "", vRest_var.tokens || []];
    const [csRest_css, csRest_tokens] = [(_d = csRest_var.declarations) != null ? _d : "", csRest_var.tokens || []];
    const [dark_css, dark_tokens] = [(_e = dark_var.declarations) != null ? _e : "", dark_var.tokens || []];
    const tokens = [.../* @__PURE__ */ new Set([...vRest_tokens, ...csRest_tokens, ...dark_tokens])];
    const light_variable_css = this.transformCSS(_name2, `${vRest_css}${csRest_css}`, "light", "variable", options3, set2, defaults, selector);
    const dark_variable_css = this.transformCSS(_name2, dark_css, "dark", "variable", options3, set2, defaults, selector);
    return {
      css: `${light_variable_css}${dark_variable_css}`,
      tokens
    };
  },
  getPresetC({ name = "", theme: theme36 = {}, params, set: set2, defaults }) {
    var _a2;
    const { preset, options: options3 } = theme36;
    const cPreset = (_a2 = preset == null ? void 0 : preset.components) == null ? void 0 : _a2[name];
    return this.getPreset({ name, preset: cPreset, options: options3, params, set: set2, defaults });
  },
  getPresetD({ name = "", theme: theme36 = {}, params, set: set2, defaults }) {
    var _a2;
    const dName = name.replace("-directive", "");
    const { preset, options: options3 } = theme36;
    const dPreset = (_a2 = preset == null ? void 0 : preset.directives) == null ? void 0 : _a2[dName];
    return this.getPreset({ name: dName, preset: dPreset, options: options3, params, set: set2, defaults });
  },
  getColorSchemeOption(options3, defaults) {
    var _a2;
    return this.regex.resolve((_a2 = options3.darkModeSelector) != null ? _a2 : defaults.options.darkModeSelector);
  },
  getLayerOrder(name, options3 = {}, params, defaults) {
    const { cssLayer } = options3;
    if (cssLayer) {
      const order = resolve(cssLayer.order || "primeui", params);
      return `@layer ${order}`;
    }
    return "";
  },
  getCommonStyleSheet({ name = "", theme: theme36 = {}, params, props = {}, set: set2, defaults }) {
    const common = this.getCommon({ name, theme: theme36, params, set: set2, defaults });
    const _props = Object.entries(props).reduce((acc, [k, v2]) => acc.push(`${k}="${v2}"`) && acc, []).join(" ");
    return Object.entries(common || {}).reduce((acc, [key, value3]) => {
      if (value3 == null ? void 0 : value3.css) {
        const _css = minifyCSS(value3 == null ? void 0 : value3.css);
        const id2 = `${key}-variables`;
        acc.push(`<style type="text/css" data-primevue-style-id="${id2}" ${_props}>${_css}</style>`);
      }
      return acc;
    }, []).join("");
  },
  getStyleSheet({ name = "", theme: theme36 = {}, params, props = {}, set: set2, defaults }) {
    var _a2;
    const options3 = { name, theme: theme36, params, set: set2, defaults };
    const preset_css = (_a2 = name.includes("-directive") ? this.getPresetD(options3) : this.getPresetC(options3)) == null ? void 0 : _a2.css;
    const _props = Object.entries(props).reduce((acc, [k, v2]) => acc.push(`${k}="${v2}"`) && acc, []).join(" ");
    return preset_css ? `<style type="text/css" data-primevue-style-id="${name}-variables" ${_props}>${minifyCSS(preset_css)}</style>` : "";
  },
  createTokens(obj = {}, defaults, parentKey = "", parentPath = "", tokens = {}) {
    Object.entries(obj).forEach(([key, value3]) => {
      const currentKey = matchRegex(key, defaults.variable.excludedKeyRegex) ? parentKey : parentKey ? `${parentKey}.${toTokenKey$1(key)}` : toTokenKey$1(key);
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      if (isObject$3(value3)) {
        this.createTokens(value3, defaults, currentKey, currentPath, tokens);
      } else {
        tokens[currentKey] || (tokens[currentKey] = {
          paths: [],
          computed(colorScheme, tokenPathMap = {}) {
            if (colorScheme) {
              const path = this.paths.find((p2) => p2.scheme === colorScheme) || this.paths.find((p2) => p2.scheme === "none");
              return path == null ? void 0 : path.computed(colorScheme, tokenPathMap["binding"]);
            }
            return this.paths.map((p2) => p2.computed(p2.scheme, tokenPathMap[p2.scheme]));
          }
        });
        tokens[currentKey].paths.push({
          path: currentPath,
          value: value3,
          scheme: currentPath.includes("colorScheme.light") ? "light" : currentPath.includes("colorScheme.dark") ? "dark" : "none",
          computed(colorScheme, tokenPathMap = {}) {
            const regex = /{([^}]*)}/g;
            let computedValue = value3;
            tokenPathMap["name"] = this.path;
            tokenPathMap["binding"] || (tokenPathMap["binding"] = {});
            if (matchRegex(value3, regex)) {
              const val = value3.trim();
              const _val = val.replaceAll(regex, (v2) => {
                var _a2, _b;
                const path = v2.replace(/{|}/g, "");
                return (_b = (_a2 = tokens[path]) == null ? void 0 : _a2.computed(colorScheme, tokenPathMap)) == null ? void 0 : _b.value;
              });
              const calculationRegex = /(\d+\w*\s+[\+\-\*\/]\s+\d+\w*)/g;
              const cleanedVarRegex = /var\([^)]+\)/g;
              computedValue = matchRegex(_val.replace(cleanedVarRegex, "0"), calculationRegex) ? `calc(${_val})` : _val;
            }
            isEmpty(tokenPathMap["binding"]) && delete tokenPathMap["binding"];
            return {
              colorScheme,
              path: this.path,
              paths: tokenPathMap,
              value: computedValue.includes("undefined") ? void 0 : computedValue
            };
          }
        });
      }
    });
    return tokens;
  },
  getTokenValue(tokens, path, defaults) {
    var _a2;
    const normalizePath = (str) => {
      const strArr = str.split(".");
      return strArr.filter((s) => !matchRegex(s.toLowerCase(), defaults.variable.excludedKeyRegex)).join(".");
    };
    const token = normalizePath(path);
    const colorScheme = path.includes("colorScheme.light") ? "light" : path.includes("colorScheme.dark") ? "dark" : void 0;
    const computedValues = [(_a2 = tokens[token]) == null ? void 0 : _a2.computed(colorScheme)].flat().filter((computed2) => computed2);
    return computedValues.length === 1 ? computedValues[0].value : computedValues.reduce((acc = {}, computed2) => {
      const _a22 = computed2, { colorScheme: cs } = _a22, rest = __objRest(_a22, ["colorScheme"]);
      acc[cs] = rest;
      return acc;
    }, void 0);
  },
  transformCSS(name, css22, mode2, type, options3 = {}, set2, defaults, selector) {
    if (isNotEmpty(css22)) {
      const { cssLayer } = options3;
      if (type !== "style") {
        const colorSchemeOption = this.getColorSchemeOption(options3, defaults);
        const _css = selector ? getRule(selector, css22) : css22;
        css22 = mode2 === "dark" ? colorSchemeOption.reduce((acc, { selector: _selector }) => {
          if (isNotEmpty(_selector)) {
            acc += _selector.includes("[CSS]") ? _selector.replace("[CSS]", _css) : getRule(_selector, _css);
          }
          return acc;
        }, "") : getRule(selector != null ? selector : ":root", css22);
      }
      if (cssLayer) {
        const layerOptions = {
          name: "primeui",
          order: "primeui"
        };
        isObject$3(cssLayer) && (layerOptions.name = resolve(cssLayer.name, { name, type }));
        if (isNotEmpty(layerOptions.name)) {
          css22 = getRule(`@layer ${layerOptions.name}`, css22);
          set2 == null ? void 0 : set2.layerNames(layerOptions.name);
        }
      }
      return css22;
    }
    return "";
  }
};
var config_default = {
  defaults: {
    variable: {
      prefix: "p",
      selector: ":root",
      excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states)$/gi
    },
    options: {
      prefix: "p",
      darkModeSelector: "system",
      cssLayer: false
    }
  },
  _theme: void 0,
  _layerNames: /* @__PURE__ */ new Set(),
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  _loadingStyles: /* @__PURE__ */ new Set(),
  _tokens: {},
  update(newValues = {}) {
    const { theme: theme36 } = newValues;
    if (theme36) {
      this._theme = __spreadProps(__spreadValues({}, theme36), {
        options: __spreadValues(__spreadValues({}, this.defaults.options), theme36.options)
      });
      this._tokens = themeUtils_default.createTokens(this.preset, this.defaults);
      this.clearLoadedStyleNames();
    }
  },
  get theme() {
    return this._theme;
  },
  get preset() {
    var _a2;
    return ((_a2 = this.theme) == null ? void 0 : _a2.preset) || {};
  },
  get options() {
    var _a2;
    return ((_a2 = this.theme) == null ? void 0 : _a2.options) || {};
  },
  get tokens() {
    return this._tokens;
  },
  getTheme() {
    return this.theme;
  },
  setTheme(newValue) {
    this.update({ theme: newValue });
    service_default.emit("theme:change", newValue);
  },
  getPreset() {
    return this.preset;
  },
  setPreset(newValue) {
    this._theme = __spreadProps(__spreadValues({}, this.theme), { preset: newValue });
    this._tokens = themeUtils_default.createTokens(newValue, this.defaults);
    this.clearLoadedStyleNames();
    service_default.emit("preset:change", newValue);
    service_default.emit("theme:change", this.theme);
  },
  getOptions() {
    return this.options;
  },
  setOptions(newValue) {
    this._theme = __spreadProps(__spreadValues({}, this.theme), { options: newValue });
    this.clearLoadedStyleNames();
    service_default.emit("options:change", newValue);
    service_default.emit("theme:change", this.theme);
  },
  getLayerNames() {
    return [...this._layerNames];
  },
  setLayerNames(layerName) {
    this._layerNames.add(layerName);
  },
  getLoadedStyleNames() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  },
  setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  },
  deleteLoadedStyleName(name) {
    this._loadedStyleNames.delete(name);
  },
  clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  },
  getTokenValue(tokenPath) {
    return themeUtils_default.getTokenValue(this.tokens, tokenPath, this.defaults);
  },
  getCommon(name = "", params) {
    return themeUtils_default.getCommon({ name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  getComponent(name = "", params) {
    const options3 = { name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPresetC(options3);
  },
  getDirective(name = "", params) {
    const options3 = { name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPresetD(options3);
  },
  getCustomPreset(name = "", preset, selector, params) {
    const options3 = { name, preset, options: this.options, selector, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPreset(options3);
  },
  getLayerOrderCSS(name = "") {
    return themeUtils_default.getLayerOrder(name, this.options, { names: this.getLayerNames() }, this.defaults);
  },
  transformCSS(name = "", css22, type = "style", mode2) {
    return themeUtils_default.transformCSS(name, css22, mode2, type, this.options, { layerNames: this.setLayerNames.bind(this) }, this.defaults);
  },
  getCommonStyleSheet(name = "", params, props = {}) {
    return themeUtils_default.getCommonStyleSheet({ name, theme: this.theme, params, props, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  getStyleSheet(name, params, props = {}) {
    return themeUtils_default.getStyleSheet({ name, theme: this.theme, params, props, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  onStyleMounted(name) {
    this._loadingStyles.add(name);
  },
  onStyleUpdated(name) {
    this._loadingStyles.add(name);
  },
  onStyleLoaded(event2, { name }) {
    if (this._loadingStyles.size) {
      this._loadingStyles.delete(name);
      service_default.emit(`theme:${name}:load`, event2);
      !this._loadingStyles.size && service_default.emit("theme:load");
    }
  }
};
function updatePreset$1(...presets) {
  const newPreset = mergeKeys(config_default.getPreset(), ...presets);
  config_default.setPreset(newPreset);
  return newPreset;
}
function updatePrimaryPalette$1(primary) {
  return $t$1().primaryPalette(primary).update().preset;
}
function updateSurfacePalette$1(palette2) {
  return $t$1().surfacePalette(palette2).update().preset;
}
function usePreset$1(...presets) {
  const newPreset = mergeKeys(...presets);
  config_default.setPreset(newPreset);
  return newPreset;
}
function useTheme$1(theme36) {
  return $t$1(theme36).update({ mergePresets: false });
}
var FilterMatchMode = {
  STARTS_WITH: "startsWith",
  CONTAINS: "contains",
  NOT_CONTAINS: "notContains",
  ENDS_WITH: "endsWith",
  EQUALS: "equals",
  NOT_EQUALS: "notEquals",
  IN: "in",
  LESS_THAN: "lt",
  LESS_THAN_OR_EQUAL_TO: "lte",
  GREATER_THAN: "gt",
  GREATER_THAN_OR_EQUAL_TO: "gte",
  BETWEEN: "between",
  DATE_IS: "dateIs",
  DATE_IS_NOT: "dateIsNot",
  DATE_BEFORE: "dateBefore",
  DATE_AFTER: "dateAfter"
};
var FilterOperator = {
  AND: "and",
  OR: "or"
};
function _createForOfIteratorHelper$7(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$n(r)) || e) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray$n(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$n(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$n(r, a) : void 0;
  }
}
function _arrayLikeToArray$n(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var FilterService = {
  filter: function filter2(value3, fields, filterValue, filterMatchMode, filterLocale) {
    var filteredItems = [];
    if (!value3) {
      return filteredItems;
    }
    var _iterator = _createForOfIteratorHelper$7(value3), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item = _step.value;
        if (typeof item === "string") {
          if (this.filters[filterMatchMode](item, filterValue, filterLocale)) {
            filteredItems.push(item);
            continue;
          }
        } else {
          var _iterator2 = _createForOfIteratorHelper$7(fields), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var field2 = _step2.value;
              var fieldValue = resolveFieldData(item, field2);
              if (this.filters[filterMatchMode](fieldValue, filterValue, filterLocale)) {
                filteredItems.push(item);
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return filteredItems;
  },
  filters: {
    startsWith: function startsWith(value3, filter5, filterLocale) {
      if (filter5 === void 0 || filter5 === null || filter5 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter5.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.slice(0, filterValue.length) === filterValue;
    },
    contains: function contains2(value3, filter5, filterLocale) {
      if (filter5 === void 0 || filter5 === null || filter5 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter5.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) !== -1;
    },
    notContains: function notContains(value3, filter5, filterLocale) {
      if (filter5 === void 0 || filter5 === null || filter5 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter5.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) === -1;
    },
    endsWith: function endsWith(value3, filter5, filterLocale) {
      if (filter5 === void 0 || filter5 === null || filter5 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      var filterValue = removeAccents(filter5.toString()).toLocaleLowerCase(filterLocale);
      var stringValue = removeAccents(value3.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue, stringValue.length - filterValue.length) !== -1;
    },
    equals: function equals2(value3, filter5, filterLocale) {
      if (filter5 === void 0 || filter5 === null || filter5 === "") {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter5.getTime) return value3.getTime() === filter5.getTime();
      else return removeAccents(value3.toString()).toLocaleLowerCase(filterLocale) == removeAccents(filter5.toString()).toLocaleLowerCase(filterLocale);
    },
    notEquals: function notEquals(value3, filter5, filterLocale) {
      if (filter5 === void 0 || filter5 === null || filter5 === "") {
        return false;
      }
      if (value3 === void 0 || value3 === null) {
        return true;
      }
      if (value3.getTime && filter5.getTime) return value3.getTime() !== filter5.getTime();
      else return removeAccents(value3.toString()).toLocaleLowerCase(filterLocale) != removeAccents(filter5.toString()).toLocaleLowerCase(filterLocale);
    },
    "in": function _in(value3, filter5) {
      if (filter5 === void 0 || filter5 === null || filter5.length === 0) {
        return true;
      }
      for (var i2 = 0; i2 < filter5.length; i2++) {
        if (equals(value3, filter5[i2])) {
          return true;
        }
      }
      return false;
    },
    between: function between(value3, filter5) {
      if (filter5 == null || filter5[0] == null || filter5[1] == null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime) return filter5[0].getTime() <= value3.getTime() && value3.getTime() <= filter5[1].getTime();
      else return filter5[0] <= value3 && value3 <= filter5[1];
    },
    lt: function lt(value3, filter5) {
      if (filter5 === void 0 || filter5 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter5.getTime) return value3.getTime() < filter5.getTime();
      else return value3 < filter5;
    },
    lte: function lte(value3, filter5) {
      if (filter5 === void 0 || filter5 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter5.getTime) return value3.getTime() <= filter5.getTime();
      else return value3 <= filter5;
    },
    gt: function gt(value3, filter5) {
      if (filter5 === void 0 || filter5 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter5.getTime) return value3.getTime() > filter5.getTime();
      else return value3 > filter5;
    },
    gte: function gte(value3, filter5) {
      if (filter5 === void 0 || filter5 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      if (value3.getTime && filter5.getTime) return value3.getTime() >= filter5.getTime();
      else return value3 >= filter5;
    },
    dateIs: function dateIs(value3, filter5) {
      if (filter5 === void 0 || filter5 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.toDateString() === filter5.toDateString();
    },
    dateIsNot: function dateIsNot(value3, filter5) {
      if (filter5 === void 0 || filter5 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.toDateString() !== filter5.toDateString();
    },
    dateBefore: function dateBefore(value3, filter5) {
      if (filter5 === void 0 || filter5 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.getTime() < filter5.getTime();
    },
    dateAfter: function dateAfter(value3, filter5) {
      if (filter5 === void 0 || filter5 === null) {
        return true;
      }
      if (value3 === void 0 || value3 === null) {
        return false;
      }
      return value3.getTime() > filter5.getTime();
    }
  },
  register: function register2(rule, fn) {
    this.filters[rule] = fn;
  }
};
var PrimeIcons = {
  ALIGN_CENTER: "pi pi-align-center",
  ALIGN_JUSTIFY: "pi pi-align-justify",
  ALIGN_LEFT: "pi pi-align-left",
  ALIGN_RIGHT: "pi pi-align-right",
  AMAZON: "pi pi-amazon",
  ANDROID: "pi pi-android",
  ANGLE_DOUBLE_DOWN: "pi pi-angle-double-down",
  ANGLE_DOUBLE_LEFT: "pi pi-angle-double-left",
  ANGLE_DOUBLE_RIGHT: "pi pi-angle-double-right",
  ANGLE_DOUBLE_UP: "pi pi-angle-double-up",
  ANGLE_DOWN: "pi pi-angle-down",
  ANGLE_LEFT: "pi pi-angle-left",
  ANGLE_RIGHT: "pi pi-angle-right",
  ANGLE_UP: "pi pi-angle-up",
  APPLE: "pi pi-apple",
  ARROW_CIRCLE_DOWN: "pi pi-arrow-circle-down",
  ARROW_CIRCLE_LEFT: "pi pi-arrow-circle-left",
  ARROW_CIRCLE_RIGHT: "pi pi-arrow-circle-right",
  ARROW_CIRCLE_UP: "pi pi-arrow-circle-up",
  ARROW_DOWN: "pi pi-arrow-down",
  ARROW_DOWN_LEFT: "pi pi-arrow-down-left",
  ARROW_DOWN_RIGHT: "pi pi-arrow-down-right",
  ARROW_LEFT: "pi pi-arrow-left",
  ARROW_RIGHT: "pi pi-arrow-right",
  ARROW_RIGHT_ARROW_LEFT: "pi pi-arrow-right-arrow-left",
  ARROW_UP: "pi pi-arrow-up",
  ARROW_UP_LEFT: "pi pi-arrow-up-left",
  ARROW_UP_RIGHT: "pi pi-arrow-up-right",
  ARROW_H: "pi pi-arrows-h",
  ARROW_V: "pi pi-arrows-v",
  ARROW_A: "pi pi-arrows-alt",
  AT: "pi pi-at",
  BACKWARD: "pi pi-backward",
  BAN: "pi pi-ban",
  BARS: "pi pi-bars",
  BELL: "pi pi-bell",
  BITCOIN: "pi pi-bitcoin",
  BOLT: "pi pi-bolt",
  BOOK: "pi pi-book",
  BOOKMARK: "pi pi-bookmark",
  BOOKMARK_FILL: "pi pi-bookmark-fill",
  BOX: "pi pi-box",
  BRIEFCASE: "pi pi-briefcase",
  BUILDING: "pi pi-building",
  CALENDAR: "pi pi-calendar",
  CALENDAR_MINUS: "pi pi-calendar-minus",
  CALENDAR_PLUS: "pi pi-calendar-plus",
  CALENDAR_TIMES: "pi pi-calendar-times",
  CALCULATOR: "pi pi-calculator",
  CAMERA: "pi pi-camera",
  CAR: "pi pi-car",
  CARET_DOWN: "pi pi-caret-down",
  CARET_LEFT: "pi pi-caret-left",
  CARET_RIGHT: "pi pi-caret-right",
  CARET_UP: "pi pi-caret-up",
  CART_PLUS: "pi pi-cart-plus",
  CHART_BAR: "pi pi-chart-bar",
  CHART_LINE: "pi pi-chart-line",
  CHART_PIE: "pi pi-chart-pie",
  CHECK: "pi pi-check",
  CHECK_CIRCLE: "pi pi-check-circle",
  CHECK_SQUARE: "pi pi-check-square",
  CHEVRON_CIRCLE_DOWN: "pi pi-chevron-circle-down",
  CHEVRON_CIRCLE_LEFT: "pi pi-chevron-circle-left",
  CHEVRON_CIRCLE_RIGHT: "pi pi-chevron-circle-right",
  CHEVRON_CIRCLE_UP: "pi pi-chevron-circle-up",
  CHEVRON_DOWN: "pi pi-chevron-down",
  CHEVRON_LEFT: "pi pi-chevron-left",
  CHEVRON_RIGHT: "pi pi-chevron-right",
  CHEVRON_UP: "pi pi-chevron-up",
  CIRCLE: "pi pi-circle",
  CIRCLE_FILL: "pi pi-circle-fill",
  CLOCK: "pi pi-clock",
  CLONE: "pi pi-clone",
  CLOUD: "pi pi-cloud",
  CLOUD_DOWNLOAD: "pi pi-cloud-download",
  CLOUD_UPLOAD: "pi pi-cloud-upload",
  CODE: "pi pi-code",
  COG: "pi pi-cog",
  COMMENT: "pi pi-comment",
  COMMENTS: "pi pi-comments",
  COMPASS: "pi pi-compass",
  COPY: "pi pi-copy",
  CREDIT_CARD: "pi pi-credit-card",
  DATABASE: "pi pi-database",
  DELETELEFT: "pi pi-delete-left",
  DESKTOP: "pi pi-desktop",
  DIRECTIONS: "pi pi-directions",
  DIRECTIONS_ALT: "pi pi-directions-alt",
  DISCORD: "pi pi-discord",
  DOLLAR: "pi pi-dollar",
  DOWNLOAD: "pi pi-download",
  EJECT: "pi pi-eject",
  ELLIPSIS_H: "pi pi-ellipsis-h",
  ELLIPSIS_V: "pi pi-ellipsis-v",
  ENVELOPE: "pi pi-envelope",
  ERASER: "pi pi-eraser",
  EURO: "pi pi-euro",
  EXCLAMATION_CIRCLE: "pi pi-exclamation-circle",
  EXCLAMATION_TRIANGLE: "pi pi-exclamation-triangle",
  EXTERNAL_LINK: "pi pi-external-link",
  EYE: "pi pi-eye",
  EYE_SLASH: "pi pi-eye-slash",
  FACEBOOK: "pi pi-facebook",
  FAST_BACKWARD: "pi pi-fast-backward",
  FAST_FORWARD: "pi pi-fast-forward",
  FILE: "pi pi-file",
  FILE_EDIT: "pi pi-file-edit",
  FILE_EXCEL: "pi pi-file-excel",
  FILE_EXPORT: "pi pi-file-export",
  FILE_IMPORT: "pi pi-file-import",
  FILE_PDF: "pi pi-file-pdf",
  FILE_WORD: "pi pi-file-word",
  FILTER: "pi pi-filter",
  FILTER_FILL: "pi pi-filter-fill",
  FILTER_SLASH: "pi pi-filter-slash",
  FLAG: "pi pi-flag",
  FLAG_FILL: "pi pi-flag-fill",
  FOLDER: "pi pi-folder",
  FOLDER_OPEN: "pi pi-folder-open",
  FORWARD: "pi pi-forward",
  GIFT: "pi pi-gift",
  GITHUB: "pi pi-github",
  GLOBE: "pi pi-globe",
  GOOGLE: "pi pi-google",
  HASHTAG: "pi pi-hashtag",
  HEART: "pi pi-heart",
  HEART_FILL: "pi pi-heart-fill",
  HISTORY: "pi pi-history",
  HOURGLASS: "pi pi-hourglass",
  HOME: "pi pi-home",
  ID_CARD: "pi pi-id-card",
  IMAGE: "pi pi-image",
  IMAGES: "pi pi-images",
  INBOX: "pi pi-inbox",
  INFO: "pi pi-info",
  INFO_CIRCLE: "pi pi-info-circle",
  INSTAGRAM: "pi pi-instagram",
  KEY: "pi pi-key",
  LANGUAGE: "pi pi-language",
  LINK: "pi pi-link",
  LINKEDIN: "pi pi-linkedin",
  LIST: "pi pi-list",
  LOCK: "pi pi-lock",
  LOCK_OPEN: "pi pi-lock-open",
  MAP: "pi pi-map",
  MAP_MARKER: "pi pi-map-marker",
  MEGAPHONE: "pi pi-megaphone",
  MICREPHONE: "pi pi-microphone",
  MICROSOFT: "pi pi-microsoft",
  MINUS: "pi pi-minus",
  MINUS_CIRCLE: "pi pi-minus-circle",
  MOBILE: "pi pi-mobile",
  MONEY_BILL: "pi pi-money-bill",
  MOON: "pi pi-moon",
  PALETTE: "pi pi-palette",
  PAPERCLIP: "pi pi-paperclip",
  PAUSE: "pi pi-pause",
  PAYPAL: "pi pi-paypal",
  PENCIL: "pi pi-pencil",
  PERCENTAGE: "pi pi-percentage",
  PHONE: "pi pi-phone",
  PLAY: "pi pi-play",
  PLUS: "pi pi-plus",
  PLUS_CIRCLE: "pi pi-plus-circle",
  POUND: "pi pi-pound",
  POWER_OFF: "pi pi-power-off",
  PRIME: "pi pi-prime",
  PRINT: "pi pi-print",
  QRCODE: "pi pi-qrcode",
  QUESTION: "pi pi-question",
  QUESTION_CIRCLE: "pi pi-question-circle",
  REDDIT: "pi pi-reddit",
  REFRESH: "pi pi-refresh",
  REPLAY: "pi pi-replay",
  REPLY: "pi pi-reply",
  SAVE: "pi pi-save",
  SEARCH: "pi pi-search",
  SEARCH_MINUS: "pi pi-search-minus",
  SEARCH_PLUS: "pi pi-search-plus",
  SEND: "pi pi-send",
  SERVER: "pi pi-server",
  SHARE_ALT: "pi pi-share-alt",
  SHIELD: "pi pi-shield",
  SHOPPING_BAG: "pi pi-shopping-bag",
  SHOPPING_CART: "pi pi-shopping-cart",
  SIGN_IN: "pi pi-sign-in",
  SIGN_OUT: "pi pi-sign-out",
  SITEMAP: "pi pi-sitemap",
  SLACK: "pi pi-slack",
  SLIDERS_H: "pi pi-sliders-h",
  SLIDERS_V: "pi pi-sliders-v",
  SORT: "pi pi-sort",
  SORT_ALPHA_DOWN: "pi pi-sort-alpha-down",
  SORT_ALPHA_ALT_DOWN: "pi pi-sort-alpha-down-alt",
  SORT_ALPHA_UP: "pi pi-sort-alpha-up",
  SORT_ALPHA_ALT_UP: "pi pi-sort-alpha-up-alt",
  SORT_ALT: "pi pi-sort-alt",
  SORT_ALT_SLASH: "pi pi-sort-alt-slash",
  SORT_AMOUNT_DOWN: "pi pi-sort-amount-down",
  SORT_AMOUNT_DOWN_ALT: "pi pi-sort-amount-down-alt",
  SORT_AMOUNT_UP: "pi pi-sort-amount-up",
  SORT_AMOUNT_UP_ALT: "pi pi-sort-amount-up-alt",
  SORT_DOWN: "pi pi-sort-down",
  SORT_NUMERIC_DOWN: "pi pi-sort-numeric-down",
  SORT_NUMERIC_ALT_DOWN: "pi pi-sort-numeric-down-alt",
  SORT_NUMERIC_UP: "pi pi-sort-numeric-up",
  SORT_NUMERIC_ALT_UP: "pi pi-sort-numeric-up-alt",
  SORT_UP: "pi pi-sort-up",
  SPINNER: "pi pi-spinner",
  STAR: "pi pi-star",
  STAR_FILL: "pi pi-star-fill",
  STEP_BACKWARD: "pi pi-step-backward",
  STEP_BACKWARD_ALT: "pi pi-step-backward-alt",
  STEP_FORWARD: "pi pi-step-forward",
  STEP_FORWARD_ALT: "pi pi-step-forward-alt",
  STOP: "pi pi-stop",
  STOPWATCH: "pi pi-stopwatch",
  STOP_CIRCLE: "pi pi-stop-circle",
  SUN: "pi pi-sun",
  SYNC: "pi pi-sync",
  TABLE: "pi pi-table",
  TABLET: "pi pi-tablet",
  TAG: "pi pi-tag",
  TAGS: "pi pi-tags",
  TELEGRAM: "pi pi-telegram",
  TH_LARGE: "pi pi-th-large",
  THUMBS_DOWN: "pi pi-thumbs-down",
  THUMBS_DOWN_FILL: "pi pi-thumbs-down-fill",
  THUMBS_UP: "pi pi-thumbs-up",
  THUMBS_UP_FILL: "pi pi-thumbs-up-fill",
  TICKET: "pi pi-ticket",
  TIMES: "pi pi-times",
  TIMES_CIRCLE: "pi pi-times-circle",
  TRASH: "pi pi-trash",
  TRUCK: "pi pi-truck",
  TWITTER: "pi pi-twitter",
  UNDO: "pi pi-undo",
  UNLOCK: "pi pi-unlock",
  UPLOAD: "pi pi-upload",
  USER: "pi pi-user",
  USER_EDIT: "pi pi-user-edit",
  USER_MINUS: "pi pi-user-minus",
  USER_PLUS: "pi pi-user-plus",
  USERS: "pi pi-users",
  VERIFIED: "pi pi-verified",
  VIDEO: "pi pi-video",
  VIMEO: "pi pi-vimeo",
  VOLUME_DOWN: "pi pi-volume-down",
  VOLUME_OFF: "pi pi-volume-off",
  VOLUME_UP: "pi pi-volume-up",
  WALLET: "pi pi-wallet",
  WHATSAPP: "pi pi-whatsapp",
  WIFI: "pi pi-wifi",
  WINDOW_MAXIMIZE: "pi pi-window-maximize",
  WINDOW_MINIMIZE: "pi pi-window-minimize",
  WRENCH: "pi pi-wrench",
  YOUTUBE: "pi pi-youtube"
};
var ToastSeverities = {
  INFO: "info",
  WARN: "warn",
  ERROR: "error",
  SUCCESS: "success"
};
function hasClass(element, className) {
  if (element) {
    if (element.classList) return element.classList.contains(className);
    else return new RegExp("(^| )" + className + "( |$)", "gi").test(element.className);
  }
  return false;
}
function addClass(element, className) {
  if (element && className) {
    const fn = (_className) => {
      if (!hasClass(element, _className)) {
        if (element.classList) element.classList.add(_className);
        else element.className += " " + _className;
      }
    };
    [className].flat().filter(Boolean).forEach((_classNames) => _classNames.split(" ").forEach(fn));
  }
}
function calculateBodyScrollbarWidth() {
  return window.innerWidth - document.documentElement.offsetWidth;
}
function getCSSVariableByRegex(variableRegex) {
  for (const sheet of document == null ? void 0 : document.styleSheets) {
    try {
      for (const rule of sheet == null ? void 0 : sheet.cssRules) {
        for (const property of rule == null ? void 0 : rule.style) {
          if (variableRegex.test(property)) {
            return { name: property, value: rule.style.getPropertyValue(property).trim() };
          }
        }
      }
    } catch (e) {
    }
  }
  return null;
}
function blockBodyScroll(className = "p-overflow-hidden") {
  const variableData = getCSSVariableByRegex(/-scrollbar-width$/);
  (variableData == null ? void 0 : variableData.name) && document.body.style.setProperty(variableData.name, calculateBodyScrollbarWidth() + "px");
  addClass(document.body, className);
}
function saveAs$1(file) {
  if (file) {
    let link = document.createElement("a");
    if (link.download !== void 0) {
      const { name, src } = file;
      link.setAttribute("href", src);
      link.setAttribute("download", name);
      link.style.display = "none";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      return true;
    }
  }
  return false;
}
function exportCSV(csv, filename) {
  let blob = new Blob([csv], {
    type: "application/csv;charset=utf-8;"
  });
  if (window.navigator.msSaveOrOpenBlob) {
    navigator.msSaveOrOpenBlob(blob, filename + ".csv");
  } else {
    const isDownloaded = saveAs$1({ name: filename + ".csv", src: URL.createObjectURL(blob) });
    if (!isDownloaded) {
      csv = "data:text/csv;charset=utf-8," + csv;
      window.open(encodeURI(csv));
    }
  }
}
function removeClass(element, className) {
  if (element && className) {
    const fn = (_className) => {
      if (element.classList) element.classList.remove(_className);
      else element.className = element.className.replace(new RegExp("(^|\\b)" + _className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    };
    [className].flat().filter(Boolean).forEach((_classNames) => _classNames.split(" ").forEach(fn));
  }
}
function unblockBodyScroll(className = "p-overflow-hidden") {
  const variableData = getCSSVariableByRegex(/-scrollbar-width$/);
  (variableData == null ? void 0 : variableData.name) && document.body.style.removeProperty(variableData.name);
  removeClass(document.body, className);
}
function getHiddenElementDimensions(element) {
  let dimensions = { width: 0, height: 0 };
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    dimensions.width = element.offsetWidth;
    dimensions.height = element.offsetHeight;
    element.style.display = "none";
    element.style.visibility = "visible";
  }
  return dimensions;
}
function getViewport() {
  let win = window, d = document, e = d.documentElement, g = d.getElementsByTagName("body")[0], w2 = win.innerWidth || e.clientWidth || g.clientWidth, h2 = win.innerHeight || e.clientHeight || g.clientHeight;
  return { width: w2, height: h2 };
}
function getWindowScrollLeft() {
  let doc2 = document.documentElement;
  return (window.pageXOffset || doc2.scrollLeft) - (doc2.clientLeft || 0);
}
function getWindowScrollTop() {
  let doc2 = document.documentElement;
  return (window.pageYOffset || doc2.scrollTop) - (doc2.clientTop || 0);
}
function absolutePosition(element, target, gutter = true) {
  var _a2, _b, _c, _d;
  if (element) {
    const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);
    const elementOuterHeight = elementDimensions.height;
    const elementOuterWidth = elementDimensions.width;
    const targetOuterHeight = target.offsetHeight;
    const targetOuterWidth = target.offsetWidth;
    const targetOffset = target.getBoundingClientRect();
    const windowScrollTop = getWindowScrollTop();
    const windowScrollLeft = getWindowScrollLeft();
    const viewport = getViewport();
    let top, left, origin = "top";
    if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
      top = targetOffset.top + windowScrollTop - elementOuterHeight;
      origin = "bottom";
      if (top < 0) {
        top = windowScrollTop;
      }
    } else {
      top = targetOuterHeight + targetOffset.top + windowScrollTop;
    }
    if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);
    else left = targetOffset.left + windowScrollLeft;
    element.style.top = top + "px";
    element.style.left = left + "px";
    element.style.transformOrigin = origin;
    gutter && (element.style.marginTop = origin === "bottom" ? `calc(${(_b = (_a2 = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a2.value) != null ? _b : "2px"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : "");
  }
}
function addStyle(element, style) {
  if (element) {
    if (typeof style === "string") {
      element.style.cssText = style;
    } else {
      Object.entries(style || {}).forEach(([key, value3]) => element.style[key] = value3);
    }
  }
}
function getOuterWidth(element, margin) {
  if (element instanceof HTMLElement) {
    let width2 = element.offsetWidth;
    if (margin) {
      let style = getComputedStyle(element);
      width2 += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    }
    return width2;
  }
  return 0;
}
function relativePosition(element, target, gutter = true) {
  var _a2, _b, _c, _d;
  if (element) {
    const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);
    const targetHeight = target.offsetHeight;
    const targetOffset = target.getBoundingClientRect();
    const viewport = getViewport();
    let top, left, origin = "top";
    if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {
      top = -1 * elementDimensions.height;
      origin = "bottom";
      if (targetOffset.top + top < 0) {
        top = -1 * targetOffset.top;
      }
    } else {
      top = targetHeight;
    }
    if (elementDimensions.width > viewport.width) {
      left = targetOffset.left * -1;
    } else if (targetOffset.left + elementDimensions.width > viewport.width) {
      left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;
    } else {
      left = 0;
    }
    element.style.top = top + "px";
    element.style.left = left + "px";
    element.style.transformOrigin = origin;
    gutter && (element.style.marginTop = origin === "bottom" ? `calc(${(_b = (_a2 = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a2.value) != null ? _b : "2px"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : "");
  }
}
function alignOverlay(overlay, target, appendTo, calculateMinWidth = true) {
  if (overlay && target) {
    if (appendTo === "self") {
      relativePosition(overlay, target);
    } else {
      calculateMinWidth && (overlay.style.minWidth = getOuterWidth(target) + "px");
      absolutePosition(overlay, target);
    }
  }
}
function isElement(element) {
  return typeof HTMLElement === "object" ? element instanceof HTMLElement : element && typeof element === "object" && element !== null && element.nodeType === 1 && typeof element.nodeName === "string";
}
function toElement(element) {
  let target = element;
  if (element && typeof element === "object") {
    if (element.hasOwnProperty("current")) {
      target = element.current;
    } else if (element.hasOwnProperty("el")) {
      if (element.el.hasOwnProperty("nativeElement")) {
        target = element.el.nativeElement;
      } else {
        target = element.el;
      }
    }
  }
  return isElement(target) ? target : void 0;
}
function appendChild(element, child) {
  const target = toElement(element);
  if (target) target.appendChild(child);
  else throw new Error("Cannot append " + child + " to " + element);
}
var calculatedScrollbarHeight = void 0;
function calculateScrollbarHeight(element) {
  if (element) {
    let style = getComputedStyle(element);
    return element.offsetHeight - element.clientHeight - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth);
  } else {
    if (calculatedScrollbarHeight != null) return calculatedScrollbarHeight;
    let scrollDiv = document.createElement("div");
    addStyle(scrollDiv, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-9999px"
    });
    document.body.appendChild(scrollDiv);
    let scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;
    document.body.removeChild(scrollDiv);
    calculatedScrollbarHeight = scrollbarHeight;
    return scrollbarHeight;
  }
}
var calculatedScrollbarWidth = void 0;
function calculateScrollbarWidth(element) {
  if (element) {
    let style = getComputedStyle(element);
    return element.offsetWidth - element.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);
  } else {
    if (calculatedScrollbarWidth != null) return calculatedScrollbarWidth;
    let scrollDiv = document.createElement("div");
    addStyle(scrollDiv, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-9999px"
    });
    document.body.appendChild(scrollDiv);
    let scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    calculatedScrollbarWidth = scrollbarWidth;
    return scrollbarWidth;
  }
}
function clearSelection() {
  if (window.getSelection) {
    const selection = window.getSelection() || {};
    if (selection.empty) {
      selection.empty();
    } else if (selection.removeAllRanges && selection.rangeCount > 0 && selection.getRangeAt(0).getClientRects().length > 0) {
      selection.removeAllRanges();
    }
  }
}
function setAttributes(element, attributes = {}) {
  if (isElement(element)) {
    const computedStyles = (rule, value3) => {
      var _a2, _b;
      const styles = ((_a2 = element == null ? void 0 : element.$attrs) == null ? void 0 : _a2[rule]) ? [(_b = element == null ? void 0 : element.$attrs) == null ? void 0 : _b[rule]] : [];
      return [value3].flat().reduce((cv, v2) => {
        if (v2 !== null && v2 !== void 0) {
          const type = typeof v2;
          if (type === "string" || type === "number") {
            cv.push(v2);
          } else if (type === "object") {
            const _cv = Array.isArray(v2) ? computedStyles(rule, v2) : Object.entries(v2).map(([_k, _v]) => rule === "style" && (!!_v || _v === 0) ? `${_k.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${_v}` : !!_v ? _k : void 0);
            cv = _cv.length ? cv.concat(_cv.filter((c) => !!c)) : cv;
          }
        }
        return cv;
      }, styles);
    };
    Object.entries(attributes).forEach(([key, value3]) => {
      if (value3 !== void 0 && value3 !== null) {
        const matchedEvent = key.match(/^on(.+)/);
        if (matchedEvent) {
          element.addEventListener(matchedEvent[1].toLowerCase(), value3);
        } else if (key === "p-bind") {
          setAttributes(element, value3);
        } else {
          value3 = key === "class" ? [...new Set(computedStyles("class", value3))].join(" ").trim() : key === "style" ? computedStyles("style", value3).join(";").trim() : value3;
          (element.$attrs = element.$attrs || {}) && (element.$attrs[key] = value3);
          element.setAttribute(key, value3);
        }
      }
    });
  }
}
function createElement(type, attributes = {}, ...children) {
  if (type) {
    const element = document.createElement(type);
    setAttributes(element, attributes);
    element.append(...children);
    return element;
  }
  return void 0;
}
function createStyleAsString(css4, options3 = {}) {
  return css4 ? `'<style type="text/css" ${Object.entries(options3).reduce((s, [k, v2]) => s + `${k}="${v2}"`, " ")}>${css4}</style>'` : "";
}
function createStyleTag(attributes = {}, container) {
  let element = document.createElement("style");
  setAttributes(element, attributes);
  if (!container) {
    container = document.head;
  }
  container.appendChild(element);
  return element;
}
function fadeIn(element, duration) {
  if (element) {
    element.style.opacity = "0";
    let last2 = +/* @__PURE__ */ new Date();
    let opacity = "0";
    let tick = function() {
      opacity = `${+element.style.opacity + ((/* @__PURE__ */ new Date()).getTime() - last2) / duration}`;
      element.style.opacity = opacity;
      last2 = +/* @__PURE__ */ new Date();
      if (+opacity < 1) {
        !!window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);
      }
    };
    tick();
  }
}
function fadeOut(element, duration) {
  if (element) {
    let opacity = 1, interval = 50, gap = interval / duration;
    let fading = setInterval(() => {
      opacity -= gap;
      if (opacity <= 0) {
        opacity = 0;
        clearInterval(fading);
      }
      element.style.opacity = opacity.toString();
    }, interval);
  }
}
function find(element, selector) {
  return isElement(element) ? Array.from(element.querySelectorAll(selector)) : [];
}
function findSingle(element, selector) {
  return isElement(element) ? element.matches(selector) ? element : element.querySelector(selector) : null;
}
function focus(element, options3) {
  element && document.activeElement !== element && element.focus(options3);
}
function getAttribute(element, name) {
  if (isElement(element)) {
    const value3 = element.getAttribute(name);
    if (!isNaN(value3)) {
      return +value3;
    }
    if (value3 === "true" || value3 === "false") {
      return value3 === "true";
    }
    return value3;
  }
  return void 0;
}
function resolveUserAgent() {
  let ua = navigator.userAgent.toLowerCase();
  let match = /(chrome)[ ]([\w.]+)/.exec(ua) || /(webkit)[ ]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
  return {
    browser: match[1] || "",
    version: match[2] || "0"
  };
}
var browser = null;
function getBrowser() {
  if (!browser) {
    browser = {};
    let matched = resolveUserAgent();
    if (matched.browser) {
      browser[matched.browser] = true;
      browser["version"] = matched.version;
    }
    if (browser["chrome"]) {
      browser["webkit"] = true;
    } else if (browser["webkit"]) {
      browser["safari"] = true;
    }
  }
  return browser;
}
function getCursorOffset(element, prevText, nextText, currentText) {
  if (element) {
    let style = getComputedStyle(element);
    let ghostDiv = document.createElement("div");
    ghostDiv.style.position = "absolute";
    ghostDiv.style.top = "0px";
    ghostDiv.style.left = "0px";
    ghostDiv.style.visibility = "hidden";
    ghostDiv.style.pointerEvents = "none";
    ghostDiv.style.overflow = style.overflow;
    ghostDiv.style.width = style.width;
    ghostDiv.style.height = style.height;
    ghostDiv.style.padding = style.padding;
    ghostDiv.style.border = style.border;
    ghostDiv.style.overflowWrap = style.overflowWrap;
    ghostDiv.style.whiteSpace = style.whiteSpace;
    ghostDiv.style.lineHeight = style.lineHeight;
    ghostDiv.innerHTML = prevText.replace(/\r\n|\r|\n/g, "<br />");
    let ghostSpan = document.createElement("span");
    ghostSpan.textContent = currentText;
    ghostDiv.appendChild(ghostSpan);
    let text2 = document.createTextNode(nextText);
    ghostDiv.appendChild(text2);
    document.body.appendChild(ghostDiv);
    const { offsetLeft, offsetTop, clientHeight } = ghostSpan;
    document.body.removeChild(ghostDiv);
    return {
      left: Math.abs(offsetLeft - element.scrollLeft),
      top: Math.abs(offsetTop - element.scrollTop) + clientHeight
    };
  }
  return {
    top: "auto",
    left: "auto"
  };
}
function getFocusableElements(element, selector = "") {
  let focusableElements = find(
    element,
    `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector}`
  );
  let visibleFocusableElements = [];
  for (let focusableElement of focusableElements) {
    if (getComputedStyle(focusableElement).display != "none" && getComputedStyle(focusableElement).visibility != "hidden") visibleFocusableElements.push(focusableElement);
  }
  return visibleFocusableElements;
}
function getFirstFocusableElement(element, selector) {
  const focusableElements = getFocusableElements(element, selector);
  return focusableElements.length > 0 ? focusableElements[0] : null;
}
function getHeight(element) {
  if (element) {
    let height = element.offsetHeight;
    let style = getComputedStyle(element);
    height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    return height;
  }
  return 0;
}
function getHiddenElementOuterHeight(element) {
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    let elementHeight = element.offsetHeight;
    element.style.display = "none";
    element.style.visibility = "visible";
    return elementHeight;
  }
  return 0;
}
function getHiddenElementOuterWidth(element) {
  if (element) {
    element.style.visibility = "hidden";
    element.style.display = "block";
    let elementWidth = element.offsetWidth;
    element.style.display = "none";
    element.style.visibility = "visible";
    return elementWidth;
  }
  return 0;
}
function getParentNode(element) {
  if (element) {
    let parent = element.parentNode;
    if (parent && parent instanceof ShadowRoot && parent.host) {
      parent = parent.host;
    }
    return parent;
  }
  return null;
}
function getIndex(element) {
  var _a2;
  if (element) {
    let children = (_a2 = getParentNode(element)) == null ? void 0 : _a2.childNodes;
    let num = 0;
    if (children) {
      for (let i2 = 0; i2 < children.length; i2++) {
        if (children[i2] === element) return num;
        if (children[i2].nodeType === 1) num++;
      }
    }
  }
  return -1;
}
function getInnerWidth(element) {
  if (element) {
    let width2 = element.offsetWidth;
    let style = getComputedStyle(element);
    width2 -= parseFloat(style.borderLeft) + parseFloat(style.borderRight);
    return width2;
  }
  return 0;
}
function getLastFocusableElement(element, selector) {
  const focusableElements = getFocusableElements(element, selector);
  return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
}
function getNextElementSibling(element, selector) {
  let nextElement = element.nextElementSibling;
  while (nextElement) {
    if (nextElement.matches(selector)) {
      return nextElement;
    } else {
      nextElement = nextElement.nextElementSibling;
    }
  }
  return null;
}
function getNextFocusableElement(container, element, selector) {
  const focusableElements = getFocusableElements(container, selector);
  const index2 = focusableElements.length > 0 ? focusableElements.findIndex((el) => el === element) : -1;
  const nextIndex = index2 > -1 && focusableElements.length >= index2 + 1 ? index2 + 1 : -1;
  return nextIndex > -1 ? focusableElements[nextIndex] : null;
}
function getOffset(element) {
  if (element) {
    let rect = element.getBoundingClientRect();
    return {
      top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
      left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)
    };
  }
  return {
    top: "auto",
    left: "auto"
  };
}
function getOuterHeight(element, margin) {
  if (element) {
    let height = element.offsetHeight;
    if (margin) {
      let style = getComputedStyle(element);
      height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
    }
    return height;
  }
  return 0;
}
function getParents(element, parents = []) {
  const parent = getParentNode(element);
  return parent === null ? parents : getParents(parent, parents.concat([parent]));
}
function getPreviousElementSibling(element, selector) {
  let previousElement = element.previousElementSibling;
  while (previousElement) {
    if (previousElement.matches(selector)) {
      return previousElement;
    } else {
      previousElement = previousElement.previousElementSibling;
    }
  }
  return null;
}
function getScrollableParents(element) {
  let scrollableParents = [];
  if (element) {
    let parents = getParents(element);
    const overflowRegex = /(auto|scroll)/;
    const overflowCheck = (node3) => {
      try {
        let styleDeclaration = window["getComputedStyle"](node3, null);
        return overflowRegex.test(styleDeclaration.getPropertyValue("overflow")) || overflowRegex.test(styleDeclaration.getPropertyValue("overflowX")) || overflowRegex.test(styleDeclaration.getPropertyValue("overflowY"));
      } catch (err) {
        return false;
      }
    };
    for (let parent of parents) {
      let scrollSelectors = parent.nodeType === 1 && parent.dataset["scrollselectors"];
      if (scrollSelectors) {
        let selectors = scrollSelectors.split(",");
        for (let selector of selectors) {
          let el = findSingle(parent, selector);
          if (el && overflowCheck(el)) {
            scrollableParents.push(el);
          }
        }
      }
      if (parent.nodeType !== 9 && overflowCheck(parent)) {
        scrollableParents.push(parent);
      }
    }
  }
  return scrollableParents;
}
function getSelection() {
  if (window.getSelection) return window.getSelection().toString();
  else if (document.getSelection) return document.getSelection().toString();
  return void 0;
}
function isExist(element) {
  return !!(element !== null && typeof element !== "undefined" && element.nodeName && getParentNode(element));
}
function getTargetElement(target, currentElement) {
  var _a2;
  if (!target) return void 0;
  switch (target) {
    case "document":
      return document;
    case "window":
      return window;
    case "@next":
      return currentElement == null ? void 0 : currentElement.nextElementSibling;
    case "@prev":
      return currentElement == null ? void 0 : currentElement.previousElementSibling;
    case "@parent":
      return currentElement == null ? void 0 : currentElement.parentElement;
    case "@grandparent":
      return (_a2 = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a2.parentElement;
    default:
      if (typeof target === "string") {
        return document.querySelector(target);
      }
      const isFunction3 = (obj) => !!(obj && obj.constructor && obj.call && obj.apply);
      const element = toElement(isFunction3(target) ? target() : target);
      return (element == null ? void 0 : element.nodeType) === 9 || isExist(element) ? element : void 0;
  }
}
function getUserAgent() {
  return navigator.userAgent;
}
function getWidth(element) {
  if (element) {
    let width2 = element.offsetWidth;
    let style = getComputedStyle(element);
    width2 -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    return width2;
  }
  return 0;
}
function hasCSSAnimation(element) {
  if (element) {
    const style = getComputedStyle(element);
    const animationDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
    return animationDuration > 0;
  }
  return false;
}
function hasCSSTransition(element) {
  if (element) {
    const style = getComputedStyle(element);
    const transitionDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
    return transitionDuration > 0;
  }
  return false;
}
function invokeElementMethod(element, methodName, args) {
  element[methodName].apply(element, args);
}
function isAndroid$1() {
  return /(android)/i.test(navigator.userAgent);
}
function isAttributeEquals(element, name, value3) {
  return isElement(element) ? getAttribute(element, name) === value3 : false;
}
function isAttributeNotEquals(element, name, value3) {
  return !isAttributeEquals(element, name, value3);
}
function isClickable(element) {
  if (element) {
    const targetNode = element.nodeName;
    const parentNode = element.parentElement && element.parentElement.nodeName;
    return targetNode === "INPUT" || targetNode === "TEXTAREA" || targetNode === "BUTTON" || targetNode === "A" || parentNode === "INPUT" || parentNode === "TEXTAREA" || parentNode === "BUTTON" || parentNode === "A" || !!element.closest(".p-button, .p-checkbox, .p-radiobutton");
  }
  return false;
}
function isClient() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function isFocusableElement(element, selector = "") {
  return isElement(element) ? element.matches(`button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector}`) : false;
}
function isVisible(element) {
  return !!(element && element.offsetParent != null);
}
function isHidden(element) {
  return !isVisible(element);
}
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window["MSStream"];
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
function nestedPosition(element, level) {
  var _a2;
  if (element) {
    const parentItem = element.parentElement;
    const elementOffset = getOffset(parentItem);
    const viewport = getViewport();
    const sublistWidth = element.offsetParent ? element.offsetWidth : getHiddenElementOuterWidth(element);
    const itemOuterWidth = getOuterWidth((_a2 = parentItem == null ? void 0 : parentItem.children) == null ? void 0 : _a2[0]);
    let left = "";
    if (elementOffset.left + itemOuterWidth + sublistWidth > viewport.width - calculateScrollbarWidth()) {
      if (elementOffset.left < sublistWidth) {
        if (level % 2 === 1) {
          left = elementOffset.left ? "-" + elementOffset.left + "px" : "100%";
        } else if (level % 2 === 0) {
          left = viewport.width - sublistWidth - calculateScrollbarWidth() + "px";
        }
      } else {
        left = "-100%";
      }
    } else {
      left = "100%";
    }
    element.style.top = "0px";
    element.style.left = left;
  }
}
function remove(element) {
  var _a2;
  if (element) {
    if (!("remove" in Element.prototype)) (_a2 = element.parentNode) == null ? void 0 : _a2.removeChild(element);
    else element.remove();
  }
}
function removeChild(element, child) {
  const target = toElement(element);
  if (target) target.removeChild(child);
  else throw new Error("Cannot remove " + child + " from " + element);
}
function removeStyleTag(element) {
  var _a2;
  if (isExist(element)) {
    try {
      (_a2 = element.parentNode) == null ? void 0 : _a2.removeChild(element);
    } catch (error) {
    }
    return null;
  }
  return element;
}
function scrollInView(container, item) {
  let borderTopValue = getComputedStyle(container).getPropertyValue("borderTopWidth");
  let borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
  let paddingTopValue = getComputedStyle(container).getPropertyValue("paddingTop");
  let paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
  let containerRect = container.getBoundingClientRect();
  let itemRect = item.getBoundingClientRect();
  let offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
  let scroll = container.scrollTop;
  let elementHeight = container.clientHeight;
  let itemHeight = getOuterHeight(item);
  if (offset < 0) {
    container.scrollTop = scroll + offset;
  } else if (offset + itemHeight > elementHeight) {
    container.scrollTop = scroll + offset - elementHeight + itemHeight;
  }
}
function setAttribute(element, attribute = "", value3) {
  if (isElement(element) && value3 !== null && value3 !== void 0) {
    element.setAttribute(attribute, value3);
  }
}
function _typeof$v(o) {
  "@babel/helpers - typeof";
  return _typeof$v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$v(o);
}
function ownKeys$r(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$r(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$r(Object(t), true).forEach(function(r2) {
      _defineProperty$u(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$r(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$u(e, r, t) {
  return (r = _toPropertyKey$t(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$t(t) {
  var i2 = _toPrimitive$t(t, "string");
  return "symbol" == _typeof$v(i2) ? i2 : i2 + "";
}
function _toPrimitive$t(t, r) {
  if ("object" != _typeof$v(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$v(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function tryOnMounted(fn) {
  var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (getCurrentInstance()) onMounted(fn);
  else if (sync) fn();
  else nextTick(fn);
}
var _id = 0;
function useStyle(css4) {
  var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var isLoaded = ref(false);
  var cssRef = ref(css4);
  var styleRef = ref(null);
  var defaultDocument = isClient() ? window.document : void 0;
  var _options$document = options3.document, document2 = _options$document === void 0 ? defaultDocument : _options$document, _options$immediate = options3.immediate, immediate = _options$immediate === void 0 ? true : _options$immediate, _options$manual = options3.manual, manual = _options$manual === void 0 ? false : _options$manual, _options$name = options3.name, name = _options$name === void 0 ? "style_".concat(++_id) : _options$name, _options$id = options3.id, id2 = _options$id === void 0 ? void 0 : _options$id, _options$media = options3.media, media = _options$media === void 0 ? void 0 : _options$media, _options$nonce = options3.nonce, nonce = _options$nonce === void 0 ? void 0 : _options$nonce, _options$first = options3.first, first4 = _options$first === void 0 ? false : _options$first, _options$onMounted = options3.onMounted, onStyleMounted2 = _options$onMounted === void 0 ? void 0 : _options$onMounted, _options$onUpdated = options3.onUpdated, onStyleUpdated2 = _options$onUpdated === void 0 ? void 0 : _options$onUpdated, _options$onLoad = options3.onLoad, onStyleLoaded2 = _options$onLoad === void 0 ? void 0 : _options$onLoad, _options$props = options3.props, props = _options$props === void 0 ? {} : _options$props;
  var stop2 = function stop3() {
  };
  var load2 = function load3(_css) {
    var _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!document2) return;
    var _styleProps = _objectSpread$r(_objectSpread$r({}, props), _props);
    var _name2 = _styleProps.name || name, _id2 = _styleProps.id || id2, _nonce = _styleProps.nonce || nonce;
    styleRef.value = document2.querySelector('style[data-primevue-style-id="'.concat(_name2, '"]')) || document2.getElementById(_id2) || document2.createElement("style");
    if (!styleRef.value.isConnected) {
      cssRef.value = _css || css4;
      setAttributes(styleRef.value, {
        type: "text/css",
        id: _id2,
        media,
        nonce: _nonce
      });
      first4 ? document2.head.prepend(styleRef.value) : document2.head.appendChild(styleRef.value);
      setAttribute(styleRef.value, "data-primevue-style-id", _name2);
      setAttributes(styleRef.value, _styleProps);
      styleRef.value.onload = function(event2) {
        return onStyleLoaded2 === null || onStyleLoaded2 === void 0 ? void 0 : onStyleLoaded2(event2, {
          name: _name2
        });
      };
      onStyleMounted2 === null || onStyleMounted2 === void 0 || onStyleMounted2(_name2);
    }
    if (isLoaded.value) return;
    stop2 = watch(cssRef, function(value3) {
      styleRef.value.textContent = value3;
      onStyleUpdated2 === null || onStyleUpdated2 === void 0 || onStyleUpdated2(_name2);
    }, {
      immediate: true
    });
    isLoaded.value = true;
  };
  var unload = function unload2() {
    if (!document2 || !isLoaded.value) return;
    stop2();
    isExist(styleRef.value) && document2.head.removeChild(styleRef.value);
    isLoaded.value = false;
  };
  if (immediate && !manual) tryOnMounted(load2);
  return {
    id: id2,
    name,
    el: styleRef,
    css: cssRef,
    unload,
    load: load2,
    isLoaded: readonly(isLoaded)
  };
}
function _typeof$u(o) {
  "@babel/helpers - typeof";
  return _typeof$u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$u(o);
}
function _slicedToArray$7(r, e) {
  return _arrayWithHoles$7(r) || _iterableToArrayLimit$7(r, e) || _unsupportedIterableToArray$m(r, e) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$m(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$m(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$m(r, a) : void 0;
  }
}
function _arrayLikeToArray$m(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit$7(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles$7(r) {
  if (Array.isArray(r)) return r;
}
function ownKeys$q(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$q(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$q(Object(t), true).forEach(function(r2) {
      _defineProperty$t(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$t(e, r, t) {
  return (r = _toPropertyKey$s(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$s(t) {
  var i2 = _toPrimitive$s(t, "string");
  return "symbol" == _typeof$u(i2) ? i2 : i2 + "";
}
function _toPrimitive$s(t, r) {
  if ("object" != _typeof$u(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$u(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var theme$x = function theme2(_ref) {
  var dt3 = _ref.dt;
  return "\n* {\n    box-sizing: border-box;\n}\n\n/* Non vue overlay animations */\n.p-connected-overlay {\n    opacity: 0;\n    transform: scaleY(0.8);\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n        opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-connected-overlay-visible {\n    opacity: 1;\n    transform: scaleY(1);\n}\n\n.p-connected-overlay-hidden {\n    opacity: 0;\n    transform: scaleY(1);\n    transition: opacity 0.1s linear;\n}\n\n/* Vue based overlay animations */\n.p-connected-overlay-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-connected-overlay-leave-to {\n    opacity: 0;\n}\n\n.p-connected-overlay-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n        opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-connected-overlay-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n/* Toggleable Content */\n.p-toggleable-content-enter-from,\n.p-toggleable-content-leave-to {\n    max-height: 0;\n}\n\n.p-toggleable-content-enter-to,\n.p-toggleable-content-leave-from {\n    max-height: 1000px;\n}\n\n.p-toggleable-content-leave-active {\n    overflow: hidden;\n    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1);\n}\n\n.p-toggleable-content-enter-active {\n    overflow: hidden;\n    transition: max-height 1s ease-in-out;\n}\n\n.p-disabled,\n.p-disabled * {\n    cursor: default;\n    pointer-events: none;\n    user-select: none;\n}\n\n.p-disabled,\n.p-component:disabled {\n    opacity: ".concat(dt3("disabled.opacity"), ";\n}\n\n.pi {\n    font-size: ").concat(dt3("icon.size"), ";\n}\n\n.p-icon {\n    width: ").concat(dt3("icon.size"), ";\n    height: ").concat(dt3("icon.size"), ";\n}\n\n.p-overlay-mask {\n    background: ").concat(dt3("mask.background"), ";\n    color: ").concat(dt3("mask.color"), ";\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.p-overlay-mask-enter {\n    animation: p-overlay-mask-enter-animation ").concat(dt3("mask.transition.duration"), " forwards;\n}\n\n.p-overlay-mask-leave {\n    animation: p-overlay-mask-leave-animation ").concat(dt3("mask.transition.duration"), " forwards;\n}\n\n@keyframes p-overlay-mask-enter-animation {\n    from {\n        background: transparent;\n    }\n    to {\n        background: ").concat(dt3("mask.background"), ";\n    }\n}\n@keyframes p-overlay-mask-leave-animation {\n    from {\n        background: ").concat(dt3("mask.background"), ";\n    }\n    to {\n        background: transparent;\n    }\n}\n");
};
var css$2 = function css2(_ref2) {
  var dt3 = _ref2.dt;
  return "\n.p-hidden-accessible {\n    border: 0;\n    clip: rect(0 0 0 0);\n    height: 1px;\n    margin: -1px;\n    overflow: hidden;\n    padding: 0;\n    position: absolute;\n    width: 1px;\n}\n\n.p-hidden-accessible input,\n.p-hidden-accessible select {\n    transform: scale(0);\n}\n\n.p-overflow-hidden {\n    overflow: hidden;\n    padding-right: ".concat(dt3("scrollbar.width"), ";\n}\n");
};
var classes$A = {};
var inlineStyles$8 = {};
var BaseStyle = {
  name: "base",
  css: css$2,
  theme: theme$x,
  classes: classes$A,
  inlineStyles: inlineStyles$8,
  load: function load(style) {
    var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var transform2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(cs) {
      return cs;
    };
    var computedStyle = transform2(resolve(style, {
      dt: dt$1
    }));
    return computedStyle ? useStyle(minifyCSS(computedStyle), _objectSpread$q({
      name: this.name
    }, options3)) : {};
  },
  loadCSS: function loadCSS() {
    var options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.css, options3);
  },
  loadTheme: function loadTheme() {
    var _this = this;
    var options3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.theme, options3, function(computedStyle) {
      return config_default.transformCSS(options3.name || _this.name, computedStyle);
    });
  },
  getCommonTheme: function getCommonTheme(params) {
    return config_default.getCommon(this.name, params);
  },
  getComponentTheme: function getComponentTheme(params) {
    return config_default.getComponent(this.name, params);
  },
  getDirectiveTheme: function getDirectiveTheme(params) {
    return config_default.getDirective(this.name, params);
  },
  getPresetTheme: function getPresetTheme(preset, selector, params) {
    return config_default.getCustomPreset(this.name, preset, selector, params);
  },
  getLayerOrderThemeCSS: function getLayerOrderThemeCSS() {
    return config_default.getLayerOrderCSS(this.name);
  },
  getStyleSheet: function getStyleSheet() {
    var extendedCSS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.css) {
      var _css = resolve(this.css, {
        dt: dt$1
      });
      var _style = minifyCSS("".concat(_css).concat(extendedCSS));
      var _props = Object.entries(props).reduce(function(acc, _ref3) {
        var _ref4 = _slicedToArray$7(_ref3, 2), k = _ref4[0], v2 = _ref4[1];
        return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      return '<style type="text/css" data-primevue-style-id="'.concat(this.name, '" ').concat(_props, ">").concat(_style, "</style>");
    }
    return "";
  },
  getCommonThemeStyleSheet: function getCommonThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return config_default.getCommonStyleSheet(this.name, params, props);
  },
  getThemeStyleSheet: function getThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var css4 = [config_default.getStyleSheet(this.name, params, props)];
    if (this.theme) {
      var name = this.name === "base" ? "global-style" : "".concat(this.name, "-style");
      var _css = resolve(this.theme, {
        dt: dt$1
      });
      var _style = minifyCSS(config_default.transformCSS(name, _css));
      var _props = Object.entries(props).reduce(function(acc, _ref5) {
        var _ref6 = _slicedToArray$7(_ref5, 2), k = _ref6[0], v2 = _ref6[1];
        return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      css4.push('<style type="text/css" data-primevue-style-id="'.concat(name, '" ').concat(_props, ">").concat(_style, "</style>"));
    }
    return css4.join("");
  },
  extend: function extend2(style) {
    return _objectSpread$q(_objectSpread$q({}, this), {}, {
      css: void 0,
      theme: void 0
    }, style);
  }
};
var PrimeVueService = EventBus();
function _typeof$t(o) {
  "@babel/helpers - typeof";
  return _typeof$t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$t(o);
}
function ownKeys$p(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$p(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$p(Object(t), true).forEach(function(r2) {
      _defineProperty$s(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$s(e, r, t) {
  return (r = _toPropertyKey$r(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$r(t) {
  var i2 = _toPrimitive$r(t, "string");
  return "symbol" == _typeof$t(i2) ? i2 : i2 + "";
}
function _toPrimitive$r(t, r) {
  if ("object" != _typeof$t(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$t(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var defaultOptions$1 = {
  ripple: false,
  inputStyle: null,
  inputVariant: null,
  locale: {
    startsWith: "Starts with",
    contains: "Contains",
    notContains: "Not contains",
    endsWith: "Ends with",
    equals: "Equals",
    notEquals: "Not equals",
    noFilter: "No Filter",
    lt: "Less than",
    lte: "Less than or equal to",
    gt: "Greater than",
    gte: "Greater than or equal to",
    dateIs: "Date is",
    dateIsNot: "Date is not",
    dateBefore: "Date is before",
    dateAfter: "Date is after",
    clear: "Clear",
    apply: "Apply",
    matchAll: "Match All",
    matchAny: "Match Any",
    addRule: "Add Rule",
    removeRule: "Remove Rule",
    accept: "Yes",
    reject: "No",
    choose: "Choose",
    upload: "Upload",
    cancel: "Cancel",
    completed: "Completed",
    pending: "Pending",
    fileSizeTypes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    chooseYear: "Choose Year",
    chooseMonth: "Choose Month",
    chooseDate: "Choose Date",
    prevDecade: "Previous Decade",
    nextDecade: "Next Decade",
    prevYear: "Previous Year",
    nextYear: "Next Year",
    prevMonth: "Previous Month",
    nextMonth: "Next Month",
    prevHour: "Previous Hour",
    nextHour: "Next Hour",
    prevMinute: "Previous Minute",
    nextMinute: "Next Minute",
    prevSecond: "Previous Second",
    nextSecond: "Next Second",
    am: "am",
    pm: "pm",
    today: "Today",
    weekHeader: "Wk",
    firstDayOfWeek: 0,
    showMonthAfterYear: false,
    dateFormat: "mm/dd/yy",
    weak: "Weak",
    medium: "Medium",
    strong: "Strong",
    passwordPrompt: "Enter a password",
    emptyFilterMessage: "No results found",
    searchMessage: "{0} results are available",
    selectionMessage: "{0} items selected",
    emptySelectionMessage: "No selected item",
    emptySearchMessage: "No results found",
    fileChosenMessage: "{0} files",
    noFileChosenMessage: "No file chosen",
    emptyMessage: "No available options",
    aria: {
      trueLabel: "True",
      falseLabel: "False",
      nullLabel: "Not Selected",
      star: "1 star",
      stars: "{star} stars",
      selectAll: "All items selected",
      unselectAll: "All items unselected",
      close: "Close",
      previous: "Previous",
      next: "Next",
      navigation: "Navigation",
      scrollTop: "Scroll Top",
      moveTop: "Move Top",
      moveUp: "Move Up",
      moveDown: "Move Down",
      moveBottom: "Move Bottom",
      moveToTarget: "Move to Target",
      moveToSource: "Move to Source",
      moveAllToTarget: "Move All to Target",
      moveAllToSource: "Move All to Source",
      pageLabel: "Page {page}",
      firstPageLabel: "First Page",
      lastPageLabel: "Last Page",
      nextPageLabel: "Next Page",
      prevPageLabel: "Previous Page",
      rowsPerPageLabel: "Rows per page",
      jumpToPageDropdownLabel: "Jump to Page Dropdown",
      jumpToPageInputLabel: "Jump to Page Input",
      selectRow: "Row Selected",
      unselectRow: "Row Unselected",
      expandRow: "Row Expanded",
      collapseRow: "Row Collapsed",
      showFilterMenu: "Show Filter Menu",
      hideFilterMenu: "Hide Filter Menu",
      filterOperator: "Filter Operator",
      filterConstraint: "Filter Constraint",
      editRow: "Row Edit",
      saveEdit: "Save Edit",
      cancelEdit: "Cancel Edit",
      listView: "List View",
      gridView: "Grid View",
      slide: "Slide",
      slideNumber: "{slideNumber}",
      zoomImage: "Zoom Image",
      zoomIn: "Zoom In",
      zoomOut: "Zoom Out",
      rotateRight: "Rotate Right",
      rotateLeft: "Rotate Left",
      listLabel: "Option List"
    }
  },
  filterMatchModeOptions: {
    text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
    numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
    date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
  },
  zIndex: {
    modal: 1100,
    overlay: 1e3,
    menu: 1e3,
    tooltip: 1100
  },
  theme: void 0,
  unstyled: false,
  pt: void 0,
  ptOptions: {
    mergeSections: true,
    mergeProps: false
  },
  csp: {
    nonce: void 0
  }
};
var PrimeVueSymbol = Symbol();
function usePrimeVue() {
  var PrimeVue2 = inject(PrimeVueSymbol);
  if (!PrimeVue2) {
    throw new Error("PrimeVue is not installed!");
  }
  return PrimeVue2;
}
function setup(app2, options3) {
  var PrimeVue2 = {
    config: reactive(options3)
  };
  app2.config.globalProperties.$primevue = PrimeVue2;
  app2.provide(PrimeVueSymbol, PrimeVue2);
  clearConfig();
  setupConfig(app2, PrimeVue2);
  return PrimeVue2;
}
var stopWatchers = [];
function clearConfig() {
  service_default.clear();
  stopWatchers.forEach(function(fn) {
    return fn === null || fn === void 0 ? void 0 : fn();
  });
  stopWatchers = [];
}
function setupConfig(app2, PrimeVue2) {
  var isThemeChanged = ref(false);
  var loadCommonTheme = function loadCommonTheme2() {
    if (!config_default.isStyleNameLoaded("common")) {
      var _BaseStyle$getCommonT, _PrimeVue$config;
      var _ref = ((_BaseStyle$getCommonT = BaseStyle.getCommonTheme) === null || _BaseStyle$getCommonT === void 0 ? void 0 : _BaseStyle$getCommonT.call(BaseStyle)) || {}, primitive = _ref.primitive, semantic = _ref.semantic;
      var styleOptions = {
        nonce: (_PrimeVue$config = PrimeVue2.config) === null || _PrimeVue$config === void 0 || (_PrimeVue$config = _PrimeVue$config.csp) === null || _PrimeVue$config === void 0 ? void 0 : _PrimeVue$config.nonce
      };
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$p({
        name: "primitive-variables"
      }, styleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$p({
        name: "semantic-variables"
      }, styleOptions));
      BaseStyle.loadTheme(_objectSpread$p({
        name: "global-style"
      }, styleOptions));
      config_default.setLoadedStyleName("common");
    }
  };
  service_default.on("theme:change", function(newTheme) {
    if (!isThemeChanged.value) {
      app2.config.globalProperties.$primevue.config.theme = newTheme;
      isThemeChanged.value = true;
    }
  });
  var stopConfigWatcher = watch(PrimeVue2.config, function(newValue, oldValue) {
    PrimeVueService.emit("config:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopRippleWatcher = watch(function() {
    return PrimeVue2.config.ripple;
  }, function(newValue, oldValue) {
    PrimeVueService.emit("config:ripple:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopThemeWatcher = watch(function() {
    return PrimeVue2.config.theme;
  }, function(newValue, oldValue) {
    if (!isThemeChanged.value) {
      config_default.setTheme(newValue);
    }
    if (!PrimeVue2.config.unstyled) {
      loadCommonTheme();
    }
    isThemeChanged.value = false;
    PrimeVueService.emit("config:theme:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopUnstyledWatcher = watch(function() {
    return PrimeVue2.config.unstyled;
  }, function(newValue, oldValue) {
    if (!newValue && PrimeVue2.config.theme) {
      loadCommonTheme();
    }
    PrimeVueService.emit("config:unstyled:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  stopWatchers.push(stopConfigWatcher);
  stopWatchers.push(stopRippleWatcher);
  stopWatchers.push(stopThemeWatcher);
  stopWatchers.push(stopUnstyledWatcher);
}
var PrimeVue = {
  install: function install2(app2, options3) {
    var configOptions = _objectSpread$p(_objectSpread$p({}, defaultOptions$1), options3);
    setup(app2, configOptions);
  }
};
var index$1l = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  panel: {
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}"
  },
  header: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{text.color}",
    padding: "1.125rem",
    fontWeight: "600",
    borderRadius: "0",
    borderWidth: "0",
    borderColor: "{content.border.color}",
    background: "{content.background}",
    hoverBackground: "{content.background}",
    activeBackground: "{content.background}",
    activeHoverBackground: "{content.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    toggleIcon: {
      color: "{text.muted.color}",
      hoverColor: "{text.color}",
      activeColor: "{text.color}",
      activeHoverColor: "{text.color}"
    },
    first: {
      topBorderRadius: "{content.border.radius}",
      borderWidth: "0"
    },
    last: {
      bottomBorderRadius: "{content.border.radius}",
      activeBottomBorderRadius: "0"
    }
  },
  content: {
    borderWidth: "0",
    borderColor: "{content.border.color}",
    background: "{content.background}",
    color: "{text.color}",
    padding: "0 1.125rem 1.125rem 1.125rem"
  }
};
var index$1k = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}"
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  dropdown: {
    width: "2.5rem",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.border.color}",
    activeBorderColor: "{form.field.border.color}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  colorScheme: {
    light: {
      dropdown: {
        background: "{surface.100}",
        hoverBackground: "{surface.200}",
        activeBackground: "{surface.300}",
        color: "{surface.600}",
        hoverColor: "{surface.700}",
        activeColor: "{surface.800}"
      }
    },
    dark: {
      dropdown: {
        background: "{surface.800}",
        hoverBackground: "{surface.700}",
        activeBackground: "{surface.600}",
        color: "{surface.300}",
        hoverColor: "{surface.200}",
        activeColor: "{surface.100}"
      }
    }
  }
};
var index$1j = {
  root: {
    width: "2rem",
    height: "2rem",
    fontSize: "1rem",
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}"
  },
  group: {
    borderColor: "{content.background}",
    offset: "-1rem"
  },
  lg: {
    width: "3rem",
    height: "3rem",
    fontSize: "1.5rem"
  },
  xl: {
    width: "4rem",
    height: "4rem",
    fontSize: "2rem"
  }
};
var index$1i = {
  root: {
    borderRadius: "{border.radius.md}",
    padding: "0 0.5rem",
    fontSize: "0.75rem",
    fontWeight: "700",
    minWidth: "1.5rem",
    height: "1.5rem"
  },
  dot: {
    size: "0.5rem"
  },
  sm: {
    fontSize: "0.625rem",
    minWidth: "1.25rem",
    height: "1.25rem"
  },
  lg: {
    fontSize: "0.875rem",
    minWidth: "1.75rem",
    height: "1.75rem"
  },
  xl: {
    fontSize: "1rem",
    minWidth: "2rem",
    height: "2rem"
  },
  colorScheme: {
    light: {
      primary: {
        background: "{primary.color}",
        color: "{primary.contrast.color}"
      },
      secondary: {
        background: "{surface.100}",
        color: "{surface.600}"
      },
      success: {
        background: "{green.500}",
        color: "{surface.0}"
      },
      info: {
        background: "{sky.500}",
        color: "{surface.0}"
      },
      warn: {
        background: "{orange.500}",
        color: "{surface.0}"
      },
      danger: {
        background: "{red.500}",
        color: "{surface.0}"
      },
      contrast: {
        background: "{surface.950}",
        color: "{surface.0}"
      }
    },
    dark: {
      primary: {
        background: "{primary.color}",
        color: "{primary.contrast.color}"
      },
      secondary: {
        background: "{surface.800}",
        color: "{surface.300}"
      },
      success: {
        background: "{green.400}",
        color: "{green.950}"
      },
      info: {
        background: "{sky.400}",
        color: "{sky.950}"
      },
      warn: {
        background: "{orange.400}",
        color: "{orange.950}"
      },
      danger: {
        background: "{red.400}",
        color: "{red.950}"
      },
      contrast: {
        background: "{surface.0}",
        color: "{surface.950}"
      }
    }
  }
};
var index$1h = {
  root: {
    borderRadius: "{content.border.radius}"
  }
};
var index$1g = {
  root: {
    padding: "1rem",
    background: "{content.background}",
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  item: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    iconColor: "{navigation.item.icon.color}",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  separator: {
    color: "{navigation.item.icon.color}"
  }
};
var index$1f = {
  root: {
    borderRadius: "{form.field.border.radius}",
    roundedBorderRadius: "2rem",
    gap: "0.5rem",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    iconOnlyWidth: "2.5rem",
    sm: {
      fontSize: "0.875rem",
      paddingX: "0.625rem",
      paddingY: "0.375rem"
    },
    lg: {
      fontSize: "1.125rem",
      paddingX: "0.875rem",
      paddingY: "0.625rem"
    },
    label: {
      fontWeight: "500"
    },
    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    },
    badgeSize: "1rem",
    transitionDuration: "{form.field.transition.duration}"
  },
  colorScheme: {
    light: {
      root: {
        primary: {
          background: "{primary.color}",
          hoverBackground: "{primary.hover.color}",
          activeBackground: "{primary.active.color}",
          borderColor: "{primary.color}",
          hoverBorderColor: "{primary.hover.color}",
          activeBorderColor: "{primary.active.color}",
          color: "{primary.contrast.color}",
          hoverColor: "{primary.contrast.color}",
          activeColor: "{primary.contrast.color}",
          focusRing: {
            color: "{primary.color}",
            shadow: "none"
          }
        },
        secondary: {
          background: "{surface.100}",
          hoverBackground: "{surface.200}",
          activeBackground: "{surface.300}",
          borderColor: "{surface.100}",
          hoverBorderColor: "{surface.200}",
          activeBorderColor: "{surface.300}",
          color: "{surface.600}",
          hoverColor: "{surface.700}",
          activeColor: "{surface.800}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        },
        info: {
          background: "{sky.500}",
          hoverBackground: "{sky.600}",
          activeBackground: "{sky.700}",
          borderColor: "{sky.500}",
          hoverBorderColor: "{sky.600}",
          activeBorderColor: "{sky.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{sky.500}",
            shadow: "none"
          }
        },
        success: {
          background: "{green.500}",
          hoverBackground: "{green.600}",
          activeBackground: "{green.700}",
          borderColor: "{green.500}",
          hoverBorderColor: "{green.600}",
          activeBorderColor: "{green.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        },
        warn: {
          background: "{orange.500}",
          hoverBackground: "{orange.600}",
          activeBackground: "{orange.700}",
          borderColor: "{orange.500}",
          hoverBorderColor: "{orange.600}",
          activeBorderColor: "{orange.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{orange.500}",
            shadow: "none"
          }
        },
        help: {
          background: "{purple.500}",
          hoverBackground: "{purple.600}",
          activeBackground: "{purple.700}",
          borderColor: "{purple.500}",
          hoverBorderColor: "{purple.600}",
          activeBorderColor: "{purple.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{purple.500}",
            shadow: "none"
          }
        },
        danger: {
          background: "{red.500}",
          hoverBackground: "{red.600}",
          activeBackground: "{red.700}",
          borderColor: "{red.500}",
          hoverBorderColor: "{red.600}",
          activeBorderColor: "{red.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        },
        contrast: {
          background: "{surface.950}",
          hoverBackground: "{surface.900}",
          activeBackground: "{surface.800}",
          borderColor: "{surface.950}",
          hoverBorderColor: "{surface.900}",
          activeBorderColor: "{surface.800}",
          color: "{surface.0}",
          hoverColor: "{surface.0}",
          activeColor: "{surface.0}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      },
      outlined: {
        primary: {
          hoverBackground: "{primary.50}",
          activeBackground: "{primary.100}",
          borderColor: "{primary.200}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{surface.500}"
        },
        success: {
          hoverBackground: "{green.50}",
          activeBackground: "{green.100}",
          borderColor: "{green.200}",
          color: "{green.500}"
        },
        info: {
          hoverBackground: "{sky.50}",
          activeBackground: "{sky.100}",
          borderColor: "{sky.200}",
          color: "{sky.500}"
        },
        warn: {
          hoverBackground: "{orange.50}",
          activeBackground: "{orange.100}",
          borderColor: "{orange.200}",
          color: "{orange.500}"
        },
        help: {
          hoverBackground: "{purple.50}",
          activeBackground: "{purple.100}",
          borderColor: "{purple.200}",
          color: "{purple.500}"
        },
        danger: {
          hoverBackground: "{red.50}",
          activeBackground: "{red.100}",
          borderColor: "{red.200}",
          color: "{red.500}"
        },
        contrast: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.700}",
          color: "{surface.950}"
        },
        plain: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{surface.700}"
        }
      },
      text: {
        primary: {
          hoverBackground: "{primary.50}",
          activeBackground: "{primary.100}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          color: "{surface.500}"
        },
        success: {
          hoverBackground: "{green.50}",
          activeBackground: "{green.100}",
          color: "{green.500}"
        },
        info: {
          hoverBackground: "{sky.50}",
          activeBackground: "{sky.100}",
          color: "{sky.500}"
        },
        warn: {
          hoverBackground: "{orange.50}",
          activeBackground: "{orange.100}",
          color: "{orange.500}"
        },
        help: {
          hoverBackground: "{purple.50}",
          activeBackground: "{purple.100}",
          color: "{purple.500}"
        },
        danger: {
          hoverBackground: "{red.50}",
          activeBackground: "{red.100}",
          color: "{red.500}"
        },
        plain: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          color: "{surface.700}"
        }
      },
      link: {
        color: "{primary.color}",
        hoverColor: "{primary.color}",
        activeColor: "{primary.color}"
      }
    },
    dark: {
      root: {
        primary: {
          background: "{primary.color}",
          hoverBackground: "{primary.hover.color}",
          activeBackground: "{primary.active.color}",
          borderColor: "{primary.color}",
          hoverBorderColor: "{primary.hover.color}",
          activeBorderColor: "{primary.active.color}",
          color: "{primary.contrast.color}",
          hoverColor: "{primary.contrast.color}",
          activeColor: "{primary.contrast.color}",
          focusRing: {
            color: "{primary.color}",
            shadow: "none"
          }
        },
        secondary: {
          background: "{surface.800}",
          hoverBackground: "{surface.700}",
          activeBackground: "{surface.600}",
          borderColor: "{surface.800}",
          hoverBorderColor: "{surface.700}",
          activeBorderColor: "{surface.600}",
          color: "{surface.300}",
          hoverColor: "{surface.200}",
          activeColor: "{surface.100}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        },
        info: {
          background: "{sky.400}",
          hoverBackground: "{sky.300}",
          activeBackground: "{sky.200}",
          borderColor: "{sky.400}",
          hoverBorderColor: "{sky.300}",
          activeBorderColor: "{sky.200}",
          color: "{sky.950}",
          hoverColor: "{sky.950}",
          activeColor: "{sky.950}",
          focusRing: {
            color: "{sky.400}",
            shadow: "none"
          }
        },
        success: {
          background: "{green.400}",
          hoverBackground: "{green.300}",
          activeBackground: "{green.200}",
          borderColor: "{green.400}",
          hoverBorderColor: "{green.300}",
          activeBorderColor: "{green.200}",
          color: "{green.950}",
          hoverColor: "{green.950}",
          activeColor: "{green.950}",
          focusRing: {
            color: "{green.400}",
            shadow: "none"
          }
        },
        warn: {
          background: "{orange.400}",
          hoverBackground: "{orange.300}",
          activeBackground: "{orange.200}",
          borderColor: "{orange.400}",
          hoverBorderColor: "{orange.300}",
          activeBorderColor: "{orange.200}",
          color: "{orange.950}",
          hoverColor: "{orange.950}",
          activeColor: "{orange.950}",
          focusRing: {
            color: "{orange.400}",
            shadow: "none"
          }
        },
        help: {
          background: "{purple.400}",
          hoverBackground: "{purple.300}",
          activeBackground: "{purple.200}",
          borderColor: "{purple.400}",
          hoverBorderColor: "{purple.300}",
          activeBorderColor: "{purple.200}",
          color: "{purple.950}",
          hoverColor: "{purple.950}",
          activeColor: "{purple.950}",
          focusRing: {
            color: "{purple.400}",
            shadow: "none"
          }
        },
        danger: {
          background: "{red.400}",
          hoverBackground: "{red.300}",
          activeBackground: "{red.200}",
          borderColor: "{red.400}",
          hoverBorderColor: "{red.300}",
          activeBorderColor: "{red.200}",
          color: "{red.950}",
          hoverColor: "{red.950}",
          activeColor: "{red.950}",
          focusRing: {
            color: "{red.400}",
            shadow: "none"
          }
        },
        contrast: {
          background: "{surface.0}",
          hoverBackground: "{surface.100}",
          activeBackground: "{surface.200}",
          borderColor: "{surface.0}",
          hoverBorderColor: "{surface.100}",
          activeBorderColor: "{surface.200}",
          color: "{surface.950}",
          hoverColor: "{surface.950}",
          activeColor: "{surface.950}",
          focusRing: {
            color: "{surface.0}",
            shadow: "none"
          }
        }
      },
      outlined: {
        primary: {
          hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
          borderColor: "{primary.700}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "rgba(255,255,255,0.04)",
          activeBackground: "rgba(255,255,255,0.16)",
          borderColor: "{surface.700}",
          color: "{surface.400}"
        },
        success: {
          hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
          borderColor: "{green.700}",
          color: "{green.400}"
        },
        info: {
          hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
          borderColor: "{sky.700}",
          color: "{sky.400}"
        },
        warn: {
          hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
          borderColor: "{orange.700}",
          color: "{orange.400}"
        },
        help: {
          hoverBackground: "color-mix(in srgb, {help.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {help.400}, transparent 84%)",
          borderColor: "{purple.700}",
          color: "{purple.400}"
        },
        danger: {
          hoverBackground: "color-mix(in srgb, {danger.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {danger.400}, transparent 84%)",
          borderColor: "{red.700}",
          color: "{red.400}"
        },
        contrast: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          borderColor: "{surface.500}",
          color: "{surface.0}"
        },
        plain: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          borderColor: "{surface.600}",
          color: "{surface.0}"
        }
      },
      text: {
        primary: {
          hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          color: "{surface.400}"
        },
        success: {
          hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
          color: "{green.400}"
        },
        info: {
          hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
          color: "{sky.400}"
        },
        warn: {
          hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
          color: "{orange.400}"
        },
        help: {
          hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)",
          color: "{purple.400}"
        },
        danger: {
          hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)",
          color: "{red.400}"
        },
        plain: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          color: "{surface.0}"
        }
      },
      link: {
        color: "{primary.color}",
        hoverColor: "{primary.color}",
        activeColor: "{primary.color}"
      }
    }
  }
};
var index$1e = {
  root: {
    background: "{content.background}",
    borderRadius: "{border.radius.xl}",
    color: "{content.color}",
    shadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
  },
  body: {
    padding: "1.25rem",
    gap: "0.5rem"
  },
  caption: {
    gap: "0.5rem"
  },
  title: {
    fontSize: "1.25rem",
    fontWeight: "500"
  },
  subtitle: {
    color: "{text.muted.color}"
  }
};
var index$1d = {
  root: {
    indicatorList: {
      padding: "1rem",
      gap: "0.5rem"
    },
    indicator: {
      width: "2rem",
      height: "0.5rem",
      borderRadius: "{content.border.radius}",
      focusRing: {
        width: "{focus.ring.width}",
        style: "{focus.ring.style}",
        color: "{focus.ring.color}",
        offset: "{focus.ring.offset}",
        shadow: "{focus.ring.shadow}"
      }
    },
    transitionDuration: "{transition.duration}"
  },
  colorScheme: {
    light: {
      indicator: {
        background: "{surface.200}",
        hoverBackground: "{surface.300}",
        activeBackground: "{primary.color}"
      }
    },
    dark: {
      indicator: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}",
        activeBackground: "{primary.color}"
      }
    }
  }
};
var index$1c = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}"
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}",
    icon: {
      color: "{list.option.icon.color}",
      focusColor: "{list.option.icon.focus.color}",
      size: "0.875rem"
    }
  }
};
var index$1b = {
  root: {
    borderRadius: "{border.radius.sm}",
    width: "1.25rem",
    height: "1.25rem",
    background: "{form.field.background}",
    checkedBackground: "{primary.color}",
    checkedHoverBackground: "{primary.hover.color}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.border.color}",
    checkedBorderColor: "{primary.color}",
    checkedHoverBorderColor: "{primary.hover.color}",
    checkedFocusBorderColor: "{primary.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    size: "0.875rem",
    color: "{form.field.color}",
    checkedColor: "{primary.contrast.color}",
    checkedHoverColor: "{primary.contrast.color}",
    disabledColor: "{form.field.disabled.color}"
  }
};
var index$1a = {
  root: {
    borderRadius: "16px",
    paddingX: "0.75rem",
    paddingY: "0.5rem",
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  image: {
    width: "2rem",
    height: "2rem"
  },
  icon: {
    size: "1rem"
  },
  removeIcon: {
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.100}",
        color: "{surface.800}"
      },
      icon: {
        color: "{surface.800}"
      },
      removeIcon: {
        color: "{surface.800}"
      }
    },
    dark: {
      root: {
        background: "{surface.800}",
        color: "{surface.0}"
      },
      icon: {
        color: "{surface.0}"
      },
      removeIcon: {
        color: "{surfaec.0}"
      }
    }
  }
};
var index$19 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  preview: {
    width: "1.5rem",
    height: "1.5rem",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  panel: {
    shadow: "{overlay.popover.shadow}",
    borderRadius: "{overlay.popover.borderRadius}"
  },
  colorScheme: {
    light: {
      panel: {
        background: "{surface.800}",
        borderColor: "{surface.900}"
      },
      handle: {
        color: "{surface.0}"
      }
    },
    dark: {
      panel: {
        background: "{surface.900}",
        borderColor: "{surface.700}"
      },
      handle: {
        color: "{surface.0}"
      }
    }
  }
};
var index$18 = {
  icon: {
    size: "2rem",
    color: "{overlay.modal.color}"
  },
  content: {
    gap: "1rem"
  }
};
var index$17 = {
  root: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    color: "{overlay.popover.color}",
    borderRadius: "{overlay.popover.border.radius}",
    shadow: "{overlay.popover.shadow}",
    gutter: "10px",
    arrowOffset: "1.25rem"
  },
  content: {
    padding: "{overlay.popover.padding}",
    gap: "1rem"
  },
  icon: {
    size: "1.5rem",
    color: "{overlay.popover.color}"
  },
  footer: {
    gap: "0.5rem",
    padding: "0 {overlay.popover.padding} {overlay.popover.padding} {overlay.popover.padding}"
  }
};
var index$16 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$15 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  headerCell: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    gap: "0.5rem",
    padding: "0.75rem 1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  columnTitle: {
    fontWeight: "600"
  },
  row: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  bodyCell: {
    borderColor: "{datatable.border.color}",
    padding: "0.75rem 1rem"
  },
  footerCell: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    padding: "0.75rem 1rem"
  },
  columnFooter: {
    fontWeight: "600"
  },
  footer: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  dropPointColor: "{primary.color}",
  columnResizerWidth: "0.5rem",
  resizeIndicator: {
    width: "1px",
    color: "{primary.color}"
  },
  sortIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  loadingIcon: {
    size: "2rem"
  },
  rowToggleButton: {
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    selectedHoverColor: "{primary.color}",
    size: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  filter: {
    inlineGap: "0.5rem",
    overlaySelect: {
      background: "{overlay.select.background}",
      borderColor: "{overlay.select.border.color}",
      borderRadius: "{overlay.select.border.radius}",
      color: "{overlay.select.color}",
      shadow: "{overlay.select.shadow}"
    },
    overlayPopover: {
      background: "{overlay.popover.background}",
      borderColor: "{overlay.popover.border.color}",
      borderRadius: "{overlay.popover.border.radius}",
      color: "{overlay.popover.color}",
      shadow: "{overlay.popover.shadow}",
      padding: "{overlay.popover.padding}",
      gap: "0.5rem"
    },
    rule: {
      borderColor: "{content.border.color}"
    },
    constraintList: {
      padding: "{list.padding}",
      gap: "{list.gap}"
    },
    constraint: {
      focusBackground: "{list.option.focus.background}",
      selectedBackground: "{list.option.selected.background}",
      selectedFocusBackground: "{list.option.selected.focus.background}",
      color: "{list.option.color}",
      focusColor: "{list.option.focus.color}",
      selectedColor: "{list.option.selected.color}",
      selectedFocusColor: "{list.option.selected.focus.color}",
      separator: {
        borderColor: "{content.border.color}"
      },
      padding: "{list.option.padding}",
      borderRadius: "{list.option.border.radius}"
    }
  },
  paginatorTop: {
    borderColor: "{datatable.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{datatable.border.color}",
    borderWidth: "0 0 1px 0"
  },
  colorScheme: {
    light: {
      root: {
        borderColor: "{content.border.color}"
      },
      row: {
        stripedBackground: "{surface.50}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.100}"
      }
    },
    dark: {
      root: {
        borderColor: "{surface.800}"
      },
      row: {
        stripedBackground: "{surface.950}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.900}"
      }
    }
  }
};
var index$14 = {
  root: {
    borderColor: "transparent",
    borderWidth: "0",
    borderRadius: "0",
    padding: "0"
  },
  header: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem",
    borderRadius: "0"
  },
  content: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "transparent",
    borderWidth: "0",
    padding: "0",
    borderRadius: "0"
  },
  footer: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "{content.border.color}",
    borderWidth: "1px 0 0 0",
    padding: "0.75rem 1rem",
    borderRadius: "0"
  },
  paginatorTop: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{content.border.color}",
    borderWidth: "1px 0 0 0"
  }
};
var index$13 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  panel: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.popover.shadow}",
    padding: "{overlay.popover.padding}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    padding: "0 0 0.5rem 0",
    fontWeight: "500",
    gap: "0.5rem"
  },
  title: {
    gap: "0.5rem",
    fontWeight: "500"
  },
  dropdown: {
    width: "2.5rem",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.border.color}",
    activeBorderColor: "{form.field.border.color}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  inputIcon: {
    color: "{form.field.icon.color}"
  },
  selectMonth: {
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}"
  },
  selectYear: {
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}"
  },
  group: {
    borderColor: "{content.border.color}",
    gap: "{overlay.popover.padding}"
  },
  dayView: {
    margin: "0.5rem 0 0 0"
  },
  weekDay: {
    padding: "0.25rem",
    fontWeight: "500",
    color: "{content.color}"
  },
  date: {
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{primary.color}",
    rangeSelectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{primary.contrast.color}",
    rangeSelectedColor: "{highlight.color}",
    width: "2rem",
    height: "2rem",
    borderRadius: "50%",
    padding: "0.25rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  monthView: {
    margin: "0.5rem 0 0 0"
  },
  month: {
    borderRadius: "{content.border.radius}"
  },
  yearView: {
    margin: "0.5rem 0 0 0"
  },
  year: {
    borderRadius: "{content.border.radius}"
  },
  buttonbar: {
    padding: "0.5rem 0 0 0",
    borderColor: "{content.border.color}"
  },
  timePicker: {
    padding: "0.5rem 0 0 0",
    borderColor: "{content.border.color}",
    gap: "0.5rem",
    buttonGap: "0.25rem"
  },
  colorScheme: {
    light: {
      dropdown: {
        background: "{surface.100}",
        hoverBackground: "{surface.200}",
        activeBackground: "{surface.300}",
        color: "{surface.600}",
        hoverColor: "{surface.700}",
        activeColor: "{surface.800}"
      },
      today: {
        background: "{surface.200}",
        color: "{surface.900}"
      }
    },
    dark: {
      dropdown: {
        background: "{surface.800}",
        hoverBackground: "{surface.700}",
        activeBackground: "{surface.600}",
        color: "{surface.300}",
        hoverColor: "{surface.200}",
        activeColor: "{surface.100}"
      },
      today: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$12 = {
  root: {
    background: "{overlay.modal.background}",
    borderColor: "{overlay.modal.border.color}",
    color: "{overlay.modal.color}",
    borderRadius: "{overlay.modal.border.radius}",
    shadow: "{overlay.modal.shadow}"
  },
  header: {
    padding: "{overlay.modal.padding}",
    gap: "0.5rem"
  },
  title: {
    fontSize: "1.25rem",
    fontWeight: "600"
  },
  content: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
  },
  footer: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}",
    gap: "0.5rem"
  }
};
var index$11 = {
  root: {
    borderColor: "{content.border.color}"
  },
  content: {
    background: "{content.background}",
    color: "{text.color}"
  },
  horizontal: {
    margin: "1rem 0",
    padding: "0 1rem",
    content: {
      padding: "0 0.5rem"
    }
  },
  vertical: {
    margin: "0 1rem",
    padding: "0.5rem 0",
    content: {
      padding: "0.5rem 0"
    }
  }
};
var index$10 = {
  root: {
    background: "rgba(255, 255, 255, 0.1)",
    borderColor: "rgba(255, 255, 255, 0.2)",
    padding: "0.5rem",
    borderRadius: "{border.radius.xl}"
  },
  item: {
    borderRadius: "{content.border.radius}",
    padding: "0.5rem",
    size: "3rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$$ = {
  root: {
    background: "{overlay.modal.background}",
    borderColor: "{overlay.modal.border.color}",
    color: "{overlay.modal.color}",
    borderRadius: "{overlay.modal.border.radius}",
    shadow: "{overlay.modal.shadow}"
  },
  header: {
    padding: "{overlay.modal.padding}"
  },
  title: {
    fontSize: "1.5rem",
    fontWeight: "600"
  },
  content: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
  }
};
var index$_ = {
  toolbar: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}"
  },
  toolbarItem: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}",
    padding: "{list.padding}"
  },
  overlayOption: {
    focusBackground: "{list.option.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  content: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}"
  }
};
var index$Z = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    padding: "0 1.125rem 1.125rem 1.125rem",
    transitionDuration: "{transition.duration}"
  },
  legend: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    borderColor: "transparent",
    padding: "0.5rem 0.75rem",
    gap: "0.5rem",
    fontWeight: "600",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  toggleIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  content: {
    padding: "0"
  }
};
var index$Y = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "transparent",
    color: "{text.color}",
    padding: "1.125rem",
    borderWidth: "0",
    borderRadius: "0",
    gap: "0.5rem"
  },
  content: {
    highlightBorderColor: "{primary.color}",
    padding: "0 1.125rem 1.125rem 1.125rem"
  },
  file: {
    padding: "1rem",
    gap: "1rem",
    borderColor: "{content.border.color}",
    info: {
      gap: "0.5rem"
    }
  },
  progressbar: {
    height: "0.25rem"
  },
  basic: {
    gap: "0.5rem"
  }
};
var index$X = {
  root: {
    color: "{form.field.float.label.color}",
    focusColor: "{form.field.float.label.focus.color}",
    invalidColor: "{form.field.float.label.invalid.color}",
    transitionDuration: "0.2s"
  }
};
var index$W = {
  root: {
    borderWidth: "1px",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    transitionDuration: "{transition.duration}"
  },
  navButton: {
    background: "rgba(255, 255, 255, 0.1)",
    hoverBackground: "rgba(255, 255, 255, 0.2)",
    color: "{surface.100}",
    hoverColor: "{surface.0}",
    size: "3rem",
    gutter: "0.5rem",
    prev: {
      borderRadius: "50%"
    },
    next: {
      borderRadius: "50%"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  navIcon: {
    size: "1.5rem"
  },
  thumbnailsContent: {
    background: "{content.background}",
    padding: "1rem 0.25rem"
  },
  thumbnailNavButton: {
    size: "2rem",
    borderRadius: "{content.border.radius}",
    gutter: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  thumbnailNavButtonIcon: {
    size: "1rem"
  },
  caption: {
    background: "rgba(0, 0, 0, 0.5)",
    color: "{surface.100}",
    padding: "1rem"
  },
  indicatorList: {
    gap: "0.5rem",
    padding: "1rem"
  },
  indicatorButton: {
    width: "1rem",
    height: "1rem",
    activeBackground: "{primary.color}",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  insetIndicatorList: {
    background: "rgba(0, 0, 0, 0.5)"
  },
  insetIndicatorButton: {
    background: "rgba(255, 255, 255, 0.4)",
    hoverBackground: "rgba(255, 255, 255, 0.6)",
    activeBackground: "rgba(255, 255, 255, 0.9)"
  },
  mask: {
    background: "{mask.background}",
    color: "{mask.color}"
  },
  closeButton: {
    size: "3rem",
    gutter: "0.5rem",
    background: "rgba(255, 255, 255, 0.1)",
    hoverBackground: "rgba(255, 255, 255, 0.2)",
    color: "{surface.50}",
    hoverColor: "{surface.0}",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  closeButtonIcon: {
    size: "1.5rem"
  },
  colorScheme: {
    light: {
      thumbnailNavButton: {
        hoverBackground: "{surface.100}",
        color: "{surface.600}",
        hoverColor: "{surface.700}"
      },
      indicatorButton: {
        background: "{surface.200}",
        hoverBackground: "{surface.300}"
      }
    },
    dark: {
      thumbnailNavButton: {
        hoverBackground: "{surface.700}",
        color: "{surface.400}",
        hoverColor: "{surface.0}"
      },
      indicatorButton: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}"
      }
    }
  }
};
var index$V = {
  icon: {
    color: "{form.field.icon.color}"
  }
};
var index$U = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  preview: {
    icon: {
      size: "1.5rem"
    },
    mask: {
      background: "{mask.background}",
      color: "{mask.color}"
    }
  },
  toolbar: {
    position: {
      left: "auto",
      right: "1rem",
      top: "1rem",
      bottom: "auto"
    },
    blur: "8px",
    background: "rgba(255,255,255,0.1)",
    borderColor: "rgba(255,255,255,0.2)",
    borderWidth: "1px",
    borderRadius: "30px",
    padding: ".5rem",
    gap: "0.5rem"
  },
  action: {
    hoverBackground: "rgba(255,255,255,0.1)",
    color: "{surface.50}",
    hoverColor: "{surface.0}",
    size: "3rem",
    iconSize: "1.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$T = {
  root: {
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{content.border.radius}",
    gap: "0.5rem"
  },
  text: {
    fontWeight: "500"
  },
  icon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
      }
    },
    dark: {
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
      }
    }
  }
};
var index$S = {
  root: {
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{transition.duration}"
  },
  display: {
    hoverBackground: "{content.hover.background}",
    hoverColor: "{content.hover.color}"
  }
};
var index$R = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  colorScheme: {
    light: {
      chip: {
        focusBackground: "{surface.200}",
        color: "{surface.800}"
      }
    },
    dark: {
      chip: {
        focusBackground: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$Q = {
  addon: {
    background: "{form.field.background}",
    borderColor: "{form.field.border.color}",
    color: "{form.field.icon.color}",
    borderRadius: "{form.field.border.radius}"
  }
};
var index$P = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  button: {
    width: "2.5rem",
    borderRadius: "{form.field.border.radius}",
    verticalPadding: "{form.field.padding.y}"
  },
  colorScheme: {
    light: {
      button: {
        background: "transparent",
        hoverBackground: "{surface.100}",
        activeBackground: "{surface.200}",
        borderColor: "{form.field.border.color}",
        hoverBorderColor: "{form.field.border.color}",
        activeBorderColor: "{form.field.border.color}",
        color: "{surface.400}",
        hoverColor: "{surface.500}",
        activeColor: "{surface.600}"
      }
    },
    dark: {
      button: {
        background: "transparent",
        hoverBackground: "{surface.800}",
        activeBackground: "{surface.700}",
        borderColor: "{form.field.border.color}",
        hoverBorderColor: "{form.field.border.color}",
        activeBorderColor: "{form.field.border.color}",
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        activeColor: "{surface.200}"
      }
    }
  }
};
var index$O = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}",
    sm: {
      fontSize: "0.875rem",
      paddingX: "0.625rem",
      paddingY: "0.375rem"
    },
    lg: {
      fontSize: "1.125rem",
      paddingX: "0.875rem",
      paddingY: "0.625rem"
    }
  }
};
var index$N = {
  root: {
    transitionDuration: "{transition.duration}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  value: {
    background: "{primary.color}"
  },
  range: {
    background: "{content.border.color}"
  },
  text: {
    color: "{text.muted.color}"
  }
};
var index$M = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    shadow: "{form.field.shadow}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  checkmark: {
    color: "{list.option.color}",
    gutterStart: "-0.375rem",
    gutterEnd: "0.375rem"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  colorScheme: {
    light: {
      option: {
        stripedBackground: "{surface.50}"
      }
    },
    dark: {
      option: {
        stripedBackground: "{surface.900}"
      }
    }
  }
};
var index$L = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    verticalOrientation: {
      padding: "{navigation.list.padding}",
      gap: "0"
    },
    horizontalOrientation: {
      padding: "0.5rem 0.75rem"
    },
    transitionDuration: "{transition.duration}"
  },
  baseItem: {
    borderRadius: "{content.border.radius}",
    padding: "{navigation.item.padding}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  overlay: {
    padding: "0",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    shadow: "{overlay.navigation.shadow}",
    gap: "0.5rem"
  },
  submenu: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  },
  mobileButton: {
    borderRadius: "50%",
    size: "1.75rem",
    color: "{text.muted.color}",
    hoverColor: "{text.muted.hover.color}",
    hoverBackground: "{content.hover.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$K = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}"
    }
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$J = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    padding: "0.5rem 0.75rem",
    transitionDuration: "{transition.duration}"
  },
  baseItem: {
    borderRadius: "{content.border.radius}",
    padding: "{navigation.item.padding}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenu: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    mobileIndent: "1rem"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  },
  mobileButton: {
    borderRadius: "50%",
    size: "1.75rem",
    color: "{text.muted.color}",
    hoverColor: "{text.muted.hover.color}",
    hoverBackground: "{content.hover.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$I = {
  root: {
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    transitionDuration: "{transition.duration}"
  },
  content: {
    padding: "0.5rem 0.75rem",
    gap: "0.5rem"
  },
  text: {
    fontSize: "1rem",
    fontWeight: "500"
  },
  icon: {
    size: "1.125rem"
  },
  closeButton: {
    width: "1.75rem",
    height: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    }
  },
  closeIcon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{blue.100}",
          focusRing: {
            color: "{blue.600}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{green.100}",
          focusRing: {
            color: "{green.600}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{yellow.100}",
          focusRing: {
            color: "{yellow.600}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{red.100}",
          focusRing: {
            color: "{red.600}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.200}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.800}",
          focusRing: {
            color: "{surface.50}",
            shadow: "none"
          }
        }
      }
    },
    dark: {
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{blue.500}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{yellow.500}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.700}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.100}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      }
    }
  }
};
var index$H = {
  root: {
    borderRadius: "{content.border.radius}",
    gap: "1rem"
  },
  meters: {
    background: "{content.border.color}",
    size: "0.5rem"
  },
  label: {
    gap: "0.5rem"
  },
  labelMarker: {
    size: "0.5rem"
  },
  labelIcon: {
    size: "1rem"
  },
  labelList: {
    verticalGap: "0.5rem",
    horizontalGap: "1rem"
  }
};
var index$G = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}",
    gap: "0.5rem"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  }
};
var index$F = {
  root: {
    gap: "1.125rem"
  },
  controls: {
    gap: "0.5rem"
  }
};
var index$E = {
  root: {
    gutter: "0.75rem",
    transitionDuration: "{transition.duration}"
  },
  node: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    selectedColor: "{highlight.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.75rem 1rem",
    toggleablePadding: "0.75rem 1rem 1.25rem 1rem",
    borderRadius: "{content.border.radius}"
  },
  nodeToggleButton: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    borderColor: "{content.border.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    size: "1.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  connector: {
    color: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: "24px"
  }
};
var index$D = {
  root: {
    outline: {
      width: "2px",
      color: "{content.background}"
    }
  }
};
var index$C = {
  root: {
    padding: "0.5rem 1rem",
    gap: "0.25rem",
    borderRadius: "{content.border.radius}",
    background: "{content.background}",
    color: "{content.color}",
    transitionDuration: "{transition.duration}"
  },
  navButton: {
    background: "transparent",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedColor: "{highlight.color}",
    width: "2.5rem",
    height: "2.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  currentPageReport: {
    color: "{text.muted.color}"
  },
  jumpToPageInput: {
    maxWidth: "2.5rem"
  }
};
var index$B = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}"
  },
  header: {
    background: "transparent",
    color: "{text.color}",
    padding: "1.125rem",
    borderColor: "{content.border.color}",
    borderWidth: "0",
    borderRadius: "0"
  },
  toggleableHeader: {
    padding: "0.375rem 1.125rem"
  },
  title: {
    fontWeight: "600"
  },
  content: {
    padding: "0 1.125rem 1.125rem 1.125rem"
  },
  footer: {
    padding: "0 1.125rem 1.125rem 1.125rem"
  }
};
var index$A = {
  root: {
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  panel: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderWidth: "1px",
    color: "{content.color}",
    padding: "0.25rem 0.25rem",
    borderRadius: "{content.border.radius}",
    first: {
      borderWidth: "1px",
      topBorderRadius: "{content.border.radius}"
    },
    last: {
      borderWidth: "1px",
      bottomBorderRadius: "{content.border.radius}"
    }
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    gap: "0.5rem",
    padding: "{navigation.item.padding}",
    borderRadius: "{content.border.radius}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}"
    }
  },
  submenu: {
    indent: "1rem"
  },
  submenuIcon: {
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}"
  }
};
var index$z = {
  meter: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: ".75rem"
  },
  icon: {
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    borderRadius: "{overlay.popover.border.radius}",
    color: "{overlay.popover.color}",
    padding: "{overlay.popover.padding}",
    shadow: "{overlay.popover.shadow}"
  },
  content: {
    gap: "0.5rem"
  },
  colorScheme: {
    light: {
      strength: {
        weakBackground: "{red.500}",
        mediumBackground: "{amber.500}",
        strongBackground: "{green.500}"
      }
    },
    dark: {
      strength: {
        weakBackground: "{red.400}",
        mediumBackground: "{amber.400}",
        strongBackground: "{green.400}"
      }
    }
  }
};
var index$y = {
  root: {
    gap: "1.125rem"
  },
  controls: {
    gap: "0.5rem"
  }
};
var index$x = {
  root: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    color: "{overlay.popover.color}",
    borderRadius: "{overlay.popover.border.radius}",
    shadow: "{overlay.popover.shadow}",
    gutter: "10px",
    arrowOffset: "1.25rem"
  },
  content: {
    padding: "{overlay.popover.padding}"
  }
};
var index$w = {
  root: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: "1.25rem"
  },
  value: {
    background: "{primary.color}"
  },
  label: {
    color: "{primary.contrast.color}",
    fontSize: "0.75rem",
    fontWeight: "600"
  }
};
var index$v = {
  colorScheme: {
    light: {
      root: {
        "color.1": "{red.500}",
        "color.2": "{blue.500}",
        "color.3": "{green.500}",
        "color.4": "{yellow.500}"
      }
    },
    dark: {
      root: {
        "color.1": "{red.400}",
        "color.2": "{blue.400}",
        "color.3": "{green.400}",
        "color.4": "{yellow.400}"
      }
    }
  }
};
var index$u = {
  root: {
    width: "1.25rem",
    height: "1.25rem",
    background: "{form.field.background}",
    checkedBackground: "{primary.color}",
    checkedHoverBackground: "{primary.hover.color}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.border.color}",
    checkedBorderColor: "{primary.color}",
    checkedHoverBorderColor: "{primary.hover.color}",
    checkedFocusBorderColor: "{primary.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    size: "0.75rem",
    checkedColor: "{primary.contrast.color}",
    checkedHoverColor: "{primary.contrast.color}",
    disabledColor: "{form.field.disabled.color}"
  }
};
var index$t = {
  root: {
    gap: "0.25rem",
    transitionDuration: "{transition.duration}"
  },
  icon: {
    size: "1rem",
    color: "{text.muted.color}",
    hoverColor: "{primary.color}",
    activeColor: "{primary.color}"
  }
};
var index$s = {
  colorScheme: {
    light: {
      root: {
        background: "rgba(0,0,0,0.1)"
      }
    },
    dark: {
      root: {
        background: "rgba(255,255,255,0.3)"
      }
    }
  }
};
var index$r = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  bar: {
    size: "9px",
    borderRadius: "{border.radius.sm}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      bar: {
        background: "{surface.100}"
      }
    },
    dark: {
      bar: {
        background: "{surface.800}"
      }
    }
  }
};
var index$q = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  clearIcon: {
    color: "{form.field.icon.color}"
  },
  checkmark: {
    color: "{list.option.color}",
    gutterStart: "-0.375rem",
    gutterEnd: "0.375rem"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  }
};
var index$p = {
  root: {
    borderRadius: "{form.field.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        invalidBorderColor: "{form.field.invalid.border.color}"
      }
    },
    dark: {
      root: {
        invalidBorderColor: "{form.field.invalid.border.color}"
      }
    }
  }
};
var index$o = {
  root: {
    borderRadius: "{content.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.200}",
        animationBackground: "rgba(255,255,255,0.4)"
      }
    },
    dark: {
      root: {
        background: "rgba(255, 255, 255, 0.06)",
        animationBackground: "rgba(255, 255, 255, 0.04)"
      }
    }
  }
};
var index$n = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  track: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    size: "3px"
  },
  range: {
    background: "{primary.color}"
  },
  handle: {
    width: "20px",
    height: "20px",
    borderRadius: "50%",
    background: "{content.border.color}",
    hoverBackground: "{content.border.color}",
    content: {
      borderRadius: "50%",
      hoverBackground: "{content.background}",
      width: "16px",
      height: "16px",
      shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.08), 0px 1px 1px 0px rgba(0, 0, 0, 0.14)"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      handle: {
        contentBackground: "{surface.0}"
      }
    },
    dark: {
      handle: {
        contentBackground: "{surface.950}"
      }
    }
  }
};
var index$m = {
  root: {
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  }
};
var index$l = {
  root: {
    borderRadius: "{form.field.border.radius}",
    roundedBorderRadius: "2rem",
    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)"
  }
};
var index$k = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    transitionDuration: "{transition.duration}"
  },
  gutter: {
    background: "{content.border.color}"
  },
  handle: {
    size: "24px",
    background: "transparent",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$j = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  separator: {
    background: "{content.border.color}",
    activeBackground: "{primary.color}",
    margin: "0 0 0 1.625rem",
    size: "2px"
  },
  step: {
    padding: "0.5rem",
    gap: "1rem"
  },
  stepHeader: {
    padding: "0",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.5rem"
  },
  stepTitle: {
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    fontWeight: "500"
  },
  stepNumber: {
    background: "{content.background}",
    activeBackground: "{content.background}",
    borderColor: "{content.border.color}",
    activeBorderColor: "{content.border.color}",
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    size: "2rem",
    fontSize: "1.143rem",
    fontWeight: "500",
    borderRadius: "50%",
    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
  },
  steppanels: {
    padding: "0.875rem 0.5rem 1.125rem 0.5rem"
  },
  steppanel: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "0 0 0 1rem",
    last: {
      padding: "0 0 0 1.625rem"
    }
  }
};
var index$i = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  separator: {
    background: "{content.border.color}"
  },
  itemLink: {
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.5rem"
  },
  itemLabel: {
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    fontWeight: "500"
  },
  itemNumber: {
    background: "{content.background}",
    activeBackground: "{content.background}",
    borderColor: "{content.border.color}",
    activeBorderColor: "{content.border.color}",
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    size: "2rem",
    fontSize: "1.143rem",
    fontWeight: "500",
    borderRadius: "50%",
    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
  }
};
var index$h = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tablist: {
    borderWidth: "0 0 1px 0",
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  item: {
    background: "transparent",
    hoverBackground: "transparent",
    activeBackground: "transparent",
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}",
    hoverBorderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}",
    padding: "1rem 1.125rem",
    fontWeight: "600",
    margin: "0 0 -1px 0",
    gap: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  itemIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  activeBar: {
    height: "1px",
    bottom: "-1px",
    background: "{primary.color}"
  }
};
var index$g = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tablist: {
    borderWidth: "0 0 1px 0",
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  tab: {
    background: "transparent",
    hoverBackground: "transparent",
    activeBackground: "transparent",
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}",
    hoverBorderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}",
    padding: "1rem 1.125rem",
    fontWeight: "600",
    margin: "0 0 -1px 0",
    gap: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  tabpanel: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "0.875rem 1.125rem 1.125rem 1.125rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "inset {focus.ring.shadow}"
    }
  },
  navButton: {
    background: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    width: "2.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  activeBar: {
    height: "1px",
    bottom: "-1px",
    background: "{primary.color}"
  },
  colorScheme: {
    light: {
      navButton: {
        boxShadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
      }
    },
    dark: {
      navButton: {
        boxShadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
      }
    }
  }
};
var index$f = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tabList: {
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  tab: {
    borderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  tabPanel: {
    background: "{content.background}",
    color: "{content.color}"
  },
  navButton: {
    background: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}"
  },
  colorScheme: {
    light: {
      navButton: {
        boxShadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
      }
    },
    dark: {
      navButton: {
        boxShadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
      }
    }
  }
};
var index$e = {
  root: {
    fontSize: "0.875rem",
    fontWeight: "700",
    padding: "0.25rem 0.5rem",
    gap: "0.25rem",
    borderRadius: "{content.border.radius}",
    roundedBorderRadius: "{border.radius.xl}"
  },
  icon: {
    size: "0.75rem"
  },
  colorScheme: {
    light: {
      primary: {
        background: "{primary.100}",
        color: "{primary.700}"
      },
      secondary: {
        background: "{surface.100}",
        color: "{surface.600}"
      },
      success: {
        background: "{green.100}",
        color: "{green.700}"
      },
      info: {
        background: "{sky.100}",
        color: "{sky.700}"
      },
      warn: {
        background: "{orange.100}",
        color: "{orange.700}"
      },
      danger: {
        background: "{red.100}",
        color: "{red.700}"
      },
      contrast: {
        background: "{surface.950}",
        color: "{surface.0}"
      }
    },
    dark: {
      primary: {
        background: "color-mix(in srgb, {primary.500}, transparent 84%)",
        color: "{primary.300}"
      },
      secondary: {
        background: "{surface.800}",
        color: "{surface.300}"
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        color: "{green.300}"
      },
      info: {
        background: "color-mix(in srgb, {sky.500}, transparent 84%)",
        color: "{sky.300}"
      },
      warn: {
        background: "color-mix(in srgb, {orange.500}, transparent 84%)",
        color: "{orange.300}"
      },
      danger: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        color: "{red.300}"
      },
      contrast: {
        background: "{surface.0}",
        color: "{surface.950}"
      }
    }
  }
};
var index$d = {
  root: {
    background: "{form.field.background}",
    borderColor: "{form.field.border.color}",
    color: "{form.field.color}",
    height: "18rem",
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{form.field.border.radius}"
  },
  prompt: {
    gap: "0.25rem"
  },
  commandResponse: {
    margin: "2px 0"
  }
};
var index$c = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  }
};
var index$b = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$a = {
  event: {
    minHeight: "5rem"
  },
  horizontal: {
    eventContent: {
      padding: "1rem 0"
    }
  },
  vertical: {
    eventContent: {
      padding: "0 1rem"
    }
  },
  eventMarker: {
    size: "1.125rem",
    borderRadius: "50%",
    borderWidth: "2px",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    content: {
      borderRadius: "50%",
      size: "0.375rem",
      background: "{primary.color}",
      insetShadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
    }
  },
  eventConnector: {
    color: "{content.border.color}",
    size: "2px"
  }
};
var index$9 = {
  root: {
    width: "25rem",
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    transitionDuration: "{transition.duration}"
  },
  icon: {
    size: "1.125rem"
  },
  content: {
    padding: "{overlay.popover.padding}",
    gap: "0.5rem"
  },
  text: {
    gap: "0.5rem"
  },
  summary: {
    fontWeight: "500",
    fontSize: "1rem"
  },
  detail: {
    fontWeight: "500",
    fontSize: "0.875rem"
  },
  closeButton: {
    width: "1.75rem",
    height: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    }
  },
  closeIcon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      blur: "1.5px",
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{blue.100}",
          focusRing: {
            color: "{blue.600}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{green.100}",
          focusRing: {
            color: "{green.600}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{yellow.100}",
          focusRing: {
            color: "{yellow.600}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{red.100}",
          focusRing: {
            color: "{red.600}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.200}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.800}",
          focusRing: {
            color: "{surface.50}",
            shadow: "none"
          }
        }
      }
    },
    dark: {
      blur: "10px",
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{blue.500}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{yellow.500}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.700}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        detailColor: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.100}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      }
    }
  }
};
var index$8 = {
  root: {
    padding: "0.5rem 1rem",
    borderRadius: "{content.border.radius}",
    gap: "0.5rem",
    fontWeight: "500",
    disabledBackground: "{form.field.disabled.background}",
    disabledBorderColor: "{form.field.disabled.background}",
    disabledColor: "{form.field.disabled.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    disabledColor: "{form.field.disabled.color}"
  },
  content: {
    left: "0.25rem",
    top: "0.25rem",
    checkedShadow: "0px 1px 2px 0px rgba(0, 0, 0, 0.02), 0px 1px 2px 0px rgba(0, 0, 0, 0.04)"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.100}",
        checkedBackground: "{surface.100}",
        hoverBackground: "{surface.100}",
        borderColor: "{surface.100}",
        color: "{surface.500}",
        hoverColor: "{surface.700}",
        checkedColor: "{surface.900}",
        checkedBorderColor: "{surface.100}"
      },
      content: {
        checkedBackground: "{surface.0}"
      },
      icon: {
        color: "{surface.500}",
        hoverColor: "{surface.700}",
        checkedColor: "{surface.900}"
      }
    },
    dark: {
      root: {
        background: "{surface.950}",
        checkedBackground: "{surface.950}",
        hoverBackground: "{surface.950}",
        borderColor: "{surface.950}",
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        checkedColor: "{surface.0}",
        checkedBorderColor: "{surface.950}"
      },
      content: {
        checkedBackground: "{surface.800}"
      },
      icon: {
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        checkedColor: "{surface.0}"
      }
    }
  }
};
var index$7 = {
  root: {
    width: "2.5rem",
    height: "1.5rem",
    borderRadius: "30px",
    gap: "0.25rem",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    borderWidth: "1px",
    borderColor: "transparent",
    hoverBorderColor: "transparent",
    checkedBorderColor: "transparent",
    checkedHoverBorderColor: "transparent",
    invalidBorderColor: "{form.field.invalid.border.color}",
    transitionDuration: "{form.field.transition.duration}",
    slideDuration: "0.2s"
  },
  handle: {
    borderRadius: "50%",
    size: "1rem"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.300}",
        hoverBackground: "{surface.400}",
        checkedBackground: "{primary.color}",
        checkedHoverBackground: "{primary.hover.color}"
      },
      handle: {
        background: "{surface.0}",
        hoverBackground: "{surface.0}",
        checkedBackground: "{surface.0}",
        checkedHoverBackground: "{surface.0}"
      }
    },
    dark: {
      root: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}",
        checkedBackground: "{primary.color}",
        checkedHoverBackground: "{primary.hover.color}"
      },
      handle: {
        background: "{surface.400}",
        hoverBackground: "{surface.300}",
        checkedBackground: "{surface.900}",
        checkedHoverBackground: "{surface.900}"
      }
    }
  }
};
var index$6 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    padding: "0.75rem"
  }
};
var index$5 = {
  root: {
    maxWidth: "12.5rem",
    gutter: "0.25rem",
    shadow: "{overlay.popover.shadow}",
    padding: "0.5rem 0.75rem",
    borderRadius: "{overlay.popover.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    },
    dark: {
      root: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$4 = {
  root: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "1rem",
    gap: "2px",
    indent: "1rem",
    transitionDuration: "{transition.duration}"
  },
  node: {
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{text.color}",
    hoverColor: "{text.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.25rem"
  },
  nodeIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedColor: "{highlight.color}"
  },
  nodeToggleButton: {
    borderRadius: "50%",
    size: "1.75rem",
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedHoverColor: "{primary.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  loadingIcon: {
    size: "2rem"
  }
};
var index$3 = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  tree: {
    padding: "{list.padding}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  }
};
var index$2 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  headerCell: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    gap: "0.5rem",
    padding: "0.75rem 1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  columnTitle: {
    fontWeight: "600"
  },
  row: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  bodyCell: {
    borderColor: "{treetable.border.color}",
    padding: "0.75rem 1rem",
    gap: "0.5rem"
  },
  footerCell: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    padding: "0.75rem 1rem"
  },
  columnFooter: {
    fontWeight: "600"
  },
  footer: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  columnResizerWidth: "0.5rem",
  resizeIndicator: {
    width: "1px",
    color: "{primary.color}"
  },
  sortIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  loadingIcon: {
    size: "2rem"
  },
  nodeToggleButton: {
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    selectedHoverColor: "{primary.color}",
    size: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  paginatorTop: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  colorScheme: {
    light: {
      root: {
        borderColor: "{content.border.color}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.100}"
      }
    },
    dark: {
      root: {
        borderColor: "{surface.800}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.900}"
      }
    }
  }
};
var index$1 = {
  primitive: {
    borderRadius: {
      none: "0",
      xs: "2px",
      sm: "4px",
      md: "6px",
      lg: "8px",
      xl: "12px"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    }
  },
  semantic: {
    transitionDuration: "0.2s",
    focusRing: {
      width: "1px",
      style: "solid",
      color: "{primary.color}",
      offset: "2px",
      shadow: "none"
    },
    disabledOpacity: "0.6",
    iconSize: "1rem",
    anchorGutter: "2px",
    primary: {
      50: "{emerald.50}",
      100: "{emerald.100}",
      200: "{emerald.200}",
      300: "{emerald.300}",
      400: "{emerald.400}",
      500: "{emerald.500}",
      600: "{emerald.600}",
      700: "{emerald.700}",
      800: "{emerald.800}",
      900: "{emerald.900}",
      950: "{emerald.950}"
    },
    formField: {
      paddingX: "0.75rem",
      paddingY: "0.5rem",
      borderRadius: "{border.radius.md}",
      focusRing: {
        width: "0",
        style: "none",
        color: "transparent",
        offset: "0",
        shadow: "none"
      },
      transitionDuration: "{transition.duration}"
    },
    list: {
      padding: "0.25rem 0.25rem",
      gap: "2px",
      header: {
        padding: "0.5rem 0.75rem 0.25rem 0.75rem"
      },
      option: {
        padding: "0.5rem 0.75rem",
        borderRadius: "{border.radius.sm}"
      },
      optionGroup: {
        padding: "0.5rem 0.75rem",
        fontWeight: "600"
      }
    },
    content: {
      borderRadius: "{border.radius.md}"
    },
    mask: {
      transitionDuration: "0.15s"
    },
    navigation: {
      list: {
        padding: "0.25rem 0.25rem",
        gap: "2px"
      },
      item: {
        padding: "0.5rem 0.75rem",
        borderRadius: "{border.radius.sm}",
        gap: "0.5rem"
      },
      submenuLabel: {
        padding: "0.5rem 0.75rem",
        fontWeight: "600"
      },
      submenuIcon: {
        size: "0.875rem"
      }
    },
    overlay: {
      select: {
        borderRadius: "{border.radius.md}",
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      },
      popover: {
        borderRadius: "{border.radius.md}",
        padding: "0.75rem",
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      },
      modal: {
        borderRadius: "{border.radius.xl}",
        padding: "1.25rem",
        shadow: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)"
      },
      navigation: {
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      }
    },
    colorScheme: {
      light: {
        surface: {
          0: "#ffffff",
          50: "{slate.50}",
          100: "{slate.100}",
          200: "{slate.200}",
          300: "{slate.300}",
          400: "{slate.400}",
          500: "{slate.500}",
          600: "{slate.600}",
          700: "{slate.700}",
          800: "{slate.800}",
          900: "{slate.900}",
          950: "{slate.950}"
        },
        primary: {
          color: "{primary.500}",
          contrastColor: "#ffffff",
          hoverColor: "{primary.600}",
          activeColor: "{primary.700}"
        },
        highlight: {
          background: "{primary.50}",
          focusBackground: "{primary.100}",
          color: "{primary.700}",
          focusColor: "{primary.800}"
        },
        mask: {
          background: "rgba(0,0,0,0.4)",
          color: "{surface.200}"
        },
        formField: {
          background: "{surface.0}",
          disabledBackground: "{surface.200}",
          filledBackground: "{surface.50}",
          filledFocusBackground: "{surface.50}",
          borderColor: "{surface.300}",
          hoverBorderColor: "{surface.400}",
          focusBorderColor: "{primary.color}",
          invalidBorderColor: "{red.400}",
          color: "{surface.700}",
          disabledColor: "{surface.500}",
          placeholderColor: "{surface.500}",
          floatLabelColor: "{surface.500}",
          floatLabelFocusColor: "{surface.500}",
          floatLabelInvalidColor: "{red.400}",
          iconColor: "{surface.400}",
          shadow: "0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)"
        },
        text: {
          color: "{surface.700}",
          hoverColor: "{surface.800}",
          mutedColor: "{surface.500}",
          hoverMutedColor: "{surface.600}"
        },
        content: {
          background: "{surface.0}",
          hoverBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{text.color}",
          hoverColor: "{text.hover.color}"
        },
        overlay: {
          select: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          },
          popover: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          },
          modal: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          }
        },
        list: {
          option: {
            focusBackground: "{surface.100}",
            selectedBackground: "{highlight.background}",
            selectedFocusBackground: "{highlight.focus.background}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            selectedColor: "{highlight.color}",
            selectedFocusColor: "{highlight.focus.color}",
            icon: {
              color: "{surface.400}",
              focusColor: "{surface.500}"
            }
          },
          optionGroup: {
            background: "transparent",
            color: "{text.muted.color}"
          }
        },
        navigation: {
          item: {
            focusBackground: "{surface.100}",
            activeBackground: "{surface.100}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            activeColor: "{text.hover.color}",
            icon: {
              color: "{surface.400}",
              focusColor: "{surface.500}",
              activeColor: "{surface.500}"
            }
          },
          submenuLabel: {
            background: "transparent",
            color: "{text.muted.color}"
          },
          submenuIcon: {
            color: "{surface.400}",
            focusColor: "{surface.500}",
            activeColor: "{surface.500}"
          }
        }
      },
      dark: {
        surface: {
          0: "#ffffff",
          50: "{zinc.50}",
          100: "{zinc.100}",
          200: "{zinc.200}",
          300: "{zinc.300}",
          400: "{zinc.400}",
          500: "{zinc.500}",
          600: "{zinc.600}",
          700: "{zinc.700}",
          800: "{zinc.800}",
          900: "{zinc.900}",
          950: "{zinc.950}"
        },
        primary: {
          color: "{primary.400}",
          contrastColor: "{surface.900}",
          hoverColor: "{primary.300}",
          activeColor: "{primary.200}"
        },
        highlight: {
          background: "color-mix(in srgb, {primary.400}, transparent 84%)",
          focusBackground: "color-mix(in srgb, {primary.400}, transparent 76%)",
          color: "rgba(255,255,255,.87)",
          focusColor: "rgba(255,255,255,.87)"
        },
        mask: {
          background: "rgba(0,0,0,0.6)",
          color: "{surface.200}"
        },
        formField: {
          background: "{surface.950}",
          disabledBackground: "{surface.700}",
          filledBackground: "{surface.800}",
          filledFocusBackground: "{surface.800}",
          borderColor: "{surface.700}",
          hoverBorderColor: "{surface.600}",
          focusBorderColor: "{primary.color}",
          invalidBorderColor: "{red.300}",
          color: "{surface.0}",
          disabledColor: "{surface.400}",
          placeholderColor: "{surface.400}",
          floatLabelColor: "{surface.400}",
          floatLabelFocusColor: "{surface.400}",
          floatLabelInvalidColor: "{red.300}",
          iconColor: "{surface.400}",
          shadow: "0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)"
        },
        text: {
          color: "{surface.0}",
          hoverColor: "{surface.0}",
          mutedColor: "{surface.400}",
          hoverMutedColor: "{surface.300}"
        },
        content: {
          background: "{surface.900}",
          hoverBackground: "{surface.800}",
          borderColor: "{surface.700}",
          color: "{text.color}",
          hoverColor: "{text.hover.color}"
        },
        overlay: {
          select: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          },
          popover: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          },
          modal: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          }
        },
        list: {
          option: {
            focusBackground: "{surface.800}",
            selectedBackground: "{highlight.background}",
            selectedFocusBackground: "{highlight.focus.background}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            selectedColor: "{highlight.color}",
            selectedFocusColor: "{highlight.focus.color}",
            icon: {
              color: "{surface.500}",
              focusColor: "{surface.400}"
            }
          },
          optionGroup: {
            background: "transparent",
            color: "{text.muted.color}"
          }
        },
        navigation: {
          item: {
            focusBackground: "{surface.800}",
            activeBackground: "{surface.800}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            activeColor: "{text.hover.color}",
            icon: {
              color: "{surface.500}",
              focusColor: "{surface.400}",
              activeColor: "{surface.400}"
            }
          },
          submenuLabel: {
            background: "transparent",
            color: "{text.muted.color}"
          },
          submenuIcon: {
            color: "{surface.500}",
            focusColor: "{surface.400}",
            activeColor: "{surface.400}"
          }
        }
      }
    }
  },
  components: {
    accordion: index$1l,
    autocomplete: index$1k,
    avatar: index$1j,
    badge: index$1i,
    blockui: index$1h,
    breadcrumb: index$1g,
    button: index$1f,
    datepicker: index$13,
    card: index$1e,
    carousel: index$1d,
    cascadeselect: index$1c,
    checkbox: index$1b,
    chip: index$1a,
    colorpicker: index$19,
    confirmdialog: index$18,
    confirmpopup: index$17,
    contextmenu: index$16,
    dataview: index$14,
    datatable: index$15,
    dialog: index$12,
    divider: index$11,
    dock: index$10,
    drawer: index$$,
    editor: index$_,
    fieldset: index$Z,
    fileupload: index$Y,
    floatlabel: index$X,
    galleria: index$W,
    iconfield: index$V,
    image: index$U,
    inlinemessage: index$T,
    inplace: index$S,
    inputchips: index$R,
    inputgroup: index$Q,
    inputnumber: index$P,
    inputtext: index$O,
    knob: index$N,
    listbox: index$M,
    megamenu: index$L,
    menu: index$K,
    menubar: index$J,
    message: index$I,
    metergroup: index$H,
    multiselect: index$G,
    orderlist: index$F,
    organizationchart: index$E,
    overlaybadge: index$D,
    popover: index$x,
    paginator: index$C,
    password: index$z,
    panel: index$B,
    panelmenu: index$A,
    picklist: index$y,
    progressbar: index$w,
    progressspinner: index$v,
    radiobutton: index$u,
    rating: index$t,
    scrollpanel: index$r,
    select: index$q,
    selectbutton: index$p,
    skeleton: index$o,
    slider: index$n,
    speeddial: index$m,
    splitter: index$k,
    splitbutton: index$l,
    stepper: index$j,
    steps: index$i,
    tabmenu: index$h,
    tabs: index$g,
    tabview: index$f,
    textarea: index$c,
    tieredmenu: index$b,
    tag: index$e,
    terminal: index$d,
    timeline: index$a,
    togglebutton: index$8,
    toggleswitch: index$7,
    tree: index$4,
    treeselect: index$3,
    treetable: index$2,
    toast: index$9,
    toolbar: index$6
  },
  directives: {
    tooltip: index$5,
    ripple: index$s
  }
};
function ownKeys$2$2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$2$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2$2(Object(t), true).forEach(function(r2) {
      _defineProperty$3$2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$3$2(e, r, t) {
  return (r = _toPropertyKey$3$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$3$2(t) {
  var i2 = _toPrimitive$3$2(t, "string");
  return "symbol" == _typeof$3$2(i2) ? i2 : i2 + "";
}
function _toPrimitive$3$2(t, r) {
  if ("object" != _typeof$3$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$3$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toConsumableArray$2$1(r) {
  return _arrayWithoutHoles$2$1(r) || _iterableToArray$2$1(r) || _unsupportedIterableToArray$3$1(r) || _nonIterableSpread$2$1();
}
function _nonIterableSpread$2$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$3$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3$1(r, a) : void 0;
  }
}
function _iterableToArray$2$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$2$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$3$1(r);
}
function _arrayLikeToArray$3$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _typeof$3$2(o) {
  "@babel/helpers - typeof";
  return _typeof$3$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3$2(o);
}
var SharedUtils = {
  object: {
    isEmpty: function isEmpty2(value3) {
      return value3 === null || value3 === void 0 || value3 === "" || Array.isArray(value3) && value3.length === 0 || !(value3 instanceof Date) && _typeof$3$2(value3) === "object" && Object.keys(value3).length === 0;
    },
    isNotEmpty: function isNotEmpty2(value3) {
      return !this.isEmpty(value3);
    },
    isFunction: function isFunction2(value3) {
      return !!(value3 && value3.constructor && value3.call && value3.apply);
    },
    isObject: function isObject2(value3) {
      var empty3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return value3 instanceof Object && value3.constructor === Object && (empty3 || Object.keys(value3).length !== 0);
    },
    isArray: function isArray2(value3) {
      var empty3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return Array.isArray(value3) && (empty3 || value3.length !== 0);
    },
    isString: function isString2(value3) {
      var empty3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return typeof value3 === "string" && (empty3 || value3 !== "");
    },
    isNumber: function isNumber2(value3) {
      return !isNaN(value3);
    },
    toFlatCase: function toFlatCase2(str) {
      return this.isString(str) ? str.replace(/(-|_)/g, "").toLowerCase() : str;
    },
    toKebabCase: function toKebabCase2(str) {
      return this.isString(str) ? str.replace(/(_)/g, "-").replace(/[A-Z]/g, function(c, i2) {
        return i2 === 0 ? c : "-" + c.toLowerCase();
      }).toLowerCase() : str;
    },
    toTokenKey: function toTokenKey2(str) {
      return this.isString(str) ? str.replace(/[A-Z]/g, function(c, i2) {
        return i2 === 0 ? c : "." + c.toLowerCase();
      }).toLowerCase() : str;
    },
    merge: function merge2(value1, value22) {
      if (this.isArray(value1)) {
        value1.push.apply(value1, _toConsumableArray$2$1(value22 || []));
      } else if (this.isObject(value1)) {
        Object.assign(value1, value22);
      }
    },
    mergeKeysByRegex: function mergeKeysByRegex() {
      var _this = this;
      var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var regex = arguments.length > 2 ? arguments[2] : void 0;
      var mergedObj = _objectSpread$2$2({}, target);
      Object.keys(source).forEach(function(key) {
        if (_this.test(regex, key)) {
          if (_this.isObject(source[key]) && key in target && _this.isObject(target[key])) {
            mergedObj[key] = _this.mergeKeysByRegex(target[key], source[key], regex);
          } else {
            mergedObj[key] = source[key];
          }
        } else {
          mergedObj[key] = source[key];
        }
      });
      return mergedObj;
    },
    mergeKeys: function mergeKeys2() {
      var _this2 = this;
      var _mergeKeys = function _mergeKeys2() {
        var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var mergedObj = _objectSpread$2$2({}, target);
        Object.keys(source).forEach(function(key) {
          if (_this2.isObject(source[key]) && key in target && _this2.isObject(target[key])) {
            mergedObj[key] = _mergeKeys2(target[key], source[key]);
          } else {
            mergedObj[key] = source[key];
          }
        });
        return mergedObj;
      };
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return args.reduce(function(acc, obj, i2) {
        return i2 === 0 ? obj : _mergeKeys(acc, obj);
      }, {});
    },
    getItemValue: function getItemValue(obj) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      return this.isFunction(obj) ? obj.apply(void 0, params) : obj;
    },
    getOptionValue: function getOptionValue(options3) {
      var _this3 = this;
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var fKeys = this.toFlatCase(key).split(".");
      var fKey = fKeys.shift();
      return fKey ? this.isObject(options3) ? this.getOptionValue(this.getItemValue(options3[Object.keys(options3).find(function(k) {
        return _this3.toFlatCase(k) === fKey;
      }) || ""], params), fKeys.join("."), params) : void 0 : this.getItemValue(options3, params);
    },
    test: function test(regex, str) {
      if (regex) {
        var match = regex.test(str);
        regex.lastIndex = 0;
        return match;
      }
      return false;
    },
    toValue: function toValue2(value3) {
      return this.isObject(value3) && value3.hasOwnProperty("value") && value3.hasOwnProperty("type") ? value3.value : value3;
    },
    toUnit: function toUnit2(value3) {
      var _this4 = this;
      var variable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var excludedProperties = ["opacity", "z-index", "line-height", "font-weight", "flex", "flex-grow", "flex-shrink", "order"];
      if (!excludedProperties.some(function(property) {
        return variable.endsWith(property);
      })) {
        var val = "".concat(value3).trim();
        var valArr = val.split(" ");
        return valArr.map(function(v2) {
          return _this4.isNumber(v2) ? "".concat(v2, "px") : v2;
        }).join(" ");
      }
      return value3;
    },
    toNormalizePrefix: function toNormalizePrefix2(prefix2) {
      return prefix2.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
    },
    toNormalizeVariable: function toNormalizeVariable2() {
      var prefix2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var variable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return this.toNormalizePrefix("".concat(this.isString(prefix2, false) && this.isString(variable, false) ? "".concat(prefix2, "-") : prefix2).concat(variable));
    },
    getVariableName: function getVariableName2() {
      var prefix2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var variable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return "--".concat(this.toNormalizeVariable(prefix2, variable));
    },
    getVariableValue: function getVariableValue2(value3) {
      var _this5 = this;
      var variable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var prefix2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      var excludedKeyRegexes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var fallback = arguments.length > 4 ? arguments[4] : void 0;
      if (this.isString(value3)) {
        var regex = /{([^}]*)}/g;
        var val = value3.trim();
        if (this.test(regex, val)) {
          var _val = val.replaceAll(regex, function(v2) {
            var path = v2.replace(/{|}/g, "");
            var keys = path.split(".").filter(function(_v) {
              return !excludedKeyRegexes.some(function(_r) {
                return _this5.test(_r, _v);
              });
            });
            return "var(".concat(_this5.getVariableName(prefix2, _this5.toKebabCase(keys.join("-")))).concat(_this5.isNotEmpty(fallback) ? ", ".concat(fallback) : "", ")");
          });
          var calculationRegex = /(\d+\s+[\+\-\*\/]\s+\d+)/g;
          var cleanedVarRegex = /var\([^)]+\)/g;
          return this.test(calculationRegex, _val.replace(cleanedVarRegex, "0")) ? "calc(".concat(_val, ")") : _val;
        }
        return this.toUnit(val, variable);
      } else if (this.isNumber(value3)) {
        return this.toUnit(value3, variable);
      }
      return void 0;
    },
    getComputedValue: function getComputedValue2() {
      var _this6 = this;
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var value3 = arguments.length > 1 ? arguments[1] : void 0;
      if (this.isString(value3)) {
        var regex = /{([^}]*)}/g;
        var val = value3.trim();
        return this.test(regex, val) ? val.replaceAll(regex, function(v2) {
          return _this6.getOptionValue(obj, v2.replace(/{|}/g, ""));
        }) : val;
      } else if (this.isNumber(value3)) {
        return value3;
      }
      return void 0;
    },
    setProperty: function setProperty2(properties, key, value3) {
      if (this.isString(key, false)) {
        properties.push("".concat(key, ":").concat(value3, ";"));
      }
    },
    getRule: function getRule2(selector, properties) {
      if (selector) {
        return "".concat(selector, "{").concat(properties, "}");
      }
      return "";
    },
    minifyCSS: function minifyCSS2(css4) {
      return css4 ? css4.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":") : css4;
    }
  },
  dom: {
    isClient: function isClient2() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    },
    addClass: function addClass2(element, className) {
      if (element && className && !this.hasClass(element, className)) {
        if (element.classList) element.classList.add(className);
        else element.className += " " + className;
      }
    },
    removeClass: function removeClass2(element, className) {
      if (element && className) {
        if (element.classList) element.classList.remove(className);
        else element.className = element.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
      }
    },
    hasClass: function hasClass2(element, className) {
      if (element) {
        if (element.classList) return element.classList.contains(className);
        else return new RegExp("(^| )" + className + "( |$)", "gi").test(element.className);
      }
      return false;
    },
    removeMultipleClasses: function removeMultipleClasses(element, classNames) {
      var _this7 = this;
      if (element && classNames) {
        [classNames].flat().filter(Boolean).forEach(function(cNames) {
          return cNames.split(" ").forEach(function(className) {
            return _this7.removeClass(element, className);
          });
        });
      }
    }
  }
};
function normalizeColor(color) {
  if (color.length === 4) {
    color = "#".concat(color[1]).concat(color[1]).concat(color[2]).concat(color[2]).concat(color[3]).concat(color[3]);
  }
  return color;
}
function hexToRgb$1(hex) {
  var bigint = parseInt(hex.substring(1), 16);
  var r = bigint >> 16 & 255;
  var g = bigint >> 8 & 255;
  var b = bigint & 255;
  return {
    r,
    g,
    b
  };
}
function rgbToHex$1(r, g, b) {
  return "#".concat(r.toString(16).padStart(2, "0")).concat(g.toString(16).padStart(2, "0")).concat(b.toString(16).padStart(2, "0"));
}
var mix = function(color1, color2, weight) {
  color1 = normalizeColor(color1);
  color2 = normalizeColor(color2);
  var p2 = weight / 100;
  var w2 = p2 * 2 - 1;
  var w1 = (w2 + 1) / 2;
  var w22 = 1 - w1;
  var rgb1 = hexToRgb$1(color1);
  var rgb2 = hexToRgb$1(color2);
  var r = Math.round(rgb1.r * w1 + rgb2.r * w22);
  var g = Math.round(rgb1.g * w1 + rgb2.g * w22);
  var b = Math.round(rgb1.b * w1 + rgb2.b * w22);
  return rgbToHex$1(r, g, b);
};
var shade = function(color, percent) {
  return mix("#000000", color, percent);
};
var tint = function(color, percent) {
  return mix("#ffffff", color, percent);
};
var scales = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
var palette = function(color) {
  if (/{([^}]*)}/g.test(color)) {
    var token = color.replace(/{|}/g, "");
    return scales.reduce(function(acc, scale) {
      return acc[scale] = "{".concat(token, ".").concat(scale, "}"), acc;
    }, {});
  }
  return typeof color === "string" ? scales.reduce(function(acc, scale, i2) {
    return acc[scale] = i2 <= 5 ? tint(color, (5 - i2) * 19) : shade(color, (i2 - 5) * 15), acc;
  }, {}) : color;
};
function createService() {
  var allHandlers = /* @__PURE__ */ new Map();
  return {
    on: function on(type, handler8) {
      var handlers = allHandlers.get(type);
      if (!handlers) handlers = [handler8];
      else handlers.push(handler8);
      allHandlers.set(type, handlers);
      return this;
    },
    off: function off(type, handler8) {
      var handlers = allHandlers.get(type);
      if (handlers) {
        handlers.splice(handlers.indexOf(handler8) >>> 0, 1);
      }
      return this;
    },
    emit: function emit2(type, evt) {
      var handlers = allHandlers.get(type);
      if (handlers) {
        handlers.slice().map(function(handler8) {
          handler8(evt);
        });
      }
    }
  };
}
var ThemeService = createService();
function _typeof$2$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2$2(o);
}
function _toConsumableArray$1$1(r) {
  return _arrayWithoutHoles$1$1(r) || _iterableToArray$1$1(r) || _unsupportedIterableToArray$2$2(r) || _nonIterableSpread$1$1();
}
function _nonIterableSpread$1$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2$2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$2$2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2$2(r, a) : void 0;
  }
}
function _iterableToArray$1$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$1$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$2$2(r);
}
function _arrayLikeToArray$2$2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function ownKeys$1$3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1$3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1$3(Object(t), true).forEach(function(r2) {
      _defineProperty$2$2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$2$2(e, r, t) {
  return (r = _toPropertyKey$2$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$2$2(t) {
  var i2 = _toPrimitive$2$2(t, "string");
  return "symbol" == _typeof$2$2(i2) ? i2 : i2 + "";
}
function _toPrimitive$2$2(t, r) {
  if ("object" != _typeof$2$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$2$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var Theme = {
  defaults: {
    variable: {
      prefix: "p",
      selector: ":root",
      excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states)$/gi
    },
    options: {
      prefix: "p",
      darkModeSelector: "system",
      cssLayer: false
    }
  },
  _theme: void 0,
  _layerNames: /* @__PURE__ */ new Set(),
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  _loadingStyles: /* @__PURE__ */ new Set(),
  _tokens: {},
  update: function update() {
    var newValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var theme36 = newValues.theme;
    if (theme36) {
      this._theme = _objectSpread$1$3(_objectSpread$1$3({}, theme36), {}, {
        options: _objectSpread$1$3(_objectSpread$1$3({}, this.defaults.options), theme36.options)
      });
      this._tokens = ThemeUtils.createTokens(this.preset, this.defaults);
      this.clearLoadedStyleNames();
    }
  },
  get theme() {
    return this._theme;
  },
  get preset() {
    var _this$theme;
    return ((_this$theme = this.theme) === null || _this$theme === void 0 ? void 0 : _this$theme.preset) || {};
  },
  get options() {
    var _this$theme2;
    return ((_this$theme2 = this.theme) === null || _this$theme2 === void 0 ? void 0 : _this$theme2.options) || {};
  },
  get tokens() {
    return this._tokens;
  },
  getTheme: function getTheme() {
    return this.theme;
  },
  setTheme: function setTheme(newValue) {
    this.update({
      theme: newValue
    });
    ThemeService.emit("theme:change", newValue);
  },
  getPreset: function getPreset() {
    return this.preset;
  },
  setPreset: function setPreset(newValue) {
    this._theme = _objectSpread$1$3(_objectSpread$1$3({}, this.theme), {}, {
      preset: newValue
    });
    this._tokens = ThemeUtils.createTokens(newValue, this.defaults);
    this.clearLoadedStyleNames();
    ThemeService.emit("preset:change", newValue);
    ThemeService.emit("theme:change", this.theme);
  },
  getOptions: function getOptions() {
    return this.options;
  },
  setOptions: function setOptions(newValue) {
    this._theme = _objectSpread$1$3(_objectSpread$1$3({}, this.theme), {}, {
      options: newValue
    });
    this.clearLoadedStyleNames();
    ThemeService.emit("options:change", newValue);
    ThemeService.emit("theme:change", this.theme);
  },
  getLayerNames: function getLayerNames() {
    return _toConsumableArray$1$1(this._layerNames);
  },
  setLayerNames: function setLayerNames(layerName) {
    this._layerNames.add(layerName);
  },
  getLoadedStyleNames: function getLoadedStyleNames() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded: function isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  },
  setLoadedStyleName: function setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  },
  deleteLoadedStyleName: function deleteLoadedStyleName(name) {
    this._loadedStyleNames["delete"](name);
  },
  clearLoadedStyleNames: function clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  },
  getTokenValue: function getTokenValue(tokenPath) {
    return ThemeUtils.getTokenValue(this.tokens, tokenPath, this.defaults);
  },
  getCommon: function getCommon() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var params = arguments.length > 1 ? arguments[1] : void 0;
    return ThemeUtils.getCommon({
      name,
      theme: this.theme,
      params,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    });
  },
  getComponent: function getComponent() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var params = arguments.length > 1 ? arguments[1] : void 0;
    var options3 = {
      name,
      theme: this.theme,
      params,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    };
    return ThemeUtils.getPresetC(options3);
  },
  getDirective: function getDirective() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var params = arguments.length > 1 ? arguments[1] : void 0;
    var options3 = {
      name,
      theme: this.theme,
      params,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    };
    return ThemeUtils.getPresetD(options3);
  },
  getCustomPreset: function getCustomPreset() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var preset = arguments.length > 1 ? arguments[1] : void 0;
    var selector = arguments.length > 2 ? arguments[2] : void 0;
    var params = arguments.length > 3 ? arguments[3] : void 0;
    var options3 = {
      name,
      preset,
      options: this.options,
      selector,
      params,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    };
    return ThemeUtils.getPreset(options3);
  },
  getLayerOrderCSS: function getLayerOrderCSS() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return ThemeUtils.getLayerOrder(name, this.options, {
      names: this.getLayerNames()
    }, this.defaults);
  },
  transformCSS: function transformCSS() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var css4 = arguments.length > 1 ? arguments[1] : void 0;
    var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "style";
    var mode2 = arguments.length > 3 ? arguments[3] : void 0;
    return ThemeUtils.transformCSS(name, css4, mode2, type, this.options, {
      layerNames: this.setLayerNames.bind(this)
    }, this.defaults);
  },
  getCommonStyleSheet: function getCommonStyleSheet() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var params = arguments.length > 1 ? arguments[1] : void 0;
    var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ThemeUtils.getCommonStyleSheet({
      name,
      theme: this.theme,
      params,
      props,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    });
  },
  getStyleSheet: function getStyleSheet2(name, params) {
    var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ThemeUtils.getStyleSheet({
      name,
      theme: this.theme,
      params,
      props,
      defaults: this.defaults,
      set: {
        layerNames: this.setLayerNames.bind(this)
      }
    });
  },
  onStyleMounted: function onStyleMounted(name) {
    this._loadingStyles.add(name);
  },
  onStyleUpdated: function onStyleUpdated(name) {
    this._loadingStyles.add(name);
  },
  onStyleLoaded: function onStyleLoaded(event2, _ref) {
    var name = _ref.name;
    if (this._loadingStyles.size) {
      this._loadingStyles["delete"](name);
      ThemeService.emit("theme:".concat(name, ":load"), event2);
      !this._loadingStyles.size && ThemeService.emit("theme:load");
    }
  }
};
var $dt = function $dt2(tokenPath) {
  var _variable$match;
  var theme36 = Theme.getTheme();
  var variable = dtwt(theme36, tokenPath, void 0, "variable");
  var name = (_variable$match = variable.match(/--[\w-]+/g)) === null || _variable$match === void 0 ? void 0 : _variable$match[0];
  var value3 = dtwt(theme36, tokenPath, void 0, "value");
  return {
    name,
    variable,
    value: value3
  };
};
var dt = function dt2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return dtwt.apply(void 0, [Theme.getTheme()].concat(args));
};
var dtwt = function dtwt2() {
  var theme36 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var tokenPath = arguments.length > 1 ? arguments[1] : void 0;
  var fallback = arguments.length > 2 ? arguments[2] : void 0;
  var type = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "variable";
  if (tokenPath) {
    var _ref = Theme.defaults || {}, VARIABLE = _ref.variable, OPTIONS = _ref.options;
    var _ref2 = (theme36 === null || theme36 === void 0 ? void 0 : theme36.options) || OPTIONS || {}, prefix2 = _ref2.prefix, transform2 = _ref2.transform;
    var regex = /{([^}]*)}/g;
    var token = SharedUtils.object.test(regex, tokenPath) ? tokenPath : "{".concat(tokenPath, "}");
    var isStrictTransform = type === "value" || transform2 === "strict";
    return isStrictTransform ? Theme.getTokenValue(tokenPath) : SharedUtils.object.getVariableValue(token, void 0, prefix2, [VARIABLE.excludedKeyRegex], fallback);
  }
  return "";
};
var css$1 = function css3(style) {
  return SharedUtils.object.getItemValue(style, {
    dt
  });
};
function _typeof$1$5(o) {
  "@babel/helpers - typeof";
  return _typeof$1$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$5(o);
}
function ownKeys$o(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$o(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$o(Object(t), true).forEach(function(r2) {
      _defineProperty$1$3(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$1$3(e, r, t) {
  return (r = _toPropertyKey$1$4(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$1$4(t) {
  var i2 = _toPrimitive$1$4(t, "string");
  return "symbol" == _typeof$1$5(i2) ? i2 : i2 + "";
}
function _toPrimitive$1$4(t, r) {
  if ("object" != _typeof$1$5(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1$5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var $t = function $t2() {
  var theme36 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _preset = theme36.preset, _options2 = theme36.options;
  return {
    preset: function preset(value3) {
      _preset = _preset ? SharedUtils.object.mergeKeys(_preset, value3) : value3;
      return this;
    },
    options: function options3(value3) {
      _options2 = _options2 ? _objectSpread$o(_objectSpread$o({}, _options2), value3) : value3;
      return this;
    },
    // features
    primaryPalette: function primaryPalette(primary) {
      var _ref = _preset || {}, semantic = _ref.semantic;
      _preset = _objectSpread$o(_objectSpread$o({}, _preset), {}, {
        semantic: _objectSpread$o(_objectSpread$o({}, semantic), {}, {
          primary
        })
      });
      return this;
    },
    surfacePalette: function surfacePalette(surface) {
      var _semantic$colorScheme, _semantic$colorScheme2;
      var _ref2 = _preset || {}, semantic = _ref2.semantic;
      var lightSurface = surface !== null && surface !== void 0 && surface.hasOwnProperty("light") ? surface === null || surface === void 0 ? void 0 : surface.light : surface;
      var darkSurface = surface !== null && surface !== void 0 && surface.hasOwnProperty("dark") ? surface === null || surface === void 0 ? void 0 : surface.dark : surface;
      var newColorScheme = {
        colorScheme: {
          light: _objectSpread$o(_objectSpread$o({}, semantic === null || semantic === void 0 || (_semantic$colorScheme = semantic.colorScheme) === null || _semantic$colorScheme === void 0 ? void 0 : _semantic$colorScheme.light), !!lightSurface && {
            surface: lightSurface
          }),
          dark: _objectSpread$o(_objectSpread$o({}, semantic === null || semantic === void 0 || (_semantic$colorScheme2 = semantic.colorScheme) === null || _semantic$colorScheme2 === void 0 ? void 0 : _semantic$colorScheme2.dark), !!darkSurface && {
            surface: darkSurface
          })
        }
      };
      _preset = _objectSpread$o(_objectSpread$o({}, _preset), {}, {
        semantic: _objectSpread$o(_objectSpread$o({}, semantic), newColorScheme)
      });
      return this;
    },
    // actions
    define: function define() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$useDefaultPrese = _ref3.useDefaultPreset, useDefaultPreset = _ref3$useDefaultPrese === void 0 ? false : _ref3$useDefaultPrese, _ref3$useDefaultOptio = _ref3.useDefaultOptions, useDefaultOptions = _ref3$useDefaultOptio === void 0 ? false : _ref3$useDefaultOptio;
      return {
        preset: useDefaultPreset ? Theme.getPreset() : _preset,
        options: useDefaultOptions ? Theme.getOptions() : _options2
      };
    },
    update: function update2() {
      var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$mergePresets = _ref4.mergePresets, mergePresets = _ref4$mergePresets === void 0 ? true : _ref4$mergePresets, _ref4$mergeOptions = _ref4.mergeOptions, mergeOptions2 = _ref4$mergeOptions === void 0 ? true : _ref4$mergeOptions;
      var newTheme = {
        preset: mergePresets ? SharedUtils.object.mergeKeys(Theme.getPreset(), _preset) : _preset,
        options: mergeOptions2 ? _objectSpread$o(_objectSpread$o({}, Theme.getOptions()), _options2) : _options2
      };
      Theme.setTheme(newTheme);
      return newTheme;
    },
    use: function use(options3) {
      var newTheme = this.define(options3);
      Theme.setTheme(newTheme);
      return newTheme;
    }
  };
};
function _slicedToArray$1$1(r, e) {
  return _arrayWithHoles$1$1(r) || _iterableToArrayLimit$1$1(r, e) || _unsupportedIterableToArray$1$2(r, e) || _nonIterableRest$1$1();
}
function _nonIterableRest$1$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1$2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1$2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1$2(r, a) : void 0;
  }
}
function _arrayLikeToArray$1$2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit$1$1(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles$1$1(r) {
  if (Array.isArray(r)) return r;
}
function toVariables(theme36) {
  var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var VARIABLE = Theme.defaults.variable;
  var _options$prefix = options3.prefix, prefix2 = _options$prefix === void 0 ? VARIABLE.prefix : _options$prefix, _options$selector = options3.selector, selector = _options$selector === void 0 ? VARIABLE.selector : _options$selector, _options$excludedKeyR = options3.excludedKeyRegex, excludedKeyRegex = _options$excludedKeyR === void 0 ? VARIABLE.excludedKeyRegex : _options$excludedKeyR;
  var _toVariables2 = function _toVariables4(_theme) {
    var _prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return Object.entries(_theme).reduce(function(acc, _ref) {
      var _ref2 = _slicedToArray$1$1(_ref, 2), key = _ref2[0], value3 = _ref2[1];
      var px = SharedUtils.object.test(excludedKeyRegex, key) ? SharedUtils.object.toNormalizeVariable(_prefix) : SharedUtils.object.toNormalizeVariable(_prefix, SharedUtils.object.toKebabCase(key));
      var v2 = SharedUtils.object.toValue(value3);
      if (SharedUtils.object.isObject(v2)) {
        var _toVariables22 = _toVariables4(v2, px), _variables = _toVariables22.variables, _tokens = _toVariables22.tokens;
        SharedUtils.object.merge(acc["tokens"], _tokens);
        SharedUtils.object.merge(acc["variables"], _variables);
      } else {
        acc["tokens"].push((prefix2 ? px.replace("".concat(prefix2, "-"), "") : px).replaceAll("-", "."));
        SharedUtils.object.setProperty(acc["variables"], SharedUtils.object.getVariableName(px), SharedUtils.object.getVariableValue(v2, px, prefix2, [excludedKeyRegex]));
      }
      return acc;
    }, {
      variables: [],
      tokens: []
    });
  };
  var _toVariables3 = _toVariables2(theme36, prefix2), variables = _toVariables3.variables, tokens = _toVariables3.tokens;
  return {
    value: variables,
    tokens,
    declarations: variables.join(""),
    css: SharedUtils.object.getRule(selector, variables.join(""))
  };
}
function _typeof$s(o) {
  "@babel/helpers - typeof";
  return _typeof$s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$s(o);
}
var _excluded$1 = ["colorScheme"], _excluded2 = ["dark"], _excluded3 = ["colorScheme"], _excluded4 = ["dark"], _excluded5 = ["colorScheme"];
function _slicedToArray$6(r, e) {
  return _arrayWithHoles$6(r) || _iterableToArrayLimit$6(r, e) || _unsupportedIterableToArray$l(r, e) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$6(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles$6(r) {
  if (Array.isArray(r)) return r;
}
function _defineProperty$r(e, r, t) {
  return (r = _toPropertyKey$q(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$q(t) {
  var i2 = _toPrimitive$q(t, "string");
  return "symbol" == _typeof$s(i2) ? i2 : i2 + "";
}
function _toPrimitive$q(t, r) {
  if ("object" != _typeof$s(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$s(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toConsumableArray$g(r) {
  return _arrayWithoutHoles$g(r) || _iterableToArray$h(r) || _unsupportedIterableToArray$l(r) || _nonIterableSpread$g();
}
function _nonIterableSpread$g() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$l(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$l(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$l(r, a) : void 0;
  }
}
function _iterableToArray$h(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$g(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$l(r);
}
function _arrayLikeToArray$l(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _objectWithoutProperties$1(e, t) {
  if (null == e) return {};
  var o, r, i2 = _objectWithoutPropertiesLoose$1(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i2[o] = e[o]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose$1(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) >= 0) continue;
    t[n] = r[n];
  }
  return t;
}
var ThemeUtils = {
  regex: {
    rules: {
      "class": {
        pattern: /^\.([a-zA-Z][\w-]*)$/,
        resolve: function resolve2(value3) {
          return {
            type: "class",
            selector: value3,
            matched: this.pattern.test(value3.trim())
          };
        }
      },
      attr: {
        pattern: /^\[(.*)\]$/,
        resolve: function resolve3(value3) {
          return {
            type: "attr",
            selector: ":root".concat(value3),
            matched: this.pattern.test(value3.trim())
          };
        }
      },
      media: {
        pattern: /^@media (.*)$/,
        resolve: function resolve4(value3) {
          return {
            type: "media",
            selector: "".concat(value3, "{:root{[CSS]}}"),
            matched: this.pattern.test(value3.trim())
          };
        }
      },
      system: {
        pattern: /^system$/,
        resolve: function resolve5(value3) {
          return {
            type: "system",
            selector: "@media (prefers-color-scheme: dark){:root{[CSS]}}",
            matched: this.pattern.test(value3.trim())
          };
        }
      },
      custom: {
        resolve: function resolve6(value3) {
          return {
            type: "custom",
            selector: value3,
            matched: true
          };
        }
      }
    },
    resolve: function resolve7(value3) {
      var _this = this;
      var rules = Object.keys(this.rules).filter(function(k) {
        return k !== "custom";
      }).map(function(r) {
        return _this.rules[r];
      });
      return [value3].flat().map(function(v2) {
        var _rules$map$find;
        return (_rules$map$find = rules.map(function(r) {
          return r.resolve(v2);
        }).find(function(rr) {
          return rr.matched;
        })) !== null && _rules$map$find !== void 0 ? _rules$map$find : _this.rules.custom.resolve(v2);
      });
    }
  },
  _toVariables: function _toVariables(theme36, options3) {
    return toVariables(theme36, {
      prefix: options3 === null || options3 === void 0 ? void 0 : options3.prefix
    });
  },
  getCommon: function getCommon2(_ref) {
    var _ref$name = _ref.name, name = _ref$name === void 0 ? "" : _ref$name, _ref$theme = _ref.theme, theme36 = _ref$theme === void 0 ? {} : _ref$theme;
    _ref.params;
    var set2 = _ref.set, defaults = _ref.defaults;
    var preset = theme36.preset, options3 = theme36.options;
    var primitive_css, primitive_tokens, semantic_css, semantic_tokens;
    if (SharedUtils.object.isNotEmpty(preset)) {
      var _prim_var$declaration, _sRest_var$declaratio, _csRest_var$declarati, _dark_var$declaration;
      var primitive = preset.primitive, semantic = preset.semantic;
      var _ref2 = semantic || {}, colorScheme = _ref2.colorScheme, sRest = _objectWithoutProperties$1(_ref2, _excluded$1);
      var _ref3 = colorScheme || {}, dark = _ref3.dark, csRest = _objectWithoutProperties$1(_ref3, _excluded2);
      var prim_var = SharedUtils.object.isNotEmpty(primitive) ? this._toVariables({
        primitive
      }, options3) : {};
      var sRest_var = SharedUtils.object.isNotEmpty(sRest) ? this._toVariables({
        semantic: sRest
      }, options3) : {};
      var csRest_var = SharedUtils.object.isNotEmpty(csRest) ? this._toVariables({
        light: csRest
      }, options3) : {};
      var dark_var = SharedUtils.object.isNotEmpty(dark) ? this._toVariables({
        dark
      }, options3) : {};
      var _ref4 = [(_prim_var$declaration = prim_var.declarations) !== null && _prim_var$declaration !== void 0 ? _prim_var$declaration : "", prim_var.tokens], prim_css = _ref4[0], prim_tokens = _ref4[1];
      var sRest_css = (_sRest_var$declaratio = sRest_var.declarations) !== null && _sRest_var$declaratio !== void 0 ? _sRest_var$declaratio : "", sRest_tokens = sRest_var.tokens || [];
      var csRest_css = (_csRest_var$declarati = csRest_var.declarations) !== null && _csRest_var$declarati !== void 0 ? _csRest_var$declarati : "", csRest_tokens = csRest_var.tokens || [];
      var dark_css = (_dark_var$declaration = dark_var.declarations) !== null && _dark_var$declaration !== void 0 ? _dark_var$declaration : "", dark_tokens = dark_var.tokens || [];
      primitive_css = this.transformCSS(name, prim_css, "light", "variable", options3, set2, defaults);
      primitive_tokens = prim_tokens;
      var semantic_light_css = this.transformCSS(name, "".concat(sRest_css).concat(csRest_css, "color-scheme:light"), "light", "variable", options3, set2, defaults);
      var semantic_dark_css = this.transformCSS(name, "".concat(dark_css, "color-scheme:dark"), "dark", "variable", options3, set2, defaults);
      semantic_css = "".concat(semantic_light_css).concat(semantic_dark_css);
      semantic_tokens = _toConsumableArray$g(new Set([].concat(_toConsumableArray$g(sRest_tokens), _toConsumableArray$g(csRest_tokens), _toConsumableArray$g(dark_tokens))));
    }
    return {
      primitive: {
        css: primitive_css,
        tokens: primitive_tokens
      },
      semantic: {
        css: semantic_css,
        tokens: semantic_tokens
      }
    };
  },
  getPreset: function getPreset2(_ref5) {
    var _vRest_var$declaratio, _csRest_var$declarati2, _dark_var$declaration2;
    var _ref5$name = _ref5.name, name = _ref5$name === void 0 ? "" : _ref5$name, _ref5$preset = _ref5.preset, preset = _ref5$preset === void 0 ? {} : _ref5$preset, options3 = _ref5.options;
    _ref5.params;
    var set2 = _ref5.set, defaults = _ref5.defaults, selector = _ref5.selector;
    var _name2 = name.replace("-directive", "");
    var colorScheme = preset.colorScheme, vRest = _objectWithoutProperties$1(preset, _excluded3);
    var _ref6 = colorScheme || {}, dark = _ref6.dark, csRest = _objectWithoutProperties$1(_ref6, _excluded4);
    var vRest_var = SharedUtils.object.isNotEmpty(vRest) ? this._toVariables(_defineProperty$r({}, _name2, vRest), options3) : {};
    var csRest_var = SharedUtils.object.isNotEmpty(csRest) ? this._toVariables(_defineProperty$r({}, _name2, csRest), options3) : {};
    var dark_var = SharedUtils.object.isNotEmpty(dark) ? this._toVariables(_defineProperty$r({}, _name2, dark), options3) : {};
    var vRest_css = (_vRest_var$declaratio = vRest_var.declarations) !== null && _vRest_var$declaratio !== void 0 ? _vRest_var$declaratio : "", vRest_tokens = vRest_var.tokens || [];
    var csRest_css = (_csRest_var$declarati2 = csRest_var.declarations) !== null && _csRest_var$declarati2 !== void 0 ? _csRest_var$declarati2 : "", csRest_tokens = csRest_var.tokens || [];
    var dark_css = (_dark_var$declaration2 = dark_var.declarations) !== null && _dark_var$declaration2 !== void 0 ? _dark_var$declaration2 : "", dark_tokens = dark_var.tokens || [];
    var tokens = _toConsumableArray$g(new Set([].concat(_toConsumableArray$g(vRest_tokens), _toConsumableArray$g(csRest_tokens), _toConsumableArray$g(dark_tokens))));
    var light_variable_css = this.transformCSS(_name2, "".concat(vRest_css).concat(csRest_css), "light", "variable", options3, set2, defaults, selector);
    var dark_variable_css = this.transformCSS(_name2, dark_css, "dark", "variable", options3, set2, defaults, selector);
    return {
      css: "".concat(light_variable_css).concat(dark_variable_css),
      tokens
    };
  },
  getPresetC: function getPresetC(_ref7) {
    var _preset$components;
    var _ref7$name = _ref7.name, name = _ref7$name === void 0 ? "" : _ref7$name, _ref7$theme = _ref7.theme, theme36 = _ref7$theme === void 0 ? {} : _ref7$theme, params = _ref7.params, set2 = _ref7.set, defaults = _ref7.defaults;
    var preset = theme36.preset, options3 = theme36.options;
    var cPreset = preset === null || preset === void 0 || (_preset$components = preset.components) === null || _preset$components === void 0 ? void 0 : _preset$components[name];
    return this.getPreset({
      name,
      preset: cPreset,
      options: options3,
      params,
      set: set2,
      defaults
    });
  },
  getPresetD: function getPresetD(_ref8) {
    var _preset$directives;
    var _ref8$name = _ref8.name, name = _ref8$name === void 0 ? "" : _ref8$name, _ref8$theme = _ref8.theme, theme36 = _ref8$theme === void 0 ? {} : _ref8$theme, params = _ref8.params, set2 = _ref8.set, defaults = _ref8.defaults;
    var dName = name.replace("-directive", "");
    var preset = theme36.preset, options3 = theme36.options;
    var dPreset = preset === null || preset === void 0 || (_preset$directives = preset.directives) === null || _preset$directives === void 0 ? void 0 : _preset$directives[dName];
    return this.getPreset({
      name: dName,
      preset: dPreset,
      options: options3,
      params,
      set: set2,
      defaults
    });
  },
  getColorSchemeOption: function getColorSchemeOption(options3, defaults) {
    var _options$darkModeSele;
    return this.regex.resolve((_options$darkModeSele = options3.darkModeSelector) !== null && _options$darkModeSele !== void 0 ? _options$darkModeSele : defaults.options.darkModeSelector);
  },
  getLayerOrder: function getLayerOrder(name) {
    var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var params = arguments.length > 2 ? arguments[2] : void 0;
    var cssLayer = options3.cssLayer;
    if (cssLayer) {
      var order = SharedUtils.object.getItemValue(cssLayer.order || "primeui", params);
      return "@layer ".concat(order);
    }
    return "";
  },
  getCommonStyleSheet: function getCommonStyleSheet2(_ref9) {
    var _ref9$name = _ref9.name, name = _ref9$name === void 0 ? "" : _ref9$name, _ref9$theme = _ref9.theme, theme36 = _ref9$theme === void 0 ? {} : _ref9$theme, params = _ref9.params, _ref9$props = _ref9.props, props = _ref9$props === void 0 ? {} : _ref9$props, set2 = _ref9.set, defaults = _ref9.defaults;
    var common = this.getCommon({
      name,
      theme: theme36,
      params,
      set: set2,
      defaults
    });
    var _props = Object.entries(props).reduce(function(acc, _ref10) {
      var _ref11 = _slicedToArray$6(_ref10, 2), k = _ref11[0], v2 = _ref11[1];
      return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
    }, []).join(" ");
    return Object.entries(common || {}).reduce(function(acc, _ref12) {
      var _ref13 = _slicedToArray$6(_ref12, 2), key = _ref13[0], value3 = _ref13[1];
      if (value3 !== null && value3 !== void 0 && value3.css) {
        var _css = SharedUtils.object.minifyCSS(value3 === null || value3 === void 0 ? void 0 : value3.css);
        var id2 = "".concat(key, "-variables");
        acc.push('<style type="text/css" data-primevue-style-id="'.concat(id2, '" ').concat(_props, ">").concat(_css, "</style>"));
      }
      return acc;
    }, []).join("");
  },
  getStyleSheet: function getStyleSheet3(_ref14) {
    var _ref15;
    var _ref14$name = _ref14.name, name = _ref14$name === void 0 ? "" : _ref14$name, _ref14$theme = _ref14.theme, theme36 = _ref14$theme === void 0 ? {} : _ref14$theme, params = _ref14.params, _ref14$props = _ref14.props, props = _ref14$props === void 0 ? {} : _ref14$props, set2 = _ref14.set, defaults = _ref14.defaults;
    var options3 = {
      name,
      theme: theme36,
      params,
      set: set2,
      defaults
    };
    var preset_css = (_ref15 = name.includes("-directive") ? this.getPresetD(options3) : this.getPresetC(options3)) === null || _ref15 === void 0 ? void 0 : _ref15.css;
    var _props = Object.entries(props).reduce(function(acc, _ref16) {
      var _ref17 = _slicedToArray$6(_ref16, 2), k = _ref17[0], v2 = _ref17[1];
      return acc.push("".concat(k, '="').concat(v2, '"')) && acc;
    }, []).join(" ");
    return preset_css ? '<style type="text/css" data-primevue-style-id="'.concat(name, '-variables" ').concat(_props, ">").concat(SharedUtils.object.minifyCSS(preset_css), "</style>") : "";
  },
  createTokens: function createTokens() {
    var _this2 = this;
    var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaults = arguments.length > 1 ? arguments[1] : void 0;
    var parentKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    var parentPath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
    var tokens = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    Object.entries(obj).forEach(function(_ref18) {
      var _ref19 = _slicedToArray$6(_ref18, 2), key = _ref19[0], value3 = _ref19[1];
      var currentKey = SharedUtils.object.test(defaults.variable.excludedKeyRegex, key) ? parentKey : parentKey ? "".concat(parentKey, ".").concat(SharedUtils.object.toTokenKey(key)) : SharedUtils.object.toTokenKey(key);
      var currentPath = parentPath ? "".concat(parentPath, ".").concat(key) : key;
      if (SharedUtils.object.isObject(value3)) {
        _this2.createTokens(value3, defaults, currentKey, currentPath, tokens);
      } else {
        tokens[currentKey] || (tokens[currentKey] = {
          paths: [],
          computed: function computed2(colorScheme) {
            var tokenPathMap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (colorScheme) {
              var path = this.paths.find(function(p2) {
                return p2.scheme === colorScheme;
              }) || this.paths.find(function(p2) {
                return p2.scheme === "none";
              });
              return path === null || path === void 0 ? void 0 : path.computed(colorScheme, tokenPathMap["binding"]);
            }
            return this.paths.map(function(p2) {
              return p2.computed(p2.scheme, tokenPathMap[p2.scheme]);
            });
          }
        });
        tokens[currentKey].paths.push({
          path: currentPath,
          value: value3,
          scheme: currentPath.includes("colorScheme.light") ? "light" : currentPath.includes("colorScheme.dark") ? "dark" : "none",
          computed: function computed2(colorScheme) {
            var _binding;
            var tokenPathMap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var regex = /{([^}]*)}/g;
            var computedValue = value3;
            tokenPathMap["name"] = this.path;
            tokenPathMap[_binding = "binding"] || (tokenPathMap[_binding] = {});
            if (SharedUtils.object.test(regex, value3)) {
              var val = value3.trim();
              var _val = val.replaceAll(regex, function(v2) {
                var _tokens$path;
                var path = v2.replace(/{|}/g, "");
                return (_tokens$path = tokens[path]) === null || _tokens$path === void 0 || (_tokens$path = _tokens$path.computed(colorScheme, tokenPathMap)) === null || _tokens$path === void 0 ? void 0 : _tokens$path.value;
              });
              var calculationRegex = /(\d+\w*\s+[\+\-\*\/]\s+\d+\w*)/g;
              var cleanedVarRegex = /var\([^)]+\)/g;
              computedValue = SharedUtils.object.test(calculationRegex, _val.replace(cleanedVarRegex, "0")) ? "calc(".concat(_val, ")") : _val;
            }
            SharedUtils.object.isEmpty(tokenPathMap["binding"]) && delete tokenPathMap["binding"];
            return {
              colorScheme,
              path: this.path,
              paths: tokenPathMap,
              value: computedValue.includes("undefined") ? void 0 : computedValue
            };
          }
        });
      }
    });
    return tokens;
  },
  getTokenValue: function getTokenValue2(tokens, path, defaults) {
    var _tokens$token;
    var normalizePath = function normalizePath2(str) {
      var strArr = str.split(".");
      return strArr.filter(function(s) {
        return !SharedUtils.object.test(defaults.variable.excludedKeyRegex, s.toLowerCase());
      }).join(".");
    };
    var token = normalizePath(path);
    var colorScheme = path.includes("colorScheme.light") ? "light" : path.includes("colorScheme.dark") ? "dark" : void 0;
    var computedValues = [(_tokens$token = tokens[token]) === null || _tokens$token === void 0 ? void 0 : _tokens$token.computed(colorScheme)].flat().filter(function(computed2) {
      return computed2;
    });
    return computedValues.length === 1 ? computedValues[0].value : computedValues.reduce(function() {
      var acc = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var computed2 = arguments.length > 1 ? arguments[1] : void 0;
      var cs = computed2.colorScheme, rest = _objectWithoutProperties$1(computed2, _excluded5);
      acc[cs] = rest;
      return acc;
    }, void 0);
  },
  transformCSS: function transformCSS2(name, css4, mode2, type) {
    var options3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    var set2 = arguments.length > 5 ? arguments[5] : void 0;
    var defaults = arguments.length > 6 ? arguments[6] : void 0;
    var selector = arguments.length > 7 ? arguments[7] : void 0;
    if (SharedUtils.object.isNotEmpty(css4)) {
      var cssLayer = options3.cssLayer;
      if (type !== "style") {
        var colorSchemeOption = this.getColorSchemeOption(options3, defaults);
        var _css = selector ? SharedUtils.object.getRule(selector, css4) : css4;
        css4 = mode2 === "dark" ? colorSchemeOption.reduce(function(acc, _ref20) {
          var _selector = _ref20.selector;
          if (SharedUtils.object.isNotEmpty(_selector)) {
            acc += _selector.includes("[CSS]") ? _selector.replace("[CSS]", _css) : SharedUtils.object.getRule(_selector, _css);
          }
          return acc;
        }, "") : SharedUtils.object.getRule(selector !== null && selector !== void 0 ? selector : ":root", css4);
      }
      if (cssLayer) {
        var layerOptions = {
          name: "primeui",
          order: "primeui"
        };
        SharedUtils.object.isObject(cssLayer) && (layerOptions.name = SharedUtils.object.getItemValue(cssLayer.name, {
          name,
          type
        }));
        if (SharedUtils.object.isNotEmpty(layerOptions.name)) {
          css4 = SharedUtils.object.getRule("@layer ".concat(layerOptions.name), css4);
          set2 === null || set2 === void 0 || set2.layerNames(layerOptions.name);
        }
      }
      return css4;
    }
    return "";
  }
};
var definePreset = function() {
  var _SharedUtils$object;
  return (_SharedUtils$object = SharedUtils.object).mergeKeys.apply(_SharedUtils$object, arguments);
};
var updatePreset = function() {
  var _SharedUtils$object;
  for (var _len = arguments.length, presets = new Array(_len), _key = 0; _key < _len; _key++) {
    presets[_key] = arguments[_key];
  }
  var newPreset = (_SharedUtils$object = SharedUtils.object).mergeKeys.apply(_SharedUtils$object, [Theme.getPreset()].concat(presets));
  Theme.setPreset(newPreset);
  return newPreset;
};
var updatePrimaryPalette = function(primary) {
  return $t().primaryPalette(primary).update().preset;
};
var updateSurfacePalette = function(surface) {
  return $t().surfacePalette(surface).update().preset;
};
var usePreset = function() {
  var _SharedUtils$object;
  var newPreset = (_SharedUtils$object = SharedUtils.object).mergeKeys.apply(_SharedUtils$object, arguments);
  Theme.setPreset(newPreset);
  return newPreset;
};
var useTheme = function(theme36) {
  return $t(theme36).update({
    mergePresets: false
  });
};
var ConfirmationEventBus = EventBus();
var PrimeVueConfirmSymbol = Symbol();
function useConfirm() {
  var PrimeVueConfirm = inject(PrimeVueConfirmSymbol);
  if (!PrimeVueConfirm) {
    throw new Error("No PrimeVue Confirmation provided!");
  }
  return PrimeVueConfirm;
}
var ConfirmationService = {
  install: function install3(app2) {
    var ConfirmationService2 = {
      require: function require2(options3) {
        ConfirmationEventBus.emit("confirm", options3);
      },
      close: function close4() {
        ConfirmationEventBus.emit("close");
      }
    };
    app2.config.globalProperties.$confirm = ConfirmationService2;
    app2.provide(PrimeVueConfirmSymbol, ConfirmationService2);
  }
};
var ToastEventBus = EventBus();
var PrimeVueToastSymbol = Symbol();
function useToast() {
  var PrimeVueToast = inject(PrimeVueToastSymbol);
  if (!PrimeVueToast) {
    throw new Error("No PrimeVue Toast provided!");
  }
  return PrimeVueToast;
}
var ToastService = {
  install: function install4(app2) {
    var ToastService2 = {
      add: function add3(message3) {
        ToastEventBus.emit("add", message3);
      },
      remove: function remove5(message3) {
        ToastEventBus.emit("remove", message3);
      },
      removeGroup: function removeGroup(group) {
        ToastEventBus.emit("remove-group", group);
      },
      removeAllGroups: function removeAllGroups() {
        ToastEventBus.emit("remove-all-groups");
      }
    };
    app2.config.globalProperties.$toast = ToastService2;
    app2.provide(PrimeVueToastSymbol, ToastService2);
  }
};
function handler() {
  let zIndexes = [];
  const generateZIndex = (key, autoZIndex, baseZIndex = 999) => {
    const lastZIndex = getLastZIndex(key, autoZIndex, baseZIndex);
    const newZIndex = lastZIndex.value + (lastZIndex.key === key ? 0 : baseZIndex) + 1;
    zIndexes.push({ key, value: newZIndex });
    return newZIndex;
  };
  const revertZIndex = (zIndex) => {
    zIndexes = zIndexes.filter((obj) => obj.value !== zIndex);
  };
  const getCurrentZIndex = (key, autoZIndex) => {
    return getLastZIndex(key, autoZIndex).value;
  };
  const getLastZIndex = (key, autoZIndex, baseZIndex = 0) => {
    return [...zIndexes].reverse().find((obj) => autoZIndex ? true : obj.key === key) || { key, value: baseZIndex };
  };
  const getZIndex = (element) => {
    return element ? parseInt(element.style.zIndex, 10) || 0 : 0;
  };
  return {
    get: getZIndex,
    set: (key, element, baseZIndex) => {
      if (element) {
        element.style.zIndex = String(generateZIndex(key, true, baseZIndex));
      }
    },
    clear: (element) => {
      if (element) {
        revertZIndex(getZIndex(element));
        element.style.zIndex = "";
      }
    },
    getCurrent: (key) => getCurrentZIndex(key, true)
  };
}
var ZIndex = handler();
var lastIds = {};
function uuid(prefix2 = "pui_id_") {
  if (!lastIds.hasOwnProperty(prefix2)) {
    lastIds[prefix2] = 0;
  }
  lastIds[prefix2]++;
  return `${prefix2}${lastIds[prefix2]}`;
}
function _typeof$1$4(o) {
  "@babel/helpers - typeof";
  return _typeof$1$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$4(o);
}
function _classCallCheck$1(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$1$3(o.key), o);
  }
}
function _createClass$1(e, r, t) {
  return r && _defineProperties$1(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
function _toPropertyKey$1$3(t) {
  var i2 = _toPrimitive$1$3(t, "string");
  return "symbol" == _typeof$1$4(i2) ? i2 : i2 + "";
}
function _toPrimitive$1$3(t, r) {
  if ("object" != _typeof$1$4(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r);
    if ("object" != _typeof$1$4(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var ConnectedOverlayScrollHandler = /* @__PURE__ */ function() {
  function ConnectedOverlayScrollHandler2(element) {
    var listener = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    };
    _classCallCheck$1(this, ConnectedOverlayScrollHandler2);
    this.element = element;
    this.listener = listener;
  }
  return _createClass$1(ConnectedOverlayScrollHandler2, [{
    key: "bindScrollListener",
    value: function bindScrollListener6() {
      this.scrollableParents = getScrollableParents(this.element);
      for (var i2 = 0; i2 < this.scrollableParents.length; i2++) {
        this.scrollableParents[i2].addEventListener("scroll", this.listener);
      }
    }
  }, {
    key: "unbindScrollListener",
    value: function unbindScrollListener6() {
      if (this.scrollableParents) {
        for (var i2 = 0; i2 < this.scrollableParents.length; i2++) {
          this.scrollableParents[i2].removeEventListener("scroll", this.listener);
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.unbindScrollListener();
      this.element = null;
      this.listener = null;
      this.scrollableParents = null;
    }
  }]);
}();
function _typeof$r(o) {
  "@babel/helpers - typeof";
  return _typeof$r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$r(o);
}
function _toConsumableArray$f(r) {
  return _arrayWithoutHoles$f(r) || _iterableToArray$g(r) || _unsupportedIterableToArray$k(r) || _nonIterableSpread$f();
}
function _nonIterableSpread$f() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$k(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$k(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$k(r, a) : void 0;
  }
}
function _iterableToArray$g(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$f(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$k(r);
}
function _arrayLikeToArray$k(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey$p(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
function _defineProperty$q(e, r, t) {
  return (r = _toPropertyKey$p(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$p(t) {
  var i2 = _toPrimitive$p(t, "string");
  return "symbol" == _typeof$r(i2) ? i2 : i2 + "";
}
function _toPrimitive$p(t, r) {
  if ("object" != _typeof$r(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r);
    if ("object" != _typeof$r(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var _default = /* @__PURE__ */ function() {
  function _default6(_ref) {
    var init2 = _ref.init, type = _ref.type;
    _classCallCheck(this, _default6);
    _defineProperty$q(this, "helpers", void 0);
    _defineProperty$q(this, "type", void 0);
    this.helpers = new Set(init2);
    this.type = type;
  }
  return _createClass(_default6, [{
    key: "add",
    value: function add3(instance) {
      this.helpers.add(instance);
    }
  }, {
    key: "update",
    value: function update2() {
    }
  }, {
    key: "delete",
    value: function _delete(instance) {
      this.helpers["delete"](instance);
    }
  }, {
    key: "clear",
    value: function clear3() {
      this.helpers.clear();
    }
  }, {
    key: "get",
    value: function get2(parentInstance, slots) {
      var children = this._get(parentInstance, slots);
      var computed2 = children ? this._recursive(_toConsumableArray$f(this.helpers), children) : null;
      return isNotEmpty(computed2) ? computed2 : null;
    }
  }, {
    key: "_isMatched",
    value: function _isMatched(instance, key) {
      var _parent$vnode;
      var parent = instance === null || instance === void 0 ? void 0 : instance.parent;
      return (parent === null || parent === void 0 || (_parent$vnode = parent.vnode) === null || _parent$vnode === void 0 ? void 0 : _parent$vnode.key) === key || parent && this._isMatched(parent, key) || false;
    }
  }, {
    key: "_get",
    value: function _get(parentInstance, slots) {
      var _ref2, _ref2$default;
      return ((_ref2 = slots || (parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$slots)) === null || _ref2 === void 0 || (_ref2$default = _ref2["default"]) === null || _ref2$default === void 0 ? void 0 : _ref2$default.call(_ref2)) || null;
    }
  }, {
    key: "_recursive",
    value: function _recursive() {
      var _this = this;
      var helpers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var children = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var components = [];
      children.forEach(function(child) {
        if (child.children instanceof Array) {
          components = components.concat(_this._recursive(components, child.children));
        } else if (child.type.name === _this.type) {
          components.push(child);
        } else if (isNotEmpty(child.key)) {
          components = components.concat(helpers.filter(function(c) {
            return _this._isMatched(c, child.key);
          }).map(function(c) {
            return c.vnode;
          }));
        }
      });
      return components;
    }
  }]);
}();
function UniqueComponentId() {
  var prefix2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pv_id_";
  return uuid(prefix2);
}
function getVNodeProp(vnode, prop2) {
  if (vnode) {
    var props = vnode.props;
    if (props) {
      var kebabProp = prop2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      var propName = Object.prototype.hasOwnProperty.call(props, kebabProp) ? kebabProp : prop2;
      return vnode.type["extends"].props[prop2].type === Boolean && props[propName] === "" ? true : props[propName];
    }
  }
  return null;
}
var Base = {
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  getLoadedStyleNames: function getLoadedStyleNames2() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded: function isStyleNameLoaded2(name) {
    return this._loadedStyleNames.has(name);
  },
  setLoadedStyleName: function setLoadedStyleName2(name) {
    this._loadedStyleNames.add(name);
  },
  deleteLoadedStyleName: function deleteLoadedStyleName2(name) {
    this._loadedStyleNames["delete"](name);
  },
  clearLoadedStyleNames: function clearLoadedStyleNames2() {
    this._loadedStyleNames.clear();
  }
};
function _typeof$q(o) {
  "@babel/helpers - typeof";
  return _typeof$q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$q(o);
}
function _slicedToArray$5(r, e) {
  return _arrayWithHoles$5(r) || _iterableToArrayLimit$5(r, e) || _unsupportedIterableToArray$j(r, e) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$j(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$j(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$j(r, a) : void 0;
  }
}
function _arrayLikeToArray$j(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit$5(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles$5(r) {
  if (Array.isArray(r)) return r;
}
function ownKeys$n(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$n(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$n(Object(t), true).forEach(function(r2) {
      _defineProperty$p(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$p(e, r, t) {
  return (r = _toPropertyKey$o(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$o(t) {
  var i2 = _toPrimitive$o(t, "string");
  return "symbol" == _typeof$q(i2) ? i2 : i2 + "";
}
function _toPrimitive$o(t, r) {
  if ("object" != _typeof$q(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$q(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var BaseDirective = {
  _getMeta: function _getMeta() {
    return [isObject$3(arguments.length <= 0 ? void 0 : arguments[0]) ? void 0 : arguments.length <= 0 ? void 0 : arguments[0], resolve(isObject$3(arguments.length <= 0 ? void 0 : arguments[0]) ? arguments.length <= 0 ? void 0 : arguments[0] : arguments.length <= 1 ? void 0 : arguments[1])];
  },
  _getConfig: function _getConfig(binding, vnode) {
    var _ref, _binding$instance, _vnode$ctx;
    return (_ref = (binding === null || binding === void 0 || (_binding$instance = binding.instance) === null || _binding$instance === void 0 ? void 0 : _binding$instance.$primevue) || (vnode === null || vnode === void 0 || (_vnode$ctx = vnode.ctx) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.appContext) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.config) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.globalProperties) === null || _vnode$ctx === void 0 ? void 0 : _vnode$ctx.$primevue)) === null || _ref === void 0 ? void 0 : _ref.config;
  },
  _getOptionValue: getKeyValue,
  _getPTValue: function _getPTValue() {
    var _instance$binding, _instance$$primevueCo;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var obj = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    var params = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var searchInDefaultPT = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var getValue2 = function getValue3() {
      var value3 = BaseDirective._getOptionValue.apply(BaseDirective, arguments);
      return isString$3(value3) || isArray$2(value3) ? {
        "class": value3
      } : value3;
    };
    var _ref2 = ((_instance$binding = instance.binding) === null || _instance$binding === void 0 || (_instance$binding = _instance$binding.value) === null || _instance$binding === void 0 ? void 0 : _instance$binding.ptOptions) || ((_instance$$primevueCo = instance.$primevueConfig) === null || _instance$$primevueCo === void 0 ? void 0 : _instance$$primevueCo.ptOptions) || {}, _ref2$mergeSections = _ref2.mergeSections, mergeSections = _ref2$mergeSections === void 0 ? true : _ref2$mergeSections, _ref2$mergeProps = _ref2.mergeProps, useMergeProps = _ref2$mergeProps === void 0 ? false : _ref2$mergeProps;
    var global2 = searchInDefaultPT ? BaseDirective._useDefaultPT(instance, instance.defaultPT(), getValue2, key, params) : void 0;
    var self2 = BaseDirective._usePT(instance, BaseDirective._getPT(obj, instance.$name), getValue2, key, _objectSpread$n(_objectSpread$n({}, params), {}, {
      global: global2 || {}
    }));
    var datasets = BaseDirective._getPTDatasets(instance, key);
    return mergeSections || !mergeSections && self2 ? useMergeProps ? BaseDirective._mergeProps(instance, useMergeProps, global2, self2, datasets) : _objectSpread$n(_objectSpread$n(_objectSpread$n({}, global2), self2), datasets) : _objectSpread$n(_objectSpread$n({}, self2), datasets);
  },
  _getPTDatasets: function _getPTDatasets() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var datasetPrefix = "data-pc-";
    return _objectSpread$n(_objectSpread$n({}, key === "root" && _defineProperty$p({}, "".concat(datasetPrefix, "name"), toFlatCase(instance.$name))), {}, _defineProperty$p({}, "".concat(datasetPrefix, "section"), toFlatCase(key)));
  },
  _getPT: function _getPT(pt) {
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var getValue2 = function getValue3(value3) {
      var _computedValue$_key;
      var computedValue = callback ? callback(value3) : value3;
      var _key = toFlatCase(key);
      return (_computedValue$_key = computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _computedValue$_key !== void 0 ? _computedValue$_key : computedValue;
    };
    return pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept") ? {
      _usept: pt["_usept"],
      originalValue: getValue2(pt.originalValue),
      value: getValue2(pt.value)
    } : getValue2(pt);
  },
  _usePT: function _usePT() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var pt = arguments.length > 1 ? arguments[1] : void 0;
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    var fn = function fn2(value4) {
      return callback(value4, key, params);
    };
    if (pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept")) {
      var _instance$$primevueCo2;
      var _ref4 = pt["_usept"] || ((_instance$$primevueCo2 = instance.$primevueConfig) === null || _instance$$primevueCo2 === void 0 ? void 0 : _instance$$primevueCo2.ptOptions) || {}, _ref4$mergeSections = _ref4.mergeSections, mergeSections = _ref4$mergeSections === void 0 ? true : _ref4$mergeSections, _ref4$mergeProps = _ref4.mergeProps, useMergeProps = _ref4$mergeProps === void 0 ? false : _ref4$mergeProps;
      var originalValue = fn(pt.originalValue);
      var value3 = fn(pt.value);
      if (originalValue === void 0 && value3 === void 0) return void 0;
      else if (isString$3(value3)) return value3;
      else if (isString$3(originalValue)) return originalValue;
      return mergeSections || !mergeSections && value3 ? useMergeProps ? BaseDirective._mergeProps(instance, useMergeProps, originalValue, value3) : _objectSpread$n(_objectSpread$n({}, originalValue), value3) : value3;
    }
    return fn(pt);
  },
  _useDefaultPT: function _useDefaultPT() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaultPT2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    return BaseDirective._usePT(instance, defaultPT2, callback, key, params);
  },
  _loadStyles: function _loadStyles(el, binding, vnode) {
    var _config$csp;
    var config = BaseDirective._getConfig(binding, vnode);
    var useStyleOptions = {
      nonce: config === null || config === void 0 || (_config$csp = config.csp) === null || _config$csp === void 0 ? void 0 : _config$csp.nonce
    };
    BaseDirective._loadCoreStyles(el.$instance, useStyleOptions);
    BaseDirective._loadThemeStyles(el.$instance, useStyleOptions);
    BaseDirective._loadScopedThemeStyles(el.$instance, useStyleOptions);
    BaseDirective._themeChangeListener(function() {
      return BaseDirective._loadThemeStyles(el.$instance, useStyleOptions);
    });
  },
  _loadCoreStyles: function _loadCoreStyles() {
    var _instance$$style, _instance$$style2;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (!Base.isStyleNameLoaded((_instance$$style = instance.$style) === null || _instance$$style === void 0 ? void 0 : _instance$$style.name) && (_instance$$style2 = instance.$style) !== null && _instance$$style2 !== void 0 && _instance$$style2.name) {
      var _instance$$style3;
      BaseStyle.loadCSS(useStyleOptions);
      instance.isUnstyled() && ((_instance$$style3 = instance.$style) === null || _instance$$style3 === void 0 ? void 0 : _instance$$style3.loadCSS(useStyleOptions));
      Base.setLoadedStyleName(instance.$style.name);
    }
  },
  _loadThemeStyles: function _loadThemeStyles() {
    var _instance$$style5, _instance$$style6;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (instance !== null && instance !== void 0 && instance.isUnstyled()) return;
    if (!config_default.isStyleNameLoaded("common")) {
      var _instance$$style4, _instance$$style4$get;
      var _ref5 = ((_instance$$style4 = instance.$style) === null || _instance$$style4 === void 0 || (_instance$$style4$get = _instance$$style4.getCommonTheme) === null || _instance$$style4$get === void 0 ? void 0 : _instance$$style4$get.call(_instance$$style4)) || {}, primitive = _ref5.primitive, semantic = _ref5.semantic;
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$n({
        name: "primitive-variables"
      }, useStyleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$n({
        name: "semantic-variables"
      }, useStyleOptions));
      BaseStyle.loadTheme(_objectSpread$n({
        name: "global-style"
      }, useStyleOptions));
      config_default.setLoadedStyleName("common");
    }
    if (!config_default.isStyleNameLoaded((_instance$$style5 = instance.$style) === null || _instance$$style5 === void 0 ? void 0 : _instance$$style5.name) && (_instance$$style6 = instance.$style) !== null && _instance$$style6 !== void 0 && _instance$$style6.name) {
      var _instance$$style7, _instance$$style7$get, _instance$$style8, _instance$$style9;
      var _ref6 = ((_instance$$style7 = instance.$style) === null || _instance$$style7 === void 0 || (_instance$$style7$get = _instance$$style7.getDirectiveTheme) === null || _instance$$style7$get === void 0 ? void 0 : _instance$$style7$get.call(_instance$$style7)) || {}, css4 = _ref6.css;
      (_instance$$style8 = instance.$style) === null || _instance$$style8 === void 0 || _instance$$style8.load(css4, _objectSpread$n({
        name: "".concat(instance.$style.name, "-variables")
      }, useStyleOptions));
      (_instance$$style9 = instance.$style) === null || _instance$$style9 === void 0 || _instance$$style9.loadTheme(_objectSpread$n({
        name: "".concat(instance.$style.name, "-style")
      }, useStyleOptions));
      config_default.setLoadedStyleName(instance.$style.name);
    }
    if (!config_default.isStyleNameLoaded("layer-order")) {
      var _instance$$style10, _instance$$style10$ge;
      var layerOrder = (_instance$$style10 = instance.$style) === null || _instance$$style10 === void 0 || (_instance$$style10$ge = _instance$$style10.getLayerOrderThemeCSS) === null || _instance$$style10$ge === void 0 ? void 0 : _instance$$style10$ge.call(_instance$$style10);
      BaseStyle.load(layerOrder, _objectSpread$n({
        name: "layer-order",
        first: true
      }, useStyleOptions));
      config_default.setLoadedStyleName("layer-order");
    }
  },
  _loadScopedThemeStyles: function _loadScopedThemeStyles() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    var preset = instance.preset();
    if (preset && instance.$attrSelector) {
      var _instance$$style11, _instance$$style11$ge, _instance$$style12;
      var _ref7 = ((_instance$$style11 = instance.$style) === null || _instance$$style11 === void 0 || (_instance$$style11$ge = _instance$$style11.getPresetTheme) === null || _instance$$style11$ge === void 0 ? void 0 : _instance$$style11$ge.call(_instance$$style11, preset, "[".concat(instance.$attrSelector, "]"))) || {}, css4 = _ref7.css;
      var scopedStyle = (_instance$$style12 = instance.$style) === null || _instance$$style12 === void 0 ? void 0 : _instance$$style12.load(css4, _objectSpread$n({
        name: "".concat(instance.$attrSelector, "-").concat(instance.$style.name)
      }, useStyleOptions));
      instance.scopedStyleEl = scopedStyle.el;
    }
  },
  _themeChangeListener: function _themeChangeListener() {
    var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    Base.clearLoadedStyleNames();
    service_default.on("theme:change", callback);
  },
  _hook: function _hook(directiveName, hookName, el, binding, vnode, prevVnode) {
    var _binding$value, _config$pt;
    var name = "on".concat(toCapitalCase(hookName));
    var config = BaseDirective._getConfig(binding, vnode);
    var instance = el === null || el === void 0 ? void 0 : el.$instance;
    var selfHook = BaseDirective._usePT(instance, BaseDirective._getPT(binding === null || binding === void 0 || (_binding$value = binding.value) === null || _binding$value === void 0 ? void 0 : _binding$value.pt, directiveName), BaseDirective._getOptionValue, "hooks.".concat(name));
    var defaultHook = BaseDirective._useDefaultPT(instance, config === null || config === void 0 || (_config$pt = config.pt) === null || _config$pt === void 0 || (_config$pt = _config$pt.directives) === null || _config$pt === void 0 ? void 0 : _config$pt[directiveName], BaseDirective._getOptionValue, "hooks.".concat(name));
    var options3 = {
      el,
      binding,
      vnode,
      prevVnode
    };
    selfHook === null || selfHook === void 0 || selfHook(instance, options3);
    defaultHook === null || defaultHook === void 0 || defaultHook(instance, options3);
  },
  _mergeProps: function _mergeProps() {
    var fn = arguments.length > 1 ? arguments[1] : void 0;
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }
    return isFunction$2(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
  },
  _extend: function _extend(name) {
    var options3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var handleHook = function handleHook2(hook, el, binding, vnode, prevVnode) {
      var _el$$instance$hook, _el$$instance9, _el$$pd;
      el._$instances = el._$instances || {};
      var config = BaseDirective._getConfig(binding, vnode);
      var $prevInstance = el._$instances[name] || {};
      var $options = isEmpty($prevInstance) ? _objectSpread$n(_objectSpread$n({}, options3), options3 === null || options3 === void 0 ? void 0 : options3.methods) : {};
      el._$instances[name] = _objectSpread$n(_objectSpread$n({}, $prevInstance), {}, {
        /* new instance variables to pass in directive methods */
        $name: name,
        $host: el,
        $binding: binding,
        $modifiers: binding === null || binding === void 0 ? void 0 : binding.modifiers,
        $value: binding === null || binding === void 0 ? void 0 : binding.value,
        $el: $prevInstance["$el"] || el || void 0,
        $style: _objectSpread$n({
          classes: void 0,
          inlineStyles: void 0,
          load: function load2() {
          },
          loadCSS: function loadCSS2() {
          },
          loadTheme: function loadTheme2() {
          }
        }, options3 === null || options3 === void 0 ? void 0 : options3.style),
        $primevueConfig: config,
        $attrSelector: el.$attrSelector,
        /* computed instance variables */
        defaultPT: function defaultPT2() {
          return BaseDirective._getPT(config === null || config === void 0 ? void 0 : config.pt, void 0, function(value3) {
            var _value$directives;
            return value3 === null || value3 === void 0 || (_value$directives = value3.directives) === null || _value$directives === void 0 ? void 0 : _value$directives[name];
          });
        },
        isUnstyled: function isUnstyled2() {
          var _el$$instance, _el$$instance2;
          return ((_el$$instance = el.$instance) === null || _el$$instance === void 0 || (_el$$instance = _el$$instance.$binding) === null || _el$$instance === void 0 || (_el$$instance = _el$$instance.value) === null || _el$$instance === void 0 ? void 0 : _el$$instance.unstyled) !== void 0 ? (_el$$instance2 = el.$instance) === null || _el$$instance2 === void 0 || (_el$$instance2 = _el$$instance2.$binding) === null || _el$$instance2 === void 0 || (_el$$instance2 = _el$$instance2.value) === null || _el$$instance2 === void 0 ? void 0 : _el$$instance2.unstyled : config === null || config === void 0 ? void 0 : config.unstyled;
        },
        theme: function theme36() {
          var _el$$instance3;
          return (_el$$instance3 = el.$instance) === null || _el$$instance3 === void 0 || (_el$$instance3 = _el$$instance3.$primevueConfig) === null || _el$$instance3 === void 0 ? void 0 : _el$$instance3.theme;
        },
        preset: function preset() {
          var _el$$instance4;
          return (_el$$instance4 = el.$instance) === null || _el$$instance4 === void 0 || (_el$$instance4 = _el$$instance4.$binding) === null || _el$$instance4 === void 0 || (_el$$instance4 = _el$$instance4.value) === null || _el$$instance4 === void 0 ? void 0 : _el$$instance4.dt;
        },
        /* instance's methods */
        ptm: function ptm2() {
          var _el$$instance5;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return BaseDirective._getPTValue(el.$instance, (_el$$instance5 = el.$instance) === null || _el$$instance5 === void 0 || (_el$$instance5 = _el$$instance5.$binding) === null || _el$$instance5 === void 0 || (_el$$instance5 = _el$$instance5.value) === null || _el$$instance5 === void 0 ? void 0 : _el$$instance5.pt, key, _objectSpread$n({}, params));
        },
        ptmo: function ptmo2() {
          var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return BaseDirective._getPTValue(el.$instance, obj, key, params, false);
        },
        cx: function cx2() {
          var _el$$instance6, _el$$instance7;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return !((_el$$instance6 = el.$instance) !== null && _el$$instance6 !== void 0 && _el$$instance6.isUnstyled()) ? BaseDirective._getOptionValue((_el$$instance7 = el.$instance) === null || _el$$instance7 === void 0 || (_el$$instance7 = _el$$instance7.$style) === null || _el$$instance7 === void 0 ? void 0 : _el$$instance7.classes, key, _objectSpread$n({}, params)) : void 0;
        },
        sx: function sx2() {
          var _el$$instance8;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return when ? BaseDirective._getOptionValue((_el$$instance8 = el.$instance) === null || _el$$instance8 === void 0 || (_el$$instance8 = _el$$instance8.$style) === null || _el$$instance8 === void 0 ? void 0 : _el$$instance8.inlineStyles, key, _objectSpread$n({}, params)) : void 0;
        }
      }, $options);
      el.$instance = el._$instances[name];
      (_el$$instance$hook = (_el$$instance9 = el.$instance)[hook]) === null || _el$$instance$hook === void 0 || _el$$instance$hook.call(_el$$instance9, el, binding, vnode, prevVnode);
      el["$".concat(name)] = el.$instance;
      BaseDirective._hook(name, hook, el, binding, vnode, prevVnode);
      el.$pd || (el.$pd = {});
      el.$pd[name] = _objectSpread$n(_objectSpread$n({}, (_el$$pd = el.$pd) === null || _el$$pd === void 0 ? void 0 : _el$$pd[name]), {}, {
        name,
        instance: el.$instance
      });
    };
    var handleWatch = function handleWatch2(el) {
      var _el$$instance10, _watchers$config, _el$$instance11, _watchers$configRipp, _el$$instance12;
      var watchers = (_el$$instance10 = el.$instance) === null || _el$$instance10 === void 0 ? void 0 : _el$$instance10.watch;
      watchers === null || watchers === void 0 || (_watchers$config = watchers["config"]) === null || _watchers$config === void 0 || _watchers$config.call(el.$instance, (_el$$instance11 = el.$instance) === null || _el$$instance11 === void 0 ? void 0 : _el$$instance11.$primevueConfig);
      PrimeVueService.on("config:change", function(_ref8) {
        var _watchers$config2;
        var newValue = _ref8.newValue, oldValue = _ref8.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$config2 = watchers["config"]) === null || _watchers$config2 === void 0 ? void 0 : _watchers$config2.call(el.$instance, newValue, oldValue);
      });
      watchers === null || watchers === void 0 || (_watchers$configRipp = watchers["config.ripple"]) === null || _watchers$configRipp === void 0 || _watchers$configRipp.call(el.$instance, (_el$$instance12 = el.$instance) === null || _el$$instance12 === void 0 || (_el$$instance12 = _el$$instance12.$primevueConfig) === null || _el$$instance12 === void 0 ? void 0 : _el$$instance12.ripple);
      PrimeVueService.on("config:ripple:change", function(_ref9) {
        var _watchers$configRipp2;
        var newValue = _ref9.newValue, oldValue = _ref9.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$configRipp2 = watchers["config.ripple"]) === null || _watchers$configRipp2 === void 0 ? void 0 : _watchers$configRipp2.call(el.$instance, newValue, oldValue);
      });
    };
    return {
      created: function created3(el, binding, vnode, prevVnode) {
        handleHook("created", el, binding, vnode, prevVnode);
      },
      beforeMount: function beforeMount4(el, binding, vnode, prevVnode) {
        el.$attrSelector = UniqueComponentId("pd");
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("beforeMount", el, binding, vnode, prevVnode);
        handleWatch(el);
      },
      mounted: function mounted24(el, binding, vnode, prevVnode) {
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("mounted", el, binding, vnode, prevVnode);
      },
      beforeUpdate: function beforeUpdate2(el, binding, vnode, prevVnode) {
        handleHook("beforeUpdate", el, binding, vnode, prevVnode);
      },
      updated: function updated13(el, binding, vnode, prevVnode) {
        BaseDirective._loadStyles(el, binding, vnode);
        handleHook("updated", el, binding, vnode, prevVnode);
      },
      beforeUnmount: function beforeUnmount15(el, binding, vnode, prevVnode) {
        handleHook("beforeUnmount", el, binding, vnode, prevVnode);
      },
      unmounted: function unmounted7(el, binding, vnode, prevVnode) {
        var _el$$instance13;
        (_el$$instance13 = el.$instance) === null || _el$$instance13 === void 0 || (_el$$instance13 = _el$$instance13.scopedStyleEl) === null || _el$$instance13 === void 0 || (_el$$instance13 = _el$$instance13.value) === null || _el$$instance13 === void 0 || _el$$instance13.remove();
        handleHook("unmounted", el, binding, vnode, prevVnode);
      }
    };
  },
  extend: function extend3() {
    var _BaseDirective$_getMe = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe2 = _slicedToArray$5(_BaseDirective$_getMe, 2), name = _BaseDirective$_getMe2[0], options3 = _BaseDirective$_getMe2[1];
    return _objectSpread$n({
      extend: function extend4() {
        var _BaseDirective$_getMe3 = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe4 = _slicedToArray$5(_BaseDirective$_getMe3, 2), _name2 = _BaseDirective$_getMe4[0], _options2 = _BaseDirective$_getMe4[1];
        return BaseDirective.extend(_name2, _objectSpread$n(_objectSpread$n(_objectSpread$n({}, options3), options3 === null || options3 === void 0 ? void 0 : options3.methods), _options2));
      }
    }, BaseDirective._extend(name, options3));
  }
};
var theme$w = function theme3(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-tooltip {\n    position: absolute;\n    display: none;\n    max-width: ".concat(dt3("tooltip.max.width"), ";\n}\n\n.p-tooltip-right,\n.p-tooltip-left {\n    padding: 0 ").concat(dt3("tooltip.gutter"), ";\n}\n\n.p-tooltip-top,\n.p-tooltip-bottom {\n    padding: ").concat(dt3("tooltip.gutter"), " 0;\n}\n\n.p-tooltip-text {\n    white-space: pre-line;\n    word-break: break-word;\n    background: ").concat(dt3("tooltip.background"), ";\n    color: ").concat(dt3("tooltip.color"), ";\n    padding: ").concat(dt3("tooltip.padding"), ";\n    box-shadow: ").concat(dt3("tooltip.shadow"), ";\n    border-radius: ").concat(dt3("tooltip.border.radius"), ";\n}\n\n.p-tooltip-arrow {\n    position: absolute;\n    width: 0;\n    height: 0;\n    border-color: transparent;\n    border-style: solid;\n    scale: 2;\n}\n\n.p-tooltip-right .p-tooltip-arrow {\n    margin-top: calc(-1 * ").concat(dt3("tooltip.gutter"), ");\n    border-width: ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), " 0;\n    border-right-color: ").concat(dt3("tooltip.background"), ";\n}\n\n.p-tooltip-left .p-tooltip-arrow {\n    margin-top: calc(-1 * ").concat(dt3("tooltip.gutter"), ");\n    border-width: ").concat(dt3("tooltip.gutter"), " 0 ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), ";\n    border-left-color: ").concat(dt3("tooltip.background"), ";\n}\n\n.p-tooltip-top .p-tooltip-arrow {\n    margin-left: calc(-1 * ").concat(dt3("tooltip.gutter"), ");\n    border-width: ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), " 0 ").concat(dt3("tooltip.gutter"), ";\n    border-top-color: ").concat(dt3("tooltip.background"), ";\n    border-bottom-color: ").concat(dt3("tooltip.background"), ";\n}\n\n.p-tooltip-bottom .p-tooltip-arrow {\n    margin-left: calc(-1 * ").concat(dt3("tooltip.gutter"), ");\n    border-width: 0 ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), " ").concat(dt3("tooltip.gutter"), ";\n    border-top-color: ").concat(dt3("tooltip.background"), ";\n    border-bottom-color: ").concat(dt3("tooltip.background"), ";\n}\n");
};
var classes$z = {
  root: "p-tooltip p-component",
  arrow: "p-tooltip-arrow",
  text: "p-tooltip-text"
};
var TooltipStyle = BaseStyle.extend({
  name: "tooltip-directive",
  theme: theme$w,
  classes: classes$z
});
var BaseTooltip = BaseDirective.extend({
  style: TooltipStyle
});
function _slicedToArray$4(r, e) {
  return _arrayWithHoles$4(r) || _iterableToArrayLimit$4(r, e) || _unsupportedIterableToArray$i(r, e) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$i(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$i(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$i(r, a) : void 0;
  }
}
function _arrayLikeToArray$i(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit$4(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles$4(r) {
  if (Array.isArray(r)) return r;
}
function _defineProperty$o(e, r, t) {
  return (r = _toPropertyKey$n(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$n(t) {
  var i2 = _toPrimitive$n(t, "string");
  return "symbol" == _typeof$p(i2) ? i2 : i2 + "";
}
function _toPrimitive$n(t, r) {
  if ("object" != _typeof$p(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$p(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _typeof$p(o) {
  "@babel/helpers - typeof";
  return _typeof$p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$p(o);
}
var Tooltip = BaseTooltip.extend("tooltip", {
  beforeMount: function beforeMount(el, options3) {
    var _options$instance$$pr;
    var target = this.getTarget(el);
    target.$_ptooltipModifiers = this.getModifiers(options3);
    if (!options3.value) return;
    else if (typeof options3.value === "string") {
      target.$_ptooltipValue = options3.value;
      target.$_ptooltipDisabled = false;
      target.$_ptooltipEscape = true;
      target.$_ptooltipClass = null;
      target.$_ptooltipFitContent = true;
      target.$_ptooltipIdAttr = UniqueComponentId() + "_tooltip";
      target.$_ptooltipShowDelay = 0;
      target.$_ptooltipHideDelay = 0;
      target.$_ptooltipAutoHide = true;
    } else if (_typeof$p(options3.value) === "object" && options3.value) {
      if (isEmpty(options3.value.value) || options3.value.value.trim() === "") return;
      else {
        target.$_ptooltipValue = options3.value.value;
        target.$_ptooltipDisabled = !!options3.value.disabled === options3.value.disabled ? options3.value.disabled : false;
        target.$_ptooltipEscape = !!options3.value.escape === options3.value.escape ? options3.value.escape : true;
        target.$_ptooltipClass = options3.value["class"] || "";
        target.$_ptooltipFitContent = !!options3.value.fitContent === options3.value.fitContent ? options3.value.fitContent : true;
        target.$_ptooltipIdAttr = options3.value.id || UniqueComponentId() + "_tooltip";
        target.$_ptooltipShowDelay = options3.value.showDelay || 0;
        target.$_ptooltipHideDelay = options3.value.hideDelay || 0;
        target.$_ptooltipAutoHide = !!options3.value.autoHide === options3.value.autoHide ? options3.value.autoHide : true;
      }
    }
    target.$_ptooltipZIndex = (_options$instance$$pr = options3.instance.$primevue) === null || _options$instance$$pr === void 0 || (_options$instance$$pr = _options$instance$$pr.config) === null || _options$instance$$pr === void 0 || (_options$instance$$pr = _options$instance$$pr.zIndex) === null || _options$instance$$pr === void 0 ? void 0 : _options$instance$$pr.tooltip;
    this.bindEvents(target, options3);
    el.setAttribute("data-pd-tooltip", true);
  },
  updated: function updated(el, options3) {
    var target = this.getTarget(el);
    target.$_ptooltipModifiers = this.getModifiers(options3);
    this.unbindEvents(target);
    if (!options3.value) {
      return;
    }
    if (typeof options3.value === "string") {
      target.$_ptooltipValue = options3.value;
      target.$_ptooltipDisabled = false;
      target.$_ptooltipEscape = true;
      target.$_ptooltipClass = null;
      target.$_ptooltipIdAttr = target.$_ptooltipIdAttr || UniqueComponentId() + "_tooltip";
      target.$_ptooltipShowDelay = 0;
      target.$_ptooltipHideDelay = 0;
      target.$_ptooltipAutoHide = true;
      this.bindEvents(target, options3);
    } else if (_typeof$p(options3.value) === "object" && options3.value) {
      if (isEmpty(options3.value.value) || options3.value.value.trim() === "") {
        this.unbindEvents(target, options3);
        return;
      } else {
        target.$_ptooltipValue = options3.value.value;
        target.$_ptooltipDisabled = !!options3.value.disabled === options3.value.disabled ? options3.value.disabled : false;
        target.$_ptooltipEscape = !!options3.value.escape === options3.value.escape ? options3.value.escape : true;
        target.$_ptooltipClass = options3.value["class"] || "";
        target.$_ptooltipFitContent = !!options3.value.fitContent === options3.value.fitContent ? options3.value.fitContent : true;
        target.$_ptooltipIdAttr = options3.value.id || target.$_ptooltipIdAttr || UniqueComponentId() + "_tooltip";
        target.$_ptooltipShowDelay = options3.value.showDelay || 0;
        target.$_ptooltipHideDelay = options3.value.hideDelay || 0;
        target.$_ptooltipAutoHide = !!options3.value.autoHide === options3.value.autoHide ? options3.value.autoHide : true;
        this.bindEvents(target, options3);
      }
    }
  },
  unmounted: function unmounted(el, options3) {
    var target = this.getTarget(el);
    this.remove(target);
    this.unbindEvents(target, options3);
    if (target.$_ptooltipScrollHandler) {
      target.$_ptooltipScrollHandler.destroy();
      target.$_ptooltipScrollHandler = null;
    }
  },
  timer: void 0,
  methods: {
    bindEvents: function bindEvents(el, options3) {
      var _this = this;
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.focus) {
        el.$_focusevent = function(event2) {
          return _this.onFocus(event2, options3);
        };
        el.addEventListener("focus", el.$_focusevent);
        el.addEventListener("blur", this.onBlur.bind(this));
      } else {
        el.$_mouseenterevent = function(event2) {
          return _this.onMouseEnter(event2, options3);
        };
        el.addEventListener("mouseenter", el.$_mouseenterevent);
        el.addEventListener("mouseleave", this.onMouseLeave.bind(this));
        el.addEventListener("click", this.onClick.bind(this));
      }
      el.addEventListener("keydown", this.onKeydown.bind(this));
    },
    unbindEvents: function unbindEvents(el) {
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.focus) {
        el.removeEventListener("focus", el.$_focusevent);
        el.$_focusevent = null;
        el.removeEventListener("blur", this.onBlur.bind(this));
      } else {
        el.removeEventListener("mouseenter", el.$_mouseenterevent);
        el.$_mouseenterevent = null;
        el.removeEventListener("mouseleave", this.onMouseLeave.bind(this));
        el.removeEventListener("click", this.onClick.bind(this));
      }
      el.removeEventListener("keydown", this.onKeydown.bind(this));
    },
    bindScrollListener: function bindScrollListener(el) {
      var _this2 = this;
      if (!el.$_ptooltipScrollHandler) {
        el.$_ptooltipScrollHandler = new ConnectedOverlayScrollHandler(el, function() {
          _this2.hide(el);
        });
      }
      el.$_ptooltipScrollHandler.bindScrollListener();
    },
    unbindScrollListener: function unbindScrollListener(el) {
      if (el.$_ptooltipScrollHandler) {
        el.$_ptooltipScrollHandler.unbindScrollListener();
      }
    },
    onMouseEnter: function onMouseEnter(event2, options3) {
      var el = event2.currentTarget;
      var showDelay = el.$_ptooltipShowDelay;
      this.show(el, options3, showDelay);
    },
    onMouseLeave: function onMouseLeave(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      var autoHide = el.$_ptooltipAutoHide;
      if (!autoHide) {
        var valid = getAttribute(event2.target, "data-pc-name") === "tooltip" || getAttribute(event2.target, "data-pc-section") === "arrow" || getAttribute(event2.target, "data-pc-section") === "text" || getAttribute(event2.relatedTarget, "data-pc-name") === "tooltip" || getAttribute(event2.relatedTarget, "data-pc-section") === "arrow" || getAttribute(event2.relatedTarget, "data-pc-section") === "text";
        !valid && this.hide(el, hideDelay);
      } else {
        this.hide(el, hideDelay);
      }
    },
    onFocus: function onFocus(event2, options3) {
      var el = event2.currentTarget;
      var showDelay = el.$_ptooltipShowDelay;
      this.show(el, options3, showDelay);
    },
    onBlur: function onBlur(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      this.hide(el, hideDelay);
    },
    onClick: function onClick(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      this.hide(el, hideDelay);
    },
    onKeydown: function onKeydown(event2) {
      var el = event2.currentTarget;
      var hideDelay = el.$_ptooltipHideDelay;
      event2.code === "Escape" && this.hide(event2.currentTarget, hideDelay);
    },
    tooltipActions: function tooltipActions(el, options3) {
      if (el.$_ptooltipDisabled || !isExist(el)) {
        return;
      }
      var tooltipElement = this.create(el, options3);
      this.align(el);
      !this.isUnstyled() && fadeIn(tooltipElement, 250);
      var $this = this;
      window.addEventListener("resize", function onWindowResize() {
        if (!isTouchDevice()) {
          $this.hide(el);
        }
        window.removeEventListener("resize", onWindowResize);
      });
      tooltipElement.addEventListener("mouseleave", function onTooltipLeave() {
        $this.hide(el);
        tooltipElement.removeEventListener("mouseleave", onTooltipLeave);
      });
      this.bindScrollListener(el);
      ZIndex.set("tooltip", tooltipElement, el.$_ptooltipZIndex);
    },
    show: function show(el, options3, showDelay) {
      var _this3 = this;
      if (showDelay !== void 0) {
        this.timer = setTimeout(function() {
          return _this3.tooltipActions(el, options3);
        }, showDelay);
      } else {
        this.tooltipActions(el, options3);
      }
    },
    tooltipRemoval: function tooltipRemoval(el) {
      this.remove(el);
      this.unbindScrollListener(el);
    },
    hide: function hide(el, hideDelay) {
      var _this4 = this;
      clearTimeout(this.timer);
      if (hideDelay !== void 0) {
        setTimeout(function() {
          return _this4.tooltipRemoval(el);
        }, hideDelay);
      } else {
        this.tooltipRemoval(el);
      }
    },
    getTooltipElement: function getTooltipElement(el) {
      return document.getElementById(el.$_ptooltipId);
    },
    create: function create(el) {
      var modifiers = el.$_ptooltipModifiers;
      var tooltipArrow = createElement("div", {
        "class": !this.isUnstyled() && this.cx("arrow"),
        "p-bind": this.ptm("arrow", {
          context: modifiers
        })
      });
      var tooltipText = createElement("div", {
        "class": !this.isUnstyled() && this.cx("text"),
        "p-bind": this.ptm("text", {
          context: modifiers
        })
      });
      if (!el.$_ptooltipEscape) {
        tooltipText.innerHTML = el.$_ptooltipValue;
      } else {
        tooltipText.innerHTML = "";
        tooltipText.appendChild(document.createTextNode(el.$_ptooltipValue));
      }
      var container = createElement("div", _defineProperty$o(_defineProperty$o({
        id: el.$_ptooltipIdAttr,
        role: "tooltip",
        style: {
          display: "inline-block",
          width: el.$_ptooltipFitContent ? "fit-content" : void 0,
          pointerEvents: !this.isUnstyled() && el.$_ptooltipAutoHide && "none"
        },
        "class": [!this.isUnstyled() && this.cx("root"), el.$_ptooltipClass]
      }, this.$attrSelector, ""), "p-bind", this.ptm("root", {
        context: modifiers
      })), tooltipArrow, tooltipText);
      document.body.appendChild(container);
      el.$_ptooltipId = container.id;
      this.$el = container;
      return container;
    },
    remove: function remove2(el) {
      if (el) {
        var tooltipElement = this.getTooltipElement(el);
        if (tooltipElement && tooltipElement.parentElement) {
          ZIndex.clear(tooltipElement);
          document.body.removeChild(tooltipElement);
        }
        el.$_ptooltipId = null;
      }
    },
    align: function align(el) {
      var modifiers = el.$_ptooltipModifiers;
      if (modifiers.top) {
        this.alignTop(el);
        if (this.isOutOfBounds(el)) {
          this.alignBottom(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
          }
        }
      } else if (modifiers.left) {
        this.alignLeft(el);
        if (this.isOutOfBounds(el)) {
          this.alignRight(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
            if (this.isOutOfBounds(el)) {
              this.alignBottom(el);
              if (this.isOutOfBounds(el)) {
                this.alignLeft(el);
              }
            }
          }
        }
      } else if (modifiers.bottom) {
        this.alignBottom(el);
        if (this.isOutOfBounds(el)) {
          this.alignTop(el);
          if (this.isOutOfBounds(el)) {
            this.alignBottom(el);
          }
        }
      } else {
        this.alignRight(el);
        if (this.isOutOfBounds(el)) {
          this.alignLeft(el);
          if (this.isOutOfBounds(el)) {
            this.alignTop(el);
            if (this.isOutOfBounds(el)) {
              this.alignBottom(el);
              if (this.isOutOfBounds(el)) {
                this.alignRight(el);
              }
            }
          }
        }
      }
    },
    getHostOffset: function getHostOffset(el) {
      var offset = el.getBoundingClientRect();
      var targetLeft = offset.left + getWindowScrollLeft();
      var targetTop = offset.top + getWindowScrollTop();
      return {
        left: targetLeft,
        top: targetTop
      };
    },
    alignRight: function alignRight(el) {
      this.preAlign(el, "right");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + getOuterWidth(el);
      var top = hostOffset.top + (getOuterHeight(el) - getOuterHeight(tooltipElement)) / 2;
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    },
    alignLeft: function alignLeft(el) {
      this.preAlign(el, "left");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left - getOuterWidth(tooltipElement);
      var top = hostOffset.top + (getOuterHeight(el) - getOuterHeight(tooltipElement)) / 2;
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    },
    alignTop: function alignTop(el) {
      this.preAlign(el, "top");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + (getOuterWidth(el) - getOuterWidth(tooltipElement)) / 2;
      var top = hostOffset.top - getOuterHeight(tooltipElement);
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    },
    alignBottom: function alignBottom(el) {
      this.preAlign(el, "bottom");
      var tooltipElement = this.getTooltipElement(el);
      var hostOffset = this.getHostOffset(el);
      var left = hostOffset.left + (getOuterWidth(el) - getOuterWidth(tooltipElement)) / 2;
      var top = hostOffset.top + getOuterHeight(el);
      tooltipElement.style.left = left + "px";
      tooltipElement.style.top = top + "px";
    },
    preAlign: function preAlign(el, position) {
      var tooltipElement = this.getTooltipElement(el);
      tooltipElement.style.left = "-999px";
      tooltipElement.style.top = "-999px";
      removeClass(tooltipElement, "p-tooltip-".concat(tooltipElement.$_ptooltipPosition));
      !this.isUnstyled() && addClass(tooltipElement, "p-tooltip-".concat(position));
      tooltipElement.$_ptooltipPosition = position;
      tooltipElement.setAttribute("data-p-position", position);
      var arrowElement = findSingle(tooltipElement, '[data-pc-section="arrow"]');
      arrowElement.style.top = position === "bottom" ? "0" : position === "right" || position === "left" || position !== "right" && position !== "left" && position !== "top" && position !== "bottom" ? "50%" : null;
      arrowElement.style.bottom = position === "top" ? "0" : null;
      arrowElement.style.left = position === "right" || position !== "right" && position !== "left" && position !== "top" && position !== "bottom" ? "0" : position === "top" || position === "bottom" ? "50%" : null;
      arrowElement.style.right = position === "left" ? "0" : null;
    },
    isOutOfBounds: function isOutOfBounds(el) {
      var tooltipElement = this.getTooltipElement(el);
      var offset = tooltipElement.getBoundingClientRect();
      var targetTop = offset.top;
      var targetLeft = offset.left;
      var width2 = getOuterWidth(tooltipElement);
      var height = getOuterHeight(tooltipElement);
      var viewport = getViewport();
      return targetLeft + width2 > viewport.width || targetLeft < 0 || targetTop < 0 || targetTop + height > viewport.height;
    },
    getTarget: function getTarget2(el) {
      return hasClass(el, "p-inputwrapper") ? findSingle(el, "input") : el;
    },
    getModifiers: function getModifiers(options3) {
      if (options3.modifiers && Object.keys(options3.modifiers).length) {
        return options3.modifiers;
      }
      if (options3.arg && _typeof$p(options3.arg) === "object") {
        return Object.entries(options3.arg).reduce(function(acc, _ref) {
          var _ref2 = _slicedToArray$4(_ref, 2), key = _ref2[0], val = _ref2[1];
          if (key === "event" || key === "position") acc[val] = true;
          return acc;
        }, {});
      }
      return {};
    }
  }
});
var BaseComponentStyle = BaseStyle.extend({
  name: "common"
});
function _typeof$o(o) {
  "@babel/helpers - typeof";
  return _typeof$o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$o(o);
}
function _toArray(r) {
  return _arrayWithHoles$3(r) || _iterableToArray$f(r) || _unsupportedIterableToArray$h(r) || _nonIterableRest$3();
}
function _iterableToArray$f(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _slicedToArray$3(r, e) {
  return _arrayWithHoles$3(r) || _iterableToArrayLimit$3(r, e) || _unsupportedIterableToArray$h(r, e) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$h(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$h(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$h(r, a) : void 0;
  }
}
function _arrayLikeToArray$h(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit$3(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles$3(r) {
  if (Array.isArray(r)) return r;
}
function ownKeys$m(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$m(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$m(Object(t), true).forEach(function(r2) {
      _defineProperty$n(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$n(e, r, t) {
  return (r = _toPropertyKey$m(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$m(t) {
  var i2 = _toPrimitive$m(t, "string");
  return "symbol" == _typeof$o(i2) ? i2 : i2 + "";
}
function _toPrimitive$m(t, r) {
  if ("object" != _typeof$o(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$o(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var script$1a = {
  name: "BaseComponent",
  props: {
    pt: {
      type: Object,
      "default": void 0
    },
    ptOptions: {
      type: Object,
      "default": void 0
    },
    unstyled: {
      type: Boolean,
      "default": void 0
    },
    dt: {
      type: Object,
      "default": void 0
    }
  },
  inject: {
    $parentInstance: {
      "default": void 0
    }
  },
  watch: {
    isUnstyled: {
      immediate: true,
      handler: function handler2(newValue) {
        if (!newValue) {
          this._loadCoreStyles();
          this._themeChangeListener(this._loadCoreStyles);
        }
      }
    },
    dt: {
      immediate: true,
      handler: function handler3(newValue) {
        var _this = this;
        if (newValue) {
          this._loadScopedThemeStyles(newValue);
          this._themeChangeListener(function() {
            return _this._loadScopedThemeStyles(newValue);
          });
        } else {
          this._unloadScopedThemeStyles();
        }
      }
    }
  },
  scopedStyleEl: void 0,
  rootEl: void 0,
  beforeCreate: function beforeCreate() {
    var _this$pt, _this$pt2, _this$pt3, _ref, _ref$onBeforeCreate, _this$$primevueConfig, _this$$primevue, _this$$primevue2, _this$$primevue3, _ref2, _ref2$onBeforeCreate;
    var _usept = (_this$pt = this.pt) === null || _this$pt === void 0 ? void 0 : _this$pt["_usept"];
    var originalValue = _usept ? (_this$pt2 = this.pt) === null || _this$pt2 === void 0 || (_this$pt2 = _this$pt2.originalValue) === null || _this$pt2 === void 0 ? void 0 : _this$pt2[this.$.type.name] : void 0;
    var value3 = _usept ? (_this$pt3 = this.pt) === null || _this$pt3 === void 0 || (_this$pt3 = _this$pt3.value) === null || _this$pt3 === void 0 ? void 0 : _this$pt3[this.$.type.name] : this.pt;
    (_ref = value3 || originalValue) === null || _ref === void 0 || (_ref = _ref.hooks) === null || _ref === void 0 || (_ref$onBeforeCreate = _ref["onBeforeCreate"]) === null || _ref$onBeforeCreate === void 0 || _ref$onBeforeCreate.call(_ref);
    var _useptInConfig = (_this$$primevueConfig = this.$primevueConfig) === null || _this$$primevueConfig === void 0 || (_this$$primevueConfig = _this$$primevueConfig.pt) === null || _this$$primevueConfig === void 0 ? void 0 : _this$$primevueConfig["_usept"];
    var originalValueInConfig = _useptInConfig ? (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.pt) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.originalValue : void 0;
    var valueInConfig = _useptInConfig ? (_this$$primevue2 = this.$primevue) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.config) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.pt) === null || _this$$primevue2 === void 0 ? void 0 : _this$$primevue2.value : (_this$$primevue3 = this.$primevue) === null || _this$$primevue3 === void 0 || (_this$$primevue3 = _this$$primevue3.config) === null || _this$$primevue3 === void 0 ? void 0 : _this$$primevue3.pt;
    (_ref2 = valueInConfig || originalValueInConfig) === null || _ref2 === void 0 || (_ref2 = _ref2[this.$.type.name]) === null || _ref2 === void 0 || (_ref2 = _ref2.hooks) === null || _ref2 === void 0 || (_ref2$onBeforeCreate = _ref2["onBeforeCreate"]) === null || _ref2$onBeforeCreate === void 0 || _ref2$onBeforeCreate.call(_ref2);
  },
  created: function created() {
    this._hook("onCreated");
  },
  beforeMount: function beforeMount2() {
    this._loadStyles();
    this._hook("onBeforeMount");
  },
  mounted: function mounted() {
    this.rootEl = findSingle(this.$el, '[data-pc-name="'.concat(toFlatCase(this.$.type.name), '"]'));
    if (this.rootEl) {
      this.rootEl.setAttribute(this.$attrSelector, "");
      this.rootEl.$pc = _objectSpread$m({
        name: this.$.type.name
      }, this.$params);
    }
    this._hook("onMounted");
  },
  beforeUpdate: function beforeUpdate() {
    this._hook("onBeforeUpdate");
  },
  updated: function updated2() {
    this._hook("onUpdated");
  },
  beforeUnmount: function beforeUnmount() {
    this._hook("onBeforeUnmount");
  },
  unmounted: function unmounted2() {
    this._unloadScopedThemeStyles();
    this._hook("onUnmounted");
  },
  methods: {
    _hook: function _hook2(hookName) {
      if (!this.$options.hostName) {
        var selfHook = this._usePT(this._getPT(this.pt, this.$.type.name), this._getOptionValue, "hooks.".concat(hookName));
        var defaultHook = this._useDefaultPT(this._getOptionValue, "hooks.".concat(hookName));
        selfHook === null || selfHook === void 0 || selfHook();
        defaultHook === null || defaultHook === void 0 || defaultHook();
      }
    },
    _mergeProps: function _mergeProps2(fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return isFunction(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
    },
    _loadStyles: function _loadStyles2() {
      var _this2 = this;
      var _load = function _load2() {
        if (!Base.isStyleNameLoaded("base")) {
          BaseStyle.loadCSS(_this2.$styleOptions);
          _this2._loadGlobalStyles();
          Base.setLoadedStyleName("base");
        }
        _this2._loadThemeStyles();
      };
      _load();
      this._themeChangeListener(_load);
    },
    _loadCoreStyles: function _loadCoreStyles2() {
      var _this$$style, _this$$style2;
      if (!Base.isStyleNameLoaded((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.name) && (_this$$style2 = this.$style) !== null && _this$$style2 !== void 0 && _this$$style2.name) {
        BaseComponentStyle.loadCSS(this.$styleOptions);
        this.$options.style && this.$style.loadCSS(this.$styleOptions);
        Base.setLoadedStyleName(this.$style.name);
      }
    },
    _loadGlobalStyles: function _loadGlobalStyles() {
      var globalCSS = this._useGlobalPT(this._getOptionValue, "global.css", this.$params);
      isNotEmpty(globalCSS) && BaseStyle.load(globalCSS, _objectSpread$m({
        name: "global"
      }, this.$styleOptions));
    },
    _loadThemeStyles: function _loadThemeStyles2() {
      var _this$$style4, _this$$style5;
      if (this.isUnstyled) return;
      if (!config_default.isStyleNameLoaded("common")) {
        var _this$$style3, _this$$style3$getComm;
        var _ref3 = ((_this$$style3 = this.$style) === null || _this$$style3 === void 0 || (_this$$style3$getComm = _this$$style3.getCommonTheme) === null || _this$$style3$getComm === void 0 ? void 0 : _this$$style3$getComm.call(_this$$style3)) || {}, primitive = _ref3.primitive, semantic = _ref3.semantic;
        BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$m({
          name: "primitive-variables"
        }, this.$styleOptions));
        BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$m({
          name: "semantic-variables"
        }, this.$styleOptions));
        BaseStyle.loadTheme(_objectSpread$m({
          name: "global-style"
        }, this.$styleOptions));
        config_default.setLoadedStyleName("common");
      }
      if (!config_default.isStyleNameLoaded((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.name) && (_this$$style5 = this.$style) !== null && _this$$style5 !== void 0 && _this$$style5.name) {
        var _this$$style6, _this$$style6$getComp, _this$$style7, _this$$style8;
        var _ref4 = ((_this$$style6 = this.$style) === null || _this$$style6 === void 0 || (_this$$style6$getComp = _this$$style6.getComponentTheme) === null || _this$$style6$getComp === void 0 ? void 0 : _this$$style6$getComp.call(_this$$style6)) || {}, css4 = _ref4.css;
        (_this$$style7 = this.$style) === null || _this$$style7 === void 0 || _this$$style7.load(css4, _objectSpread$m({
          name: "".concat(this.$style.name, "-variables")
        }, this.$styleOptions));
        (_this$$style8 = this.$style) === null || _this$$style8 === void 0 || _this$$style8.loadTheme(_objectSpread$m({
          name: "".concat(this.$style.name, "-style")
        }, this.$styleOptions));
        config_default.setLoadedStyleName(this.$style.name);
      }
      if (!config_default.isStyleNameLoaded("layer-order")) {
        var _this$$style9, _this$$style9$getLaye;
        var layerOrder = (_this$$style9 = this.$style) === null || _this$$style9 === void 0 || (_this$$style9$getLaye = _this$$style9.getLayerOrderThemeCSS) === null || _this$$style9$getLaye === void 0 ? void 0 : _this$$style9$getLaye.call(_this$$style9);
        BaseStyle.load(layerOrder, _objectSpread$m({
          name: "layer-order",
          first: true
        }, this.$styleOptions));
        config_default.setLoadedStyleName("layer-order");
      }
    },
    _loadScopedThemeStyles: function _loadScopedThemeStyles2(preset) {
      var _this$$style10, _this$$style10$getPre, _this$$style11;
      var _ref5 = ((_this$$style10 = this.$style) === null || _this$$style10 === void 0 || (_this$$style10$getPre = _this$$style10.getPresetTheme) === null || _this$$style10$getPre === void 0 ? void 0 : _this$$style10$getPre.call(_this$$style10, preset, "[".concat(this.$attrSelector, "]"))) || {}, css4 = _ref5.css;
      var scopedStyle = (_this$$style11 = this.$style) === null || _this$$style11 === void 0 ? void 0 : _this$$style11.load(css4, _objectSpread$m({
        name: "".concat(this.$attrSelector, "-").concat(this.$style.name)
      }, this.$styleOptions));
      this.scopedStyleEl = scopedStyle.el;
    },
    _unloadScopedThemeStyles: function _unloadScopedThemeStyles() {
      var _this$scopedStyleEl;
      (_this$scopedStyleEl = this.scopedStyleEl) === null || _this$scopedStyleEl === void 0 || (_this$scopedStyleEl = _this$scopedStyleEl.value) === null || _this$scopedStyleEl === void 0 || _this$scopedStyleEl.remove();
    },
    _themeChangeListener: function _themeChangeListener2() {
      var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
      };
      Base.clearLoadedStyleNames();
      service_default.on("theme:change", callback);
    },
    _getHostInstance: function _getHostInstance(instance) {
      return instance ? this.$options.hostName ? instance.$.type.name === this.$options.hostName ? instance : this._getHostInstance(instance.$parentInstance) : instance.$parentInstance : void 0;
    },
    _getPropValue: function _getPropValue(name) {
      var _this$_getHostInstanc;
      return this[name] || ((_this$_getHostInstanc = this._getHostInstance(this)) === null || _this$_getHostInstanc === void 0 ? void 0 : _this$_getHostInstanc[name]);
    },
    _getOptionValue: function _getOptionValue(options3) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return getKeyValue(options3, key, params);
    },
    _getPTValue: function _getPTValue2() {
      var _this$$primevueConfig2;
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var searchInDefaultPT = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var searchOut = /./g.test(key) && !!params[key.split(".")[0]];
      var _ref6 = this._getPropValue("ptOptions") || ((_this$$primevueConfig2 = this.$primevueConfig) === null || _this$$primevueConfig2 === void 0 ? void 0 : _this$$primevueConfig2.ptOptions) || {}, _ref6$mergeSections = _ref6.mergeSections, mergeSections = _ref6$mergeSections === void 0 ? true : _ref6$mergeSections, _ref6$mergeProps = _ref6.mergeProps, useMergeProps = _ref6$mergeProps === void 0 ? false : _ref6$mergeProps;
      var global2 = searchInDefaultPT ? searchOut ? this._useGlobalPT(this._getPTClassValue, key, params) : this._useDefaultPT(this._getPTClassValue, key, params) : void 0;
      var self2 = searchOut ? void 0 : this._getPTSelf(obj, this._getPTClassValue, key, _objectSpread$m(_objectSpread$m({}, params), {}, {
        global: global2 || {}
      }));
      var datasets = this._getPTDatasets(key);
      return mergeSections || !mergeSections && self2 ? useMergeProps ? this._mergeProps(useMergeProps, global2, self2, datasets) : _objectSpread$m(_objectSpread$m(_objectSpread$m({}, global2), self2), datasets) : _objectSpread$m(_objectSpread$m({}, self2), datasets);
    },
    _getPTSelf: function _getPTSelf() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return mergeProps(
        this._usePT.apply(this, [this._getPT(obj, this.$name)].concat(args)),
        // Exp; <component :pt="{}"
        this._usePT.apply(this, [this.$_attrsPT].concat(args))
        // Exp; <component :pt:[passthrough_key]:[attribute]="{value}" or <component :pt:[passthrough_key]="() =>{value}"
      );
    },
    _getPTDatasets: function _getPTDatasets2() {
      var _this$pt4, _this$pt5;
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var datasetPrefix = "data-pc-";
      var isExtended = key === "root" && isNotEmpty((_this$pt4 = this.pt) === null || _this$pt4 === void 0 ? void 0 : _this$pt4["data-pc-section"]);
      return key !== "transition" && _objectSpread$m(_objectSpread$m({}, key === "root" && _objectSpread$m(_defineProperty$n({}, "".concat(datasetPrefix, "name"), toFlatCase(isExtended ? (_this$pt5 = this.pt) === null || _this$pt5 === void 0 ? void 0 : _this$pt5["data-pc-section"] : this.$.type.name)), isExtended && _defineProperty$n({}, "".concat(datasetPrefix, "extend"), toFlatCase(this.$.type.name)))), {}, _defineProperty$n({}, "".concat(datasetPrefix, "section"), toFlatCase(key)));
    },
    _getPTClassValue: function _getPTClassValue() {
      var value3 = this._getOptionValue.apply(this, arguments);
      return isString$3(value3) || isArray$2(value3) ? {
        "class": value3
      } : value3;
    },
    _getPT: function _getPT2(pt) {
      var _this3 = this;
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var callback = arguments.length > 2 ? arguments[2] : void 0;
      var getValue2 = function getValue3(value3) {
        var _ref8;
        var checkSameKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var computedValue = callback ? callback(value3) : value3;
        var _key = toFlatCase(key);
        var _cKey = toFlatCase(_this3.$name);
        return (_ref8 = checkSameKey ? _key !== _cKey ? computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key] : void 0 : computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _ref8 !== void 0 ? _ref8 : computedValue;
      };
      return pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept") ? {
        _usept: pt["_usept"],
        originalValue: getValue2(pt.originalValue),
        value: getValue2(pt.value)
      } : getValue2(pt, true);
    },
    _usePT: function _usePT2(pt, callback, key, params) {
      var fn = function fn2(value4) {
        return callback(value4, key, params);
      };
      if (pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept")) {
        var _this$$primevueConfig3;
        var _ref9 = pt["_usept"] || ((_this$$primevueConfig3 = this.$primevueConfig) === null || _this$$primevueConfig3 === void 0 ? void 0 : _this$$primevueConfig3.ptOptions) || {}, _ref9$mergeSections = _ref9.mergeSections, mergeSections = _ref9$mergeSections === void 0 ? true : _ref9$mergeSections, _ref9$mergeProps = _ref9.mergeProps, useMergeProps = _ref9$mergeProps === void 0 ? false : _ref9$mergeProps;
        var originalValue = fn(pt.originalValue);
        var value3 = fn(pt.value);
        if (originalValue === void 0 && value3 === void 0) return void 0;
        else if (isString$3(value3)) return value3;
        else if (isString$3(originalValue)) return originalValue;
        return mergeSections || !mergeSections && value3 ? useMergeProps ? this._mergeProps(useMergeProps, originalValue, value3) : _objectSpread$m(_objectSpread$m({}, originalValue), value3) : value3;
      }
      return fn(pt);
    },
    _useGlobalPT: function _useGlobalPT(callback, key, params) {
      return this._usePT(this.globalPT, callback, key, params);
    },
    _useDefaultPT: function _useDefaultPT2(callback, key, params) {
      return this._usePT(this.defaultPT, callback, key, params);
    },
    ptm: function ptm() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._getPTValue(this.pt, key, _objectSpread$m(_objectSpread$m({}, this.$params), params));
    },
    ptmi: function ptmi() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return mergeProps(this.$_attrsWithoutPT, this.ptm(key, params));
    },
    ptmo: function ptmo() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this._getPTValue(obj, key, _objectSpread$m({
        instance: this
      }, params), false);
    },
    cx: function cx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return !this.isUnstyled ? this._getOptionValue(this.$style.classes, key, _objectSpread$m(_objectSpread$m({}, this.$params), params)) : void 0;
    },
    sx: function sx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (when) {
        var self2 = this._getOptionValue(this.$style.inlineStyles, key, _objectSpread$m(_objectSpread$m({}, this.$params), params));
        var base = this._getOptionValue(BaseComponentStyle.inlineStyles, key, _objectSpread$m(_objectSpread$m({}, this.$params), params));
        return [base, self2];
      }
      return void 0;
    }
  },
  computed: {
    globalPT: function globalPT() {
      var _this$$primevueConfig4, _this4 = this;
      return this._getPT((_this$$primevueConfig4 = this.$primevueConfig) === null || _this$$primevueConfig4 === void 0 ? void 0 : _this$$primevueConfig4.pt, void 0, function(value3) {
        return resolve(value3, {
          instance: _this4
        });
      });
    },
    defaultPT: function defaultPT() {
      var _this$$primevueConfig5, _this5 = this;
      return this._getPT((_this$$primevueConfig5 = this.$primevueConfig) === null || _this$$primevueConfig5 === void 0 ? void 0 : _this$$primevueConfig5.pt, void 0, function(value3) {
        return _this5._getOptionValue(value3, _this5.$name, _objectSpread$m({}, _this5.$params)) || resolve(value3, _objectSpread$m({}, _this5.$params));
      });
    },
    isUnstyled: function isUnstyled() {
      var _this$$primevueConfig6;
      return this.unstyled !== void 0 ? this.unstyled : (_this$$primevueConfig6 = this.$primevueConfig) === null || _this$$primevueConfig6 === void 0 ? void 0 : _this$$primevueConfig6.unstyled;
    },
    $theme: function $theme() {
      var _this$$primevueConfig7;
      return (_this$$primevueConfig7 = this.$primevueConfig) === null || _this$$primevueConfig7 === void 0 ? void 0 : _this$$primevueConfig7.theme;
    },
    $style: function $style() {
      return _objectSpread$m(_objectSpread$m({
        classes: void 0,
        inlineStyles: void 0,
        load: function load2() {
        },
        loadCSS: function loadCSS2() {
        },
        loadTheme: function loadTheme2() {
        }
      }, (this._getHostInstance(this) || {}).$style), this.$options.style);
    },
    $styleOptions: function $styleOptions() {
      var _this$$primevueConfig8;
      return {
        nonce: (_this$$primevueConfig8 = this.$primevueConfig) === null || _this$$primevueConfig8 === void 0 || (_this$$primevueConfig8 = _this$$primevueConfig8.csp) === null || _this$$primevueConfig8 === void 0 ? void 0 : _this$$primevueConfig8.nonce
      };
    },
    $primevueConfig: function $primevueConfig() {
      var _this$$primevue4;
      return (_this$$primevue4 = this.$primevue) === null || _this$$primevue4 === void 0 ? void 0 : _this$$primevue4.config;
    },
    $name: function $name() {
      return this.$options.hostName || this.$.type.name;
    },
    $params: function $params() {
      var parentInstance = this._getHostInstance(this) || this.$parent;
      return {
        instance: this,
        props: this.$props,
        state: this.$data,
        attrs: this.$attrs,
        parent: {
          instance: parentInstance,
          props: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$props,
          state: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$data,
          attrs: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$attrs
        }
      };
    },
    $_attrsPT: function $_attrsPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref10) {
        var _ref11 = _slicedToArray$3(_ref10, 1), key = _ref11[0];
        return key === null || key === void 0 ? void 0 : key.startsWith("pt:");
      }).reduce(function(result, _ref12) {
        var _ref13 = _slicedToArray$3(_ref12, 2), key = _ref13[0], value3 = _ref13[1];
        var _key$split = key.split(":"), _key$split2 = _toArray(_key$split), rest = _key$split2.slice(1);
        rest === null || rest === void 0 || rest.reduce(function(currentObj, nestedKey, index2, array) {
          !currentObj[nestedKey] && (currentObj[nestedKey] = index2 === array.length - 1 ? value3 : {});
          return currentObj[nestedKey];
        }, result);
        return result;
      }, {});
    },
    $_attrsWithoutPT: function $_attrsWithoutPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref14) {
        var _ref15 = _slicedToArray$3(_ref14, 1), key = _ref15[0];
        return !(key !== null && key !== void 0 && key.startsWith("pt:"));
      }).reduce(function(acc, _ref16) {
        var _ref17 = _slicedToArray$3(_ref16, 2), key = _ref17[0], value3 = _ref17[1];
        acc[key] = value3;
        return acc;
      }, {});
    },
    $attrSelector: function $attrSelector() {
      return UniqueComponentId("pc");
    }
  }
};
var theme$v = function theme4(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-blockui {\n    position: relative;\n}\n\n.p-blockui-mask {\n    border-radius: ".concat(dt3("blockui.border.radius"), ";\n}\n\n.p-blockui-mask.p-overlay-mask {\n    position: absolute;\n}\n\n.p-blockui-mask-document.p-overlay-mask {\n    position: fixed;\n}\n");
};
var classes$y = {
  root: "p-blockui"
};
var BlockUIStyle = BaseStyle.extend({
  name: "blockui",
  theme: theme$v,
  classes: classes$y
});
var script$1$z = {
  name: "BaseBlockUI",
  "extends": script$1a,
  props: {
    blocked: {
      type: Boolean,
      "default": false
    },
    fullScreen: {
      type: Boolean,
      "default": false
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    }
  },
  style: BlockUIStyle,
  provide: function provide2() {
    return {
      $pcBlockUI: this,
      $parentInstance: this
    };
  }
};
var script$19 = {
  name: "BlockUI",
  "extends": script$1$z,
  inheritAttrs: false,
  emits: ["block", "unblock"],
  mask: null,
  data: function data() {
    return {
      isBlocked: false
    };
  },
  watch: {
    blocked: function blocked(newValue) {
      if (newValue === true) this.block();
      else this.unblock();
    }
  },
  mounted: function mounted2() {
    if (this.blocked) {
      this.block();
    }
  },
  methods: {
    block: function block() {
      var styleClass = "p-blockui-mask p-overlay-mask p-overlay-mask-enter";
      if (this.fullScreen) {
        styleClass += " p-blockui-mask-document";
        this.mask = createElement("div", {
          style: {
            position: "fixed",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          },
          "class": !this.isUnstyled && styleClass,
          "p-bind": this.ptm("mask")
        });
        document.body.appendChild(this.mask);
        blockBodyScroll();
        document.activeElement.blur();
      } else {
        this.mask = createElement("div", {
          style: {
            position: "absolute",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          },
          "class": !this.isUnstyled && styleClass,
          "p-bind": this.ptm("mask")
        });
        this.$refs.container.appendChild(this.mask);
      }
      if (this.autoZIndex) {
        ZIndex.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
      }
      this.isBlocked = true;
      this.$emit("block");
    },
    unblock: function unblock() {
      var _this = this;
      !this.isUnstyled && addClass(this.mask, "p-overlay-mask-leave");
      if (hasCSSAnimation(this.mask) > 0) {
        this.mask.addEventListener("animationend", function() {
          _this.removeMask();
        });
      } else {
        this.removeMask();
      }
    },
    removeMask: function removeMask() {
      ZIndex.clear(this.mask);
      if (this.fullScreen) {
        document.body.removeChild(this.mask);
        unblockBodyScroll();
      } else {
        var _this$$refs$container;
        (_this$$refs$container = this.$refs.container) === null || _this$$refs$container === void 0 || _this$$refs$container.removeChild(this.mask);
      }
      this.isBlocked = false;
      this.$emit("unblock");
    }
  }
};
var _hoisted_1$14 = ["aria-busy"];
function render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root"),
    "aria-busy": $data.isBlocked
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16, _hoisted_1$14);
}
script$19.render = render$17;
var theme$u = function theme5(_ref) {
  var dt3 = _ref.dt;
  return '\n.p-progressspinner {\n    position: relative;\n    margin: 0 auto;\n    width: 100px;\n    height: 100px;\n    display: inline-block;\n}\n\n.p-progressspinner::before {\n    content: "";\n    display: block;\n    padding-top: 100%;\n}\n\n.p-progressspinner-spin {\n    height: 100%;\n    transform-origin: center center;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n    animation: p-progressspinner-rotate 2s linear infinite;\n}\n\n.p-progressspinner-circle {\n    stroke-dasharray: 89, 200;\n    stroke-dashoffset: 0;\n    stroke: '.concat(dt3("progressspinner.color.1"), ";\n    animation: p-progressspinner-dash 1.5s ease-in-out infinite, p-progressspinner-color 6s ease-in-out infinite;\n    stroke-linecap: round;\n}\n\n@keyframes p-progressspinner-rotate {\n    100% {\n        transform: rotate(360deg);\n    }\n}\n@keyframes p-progressspinner-dash {\n    0% {\n        stroke-dasharray: 1, 200;\n        stroke-dashoffset: 0;\n    }\n    50% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -35px;\n    }\n    100% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -124px;\n    }\n}\n@keyframes p-progressspinner-color {\n    100%,\n    0% {\n        stroke: ").concat(dt3("progressspinner.color.1"), ";\n    }\n    40% {\n        stroke: ").concat(dt3("progressspinner.color.2"), ";\n    }\n    66% {\n        stroke: ").concat(dt3("progressspinner.color.3"), ";\n    }\n    80%,\n    90% {\n        stroke: ").concat(dt3("progressspinner.color.4"), ";\n    }\n}\n");
};
var classes$x = {
  root: "p-progressspinner",
  spin: "p-progressspinner-spin",
  circle: "p-progressspinner-circle"
};
var ProgressSpinnerStyle = BaseStyle.extend({
  name: "progressspinner",
  theme: theme$u,
  classes: classes$x
});
var script$1$y = {
  name: "BaseProgressSpinner",
  "extends": script$1a,
  props: {
    strokeWidth: {
      type: String,
      "default": "2"
    },
    fill: {
      type: String,
      "default": "none"
    },
    animationDuration: {
      type: String,
      "default": "2s"
    }
  },
  style: ProgressSpinnerStyle,
  provide: function provide3() {
    return {
      $pcProgressSpinner: this,
      $parentInstance: this
    };
  }
};
var script$18 = {
  name: "ProgressSpinner",
  "extends": script$1$y,
  inheritAttrs: false,
  computed: {
    svgStyle: function svgStyle() {
      return {
        "animation-duration": this.animationDuration
      };
    }
  }
};
var _hoisted_1$13 = ["fill", "stroke-width"];
function render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "progressbar"
  }, _ctx.ptmi("root")), [(openBlock(), createElementBlock("svg", mergeProps({
    "class": _ctx.cx("spin"),
    viewBox: "25 25 50 50",
    style: $options.svgStyle
  }, _ctx.ptm("spin")), [createBaseVNode("circle", mergeProps({
    "class": _ctx.cx("circle"),
    cx: "50",
    cy: "50",
    r: "20",
    fill: _ctx.fill,
    "stroke-width": _ctx.strokeWidth,
    strokeMiterlimit: "10"
  }, _ctx.ptm("circle")), null, 16, _hoisted_1$13)], 16))], 16);
}
script$18.render = render$16;
var theme$t = function theme6(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-badge {\n    display: inline-flex;\n    border-radius: ".concat(dt3("badge.border.radius"), ";\n    align-items: center;\n    justify-content: center;\n    padding: ").concat(dt3("badge.padding"), ";\n    background: ").concat(dt3("badge.primary.background"), ";\n    color: ").concat(dt3("badge.primary.color"), ";\n    font-size: ").concat(dt3("badge.font.size"), ";\n    font-weight: ").concat(dt3("badge.font.weight"), ";\n    min-width: ").concat(dt3("badge.min.width"), ";\n    height: ").concat(dt3("badge.height"), ";\n}\n\n.p-badge-dot {\n    width: ").concat(dt3("badge.dot.size"), ";\n    min-width: ").concat(dt3("badge.dot.size"), ";\n    height: ").concat(dt3("badge.dot.size"), ";\n    border-radius: 50%;\n    padding: 0;\n}\n\n.p-badge-circle {\n    padding: 0;\n    border-radius: 50%;\n}\n\n.p-badge-secondary {\n    background: ").concat(dt3("badge.secondary.background"), ";\n    color: ").concat(dt3("badge.secondary.color"), ";\n}\n\n.p-badge-success {\n    background: ").concat(dt3("badge.success.background"), ";\n    color: ").concat(dt3("badge.success.color"), ";\n}\n\n.p-badge-info {\n    background: ").concat(dt3("badge.info.background"), ";\n    color: ").concat(dt3("badge.info.color"), ";\n}\n\n.p-badge-warn {\n    background: ").concat(dt3("badge.warn.background"), ";\n    color: ").concat(dt3("badge.warn.color"), ";\n}\n\n.p-badge-danger {\n    background: ").concat(dt3("badge.danger.background"), ";\n    color: ").concat(dt3("badge.danger.color"), ";\n}\n\n.p-badge-contrast {\n    background: ").concat(dt3("badge.contrast.background"), ";\n    color: ").concat(dt3("badge.contrast.color"), ";\n}\n\n.p-badge-sm {\n    font-size: ").concat(dt3("badge.sm.font.size"), ";\n    min-width: ").concat(dt3("badge.sm.min.width"), ";\n    height: ").concat(dt3("badge.sm.height"), ";\n}\n\n.p-badge-lg {\n    font-size: ").concat(dt3("badge.lg.font.size"), ";\n    min-width: ").concat(dt3("badge.lg.min.width"), ";\n    height: ").concat(dt3("badge.lg.height"), ";\n}\n\n.p-badge-xl {\n    font-size: ").concat(dt3("badge.xl.font.size"), ";\n    min-width: ").concat(dt3("badge.xl.min.width"), ";\n    height: ").concat(dt3("badge.xl.height"), ";\n}\n");
};
var classes$w = {
  root: function root(_ref2) {
    var props = _ref2.props, instance = _ref2.instance;
    return ["p-badge p-component", {
      "p-badge-circle": isNotEmpty(props.value) && String(props.value).length === 1,
      "p-badge-dot": isEmpty(props.value) && !instance.$slots["default"],
      "p-badge-sm": props.size === "small",
      "p-badge-lg": props.size === "large",
      "p-badge-xl": props.size === "xlarge",
      "p-badge-info": props.severity === "info",
      "p-badge-success": props.severity === "success",
      "p-badge-warn": props.severity === "warn",
      "p-badge-danger": props.severity === "danger",
      "p-badge-secondary": props.severity === "secondary",
      "p-badge-contrast": props.severity === "contrast"
    }];
  }
};
var BadgeStyle = BaseStyle.extend({
  name: "badge",
  theme: theme$t,
  classes: classes$w
});
var script$1$x = {
  name: "BaseBadge",
  "extends": script$1a,
  props: {
    value: {
      type: [String, Number],
      "default": null
    },
    severity: {
      type: String,
      "default": null
    },
    size: {
      type: String,
      "default": null
    }
  },
  style: BadgeStyle,
  provide: function provide4() {
    return {
      $pcBadge: this,
      $parentInstance: this
    };
  }
};
var script$17 = {
  name: "Badge",
  "extends": script$1$x,
  inheritAttrs: false
};
function render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [createTextVNode(toDisplayString$1(_ctx.value), 1)];
  })], 16);
}
script$17.render = render$15;
var theme$s = function theme7(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-overlaybadge {\n    position: relative;\n}\n\n.p-overlaybadge .p-badge {\n    position: absolute;\n    top: 0;\n    right: 0;\n    transform: translate(50%, -50%);\n    transform-origin: 100% 0;\n    margin: 0;\n    outline-width: ".concat(dt3("overlaybadge.outline.width"), ";\n    outline-style: solid;\n    outline-color: ").concat(dt3("overlaybadge.outline.color"), ";\n}\n");
};
var classes$v = {
  root: "p-overlaybadge"
};
var OverlayBadgeStyle = BaseStyle.extend({
  name: "overlaybadge",
  theme: theme$s,
  classes: classes$v
});
var script$1$w = {
  name: "OverlayBadge",
  "extends": script$17,
  style: OverlayBadgeStyle,
  provide: function provide5() {
    return {
      $pcOverlayBadge: this,
      $parentInstance: this
    };
  }
};
var script$16 = {
  name: "OverlayBadge",
  "extends": script$1$w,
  inheritAttrs: false,
  components: {
    Badge: script$17
  }
};
function render$14(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Badge = resolveComponent("Badge");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default"), createVNode(_component_Badge, mergeProps(_ctx.$props, {
    pt: _ctx.ptm("pcBadge")
  }), null, 16, ["pt"])], 16);
}
script$16.render = render$14;
var css = "\n.p-icon {\n    display: inline-block;\n}\n\n.p-icon-spin {\n    -webkit-animation: p-icon-spin 2s infinite linear;\n    animation: p-icon-spin 2s infinite linear;\n}\n\n@-webkit-keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n\n@keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n";
var BaseIconStyle = BaseStyle.extend({
  name: "baseicon",
  css
});
function _typeof$n(o) {
  "@babel/helpers - typeof";
  return _typeof$n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$n(o);
}
function ownKeys$l(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$l(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$l(Object(t), true).forEach(function(r2) {
      _defineProperty$m(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$m(e, r, t) {
  return (r = _toPropertyKey$l(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$l(t) {
  var i2 = _toPrimitive$l(t, "string");
  return "symbol" == _typeof$n(i2) ? i2 : i2 + "";
}
function _toPrimitive$l(t, r) {
  if ("object" != _typeof$n(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$n(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var script$15 = {
  name: "BaseIcon",
  "extends": script$1a,
  props: {
    label: {
      type: String,
      "default": void 0
    },
    spin: {
      type: Boolean,
      "default": false
    }
  },
  style: BaseIconStyle,
  provide: function provide6() {
    return {
      $pcIcon: this,
      $parentInstance: this
    };
  },
  methods: {
    pti: function pti() {
      var isLabelEmpty = isEmpty(this.label);
      return _objectSpread$l(_objectSpread$l({}, !this.isUnstyled && {
        "class": ["p-icon", {
          "p-icon-spin": this.spin
        }]
      }), {}, {
        role: !isLabelEmpty ? "img" : void 0,
        "aria-label": !isLabelEmpty ? this.label : void 0,
        "aria-hidden": isLabelEmpty
      });
    }
  }
};
var script$14 = {
  name: "SpinnerIcon",
  "extends": script$15
};
var _hoisted_1$12 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$R = [_hoisted_1$12];
function render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$R, 16);
}
script$14.render = render$13;
var theme$r = function theme8(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-ink {\n    display: block;\n    position: absolute;\n    background: ".concat(dt3("ripple.background"), ";\n    border-radius: 100%;\n    transform: scale(0);\n    pointer-events: none;\n}\n\n.p-ink-active {\n    animation: ripple 0.4s linear;\n}\n\n@keyframes ripple {\n    100% {\n        opacity: 0;\n        transform: scale(2.5);\n    }\n}\n");
};
var classes$u = {
  root: "p-ink"
};
var RippleStyle = BaseStyle.extend({
  name: "ripple-directive",
  theme: theme$r,
  classes: classes$u
});
var BaseRipple = BaseDirective.extend({
  style: RippleStyle
});
function _typeof$m(o) {
  "@babel/helpers - typeof";
  return _typeof$m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$m(o);
}
function _toConsumableArray$e(r) {
  return _arrayWithoutHoles$e(r) || _iterableToArray$e(r) || _unsupportedIterableToArray$g(r) || _nonIterableSpread$e();
}
function _nonIterableSpread$e() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$g(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$g(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$g(r, a) : void 0;
  }
}
function _iterableToArray$e(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$e(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$g(r);
}
function _arrayLikeToArray$g(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _defineProperty$l(e, r, t) {
  return (r = _toPropertyKey$k(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$k(t) {
  var i2 = _toPrimitive$k(t, "string");
  return "symbol" == _typeof$m(i2) ? i2 : i2 + "";
}
function _toPrimitive$k(t, r) {
  if ("object" != _typeof$m(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$m(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var Ripple = BaseRipple.extend("ripple", {
  watch: {
    "config.ripple": function configRipple(newValue) {
      if (newValue) {
        this.createRipple(this.$host);
        this.bindEvents(this.$host);
        this.$host.setAttribute("data-pd-ripple", true);
        this.$host.style["overflow"] = "hidden";
        this.$host.style["position"] = "relative";
      } else {
        this.remove(this.$host);
        this.$host.removeAttribute("data-pd-ripple");
      }
    }
  },
  unmounted: function unmounted3(el) {
    this.remove(el);
  },
  timeout: void 0,
  methods: {
    bindEvents: function bindEvents2(el) {
      el.addEventListener("mousedown", this.onMouseDown.bind(this));
    },
    unbindEvents: function unbindEvents2(el) {
      el.removeEventListener("mousedown", this.onMouseDown.bind(this));
    },
    createRipple: function createRipple(el) {
      var ink = createElement("span", _defineProperty$l(_defineProperty$l({
        role: "presentation",
        "aria-hidden": true,
        "data-p-ink": true,
        "data-p-ink-active": false,
        "class": !this.isUnstyled() && this.cx("root"),
        onAnimationEnd: this.onAnimationEnd.bind(this)
      }, this.$attrSelector, ""), "p-bind", this.ptm("root")));
      el.appendChild(ink);
      this.$el = ink;
    },
    remove: function remove3(el) {
      var ink = this.getInk(el);
      if (ink) {
        this.$host.style["overflow"] = "";
        this.$host.style["position"] = "";
        this.unbindEvents(el);
        ink.removeEventListener("animationend", this.onAnimationEnd);
        ink.remove();
      }
    },
    onMouseDown: function onMouseDown(event2) {
      var _this = this;
      var target = event2.currentTarget;
      var ink = this.getInk(target);
      if (!ink || getComputedStyle(ink, null).display === "none") {
        return;
      }
      !this.isUnstyled() && removeClass(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "false");
      if (!getHeight(ink) && !getWidth(ink)) {
        var d = Math.max(getOuterWidth(target), getOuterHeight(target));
        ink.style.height = d + "px";
        ink.style.width = d + "px";
      }
      var offset = getOffset(target);
      var x2 = event2.pageX - offset.left + document.body.scrollTop - getWidth(ink) / 2;
      var y2 = event2.pageY - offset.top + document.body.scrollLeft - getHeight(ink) / 2;
      ink.style.top = y2 + "px";
      ink.style.left = x2 + "px";
      !this.isUnstyled() && addClass(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "true");
      this.timeout = setTimeout(function() {
        if (ink) {
          !_this.isUnstyled() && removeClass(ink, "p-ink-active");
          ink.setAttribute("data-p-ink-active", "false");
        }
      }, 401);
    },
    onAnimationEnd: function onAnimationEnd(event2) {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      !this.isUnstyled() && removeClass(event2.currentTarget, "p-ink-active");
      event2.currentTarget.setAttribute("data-p-ink-active", "false");
    },
    getInk: function getInk(el) {
      return el && el.children ? _toConsumableArray$e(el.children).find(function(child) {
        return getAttribute(child, "data-pc-name") === "ripple";
      }) : void 0;
    }
  }
});
function _typeof$l(o) {
  "@babel/helpers - typeof";
  return _typeof$l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$l(o);
}
function _defineProperty$k(e, r, t) {
  return (r = _toPropertyKey$j(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$j(t) {
  var i2 = _toPrimitive$j(t, "string");
  return "symbol" == _typeof$l(i2) ? i2 : i2 + "";
}
function _toPrimitive$j(t, r) {
  if ("object" != _typeof$l(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$l(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var theme$q = function theme9(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-button {\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    color: ".concat(dt3("button.primary.color"), ";\n    background: ").concat(dt3("button.primary.background"), ";\n    border: 1px solid ").concat(dt3("button.primary.border.color"), ";\n    padding: ").concat(dt3("button.padding.y"), " ").concat(dt3("button.padding.x"), ";\n    font-size: 1rem;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    transition: background ").concat(dt3("button.transition.duration"), ", color ").concat(dt3("button.transition.duration"), ", border-color ").concat(dt3("button.transition.duration"), ",\n            outline-color ").concat(dt3("button.transition.duration"), ", box-shadow ").concat(dt3("button.transition.duration"), ";\n    border-radius: ").concat(dt3("button.border.radius"), ";\n    outline-color: transparent;\n    gap: ").concat(dt3("button.gap"), ";\n}\n\n.p-button:disabled {\n    cursor: default;\n}\n\n.p-button-icon-right {\n    order: 1;\n}\n\n.p-button-icon-bottom {\n    order: 2;\n}\n\n.p-button-icon-only {\n    width: ").concat(dt3("button.icon.only.width"), ";\n    padding-left: 0;\n    padding-right: 0;\n    gap: 0;\n}\n\n.p-button-icon-only.p-button-rounded {\n    border-radius: 50%;\n    height: ").concat(dt3("button.icon.only.width"), ";\n}\n\n.p-button-icon-only .p-button-label {\n    visibility: hidden;\n    width: 0;\n}\n\n.p-button-sm {\n    font-size: ").concat(dt3("button.sm.font.size"), ";\n    padding: ").concat(dt3("button.sm.padding.y"), " ").concat(dt3("button.sm.padding.x"), ";\n}\n\n.p-button-sm .p-button-icon {\n    font-size: ").concat(dt3("button.sm.font.size"), ";\n}\n\n.p-button-lg {\n    font-size: ").concat(dt3("button.lg.font.size"), ";\n    padding: ").concat(dt3("button.lg.padding.y"), " ").concat(dt3("button.lg.padding.x"), ";\n}\n\n.p-button-lg .p-button-icon {\n    font-size: ").concat(dt3("button.lg.font.size"), ";\n}\n\n.p-button-vertical {\n    flex-direction: column;\n}\n\n.p-button-label {\n    font-weight: ").concat(dt3("button.label.font.weight"), ";\n}\n\n.p-button-fluid {\n    width: 100%;\n}\n\n.p-button-fluid.p-button-icon-only {\n    width: ").concat(dt3("button.icon.only.width"), ";\n}\n\n.p-button:not(:disabled):hover {\n    background: ").concat(dt3("button.primary.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.primary.hover.border.color"), ";\n    color: ").concat(dt3("button.primary.hover.color"), ";\n}\n\n.p-button:not(:disabled):active {\n    background: ").concat(dt3("button.primary.active.background"), ";\n    border: 1px solid ").concat(dt3("button.primary.active.border.color"), ";\n    color: ").concat(dt3("button.primary.active.color"), ";\n}\n\n.p-button:focus-visible {\n    box-shadow: ").concat(dt3("button.primary.focus.ring.shadow"), ";\n    outline: ").concat(dt3("button.focus.ring.width"), " ").concat(dt3("button.focus.ring.style"), " ").concat(dt3("button.primary.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("button.focus.ring.offset"), ";\n}\n\n.p-button .p-badge {\n    min-width: ").concat(dt3("button.badge.size"), ";\n    height: ").concat(dt3("button.badge.size"), ";\n    line-height: ").concat(dt3("button.badge.size"), ";\n}\n\n.p-button-raised {\n    box-shadow: ").concat(dt3("button.raised.shadow"), ";\n}\n\n.p-button-rounded {\n    border-radius: ").concat(dt3("button.rounded.border.radius"), ";\n}\n\n.p-button-secondary {\n    background: ").concat(dt3("button.secondary.background"), ";\n    border: 1px solid ").concat(dt3("button.secondary.border.color"), ";\n    color: ").concat(dt3("button.secondary.color"), ";\n}\n\n.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt3("button.secondary.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.secondary.hover.border.color"), ";\n    color: ").concat(dt3("button.secondary.hover.color"), ";\n}\n\n.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt3("button.secondary.active.background"), ";\n    border: 1px solid ").concat(dt3("button.secondary.active.border.color"), ";\n    color: ").concat(dt3("button.secondary.active.color"), ";\n}\n\n.p-button-secondary:focus-visible {\n    outline-color: ").concat(dt3("button.secondary.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.secondary.focus.ring.shadow"), ";\n}\n\n.p-button-success {\n    background: ").concat(dt3("button.success.background"), ";\n    border: 1px solid ").concat(dt3("button.success.border.color"), ";\n    color: ").concat(dt3("button.success.color"), ";\n}\n\n.p-button-success:not(:disabled):hover {\n    background: ").concat(dt3("button.success.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.success.hover.border.color"), ";\n    color: ").concat(dt3("button.success.hover.color"), ";\n}\n\n.p-button-success:not(:disabled):active {\n    background: ").concat(dt3("button.success.active.background"), ";\n    border: 1px solid ").concat(dt3("button.success.active.border.color"), ";\n    color: ").concat(dt3("button.success.active.color"), ";\n}\n\n.p-button-success:focus-visible {\n    outline-color: ").concat(dt3("button.success.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.success.focus.ring.shadow"), ";\n}\n\n.p-button-info {\n    background: ").concat(dt3("button.info.background"), ";\n    border: 1px solid ").concat(dt3("button.info.border.color"), ";\n    color: ").concat(dt3("button.info.color"), ";\n}\n\n.p-button-info:not(:disabled):hover {\n    background: ").concat(dt3("button.info.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.info.hover.border.color"), ";\n    color: ").concat(dt3("button.info.hover.color"), ";\n}\n\n.p-button-info:not(:disabled):active {\n    background: ").concat(dt3("button.info.active.background"), ";\n    border: 1px solid ").concat(dt3("button.info.active.border.color"), ";\n    color: ").concat(dt3("button.info.active.color"), ";\n}\n\n.p-button-info:focus-visible {\n    outline-color: ").concat(dt3("button.info.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.info.focus.ring.shadow"), ";\n}\n\n.p-button-warn {\n    background: ").concat(dt3("button.warn.background"), ";\n    border: 1px solid ").concat(dt3("button.warn.border.color"), ";\n    color: ").concat(dt3("button.warn.color"), ";\n}\n\n.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt3("button.warn.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.warn.hover.border.color"), ";\n    color: ").concat(dt3("button.warn.hover.color"), ";\n}\n\n.p-button-warn:not(:disabled):active {\n    background: ").concat(dt3("button.warn.active.background"), ";\n    border: 1px solid ").concat(dt3("button.warn.active.border.color"), ";\n    color: ").concat(dt3("button.warn.active.color"), ";\n}\n\n.p-button-warn:focus-visible {\n    outline-color: ").concat(dt3("button.warn.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.warn.focus.ring.shadow"), ";\n}\n\n.p-button-help {\n    background: ").concat(dt3("button.help.background"), ";\n    border: 1px solid ").concat(dt3("button.help.border.color"), ";\n    color: ").concat(dt3("button.help.color"), ";\n}\n\n.p-button-help:not(:disabled):hover {\n    background: ").concat(dt3("button.help.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.help.hover.border.color"), ";\n    color: ").concat(dt3("button.help.hover.color"), ";\n}\n\n.p-button-help:not(:disabled):active {\n    background: ").concat(dt3("button.help.active.background"), ";\n    border: 1px solid ").concat(dt3("button.help.active.border.color"), ";\n    color: ").concat(dt3("button.help.active.color"), ";\n}\n\n.p-button-help:focus-visible {\n    outline-color: ").concat(dt3("button.help.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.help.focus.ring.shadow"), ";\n}\n\n.p-button-danger {\n    background: ").concat(dt3("button.danger.background"), ";\n    border: 1px solid ").concat(dt3("button.danger.border.color"), ";\n    color: ").concat(dt3("button.danger.color"), ";\n}\n\n.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt3("button.danger.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.danger.hover.border.color"), ";\n    color: ").concat(dt3("button.danger.hover.color"), ";\n}\n\n.p-button-danger:not(:disabled):active {\n    background: ").concat(dt3("button.danger.active.background"), ";\n    border: 1px solid ").concat(dt3("button.danger.active.border.color"), ";\n    color: ").concat(dt3("button.danger.active.color"), ";\n}\n\n.p-button-danger:focus-visible {\n    outline-color: ").concat(dt3("button.danger.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.danger.focus.ring.shadow"), ";\n}\n\n.p-button-contrast {\n    background: ").concat(dt3("button.contrast.background"), ";\n    border: 1px solid ").concat(dt3("button.contrast.border.color"), ";\n    color: ").concat(dt3("button.contrast.color"), ";\n}\n\n.p-button-contrast:not(:disabled):hover {\n    background: ").concat(dt3("button.contrast.hover.background"), ";\n    border: 1px solid ").concat(dt3("button.contrast.hover.border.color"), ";\n    color: ").concat(dt3("button.contrast.hover.color"), ";\n}\n\n.p-button-contrast:not(:disabled):active {\n    background: ").concat(dt3("button.contrast.active.background"), ";\n    border: 1px solid ").concat(dt3("button.contrast.active.border.color"), ";\n    color: ").concat(dt3("button.contrast.active.color"), ";\n}\n\n.p-button-contrast:focus-visible {\n    outline-color: ").concat(dt3("button.contrast.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("button.contrast.focus.ring.shadow"), ";\n}\n\n.p-button-outlined {\n    background: transparent;\n    border-color: ").concat(dt3("button.outlined.primary.border.color"), ";\n    color: ").concat(dt3("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.primary.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.primary.border.color"), ";\n    color: ").concat(dt3("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.primary.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.primary.border.color"), ";\n    color: ").concat(dt3("button.outlined.primary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary {\n    border-color: ").concat(dt3("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt3("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.secondary.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt3("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.secondary.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.secondary.border.color"), ";\n    color: ").concat(dt3("button.outlined.secondary.color"), ";\n}\n\n.p-button-outlined.p-button-success {\n    border-color: ").concat(dt3("button.outlined.success.border.color"), ";\n    color: ").concat(dt3("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-success:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.success.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.success.border.color"), ";\n    color: ").concat(dt3("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-success:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.success.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.success.border.color"), ";\n    color: ").concat(dt3("button.outlined.success.color"), ";\n}\n\n.p-button-outlined.p-button-info {\n    border-color: ").concat(dt3("button.outlined.info.border.color"), ";\n    color: ").concat(dt3("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-info:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.info.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.info.border.color"), ";\n    color: ").concat(dt3("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-info:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.info.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.info.border.color"), ";\n    color: ").concat(dt3("button.outlined.info.color"), ";\n}\n\n.p-button-outlined.p-button-warn {\n    border-color: ").concat(dt3("button.outlined.warn.border.color"), ";\n    color: ").concat(dt3("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.warn.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.warn.border.color"), ";\n    color: ").concat(dt3("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-warn:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.warn.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.warn.border.color"), ";\n    color: ").concat(dt3("button.outlined.warn.color"), ";\n}\n\n.p-button-outlined.p-button-help {\n    border-color: ").concat(dt3("button.outlined.help.border.color"), ";\n    color: ").concat(dt3("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-help:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.help.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.help.border.color"), ";\n    color: ").concat(dt3("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-help:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.help.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.help.border.color"), ";\n    color: ").concat(dt3("button.outlined.help.color"), ";\n}\n\n.p-button-outlined.p-button-danger {\n    border-color: ").concat(dt3("button.outlined.danger.border.color"), ";\n    color: ").concat(dt3("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.danger.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.danger.border.color"), ";\n    color: ").concat(dt3("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-danger:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.danger.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.danger.border.color"), ";\n    color: ").concat(dt3("button.outlined.danger.color"), ";\n}\n\n.p-button-outlined.p-button-contrast {\n    border-color: ").concat(dt3("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt3("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-contrast:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.contrast.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt3("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-contrast:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.contrast.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.contrast.border.color"), ";\n    color: ").concat(dt3("button.outlined.contrast.color"), ";\n}\n\n.p-button-outlined.p-button-plain {\n    border-color: ").concat(dt3("button.outlined.plain.border.color"), ";\n    color: ").concat(dt3("button.outlined.plain.color"), ";\n}\n\n.p-button-outlined.p-button-plain:not(:disabled):hover {\n    background: ").concat(dt3("button.outlined.plain.hover.background"), ";\n    border-color: ").concat(dt3("button.outlined.plain.border.color"), ";\n    color: ").concat(dt3("button.outlined.plain.color"), ";\n}\n\n.p-button-outlined.p-button-plain:not(:disabled):active {\n    background: ").concat(dt3("button.outlined.plain.active.background"), ";\n    border-color: ").concat(dt3("button.outlined.plain.border.color"), ";\n    color: ").concat(dt3("button.outlined.plain.color"), ";\n}\n\n.p-button-text {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.primary.color"), ";\n}\n\n.p-button-text:not(:disabled):hover {\n    background: ").concat(dt3("button.text.primary.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.primary.color"), ";\n}\n\n.p-button-text:not(:disabled):active {\n    background: ").concat(dt3("button.text.primary.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.primary.color"), ";\n}\n\n.p-button-text.p-button-secondary {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-secondary:not(:disabled):hover {\n    background: ").concat(dt3("button.text.secondary.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-secondary:not(:disabled):active {\n    background: ").concat(dt3("button.text.secondary.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.secondary.color"), ";\n}\n\n.p-button-text.p-button-success {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-success:not(:disabled):hover {\n    background: ").concat(dt3("button.text.success.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-success:not(:disabled):active {\n    background: ").concat(dt3("button.text.success.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.success.color"), ";\n}\n\n.p-button-text.p-button-info {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-info:not(:disabled):hover {\n    background: ").concat(dt3("button.text.info.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-info:not(:disabled):active {\n    background: ").concat(dt3("button.text.info.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.info.color"), ";\n}\n\n.p-button-text.p-button-warn {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-warn:not(:disabled):hover {\n    background: ").concat(dt3("button.text.warn.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-warn:not(:disabled):active {\n    background: ").concat(dt3("button.text.warn.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.warn.color"), ";\n}\n\n.p-button-text.p-button-help {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-help:not(:disabled):hover {\n    background: ").concat(dt3("button.text.help.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-help:not(:disabled):active {\n    background: ").concat(dt3("button.text.help.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.help.color"), ";\n}\n\n.p-button-text.p-button-danger {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-danger:not(:disabled):hover {\n    background: ").concat(dt3("button.text.danger.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-danger:not(:disabled):active {\n    background: ").concat(dt3("button.text.danger.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.danger.color"), ";\n}\n\n.p-button-text.p-button-plain {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.text.plain.color"), ";\n}\n\n.p-button-text.p-button-plain:not(:disabled):hover {\n    background: ").concat(dt3("button.text.plain.hover.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.plain.color"), ";\n}\n\n.p-button-text.p-button-plain:not(:disabled):active {\n    background: ").concat(dt3("button.text.plain.active.background"), ";\n    border-color: transparent;\n    color: ").concat(dt3("button.text.plain.color"), ";\n}\n\n.p-button-link {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.link.color"), ";\n}\n\n.p-button-link:not(:disabled):hover {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.link.hover.color"), ";\n}\n\n.p-button-link:not(:disabled):hover .p-button-label {\n    text-decoration: underline;\n}\n\n.p-button-link:not(:disabled):active {\n    background: transparent;\n    border-color: transparent;\n    color: ").concat(dt3("button.link.active.color"), ";\n}\n");
};
var classes$t = {
  root: function root2(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-button p-component", _defineProperty$k(_defineProperty$k(_defineProperty$k(_defineProperty$k(_defineProperty$k(_defineProperty$k(_defineProperty$k(_defineProperty$k(_defineProperty$k({
      "p-button-icon-only": instance.hasIcon && !props.label && !props.badge,
      "p-button-vertical": (props.iconPos === "top" || props.iconPos === "bottom") && props.label,
      "p-button-loading": props.loading,
      "p-button-link": props.link
    }, "p-button-".concat(props.severity), props.severity), "p-button-raised", props.raised), "p-button-rounded", props.rounded), "p-button-text", props.text), "p-button-outlined", props.outlined), "p-button-sm", props.size === "small"), "p-button-lg", props.size === "large"), "p-button-plain", props.plain), "p-button-fluid", props.fluid)];
  },
  loadingIcon: "p-button-loading-icon",
  icon: function icon(_ref4) {
    var props = _ref4.props;
    return ["p-button-icon", _defineProperty$k({}, "p-button-icon-".concat(props.iconPos), props.label)];
  },
  label: "p-button-label"
};
var ButtonStyle = BaseStyle.extend({
  name: "button",
  theme: theme$q,
  classes: classes$t
});
var script$1$v = {
  name: "BaseButton",
  "extends": script$1a,
  props: {
    label: {
      type: String,
      "default": null
    },
    icon: {
      type: String,
      "default": null
    },
    iconPos: {
      type: String,
      "default": "left"
    },
    iconClass: {
      type: String,
      "default": null
    },
    badge: {
      type: String,
      "default": null
    },
    badgeClass: {
      type: String,
      "default": null
    },
    badgeSeverity: {
      type: String,
      "default": "secondary"
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    as: {
      type: String,
      "default": "BUTTON"
    },
    asChild: {
      type: Boolean,
      "default": false
    },
    link: {
      type: Boolean,
      "default": false
    },
    severity: {
      type: String,
      "default": null
    },
    raised: {
      type: Boolean,
      "default": false
    },
    rounded: {
      type: Boolean,
      "default": false
    },
    text: {
      type: Boolean,
      "default": false
    },
    outlined: {
      type: Boolean,
      "default": false
    },
    size: {
      type: String,
      "default": null
    },
    plain: {
      type: Boolean,
      "default": false
    },
    fluid: {
      type: Boolean,
      "default": false
    }
  },
  style: ButtonStyle,
  provide: function provide7() {
    return {
      $pcButton: this,
      $parentInstance: this
    };
  }
};
var script$13 = {
  name: "Button",
  "extends": script$1$v,
  inheritAttrs: false,
  methods: {
    getPTOptions: function getPTOptions(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          disabled: this.disabled
        }
      });
    }
  },
  computed: {
    disabled: function disabled() {
      return this.$attrs.disabled || this.$attrs.disabled === "" || this.loading;
    },
    defaultAriaLabel: function defaultAriaLabel() {
      return this.label ? this.label + (this.badge ? " " + this.badge : "") : this.$attrs.ariaLabel;
    },
    hasIcon: function hasIcon() {
      return this.icon || this.$slots.icon;
    },
    attrs: function attrs() {
      return mergeProps(this.asAttrs, this.a11yAttrs, this.getPTOptions("root"));
    },
    asAttrs: function asAttrs() {
      return this.as === "BUTTON" ? {
        type: "button",
        disabled: this.disabled
      } : void 0;
    },
    a11yAttrs: function a11yAttrs() {
      return {
        "aria-label": this.defaultAriaLabel,
        "data-pc-name": "button",
        "data-p-disabled": this.disabled,
        "data-p-severity": this.severity
      };
    }
  },
  components: {
    SpinnerIcon: script$14,
    Badge: script$17
  },
  directives: {
    ripple: Ripple
  }
};
function render$12(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_Badge = resolveComponent("Badge");
  var _directive_ripple = resolveDirective("ripple");
  return !_ctx.asChild ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.as), mergeProps({
    key: 0,
    "class": _ctx.cx("root")
  }, $options.attrs), {
    "default": withCtx(function() {
      return [renderSlot(_ctx.$slots, "default", {}, function() {
        return [_ctx.loading ? renderSlot(_ctx.$slots, "loadingicon", {
          key: 0,
          "class": normalizeClass([_ctx.cx("loadingIcon"), _ctx.cx("icon")])
        }, function() {
          return [_ctx.loadingIcon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon"), _ctx.loadingIcon]
          }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
            key: 1,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon")],
            spin: ""
          }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
        }) : renderSlot(_ctx.$slots, "icon", {
          key: 1,
          "class": normalizeClass([_ctx.cx("icon")])
        }, function() {
          return [_ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("icon"), _ctx.icon, _ctx.iconClass]
          }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true)];
        }), createBaseVNode("span", mergeProps({
          "class": _ctx.cx("label")
        }, _ctx.ptm("label")), toDisplayString$1(_ctx.label || " "), 17), _ctx.badge ? (openBlock(), createBlock(_component_Badge, mergeProps({
          key: 2,
          value: _ctx.badge,
          "class": _ctx.badgeClass,
          severity: _ctx.badgeSeverity,
          unstyled: _ctx.unstyled
        }, _ctx.ptm("pcBadge")), null, 16, ["value", "class", "severity", "unstyled"])) : createCommentVNode("", true)];
      })];
    }),
    _: 3
  }, 16, ["class"])), [[_directive_ripple]]) : renderSlot(_ctx.$slots, "default", {
    key: 1,
    "class": normalizeClass(_ctx.cx("root")),
    a11yAttrs: $options.a11yAttrs
  });
}
script$13.render = render$12;
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "SidebarIcon",
  props: {
    icon: String,
    selected: Boolean,
    tooltip: {
      type: String,
      default: ""
    },
    class: {
      type: String,
      default: ""
    },
    iconBadge: {
      type: [String, Function],
      default: ""
    }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const overlayValue = computed(
      () => typeof props.iconBadge === "function" ? props.iconBadge() || "" : props.iconBadge
    );
    const shouldShowBadge = computed(() => !!overlayValue.value);
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return withDirectives((openBlock(), createBlock(unref(script$13), {
        class: normalizeClass(props.class),
        text: "",
        pt: {
          root: `side-bar-button ${props.selected ? "p-button-primary side-bar-button-selected" : "p-button-secondary"}`
        },
        onClick: _cache[0] || (_cache[0] = ($event) => emit2("click", $event))
      }, {
        icon: withCtx(() => [
          shouldShowBadge.value ? (openBlock(), createBlock(unref(script$16), {
            key: 0,
            value: overlayValue.value
          }, {
            default: withCtx(() => [
              createBaseVNode("i", {
                class: normalizeClass(props.icon + " side-bar-button-icon")
              }, null, 2)
            ]),
            _: 1
          }, 8, ["value"])) : (openBlock(), createElementBlock("i", {
            key: 1,
            class: normalizeClass(props.icon + " side-bar-button-icon")
          }, null, 2))
        ]),
        _: 1
      }, 8, ["class", "pt"])), [
        [_directive_tooltip, { value: props.tooltip, showDelay: 300, hideDelay: 300 }]
      ]);
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const SidebarIcon = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-7a0b94a3"]]);
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.all(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i2 = links.length - 1; i2 >= 0; i2--) {
            const link2 = links[i2];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
          link.crossOrigin = "";
        }
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items2) => {
    const obj = {};
    for (const item of items2) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value3) => {
    if (typeof value3 === "bigint") {
      return value3.toString();
    }
    return value3;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first4, second) => {
    return __spreadValues2(__spreadValues2({}, first4), second);
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data28) => {
  const t = typeof data28;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data28) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data28)) {
        return ZodParsedType.array;
      }
      if (data28 === null) {
        return ZodParsedType.null;
      }
      if (data28.then && typeof data28.then === "function" && data28.catch && typeof data28.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data28 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data28 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data28 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value3) {
    if (!(value3 instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value3}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap$1 = (issue, _ctx) => {
  let message3;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message3 = "Required";
      } else {
        message3 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message3 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message3 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message3 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message3 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message3 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message3 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message3 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message3 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message3 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message3 = `${message3} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message3 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message3 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message3 = `Invalid ${issue.validation}`;
      } else {
        message3 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message3 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message3 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message3 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message3 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message3 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message3 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message3 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message3 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message3 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message3 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message3 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message3 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message3 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message3 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message3 = "Number must be finite";
      break;
    default:
      message3 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message3 };
};
let overrideErrorMap = errorMap$1;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data: data28, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = __spreadProps2(__spreadValues2({}, issueData), {
    path: fullPath
  });
  if (issueData.message !== void 0) {
    return __spreadProps2(__spreadValues2({}, issueData), {
      path: fullPath,
      message: issueData.message
    });
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data: data28, defaultError: errorMessage }).message;
  }
  return __spreadProps2(__spreadValues2({}, issueData), {
    path: fullPath,
    message: errorMessage
  });
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap$1 ? void 0 : errorMap$1
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static mergeObjectAsync(status, pairs) {
    return __async(this, null, function* () {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = yield pair.key;
        const value3 = yield pair.value;
        syncPairs.push({
          key,
          value: value3
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    });
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value3 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value3.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value3.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value3.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value3.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value3) => ({ status: "dirty", value: value3 });
const OK = (value3) => ({ status: "valid", value: value3 });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value3, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value3) : f ? f.value = value3 : state.set(receiver, value3), value3;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message3) {
  var e = new Error(message3);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message3) => typeof message3 === "string" ? { message: message3 } : message3 || {};
  errorUtil2.toString = (message3) => typeof message3 === "string" ? message3 : message3 === null || message3 === void 0 ? void 0 : message3.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value3, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value3;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a2, _b;
    const { message: message3 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message3 !== null && message3 !== void 0 ? message3 : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a2 = message3 !== null && message3 !== void 0 ? message3 : required_error) !== null && _a2 !== void 0 ? _a2 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message3 !== null && message3 !== void 0 ? message3 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data28, params) {
    const result = this.safeParse(data28, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data28, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data28,
      parsedType: getParsedType(data28)
    };
    const result = this._parseSync({ data: data28, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  parseAsync(data28, params) {
    return __async(this, null, function* () {
      const result = yield this.safeParseAsync(data28, params);
      if (result.success)
        return result.data;
      throw result.error;
    });
  }
  safeParseAsync(data28, params) {
    return __async(this, null, function* () {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data28,
        parsedType: getParsedType(data28)
      };
      const maybeAsyncResult = this._parse({ data: data28, path: ctx.path, parent: ctx });
      const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
      return handleResult(ctx, result);
    });
  }
  refine(check, message3) {
    const getIssueProperties = (val) => {
      if (typeof message3 === "string" || typeof message3 === "undefined") {
        return { message: message3 };
      } else if (typeof message3 === "function") {
        return message3(val);
      } else {
        return message3;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue(__spreadValues2({
        code: ZodIssueCode.custom
      }, getIssueProperties(val)));
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data28) => {
          if (!data28) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option4) {
    return ZodUnion.create([this, option4], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects(__spreadProps2(__spreadValues2({}, processCreateParams(this._def)), {
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    }));
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault(__spreadProps2(__spreadValues2({}, processCreateParams(this._def)), {
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    }));
  }
  brand() {
    return new ZodBranded(__spreadValues2({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this
    }, processCreateParams(this._def)));
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch(__spreadProps2(__spreadValues2({}, processCreateParams(this._def)), {
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    }));
  }
  describe(description) {
    const This = this.constructor;
    return new This(__spreadProps2(__spreadValues2({}, this._def), {
      description
    }));
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message3) {
    return this.refinement((data28) => regex.test(data28), __spreadValues2({
      validation,
      code: ZodIssueCode.invalid_string
    }, errorUtil.errToObj(message3)));
  }
  _addCheck(check) {
    return new ZodString(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  email(message3) {
    return this._addCheck(__spreadValues2({ kind: "email" }, errorUtil.errToObj(message3)));
  }
  url(message3) {
    return this._addCheck(__spreadValues2({ kind: "url" }, errorUtil.errToObj(message3)));
  }
  emoji(message3) {
    return this._addCheck(__spreadValues2({ kind: "emoji" }, errorUtil.errToObj(message3)));
  }
  uuid(message3) {
    return this._addCheck(__spreadValues2({ kind: "uuid" }, errorUtil.errToObj(message3)));
  }
  nanoid(message3) {
    return this._addCheck(__spreadValues2({ kind: "nanoid" }, errorUtil.errToObj(message3)));
  }
  cuid(message3) {
    return this._addCheck(__spreadValues2({ kind: "cuid" }, errorUtil.errToObj(message3)));
  }
  cuid2(message3) {
    return this._addCheck(__spreadValues2({ kind: "cuid2" }, errorUtil.errToObj(message3)));
  }
  ulid(message3) {
    return this._addCheck(__spreadValues2({ kind: "ulid" }, errorUtil.errToObj(message3)));
  }
  base64(message3) {
    return this._addCheck(__spreadValues2({ kind: "base64" }, errorUtil.errToObj(message3)));
  }
  ip(options3) {
    return this._addCheck(__spreadValues2({ kind: "ip" }, errorUtil.errToObj(options3)));
  }
  datetime(options3) {
    var _a2, _b;
    if (typeof options3 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options3
      });
    }
    return this._addCheck(__spreadValues2({
      kind: "datetime",
      precision: typeof (options3 === null || options3 === void 0 ? void 0 : options3.precision) === "undefined" ? null : options3 === null || options3 === void 0 ? void 0 : options3.precision,
      offset: (_a2 = options3 === null || options3 === void 0 ? void 0 : options3.offset) !== null && _a2 !== void 0 ? _a2 : false,
      local: (_b = options3 === null || options3 === void 0 ? void 0 : options3.local) !== null && _b !== void 0 ? _b : false
    }, errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)));
  }
  date(message3) {
    return this._addCheck({ kind: "date", message: message3 });
  }
  time(options3) {
    if (typeof options3 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options3
      });
    }
    return this._addCheck(__spreadValues2({
      kind: "time",
      precision: typeof (options3 === null || options3 === void 0 ? void 0 : options3.precision) === "undefined" ? null : options3 === null || options3 === void 0 ? void 0 : options3.precision
    }, errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)));
  }
  duration(message3) {
    return this._addCheck(__spreadValues2({ kind: "duration" }, errorUtil.errToObj(message3)));
  }
  regex(regex, message3) {
    return this._addCheck(__spreadValues2({
      kind: "regex",
      regex
    }, errorUtil.errToObj(message3)));
  }
  includes(value3, options3) {
    return this._addCheck(__spreadValues2({
      kind: "includes",
      value: value3,
      position: options3 === null || options3 === void 0 ? void 0 : options3.position
    }, errorUtil.errToObj(options3 === null || options3 === void 0 ? void 0 : options3.message)));
  }
  startsWith(value3, message3) {
    return this._addCheck(__spreadValues2({
      kind: "startsWith",
      value: value3
    }, errorUtil.errToObj(message3)));
  }
  endsWith(value3, message3) {
    return this._addCheck(__spreadValues2({
      kind: "endsWith",
      value: value3
    }, errorUtil.errToObj(message3)));
  }
  min(minLength, message3) {
    return this._addCheck(__spreadValues2({
      kind: "min",
      value: minLength
    }, errorUtil.errToObj(message3)));
  }
  max(maxLength, message3) {
    return this._addCheck(__spreadValues2({
      kind: "max",
      value: maxLength
    }, errorUtil.errToObj(message3)));
  }
  length(len, message3) {
    return this._addCheck(__spreadValues2({
      kind: "length",
      value: len
    }, errorUtil.errToObj(message3)));
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message3) {
    return this.min(1, errorUtil.errToObj(message3));
  }
  trim() {
    return new ZodString(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  toLowerCase() {
    return new ZodString(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new ZodString(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a2;
  return new ZodString(__spreadValues2({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false
  }, processCreateParams(params)));
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value3, message3) {
    return this.setLimit("min", value3, true, errorUtil.toString(message3));
  }
  gt(value3, message3) {
    return this.setLimit("min", value3, false, errorUtil.toString(message3));
  }
  lte(value3, message3) {
    return this.setLimit("max", value3, true, errorUtil.toString(message3));
  }
  lt(value3, message3) {
    return this.setLimit("max", value3, false, errorUtil.toString(message3));
  }
  setLimit(kind, value3, inclusive, message3) {
    return new ZodNumber(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value3,
          inclusive,
          message: errorUtil.toString(message3)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new ZodNumber(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  int(message3) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message3)
    });
  }
  positive(message3) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  negative(message3) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  nonpositive(message3) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  nonnegative(message3) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  multipleOf(value3, message3) {
    return this._addCheck({
      kind: "multipleOf",
      value: value3,
      message: errorUtil.toString(message3)
    });
  }
  finite(message3) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message3)
    });
  }
  safe(message3) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message3)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message3)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber(__spreadValues2({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value3, message3) {
    return this.setLimit("min", value3, true, errorUtil.toString(message3));
  }
  gt(value3, message3) {
    return this.setLimit("min", value3, false, errorUtil.toString(message3));
  }
  lte(value3, message3) {
    return this.setLimit("max", value3, true, errorUtil.toString(message3));
  }
  lt(value3, message3) {
    return this.setLimit("max", value3, false, errorUtil.toString(message3));
  }
  setLimit(kind, value3, inclusive, message3) {
    return new ZodBigInt(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value3,
          inclusive,
          message: errorUtil.toString(message3)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new ZodBigInt(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  positive(message3) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  negative(message3) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message3)
    });
  }
  nonpositive(message3) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  nonnegative(message3) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message3)
    });
  }
  multipleOf(value3, message3) {
    return this._addCheck({
      kind: "multipleOf",
      value: value3,
      message: errorUtil.toString(message3)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt(__spreadValues2({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false
  }, processCreateParams(params)));
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate(__spreadProps2(__spreadValues2({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  min(minDate, message3) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message3)
    });
  }
  max(maxDate, message3) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message3)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate(__spreadValues2({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate
  }, processCreateParams(params)));
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodSymbol
  }, processCreateParams(params)));
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodUndefined
  }, processCreateParams(params)));
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodNull
  }, processCreateParams(params)));
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodAny
  }, processCreateParams(params)));
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodUnknown
  }, processCreateParams(params)));
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodNever
  }, processCreateParams(params)));
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodVoid
  }, processCreateParams(params)));
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message3) {
    return new ZodArray(__spreadProps2(__spreadValues2({}, this._def), {
      minLength: { value: minLength, message: errorUtil.toString(message3) }
    }));
  }
  max(maxLength, message3) {
    return new ZodArray(__spreadProps2(__spreadValues2({}, this._def), {
      maxLength: { value: maxLength, message: errorUtil.toString(message3) }
    }));
  }
  length(len, message3) {
    return new ZodArray(__spreadProps2(__spreadValues2({}, this._def), {
      exactLength: { value: len, message: errorUtil.toString(message3) }
    }));
  }
  nonempty(message3) {
    return this.min(1, message3);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray(__spreadValues2({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray
  }, processCreateParams(params)));
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject(__spreadProps2(__spreadValues2({}, schema._def), {
      shape: () => newShape
    }));
  } else if (schema instanceof ZodArray) {
    return new ZodArray(__spreadProps2(__spreadValues2({}, schema._def), {
      type: deepPartialify(schema.element)
    }));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value3 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value3, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value3 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value3, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(() => __async(this, null, function* () {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = yield pair.key;
          const value3 = yield pair.value;
          syncPairs.push({
            key,
            value: value3,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      })).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message3) {
    errorUtil.errToObj;
    return new ZodObject(__spreadValues2(__spreadProps2(__spreadValues2({}, this._def), {
      unknownKeys: "strict"
    }), message3 !== void 0 ? {
      errorMap: (issue, ctx) => {
        var _a2, _b, _c, _d;
        const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
        if (issue.code === "unrecognized_keys")
          return {
            message: (_d = errorUtil.errToObj(message3).message) !== null && _d !== void 0 ? _d : defaultError
          };
        return {
          message: defaultError
        };
      }
    } : {}));
  }
  strip() {
    return new ZodObject(__spreadProps2(__spreadValues2({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new ZodObject(__spreadProps2(__spreadValues2({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject(__spreadProps2(__spreadValues2({}, this._def), {
      shape: () => __spreadValues2(__spreadValues2({}, this._def.shape()), augmentation)
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => __spreadValues2(__spreadValues2({}, this._def.shape()), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject(__spreadProps2(__spreadValues2({}, this._def), {
      catchall: index2
    }));
  }
  pick(mask3) {
    const shape = {};
    util.objectKeys(mask3).forEach((key) => {
      if (mask3[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject(__spreadProps2(__spreadValues2({}, this._def), {
      shape: () => shape
    }));
  }
  omit(mask3) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask3[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject(__spreadProps2(__spreadValues2({}, this._def), {
      shape: () => shape
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask3) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask3 && !mask3[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject(__spreadProps2(__spreadValues2({}, this._def), {
      shape: () => newShape
    }));
  }
  required(mask3) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask3 && !mask3[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject(__spreadProps2(__spreadValues2({}, this._def), {
      shape: () => newShape
    }));
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject(__spreadValues2({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject(__spreadValues2({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject(__spreadValues2({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options3 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options3.map((option4) => __async(this, null, function* () {
        const childCtx = __spreadProps2(__spreadValues2({}, ctx), {
          common: __spreadProps2(__spreadValues2({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        return {
          result: yield option4._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      }))).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option4 of options3) {
        const childCtx = __spreadProps2(__spreadValues2({}, ctx), {
          common: __spreadProps2(__spreadValues2({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        const result = option4._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion(__spreadValues2({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion
  }, processCreateParams(params)));
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option4 = this.optionsMap.get(discriminatorValue);
    if (!option4) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option4._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option4._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options3, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options3) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value3 of discriminatorValues) {
        if (optionsMap.has(value3)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value3)}`);
        }
        optionsMap.set(value3, type);
      }
    }
    return new ZodDiscriminatedUnion(__spreadValues2({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options3,
      optionsMap
    }, processCreateParams(params)));
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = __spreadValues2(__spreadValues2({}, a), b);
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection(__spreadValues2({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection
  }, processCreateParams(params)));
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items2 = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items2).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items2);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple(__spreadProps2(__spreadValues2({}, this._def), {
      rest
    }));
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple(__spreadValues2({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null
  }, processCreateParams(params)));
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first4, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord(__spreadValues2({
        keyType: first4,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord
      }, processCreateParams(third)));
    }
    return new ZodRecord(__spreadValues2({
      keyType: ZodString.create(),
      valueType: first4,
      typeName: ZodFirstPartyTypeKind.ZodRecord
    }, processCreateParams(second)));
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value3], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value3, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(() => __async(this, null, function* () {
        for (const pair of pairs) {
          const key = yield pair.key;
          const value3 = yield pair.value;
          if (key.status === "aborted" || value3.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value3.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value3.value);
        }
        return { status: status.value, value: finalMap };
      }));
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value3 = pair.value;
        if (key.status === "aborted" || value3.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value3.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value3.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap(__spreadValues2({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap
  }, processCreateParams(params)));
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message3) {
    return new ZodSet(__spreadProps2(__spreadValues2({}, this._def), {
      minSize: { value: minSize, message: errorUtil.toString(message3) }
    }));
  }
  max(maxSize, message3) {
    return new ZodSet(__spreadProps2(__spreadValues2({}, this._def), {
      maxSize: { value: maxSize, message: errorUtil.toString(message3) }
    }));
  }
  size(size2, message3) {
    return this.min(size2, message3).max(size2, message3);
  }
  nonempty(message3) {
    return this.min(1, message3);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet(__spreadValues2({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet
  }, processCreateParams(params)));
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap$1
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap$1
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(function(...args) {
        return __async(this, null, function* () {
          const error = new ZodError([]);
          const parsedArgs = yield me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = yield Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = yield me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items2) {
    return new ZodFunction(__spreadProps2(__spreadValues2({}, this._def), {
      args: ZodTuple.create(items2).rest(ZodUnknown.create())
    }));
  }
  returns(returnType) {
    return new ZodFunction(__spreadProps2(__spreadValues2({}, this._def), {
      returns: returnType
    }));
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction(__spreadValues2({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction
    }, processCreateParams(params)));
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy(__spreadValues2({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy
  }, processCreateParams(params)));
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value3, params) => {
  return new ZodLiteral(__spreadValues2({
    value: value3,
    typeName: ZodFirstPartyTypeKind.ZodLiteral
  }, processCreateParams(params)));
};
function createZodEnum(values2, params) {
  return new ZodEnum(__spreadValues2({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum
  }, processCreateParams(params)));
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2, newDef = this._def) {
    return ZodEnum.create(values2, __spreadValues2(__spreadValues2({}, this._def), newDef));
  }
  exclude(values2, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)), __spreadValues2(__spreadValues2({}, this._def), newDef));
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum(__spreadValues2({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum
  }, processCreateParams(params)));
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data28) => {
      return this._def.type.parseAsync(data28, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise(__spreadValues2({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise
  }, processCreateParams(params)));
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect2 = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect2.type === "preprocess") {
      const processed = effect2.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => __async(this, null, function* () {
          if (status.value === "aborted")
            return INVALID;
          const result = yield this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }));
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect2.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect2.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect2.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect2.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect2.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect2);
  }
}
ZodEffects.create = (schema, effect2, params) => {
  return new ZodEffects(__spreadValues2({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: effect2
  }, processCreateParams(params)));
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects(__spreadValues2({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects
  }, processCreateParams(params)));
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional(__spreadValues2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional
  }, processCreateParams(params)));
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable(__spreadValues2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable
  }, processCreateParams(params)));
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data28 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data28 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data28,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault(__spreadValues2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default
  }, processCreateParams(params)));
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = __spreadProps2(__spreadValues2({}, ctx), {
      common: __spreadProps2(__spreadValues2({}, ctx.common), {
        issues: []
      })
    });
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: __spreadValues2({}, newCtx)
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch(__spreadValues2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
  }, processCreateParams(params)));
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN(__spreadValues2({
    typeName: ZodFirstPartyTypeKind.ZodNaN
  }, processCreateParams(params)));
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data28 = ctx.data;
    return this._def.type._parse({
      data: data28,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = () => __async(this, null, function* () {
        const inResult = yield this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      });
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data28) => {
      if (isValid(data28)) {
        data28.value = Object.freeze(data28.value);
      }
      return data28;
    };
    return isAsync(result) ? result.then((data28) => freeze(data28)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly(__spreadValues2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly
  }, processCreateParams(params)));
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data28, ctx) => {
      var _a2, _b;
      if (!check(data28)) {
        const p2 = typeof params === "function" ? params(data28) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a2 = p2.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue(__spreadProps2(__spreadValues2({ code: "custom" }, p22), { fatal: _fatal }));
      }
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data28) => data28 instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create(__spreadProps2(__spreadValues2({}, arg), { coerce: true })),
  number: (arg) => ZodNumber.create(__spreadProps2(__spreadValues2({}, arg), { coerce: true })),
  boolean: (arg) => ZodBoolean.create(__spreadProps2(__spreadValues2({}, arg), {
    coerce: true
  })),
  bigint: (arg) => ZodBigInt.create(__spreadProps2(__spreadValues2({}, arg), { coerce: true })),
  date: (arg) => ZodDate.create(__spreadProps2(__spreadValues2({}, arg), { coerce: true }))
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$1,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
function isZodErrorLike(err) {
  return err instanceof Error && err.name === "ZodError" && "issues" in err && Array.isArray(err.issues);
}
var ValidationError = class extends Error {
  constructor(message3, options3) {
    super(message3, options3);
    __publicField2(this, "name");
    __publicField2(this, "details");
    this.name = "ZodValidationError";
    this.details = getIssuesFromErrorOptions(options3);
  }
  toString() {
    return this.message;
  }
};
function getIssuesFromErrorOptions(options3) {
  if (options3) {
    const cause = options3.cause;
    if (isZodErrorLike(cause)) {
      return cause.issues;
    }
  }
  return [];
}
function isValidationError(err) {
  return err instanceof ValidationError;
}
function isValidationErrorLike(err) {
  return err instanceof Error && err.name === "ZodValidationError";
}
var ISSUE_SEPARATOR = "; ";
var MAX_ISSUES_IN_MESSAGE = 99;
var PREFIX = "Validation error";
var PREFIX_SEPARATOR = ": ";
var UNION_SEPARATOR = ", or ";
function prefixMessage(message3, prefix2, prefixSeparator) {
  if (prefix2 !== null) {
    if (message3.length > 0) {
      return [prefix2, message3].join(prefixSeparator);
    }
    return prefix2;
  }
  if (message3.length > 0) {
    return message3;
  }
  return PREFIX;
}
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path) {
  if (path.length === 1) {
    return path[0].toString();
  }
  return path.reduce((acc, item) => {
    if (typeof item === "number") {
      return acc + "[" + item.toString() + "]";
    }
    if (item.includes('"')) {
      return acc + '["' + escapeQuotes(item) + '"]';
    }
    if (!identifierRegex.test(item)) {
      return acc + '["' + item + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + item;
  }, "");
}
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}
function isNonEmptyArray(value3) {
  return value3.length !== 0;
}
function getMessageFromZodIssue(props) {
  const { issue, issueSeparator, unionSeparator, includePath } = props;
  if (issue.code === "invalid_union") {
    return issue.unionErrors.reduce((acc, zodError) => {
      const newIssues = zodError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      ).join(issueSeparator);
      if (!acc.includes(newIssues)) {
        acc.push(newIssues);
      }
      return acc;
    }, []).join(unionSeparator);
  }
  if (issue.code === "invalid_arguments") {
    return [
      issue.message,
      ...issue.argumentsError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (issue.code === "invalid_return_type") {
    return [
      issue.message,
      ...issue.returnTypeError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (includePath && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier = issue.path[0];
      if (typeof identifier === "number") {
        return `${issue.message} at index ${identifier}`;
      }
    }
    return `${issue.message} at "${joinPath(issue.path)}"`;
  }
  return issue.message;
}
function fromZodIssue(issue, options3 = {}) {
  const {
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix: prefix2 = PREFIX,
    includePath = true
  } = options3;
  const reason = getMessageFromZodIssue({
    issue,
    issueSeparator,
    unionSeparator,
    includePath
  });
  const message3 = prefixMessage(reason, prefix2, prefixSeparator);
  return new ValidationError(message3, { cause: new ZodError([issue]) });
}
var errorMap = (issue, ctx) => {
  var _a2;
  const error = fromZodIssue(__spreadProps2(__spreadValues2({}, issue), {
    // fallback to the default error message
    // when issue does not have a message
    message: (_a2 = issue.message) != null ? _a2 : ctx.defaultError
  }));
  return {
    message: error.message
  };
};
function fromZodError(zodError, options3 = {}) {
  if (!isZodErrorLike(zodError)) {
    throw new TypeError(
      `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
    );
  }
  return fromZodErrorWithoutRuntimeCheck(zodError, options3);
}
function fromZodErrorWithoutRuntimeCheck(zodError, options3 = {}) {
  const {
    maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE,
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix: prefix2 = PREFIX,
    includePath = true
  } = options3;
  const zodIssues = zodError.errors;
  const reason = zodIssues.length === 0 ? zodError.message : zodIssues.slice(0, maxIssuesInMessage).map(
    (issue) => getMessageFromZodIssue({
      issue,
      issueSeparator,
      unionSeparator,
      includePath
    })
  ).join(issueSeparator);
  const message3 = prefixMessage(reason, prefix2, prefixSeparator);
  return new ValidationError(message3, { cause: zodError });
}
var toValidationError = (options3 = {}) => (err) => {
  if (isZodErrorLike(err)) {
    return fromZodErrorWithoutRuntimeCheck(err, options3);
  }
  if (err instanceof Error) {
    return new ValidationError(err.message, { cause: err });
  }
  return new ValidationError("Unknown error");
};
function fromError(err, options3 = {}) {
  return toValidationError(options3)(err);
}
const zNodeId = z.union([z.number().int(), z.string()]);
const zSlotIndex = z.union([
  z.number().int(),
  z.string().transform((val) => parseInt(val)).refine((val) => !isNaN(val), {
    message: "Invalid number"
  })
]);
const zDataType = z.union([z.string(), z.array(z.string()), z.number()]);
const zModelFile = z.object({
  name: z.string(),
  url: z.string().url(),
  hash: z.string(),
  hash_type: z.string(),
  directory: z.string()
});
const zComfyLink = z.tuple([
  z.number(),
  // Link id
  zNodeId,
  // Node id of source node
  zSlotIndex,
  // Output slot# of source node
  zNodeId,
  // Node id of destination node
  zSlotIndex,
  // Input slot# of destination node
  zDataType
  // Data type
]);
const zNodeOutput = z.object({
  name: z.string(),
  type: zDataType,
  links: z.array(z.number()).nullable().optional(),
  slot_index: zSlotIndex.optional()
}).passthrough();
const zNodeInput = z.object({
  name: z.string(),
  type: zDataType,
  link: z.number().nullable().optional(),
  slot_index: zSlotIndex.optional()
}).passthrough();
const zFlags = z.object({
  collapsed: z.boolean().optional(),
  pinned: z.boolean().optional(),
  allow_interaction: z.boolean().optional(),
  horizontal: z.boolean().optional(),
  skip_repeated_outputs: z.boolean().optional()
}).passthrough();
const zProperties = z.object({
  ["Node name for S&R"]: z.string().optional()
}).passthrough();
const zVector2 = z.union([
  z.object({ 0: z.number(), 1: z.number() }).transform((v2) => [v2[0], v2[1]]),
  z.tuple([z.number(), z.number()])
]);
const zWidgetValues = z.union([z.array(z.any()), z.record(z.any())]);
const zComfyNode = z.object({
  id: zNodeId,
  type: z.string(),
  pos: zVector2,
  size: zVector2,
  flags: zFlags,
  order: z.number(),
  mode: z.number(),
  inputs: z.array(zNodeInput).optional(),
  outputs: z.array(zNodeOutput).optional(),
  properties: zProperties,
  widgets_values: zWidgetValues.optional(),
  color: z.string().optional(),
  bgcolor: z.string().optional()
}).passthrough();
const zGroup = z.object({
  title: z.string(),
  bounding: z.tuple([z.number(), z.number(), z.number(), z.number()]),
  color: z.string().optional(),
  font_size: z.number().optional(),
  locked: z.boolean().optional()
}).passthrough();
const zInfo = z.object({
  name: z.string(),
  author: z.string(),
  description: z.string(),
  version: z.string(),
  created: z.string(),
  modified: z.string(),
  software: z.string()
}).passthrough();
const zDS = z.object({
  scale: z.number(),
  offset: zVector2
}).passthrough();
const zConfig = z.object({
  links_ontop: z.boolean().optional(),
  align_to_grid: z.boolean().optional()
}).passthrough();
const zExtra = z.object({
  ds: zDS.optional(),
  info: zInfo.optional()
}).passthrough();
const zComfyWorkflow = z.object({
  last_node_id: zNodeId,
  last_link_id: z.number(),
  nodes: z.array(zComfyNode),
  links: z.array(zComfyLink),
  groups: z.array(zGroup).optional(),
  config: zConfig.optional().nullable(),
  extra: zExtra.optional().nullable(),
  version: z.number(),
  models: z.array(zModelFile).optional()
}).passthrough();
function validateComfyWorkflow(_0) {
  return __async(this, arguments, function* (data28, onError = console.warn) {
    const result = yield zComfyWorkflow.safeParseAsync(data28);
    if (!result.success) {
      const error = fromZodError(result.error);
      onError(`Invalid workflow against zod schema:
${error}`);
      return null;
    }
    return result.data;
  });
}
const zNodeType = z.string();
const zQueueIndex = z.number();
const zPromptId = z.string();
const zImageResult = z.object({
  filename: z.string(),
  subfolder: z.string().optional(),
  type: z.string()
});
const zStatusWsMessageStatus = z.object({
  exec_info: z.object({
    queue_remaining: z.number().int()
  })
});
const zStatusWsMessage = z.object({
  status: zStatusWsMessageStatus.nullable().optional()
});
const zProgressWsMessage = z.object({
  value: z.number().int(),
  max: z.number().int(),
  prompt_id: zPromptId,
  node: zNodeId
});
const zExecutingWsMessage = z.object({
  node: zNodeId,
  display_node: zNodeId,
  prompt_id: zPromptId
});
const zExecutedWsMessage = zExecutingWsMessage.extend({
  outputs: z.object({
    images: z.array(zImageResult)
  }).passthrough()
});
const zExecutionWsMessageBase = z.object({
  prompt_id: zPromptId,
  timestamp: z.number().int()
});
const zExecutionStartWsMessage = zExecutionWsMessageBase;
const zExecutionSuccessWsMessage = zExecutionWsMessageBase;
const zExecutionCachedWsMessage = zExecutionWsMessageBase.extend({
  nodes: z.array(zNodeId)
});
const zExecutionInterruptedWsMessage = zExecutionWsMessageBase.extend({
  node_id: zNodeId,
  node_type: zNodeType,
  executed: z.array(zNodeId)
});
const zExecutionErrorWsMessage = zExecutionWsMessageBase.extend({
  node_id: zNodeId,
  node_type: zNodeType,
  executed: z.array(zNodeId),
  exception_message: z.string(),
  exception_type: z.string(),
  traceback: z.string(),
  current_inputs: z.any(),
  current_outputs: z.any()
});
const zPromptInputItem = z.object({
  inputs: z.record(z.string(), z.any()),
  class_type: zNodeType
});
const zPromptInputs = z.record(zPromptInputItem);
const zExtraPngInfo = z.object({
  workflow: zComfyWorkflow
}).passthrough();
const zExtraData = z.object({
  extra_pnginfo: zExtraPngInfo,
  client_id: z.string()
});
const zOutputsToExecute = z.array(zNodeId);
const zExecutionStartMessage = z.tuple([
  z.literal("execution_start"),
  zExecutionStartWsMessage
]);
const zExecutionSuccessMessage = z.tuple([
  z.literal("execution_success"),
  zExecutionSuccessWsMessage
]);
const zExecutionCachedMessage = z.tuple([
  z.literal("execution_cached"),
  zExecutionCachedWsMessage
]);
const zExecutionInterruptedMessage = z.tuple([
  z.literal("execution_interrupted"),
  zExecutionInterruptedWsMessage
]);
const zExecutionErrorMessage = z.tuple([
  z.literal("execution_error"),
  zExecutionErrorWsMessage
]);
const zStatusMessage = z.union([
  zExecutionStartMessage,
  zExecutionSuccessMessage,
  zExecutionCachedMessage,
  zExecutionInterruptedMessage,
  zExecutionErrorMessage
]);
const zStatus = z.object({
  status_str: z.enum(["success", "error"]),
  completed: z.boolean(),
  messages: z.array(zStatusMessage)
});
const zOutput = z.any();
const zTaskPrompt = z.tuple([
  zQueueIndex,
  zPromptId,
  zPromptInputs,
  zExtraData,
  zOutputsToExecute
]);
const zRunningTaskItem = z.object({
  taskType: z.literal("Running"),
  prompt: zTaskPrompt,
  // @Deprecated
  remove: z.object({
    name: z.literal("Cancel"),
    cb: z.function()
  })
});
const zPendingTaskItem = z.object({
  taskType: z.literal("Pending"),
  prompt: zTaskPrompt
});
const zTaskOutput = z.record(zNodeId, zOutput);
const zHistoryTaskItem = z.object({
  taskType: z.literal("History"),
  prompt: zTaskPrompt,
  status: zStatus.optional(),
  outputs: zTaskOutput
});
const zTaskItem = z.union([
  zRunningTaskItem,
  zPendingTaskItem,
  zHistoryTaskItem
]);
const zTaskType = z.union([
  z.literal("Running"),
  z.literal("Pending"),
  z.literal("History")
]);
function validateTaskItem(taskItem) {
  const result = zTaskItem.safeParse(taskItem);
  if (!result.success) {
    const zodError = fromZodError(result.error);
    console.warn(
      `Invalid TaskItem: ${JSON.stringify(taskItem)}
${zodError.message}`
    );
  }
  return result;
}
function inputSpec(spec, allowUpcast = true) {
  const [inputType, inputSpec2] = spec;
  const upcastTypes = allowUpcast ? [inputType.transform((type) => [type, {}])] : [];
  return z.union([
    z.tuple([inputType, inputSpec2]),
    z.tuple([inputType]).transform(([type]) => [type, {}]),
    ...upcastTypes
  ]);
}
const zBaseInputSpecValue = z.object({
  default: z.any().optional(),
  forceInput: z.boolean().optional()
}).passthrough();
const zIntInputSpec = inputSpec([
  z.literal("INT"),
  zBaseInputSpecValue.extend({
    min: z.number().optional(),
    max: z.number().optional(),
    step: z.number().optional(),
    // Note: Many node authors are using INT to pass list of INT.
    // TODO: Add list of ints type.
    default: z.union([z.number(), z.array(z.number())]).optional()
  })
]);
const zFloatInputSpec = inputSpec([
  z.literal("FLOAT"),
  zBaseInputSpecValue.extend({
    min: z.number().optional(),
    max: z.number().optional(),
    step: z.number().optional(),
    round: z.union([z.number(), z.literal(false)]).optional(),
    // Note: Many node authors are using FLOAT to pass list of FLOAT.
    // TODO: Add list of floats type.
    default: z.union([z.number(), z.array(z.number())]).optional()
  })
]);
const zBooleanInputSpec = inputSpec([
  z.literal("BOOLEAN"),
  zBaseInputSpecValue.extend({
    label_on: z.string().optional(),
    label_off: z.string().optional(),
    default: z.boolean().optional()
  })
]);
const zStringInputSpec = inputSpec([
  z.literal("STRING"),
  zBaseInputSpecValue.extend({
    default: z.string().optional(),
    multiline: z.boolean().optional(),
    dynamicPrompts: z.boolean().optional()
  })
]);
const zComboInputSpec = inputSpec(
  [
    z.array(z.any()),
    zBaseInputSpecValue.extend({
      control_after_generate: z.boolean().optional(),
      image_upload: z.boolean().optional()
    })
  ],
  /* allowUpcast=*/
  false
);
const excludedLiterals = /* @__PURE__ */ new Set(["INT", "FLOAT", "BOOLEAN", "STRING", "COMBO"]);
const zCustomInputSpec = inputSpec([
  z.string().refine((value3) => !excludedLiterals.has(value3)),
  zBaseInputSpecValue
]);
const zInputSpec = z.union([
  zIntInputSpec,
  zFloatInputSpec,
  zBooleanInputSpec,
  zStringInputSpec,
  zComboInputSpec,
  zCustomInputSpec
]);
const zComfyInputsSpec = z.object({
  required: z.record(zInputSpec).optional(),
  optional: z.record(zInputSpec).optional(),
  // Frontend repo is not using it, but some custom nodes are using the
  // hidden field to pass various values.
  hidden: z.record(z.any()).optional()
});
const zComfyNodeDataType = z.string();
const zComfyComboOutput = z.array(z.any());
const zComfyOutputTypesSpec = z.array(
  z.union([zComfyNodeDataType, zComfyComboOutput])
);
const zComfyNodeDef = z.object({
  input: zComfyInputsSpec,
  output: zComfyOutputTypesSpec,
  output_is_list: z.array(z.boolean()),
  output_name: z.array(z.string()),
  output_tooltips: z.array(z.string()).optional(),
  name: z.string(),
  display_name: z.string(),
  description: z.string(),
  category: z.string(),
  output_node: z.boolean(),
  python_module: z.string()
});
function validateComfyNodeDef(data28, onError = console.warn) {
  const result = zComfyNodeDef.safeParse(data28);
  if (!result.success) {
    const zodError = fromZodError(result.error);
    onError(
      `Invalid ComfyNodeDef: ${JSON.stringify(data28)}
${zodError.message}`
    );
    return null;
  }
  return result.data;
}
class ComfyApi extends EventTarget {
  constructor() {
    super();
    __privateAdd(this, _ComfyApi_instances);
    __privateAdd(this, _registered, /* @__PURE__ */ new Set());
    __publicField2(this, "api_host");
    __publicField2(this, "api_base");
    __publicField2(this, "initialClientId");
    __publicField2(this, "user");
    __publicField2(this, "socket");
    __publicField2(this, "clientId");
    __publicField2(this, "reportedUnknownMessageTypes", /* @__PURE__ */ new Set());
    this.api_host = location.host;
    this.api_base = location.pathname.split("/").slice(0, -1).join("/");
    this.initialClientId = sessionStorage.getItem("clientId");
  }
  apiURL(route) {
    return this.api_base + "/api" + route;
  }
  fileURL(route) {
    return this.api_base + route;
  }
  fetchApi(route, options3) {
    if (!options3) {
      options3 = {};
    }
    if (!options3.headers) {
      options3.headers = {};
    }
    if (!options3.cache) {
      options3.cache = "no-cache";
    }
    options3.headers["Comfy-User"] = this.user;
    return fetch(this.apiURL(route), options3);
  }
  addEventListener(type, callback, options3) {
    super.addEventListener(type, callback, options3);
    __privateGet(this, _registered).add(type);
  }
  /**
   * Initialises sockets and realtime updates
   */
  init() {
    __privateMethod(this, _ComfyApi_instances, createSocket_fn).call(this);
  }
  /**
   * Gets a list of extension urls
   * @returns An array of script urls to import
   */
  getExtensions() {
    return __async(this, null, function* () {
      const resp = yield this.fetchApi("/extensions", { cache: "no-store" });
      return yield resp.json();
    });
  }
  /**
   * Gets a list of embedding names
   * @returns An array of script urls to import
   */
  getEmbeddings() {
    return __async(this, null, function* () {
      const resp = yield this.fetchApi("/embeddings", { cache: "no-store" });
      return yield resp.json();
    });
  }
  /**
   * Loads node object definitions for the graph
   * @returns The node definitions
   */
  getNodeDefs() {
    return __async(this, null, function* () {
      const resp = yield this.fetchApi("/object_info", { cache: "no-store" });
      const objectInfoUnsafe = yield resp.json();
      const objectInfo = {};
      for (const key in objectInfoUnsafe) {
        const validatedDef = validateComfyNodeDef(
          objectInfoUnsafe[key],
          /* onError=*/
          (errorMessage) => {
            console.warn(
              `Skipping invalid node definition: ${key}. See debug log for more information.`
            );
            console.debug(errorMessage);
          }
        );
        if (validatedDef !== null) {
          objectInfo[key] = validatedDef;
        }
      }
      return objectInfo;
    });
  }
  /**
   *
   * @param {number} number The index at which to queue the prompt, passing -1 will insert the prompt at the front of the queue
   * @param {object} prompt The prompt data to queue
   */
  queuePrompt(_0, _1) {
    return __async(this, arguments, function* (number2, { output, workflow }) {
      const body = {
        client_id: this.clientId,
        prompt: output,
        extra_data: { extra_pnginfo: { workflow } }
      };
      if (number2 === -1) {
        body.front = true;
      } else if (number2 != 0) {
        body.number = number2;
      }
      const res = yield this.fetchApi("/prompt", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      if (res.status !== 200) {
        throw {
          response: yield res.json()
        };
      }
      return yield res.json();
    });
  }
  /**
   * Loads a list of items (queue or history)
   * @param {string} type The type of items to load, queue or history
   * @returns The items of the specified type grouped by their status
   */
  getItems(type) {
    return __async(this, null, function* () {
      if (type === "queue") {
        return this.getQueue();
      }
      return this.getHistory();
    });
  }
  /**
   * Gets the current state of the queue
   * @returns The currently running and queued items
   */
  getQueue() {
    return __async(this, null, function* () {
      try {
        const res = yield this.fetchApi("/queue");
        const data28 = yield res.json();
        return {
          // Running action uses a different endpoint for cancelling
          Running: data28.queue_running.map((prompt2) => ({
            taskType: "Running",
            prompt: prompt2,
            remove: { name: "Cancel", cb: () => api.interrupt() }
          })),
          Pending: data28.queue_pending.map((prompt2) => ({
            taskType: "Pending",
            prompt: prompt2
          }))
        };
      } catch (error) {
        console.error(error);
        return { Running: [], Pending: [] };
      }
    });
  }
  /**
   * Gets the prompt execution history
   * @returns Prompt history including node outputs
   */
  getHistory(max_items = 200) {
    return __async(this, null, function* () {
      try {
        const res = yield this.fetchApi(`/history?max_items=${max_items}`);
        return {
          History: Object.values(yield res.json()).map(
            (item) => __spreadProps2(__spreadValues2({}, item), { taskType: "History" })
          )
        };
      } catch (error) {
        console.error(error);
        return { History: [] };
      }
    });
  }
  /**
   * Gets system & device stats
   * @returns System stats such as python version, OS, per device info
   */
  getSystemStats() {
    return __async(this, null, function* () {
      const res = yield this.fetchApi("/system_stats");
      return yield res.json();
    });
  }
  /**
   * Deletes an item from the specified list
   * @param {string} type The type of item to delete, queue or history
   * @param {number} id The id of the item to delete
   */
  deleteItem(type, id2) {
    return __async(this, null, function* () {
      yield __privateMethod(this, _ComfyApi_instances, postItem_fn).call(this, type, { delete: [id2] });
    });
  }
  /**
   * Clears the specified list
   * @param {string} type The type of list to clear, queue or history
   */
  clearItems(type) {
    return __async(this, null, function* () {
      yield __privateMethod(this, _ComfyApi_instances, postItem_fn).call(this, type, { clear: true });
    });
  }
  /**
   * Interrupts the execution of the running prompt
   */
  interrupt() {
    return __async(this, null, function* () {
      yield __privateMethod(this, _ComfyApi_instances, postItem_fn).call(this, "interrupt", null);
    });
  }
  /**
   * Gets user configuration data and where data should be stored
   * @returns { Promise<{ storage: "server" | "browser", users?: Promise<string, unknown>, migrated?: boolean }> }
   */
  getUserConfig() {
    return __async(this, null, function* () {
      return (yield this.fetchApi("/users")).json();
    });
  }
  /**
   * Creates a new user
   * @param { string } username
   * @returns The fetch response
   */
  createUser(username) {
    return this.fetchApi("/users", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ username })
    });
  }
  /**
   * Gets all setting values for the current user
   * @returns { Promise<string, unknown> } A dictionary of id -> value
   */
  getSettings() {
    return __async(this, null, function* () {
      return (yield this.fetchApi("/settings")).json();
    });
  }
  /**
   * Gets a setting for the current user
   * @param { string } id The id of the setting to fetch
   * @returns { Promise<unknown> } The setting value
   */
  getSetting(id2) {
    return __async(this, null, function* () {
      return (yield this.fetchApi(`/settings/${encodeURIComponent(id2)}`)).json();
    });
  }
  /**
   * Stores a dictionary of settings for the current user
   * @param { Record<string, unknown> } settings Dictionary of setting id -> value to save
   * @returns { Promise<void> }
   */
  storeSettings(settings) {
    return __async(this, null, function* () {
      return this.fetchApi(`/settings`, {
        method: "POST",
        body: JSON.stringify(settings)
      });
    });
  }
  /**
   * Stores a setting for the current user
   * @param { string } id The id of the setting to update
   * @param { unknown } value The value of the setting
   * @returns { Promise<void> }
   */
  storeSetting(id2, value3) {
    return __async(this, null, function* () {
      return this.fetchApi(`/settings/${encodeURIComponent(id2)}`, {
        method: "POST",
        body: JSON.stringify(value3)
      });
    });
  }
  /**
   * Gets a user data file for the current user
   * @param { string } file The name of the userdata file to load
   * @param { RequestInit } [options]
   * @returns { Promise<unknown> } The fetch response object
   */
  getUserData(file, options3) {
    return __async(this, null, function* () {
      return this.fetchApi(`/userdata/${encodeURIComponent(file)}`, options3);
    });
  }
  /**
   * Stores a user data file for the current user
   * @param { string } file The name of the userdata file to save
   * @param { unknown } data The data to save to the file
   * @param { RequestInit & { stringify?: boolean, throwOnError?: boolean } } [options]
   * @returns { Promise<Response> }
   */
  storeUserData(_0, _1) {
    return __async(this, arguments, function* (file, data28, options3 = { overwrite: true, stringify: true, throwOnError: true }) {
      const resp = yield this.fetchApi(
        `/userdata/${encodeURIComponent(file)}?overwrite=${options3.overwrite}`,
        __spreadValues2({
          method: "POST",
          body: (options3 == null ? void 0 : options3.stringify) ? JSON.stringify(data28) : data28
        }, options3)
      );
      if (resp.status !== 200 && options3.throwOnError !== false) {
        throw new Error(
          `Error storing user data file '${file}': ${resp.status} ${(yield resp).statusText}`
        );
      }
      return resp;
    });
  }
  /**
   * Deletes a user data file for the current user
   * @param { string } file The name of the userdata file to delete
   */
  deleteUserData(file) {
    return __async(this, null, function* () {
      const resp = yield this.fetchApi(`/userdata/${encodeURIComponent(file)}`, {
        method: "DELETE"
      });
      if (resp.status !== 204) {
        throw new Error(
          `Error removing user data file '${file}': ${resp.status} ${resp.statusText}`
        );
      }
    });
  }
  /**
   * Move a user data file for the current user
   * @param { string } source The userdata file to move
   * @param { string } dest The destination for the file
   */
  moveUserData(_0, _1) {
    return __async(this, arguments, function* (source, dest, options3 = { overwrite: false }) {
      const resp = yield this.fetchApi(
        `/userdata/${encodeURIComponent(source)}/move/${encodeURIComponent(dest)}?overwrite=${options3 == null ? void 0 : options3.overwrite}`,
        {
          method: "POST"
        }
      );
      return resp;
    });
  }
  /**
   * @overload
   * Lists user data files for the current user
   * @param { string } dir The directory in which to list files
   * @param { boolean } [recurse] If the listing should be recursive
   * @param { true } [split] If the paths should be split based on the os path separator
   * @returns { Promise<string[][]>> } The list of split file paths in the format [fullPath, ...splitPath]
   */
  /**
   * @overload
   * Lists user data files for the current user
   * @param { string } dir The directory in which to list files
   * @param { boolean } [recurse] If the listing should be recursive
   * @param { false | undefined } [split] If the paths should be split based on the os path separator
   * @returns { Promise<string[]> } The list of files
   */
  listUserData(dir, recurse, split) {
    return __async(this, null, function* () {
      const resp = yield this.fetchApi(
        `/userdata?${new URLSearchParams({
          recurse,
          dir,
          split
        })}`
      );
      if (resp.status === 404) return [];
      if (resp.status !== 200) {
        throw new Error(
          `Error getting user data list '${dir}': ${resp.status} ${resp.statusText}`
        );
      }
      return resp.json();
    });
  }
}
_registered = new WeakMap();
_ComfyApi_instances = new WeakSet();
/**
 * Poll status  for colab and other things that don't support websockets.
 */
pollQueue_fn = function() {
  setInterval(() => __async(this, null, function* () {
    try {
      const resp = yield this.fetchApi("/prompt");
      const status = yield resp.json();
      this.dispatchEvent(new CustomEvent("status", { detail: status }));
    } catch (error) {
      this.dispatchEvent(new CustomEvent("status", { detail: null }));
    }
  }), 1e3);
};
/**
 * Creates and connects a WebSocket for realtime updates
 * @param {boolean} isReconnect If the socket is connection is a reconnect attempt
 */
createSocket_fn = function(isReconnect) {
  if (this.socket) {
    return;
  }
  let opened = false;
  let existingSession = window.name;
  if (existingSession) {
    existingSession = "?clientId=" + existingSession;
  }
  this.socket = new WebSocket(
    `ws${window.location.protocol === "https:" ? "s" : ""}://${this.api_host}${this.api_base}/ws${existingSession}`
  );
  this.socket.binaryType = "arraybuffer";
  this.socket.addEventListener("open", () => {
    opened = true;
    if (isReconnect) {
      this.dispatchEvent(new CustomEvent("reconnected"));
    }
  });
  this.socket.addEventListener("error", () => {
    if (this.socket) this.socket.close();
    if (!isReconnect && !opened) {
      __privateMethod(this, _ComfyApi_instances, pollQueue_fn).call(this);
    }
  });
  this.socket.addEventListener("close", () => {
    setTimeout(() => {
      this.socket = null;
      __privateMethod(this, _ComfyApi_instances, createSocket_fn).call(this, true);
    }, 300);
    if (opened) {
      this.dispatchEvent(new CustomEvent("status", { detail: null }));
      this.dispatchEvent(new CustomEvent("reconnecting"));
    }
  });
  this.socket.addEventListener("message", (event2) => {
    try {
      if (event2.data instanceof ArrayBuffer) {
        const view = new DataView(event2.data);
        const eventType = view.getUint32(0);
        const buffer2 = event2.data.slice(4);
        switch (eventType) {
          case 1:
            const view2 = new DataView(event2.data);
            const imageType = view2.getUint32(0);
            let imageMime;
            switch (imageType) {
              case 1:
              default:
                imageMime = "image/jpeg";
                break;
              case 2:
                imageMime = "image/png";
            }
            const imageBlob = new Blob([buffer2.slice(4)], {
              type: imageMime
            });
            this.dispatchEvent(
              new CustomEvent("b_preview", { detail: imageBlob })
            );
            break;
          default:
            throw new Error(
              `Unknown binary websocket message of type ${eventType}`
            );
        }
      } else {
        const msg = JSON.parse(event2.data);
        switch (msg.type) {
          case "status":
            if (msg.data.sid) {
              this.clientId = msg.data.sid;
              window.name = this.clientId;
              sessionStorage.setItem("clientId", this.clientId);
            }
            this.dispatchEvent(
              new CustomEvent("status", { detail: msg.data.status })
            );
            break;
          case "progress":
            this.dispatchEvent(
              new CustomEvent("progress", { detail: msg.data })
            );
            break;
          case "executing":
            this.dispatchEvent(
              new CustomEvent("executing", {
                detail: msg.data.display_node || msg.data.node
              })
            );
            break;
          case "executed":
            this.dispatchEvent(
              new CustomEvent("executed", { detail: msg.data })
            );
            break;
          case "execution_start":
            this.dispatchEvent(
              new CustomEvent("execution_start", { detail: msg.data })
            );
            break;
          case "execution_success":
            this.dispatchEvent(
              new CustomEvent("execution_success", { detail: msg.data })
            );
            break;
          case "execution_error":
            this.dispatchEvent(
              new CustomEvent("execution_error", { detail: msg.data })
            );
            break;
          case "execution_cached":
            this.dispatchEvent(
              new CustomEvent("execution_cached", { detail: msg.data })
            );
            break;
          default:
            if (__privateGet(this, _registered).has(msg.type)) {
              this.dispatchEvent(
                new CustomEvent(msg.type, { detail: msg.data })
              );
            } else if (!this.reportedUnknownMessageTypes.has(msg.type)) {
              this.reportedUnknownMessageTypes.add(msg.type);
              throw new Error(`Unknown message type ${msg.type}`);
            }
        }
      }
    } catch (error) {
      console.warn("Unhandled message:", event2.data, error);
    }
  });
};
postItem_fn = function(type, body) {
  return __async(this, null, function* () {
    try {
      yield this.fetchApi("/" + type, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: body ? JSON.stringify(body) : void 0
      });
    } catch (error) {
      console.error(error);
    }
  });
};
const api = new ComfyApi();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.api = window.comfyAPI.api || {};
window.comfyAPI.api.api = api;
let ComfyDialog$1 = (_a = class extends EventTarget {
  constructor(type = "div", buttons = null) {
    super();
    __publicField2(this, "element");
    __publicField2(this, "textElement");
    __privateAdd(this, _buttons);
    __privateSet(this, _buttons, buttons);
    this.element = $el(type + ".comfy-modal", { parent: document.body }, [
      $el("div.comfy-modal-content", [
        $el("p", { $: (p2) => this.textElement = p2 }),
        ...this.createButtons()
      ])
    ]);
  }
  createButtons() {
    var _a2;
    return (_a2 = __privateGet(this, _buttons)) != null ? _a2 : [
      $el("button", {
        type: "button",
        textContent: "Close",
        onclick: () => this.close()
      })
    ];
  }
  close() {
    this.element.style.display = "none";
  }
  show(html) {
    if (typeof html === "string") {
      this.textElement.innerHTML = html;
    } else {
      this.textElement.replaceChildren(
        ...html instanceof Array ? html : [html]
      );
    }
    this.element.style.display = "flex";
  }
}, _buttons = new WeakMap(), _a);
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.dialog = window.comfyAPI.dialog || {};
window.comfyAPI.dialog.ComfyDialog = ComfyDialog$1;
function toggleSwitch(name, items2, e) {
  const onChange12 = e == null ? void 0 : e.onChange;
  let selectedIndex;
  let elements;
  function updateSelected(index2) {
    if (selectedIndex != null) {
      elements[selectedIndex].classList.remove("comfy-toggle-selected");
    }
    onChange12 == null ? void 0 : onChange12({
      item: items2[index2],
      prev: selectedIndex == null ? void 0 : items2[selectedIndex]
    });
    selectedIndex = index2;
    elements[selectedIndex].classList.add("comfy-toggle-selected");
  }
  elements = items2.map((item, i2) => {
    var _a2, _b;
    if (typeof item === "string") item = { text: item };
    if (!item.value) item.value = item.text;
    const toggle2 = $el(
      "label",
      {
        textContent: item.text,
        title: (_a2 = item.tooltip) != null ? _a2 : ""
      },
      $el("input", {
        name,
        type: "radio",
        value: (_b = item.value) != null ? _b : item.text,
        checked: item.selected,
        onchange: () => {
          updateSelected(i2);
        }
      })
    );
    if (item.selected) {
      updateSelected(i2);
    }
    return toggle2;
  });
  const container = $el("div.comfy-toggle-switch", elements);
  if (selectedIndex == null) {
    elements[0].children[0].checked = true;
    updateSelected(0);
  }
  return container;
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.toggleSwitch = window.comfyAPI.toggleSwitch || {};
window.comfyAPI.toggleSwitch.toggleSwitch = toggleSwitch;
class ComfySettingsDialog extends ComfyDialog$1 {
  constructor(app2) {
    super();
    __privateAdd(this, _ComfySettingsDialog_instances);
    __publicField2(this, "app");
    __publicField2(this, "settingsValues");
    __publicField2(this, "settingsLookup");
    __publicField2(this, "settingsParamLookup");
    const frontendVersion = window["__COMFYUI_FRONTEND_VERSION__"];
    this.app = app2;
    this.settingsValues = {};
    this.settingsLookup = {};
    this.settingsParamLookup = {};
    this.element = $el(
      "dialog",
      {
        id: "comfy-settings-dialog",
        parent: document.body
      },
      [
        $el("table.comfy-modal-content.comfy-table", [
          $el(
            "caption",
            { textContent: `Settings (v${frontendVersion})` },
            $el("button.comfy-btn", {
              type: "button",
              textContent: "×",
              onclick: () => {
                this.element.close();
              }
            })
          ),
          $el("tbody", { $: (tbody2) => this.textElement = tbody2 }),
          $el("button", {
            type: "button",
            textContent: "Close",
            style: {
              cursor: "pointer"
            },
            onclick: () => {
              this.element.close();
            }
          })
        ])
      ]
    );
  }
  get settings() {
    return Object.values(this.settingsLookup);
  }
  load() {
    return __async(this, null, function* () {
      var _a2, _b;
      if (this.app.storageLocation === "browser") {
        this.settingsValues = localStorage;
      } else {
        this.settingsValues = yield api.getSettings();
      }
      for (const id2 in this.settingsLookup) {
        const value3 = this.settingsValues[this.getId(id2)];
        (_b = (_a2 = this.settingsLookup[id2]).onChange) == null ? void 0 : _b.call(_a2, value3);
        __privateMethod(this, _ComfySettingsDialog_instances, dispatchChange_fn).call(this, id2, value3);
      }
    });
  }
  getId(id2) {
    if (this.app.storageLocation === "browser") {
      id2 = "Comfy.Settings." + id2;
    }
    return id2;
  }
  getSettingValue(id2, defaultValue) {
    let value3 = this.settingsValues[this.getId(id2)];
    if (value3 != null) {
      if (this.app.storageLocation === "browser") {
        try {
          value3 = JSON.parse(value3);
        } catch (error) {
        }
      }
    }
    return value3 != null ? value3 : defaultValue;
  }
  getSettingDefaultValue(id2) {
    const param = this.settingsParamLookup[id2];
    return param == null ? void 0 : param.defaultValue;
  }
  setSettingValueAsync(id2, value3) {
    return __async(this, null, function* () {
      var _a2, _b;
      const json = JSON.stringify(value3);
      localStorage["Comfy.Settings." + id2] = json;
      let oldValue = this.getSettingValue(id2, void 0);
      this.settingsValues[this.getId(id2)] = value3;
      if (id2 in this.settingsLookup) {
        (_b = (_a2 = this.settingsLookup[id2]).onChange) == null ? void 0 : _b.call(_a2, value3, oldValue);
      }
      __privateMethod(this, _ComfySettingsDialog_instances, dispatchChange_fn).call(this, id2, value3, oldValue);
      yield api.storeSetting(id2, value3);
    });
  }
  setSettingValue(id2, value3) {
    this.setSettingValueAsync(id2, value3).catch((err) => {
      alert(`Error saving setting '${id2}'`);
      console.error(err);
    });
  }
  refreshSetting(id2) {
    var _a2, _b;
    const value3 = this.getSettingValue(id2);
    (_b = (_a2 = this.settingsLookup[id2]).onChange) == null ? void 0 : _b.call(_a2, value3);
    __privateMethod(this, _ComfySettingsDialog_instances, dispatchChange_fn).call(this, id2, value3);
  }
  addSetting(params) {
    const {
      id: id2,
      name,
      type,
      defaultValue,
      onChange: onChange12,
      attrs: attrs3 = {},
      tooltip = "",
      options: options3 = void 0
    } = params;
    if (!id2) {
      throw new Error("Settings must have an ID");
    }
    if (id2 in this.settingsLookup) {
      throw new Error(`Setting ${id2} of type ${type} must have a unique ID.`);
    }
    let skipOnChange = false;
    let value3 = this.getSettingValue(id2);
    if (value3 == null) {
      if (this.app.isNewUserSession) {
        const localValue = localStorage["Comfy.Settings." + id2];
        if (localValue) {
          value3 = JSON.parse(localValue);
          this.setSettingValue(id2, value3);
        }
      }
      if (value3 == null) {
        value3 = defaultValue;
      }
    }
    if (!skipOnChange) {
      onChange12 == null ? void 0 : onChange12(value3, void 0);
      __privateMethod(this, _ComfySettingsDialog_instances, dispatchChange_fn).call(this, id2, value3);
    }
    this.settingsParamLookup[id2] = params;
    if (this.app.vueAppReady) {
      useSettingStore().settings[id2] = params;
    }
    this.settingsLookup[id2] = {
      id: id2,
      onChange: onChange12,
      name,
      render: () => {
        if (type === "hidden") return;
        const setter = (v2) => {
          if (onChange12) {
            onChange12(v2, value3);
          }
          this.setSettingValue(id2, v2);
          value3 = v2;
        };
        value3 = this.getSettingValue(id2, defaultValue);
        let element;
        const htmlID = id2.replaceAll(".", "-");
        const labelCell = $el("td", [
          $el("label", {
            for: htmlID,
            classList: [tooltip !== "" ? "comfy-tooltip-indicator" : ""],
            textContent: name
          })
        ]);
        if (typeof type === "function") {
          element = type(name, setter, value3, attrs3);
        } else {
          switch (type) {
            case "boolean":
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el("input", {
                    id: htmlID,
                    type: "checkbox",
                    checked: value3,
                    onchange: (event2) => {
                      const isChecked2 = event2.target.checked;
                      if (onChange12 !== void 0) {
                        onChange12(isChecked2);
                      }
                      this.setSettingValue(id2, isChecked2);
                    }
                  })
                ])
              ]);
              break;
            case "number":
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el("input", __spreadValues2({
                    type,
                    value: value3,
                    id: htmlID,
                    oninput: (e) => {
                      setter(e.target.value);
                    }
                  }, attrs3))
                ])
              ]);
              break;
            case "slider":
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el(
                    "div",
                    {
                      style: {
                        display: "grid",
                        gridAutoFlow: "column"
                      }
                    },
                    [
                      $el("input", __spreadProps2(__spreadValues2({}, attrs3), {
                        value: value3,
                        type: "range",
                        oninput: (e) => {
                          setter(e.target.value);
                          e.target.nextElementSibling.value = e.target.value;
                        }
                      })),
                      $el("input", __spreadProps2(__spreadValues2({}, attrs3), {
                        value: value3,
                        id: htmlID,
                        type: "number",
                        style: { maxWidth: "4rem" },
                        oninput: (e) => {
                          setter(e.target.value);
                          e.target.previousElementSibling.value = e.target.value;
                        }
                      }))
                    ]
                  )
                ])
              ]);
              break;
            case "combo":
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el(
                    "select",
                    {
                      oninput: (e) => {
                        setter(e.target.value);
                      }
                    },
                    (typeof options3 === "function" ? options3(value3) : options3 || []).map((opt) => {
                      var _a2;
                      if (typeof opt === "string") {
                        opt = { text: opt };
                      }
                      const v2 = (_a2 = opt.value) != null ? _a2 : opt.text;
                      return $el("option", {
                        value: v2,
                        textContent: opt.text,
                        selected: value3 + "" === v2 + ""
                      });
                    })
                  )
                ])
              ]);
              break;
            case "text":
            default:
              if (type !== "text") {
                console.warn(
                  `Unsupported setting type '${type}, defaulting to text`
                );
              }
              element = $el("tr", [
                labelCell,
                $el("td", [
                  $el("input", __spreadValues2({
                    value: value3,
                    id: htmlID,
                    oninput: (e) => {
                      setter(e.target.value);
                    }
                  }, attrs3))
                ])
              ]);
              break;
          }
        }
        if (tooltip) {
          element.title = tooltip;
        }
        return element;
      }
    };
    const self2 = this;
    return {
      get value() {
        return self2.getSettingValue(id2, defaultValue);
      },
      set value(v2) {
        self2.setSettingValue(id2, v2);
      }
    };
  }
  show() {
    this.textElement.replaceChildren(
      $el(
        "tr",
        {
          style: { display: "none" }
        },
        [$el("th"), $el("th", { style: { width: "33%" } })]
      ),
      ...this.settings.sort((a, b) => a.name.localeCompare(b.name)).map((s) => s.render()).filter(Boolean)
    );
    this.element.showModal();
  }
}
_ComfySettingsDialog_instances = new WeakSet();
dispatchChange_fn = function(id2, value3, oldValue) {
  if (this.app.vueAppReady) {
    useSettingStore().settingValues[id2] = value3;
  }
  this.dispatchEvent(
    new CustomEvent(id2 + ".change", {
      detail: {
        value: value3,
        oldValue
      }
    })
  );
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.settings = window.comfyAPI.settings || {};
window.comfyAPI.settings.ComfySettingsDialog = ComfySettingsDialog;
const ComfyDialog = ComfyDialog$1;
function $el(tag, propsOrChildren, children) {
  const split = tag.split(".");
  const element = document.createElement(split.shift());
  if (split.length > 0) {
    element.classList.add(...split);
  }
  if (propsOrChildren) {
    if (typeof propsOrChildren === "string") {
      propsOrChildren = { textContent: propsOrChildren };
    } else if (propsOrChildren instanceof Element) {
      propsOrChildren = [propsOrChildren];
    }
    if (Array.isArray(propsOrChildren)) {
      element.append(...propsOrChildren);
    } else {
      const _a2 = propsOrChildren, {
        parent,
        $: cb,
        dataset,
        style
      } = _a2, rest = __objRest2(_a2, [
        "parent",
        "$",
        "dataset",
        "style"
      ]);
      if (rest.for) {
        element.setAttribute("for", rest.for);
      }
      if (style) {
        Object.assign(element.style, style);
      }
      if (dataset) {
        Object.assign(element.dataset, dataset);
      }
      Object.assign(element, rest);
      if (children) {
        element.append(...Array.isArray(children) ? children : [children]);
      }
      if (parent) {
        parent.append(element);
      }
      if (cb) {
        cb(element);
      }
    }
  }
  return element;
}
function dragElement(dragEl, settings) {
  var posDiffX = 0, posDiffY = 0, posStartX = 0, posStartY = 0, newPosX = 0, newPosY = 0;
  if (dragEl.getElementsByClassName("drag-handle")[0]) {
    dragEl.getElementsByClassName("drag-handle")[0].onmousedown = dragMouseDown;
  } else {
    dragEl.onmousedown = dragMouseDown;
  }
  const resizeObserver = new ResizeObserver(() => {
    ensureInBounds();
  }).observe(dragEl);
  function ensureInBounds() {
    try {
      newPosX = Math.min(
        document.body.clientWidth - dragEl.clientWidth,
        Math.max(0, dragEl.offsetLeft)
      );
      newPosY = Math.min(
        document.body.clientHeight - dragEl.clientHeight,
        Math.max(0, dragEl.offsetTop)
      );
      positionElement();
    } catch (exception) {
    }
  }
  function positionElement() {
    if (dragEl.style.display === "none") return;
    const halfWidth = document.body.clientWidth / 2;
    const anchorRight = newPosX + dragEl.clientWidth / 2 > halfWidth;
    if (anchorRight) {
      dragEl.style.left = "unset";
      dragEl.style.right = document.body.clientWidth - newPosX - dragEl.clientWidth + "px";
    } else {
      dragEl.style.left = newPosX + "px";
      dragEl.style.right = "unset";
    }
    dragEl.style.top = newPosY + "px";
    dragEl.style.bottom = "unset";
    if (savePos) {
      localStorage.setItem(
        "Comfy.MenuPosition",
        JSON.stringify({
          x: dragEl.offsetLeft,
          y: dragEl.offsetTop
        })
      );
    }
  }
  function restorePos() {
    let posString = localStorage.getItem("Comfy.MenuPosition");
    if (posString) {
      const pos2 = JSON.parse(posString);
      newPosX = pos2.x;
      newPosY = pos2.y;
      positionElement();
      ensureInBounds();
    }
  }
  let savePos = void 0;
  settings.addSetting({
    id: "Comfy.MenuPosition",
    name: "Save menu position",
    type: "boolean",
    defaultValue: savePos,
    onChange(value3) {
      if (savePos === void 0 && value3) {
        restorePos();
      }
      savePos = value3;
    }
  });
  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    posStartX = e.clientX;
    posStartY = e.clientY;
    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;
  }
  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    dragEl.classList.add("comfy-menu-manual-pos");
    posDiffX = e.clientX - posStartX;
    posDiffY = e.clientY - posStartY;
    posStartX = e.clientX;
    posStartY = e.clientY;
    newPosX = Math.min(
      document.body.clientWidth - dragEl.clientWidth,
      Math.max(0, dragEl.offsetLeft + posDiffX)
    );
    newPosY = Math.min(
      document.body.clientHeight - dragEl.clientHeight,
      Math.max(0, dragEl.offsetTop + posDiffY)
    );
    positionElement();
  }
  window.addEventListener("resize", () => {
    ensureInBounds();
  });
  function closeDragElement() {
    document.onmouseup = null;
    document.onmousemove = null;
  }
  return restorePos;
}
class ComfyList {
  constructor(text2, type, reverse) {
    __privateAdd(this, _type);
    __privateAdd(this, _text);
    __privateAdd(this, _reverse);
    __publicField2(this, "element");
    __publicField2(this, "button");
    __privateSet(this, _text, text2);
    __privateSet(this, _type, type || text2.toLowerCase());
    __privateSet(this, _reverse, reverse || false);
    this.element = $el("div.comfy-list");
    this.element.style.display = "none";
  }
  get visible() {
    return this.element.style.display !== "none";
  }
  load() {
    return __async(this, null, function* () {
      const items2 = yield api.getItems(__privateGet(this, _type));
      this.element.replaceChildren(
        ...Object.keys(items2).flatMap((section) => [
          $el("h4", {
            textContent: section
          }),
          $el("div.comfy-list-items", [
            ...(__privateGet(this, _reverse) ? items2[section].reverse() : items2[section]).map(
              (item) => {
                const removeAction = "remove" in item ? item.remove : {
                  name: "Delete",
                  cb: () => api.deleteItem(__privateGet(this, _type), item.prompt[1])
                };
                return $el("div", { textContent: item.prompt[0] + ": " }, [
                  $el("button", {
                    textContent: "Load",
                    onclick: () => __async(this, null, function* () {
                      var _a2, _b, _c;
                      yield app$1.loadGraphData(
                        item.prompt[3].extra_pnginfo.workflow,
                        true,
                        false
                      );
                      if ("outputs" in item) {
                        app$1.nodeOutputs = {};
                        for (const [key, value3] of Object.entries(item.outputs)) {
                          const realKey = (_c = (_b = (_a2 = item["meta"]) == null ? void 0 : _a2[key]) == null ? void 0 : _b.display_node) != null ? _c : key;
                          app$1.nodeOutputs[realKey] = value3;
                        }
                      }
                    })
                  }),
                  $el("button", {
                    textContent: removeAction.name,
                    onclick: () => __async(this, null, function* () {
                      yield removeAction.cb();
                      yield this.update();
                    })
                  })
                ]);
              }
            )
          ])
        ]),
        $el("div.comfy-list-actions", [
          $el("button", {
            textContent: "Clear " + __privateGet(this, _text),
            onclick: () => __async(this, null, function* () {
              yield api.clearItems(__privateGet(this, _type));
              yield this.load();
            })
          }),
          $el("button", { textContent: "Refresh", onclick: () => this.load() })
        ])
      );
    });
  }
  update() {
    return __async(this, null, function* () {
      if (this.visible) {
        yield this.load();
      }
    });
  }
  show() {
    return __async(this, null, function* () {
      this.element.style.display = "block";
      this.button.textContent = "Close";
      yield this.load();
    });
  }
  hide() {
    this.element.style.display = "none";
    this.button.textContent = "View " + __privateGet(this, _text);
  }
  toggle() {
    if (this.visible) {
      this.hide();
      return false;
    } else {
      this.show();
      return true;
    }
  }
}
_type = new WeakMap();
_text = new WeakMap();
_reverse = new WeakMap();
class ComfyUI {
  constructor(app2) {
    __publicField2(this, "app");
    __publicField2(this, "dialog");
    __publicField2(this, "settings");
    __publicField2(this, "batchCount");
    __publicField2(this, "lastQueueSize");
    __publicField2(this, "queue");
    __publicField2(this, "history");
    __publicField2(this, "autoQueueMode");
    __publicField2(this, "graphHasChanged");
    __publicField2(this, "autoQueueEnabled");
    __publicField2(this, "menuHamburger");
    __publicField2(this, "menuContainer");
    __publicField2(this, "queueSize");
    __publicField2(this, "restoreMenuPosition");
    __publicField2(this, "loadFile");
    this.app = app2;
    this.dialog = new ComfyDialog();
    this.settings = new ComfySettingsDialog(app2);
    this.batchCount = 1;
    this.lastQueueSize = 0;
    this.queue = new ComfyList("Queue");
    this.history = new ComfyList("History", "history", true);
    api.addEventListener("status", () => {
      this.queue.update();
      this.history.update();
    });
    const confirmClear = this.settings.addSetting({
      id: "Comfy.ConfirmClear",
      name: "Require confirmation when clearing workflow",
      type: "boolean",
      defaultValue: true
    });
    const promptFilename = this.settings.addSetting({
      id: "Comfy.PromptFilename",
      name: "Prompt for filename when saving workflow",
      type: "boolean",
      defaultValue: true
    });
    const previewImage = this.settings.addSetting({
      id: "Comfy.PreviewFormat",
      name: "When displaying a preview in the image widget, convert it to a lightweight image, e.g. webp, jpeg, webp;50, etc.",
      type: "text",
      defaultValue: ""
    });
    this.settings.addSetting({
      id: "Comfy.DisableSliders",
      name: "Disable sliders.",
      type: "boolean",
      defaultValue: false
    });
    this.settings.addSetting({
      id: "Comfy.DisableFloatRounding",
      name: "Disable rounding floats (requires page reload).",
      type: "boolean",
      defaultValue: false
    });
    this.settings.addSetting({
      id: "Comfy.FloatRoundingPrecision",
      name: "Decimal places [0 = auto] (requires page reload).",
      type: "slider",
      attrs: {
        min: 0,
        max: 6,
        step: 1
      },
      defaultValue: 0
    });
    this.settings.addSetting({
      id: "Comfy.EnableTooltips",
      name: "Enable Tooltips",
      type: "boolean",
      defaultValue: true
    });
    const fileInput2 = $el("input", {
      id: "comfy-file-input",
      type: "file",
      accept: ".json,image/png,.latent,.safetensors,image/webp,audio/flac",
      style: { display: "none" },
      parent: document.body,
      onchange: () => {
        app2.handleFile(fileInput2.files[0]);
      }
    });
    this.loadFile = () => fileInput2.click();
    const autoQueueModeEl = toggleSwitch(
      "autoQueueMode",
      [
        {
          text: "instant",
          tooltip: "A new prompt will be queued as soon as the queue reaches 0"
        },
        {
          text: "change",
          tooltip: "A new prompt will be queued when the queue is at 0 and the graph is/has changed"
        }
      ],
      {
        onChange: (value3) => {
          this.autoQueueMode = value3.item.value;
        }
      }
    );
    autoQueueModeEl.style.display = "none";
    api.addEventListener("graphChanged", () => {
      if (this.autoQueueMode === "change" && this.autoQueueEnabled === true) {
        if (this.lastQueueSize === 0) {
          this.graphHasChanged = false;
          app2.queuePrompt(0, this.batchCount);
        } else {
          this.graphHasChanged = true;
        }
      }
    });
    this.menuHamburger = $el(
      "div.comfy-menu-hamburger",
      {
        parent: document.body,
        onclick: () => {
          this.menuContainer.style.display = "block";
          this.menuHamburger.style.display = "none";
        }
      },
      [$el("div"), $el("div"), $el("div")]
    );
    this.menuContainer = $el("div.comfy-menu", { parent: document.body }, [
      $el(
        "div.drag-handle.comfy-menu-header",
        {
          style: {
            overflow: "hidden",
            position: "relative",
            width: "100%",
            cursor: "default"
          }
        },
        [
          $el("span.drag-handle"),
          $el("span.comfy-menu-queue-size", { $: (q) => this.queueSize = q }),
          $el("div.comfy-menu-actions", [
            $el("button.comfy-settings-btn", {
              textContent: "⚙️",
              onclick: () => this.settings.show()
            }),
            $el("button.comfy-close-menu-btn", {
              textContent: "×",
              onclick: () => {
                this.menuContainer.style.display = "none";
                this.menuHamburger.style.display = "flex";
              }
            })
          ])
        ]
      ),
      $el("button.comfy-queue-btn", {
        id: "queue-button",
        textContent: "Queue Prompt",
        onclick: () => app2.queuePrompt(0, this.batchCount)
      }),
      $el("div", {}, [
        $el("label", { innerHTML: "Extra options" }, [
          $el("input", {
            type: "checkbox",
            onchange: (i2) => {
              document.getElementById("extraOptions").style.display = i2.srcElement.checked ? "block" : "none";
              this.batchCount = i2.srcElement.checked ? Number.parseInt(
                document.getElementById(
                  "batchCountInputRange"
                ).value
              ) : 1;
              document.getElementById("autoQueueCheckbox").checked = false;
              this.autoQueueEnabled = false;
            }
          })
        ])
      ]),
      $el(
        "div",
        { id: "extraOptions", style: { width: "100%", display: "none" } },
        [
          $el("div", [
            $el("label", { innerHTML: "Batch count" }),
            $el("input", {
              id: "batchCountInputNumber",
              type: "number",
              value: this.batchCount,
              min: "1",
              style: { width: "35%", marginLeft: "0.4em" },
              oninput: (i2) => {
                this.batchCount = i2.target.value;
                document.getElementById(
                  "batchCountInputRange"
                ).value = this.batchCount.toString();
              }
            }),
            $el("input", {
              id: "batchCountInputRange",
              type: "range",
              min: "1",
              max: "100",
              value: this.batchCount,
              oninput: (i2) => {
                this.batchCount = i2.srcElement.value;
                document.getElementById(
                  "batchCountInputNumber"
                ).value = i2.srcElement.value;
              }
            })
          ]),
          $el("div", [
            $el("label", {
              for: "autoQueueCheckbox",
              innerHTML: "Auto Queue"
            }),
            $el("input", {
              id: "autoQueueCheckbox",
              type: "checkbox",
              checked: false,
              title: "Automatically queue prompt when the queue size hits 0",
              onchange: (e) => {
                this.autoQueueEnabled = e.target.checked;
                autoQueueModeEl.style.display = this.autoQueueEnabled ? "" : "none";
              }
            }),
            autoQueueModeEl
          ])
        ]
      ),
      $el("div.comfy-menu-btns", [
        $el("button", {
          id: "queue-front-button",
          textContent: "Queue Front",
          onclick: () => app2.queuePrompt(-1, this.batchCount)
        }),
        $el("button", {
          $: (b) => this.queue.button = b,
          id: "comfy-view-queue-button",
          textContent: "View Queue",
          onclick: () => {
            this.history.hide();
            this.queue.toggle();
          }
        }),
        $el("button", {
          $: (b) => this.history.button = b,
          id: "comfy-view-history-button",
          textContent: "View History",
          onclick: () => {
            this.queue.hide();
            this.history.toggle();
          }
        })
      ]),
      this.queue.element,
      this.history.element,
      $el("button", {
        id: "comfy-save-button",
        textContent: "Save",
        onclick: () => {
          let filename = "workflow.json";
          if (promptFilename.value) {
            filename = prompt("Save workflow as:", filename);
            if (!filename) return;
            if (!filename.toLowerCase().endsWith(".json")) {
              filename += ".json";
            }
          }
          app2.graphToPrompt().then((p2) => {
            const json = JSON.stringify(p2.workflow, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = $el("a", {
              href: url,
              download: filename,
              style: { display: "none" },
              parent: document.body
            });
            a.click();
            setTimeout(function() {
              a.remove();
              window.URL.revokeObjectURL(url);
            }, 0);
          });
        }
      }),
      $el("button", {
        id: "comfy-dev-save-api-button",
        textContent: "Save (API Format)",
        style: { width: "100%", display: "none" },
        onclick: () => {
          let filename = "workflow_api.json";
          if (promptFilename.value) {
            filename = prompt("Save workflow (API) as:", filename);
            if (!filename) return;
            if (!filename.toLowerCase().endsWith(".json")) {
              filename += ".json";
            }
          }
          app2.graphToPrompt().then((p2) => {
            const json = JSON.stringify(p2.output, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = $el("a", {
              href: url,
              download: filename,
              style: { display: "none" },
              parent: document.body
            });
            a.click();
            setTimeout(function() {
              a.remove();
              window.URL.revokeObjectURL(url);
            }, 0);
          });
        }
      }),
      $el("button", {
        id: "comfy-load-button",
        textContent: "Load",
        onclick: () => fileInput2.click()
      }),
      $el("button", {
        id: "comfy-refresh-button",
        textContent: "Refresh",
        onclick: () => app2.refreshComboInNodes()
      }),
      $el("button", {
        id: "comfy-clipspace-button",
        textContent: "Clipspace",
        onclick: () => app2.openClipspace()
      }),
      $el("button", {
        id: "comfy-clear-button",
        textContent: "Clear",
        onclick: () => {
          if (!confirmClear.value || confirm("Clear workflow?")) {
            app2.clean();
            app2.graph.clear();
            app2.resetView();
            api.dispatchEvent(new CustomEvent("graphCleared"));
          }
        }
      }),
      $el("button", {
        id: "comfy-load-default-button",
        textContent: "Load Default",
        onclick: () => __async(this, null, function* () {
          if (!confirmClear.value || confirm("Load default workflow?")) {
            app2.resetView();
            yield app2.loadGraphData();
          }
        })
      }),
      $el("button", {
        id: "comfy-reset-view-button",
        textContent: "Reset View",
        onclick: () => __async(this, null, function* () {
          app2.resetView();
        })
      })
    ]);
    const devMode = this.settings.addSetting({
      id: "Comfy.DevMode",
      name: "Enable Dev mode Options",
      type: "boolean",
      defaultValue: false,
      onChange: function(value3) {
        document.getElementById("comfy-dev-save-api-button").style.display = value3 ? "flex" : "none";
      }
    });
    this.restoreMenuPosition = dragElement(this.menuContainer, this.settings);
    this.setStatus({ exec_info: { queue_remaining: "X" } });
  }
  setStatus(status) {
    this.queueSize.textContent = "Queue size: " + (status ? status.exec_info.queue_remaining : "ERR");
    if (status) {
      if (this.lastQueueSize != 0 && status.exec_info.queue_remaining == 0 && this.autoQueueEnabled && (this.autoQueueMode === "instant" || this.graphHasChanged) && !app$1.lastExecutionError) {
        app$1.queuePrompt(0, this.batchCount);
        status.exec_info.queue_remaining += this.batchCount;
        this.graphHasChanged = false;
      }
      this.lastQueueSize = status.exec_info.queue_remaining;
    }
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.ui = window.comfyAPI.ui || {};
window.comfyAPI.ui.ComfyDialog = ComfyDialog;
window.comfyAPI.ui.$el = $el;
window.comfyAPI.ui.ComfyUI = ComfyUI;
$el("style", {
  textContent: `
        .comfy-logging-logs {
            display: grid;
            color: var(--fg-color);
            white-space: pre-wrap;
        }
        .comfy-logging-log {
            display: contents;
        }
        .comfy-logging-title {
            background: var(--tr-even-bg-color);
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }
        .comfy-logging-log div {
            background: var(--row-bg);
            padding: 5px;
        }
    `,
  parent: document.body
});
function stringify(val, depth, replacer2, space, onGetObjID) {
  depth = isNaN(+depth) ? 1 : depth;
  var recursMap = /* @__PURE__ */ new WeakMap();
  function _build(val2, depth2, o, a, r) {
    return !val2 || typeof val2 != "object" ? val2 : (r = recursMap.has(val2), recursMap.set(val2, true), a = Array.isArray(val2), r ? o = onGetObjID && onGetObjID(val2) || null : JSON.stringify(val2, function(k, v2) {
      if (a || depth2 > 0) {
        if (replacer2) v2 = replacer2(k, v2);
        if (!k) return a = Array.isArray(v2), val2 = v2;
        !o && (o = a ? [] : {});
        o[k] = _build(v2, a ? depth2 : depth2 - 1);
      }
    }), o === void 0 ? a ? [] : {} : o);
  }
  return JSON.stringify(_build(val, depth), null, space);
}
const jsonReplacer = (k, v2, ui) => {
  if (v2 instanceof Array && v2.length === 1) {
    v2 = v2[0];
  }
  if (v2 instanceof Date) {
    v2 = v2.toISOString();
    if (ui) {
      v2 = v2.split("T")[1];
    }
  }
  if (v2 instanceof Error) {
    let err = "";
    if (v2.name) err += v2.name + "\n";
    if (v2.message) err += v2.message + "\n";
    if (v2.stack) err += v2.stack + "\n";
    if (!err) {
      err = v2.toString();
    }
    v2 = err;
  }
  return v2;
};
const fileInput$1 = $el("input", {
  type: "file",
  accept: ".json",
  style: { display: "none" },
  parent: document.body
});
class ComfyLoggingDialog extends ComfyDialog {
  constructor(logging) {
    super();
    __publicField2(this, "logging");
    this.logging = logging;
  }
  clear() {
    this.logging.clear();
    this.show();
  }
  export() {
    const blob = new Blob(
      [stringify([...this.logging.entries], 20, jsonReplacer, "	")],
      {
        type: "application/json"
      }
    );
    const url = URL.createObjectURL(blob);
    const a = $el("a", {
      href: url,
      download: `comfyui-logs-${Date.now()}.json`,
      style: { display: "none" },
      parent: document.body
    });
    a.click();
    setTimeout(function() {
      a.remove();
      window.URL.revokeObjectURL(url);
    }, 0);
  }
  import() {
    fileInput$1.onchange = () => {
      const reader = new FileReader();
      reader.onload = () => {
        fileInput$1.remove();
        try {
          const obj = JSON.parse(reader.result);
          if (obj instanceof Array) {
            this.show(obj);
          } else {
            throw new Error("Invalid file selected.");
          }
        } catch (error) {
          alert("Unable to load logs: " + error.message);
        }
      };
      reader.readAsText(fileInput$1.files[0]);
    };
    fileInput$1.click();
  }
  createButtons() {
    return [
      $el("button", {
        type: "button",
        textContent: "Clear",
        onclick: () => this.clear()
      }),
      $el("button", {
        type: "button",
        textContent: "Export logs...",
        onclick: () => this.export()
      }),
      $el("button", {
        type: "button",
        textContent: "View exported logs...",
        onclick: () => this.import()
      }),
      ...super.createButtons()
    ];
  }
  getTypeColor(type) {
    switch (type) {
      case "error":
        return "red";
      case "warn":
        return "orange";
      case "debug":
        return "dodgerblue";
    }
  }
  show(entries) {
    if (!entries) entries = this.logging.entries;
    this.element.style.width = "100%";
    const cols = {
      source: "Source",
      type: "Type",
      timestamp: "Timestamp",
      message: "Message"
    };
    const keys = Object.keys(cols);
    const headers = Object.values(cols).map(
      (title) => $el("div.comfy-logging-title", {
        textContent: title
      })
    );
    const rows3 = entries.map((entry, i2) => {
      return $el(
        "div.comfy-logging-log",
        {
          $: (el) => el.style.setProperty(
            "--row-bg",
            `var(--tr-${i2 % 2 ? "even" : "odd"}-bg-color)`
          )
        },
        keys.map((key) => {
          let v2 = entry[key];
          let color;
          if (key === "type") {
            color = this.getTypeColor(v2);
          } else {
            v2 = jsonReplacer(key, v2, true);
            if (typeof v2 === "object") {
              v2 = stringify(v2, 5, jsonReplacer, "  ");
            }
          }
          return $el("div", {
            style: {
              color
            },
            textContent: v2
          });
        })
      );
    });
    const grid = $el(
      "div.comfy-logging-logs",
      {
        style: {
          gridTemplateColumns: `repeat(${headers.length}, 1fr)`
        }
      },
      [...headers, ...rows3]
    );
    const els = [grid];
    if (!this.logging.enabled) {
      els.unshift(
        $el("h3", {
          style: { textAlign: "center" },
          textContent: "Logging is disabled"
        })
      );
    }
    super.show($el("div", els));
  }
}
class ComfyLogging {
  constructor(app2) {
    /**
     * @type Array<{ source: string, type: string, timestamp: Date, message: any }>
     */
    __publicField2(this, "entries", []);
    __privateAdd(this, _enabled);
    __privateAdd(this, _console, {});
    __publicField2(this, "app");
    __publicField2(this, "dialog");
    this.app = app2;
    this.dialog = new ComfyLoggingDialog(this);
    this.addSetting();
    this.catchUnhandled();
    this.addInitData();
  }
  get enabled() {
    return __privateGet(this, _enabled);
  }
  set enabled(value3) {
    if (value3 === __privateGet(this, _enabled)) return;
    if (value3) {
      this.patchConsole();
    } else {
      this.unpatchConsole();
    }
    __privateSet(this, _enabled, value3);
  }
  addSetting() {
    const settingId = "Comfy.Logging.Enabled";
    const htmlSettingId = settingId.replaceAll(".", "-");
    const setting = this.app.ui.settings.addSetting({
      id: settingId,
      name: settingId,
      defaultValue: true,
      onChange: (value3) => {
        this.enabled = value3;
      },
      type: (name, setter, value3) => {
        return $el("tr", [
          $el("td", [
            $el("label", {
              textContent: "Logging",
              for: htmlSettingId
            })
          ]),
          $el("td", [
            $el("input", {
              id: htmlSettingId,
              type: "checkbox",
              checked: value3,
              onchange: (event2) => {
                setter(event2.target.checked);
              }
            }),
            $el("button", {
              textContent: "View Logs",
              onclick: () => {
                this.app.ui.settings.element.close();
                this.dialog.show();
              },
              style: {
                fontSize: "14px",
                display: "block",
                marginTop: "5px"
              }
            })
          ])
        ]);
      }
    });
    this.enabled = setting.value;
  }
  patchConsole() {
    const self2 = this;
    for (const type of ["log", "warn", "error", "debug"]) {
      const orig = console[type];
      __privateGet(this, _console)[type] = orig;
      console[type] = function() {
        orig.apply(console, arguments);
        self2.addEntry("console", type, ...arguments);
      };
    }
  }
  unpatchConsole() {
    for (const type of Object.keys(__privateGet(this, _console))) {
      console[type] = __privateGet(this, _console)[type];
    }
    __privateSet(this, _console, {});
  }
  catchUnhandled() {
    window.addEventListener("error", (e) => {
      var _a2;
      this.addEntry("window", "error", (_a2 = e.error) != null ? _a2 : "Unknown error");
      return false;
    });
    window.addEventListener("unhandledrejection", (e) => {
      var _a2;
      this.addEntry("unhandledrejection", "error", (_a2 = e.reason) != null ? _a2 : "Unknown error");
    });
  }
  clear() {
    this.entries = [];
  }
  addEntry(source, type, ...args) {
    if (this.enabled) {
      this.entries.push({
        source,
        type,
        timestamp: /* @__PURE__ */ new Date(),
        message: args
      });
    }
  }
  log(source, ...args) {
    this.addEntry(source, "log", ...args);
  }
  addInitData() {
    return __async(this, null, function* () {
      if (!this.enabled) return;
      const source = "ComfyUI.Logging";
      this.addEntry(source, "debug", { UserAgent: navigator.userAgent });
      const systemStats = yield api.getSystemStats();
      this.addEntry(source, "debug", systemStats);
    });
  }
}
_enabled = new WeakMap();
_console = new WeakMap();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.logging = window.comfyAPI.logging || {};
window.comfyAPI.logging.ComfyLogging = ComfyLogging;
var __defProp$1 = Object.defineProperty;
var __defNormalProp = (obj, key, value3) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3;
var __publicField = (obj, key, value3) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value3);
const globalExport = {};
(function(globalThis) {
  var LiteGraph = globalThis.LiteGraph = {
    VERSION: 0.4,
    CANVAS_GRID_SIZE: 10,
    NODE_TITLE_HEIGHT: 30,
    NODE_TITLE_TEXT_Y: 20,
    NODE_SLOT_HEIGHT: 20,
    NODE_WIDGET_HEIGHT: 20,
    NODE_WIDTH: 140,
    NODE_MIN_WIDTH: 50,
    NODE_COLLAPSED_RADIUS: 10,
    NODE_COLLAPSED_WIDTH: 80,
    NODE_TITLE_COLOR: "#999",
    NODE_SELECTED_TITLE_COLOR: "#FFF",
    NODE_TEXT_SIZE: 14,
    NODE_TEXT_COLOR: "#AAA",
    NODE_SUBTEXT_SIZE: 12,
    NODE_DEFAULT_COLOR: "#333",
    NODE_DEFAULT_BGCOLOR: "#353535",
    NODE_DEFAULT_BOXCOLOR: "#666",
    NODE_DEFAULT_SHAPE: "box",
    NODE_BOX_OUTLINE_COLOR: "#FFF",
    DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",
    DEFAULT_GROUP_FONT: 24,
    WIDGET_BGCOLOR: "#222",
    WIDGET_OUTLINE_COLOR: "#666",
    WIDGET_TEXT_COLOR: "#DDD",
    WIDGET_SECONDARY_TEXT_COLOR: "#999",
    LINK_COLOR: "#9A9",
    EVENT_LINK_COLOR: "#A86",
    CONNECTING_LINK_COLOR: "#AFA",
    MAX_NUMBER_OF_NODES: 1e4,
    //avoid infinite loops
    DEFAULT_POSITION: [100, 100],
    //default node position
    VALID_SHAPES: ["default", "box", "round", "card"],
    //,"circle"
    //shapes are used for nodes but also for slots
    BOX_SHAPE: 1,
    ROUND_SHAPE: 2,
    CIRCLE_SHAPE: 3,
    CARD_SHAPE: 4,
    ARROW_SHAPE: 5,
    GRID_SHAPE: 6,
    // intended for slot arrays
    //enums
    INPUT: 1,
    OUTPUT: 2,
    EVENT: -1,
    //for outputs
    ACTION: -1,
    //for inputs
    NODE_MODES: ["Always", "On Event", "Never", "On Trigger"],
    // helper, will add "On Request" and more in the future
    NODE_MODES_COLORS: ["#666", "#422", "#333", "#224", "#626"],
    // use with node_box_coloured_by_mode
    ALWAYS: 0,
    ON_EVENT: 1,
    NEVER: 2,
    ON_TRIGGER: 3,
    UP: 1,
    DOWN: 2,
    LEFT: 3,
    RIGHT: 4,
    CENTER: 5,
    LINK_RENDER_MODES: ["Straight", "Linear", "Spline"],
    // helper
    STRAIGHT_LINK: 0,
    LINEAR_LINK: 1,
    SPLINE_LINK: 2,
    NORMAL_TITLE: 0,
    NO_TITLE: 1,
    TRANSPARENT_TITLE: 2,
    AUTOHIDE_TITLE: 3,
    VERTICAL_LAYOUT: "vertical",
    // arrange nodes vertically
    proxy: null,
    //used to redirect calls
    node_images_path: "",
    debug: false,
    catch_exceptions: true,
    throw_errors: true,
    allow_scripts: false,
    //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits
    registered_node_types: {},
    //nodetypes by string
    node_types_by_file_extension: {},
    //used for dropping files in the canvas
    Nodes: {},
    //node types by classname
    Globals: {},
    //used to store vars between graphs
    searchbox_extras: {},
    //used to add extra features to the search box
    auto_sort_node_types: false,
    // [true!] If set to true, will automatically sort node types / categories in the context menus
    node_box_coloured_when_on: false,
    // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback
    node_box_coloured_by_mode: false,
    // [true!] nodebox based on node mode, visual feedback
    dialog_close_on_mouse_leave: false,
    // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false
    dialog_close_on_mouse_leave_delay: 500,
    shift_click_do_break_link_from: false,
    // [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys
    click_do_break_link_to: false,
    // [false!]prefer false, way too easy to break links
    ctrl_alt_click_do_break_link: true,
    // [true!] who accidentally ctrl-alt-clicks on an in/output? nobody! that's who!
    search_hide_on_mouse_leave: true,
    // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false
    search_filter_enabled: false,
    // [true!] enable filtering slots type in the search widget, !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]
    search_show_all_on_open: true,
    // [true!] opens the results list when opening the search widget
    auto_load_slot_types: false,
    // [if want false, use true, run, get vars values to be statically set, than disable] nodes types and nodeclass association with node types need to be calculated, if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]
    // set these values if not using auto_load_slot_types
    registered_slot_in_types: {},
    // slot types for nodeclass
    registered_slot_out_types: {},
    // slot types for nodeclass
    slot_types_in: [],
    // slot types IN
    slot_types_out: [],
    // slot types OUT
    slot_types_default_in: [],
    // specify for each IN slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search
    slot_types_default_out: [],
    // specify for each OUT slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search
    alt_drag_do_clone_nodes: false,
    // [true!] very handy, ALT click to clone and drag the new node
    do_add_triggers_slots: false,
    // [true!] will create and connect event slots when using action/events connections, !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this
    allow_multi_output_for_events: true,
    // [false!] being events, it is strongly reccomended to use them sequentially, one by one
    middle_click_slot_add_default_node: false,
    //[true!] allows to create and connect a ndoe clicking with the third button (wheel)
    release_link_on_empty_shows_menu: false,
    //[true!] dragging a link to empty space will open a menu, add from list, search or defaults
    pointerevents_method: "pointer",
    // "mouse"|"pointer" use mouse for retrocompatibility issues? (none found @ now)
    // TODO implement pointercancel, gotpointercapture, lostpointercapture, (pointerover, pointerout if necessary)
    ctrl_shift_v_paste_connect_unselected_outputs: true,
    //[true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected with the inputs of the newly pasted nodes
    // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.
    // use this if you must have node IDs that are unique across all graphs and subgraphs.
    use_uuids: false,
    /**
     * Register a node class so it can be listed when the user wants to create a new one
     * @method registerNodeType
     * @param {String} type name of the node and path
     * @param {Class} base_class class containing the structure of a node
     */
    registerNodeType: function(type, base_class) {
      if (!base_class.prototype) {
        throw "Cannot register a simple object, it must be a class with a prototype";
      }
      base_class.type = type;
      if (LiteGraph.debug) {
        console.log("Node registered: " + type);
      }
      const classname = base_class.name;
      const pos2 = type.lastIndexOf("/");
      base_class.category = type.substring(0, pos2);
      if (!base_class.title) {
        base_class.title = classname;
      }
      for (var i2 in LGraphNode.prototype) {
        if (!base_class.prototype[i2]) {
          base_class.prototype[i2] = LGraphNode.prototype[i2];
        }
      }
      const prev2 = this.registered_node_types[type];
      if (prev2) {
        console.log("replacing node type: " + type);
      }
      if (!Object.prototype.hasOwnProperty.call(base_class.prototype, "shape")) {
        Object.defineProperty(base_class.prototype, "shape", {
          set: function(v2) {
            switch (v2) {
              case "default":
                delete this._shape;
                break;
              case "box":
                this._shape = LiteGraph.BOX_SHAPE;
                break;
              case "round":
                this._shape = LiteGraph.ROUND_SHAPE;
                break;
              case "circle":
                this._shape = LiteGraph.CIRCLE_SHAPE;
                break;
              case "card":
                this._shape = LiteGraph.CARD_SHAPE;
                break;
              default:
                this._shape = v2;
            }
          },
          get: function() {
            return this._shape;
          },
          enumerable: true,
          configurable: true
        });
        if (base_class.supported_extensions) {
          for (let i3 in base_class.supported_extensions) {
            const ext = base_class.supported_extensions[i3];
            if (ext && ext.constructor === String) {
              this.node_types_by_file_extension[ext.toLowerCase()] = base_class;
            }
          }
        }
      }
      this.registered_node_types[type] = base_class;
      if (base_class.constructor.name) {
        this.Nodes[classname] = base_class;
      }
      if (LiteGraph.onNodeTypeRegistered) {
        LiteGraph.onNodeTypeRegistered(type, base_class);
      }
      if (prev2 && LiteGraph.onNodeTypeReplaced) {
        LiteGraph.onNodeTypeReplaced(type, base_class, prev2);
      }
      if (base_class.prototype.onPropertyChange) {
        console.warn(
          "LiteGraph node class " + type + " has onPropertyChange method, it must be called onPropertyChanged with d at the end"
        );
      }
      if (this.auto_load_slot_types) {
        new base_class(base_class.title || "tmpnode");
      }
    },
    /**
     * removes a node type from the system
     * @method unregisterNodeType
     * @param {String|Object} type name of the node or the node constructor itself
     */
    unregisterNodeType: function(type) {
      const base_class = type.constructor === String ? this.registered_node_types[type] : type;
      if (!base_class) {
        throw "node type not found: " + type;
      }
      delete this.registered_node_types[base_class.type];
      if (base_class.constructor.name) {
        delete this.Nodes[base_class.constructor.name];
      }
    },
    /**
    * Save a slot type and his node
    * @method registerSlotType
    * @param {String|Object} type name of the node or the node constructor itself
    * @param {String} slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..
    */
    registerNodeAndSlotType: function(type, slot_type, out) {
      out = out || false;
      const base_class = type.constructor === String && this.registered_node_types[type] !== "anonymous" ? this.registered_node_types[type] : type;
      const class_type = base_class.constructor.type;
      let allTypes = [];
      if (typeof slot_type === "string") {
        allTypes = slot_type.split(",");
      } else if (slot_type == this.EVENT || slot_type == this.ACTION) {
        allTypes = ["_event_"];
      } else {
        allTypes = ["*"];
      }
      for (let i2 = 0; i2 < allTypes.length; ++i2) {
        let slotType = allTypes[i2];
        if (slotType === "") {
          slotType = "*";
        }
        const registerTo = out ? "registered_slot_out_types" : "registered_slot_in_types";
        if (this[registerTo][slotType] === void 0) {
          this[registerTo][slotType] = { nodes: [] };
        }
        if (!this[registerTo][slotType].nodes.includes(class_type)) {
          this[registerTo][slotType].nodes.push(class_type);
        }
        if (!out) {
          if (!this.slot_types_in.includes(slotType.toLowerCase())) {
            this.slot_types_in.push(slotType.toLowerCase());
            this.slot_types_in.sort();
          }
        } else {
          if (!this.slot_types_out.includes(slotType.toLowerCase())) {
            this.slot_types_out.push(slotType.toLowerCase());
            this.slot_types_out.sort();
          }
        }
      }
    },
    /**
     * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.
     * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.
     * @method wrapFunctionAsNode
     * @param {String} name node name with namespace (p.e.: 'math/sum')
     * @param {Function} func
     * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type
     * @param {String} return_type [optional] string with the return type, otherwise it will be generic
     * @param {Object} properties [optional] properties to be configurable
     */
    wrapFunctionAsNode: function(name, func, param_types, return_type, properties) {
      var params = Array(func.length);
      var code2 = "";
      var names = LiteGraph.getParameterNames(func);
      for (var i2 = 0; i2 < names.length; ++i2) {
        code2 += "this.addInput('" + names[i2] + "'," + (param_types && param_types[i2] ? "'" + param_types[i2] + "'" : "0") + ");\n";
      }
      code2 += "this.addOutput('out'," + (return_type ? "'" + return_type + "'" : 0) + ");\n";
      if (properties) {
        code2 += "this.properties = " + JSON.stringify(properties) + ";\n";
      }
      var classobj = Function(code2);
      classobj.title = name.split("/").pop();
      classobj.desc = "Generated from " + func.name;
      classobj.prototype.onExecute = function onExecute() {
        for (var i3 = 0; i3 < params.length; ++i3) {
          params[i3] = this.getInputData(i3);
        }
        var r = func.apply(this, params);
        this.setOutputData(0, r);
      };
      this.registerNodeType(name, classobj);
    },
    /**
     * Removes all previously registered node's types
     */
    clearRegisteredTypes: function() {
      this.registered_node_types = {};
      this.node_types_by_file_extension = {};
      this.Nodes = {};
      this.searchbox_extras = {};
    },
    /**
     * Adds this method to all nodetypes, existing and to be created
     * (You can add it to LGraphNode.prototype but then existing node types wont have it)
     * @method addNodeMethod
     * @param {Function} func
     */
    addNodeMethod: function(name, func) {
      LGraphNode.prototype[name] = func;
      for (var i2 in this.registered_node_types) {
        var type = this.registered_node_types[i2];
        if (type.prototype[name]) {
          type.prototype["_" + name] = type.prototype[name];
        }
        type.prototype[name] = func;
      }
    },
    /**
     * Create a node of a given type with a name. The node is not attached to any graph yet.
     * @method createNode
     * @param {String} type full name of the node class. p.e. "math/sin"
     * @param {String} name a name to distinguish from other nodes
     * @param {Object} options to set options
     */
    createNode: function(type, title, options3) {
      var base_class = this.registered_node_types[type];
      if (!base_class) {
        if (LiteGraph.debug) {
          console.log(
            'GraphNode type "' + type + '" not registered.'
          );
        }
        return null;
      }
      base_class.prototype || base_class;
      title = title || base_class.title || type;
      var node22 = null;
      if (LiteGraph.catch_exceptions) {
        try {
          node22 = new base_class(title);
        } catch (err) {
          console.error(err);
          return null;
        }
      } else {
        node22 = new base_class(title);
      }
      node22.type = type;
      if (!node22.title && title) {
        node22.title = title;
      }
      if (!node22.properties) {
        node22.properties = {};
      }
      if (!node22.properties_info) {
        node22.properties_info = [];
      }
      if (!node22.flags) {
        node22.flags = {};
      }
      if (!node22.size) {
        node22.size = node22.computeSize();
      }
      if (!node22.pos) {
        node22.pos = LiteGraph.DEFAULT_POSITION.concat();
      }
      if (!node22.mode) {
        node22.mode = LiteGraph.ALWAYS;
      }
      if (options3) {
        for (var i2 in options3) {
          node22[i2] = options3[i2];
        }
      }
      if (node22.onNodeCreated) {
        node22.onNodeCreated();
      }
      return node22;
    },
    /**
     * Returns a registered node type with a given name
     * @method getNodeType
     * @param {String} type full name of the node class. p.e. "math/sin"
     * @return {Class} the node class
     */
    getNodeType: function(type) {
      return this.registered_node_types[type];
    },
    /**
     * Returns a list of node types matching one category
     * @method getNodeType
     * @param {String} category category name
     * @return {Array} array with all the node classes
     */
    getNodeTypesInCategory: function(category, filter5) {
      var r = [];
      for (var i2 in this.registered_node_types) {
        var type = this.registered_node_types[i2];
        if (type.filter != filter5) {
          continue;
        }
        if (category == "") {
          if (type.category == null) {
            r.push(type);
          }
        } else if (type.category == category) {
          r.push(type);
        }
      }
      if (this.auto_sort_node_types) {
        r.sort(function(a, b) {
          return a.title.localeCompare(b.title);
        });
      }
      return r;
    },
    /**
     * Returns a list with all the node type categories
     * @method getNodeTypesCategories
     * @param {String} filter only nodes with ctor.filter equal can be shown
     * @return {Array} array with all the names of the categories
     */
    getNodeTypesCategories: function(filter5) {
      var categories = { "": 1 };
      for (var i2 in this.registered_node_types) {
        var type = this.registered_node_types[i2];
        if (type.category && !type.skip_list) {
          if (type.filter != filter5)
            continue;
          categories[type.category] = 1;
        }
      }
      var result = [];
      for (var i2 in categories) {
        result.push(i2);
      }
      return this.auto_sort_node_types ? result.sort() : result;
    },
    //debug purposes: reloads all the js scripts that matches a wildcard
    reloadNodes: function(folder_wildcard) {
      var tmp = document.getElementsByTagName("script");
      var script_files = [];
      for (var i2 = 0; i2 < tmp.length; i2++) {
        script_files.push(tmp[i2]);
      }
      var docHeadObj = document.getElementsByTagName("head")[0];
      folder_wildcard = document.location.href + folder_wildcard;
      for (var i2 = 0; i2 < script_files.length; i2++) {
        var src = script_files[i2].src;
        if (!src || src.substr(0, folder_wildcard.length) != folder_wildcard) {
          continue;
        }
        try {
          if (LiteGraph.debug) {
            console.log("Reloading: " + src);
          }
          var dynamicScript = document.createElement("script");
          dynamicScript.type = "text/javascript";
          dynamicScript.src = src;
          docHeadObj.appendChild(dynamicScript);
          docHeadObj.removeChild(script_files[i2]);
        } catch (err) {
          if (LiteGraph.throw_errors) {
            throw err;
          }
          if (LiteGraph.debug) {
            console.log("Error while reloading " + src);
          }
        }
      }
      if (LiteGraph.debug) {
        console.log("Nodes reloaded");
      }
    },
    //separated just to improve if it doesn't work
    cloneObject: function(obj, target) {
      if (obj == null) {
        return null;
      }
      var r = JSON.parse(JSON.stringify(obj));
      if (!target) {
        return r;
      }
      for (var i2 in r) {
        target[i2] = r[i2];
      }
      return target;
    },
    /*
     * https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670
     */
    uuidv4: function() {
      return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (a) => (a ^ Math.random() * 16 >> a / 4).toString(16));
    },
    /**
     * Returns if the types of two slots are compatible (taking into account wildcards, etc)
     * @method isValidConnection
     * @param {String} type_a
     * @param {String} type_b
     * @return {Boolean} true if they can be connected
     */
    isValidConnection: function(type_a, type_b) {
      if (type_a == "" || type_a === "*") type_a = 0;
      if (type_b == "" || type_b === "*") type_b = 0;
      if (!type_a || !type_b || type_a == type_b || type_a == LiteGraph.EVENT && type_b == LiteGraph.ACTION) {
        return true;
      }
      type_a = String(type_a);
      type_b = String(type_b);
      type_a = type_a.toLowerCase();
      type_b = type_b.toLowerCase();
      if (type_a.indexOf(",") == -1 && type_b.indexOf(",") == -1) {
        return type_a == type_b;
      }
      var supported_types_a = type_a.split(",");
      var supported_types_b = type_b.split(",");
      for (var i2 = 0; i2 < supported_types_a.length; ++i2) {
        for (var j = 0; j < supported_types_b.length; ++j) {
          if (this.isValidConnection(supported_types_a[i2], supported_types_b[j])) {
            return true;
          }
        }
      }
      return false;
    },
    /**
     * Register a string in the search box so when the user types it it will recommend this node
     * @method registerSearchboxExtra
     * @param {String} node_type the node recommended
     * @param {String} description text to show next to it
     * @param {Object} data it could contain info of how the node should be configured
     * @return {Boolean} true if they can be connected
     */
    registerSearchboxExtra: function(node_type, description, data28) {
      this.searchbox_extras[description.toLowerCase()] = {
        type: node_type,
        desc: description,
        data: data28
      };
    },
    /**
     * Wrapper to load files (from url using fetch or from file using FileReader)
     * @method fetchFile
     * @param {String|File|Blob} url the url of the file (or the file itself)
     * @param {String} type an string to know how to fetch it: "text","arraybuffer","json","blob"
     * @param {Function} on_complete callback(data)
     * @param {Function} on_error in case of an error
     * @return {FileReader|Promise} returns the object used to 
     */
    fetchFile: function(url, type, on_complete, on_error) {
      if (!url)
        return null;
      type = type || "text";
      if (url.constructor === String) {
        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {
          url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);
        }
        return fetch(url).then(function(response) {
          if (!response.ok)
            throw new Error("File not found");
          if (type == "arraybuffer")
            return response.arrayBuffer();
          else if (type == "text" || type == "string")
            return response.text();
          else if (type == "json")
            return response.json();
          else if (type == "blob")
            return response.blob();
        }).then(function(data28) {
          if (on_complete)
            on_complete(data28);
        }).catch(function(error) {
          console.error("error fetching file:", url);
          if (on_error)
            on_error(error);
        });
      } else if (url.constructor === File || url.constructor === Blob) {
        var reader = new FileReader();
        reader.onload = function(e) {
          var v2 = e.target.result;
          if (type == "json")
            v2 = JSON.parse(v2);
          if (on_complete)
            on_complete(v2);
        };
        if (type == "arraybuffer")
          return reader.readAsArrayBuffer(url);
        else if (type == "text" || type == "json")
          return reader.readAsText(url);
        else if (type == "blob")
          return reader.readAsBinaryString(url);
      }
      return null;
    }
  };
  if (typeof performance != "undefined") {
    LiteGraph.getTime = performance.now.bind(performance);
  } else if (typeof Date != "undefined" && Date.now) {
    LiteGraph.getTime = Date.now.bind(Date);
  } else if (typeof process != "undefined") {
    LiteGraph.getTime = function() {
      var t = process.hrtime();
      return t[0] * 1e-3 + t[1] * 1e-6;
    };
  } else {
    LiteGraph.getTime = function getTime() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
  const _LGraph = class _LGraph2 {
    constructor(o) {
      if (LiteGraph.debug) {
        console.log("Graph created");
      }
      this.list_of_graphcanvas = null;
      this.clear();
      if (o) {
        this.configure(o);
      }
    }
    //used to know which types of connections support this graph (some graphs do not allow certain types)
    getSupportedTypes() {
      return this.supported_types || _LGraph2.supported_types;
    }
    /**
         * Removes all nodes from this graph
         * @method clear
         */
    clear() {
      this.stop();
      this.status = _LGraph2.STATUS_STOPPED;
      this.last_node_id = 0;
      this.last_link_id = 0;
      this._version = -1;
      if (this._nodes) {
        for (var i2 = 0; i2 < this._nodes.length; ++i2) {
          var node22 = this._nodes[i2];
          if (node22.onRemoved) {
            node22.onRemoved();
          }
        }
      }
      this._nodes = [];
      this._nodes_by_id = {};
      this._nodes_in_order = [];
      this._nodes_executable = null;
      this._groups = [];
      this.links = {};
      this.iteration = 0;
      this.config = {};
      this.vars = {};
      this.extra = {};
      this.globaltime = 0;
      this.runningtime = 0;
      this.fixedtime = 0;
      this.fixedtime_lapse = 0.01;
      this.elapsed_time = 0.01;
      this.last_update_time = 0;
      this.starttime = 0;
      this.catch_errors = true;
      this.nodes_executing = [];
      this.nodes_actioning = [];
      this.nodes_executedAction = [];
      this.inputs = {};
      this.outputs = {};
      this.change();
      this.sendActionToCanvas("clear");
    }
    /**
         * Attach Canvas to this graph
         * @method attachCanvas
         * @param {GraphCanvas} graph_canvas
         */
    attachCanvas(graphcanvas) {
      if (graphcanvas.constructor != LGraphCanvas) {
        throw "attachCanvas expects a LGraphCanvas instance";
      }
      if (graphcanvas.graph && graphcanvas.graph != this) {
        graphcanvas.graph.detachCanvas(graphcanvas);
      }
      graphcanvas.graph = this;
      if (!this.list_of_graphcanvas) {
        this.list_of_graphcanvas = [];
      }
      this.list_of_graphcanvas.push(graphcanvas);
    }
    /**
         * Detach Canvas from this graph
         * @method detachCanvas
         * @param {GraphCanvas} graph_canvas
         */
    detachCanvas(graphcanvas) {
      if (!this.list_of_graphcanvas) {
        return;
      }
      var pos2 = this.list_of_graphcanvas.indexOf(graphcanvas);
      if (pos2 == -1) {
        return;
      }
      graphcanvas.graph = null;
      this.list_of_graphcanvas.splice(pos2, 1);
    }
    /**
         * Starts running this graph every interval milliseconds.
         * @method start
         * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate
         */
    start(interval) {
      if (this.status == _LGraph2.STATUS_RUNNING) {
        return;
      }
      this.status = _LGraph2.STATUS_RUNNING;
      if (this.onPlayEvent) {
        this.onPlayEvent();
      }
      this.sendEventToAllNodes("onStart");
      this.starttime = LiteGraph.getTime();
      this.last_update_time = this.starttime;
      interval = interval || 0;
      var that2 = this;
      if (interval == 0 && typeof window != "undefined" && window.requestAnimationFrame) {
        let on_frame = function() {
          if (that2.execution_timer_id != -1) {
            return;
          }
          window.requestAnimationFrame(on_frame);
          if (that2.onBeforeStep)
            that2.onBeforeStep();
          that2.runStep(1, !that2.catch_errors);
          if (that2.onAfterStep)
            that2.onAfterStep();
        };
        this.execution_timer_id = -1;
        on_frame();
      } else {
        this.execution_timer_id = setInterval(function() {
          if (that2.onBeforeStep)
            that2.onBeforeStep();
          that2.runStep(1, !that2.catch_errors);
          if (that2.onAfterStep)
            that2.onAfterStep();
        }, interval);
      }
    }
    /**
         * Stops the execution loop of the graph
         * @method stop execution
         */
    stop() {
      if (this.status == _LGraph2.STATUS_STOPPED) {
        return;
      }
      this.status = _LGraph2.STATUS_STOPPED;
      if (this.onStopEvent) {
        this.onStopEvent();
      }
      if (this.execution_timer_id != null) {
        if (this.execution_timer_id != -1) {
          clearInterval(this.execution_timer_id);
        }
        this.execution_timer_id = null;
      }
      this.sendEventToAllNodes("onStop");
    }
    /**
         * Run N steps (cycles) of the graph
         * @method runStep
         * @param {number} num number of steps to run, default is 1
         * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors
         * @param {number} limit max number of nodes to execute (used to execute from start to a node)
         */
    runStep(num, do_not_catch_errors, limit) {
      num = num || 1;
      var start2 = LiteGraph.getTime();
      this.globaltime = 1e-3 * (start2 - this.starttime);
      var nodes = this._nodes_executable ? this._nodes_executable : this._nodes;
      if (!nodes) {
        return;
      }
      limit = limit || nodes.length;
      if (do_not_catch_errors) {
        for (var i2 = 0; i2 < num; i2++) {
          for (var j = 0; j < limit; ++j) {
            var node22 = nodes[j];
            if (node22.mode == LiteGraph.ALWAYS && node22.onExecute) {
              node22.doExecute();
            }
          }
          this.fixedtime += this.fixedtime_lapse;
          if (this.onExecuteStep) {
            this.onExecuteStep();
          }
        }
        if (this.onAfterExecute) {
          this.onAfterExecute();
        }
      } else {
        try {
          for (var i2 = 0; i2 < num; i2++) {
            for (var j = 0; j < limit; ++j) {
              var node22 = nodes[j];
              if (node22.mode == LiteGraph.ALWAYS && node22.onExecute) {
                node22.onExecute();
              }
            }
            this.fixedtime += this.fixedtime_lapse;
            if (this.onExecuteStep) {
              this.onExecuteStep();
            }
          }
          if (this.onAfterExecute) {
            this.onAfterExecute();
          }
          this.errors_in_execution = false;
        } catch (err) {
          this.errors_in_execution = true;
          if (LiteGraph.throw_errors) {
            throw err;
          }
          if (LiteGraph.debug) {
            console.log("Error during execution: " + err);
          }
          this.stop();
        }
      }
      var now2 = LiteGraph.getTime();
      var elapsed = now2 - start2;
      if (elapsed == 0) {
        elapsed = 1;
      }
      this.execution_time = 1e-3 * elapsed;
      this.globaltime += 1e-3 * elapsed;
      this.iteration += 1;
      this.elapsed_time = (now2 - this.last_update_time) * 1e-3;
      this.last_update_time = now2;
      this.nodes_executing = [];
      this.nodes_actioning = [];
      this.nodes_executedAction = [];
    }
    /**
         * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than
         * nodes with only inputs.
         * @method updateExecutionOrder
         */
    updateExecutionOrder() {
      this._nodes_in_order = this.computeExecutionOrder(false);
      this._nodes_executable = [];
      for (var i2 = 0; i2 < this._nodes_in_order.length; ++i2) {
        if (this._nodes_in_order[i2].onExecute) {
          this._nodes_executable.push(this._nodes_in_order[i2]);
        }
      }
    }
    //This is more internal, it computes the executable nodes in order and returns it
    computeExecutionOrder(only_onExecute, set_level) {
      var L = [];
      var S = [];
      var M = {};
      var visited_links = {};
      var remaining_links = {};
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        var node22 = this._nodes[i2];
        if (only_onExecute && !node22.onExecute) {
          continue;
        }
        M[node22.id] = node22;
        var num = 0;
        if (node22.inputs) {
          for (var j = 0, l2 = node22.inputs.length; j < l2; j++) {
            if (node22.inputs[j] && node22.inputs[j].link != null) {
              num += 1;
            }
          }
        }
        if (num == 0) {
          S.push(node22);
          if (set_level) {
            node22._level = 1;
          }
        } else {
          if (set_level) {
            node22._level = 0;
          }
          remaining_links[node22.id] = num;
        }
      }
      while (true) {
        if (S.length == 0) {
          break;
        }
        var node22 = S.shift();
        L.push(node22);
        delete M[node22.id];
        if (!node22.outputs) {
          continue;
        }
        for (var i2 = 0; i2 < node22.outputs.length; i2++) {
          var output = node22.outputs[i2];
          if (output == null || output.links == null || output.links.length == 0) {
            continue;
          }
          for (var j = 0; j < output.links.length; j++) {
            var link_id = output.links[j];
            var link = this.links[link_id];
            if (!link) {
              continue;
            }
            if (visited_links[link.id]) {
              continue;
            }
            var target_node = this.getNodeById(link.target_id);
            if (target_node == null) {
              visited_links[link.id] = true;
              continue;
            }
            if (set_level && (!target_node._level || target_node._level <= node22._level)) {
              target_node._level = node22._level + 1;
            }
            visited_links[link.id] = true;
            remaining_links[target_node.id] -= 1;
            if (remaining_links[target_node.id] == 0) {
              S.push(target_node);
            }
          }
        }
      }
      for (var i2 in M) {
        L.push(M[i2]);
      }
      if (L.length != this._nodes.length && LiteGraph.debug) {
        console.warn("something went wrong, nodes missing");
      }
      var l = L.length;
      for (var i2 = 0; i2 < l; ++i2) {
        L[i2].order = i2;
      }
      L = L.sort(function(A, B) {
        var Ap = A.constructor.priority || A.priority || 0;
        var Bp = B.constructor.priority || B.priority || 0;
        if (Ap == Bp) {
          return A.order - B.order;
        }
        return Ap - Bp;
      });
      for (var i2 = 0; i2 < l; ++i2) {
        L[i2].order = i2;
      }
      return L;
    }
    /**
         * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.
         * It doesn't include the node itself
         * @method getAncestors
         * @return {Array} an array with all the LGraphNodes that affect this node, in order of execution
         */
    getAncestors(node22) {
      var ancestors = [];
      var pending = [node22];
      var visited = {};
      while (pending.length) {
        var current = pending.shift();
        if (!current.inputs) {
          continue;
        }
        if (!visited[current.id] && current != node22) {
          visited[current.id] = true;
          ancestors.push(current);
        }
        for (var i2 = 0; i2 < current.inputs.length; ++i2) {
          var input = current.getInputNode(i2);
          if (input && ancestors.indexOf(input) == -1) {
            pending.push(input);
          }
        }
      }
      ancestors.sort(function(a, b) {
        return a.order - b.order;
      });
      return ancestors;
    }
    /**
         * Positions every node in a more readable manner
         * @method arrange
         */
    arrange(margin, layout) {
      margin = margin || 100;
      const nodes = this.computeExecutionOrder(false, true);
      const columns2 = [];
      for (let i2 = 0; i2 < nodes.length; ++i2) {
        const node22 = nodes[i2];
        const col = node22._level || 1;
        if (!columns2[col]) {
          columns2[col] = [];
        }
        columns2[col].push(node22);
      }
      let x2 = margin;
      for (let i2 = 0; i2 < columns2.length; ++i2) {
        const column = columns2[i2];
        if (!column) {
          continue;
        }
        let max_size = 100;
        let y2 = margin + LiteGraph.NODE_TITLE_HEIGHT;
        for (let j = 0; j < column.length; ++j) {
          const node22 = column[j];
          node22.pos[0] = layout == LiteGraph.VERTICAL_LAYOUT ? y2 : x2;
          node22.pos[1] = layout == LiteGraph.VERTICAL_LAYOUT ? x2 : y2;
          const max_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 1 : 0;
          if (node22.size[max_size_index] > max_size) {
            max_size = node22.size[max_size_index];
          }
          const node_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 0 : 1;
          y2 += node22.size[node_size_index] + margin + LiteGraph.NODE_TITLE_HEIGHT;
        }
        x2 += max_size + margin;
      }
      this.setDirtyCanvas(true, true);
    }
    /**
         * Returns the amount of time the graph has been running in milliseconds
         * @method getTime
         * @return {number} number of milliseconds the graph has been running
         */
    getTime() {
      return this.globaltime;
    }
    /**
         * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant
         * @method getFixedTime
         * @return {number} number of milliseconds the graph has been running
         */
    getFixedTime() {
      return this.fixedtime;
    }
    /**
         * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct
         * if the nodes are using graphical actions
         * @method getElapsedTime
         * @return {number} number of milliseconds it took the last cycle
         */
    getElapsedTime() {
      return this.elapsed_time;
    }
    /**
         * Sends an event to all the nodes, useful to trigger stuff
         * @method sendEventToAllNodes
         * @param {String} eventname the name of the event (function to be called)
         * @param {Array} params parameters in array format
         */
    sendEventToAllNodes(eventname, params, mode2) {
      mode2 = mode2 || LiteGraph.ALWAYS;
      var nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;
      if (!nodes) {
        return;
      }
      for (var j = 0, l = nodes.length; j < l; ++j) {
        var node22 = nodes[j];
        if (node22.constructor === LiteGraph.Subgraph && eventname != "onExecute") {
          if (node22.mode == mode2) {
            node22.sendEventToAllNodes(eventname, params, mode2);
          }
          continue;
        }
        if (!node22[eventname] || node22.mode != mode2) {
          continue;
        }
        if (params === void 0) {
          node22[eventname]();
        } else if (params && params.constructor === Array) {
          node22[eventname].apply(node22, params);
        } else {
          node22[eventname](params);
        }
      }
    }
    sendActionToCanvas(action, params) {
      if (!this.list_of_graphcanvas) {
        return;
      }
      for (var i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
        var c = this.list_of_graphcanvas[i2];
        if (c[action]) {
          c[action].apply(c, params);
        }
      }
    }
    /**
         * Adds a new node instance to this graph
         * @method add
         * @param {LGraphNode} node the instance of the node
         */
    add(node22, skip_compute_order) {
      if (!node22) {
        return;
      }
      if (node22.constructor === LGraphGroup) {
        this._groups.push(node22);
        this.setDirtyCanvas(true);
        this.change();
        node22.graph = this;
        this._version++;
        return;
      }
      if (node22.id != -1 && this._nodes_by_id[node22.id] != null) {
        console.warn(
          "LiteGraph: there is already a node with this ID, changing it"
        );
        if (LiteGraph.use_uuids) {
          node22.id = LiteGraph.uuidv4();
        } else {
          node22.id = ++this.last_node_id;
        }
      }
      if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {
        throw "LiteGraph: max number of nodes in a graph reached";
      }
      if (LiteGraph.use_uuids) {
        if (node22.id == null || node22.id == -1)
          node22.id = LiteGraph.uuidv4();
      } else {
        if (node22.id == null || node22.id == -1) {
          node22.id = ++this.last_node_id;
        } else if (this.last_node_id < node22.id) {
          this.last_node_id = node22.id;
        }
      }
      node22.graph = this;
      this._version++;
      this._nodes.push(node22);
      this._nodes_by_id[node22.id] = node22;
      if (node22.onAdded) {
        node22.onAdded(this);
      }
      if (this.config.align_to_grid) {
        node22.alignToGrid();
      }
      if (!skip_compute_order) {
        this.updateExecutionOrder();
      }
      if (this.onNodeAdded) {
        this.onNodeAdded(node22);
      }
      this.setDirtyCanvas(true);
      this.change();
      return node22;
    }
    /**
         * Removes a node from the graph
         * @method remove
         * @param {LGraphNode} node the instance of the node
         */
    remove(node22) {
      if (node22.constructor === LiteGraph.LGraphGroup) {
        var index2 = this._groups.indexOf(node22);
        if (index2 != -1) {
          this._groups.splice(index2, 1);
        }
        node22.graph = null;
        this._version++;
        this.setDirtyCanvas(true, true);
        this.change();
        return;
      }
      if (this._nodes_by_id[node22.id] == null) {
        return;
      }
      if (node22.ignore_remove) {
        return;
      }
      this.beforeChange();
      if (node22.inputs) {
        for (var i2 = 0; i2 < node22.inputs.length; i2++) {
          var slot = node22.inputs[i2];
          if (slot.link != null) {
            node22.disconnectInput(i2);
          }
        }
      }
      if (node22.outputs) {
        for (var i2 = 0; i2 < node22.outputs.length; i2++) {
          var slot = node22.outputs[i2];
          if (slot.links != null && slot.links.length) {
            node22.disconnectOutput(i2);
          }
        }
      }
      if (node22.onRemoved) {
        node22.onRemoved();
      }
      node22.graph = null;
      this._version++;
      if (this.list_of_graphcanvas) {
        for (var i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
          var canvas = this.list_of_graphcanvas[i2];
          if (canvas.selected_nodes[node22.id]) {
            delete canvas.selected_nodes[node22.id];
          }
          if (canvas.node_dragged == node22) {
            canvas.node_dragged = null;
          }
        }
      }
      var pos2 = this._nodes.indexOf(node22);
      if (pos2 != -1) {
        this._nodes.splice(pos2, 1);
      }
      delete this._nodes_by_id[node22.id];
      if (this.onNodeRemoved) {
        this.onNodeRemoved(node22);
      }
      this.sendActionToCanvas("checkPanels");
      this.setDirtyCanvas(true, true);
      this.afterChange();
      this.change();
      this.updateExecutionOrder();
    }
    /**
         * Returns a node by its id.
         * @method getNodeById
         * @param {Number} id
         */
    getNodeById(id2) {
      if (id2 == null) {
        return null;
      }
      return this._nodes_by_id[id2];
    }
    /**
         * Returns a list of nodes that matches a class
         * @method findNodesByClass
         * @param {Class} classObject the class itself (not an string)
         * @return {Array} a list with all the nodes of this type
         */
    findNodesByClass(classObject, result) {
      result = result || [];
      result.length = 0;
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        if (this._nodes[i2].constructor === classObject) {
          result.push(this._nodes[i2]);
        }
      }
      return result;
    }
    /**
         * Returns a list of nodes that matches a type
         * @method findNodesByType
         * @param {String} type the name of the node type
         * @return {Array} a list with all the nodes of this type
         */
    findNodesByType(type, result) {
      var type = type.toLowerCase();
      result = result || [];
      result.length = 0;
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        if (this._nodes[i2].type.toLowerCase() == type) {
          result.push(this._nodes[i2]);
        }
      }
      return result;
    }
    /**
         * Returns the first node that matches a name in its title
         * @method findNodeByTitle
         * @param {String} name the name of the node to search
         * @return {Node} the node or null
         */
    findNodeByTitle(title) {
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        if (this._nodes[i2].title == title) {
          return this._nodes[i2];
        }
      }
      return null;
    }
    /**
         * Returns a list of nodes that matches a name
         * @method findNodesByTitle
         * @param {String} name the name of the node to search
         * @return {Array} a list with all the nodes with this name
         */
    findNodesByTitle(title) {
      var result = [];
      for (var i2 = 0, l = this._nodes.length; i2 < l; ++i2) {
        if (this._nodes[i2].title == title) {
          result.push(this._nodes[i2]);
        }
      }
      return result;
    }
    /**
         * Returns the top-most node in this position of the canvas
         * @method getNodeOnPos
         * @param {number} x the x coordinate in canvas space
         * @param {number} y the y coordinate in canvas space
         * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph
         * @return {LGraphNode} the node at this position or null
         */
    getNodeOnPos(x2, y2, nodes_list, margin) {
      nodes_list = nodes_list || this._nodes;
      var nRet = null;
      for (var i2 = nodes_list.length - 1; i2 >= 0; i2--) {
        var n = nodes_list[i2];
        var skip_title = n.constructor.title_mode == LiteGraph.NO_TITLE;
        if (n.isPointInside(x2, y2, margin, skip_title)) {
          return n;
        }
      }
      return nRet;
    }
    /**
         * Returns the top-most group in that position
         * @method getGroupOnPos
         * @param {number} x the x coordinate in canvas space
         * @param {number} y the y coordinate in canvas space
         * @return {LGraphGroup} the group or null
         */
    getGroupOnPos(x2, y2) {
      for (var i2 = this._groups.length - 1; i2 >= 0; i2--) {
        var g = this._groups[i2];
        if (g.isPointInside(x2, y2, 2, true)) {
          return g;
        }
      }
      return null;
    }
    /**
         * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution
         * this replaces the ones using the old version with the new version
         * @method checkNodeTypes
         */
    checkNodeTypes() {
      for (var i2 = 0; i2 < this._nodes.length; i2++) {
        var node22 = this._nodes[i2];
        var ctor = LiteGraph.registered_node_types[node22.type];
        if (node22.constructor == ctor) {
          continue;
        }
        console.log("node being replaced by newer version: " + node22.type);
        var newnode = LiteGraph.createNode(node22.type);
        this._nodes[i2] = newnode;
        newnode.configure(node22.serialize());
        newnode.graph = this;
        this._nodes_by_id[newnode.id] = newnode;
        if (node22.inputs) {
          newnode.inputs = node22.inputs.concat();
        }
        if (node22.outputs) {
          newnode.outputs = node22.outputs.concat();
        }
      }
      this.updateExecutionOrder();
    }
    // ********** GLOBALS *****************
    onAction(action, param, options3) {
      this._input_nodes = this.findNodesByClass(
        LiteGraph.GraphInput,
        this._input_nodes
      );
      for (var i2 = 0; i2 < this._input_nodes.length; ++i2) {
        var node22 = this._input_nodes[i2];
        if (node22.properties.name != action) {
          continue;
        }
        node22.actionDo(action, param, options3);
        break;
      }
    }
    trigger(action, param) {
      if (this.onTrigger) {
        this.onTrigger(action, param);
      }
    }
    /**
         * Tell this graph it has a global graph input of this type
         * @method addGlobalInput
         * @param {String} name
         * @param {String} type
         * @param {*} value [optional]
         */
    addInput(name, type, value3) {
      var input = this.inputs[name];
      if (input) {
        return;
      }
      this.beforeChange();
      this.inputs[name] = { name, type, value: value3 };
      this._version++;
      this.afterChange();
      if (this.onInputAdded) {
        this.onInputAdded(name, type);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
    /**
         * Assign a data to the global graph input
         * @method setGlobalInputData
         * @param {String} name
         * @param {*} data
         */
    setInputData(name, data28) {
      var input = this.inputs[name];
      if (!input) {
        return;
      }
      input.value = data28;
    }
    /**
         * Returns the current value of a global graph input
         * @method getInputData
         * @param {String} name
         * @return {*} the data
         */
    getInputData(name) {
      var input = this.inputs[name];
      if (!input) {
        return null;
      }
      return input.value;
    }
    /**
         * Changes the name of a global graph input
         * @method renameInput
         * @param {String} old_name
         * @param {String} new_name
         */
    renameInput(old_name, name) {
      if (name == old_name) {
        return;
      }
      if (!this.inputs[old_name]) {
        return false;
      }
      if (this.inputs[name]) {
        console.error("there is already one input with that name");
        return false;
      }
      this.inputs[name] = this.inputs[old_name];
      delete this.inputs[old_name];
      this._version++;
      if (this.onInputRenamed) {
        this.onInputRenamed(old_name, name);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
    /**
         * Changes the type of a global graph input
         * @method changeInputType
         * @param {String} name
         * @param {String} type
         */
    changeInputType(name, type) {
      if (!this.inputs[name]) {
        return false;
      }
      if (this.inputs[name].type && String(this.inputs[name].type).toLowerCase() == String(type).toLowerCase()) {
        return;
      }
      this.inputs[name].type = type;
      this._version++;
      if (this.onInputTypeChanged) {
        this.onInputTypeChanged(name, type);
      }
    }
    /**
         * Removes a global graph input
         * @method removeInput
         * @param {String} name
         * @param {String} type
         */
    removeInput(name) {
      if (!this.inputs[name]) {
        return false;
      }
      delete this.inputs[name];
      this._version++;
      if (this.onInputRemoved) {
        this.onInputRemoved(name);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
      return true;
    }
    /**
         * Creates a global graph output
         * @method addOutput
         * @param {String} name
         * @param {String} type
         * @param {*} value
         */
    addOutput(name, type, value3) {
      this.outputs[name] = { name, type, value: value3 };
      this._version++;
      if (this.onOutputAdded) {
        this.onOutputAdded(name, type);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
    /**
         * Assign a data to the global output
         * @method setOutputData
         * @param {String} name
         * @param {String} value
         */
    setOutputData(name, value3) {
      var output = this.outputs[name];
      if (!output) {
        return;
      }
      output.value = value3;
    }
    /**
         * Returns the current value of a global graph output
         * @method getOutputData
         * @param {String} name
         * @return {*} the data
         */
    getOutputData(name) {
      var output = this.outputs[name];
      if (!output) {
        return null;
      }
      return output.value;
    }
    /**
         * Renames a global graph output
         * @method renameOutput
         * @param {String} old_name
         * @param {String} new_name
         */
    renameOutput(old_name, name) {
      if (!this.outputs[old_name]) {
        return false;
      }
      if (this.outputs[name]) {
        console.error("there is already one output with that name");
        return false;
      }
      this.outputs[name] = this.outputs[old_name];
      delete this.outputs[old_name];
      this._version++;
      if (this.onOutputRenamed) {
        this.onOutputRenamed(old_name, name);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
    /**
         * Changes the type of a global graph output
         * @method changeOutputType
         * @param {String} name
         * @param {String} type
         */
    changeOutputType(name, type) {
      if (!this.outputs[name]) {
        return false;
      }
      if (this.outputs[name].type && String(this.outputs[name].type).toLowerCase() == String(type).toLowerCase()) {
        return;
      }
      this.outputs[name].type = type;
      this._version++;
      if (this.onOutputTypeChanged) {
        this.onOutputTypeChanged(name, type);
      }
    }
    /**
         * Removes a global graph output
         * @method removeOutput
         * @param {String} name
         */
    removeOutput(name) {
      if (!this.outputs[name]) {
        return false;
      }
      delete this.outputs[name];
      this._version++;
      if (this.onOutputRemoved) {
        this.onOutputRemoved(name);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
      return true;
    }
    triggerInput(name, value3) {
      var nodes = this.findNodesByTitle(name);
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        nodes[i2].onTrigger(value3);
      }
    }
    setCallback(name, func) {
      var nodes = this.findNodesByTitle(name);
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        nodes[i2].setTrigger(func);
      }
    }
    //used for undo, called before any change is made to the graph
    beforeChange(info) {
      if (this.onBeforeChange) {
        this.onBeforeChange(this, info);
      }
      this.sendActionToCanvas("onBeforeChange", this);
    }
    //used to resend actions, called after any change is made to the graph
    afterChange(info) {
      if (this.onAfterChange) {
        this.onAfterChange(this, info);
      }
      this.sendActionToCanvas("onAfterChange", this);
    }
    connectionChange(node22, link_info) {
      this.updateExecutionOrder();
      if (this.onConnectionChange) {
        this.onConnectionChange(node22);
      }
      this._version++;
      this.sendActionToCanvas("onConnectionChange");
    }
    /**
         * returns if the graph is in live mode
         * @method isLive
         */
    isLive() {
      if (!this.list_of_graphcanvas) {
        return false;
      }
      for (var i2 = 0; i2 < this.list_of_graphcanvas.length; ++i2) {
        var c = this.list_of_graphcanvas[i2];
        if (c.live_mode) {
          return true;
        }
      }
      return false;
    }
    /**
         * clears the triggered slot animation in all links (stop visual animation)
         * @method clearTriggeredSlots
         */
    clearTriggeredSlots() {
      for (var i2 in this.links) {
        var link_info = this.links[i2];
        if (!link_info) {
          continue;
        }
        if (link_info._last_time) {
          link_info._last_time = 0;
        }
      }
    }
    /* Called when something visually changed (not the graph!) */
    change() {
      if (LiteGraph.debug) {
        console.log("Graph changed");
      }
      this.sendActionToCanvas("setDirty", [true, true]);
      if (this.on_change) {
        this.on_change(this);
      }
    }
    setDirtyCanvas(fg, bg) {
      this.sendActionToCanvas("setDirty", [fg, bg]);
    }
    /**
         * Destroys a link
         * @method removeLink
         * @param {Number} link_id
         */
    removeLink(link_id) {
      var link = this.links[link_id];
      if (!link) {
        return;
      }
      var node22 = this.getNodeById(link.target_id);
      if (node22) {
        node22.disconnectInput(link.target_slot);
      }
    }
    //save and recover app state ***************************************
    /**
         * Creates a Object containing all the info about this graph, it can be serialized
         * @method serialize
         * @return {Object} value of the node
         */
    serialize() {
      var nodes_info = [];
      nodes_info = this._nodes.sort((a, b) => a.id - b.id).map((node22) => node22.serialize());
      var links = [];
      for (var i2 in this.links) {
        var link = this.links[i2];
        if (!link.serialize) {
          console.warn(
            "weird LLink bug, link info is not a LLink but a regular object"
          );
          var link2 = new LLink();
          for (var j in link) {
            link2[j] = link[j];
          }
          this.links[i2] = link2;
          link = link2;
        }
        links.push(link.serialize());
      }
      var groups_info = [];
      for (var i2 = 0; i2 < this._groups.length; ++i2) {
        groups_info.push(this._groups[i2].serialize());
      }
      var data28 = {
        last_node_id: this.last_node_id,
        last_link_id: this.last_link_id,
        nodes: nodes_info,
        links,
        groups: groups_info,
        config: this.config,
        extra: this.extra,
        version: LiteGraph.VERSION
      };
      if (this.onSerialize)
        this.onSerialize(data28);
      return data28;
    }
    /**
         * Configure a graph from a JSON string
         * @method configure
         * @param {String} str configure a graph from a JSON string
         * @param {Boolean} returns if there was any error parsing
         */
    configure(data28, keep_old) {
      if (!data28) {
        return;
      }
      if (!keep_old) {
        this.clear();
      }
      var nodes = data28.nodes;
      if (data28.links && data28.links.constructor === Array) {
        var links = [];
        for (var i2 = 0; i2 < data28.links.length; ++i2) {
          var link_data = data28.links[i2];
          if (!link_data) {
            console.warn("serialized graph link data contains errors, skipping.");
            continue;
          }
          var link = new LLink();
          link.configure(link_data);
          links[link.id] = link;
        }
        data28.links = links;
      }
      for (var i2 in data28) {
        if (i2 == "nodes" || i2 == "groups")
          continue;
        this[i2] = data28[i2];
      }
      var error = false;
      this._nodes = [];
      if (nodes) {
        for (var i2 = 0, l = nodes.length; i2 < l; ++i2) {
          var n_info = nodes[i2];
          var node22 = LiteGraph.createNode(n_info.type, n_info.title);
          if (!node22) {
            if (LiteGraph.debug) {
              console.log(
                "Node not found or has errors: " + n_info.type
              );
            }
            node22 = new LGraphNode();
            node22.last_serialization = n_info;
            node22.has_errors = true;
            error = true;
          }
          node22.id = n_info.id;
          this.add(node22, true);
        }
        for (var i2 = 0, l = nodes.length; i2 < l; ++i2) {
          var n_info = nodes[i2];
          var node22 = this.getNodeById(n_info.id);
          if (node22) {
            node22.configure(n_info);
          }
        }
      }
      this._groups.length = 0;
      if (data28.groups) {
        for (var i2 = 0; i2 < data28.groups.length; ++i2) {
          var group = new LiteGraph.LGraphGroup();
          group.configure(data28.groups[i2]);
          this.add(group);
        }
      }
      this.updateExecutionOrder();
      this.extra = data28.extra || {};
      if (this.onConfigure)
        this.onConfigure(data28);
      this._version++;
      this.setDirtyCanvas(true, true);
      return error;
    }
    load(url, callback) {
      var that2 = this;
      if (url.constructor === File || url.constructor === Blob) {
        var reader = new FileReader();
        reader.addEventListener("load", function(event2) {
          var data28 = JSON.parse(event2.target.result);
          that2.configure(data28);
          if (callback)
            callback();
        });
        reader.readAsText(url);
        return;
      }
      var req = new XMLHttpRequest();
      req.open("GET", url, true);
      req.send(null);
      req.onload = function(oEvent) {
        if (req.status !== 200) {
          console.error("Error loading graph:", req.status, req.response);
          return;
        }
        var data28 = JSON.parse(req.response);
        that2.configure(data28);
        if (callback)
          callback();
      };
      req.onerror = function(err) {
        console.error("Error loading graph:", err);
      };
    }
    onNodeTrace(node22, msg, color) {
    }
  };
  __publicField(_LGraph, "supported_types", ["number", "string", "boolean"]);
  __publicField(_LGraph, "STATUS_STOPPED", 1);
  __publicField(_LGraph, "STATUS_RUNNING", 2);
  let LGraph = _LGraph;
  function LegacyLGraph(...args) {
    return new LGraph(...args);
  }
  LegacyLGraph.prototype = LGraph.prototype;
  globalThis.LGraph = LGraph;
  globalThis.LegacyLGraph = LiteGraph.LGraph = LegacyLGraph;
  function LLink(id2, type, origin_id, origin_slot, target_id, target_slot) {
    this.id = id2;
    this.type = type;
    this.origin_id = origin_id;
    this.origin_slot = origin_slot;
    this.target_id = target_id;
    this.target_slot = target_slot;
    this._data = null;
    this._pos = new Float32Array(2);
  }
  LLink.prototype.configure = function(o) {
    if (o.constructor === Array) {
      this.id = o[0];
      this.origin_id = o[1];
      this.origin_slot = o[2];
      this.target_id = o[3];
      this.target_slot = o[4];
      this.type = o[5];
    } else {
      this.id = o.id;
      this.type = o.type;
      this.origin_id = o.origin_id;
      this.origin_slot = o.origin_slot;
      this.target_id = o.target_id;
      this.target_slot = o.target_slot;
    }
  };
  LLink.prototype.serialize = function() {
    return [
      this.id,
      this.origin_id,
      this.origin_slot,
      this.target_id,
      this.target_slot,
      this.type
    ];
  };
  LiteGraph.LLink = LLink;
  function LGraphNode(title) {
    this._ctor(title);
  }
  globalThis.LGraphNode = LiteGraph.LGraphNode = LGraphNode;
  LGraphNode.prototype._ctor = function(title) {
    this.title = title || "Unnamed";
    this.size = [LiteGraph.NODE_WIDTH, 60];
    this.graph = null;
    this._pos = new Float32Array(10, 10);
    Object.defineProperty(this, "pos", {
      set: function(v2) {
        if (!v2 || v2.length < 2) {
          return;
        }
        this._pos[0] = v2[0];
        this._pos[1] = v2[1];
      },
      get: function() {
        return this._pos;
      },
      enumerable: true
    });
    if (LiteGraph.use_uuids) {
      this.id = LiteGraph.uuidv4();
    } else {
      this.id = -1;
    }
    this.type = null;
    this.inputs = [];
    this.outputs = [];
    this.connections = [];
    this.properties = {};
    this.properties_info = [];
    this.flags = {};
  };
  LGraphNode.prototype.configure = function(info) {
    if (this.graph) {
      this.graph._version++;
    }
    for (var j in info) {
      if (j == "properties") {
        for (var k in info.properties) {
          this.properties[k] = info.properties[k];
          if (this.onPropertyChanged) {
            this.onPropertyChanged(k, info.properties[k]);
          }
        }
        continue;
      }
      if (info[j] == null) {
        continue;
      } else if (typeof info[j] == "object") {
        if (this[j] && this[j].configure) {
          this[j].configure(info[j]);
        } else {
          this[j] = LiteGraph.cloneObject(info[j], this[j]);
        }
      } else {
        this[j] = info[j];
      }
    }
    if (!info.title) {
      this.title = this.constructor.title;
    }
    if (this.inputs) {
      for (var i2 = 0; i2 < this.inputs.length; ++i2) {
        var input = this.inputs[i2];
        var link_info = this.graph ? this.graph.links[input.link] : null;
        if (this.onConnectionsChange)
          this.onConnectionsChange(LiteGraph.INPUT, i2, true, link_info, input);
        if (this.onInputAdded)
          this.onInputAdded(input);
      }
    }
    if (this.outputs) {
      for (var i2 = 0; i2 < this.outputs.length; ++i2) {
        var output = this.outputs[i2];
        if (!output.links) {
          continue;
        }
        for (var j = 0; j < output.links.length; ++j) {
          var link_info = this.graph ? this.graph.links[output.links[j]] : null;
          if (this.onConnectionsChange)
            this.onConnectionsChange(LiteGraph.OUTPUT, i2, true, link_info, output);
        }
        if (this.onOutputAdded)
          this.onOutputAdded(output);
      }
    }
    if (this.widgets) {
      for (var i2 = 0; i2 < this.widgets.length; ++i2) {
        var w2 = this.widgets[i2];
        if (!w2)
          continue;
        if (w2.options && w2.options.property && this.properties[w2.options.property] != void 0)
          w2.value = JSON.parse(JSON.stringify(this.properties[w2.options.property]));
      }
      if (info.widgets_values) {
        for (var i2 = 0; i2 < info.widgets_values.length; ++i2) {
          if (this.widgets[i2]) {
            this.widgets[i2].value = info.widgets_values[i2];
          }
        }
      }
    }
    if (this.onConfigure) {
      this.onConfigure(info);
    }
  };
  LGraphNode.prototype.serialize = function() {
    var o = {
      id: this.id,
      type: this.type,
      pos: this.pos,
      size: this.size,
      flags: LiteGraph.cloneObject(this.flags),
      order: this.order,
      mode: this.mode
    };
    if (this.constructor === LGraphNode && this.last_serialization) {
      return this.last_serialization;
    }
    if (this.inputs) {
      o.inputs = this.inputs;
    }
    if (this.outputs) {
      for (var i2 = 0; i2 < this.outputs.length; i2++) {
        delete this.outputs[i2]._data;
      }
      o.outputs = this.outputs;
    }
    if (this.title && this.title != this.constructor.title) {
      o.title = this.title;
    }
    if (this.properties) {
      o.properties = LiteGraph.cloneObject(this.properties);
    }
    if (this.widgets && this.serialize_widgets) {
      o.widgets_values = [];
      for (var i2 = 0; i2 < this.widgets.length; ++i2) {
        if (this.widgets[i2])
          o.widgets_values[i2] = this.widgets[i2].value;
        else
          o.widgets_values[i2] = null;
      }
    }
    if (!o.type) {
      o.type = this.constructor.type;
    }
    if (this.color) {
      o.color = this.color;
    }
    if (this.bgcolor) {
      o.bgcolor = this.bgcolor;
    }
    if (this.boxcolor) {
      o.boxcolor = this.boxcolor;
    }
    if (this.shape) {
      o.shape = this.shape;
    }
    if (this.onSerialize) {
      if (this.onSerialize(o)) {
        console.warn(
          "node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter"
        );
      }
    }
    return o;
  };
  LGraphNode.prototype.clone = function() {
    var node22 = LiteGraph.createNode(this.type);
    if (!node22) {
      return null;
    }
    var data28 = LiteGraph.cloneObject(this.serialize());
    if (data28.inputs) {
      for (var i2 = 0; i2 < data28.inputs.length; ++i2) {
        data28.inputs[i2].link = null;
      }
    }
    if (data28.outputs) {
      for (var i2 = 0; i2 < data28.outputs.length; ++i2) {
        if (data28.outputs[i2].links) {
          data28.outputs[i2].links.length = 0;
        }
      }
    }
    delete data28["id"];
    if (LiteGraph.use_uuids) {
      data28["id"] = LiteGraph.uuidv4();
    }
    node22.configure(data28);
    return node22;
  };
  LGraphNode.prototype.toString = function() {
    return JSON.stringify(this.serialize());
  };
  LGraphNode.prototype.getTitle = function() {
    return this.title || this.constructor.title;
  };
  LGraphNode.prototype.setProperty = function(name, value3) {
    if (!this.properties) {
      this.properties = {};
    }
    if (value3 === this.properties[name])
      return;
    var prev_value = this.properties[name];
    this.properties[name] = value3;
    if (this.onPropertyChanged) {
      if (this.onPropertyChanged(name, value3, prev_value) === false)
        this.properties[name] = prev_value;
    }
    if (this.widgets)
      for (var i2 = 0; i2 < this.widgets.length; ++i2) {
        var w2 = this.widgets[i2];
        if (!w2)
          continue;
        if (w2.options.property == name) {
          w2.value = value3;
          break;
        }
      }
  };
  LGraphNode.prototype.setOutputData = function(slot, data28) {
    if (!this.outputs) {
      return;
    }
    if (slot == -1 || slot >= this.outputs.length) {
      return;
    }
    var output_info = this.outputs[slot];
    if (!output_info) {
      return;
    }
    output_info._data = data28;
    if (this.outputs[slot].links) {
      for (var i2 = 0; i2 < this.outputs[slot].links.length; i2++) {
        var link_id = this.outputs[slot].links[i2];
        var link = this.graph.links[link_id];
        if (link)
          link.data = data28;
      }
    }
  };
  LGraphNode.prototype.setOutputDataType = function(slot, type) {
    if (!this.outputs) {
      return;
    }
    if (slot == -1 || slot >= this.outputs.length) {
      return;
    }
    var output_info = this.outputs[slot];
    if (!output_info) {
      return;
    }
    output_info.type = type;
    if (this.outputs[slot].links) {
      for (var i2 = 0; i2 < this.outputs[slot].links.length; i2++) {
        var link_id = this.outputs[slot].links[i2];
        this.graph.links[link_id].type = type;
      }
    }
  };
  LGraphNode.prototype.getInputData = function(slot, force_update) {
    if (!this.inputs) {
      return;
    }
    if (slot >= this.inputs.length || this.inputs[slot].link == null) {
      return;
    }
    var link_id = this.inputs[slot].link;
    var link = this.graph.links[link_id];
    if (!link) {
      return null;
    }
    if (!force_update) {
      return link.data;
    }
    var node22 = this.graph.getNodeById(link.origin_id);
    if (!node22) {
      return link.data;
    }
    if (node22.updateOutputData) {
      node22.updateOutputData(link.origin_slot);
    } else if (node22.onExecute) {
      node22.onExecute();
    }
    return link.data;
  };
  LGraphNode.prototype.getInputDataType = function(slot) {
    if (!this.inputs) {
      return null;
    }
    if (slot >= this.inputs.length || this.inputs[slot].link == null) {
      return null;
    }
    var link_id = this.inputs[slot].link;
    var link = this.graph.links[link_id];
    if (!link) {
      return null;
    }
    var node22 = this.graph.getNodeById(link.origin_id);
    if (!node22) {
      return link.type;
    }
    var output_info = node22.outputs[link.origin_slot];
    if (output_info) {
      return output_info.type;
    }
    return null;
  };
  LGraphNode.prototype.getInputDataByName = function(slot_name, force_update) {
    var slot = this.findInputSlot(slot_name);
    if (slot == -1) {
      return null;
    }
    return this.getInputData(slot, force_update);
  };
  LGraphNode.prototype.isInputConnected = function(slot) {
    if (!this.inputs) {
      return false;
    }
    return slot < this.inputs.length && this.inputs[slot].link != null;
  };
  LGraphNode.prototype.getInputInfo = function(slot) {
    if (!this.inputs) {
      return null;
    }
    if (slot < this.inputs.length) {
      return this.inputs[slot];
    }
    return null;
  };
  LGraphNode.prototype.getInputLink = function(slot) {
    if (!this.inputs) {
      return null;
    }
    if (slot < this.inputs.length) {
      var slot_info = this.inputs[slot];
      return this.graph.links[slot_info.link];
    }
    return null;
  };
  LGraphNode.prototype.getInputNode = function(slot) {
    if (!this.inputs) {
      return null;
    }
    if (slot >= this.inputs.length) {
      return null;
    }
    var input = this.inputs[slot];
    if (!input || input.link === null) {
      return null;
    }
    var link_info = this.graph.links[input.link];
    if (!link_info) {
      return null;
    }
    return this.graph.getNodeById(link_info.origin_id);
  };
  LGraphNode.prototype.getInputOrProperty = function(name) {
    if (!this.inputs || !this.inputs.length) {
      return this.properties ? this.properties[name] : null;
    }
    for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
      var input_info = this.inputs[i2];
      if (name == input_info.name && input_info.link != null) {
        var link = this.graph.links[input_info.link];
        if (link) {
          return link.data;
        }
      }
    }
    return this.properties[name];
  };
  LGraphNode.prototype.getOutputData = function(slot) {
    if (!this.outputs) {
      return null;
    }
    if (slot >= this.outputs.length) {
      return null;
    }
    var info = this.outputs[slot];
    return info._data;
  };
  LGraphNode.prototype.getOutputInfo = function(slot) {
    if (!this.outputs) {
      return null;
    }
    if (slot < this.outputs.length) {
      return this.outputs[slot];
    }
    return null;
  };
  LGraphNode.prototype.isOutputConnected = function(slot) {
    if (!this.outputs) {
      return false;
    }
    return slot < this.outputs.length && this.outputs[slot].links && this.outputs[slot].links.length;
  };
  LGraphNode.prototype.isAnyOutputConnected = function() {
    if (!this.outputs) {
      return false;
    }
    for (var i2 = 0; i2 < this.outputs.length; ++i2) {
      if (this.outputs[i2].links && this.outputs[i2].links.length) {
        return true;
      }
    }
    return false;
  };
  LGraphNode.prototype.getOutputNodes = function(slot) {
    if (!this.outputs || this.outputs.length == 0) {
      return null;
    }
    if (slot >= this.outputs.length) {
      return null;
    }
    var output = this.outputs[slot];
    if (!output.links || output.links.length == 0) {
      return null;
    }
    var r = [];
    for (var i2 = 0; i2 < output.links.length; i2++) {
      var link_id = output.links[i2];
      var link = this.graph.links[link_id];
      if (link) {
        var target_node = this.graph.getNodeById(link.target_id);
        if (target_node) {
          r.push(target_node);
        }
      }
    }
    return r;
  };
  LGraphNode.prototype.addOnTriggerInput = function() {
    var trigS = this.findInputSlot("onTrigger");
    if (trigS == -1) {
      //!trigS || 
      this.addInput("onTrigger", LiteGraph.EVENT, { optional: true, nameLocked: true });
      return this.findInputSlot("onTrigger");
    }
    return trigS;
  };
  LGraphNode.prototype.addOnExecutedOutput = function() {
    var trigS = this.findOutputSlot("onExecuted");
    if (trigS == -1) {
      //!trigS || 
      this.addOutput("onExecuted", LiteGraph.ACTION, { optional: true, nameLocked: true });
      return this.findOutputSlot("onExecuted");
    }
    return trigS;
  };
  LGraphNode.prototype.onAfterExecuteNode = function(param, options3) {
    var trigS = this.findOutputSlot("onExecuted");
    if (trigS != -1) {
      this.triggerSlot(trigS, param, null, options3);
    }
  };
  LGraphNode.prototype.changeMode = function(modeTo) {
    switch (modeTo) {
      case LiteGraph.ON_EVENT:
        break;
      case LiteGraph.ON_TRIGGER:
        this.addOnTriggerInput();
        this.addOnExecutedOutput();
        break;
      case LiteGraph.NEVER:
        break;
      case LiteGraph.ALWAYS:
        break;
      case LiteGraph.ON_REQUEST:
        break;
      default:
        return false;
    }
    this.mode = modeTo;
    return true;
  };
  LGraphNode.prototype.doExecute = function(param, options3) {
    options3 = options3 || {};
    if (this.onExecute) {
      if (!options3.action_call) options3.action_call = this.id + "_exec_" + Math.floor(Math.random() * 9999);
      this.graph.nodes_executing[this.id] = true;
      this.onExecute(param, options3);
      this.graph.nodes_executing[this.id] = false;
      this.exec_version = this.graph.iteration;
      if (options3 && options3.action_call) {
        this.action_call = options3.action_call;
        this.graph.nodes_executedAction[this.id] = options3.action_call;
      }
    }
    this.execute_triggered = 2;
    if (this.onAfterExecuteNode) this.onAfterExecuteNode(param, options3);
  };
  LGraphNode.prototype.actionDo = function(action, param, options3) {
    options3 = options3 || {};
    if (this.onAction) {
      if (!options3.action_call) options3.action_call = this.id + "_" + (action ? action : "action") + "_" + Math.floor(Math.random() * 9999);
      this.graph.nodes_actioning[this.id] = action ? action : "actioning";
      this.onAction(action, param, options3);
      this.graph.nodes_actioning[this.id] = false;
      if (options3 && options3.action_call) {
        this.action_call = options3.action_call;
        this.graph.nodes_executedAction[this.id] = options3.action_call;
      }
    }
    this.action_triggered = 2;
    if (this.onAfterExecuteNode) this.onAfterExecuteNode(param, options3);
  };
  LGraphNode.prototype.trigger = function(action, param, options3) {
    if (!this.outputs || !this.outputs.length) {
      return;
    }
    if (this.graph)
      this.graph._last_trigger_time = LiteGraph.getTime();
    for (var i2 = 0; i2 < this.outputs.length; ++i2) {
      var output = this.outputs[i2];
      if (!output || output.type !== LiteGraph.EVENT || action && output.name != action)
        continue;
      this.triggerSlot(i2, param, null, options3);
    }
  };
  LGraphNode.prototype.triggerSlot = function(slot, param, link_id, options3) {
    options3 = options3 || {};
    if (!this.outputs) {
      return;
    }
    if (slot == null) {
      console.error("slot must be a number");
      return;
    }
    if (slot.constructor !== Number)
      console.warn("slot must be a number, use node.trigger('name') if you want to use a string");
    var output = this.outputs[slot];
    if (!output) {
      return;
    }
    var links = output.links;
    if (!links || !links.length) {
      return;
    }
    if (this.graph) {
      this.graph._last_trigger_time = LiteGraph.getTime();
    }
    for (var k = 0; k < links.length; ++k) {
      var id2 = links[k];
      if (link_id != null && link_id != id2) {
        continue;
      }
      var link_info = this.graph.links[links[k]];
      if (!link_info) {
        continue;
      }
      link_info._last_time = LiteGraph.getTime();
      var node22 = this.graph.getNodeById(link_info.target_id);
      if (!node22) {
        continue;
      }
      var target_connection = node22.inputs[link_info.target_slot];
      if (node22.mode === LiteGraph.ON_TRIGGER) {
        if (!options3.action_call) options3.action_call = this.id + "_trigg_" + Math.floor(Math.random() * 9999);
        if (node22.onExecute) {
          node22.doExecute(param, options3);
        }
      } else if (node22.onAction) {
        if (!options3.action_call) options3.action_call = this.id + "_act_" + Math.floor(Math.random() * 9999);
        var target_connection = node22.inputs[link_info.target_slot];
        node22.actionDo(target_connection.name, param, options3);
      }
    }
  };
  LGraphNode.prototype.clearTriggeredSlot = function(slot, link_id) {
    if (!this.outputs) {
      return;
    }
    var output = this.outputs[slot];
    if (!output) {
      return;
    }
    var links = output.links;
    if (!links || !links.length) {
      return;
    }
    for (var k = 0; k < links.length; ++k) {
      var id2 = links[k];
      if (link_id != null && link_id != id2) {
        continue;
      }
      var link_info = this.graph.links[links[k]];
      if (!link_info) {
        continue;
      }
      link_info._last_time = 0;
    }
  };
  LGraphNode.prototype.setSize = function(size2) {
    this.size = size2;
    if (this.onResize)
      this.onResize(this.size);
  };
  LGraphNode.prototype.addProperty = function(name, default_value, type, extra_info) {
    var o = { name, type, default_value };
    if (extra_info) {
      for (var i2 in extra_info) {
        o[i2] = extra_info[i2];
      }
    }
    if (!this.properties_info) {
      this.properties_info = [];
    }
    this.properties_info.push(o);
    if (!this.properties) {
      this.properties = {};
    }
    this.properties[name] = default_value;
    return o;
  };
  LGraphNode.prototype.addOutput = function(name, type, extra_info) {
    var output = { name, type, links: null };
    if (extra_info) {
      for (var i2 in extra_info) {
        output[i2] = extra_info[i2];
      }
    }
    if (!this.outputs) {
      this.outputs = [];
    }
    this.outputs.push(output);
    if (this.onOutputAdded) {
      this.onOutputAdded(output);
    }
    if (LiteGraph.auto_load_slot_types) LiteGraph.registerNodeAndSlotType(this, type, true);
    this.setSize(this.computeSize());
    this.setDirtyCanvas(true, true);
    return output;
  };
  LGraphNode.prototype.addOutputs = function(array) {
    for (var i2 = 0; i2 < array.length; ++i2) {
      var info = array[i2];
      var o = { name: info[0], type: info[1], link: null };
      if (array[2]) {
        for (var j in info[2]) {
          o[j] = info[2][j];
        }
      }
      if (!this.outputs) {
        this.outputs = [];
      }
      this.outputs.push(o);
      if (this.onOutputAdded) {
        this.onOutputAdded(o);
      }
      if (LiteGraph.auto_load_slot_types) LiteGraph.registerNodeAndSlotType(this, info[1], true);
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(true, true);
  };
  LGraphNode.prototype.removeOutput = function(slot) {
    this.disconnectOutput(slot);
    this.outputs.splice(slot, 1);
    for (var i2 = slot; i2 < this.outputs.length; ++i2) {
      if (!this.outputs[i2] || !this.outputs[i2].links) {
        continue;
      }
      var links = this.outputs[i2].links;
      for (var j = 0; j < links.length; ++j) {
        var link = this.graph.links[links[j]];
        if (!link) {
          continue;
        }
        link.origin_slot -= 1;
      }
    }
    this.setSize(this.computeSize());
    if (this.onOutputRemoved) {
      this.onOutputRemoved(slot);
    }
    this.setDirtyCanvas(true, true);
  };
  LGraphNode.prototype.addInput = function(name, type, extra_info) {
    type = type || 0;
    var input = { name, type, link: null };
    if (extra_info) {
      for (var i2 in extra_info) {
        input[i2] = extra_info[i2];
      }
    }
    if (!this.inputs) {
      this.inputs = [];
    }
    this.inputs.push(input);
    this.setSize(this.computeSize());
    if (this.onInputAdded) {
      this.onInputAdded(input);
    }
    LiteGraph.registerNodeAndSlotType(this, type);
    this.setDirtyCanvas(true, true);
    return input;
  };
  LGraphNode.prototype.addInputs = function(array) {
    for (var i2 = 0; i2 < array.length; ++i2) {
      var info = array[i2];
      var o = { name: info[0], type: info[1], link: null };
      if (array[2]) {
        for (var j in info[2]) {
          o[j] = info[2][j];
        }
      }
      if (!this.inputs) {
        this.inputs = [];
      }
      this.inputs.push(o);
      if (this.onInputAdded) {
        this.onInputAdded(o);
      }
      LiteGraph.registerNodeAndSlotType(this, info[1]);
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(true, true);
  };
  LGraphNode.prototype.removeInput = function(slot) {
    this.disconnectInput(slot);
    var slot_info = this.inputs.splice(slot, 1);
    for (var i2 = slot; i2 < this.inputs.length; ++i2) {
      if (!this.inputs[i2]) {
        continue;
      }
      var link = this.graph.links[this.inputs[i2].link];
      if (!link) {
        continue;
      }
      link.target_slot -= 1;
    }
    this.setSize(this.computeSize());
    if (this.onInputRemoved) {
      this.onInputRemoved(slot, slot_info[0]);
    }
    this.setDirtyCanvas(true, true);
  };
  LGraphNode.prototype.addConnection = function(name, type, pos2, direction) {
    var o = {
      name,
      type,
      pos: pos2,
      direction,
      links: null
    };
    this.connections.push(o);
    return o;
  };
  LGraphNode.prototype.computeSize = function(out) {
    if (this.constructor.size) {
      return this.constructor.size.concat();
    }
    var rows3 = Math.max(
      this.inputs ? this.inputs.length : 1,
      this.outputs ? this.outputs.length : 1
    );
    var size2 = out || new Float32Array([0, 0]);
    rows3 = Math.max(rows3, 1);
    var font_size = LiteGraph.NODE_TEXT_SIZE;
    var title_width = compute_text_size(this.title);
    var input_width = 0;
    var output_width = 0;
    if (this.inputs) {
      for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
        var input = this.inputs[i2];
        var text2 = input.label || input.name || "";
        var text_width = compute_text_size(text2);
        if (input_width < text_width) {
          input_width = text_width;
        }
      }
    }
    if (this.outputs) {
      for (var i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
        var output = this.outputs[i2];
        var text2 = output.label || output.name || "";
        var text_width = compute_text_size(text2);
        if (output_width < text_width) {
          output_width = text_width;
        }
      }
    }
    size2[0] = Math.max(input_width + output_width + 10, title_width);
    size2[0] = Math.max(size2[0], LiteGraph.NODE_WIDTH);
    if (this.widgets && this.widgets.length) {
      size2[0] = Math.max(size2[0], LiteGraph.NODE_WIDTH * 1.5);
    }
    size2[1] = (this.constructor.slot_start_y || 0) + rows3 * LiteGraph.NODE_SLOT_HEIGHT;
    var widgets_height = 0;
    if (this.widgets && this.widgets.length) {
      for (var i2 = 0, l = this.widgets.length; i2 < l; ++i2) {
        if (this.widgets[i2].computeSize)
          widgets_height += this.widgets[i2].computeSize(size2[0])[1] + 4;
        else
          widgets_height += LiteGraph.NODE_WIDGET_HEIGHT + 4;
      }
      widgets_height += 8;
    }
    if (this.widgets_up)
      size2[1] = Math.max(size2[1], widgets_height);
    else if (this.widgets_start_y != null)
      size2[1] = Math.max(size2[1], widgets_height + this.widgets_start_y);
    else
      size2[1] += widgets_height;
    function compute_text_size(text22) {
      if (!text22) {
        return 0;
      }
      return font_size * text22.length * 0.6;
    }
    if (this.constructor.min_height && size2[1] < this.constructor.min_height) {
      size2[1] = this.constructor.min_height;
    }
    size2[1] += 6;
    return size2;
  };
  LGraphNode.prototype.inResizeCorner = function(canvasX, canvasY) {
    var rows3 = this.outputs ? this.outputs.length : 1;
    var outputs_offset = (this.constructor.slot_start_y || 0) + rows3 * LiteGraph.NODE_SLOT_HEIGHT;
    return isInsideRectangle(
      canvasX,
      canvasY,
      this.pos[0] + this.size[0] - 15,
      this.pos[1] + Math.max(this.size[1] - 15, outputs_offset),
      20,
      20
    );
  };
  LGraphNode.prototype.getPropertyInfo = function(property) {
    var info = null;
    if (this.properties_info) {
      for (var i2 = 0; i2 < this.properties_info.length; ++i2) {
        if (this.properties_info[i2].name == property) {
          info = this.properties_info[i2];
          break;
        }
      }
    }
    if (this.constructor["@" + property])
      info = this.constructor["@" + property];
    if (this.constructor.widgets_info && this.constructor.widgets_info[property])
      info = this.constructor.widgets_info[property];
    if (!info && this.onGetPropertyInfo) {
      info = this.onGetPropertyInfo(property);
    }
    if (!info)
      info = {};
    if (!info.type)
      info.type = typeof this.properties[property];
    if (info.widget == "combo")
      info.type = "enum";
    return info;
  };
  LGraphNode.prototype.addWidget = function(type, name, value3, callback, options3) {
    if (!this.widgets) {
      this.widgets = [];
    }
    if (!options3 && callback && callback.constructor === Object) {
      options3 = callback;
      callback = null;
    }
    if (options3 && options3.constructor === String)
      options3 = { property: options3 };
    if (callback && callback.constructor === String) {
      if (!options3)
        options3 = {};
      options3.property = callback;
      callback = null;
    }
    if (callback && callback.constructor !== Function) {
      console.warn("addWidget: callback must be a function");
      callback = null;
    }
    var w2 = {
      type: type.toLowerCase(),
      name,
      value: value3,
      callback,
      options: options3 || {}
    };
    if (w2.options.y !== void 0) {
      w2.y = w2.options.y;
    }
    if (!callback && !w2.options.callback && !w2.options.property) {
      console.warn("LiteGraph addWidget(...) without a callback or property assigned");
    }
    if (type == "combo" && !w2.options.values) {
      throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
    }
    this.widgets.push(w2);
    this.setSize(this.computeSize());
    return w2;
  };
  LGraphNode.prototype.addCustomWidget = function(custom_widget) {
    if (!this.widgets) {
      this.widgets = [];
    }
    this.widgets.push(custom_widget);
    return custom_widget;
  };
  LGraphNode.prototype.getBounding = function(out, compute_outer) {
    out = out || new Float32Array(4);
    const nodePos = this.pos;
    const isCollapsed = this.flags.collapsed;
    const nodeSize = this.size;
    let left_offset = 0;
    let right_offset = 1;
    let top_offset = 0;
    let bottom_offset = 0;
    if (compute_outer) {
      left_offset = 4;
      right_offset = 6 + left_offset;
      top_offset = 4;
      bottom_offset = 5 + top_offset;
    }
    out[0] = nodePos[0] - left_offset;
    out[1] = nodePos[1] - LiteGraph.NODE_TITLE_HEIGHT - top_offset;
    out[2] = isCollapsed ? (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + right_offset : nodeSize[0] + right_offset;
    out[3] = isCollapsed ? LiteGraph.NODE_TITLE_HEIGHT + bottom_offset : nodeSize[1] + LiteGraph.NODE_TITLE_HEIGHT + bottom_offset;
    if (this.onBounding) {
      this.onBounding(out);
    }
    return out;
  };
  LGraphNode.prototype.isPointInside = function(x2, y2, margin, skip_title) {
    margin = margin || 0;
    var margin_top = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT;
    if (skip_title) {
      margin_top = 0;
    }
    if (this.flags && this.flags.collapsed) {
      if (isInsideRectangle(
        x2,
        y2,
        this.pos[0] - margin,
        this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - margin,
        (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + 2 * margin,
        LiteGraph.NODE_TITLE_HEIGHT + 2 * margin
      )) {
        return true;
      }
    } else if (this.pos[0] - 4 - margin < x2 && this.pos[0] + this.size[0] + 4 + margin > x2 && this.pos[1] - margin_top - margin < y2 && this.pos[1] + this.size[1] + margin > y2) {
      return true;
    }
    return false;
  };
  LGraphNode.prototype.getSlotInPosition = function(x2, y2) {
    var link_pos = new Float32Array(2);
    if (this.inputs) {
      for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
        var input = this.inputs[i2];
        this.getConnectionPos(true, i2, link_pos);
        if (isInsideRectangle(
          x2,
          y2,
          link_pos[0] - 10,
          link_pos[1] - 5,
          20,
          10
        )) {
          return { input, slot: i2, link_pos };
        }
      }
    }
    if (this.outputs) {
      for (var i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
        var output = this.outputs[i2];
        this.getConnectionPos(false, i2, link_pos);
        if (isInsideRectangle(
          x2,
          y2,
          link_pos[0] - 10,
          link_pos[1] - 5,
          20,
          10
        )) {
          return { output, slot: i2, link_pos };
        }
      }
    }
    return null;
  };
  LGraphNode.prototype.findInputSlot = function(name, returnObj) {
    if (!this.inputs) {
      return -1;
    }
    for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
      if (name == this.inputs[i2].name) {
        return !returnObj ? i2 : this.inputs[i2];
      }
    }
    return -1;
  };
  LGraphNode.prototype.findOutputSlot = function(name, returnObj) {
    returnObj = returnObj || false;
    if (!this.outputs) {
      return -1;
    }
    for (var i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
      if (name == this.outputs[i2].name) {
        return !returnObj ? i2 : this.outputs[i2];
      }
    }
    return -1;
  };
  LGraphNode.prototype.findInputSlotFree = function(optsIn) {
    var optsIn = optsIn || {};
    var optsDef = {
      returnObj: false,
      typesNotAccepted: []
    };
    var opts = Object.assign(optsDef, optsIn);
    if (!this.inputs) {
      return -1;
    }
    for (var i2 = 0, l = this.inputs.length; i2 < l; ++i2) {
      if (this.inputs[i2].link && this.inputs[i2].link != null) {
        continue;
      }
      if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.inputs[i2].type)) {
        continue;
      }
      return !opts.returnObj ? i2 : this.inputs[i2];
    }
    return -1;
  };
  LGraphNode.prototype.findOutputSlotFree = function(optsIn) {
    var optsIn = optsIn || {};
    var optsDef = {
      returnObj: false,
      typesNotAccepted: []
    };
    var opts = Object.assign(optsDef, optsIn);
    if (!this.outputs) {
      return -1;
    }
    for (var i2 = 0, l = this.outputs.length; i2 < l; ++i2) {
      if (this.outputs[i2].links && this.outputs[i2].links != null) {
        continue;
      }
      if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.outputs[i2].type)) {
        continue;
      }
      return !opts.returnObj ? i2 : this.outputs[i2];
    }
    return -1;
  };
  LGraphNode.prototype.findInputSlotByType = function(type, returnObj, preferFreeSlot, doNotUseOccupied) {
    return this.findSlotByType(true, type, returnObj, preferFreeSlot, doNotUseOccupied);
  };
  LGraphNode.prototype.findOutputSlotByType = function(type, returnObj, preferFreeSlot, doNotUseOccupied) {
    return this.findSlotByType(false, type, returnObj, preferFreeSlot, doNotUseOccupied);
  };
  LGraphNode.prototype.findSlotByType = function(input, type, returnObj, preferFreeSlot, doNotUseOccupied) {
    input = input || false;
    returnObj = returnObj || false;
    preferFreeSlot = preferFreeSlot || false;
    doNotUseOccupied = doNotUseOccupied || false;
    var aSlots = input ? this.inputs : this.outputs;
    if (!aSlots) {
      return -1;
    }
    if (type == "" || type == "*") type = 0;
    for (var i2 = 0, l = aSlots.length; i2 < l; ++i2) {
      var aSource = (type + "").toLowerCase().split(",");
      var aDest = aSlots[i2].type == "0" || aSlots[i2].type == "*" ? "0" : aSlots[i2].type;
      aDest = (aDest + "").toLowerCase().split(",");
      for (var sI = 0; sI < aSource.length; sI++) {
        for (var dI = 0; dI < aDest.length; dI++) {
          if (aSource[sI] == "_event_") aSource[sI] = LiteGraph.EVENT;
          if (aDest[sI] == "_event_") aDest[sI] = LiteGraph.EVENT;
          if (aSource[sI] == "*") aSource[sI] = 0;
          if (aDest[sI] == "*") aDest[sI] = 0;
          if (aSource[sI] == aDest[dI]) {
            if (preferFreeSlot && (aSlots[i2].links && aSlots[i2].links !== null) || aSlots[i2].link && aSlots[i2].link !== null) continue;
            return !returnObj ? i2 : aSlots[i2];
          }
        }
      }
    }
    if (preferFreeSlot && !doNotUseOccupied) {
      for (var i2 = 0, l = aSlots.length; i2 < l; ++i2) {
        var aSource = (type + "").toLowerCase().split(",");
        var aDest = aSlots[i2].type == "0" || aSlots[i2].type == "*" ? "0" : aSlots[i2].type;
        aDest = (aDest + "").toLowerCase().split(",");
        for (var sI = 0; sI < aSource.length; sI++) {
          for (var dI = 0; dI < aDest.length; dI++) {
            if (aSource[sI] == "*") aSource[sI] = 0;
            if (aDest[sI] == "*") aDest[sI] = 0;
            if (aSource[sI] == aDest[dI]) {
              return !returnObj ? i2 : aSlots[i2];
            }
          }
        }
      }
    }
    return -1;
  };
  LGraphNode.prototype.connectByType = function(slot, target_node, target_slotType, optsIn) {
    var optsIn = optsIn || {};
    var optsDef = {
      createEventInCase: true,
      firstFreeIfOutputGeneralInCase: true,
      generalTypeInCase: true
    };
    var opts = Object.assign(optsDef, optsIn);
    if (target_node && target_node.constructor === Number) {
      target_node = this.graph.getNodeById(target_node);
    }
    var target_slot = target_node.findInputSlotByType(target_slotType, false, true);
    if (target_slot >= 0 && target_slot !== null) {
      return this.connect(slot, target_node, target_slot);
    } else {
      if (opts.createEventInCase && target_slotType == LiteGraph.EVENT) {
        return this.connect(slot, target_node, -1);
      }
      if (opts.generalTypeInCase) {
        var target_slot = target_node.findInputSlotByType(0, false, true, true);
        if (target_slot >= 0) {
          return this.connect(slot, target_node, target_slot);
        }
      }
      if (opts.firstFreeIfOutputGeneralInCase && (target_slotType == 0 || target_slotType == "*" || target_slotType == "")) {
        var target_slot = target_node.findInputSlotFree({ typesNotAccepted: [LiteGraph.EVENT] });
        if (target_slot >= 0) {
          return this.connect(slot, target_node, target_slot);
        }
      }
      console.debug("no way to connect type: ", target_slotType, " to targetNODE ", target_node);
      return null;
    }
  };
  LGraphNode.prototype.connectByTypeOutput = function(slot, source_node, source_slotType, optsIn) {
    var optsIn = optsIn || {};
    var optsDef = {
      createEventInCase: true,
      firstFreeIfInputGeneralInCase: true,
      generalTypeInCase: true
    };
    var opts = Object.assign(optsDef, optsIn);
    if (source_node && source_node.constructor === Number) {
      source_node = this.graph.getNodeById(source_node);
    }
    var source_slot = source_node.findOutputSlotByType(source_slotType, false, true);
    if (source_slot >= 0 && source_slot !== null) {
      return source_node.connect(source_slot, this, slot);
    } else {
      if (opts.generalTypeInCase) {
        var source_slot = source_node.findOutputSlotByType(0, false, true, true);
        if (source_slot >= 0) {
          return source_node.connect(source_slot, this, slot);
        }
      }
      if (opts.createEventInCase && source_slotType == LiteGraph.EVENT) {
        if (LiteGraph.do_add_triggers_slots) {
          var source_slot = source_node.addOnExecutedOutput();
          return source_node.connect(source_slot, this, slot);
        }
      }
      if (opts.firstFreeIfInputGeneralInCase && (source_slotType == 0 || source_slotType == "*" || source_slotType == "")) {
        var source_slot = source_node.findOutputSlotFree({ typesNotAccepted: [LiteGraph.EVENT] });
        if (source_slot >= 0) {
          return source_node.connect(source_slot, this, slot);
        }
      }
      console.debug("no way to connect byOUT type: ", source_slotType, " to sourceNODE ", source_node);
      return null;
    }
  };
  LGraphNode.prototype.connect = function(slot, target_node, target_slot) {
    target_slot = target_slot || 0;
    if (!this.graph) {
      console.log(
        "Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."
      );
      return null;
    }
    if (slot.constructor === String) {
      slot = this.findOutputSlot(slot);
      if (slot == -1) {
        if (LiteGraph.debug) {
          console.log("Connect: Error, no slot of name " + slot);
        }
        return null;
      }
    } else if (!this.outputs || slot >= this.outputs.length) {
      if (LiteGraph.debug) {
        console.log("Connect: Error, slot number not found");
      }
      return null;
    }
    if (target_node && target_node.constructor === Number) {
      target_node = this.graph.getNodeById(target_node);
    }
    if (!target_node) {
      throw "target node is null";
    }
    if (target_node == this) {
      return null;
    }
    if (target_slot.constructor === String) {
      target_slot = target_node.findInputSlot(target_slot);
      if (target_slot == -1) {
        if (LiteGraph.debug) {
          console.log(
            "Connect: Error, no slot of name " + target_slot
          );
        }
        return null;
      }
    } else if (target_slot === LiteGraph.EVENT) {
      if (LiteGraph.do_add_triggers_slots) {
        target_node.changeMode(LiteGraph.ON_TRIGGER);
        target_slot = target_node.findInputSlot("onTrigger");
      } else {
        return null;
      }
    } else if (!target_node.inputs || target_slot >= target_node.inputs.length) {
      if (LiteGraph.debug) {
        console.log("Connect: Error, slot number not found");
      }
      return null;
    }
    var changed = false;
    var input = target_node.inputs[target_slot];
    var link_info = null;
    var output = this.outputs[slot];
    if (!this.outputs[slot]) {
      return null;
    }
    if (target_node.onBeforeConnectInput) {
      target_slot = target_node.onBeforeConnectInput(target_slot);
    }
    if (target_slot === false || target_slot === null || !LiteGraph.isValidConnection(output.type, input.type)) {
      this.setDirtyCanvas(false, true);
      if (changed)
        this.graph.connectionChange(this, link_info);
      return null;
    }
    if (target_node.onConnectInput) {
      if (target_node.onConnectInput(target_slot, output.type, output, this, slot) === false) {
        return null;
      }
    }
    if (this.onConnectOutput) {
      if (this.onConnectOutput(slot, input.type, input, target_node, target_slot) === false) {
        return null;
      }
    }
    if (target_node.inputs[target_slot] && target_node.inputs[target_slot].link != null) {
      this.graph.beforeChange();
      target_node.disconnectInput(target_slot, { doProcessChange: false });
      changed = true;
    }
    if (output.links !== null && output.links.length) {
      switch (output.type) {
        case LiteGraph.EVENT:
          if (!LiteGraph.allow_multi_output_for_events) {
            this.graph.beforeChange();
            this.disconnectOutput(slot, false, { doProcessChange: false });
            changed = true;
          }
          break;
      }
    }
    var nextId;
    if (LiteGraph.use_uuids)
      nextId = LiteGraph.uuidv4();
    else
      nextId = ++this.graph.last_link_id;
    link_info = new LLink(
      nextId,
      input.type || output.type,
      this.id,
      slot,
      target_node.id,
      target_slot
    );
    this.graph.links[link_info.id] = link_info;
    if (output.links == null) {
      output.links = [];
    }
    output.links.push(link_info.id);
    target_node.inputs[target_slot].link = link_info.id;
    if (this.graph) {
      this.graph._version++;
    }
    if (this.onConnectionsChange) {
      this.onConnectionsChange(
        LiteGraph.OUTPUT,
        slot,
        true,
        link_info,
        output
      );
    }
    if (target_node.onConnectionsChange) {
      target_node.onConnectionsChange(
        LiteGraph.INPUT,
        target_slot,
        true,
        link_info,
        input
      );
    }
    if (this.graph && this.graph.onNodeConnectionChange) {
      this.graph.onNodeConnectionChange(
        LiteGraph.INPUT,
        target_node,
        target_slot,
        this,
        slot
      );
      this.graph.onNodeConnectionChange(
        LiteGraph.OUTPUT,
        this,
        slot,
        target_node,
        target_slot
      );
    }
    this.setDirtyCanvas(false, true);
    this.graph.afterChange();
    this.graph.connectionChange(this, link_info);
    return link_info;
  };
  LGraphNode.prototype.disconnectOutput = function(slot, target_node) {
    if (slot.constructor === String) {
      slot = this.findOutputSlot(slot);
      if (slot == -1) {
        if (LiteGraph.debug) {
          console.log("Connect: Error, no slot of name " + slot);
        }
        return false;
      }
    } else if (!this.outputs || slot >= this.outputs.length) {
      if (LiteGraph.debug) {
        console.log("Connect: Error, slot number not found");
      }
      return false;
    }
    var output = this.outputs[slot];
    if (!output || !output.links || output.links.length == 0) {
      return false;
    }
    if (target_node) {
      if (target_node.constructor === Number) {
        target_node = this.graph.getNodeById(target_node);
      }
      if (!target_node) {
        throw "Target Node not found";
      }
      for (var i2 = 0, l = output.links.length; i2 < l; i2++) {
        var link_id = output.links[i2];
        var link_info = this.graph.links[link_id];
        if (link_info.target_id == target_node.id) {
          output.links.splice(i2, 1);
          var input = target_node.inputs[link_info.target_slot];
          input.link = null;
          delete this.graph.links[link_id];
          if (this.graph) {
            this.graph._version++;
          }
          if (target_node.onConnectionsChange) {
            target_node.onConnectionsChange(
              LiteGraph.INPUT,
              link_info.target_slot,
              false,
              link_info,
              input
            );
          }
          if (this.onConnectionsChange) {
            this.onConnectionsChange(
              LiteGraph.OUTPUT,
              slot,
              false,
              link_info,
              output
            );
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(
              LiteGraph.OUTPUT,
              this,
              slot
            );
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(
              LiteGraph.OUTPUT,
              this,
              slot
            );
            this.graph.onNodeConnectionChange(
              LiteGraph.INPUT,
              target_node,
              link_info.target_slot
            );
          }
          break;
        }
      }
    } else {
      for (var i2 = 0, l = output.links.length; i2 < l; i2++) {
        var link_id = output.links[i2];
        var link_info = this.graph.links[link_id];
        if (!link_info) {
          continue;
        }
        var target_node = this.graph.getNodeById(link_info.target_id);
        var input = null;
        if (this.graph) {
          this.graph._version++;
        }
        if (target_node) {
          input = target_node.inputs[link_info.target_slot];
          input.link = null;
          if (target_node.onConnectionsChange) {
            target_node.onConnectionsChange(
              LiteGraph.INPUT,
              link_info.target_slot,
              false,
              link_info,
              input
            );
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(
              LiteGraph.INPUT,
              target_node,
              link_info.target_slot
            );
          }
        }
        delete this.graph.links[link_id];
        if (this.onConnectionsChange) {
          this.onConnectionsChange(
            LiteGraph.OUTPUT,
            slot,
            false,
            link_info,
            output
          );
        }
        if (this.graph && this.graph.onNodeConnectionChange) {
          this.graph.onNodeConnectionChange(
            LiteGraph.OUTPUT,
            this,
            slot
          );
          this.graph.onNodeConnectionChange(
            LiteGraph.INPUT,
            target_node,
            link_info.target_slot
          );
        }
      }
      output.links = null;
    }
    this.setDirtyCanvas(false, true);
    this.graph.connectionChange(this);
    return true;
  };
  LGraphNode.prototype.disconnectInput = function(slot) {
    if (slot.constructor === String) {
      slot = this.findInputSlot(slot);
      if (slot == -1) {
        if (LiteGraph.debug) {
          console.log("Connect: Error, no slot of name " + slot);
        }
        return false;
      }
    } else if (!this.inputs || slot >= this.inputs.length) {
      if (LiteGraph.debug) {
        console.log("Connect: Error, slot number not found");
      }
      return false;
    }
    var input = this.inputs[slot];
    if (!input) {
      return false;
    }
    var link_id = this.inputs[slot].link;
    if (link_id != null) {
      this.inputs[slot].link = null;
      var link_info = this.graph.links[link_id];
      if (link_info) {
        var target_node = this.graph.getNodeById(link_info.origin_id);
        if (!target_node) {
          return false;
        }
        var output = target_node.outputs[link_info.origin_slot];
        if (!output || !output.links || output.links.length == 0) {
          return false;
        }
        for (var i2 = 0, l = output.links.length; i2 < l; i2++) {
          if (output.links[i2] == link_id) {
            output.links.splice(i2, 1);
            break;
          }
        }
        delete this.graph.links[link_id];
        if (this.graph) {
          this.graph._version++;
        }
        if (this.onConnectionsChange) {
          this.onConnectionsChange(
            LiteGraph.INPUT,
            slot,
            false,
            link_info,
            input
          );
        }
        if (target_node.onConnectionsChange) {
          target_node.onConnectionsChange(
            LiteGraph.OUTPUT,
            i2,
            false,
            link_info,
            output
          );
        }
        if (this.graph && this.graph.onNodeConnectionChange) {
          this.graph.onNodeConnectionChange(
            LiteGraph.OUTPUT,
            target_node,
            i2
          );
          this.graph.onNodeConnectionChange(LiteGraph.INPUT, this, slot);
        }
      }
    }
    this.setDirtyCanvas(false, true);
    if (this.graph)
      this.graph.connectionChange(this);
    return true;
  };
  LGraphNode.prototype.getConnectionPos = function(is_input, slot_number, out) {
    out = out || new Float32Array(2);
    var num_slots = 0;
    if (is_input && this.inputs) {
      num_slots = this.inputs.length;
    }
    if (!is_input && this.outputs) {
      num_slots = this.outputs.length;
    }
    var offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5;
    if (this.flags.collapsed) {
      var w2 = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;
      if (this.horizontal) {
        out[0] = this.pos[0] + w2 * 0.5;
        if (is_input) {
          out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
        } else {
          out[1] = this.pos[1];
        }
      } else {
        if (is_input) {
          out[0] = this.pos[0];
        } else {
          out[0] = this.pos[0] + w2;
        }
        out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5;
      }
      return out;
    }
    if (is_input && slot_number == -1) {
      out[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
      out[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;
      return out;
    }
    if (is_input && num_slots > slot_number && this.inputs[slot_number].pos) {
      out[0] = this.pos[0] + this.inputs[slot_number].pos[0];
      out[1] = this.pos[1] + this.inputs[slot_number].pos[1];
      return out;
    } else if (!is_input && num_slots > slot_number && this.outputs[slot_number].pos) {
      out[0] = this.pos[0] + this.outputs[slot_number].pos[0];
      out[1] = this.pos[1] + this.outputs[slot_number].pos[1];
      return out;
    }
    if (this.horizontal) {
      out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);
      if (is_input) {
        out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;
      } else {
        out[1] = this.pos[1] + this.size[1];
      }
      return out;
    }
    if (is_input) {
      out[0] = this.pos[0] + offset;
    } else {
      out[0] = this.pos[0] + this.size[0] + 1 - offset;
    }
    out[1] = this.pos[1] + (slot_number + 0.7) * LiteGraph.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);
    return out;
  };
  LGraphNode.prototype.alignToGrid = function() {
    this.pos[0] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE);
    this.pos[1] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);
  };
  LGraphNode.prototype.trace = function(msg) {
    if (!this.console) {
      this.console = [];
    }
    this.console.push(msg);
    if (this.console.length > LGraphNode.MAX_CONSOLE) {
      this.console.shift();
    }
    if (this.graph.onNodeTrace)
      this.graph.onNodeTrace(this, msg);
  };
  LGraphNode.prototype.setDirtyCanvas = function(dirty_foreground, dirty_background) {
    if (!this.graph) {
      return;
    }
    this.graph.sendActionToCanvas("setDirty", [
      dirty_foreground,
      dirty_background
    ]);
  };
  LGraphNode.prototype.loadImage = function(url) {
    var img = new Image();
    img.src = LiteGraph.node_images_path + url;
    img.ready = false;
    var that2 = this;
    img.onload = function() {
      this.ready = true;
      that2.setDirtyCanvas(true);
    };
    return img;
  };
  LGraphNode.prototype.captureInput = function(v2) {
    if (!this.graph || !this.graph.list_of_graphcanvas) {
      return;
    }
    var list = this.graph.list_of_graphcanvas;
    for (var i2 = 0; i2 < list.length; ++i2) {
      var c = list[i2];
      if (!v2 && c.node_capturing_input != this) {
        continue;
      }
      c.node_capturing_input = v2 ? this : null;
    }
  };
  LGraphNode.prototype.collapse = function(force) {
    this.graph._version++;
    if (this.constructor.collapsable === false && !force) {
      return;
    }
    if (!this.flags.collapsed) {
      this.flags.collapsed = true;
    } else {
      this.flags.collapsed = false;
    }
    this.setDirtyCanvas(true, true);
  };
  LGraphNode.prototype.pin = function(v2) {
    this.graph._version++;
    if (v2 === void 0) {
      this.flags.pinned = !this.flags.pinned;
    } else {
      this.flags.pinned = v2;
    }
  };
  LGraphNode.prototype.localToScreen = function(x2, y2, graphcanvas) {
    return [
      (x2 + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],
      (y2 + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1]
    ];
  };
  function LGraphGroup(title) {
    this._ctor(title);
  }
  globalThis.LGraphGroup = LiteGraph.LGraphGroup = LGraphGroup;
  LGraphGroup.prototype._ctor = function(title) {
    this.title = title || "Group";
    this.font_size = LiteGraph.DEFAULT_GROUP_FONT || 24;
    this.color = LGraphCanvas.node_colors.pale_blue ? LGraphCanvas.node_colors.pale_blue.groupcolor : "#AAA";
    this._bounding = new Float32Array([10, 10, 140, 80]);
    this._pos = this._bounding.subarray(0, 2);
    this._size = this._bounding.subarray(2, 4);
    this._nodes = [];
    this.graph = null;
    Object.defineProperty(this, "pos", {
      set: function(v2) {
        if (!v2 || v2.length < 2) {
          return;
        }
        this._pos[0] = v2[0];
        this._pos[1] = v2[1];
      },
      get: function() {
        return this._pos;
      },
      enumerable: true
    });
    Object.defineProperty(this, "size", {
      set: function(v2) {
        if (!v2 || v2.length < 2) {
          return;
        }
        this._size[0] = Math.max(140, v2[0]);
        this._size[1] = Math.max(80, v2[1]);
      },
      get: function() {
        return this._size;
      },
      enumerable: true
    });
  };
  LGraphGroup.prototype.configure = function(o) {
    this.title = o.title;
    this._bounding.set(o.bounding);
    this.color = o.color;
    if (o.font_size) {
      this.font_size = o.font_size;
    }
  };
  LGraphGroup.prototype.serialize = function() {
    var b = this._bounding;
    return {
      title: this.title,
      bounding: [
        Math.round(b[0]),
        Math.round(b[1]),
        Math.round(b[2]),
        Math.round(b[3])
      ],
      color: this.color,
      font_size: this.font_size
    };
  };
  LGraphGroup.prototype.move = function(deltax, deltay, ignore_nodes) {
    this._pos[0] += deltax;
    this._pos[1] += deltay;
    if (ignore_nodes) {
      return;
    }
    for (var i2 = 0; i2 < this._nodes.length; ++i2) {
      var node22 = this._nodes[i2];
      node22.pos[0] += deltax;
      node22.pos[1] += deltay;
    }
  };
  LGraphGroup.prototype.recomputeInsideNodes = function() {
    this._nodes.length = 0;
    var nodes = this.graph._nodes;
    var node_bounding = new Float32Array(4);
    for (var i2 = 0; i2 < nodes.length; ++i2) {
      var node22 = nodes[i2];
      node22.getBounding(node_bounding);
      if (!overlapBounding(this._bounding, node_bounding)) {
        continue;
      }
      this._nodes.push(node22);
    }
  };
  LGraphGroup.prototype.isPointInside = LGraphNode.prototype.isPointInside;
  LGraphGroup.prototype.setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas;
  function DragAndScale(element, skip_events) {
    this.offset = new Float32Array([0, 0]);
    this.scale = 1;
    this.max_scale = 10;
    this.min_scale = 0.1;
    this.onredraw = null;
    this.enabled = true;
    this.last_mouse = [0, 0];
    this.element = null;
    this.visible_area = new Float32Array(4);
    if (element) {
      this.element = element;
      if (!skip_events) {
        this.bindEvents(element);
      }
    }
  }
  LiteGraph.DragAndScale = DragAndScale;
  DragAndScale.prototype.bindEvents = function(element) {
    this.last_mouse = new Float32Array(2);
    this._binded_mouse_callback = this.onMouse.bind(this);
    LiteGraph.pointerListenerAdd(element, "down", this._binded_mouse_callback);
    LiteGraph.pointerListenerAdd(element, "move", this._binded_mouse_callback);
    LiteGraph.pointerListenerAdd(element, "up", this._binded_mouse_callback);
    element.addEventListener(
      "mousewheel",
      this._binded_mouse_callback,
      false
    );
    element.addEventListener("wheel", this._binded_mouse_callback, false);
  };
  DragAndScale.prototype.computeVisibleArea = function(viewport) {
    if (!this.element) {
      this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;
      return;
    }
    var width2 = this.element.width;
    var height = this.element.height;
    var startx = -this.offset[0];
    var starty = -this.offset[1];
    if (viewport) {
      startx += viewport[0] / this.scale;
      starty += viewport[1] / this.scale;
      width2 = viewport[2];
      height = viewport[3];
    }
    var endx = startx + width2 / this.scale;
    var endy = starty + height / this.scale;
    this.visible_area[0] = startx;
    this.visible_area[1] = starty;
    this.visible_area[2] = endx - startx;
    this.visible_area[3] = endy - starty;
  };
  DragAndScale.prototype.onMouse = function(e) {
    if (!this.enabled) {
      return;
    }
    var canvas = this.element;
    var rect = canvas.getBoundingClientRect();
    var x2 = e.clientX - rect.left;
    var y2 = e.clientY - rect.top;
    e.canvasx = x2;
    e.canvasy = y2;
    e.dragging = this.dragging;
    var is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
    var ignore = false;
    if (this.onmouse) {
      ignore = this.onmouse(e);
    }
    if (e.type == LiteGraph.pointerevents_method + "down" && is_inside) {
      this.dragging = true;
      LiteGraph.pointerListenerRemove(canvas, "move", this._binded_mouse_callback);
      LiteGraph.pointerListenerAdd(document, "move", this._binded_mouse_callback);
      LiteGraph.pointerListenerAdd(document, "up", this._binded_mouse_callback);
    } else if (e.type == LiteGraph.pointerevents_method + "move") {
      if (!ignore) {
        var deltax = x2 - this.last_mouse[0];
        var deltay = y2 - this.last_mouse[1];
        if (this.dragging) {
          this.mouseDrag(deltax, deltay);
        }
      }
    } else if (e.type == LiteGraph.pointerevents_method + "up") {
      this.dragging = false;
      LiteGraph.pointerListenerRemove(document, "move", this._binded_mouse_callback);
      LiteGraph.pointerListenerRemove(document, "up", this._binded_mouse_callback);
      LiteGraph.pointerListenerAdd(canvas, "move", this._binded_mouse_callback);
    } else if (is_inside && (e.type == "mousewheel" || e.type == "wheel" || e.type == "DOMMouseScroll")) {
      e.eventType = "mousewheel";
      if (e.type == "wheel") {
        e.wheel = -e.deltaY;
      } else {
        e.wheel = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;
      }
      e.delta = e.wheelDelta ? e.wheelDelta / 40 : e.deltaY ? -e.deltaY / 3 : 0;
      this.changeDeltaScale(1 + e.delta * 0.05);
    }
    this.last_mouse[0] = x2;
    this.last_mouse[1] = y2;
    if (is_inside) {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  };
  DragAndScale.prototype.toCanvasContext = function(ctx) {
    ctx.scale(this.scale, this.scale);
    ctx.translate(this.offset[0], this.offset[1]);
  };
  DragAndScale.prototype.convertOffsetToCanvas = function(pos2) {
    return [
      (pos2[0] + this.offset[0]) * this.scale,
      (pos2[1] + this.offset[1]) * this.scale
    ];
  };
  DragAndScale.prototype.convertCanvasToOffset = function(pos2, out) {
    out = out || [0, 0];
    out[0] = pos2[0] / this.scale - this.offset[0];
    out[1] = pos2[1] / this.scale - this.offset[1];
    return out;
  };
  DragAndScale.prototype.mouseDrag = function(x2, y2) {
    this.offset[0] += x2 / this.scale;
    this.offset[1] += y2 / this.scale;
    if (this.onredraw) {
      this.onredraw(this);
    }
  };
  DragAndScale.prototype.changeScale = function(value3, zooming_center) {
    if (value3 < this.min_scale) {
      value3 = this.min_scale;
    } else if (value3 > this.max_scale) {
      value3 = this.max_scale;
    }
    if (value3 == this.scale) {
      return;
    }
    if (!this.element) {
      return;
    }
    var rect = this.element.getBoundingClientRect();
    if (!rect) {
      return;
    }
    zooming_center = zooming_center || [
      rect.width * 0.5,
      rect.height * 0.5
    ];
    var center = this.convertCanvasToOffset(zooming_center);
    this.scale = value3;
    if (Math.abs(this.scale - 1) < 0.01) {
      this.scale = 1;
    }
    var new_center = this.convertCanvasToOffset(zooming_center);
    var delta_offset = [
      new_center[0] - center[0],
      new_center[1] - center[1]
    ];
    this.offset[0] += delta_offset[0];
    this.offset[1] += delta_offset[1];
    if (this.onredraw) {
      this.onredraw(this);
    }
  };
  DragAndScale.prototype.changeDeltaScale = function(value3, zooming_center) {
    this.changeScale(this.scale * value3, zooming_center);
  };
  DragAndScale.prototype.reset = function() {
    this.scale = 1;
    this.offset[0] = 0;
    this.offset[1] = 0;
  };
  function LGraphCanvas(canvas, graph, options3) {
    this.options = options3 = options3 || {};
    this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;
    if (canvas && canvas.constructor === String) {
      canvas = document.querySelector(canvas);
    }
    this.ds = new DragAndScale();
    this.zoom_modify_alpha = true;
    this.title_text_font = "" + LiteGraph.NODE_TEXT_SIZE + "px Arial";
    this.inner_text_font = "normal " + LiteGraph.NODE_SUBTEXT_SIZE + "px Arial";
    this.node_title_color = LiteGraph.NODE_TITLE_COLOR;
    this.default_link_color = LiteGraph.LINK_COLOR;
    this.default_connection_color = {
      input_off: "#778",
      input_on: "#7F7",
      //"#BBD"
      output_off: "#778",
      output_on: "#7F7"
      //"#BBD"
    };
    this.default_connection_color_byType = {
      /*number: "#7F7",
      string: "#77F",
      boolean: "#F77",*/
    };
    this.default_connection_color_byTypeOff = {
      /*number: "#474",
      string: "#447",
      boolean: "#744",*/
    };
    this.highquality_render = true;
    this.use_gradients = false;
    this.editor_alpha = 1;
    this.pause_rendering = false;
    this.clear_background = true;
    this.clear_background_color = "#222";
    this.read_only = false;
    this.render_only_selected = true;
    this.live_mode = false;
    this.show_info = true;
    this.allow_dragcanvas = true;
    this.allow_dragnodes = true;
    this.allow_interaction = true;
    this.multi_select = false;
    this.allow_searchbox = true;
    this.allow_reconnect_links = true;
    this.align_to_grid = false;
    this.drag_mode = false;
    this.dragging_rectangle = null;
    this.filter = null;
    this.set_canvas_dirty_on_mouse_event = true;
    this.always_render_background = false;
    this.render_shadows = true;
    this.render_canvas_border = true;
    this.render_connections_shadows = false;
    this.render_connections_border = true;
    this.render_curved_connections = false;
    this.render_connection_arrows = false;
    this.render_collapsed_slots = true;
    this.render_execution_order = false;
    this.render_title_colored = true;
    this.render_link_tooltip = true;
    this.links_render_mode = LiteGraph.SPLINE_LINK;
    this.mouse = [0, 0];
    this.graph_mouse = [0, 0];
    this.canvas_mouse = this.graph_mouse;
    this.onSearchBox = null;
    this.onSearchBoxSelection = null;
    this.onMouse = null;
    this.onDrawBackground = null;
    this.onDrawForeground = null;
    this.onDrawOverlay = null;
    this.onDrawLinkTooltip = null;
    this.onNodeMoved = null;
    this.onSelectionChange = null;
    this.onConnectingChange = null;
    this.onBeforeChange = null;
    this.onAfterChange = null;
    this.connections_width = 3;
    this.round_radius = 8;
    this.current_node = null;
    this.node_widget = null;
    this.over_link_center = null;
    this.last_mouse_position = [0, 0];
    this.visible_area = this.ds.visible_area;
    this.visible_links = [];
    this.connecting_links = null;
    this.viewport = options3.viewport || null;
    if (graph) {
      graph.attachCanvas(this);
    }
    this.setCanvas(canvas, options3.skip_events);
    this.clear();
    if (!options3.skip_render) {
      this.startRendering();
    }
    this.autoresize = options3.autoresize;
  }
  globalThis.LGraphCanvas = LiteGraph.LGraphCanvas = LGraphCanvas;
  LGraphCanvas.DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";
  LGraphCanvas.link_type_colors = {
    "-1": LiteGraph.EVENT_LINK_COLOR,
    number: "#AAA",
    node: "#DCA"
  };
  LGraphCanvas.gradients = {};
  LGraphCanvas.prototype.clear = function() {
    this.frame = 0;
    this.last_draw_time = 0;
    this.render_time = 0;
    this.fps = 0;
    this.dragging_rectangle = null;
    this.selected_nodes = {};
    this.selected_group = null;
    this.visible_nodes = [];
    this.node_dragged = null;
    this.node_over = null;
    this.node_capturing_input = null;
    this.connecting_links = null;
    this.highlighted_links = {};
    this.dragging_canvas = false;
    this.dirty_canvas = true;
    this.dirty_bgcanvas = true;
    this.dirty_area = null;
    this.node_in_panel = null;
    this.node_widget = null;
    this.last_mouse = [0, 0];
    this.last_mouseclick = 0;
    this.pointer_is_down = false;
    this.pointer_is_double = false;
    this.visible_area.set([0, 0, 0, 0]);
    if (this.onClear) {
      this.onClear();
    }
  };
  LGraphCanvas.prototype.setGraph = function(graph, skip_clear) {
    if (this.graph == graph) {
      return;
    }
    if (!skip_clear) {
      this.clear();
    }
    if (!graph && this.graph) {
      this.graph.detachCanvas(this);
      return;
    }
    graph.attachCanvas(this);
    if (this._graph_stack)
      this._graph_stack = null;
    this.setDirty(true, true);
  };
  LGraphCanvas.prototype.getTopGraph = function() {
    if (this._graph_stack.length)
      return this._graph_stack[0];
    return this.graph;
  };
  LGraphCanvas.prototype.openSubgraph = function(graph) {
    if (!graph) {
      throw "graph cannot be null";
    }
    if (this.graph == graph) {
      throw "graph cannot be the same";
    }
    this.clear();
    if (this.graph) {
      if (!this._graph_stack) {
        this._graph_stack = [];
      }
      this._graph_stack.push(this.graph);
    }
    graph.attachCanvas(this);
    this.checkPanels();
    this.setDirty(true, true);
  };
  LGraphCanvas.prototype.closeSubgraph = function() {
    if (!this._graph_stack || this._graph_stack.length == 0) {
      return;
    }
    var subgraph_node = this.graph._subgraph_node;
    var graph = this._graph_stack.pop();
    this.selected_nodes = {};
    this.highlighted_links = {};
    graph.attachCanvas(this);
    this.setDirty(true, true);
    if (subgraph_node) {
      this.centerOnNode(subgraph_node);
      this.selectNodes([subgraph_node]);
    }
    this.ds.offset = [0, 0];
    this.ds.scale = 1;
  };
  LGraphCanvas.prototype.getCurrentGraph = function() {
    return this.graph;
  };
  LGraphCanvas.prototype.setCanvas = function(canvas, skip_events) {
    if (canvas) {
      if (canvas.constructor === String) {
        canvas = document.getElementById(canvas);
        if (!canvas) {
          throw "Error creating LiteGraph canvas: Canvas not found";
        }
      }
    }
    if (canvas === this.canvas) {
      return;
    }
    if (!canvas && this.canvas) {
      if (!skip_events) {
        this.unbindEvents();
      }
    }
    this.canvas = canvas;
    this.ds.element = canvas;
    if (!canvas) {
      return;
    }
    canvas.className += " lgraphcanvas";
    canvas.data = this;
    canvas.tabindex = "1";
    this.bgcanvas = null;
    if (!this.bgcanvas) {
      this.bgcanvas = document.createElement("canvas");
      this.bgcanvas.width = this.canvas.width;
      this.bgcanvas.height = this.canvas.height;
    }
    if (canvas.getContext == null) {
      if (canvas.localName != "canvas") {
        throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + canvas.localName;
      }
      throw "This browser doesn't support Canvas";
    }
    var ctx = this.ctx = canvas.getContext("2d");
    if (ctx == null) {
      if (!canvas.webgl_enabled) {
        console.warn(
          "This canvas seems to be WebGL, enabling WebGL renderer"
        );
      }
      this.enableWebGL();
    }
    if (!skip_events) {
      this.bindEvents();
    }
  };
  LGraphCanvas.prototype._doNothing = function doNothing(e) {
    e.preventDefault();
    return false;
  };
  LGraphCanvas.prototype._doReturnTrue = function doNothing(e) {
    e.preventDefault();
    return true;
  };
  LGraphCanvas.prototype.bindEvents = function() {
    if (this._events_binded) {
      console.warn("LGraphCanvas: events already binded");
      return;
    }
    var canvas = this.canvas;
    var ref_window2 = this.getCanvasWindow();
    var document2 = ref_window2.document;
    this._mousedown_callback = this.processMouseDown.bind(this);
    this._mousewheel_callback = this.processMouseWheel.bind(this);
    this._mousemove_callback = this.processMouseMove.bind(this);
    this._mouseup_callback = this.processMouseUp.bind(this);
    LiteGraph.pointerListenerAdd(canvas, "down", this._mousedown_callback, true);
    canvas.addEventListener("mousewheel", this._mousewheel_callback, false);
    LiteGraph.pointerListenerAdd(canvas, "up", this._mouseup_callback, true);
    LiteGraph.pointerListenerAdd(canvas, "move", this._mousemove_callback);
    canvas.addEventListener("contextmenu", this._doNothing);
    canvas.addEventListener(
      "DOMMouseScroll",
      this._mousewheel_callback,
      false
    );
    this._key_callback = this.processKey.bind(this);
    canvas.addEventListener("keydown", this._key_callback, true);
    document2.addEventListener("keyup", this._key_callback, true);
    this._ondrop_callback = this.processDrop.bind(this);
    canvas.addEventListener("dragover", this._doNothing, false);
    canvas.addEventListener("dragend", this._doNothing, false);
    canvas.addEventListener("drop", this._ondrop_callback, false);
    canvas.addEventListener("dragenter", this._doReturnTrue, false);
    this._events_binded = true;
  };
  LGraphCanvas.prototype.unbindEvents = function() {
    if (!this._events_binded) {
      console.warn("LGraphCanvas: no events binded");
      return;
    }
    var ref_window2 = this.getCanvasWindow();
    var document2 = ref_window2.document;
    LiteGraph.pointerListenerRemove(this.canvas, "move", this._mousemove_callback);
    LiteGraph.pointerListenerRemove(this.canvas, "up", this._mouseup_callback);
    LiteGraph.pointerListenerRemove(this.canvas, "down", this._mousedown_callback);
    this.canvas.removeEventListener(
      "mousewheel",
      this._mousewheel_callback
    );
    this.canvas.removeEventListener(
      "DOMMouseScroll",
      this._mousewheel_callback
    );
    this.canvas.removeEventListener("keydown", this._key_callback);
    document2.removeEventListener("keyup", this._key_callback);
    this.canvas.removeEventListener("contextmenu", this._doNothing);
    this.canvas.removeEventListener("drop", this._ondrop_callback);
    this.canvas.removeEventListener("dragenter", this._doReturnTrue);
    this._mousedown_callback = null;
    this._mousewheel_callback = null;
    this._key_callback = null;
    this._ondrop_callback = null;
    this._events_binded = false;
  };
  LGraphCanvas.getFileExtension = function(url) {
    var question = url.indexOf("?");
    if (question != -1) {
      url = url.substr(0, question);
    }
    var point = url.lastIndexOf(".");
    if (point == -1) {
      return "";
    }
    return url.substr(point + 1).toLowerCase();
  };
  LGraphCanvas.prototype.enableWebGL = function() {
    if (typeof GL === "undefined") {
      throw "litegl.js must be included to use a WebGL canvas";
    }
    if (typeof enableWebGLCanvas === "undefined") {
      throw "webglCanvas.js must be included to use this feature";
    }
    this.gl = this.ctx = enableWebGLCanvas(this.canvas);
    this.ctx.webgl = true;
    this.bgcanvas = this.canvas;
    this.bgctx = this.gl;
    this.canvas.webgl_enabled = true;
  };
  LGraphCanvas.prototype.setDirty = function(fgcanvas, bgcanvas) {
    if (fgcanvas) {
      this.dirty_canvas = true;
    }
    if (bgcanvas) {
      this.dirty_bgcanvas = true;
    }
  };
  LGraphCanvas.prototype.getCanvasWindow = function() {
    if (!this.canvas) {
      return window;
    }
    var doc2 = this.canvas.ownerDocument;
    return doc2.defaultView || doc2.parentWindow;
  };
  LGraphCanvas.prototype.startRendering = function() {
    if (this.is_rendering) {
      return;
    }
    this.is_rendering = true;
    renderFrame.call(this);
    function renderFrame() {
      if (!this.pause_rendering) {
        this.draw();
      }
      var window2 = this.getCanvasWindow();
      if (this.is_rendering) {
        window2.requestAnimationFrame(renderFrame.bind(this));
      }
    }
  };
  LGraphCanvas.prototype.stopRendering = function() {
    this.is_rendering = false;
  };
  LGraphCanvas.prototype.blockClick = function() {
    this.block_click = true;
    this.last_mouseclick = 0;
  };
  LGraphCanvas.prototype.processMouseDown = function(e) {
    var _a2;
    if (this.set_canvas_dirty_on_mouse_event)
      this.dirty_canvas = true;
    if (!this.graph) {
      return;
    }
    this.adjustMouseEvent(e);
    var ref_window2 = this.getCanvasWindow();
    ref_window2.document;
    LGraphCanvas.active_canvas = this;
    var that2 = this;
    var x2 = e.clientX;
    var y2 = e.clientY;
    this.ds.viewport = this.viewport;
    var is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
    if (!this.options.skip_events) {
      LiteGraph.pointerListenerRemove(this.canvas, "move", this._mousemove_callback);
      LiteGraph.pointerListenerAdd(ref_window2.document, "move", this._mousemove_callback, true);
      LiteGraph.pointerListenerAdd(ref_window2.document, "up", this._mouseup_callback, true);
    }
    if (!is_inside) {
      return;
    }
    var node22 = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes, 5);
    var skip_action = false;
    var now2 = LiteGraph.getTime();
    var is_primary = e.isPrimary === void 0 || !e.isPrimary;
    var is_double_click = now2 - this.last_mouseclick < 300;
    this.mouse[0] = e.clientX;
    this.mouse[1] = e.clientY;
    this.graph_mouse[0] = e.canvasX;
    this.graph_mouse[1] = e.canvasY;
    this.last_click_position = [this.mouse[0], this.mouse[1]];
    if (this.pointer_is_down && is_primary) {
      this.pointer_is_double = true;
    } else {
      this.pointer_is_double = false;
    }
    this.pointer_is_down = true;
    this.canvas.focus();
    LiteGraph.closeAllContextMenus(ref_window2);
    if (this.onMouse) {
      if (this.onMouse(e) == true)
        return;
    }
    if (e.which == 1 && !this.pointer_is_double) {
      if (e.ctrlKey && !e.altKey) {
        this.dragging_rectangle = new Float32Array(4);
        this.dragging_rectangle[0] = e.canvasX;
        this.dragging_rectangle[1] = e.canvasY;
        this.dragging_rectangle[2] = 1;
        this.dragging_rectangle[3] = 1;
        skip_action = true;
      }
      if (LiteGraph.alt_drag_do_clone_nodes && e.altKey && !e.ctrlKey && node22 && this.allow_interaction && !skip_action && !this.read_only) {
        const cloned = node22.clone();
        if (cloned) {
          cloned.pos[0] += 5;
          cloned.pos[1] += 5;
          this.graph.add(cloned, false, { doCalcSize: false });
          node22 = cloned;
          skip_action = true;
          if (!block_drag_node) {
            if (this.allow_dragnodes) {
              this.graph.beforeChange();
              this.node_dragged = node22;
            }
            if (!this.selected_nodes[node22.id]) {
              this.processNodeSelected(node22, e);
            }
          }
        }
      }
      var clicking_canvas_bg = false;
      if (node22 && (this.allow_interaction || node22.flags.allow_interaction) && !skip_action && !this.read_only) {
        if (!this.live_mode && !node22.flags.pinned) {
          this.bringToFront(node22);
        }
        if (this.allow_interaction && !this.connecting_links && !node22.flags.collapsed && !this.live_mode) {
          if (!skip_action && node22.resizable !== false && node22.inResizeCorner(e.canvasX, e.canvasY)) {
            this.graph.beforeChange();
            this.resizing_node = node22;
            this.canvas.style.cursor = "se-resize";
            skip_action = true;
          } else {
            if (node22.outputs) {
              for (var i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
                var output = node22.outputs[i2];
                var link_pos = node22.getConnectionPos(false, i2);
                if (isInsideRectangle(
                  e.canvasX,
                  e.canvasY,
                  link_pos[0] - 15,
                  link_pos[1] - 10,
                  30,
                  20
                )) {
                  if (e.shiftKey) {
                    if (((_a2 = output.links) == null ? void 0 : _a2.length) > 0) {
                      this.connecting_links = [];
                      for (const linkId of output.links) {
                        const link2 = this.graph.links[linkId];
                        const slot = link2.target_slot;
                        const linked_node = this.graph._nodes_by_id[link2.target_id];
                        const input2 = linked_node.inputs[slot];
                        const pos3 = linked_node.getConnectionPos(true, slot);
                        this.connecting_links.push({
                          node: linked_node,
                          slot,
                          input: input2,
                          output: null,
                          pos: pos3
                        });
                      }
                      skip_action = true;
                      break;
                    }
                  }
                  output.slot_index = i2;
                  this.connecting_links = [
                    {
                      node: node22,
                      slot: i2,
                      input: null,
                      output,
                      pos: link_pos
                    }
                  ];
                  if (LiteGraph.shift_click_do_break_link_from) {
                    if (e.shiftKey) {
                      node22.disconnectOutput(i2);
                    }
                  } else if (LiteGraph.ctrl_alt_click_do_break_link) {
                    if (e.ctrlKey && e.altKey && !e.shiftKey) {
                      node22.disconnectOutput(i2);
                    }
                  }
                  if (is_double_click) {
                    if (node22.onOutputDblClick) {
                      node22.onOutputDblClick(i2, e);
                    }
                  } else {
                    if (node22.onOutputClick) {
                      node22.onOutputClick(i2, e);
                    }
                  }
                  skip_action = true;
                  break;
                }
              }
            }
            if (node22.inputs) {
              for (var i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
                var input = node22.inputs[i2];
                var link_pos = node22.getConnectionPos(true, i2);
                if (isInsideRectangle(
                  e.canvasX,
                  e.canvasY,
                  link_pos[0] - 15,
                  link_pos[1] - 10,
                  30,
                  20
                )) {
                  if (is_double_click) {
                    if (node22.onInputDblClick) {
                      node22.onInputDblClick(i2, e);
                    }
                  } else {
                    if (node22.onInputClick) {
                      node22.onInputClick(i2, e);
                    }
                  }
                  if (input.link !== null) {
                    var link_info = this.graph.links[input.link];
                    if (LiteGraph.click_do_break_link_to || LiteGraph.ctrl_alt_click_do_break_link && e.ctrlKey && e.altKey && !e.shiftKey) {
                      node22.disconnectInput(i2);
                    } else if (this.allow_reconnect_links || //this.move_destination_link_without_shift ||
                    e.shiftKey) {
                      if (!LiteGraph.click_do_break_link_to) {
                        node22.disconnectInput(i2);
                      }
                      const linked_node = this.graph._nodes_by_id[link_info.origin_id];
                      const slot = link_info.origin_slot;
                      this.connecting_links = [
                        {
                          node: linked_node,
                          slot,
                          input: null,
                          output: linked_node.outputs[slot],
                          pos: linked_node.getConnectionPos(false, slot)
                        }
                      ];
                      this.dirty_bgcanvas = true;
                      skip_action = true;
                    } else ;
                  }
                  if (!skip_action) {
                    this.connecting_links = [
                      {
                        node: node22,
                        slot: i2,
                        input,
                        output: null,
                        pos: link_pos
                      }
                    ];
                    this.dirty_bgcanvas = true;
                    skip_action = true;
                  }
                  break;
                }
              }
            }
          }
        }
        if (!skip_action) {
          var block_drag_node = false;
          if (node22 && node22.flags && node22.flags.pinned) {
            block_drag_node = true;
          }
          var pos2 = [e.canvasX - node22.pos[0], e.canvasY - node22.pos[1]];
          var widget = this.processNodeWidgets(node22, this.graph_mouse, e);
          if (widget) {
            block_drag_node = true;
            this.node_widget = [node22, widget];
          }
          if (this.allow_interaction && is_double_click && this.selected_nodes[node22.id]) {
            if (node22.onDblClick) {
              node22.onDblClick(e, pos2, this);
            }
            this.processNodeDblClicked(node22);
            block_drag_node = true;
          }
          if (node22.onMouseDown && node22.onMouseDown(e, pos2, this)) {
            block_drag_node = true;
          } else {
            if (node22.subgraph && !node22.skip_subgraph_button) {
              if (!node22.flags.collapsed && pos2[0] > node22.size[0] - LiteGraph.NODE_TITLE_HEIGHT && pos2[1] < 0) {
                var that2 = this;
                setTimeout(function() {
                  that2.openSubgraph(node22.subgraph);
                }, 10);
              }
            }
            if (this.live_mode) {
              clicking_canvas_bg = true;
              block_drag_node = true;
            }
          }
          if (!block_drag_node) {
            if (this.allow_dragnodes) {
              this.graph.beforeChange();
              this.node_dragged = node22;
            }
            if (!(e.shiftKey && !e.ctrlKey && !e.altKey) || !node22.is_selected) {
              this.processNodeSelected(node22, e);
            }
          } else {
            if (!node22.is_selected) this.processNodeSelected(node22, e);
          }
          this.dirty_canvas = true;
        }
      } else {
        if (!skip_action) {
          if (!this.read_only) {
            for (var i2 = 0; i2 < this.visible_links.length; ++i2) {
              var link = this.visible_links[i2];
              var center = link._pos;
              if (!center || e.canvasX < center[0] - 4 || e.canvasX > center[0] + 4 || e.canvasY < center[1] - 4 || e.canvasY > center[1] + 4) {
                continue;
              }
              this.showLinkMenu(link, e);
              this.over_link_center = null;
              break;
            }
          }
          this.selected_group = this.graph.getGroupOnPos(e.canvasX, e.canvasY);
          this.selected_group_resizing = false;
          if (this.selected_group && !this.read_only) {
            if (e.ctrlKey) {
              this.dragging_rectangle = null;
            }
            var dist2 = distance([e.canvasX, e.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]);
            if (dist2 * this.ds.scale < 10) {
              this.selected_group_resizing = true;
            } else {
              this.selected_group.recomputeInsideNodes();
            }
          }
          if (is_double_click && !this.read_only) {
            if (this.allow_searchbox) {
              this.showSearchBox(e);
              e.preventDefault();
              e.stopPropagation();
            }
            this.canvas.dispatchEvent(new CustomEvent(
              "litegraph:canvas",
              {
                bubbles: true,
                detail: {
                  subType: "empty-double-click",
                  originalEvent: e
                }
              }
            ));
          }
          clicking_canvas_bg = true;
        }
      }
      if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {
        this.dragging_canvas = true;
      }
    } else if (e.which == 2) {
      if (LiteGraph.middle_click_slot_add_default_node) {
        if (node22 && this.allow_interaction && !skip_action && !this.read_only) {
          if (!this.connecting_links && !node22.flags.collapsed && !this.live_mode) {
            var mClikSlot = false;
            var mClikSlot_index = false;
            var mClikSlot_isOut = false;
            if (node22.outputs) {
              for (var i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
                var output = node22.outputs[i2];
                var link_pos = node22.getConnectionPos(false, i2);
                if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {
                  mClikSlot = output;
                  mClikSlot_index = i2;
                  mClikSlot_isOut = true;
                  break;
                }
              }
            }
            if (node22.inputs) {
              for (var i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
                var input = node22.inputs[i2];
                var link_pos = node22.getConnectionPos(true, i2);
                if (isInsideRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {
                  mClikSlot = input;
                  mClikSlot_index = i2;
                  mClikSlot_isOut = false;
                  break;
                }
              }
            }
            if (mClikSlot && mClikSlot_index !== false) {
              var alphaPosY = 0.5 - (mClikSlot_index + 1) / (mClikSlot_isOut ? node22.outputs.length : node22.inputs.length);
              var node_bounding = node22.getBounding();
              var posRef = [
                !mClikSlot_isOut ? node_bounding[0] : node_bounding[0] + node_bounding[2],
                e.canvasY - 80
                // + node_bounding[0]/this.canvas.width*66 // vertical "derive"
              ];
              this.createDefaultNodeForSlot({
                nodeFrom: !mClikSlot_isOut ? null : node22,
                slotFrom: !mClikSlot_isOut ? null : mClikSlot_index,
                nodeTo: !mClikSlot_isOut ? node22 : null,
                slotTo: !mClikSlot_isOut ? mClikSlot_index : null,
                position: posRef,
                nodeType: "AUTO",
                posAdd: [!mClikSlot_isOut ? -30 : 30, -alphaPosY * 130],
                posSizeFix: [!mClikSlot_isOut ? -1 : 0, 0]
                //-alphaPosY*2*/
              });
              skip_action = true;
            }
          }
        }
      }
      if (!skip_action && this.allow_dragcanvas) {
        this.dragging_canvas = true;
      }
    } else if (e.which == 3 || this.pointer_is_double) {
      if (this.allow_interaction && !skip_action && !this.read_only) {
        if (node22) {
          if (Object.keys(this.selected_nodes).length && (this.selected_nodes[node22.id] || e.shiftKey || e.ctrlKey || e.metaKey)) {
            if (!this.selected_nodes[node22.id]) this.selectNodes([node22], true);
          } else {
            this.selectNodes([node22]);
          }
        }
        this.processContextMenu(node22, e);
      }
    }
    this.last_mouse[0] = e.clientX;
    this.last_mouse[1] = e.clientY;
    this.last_mouseclick = LiteGraph.getTime();
    this.last_mouse_dragging = true;
    this.graph.change();
    if (!ref_window2.document.activeElement || ref_window2.document.activeElement.nodeName.toLowerCase() != "input" && ref_window2.document.activeElement.nodeName.toLowerCase() != "textarea") {
      e.preventDefault();
    }
    e.stopPropagation();
    if (this.onMouseDown) {
      this.onMouseDown(e);
    }
    return false;
  };
  LGraphCanvas.prototype.processMouseMove = function(e) {
    if (this.autoresize) {
      this.resize();
    }
    if (this.set_canvas_dirty_on_mouse_event)
      this.dirty_canvas = true;
    if (!this.graph) {
      return;
    }
    LGraphCanvas.active_canvas = this;
    this.adjustMouseEvent(e);
    var mouse = [e.clientX, e.clientY];
    this.mouse[0] = mouse[0];
    this.mouse[1] = mouse[1];
    var delta2 = [
      mouse[0] - this.last_mouse[0],
      mouse[1] - this.last_mouse[1]
    ];
    this.last_mouse = mouse;
    this.graph_mouse[0] = e.canvasX;
    this.graph_mouse[1] = e.canvasY;
    if (this.block_click) {
      e.preventDefault();
      return false;
    }
    e.dragging = this.last_mouse_dragging;
    if (this.node_widget) {
      this.processNodeWidgets(
        this.node_widget[0],
        this.graph_mouse,
        e,
        this.node_widget[1]
      );
      this.dirty_canvas = true;
    }
    var node22 = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);
    if (this.dragging_rectangle) {
      this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];
      this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];
      this.dirty_canvas = true;
    } else if (this.selected_group && !this.read_only) {
      if (this.selected_group_resizing) {
        this.selected_group.size = [
          e.canvasX - this.selected_group.pos[0],
          e.canvasY - this.selected_group.pos[1]
        ];
      } else {
        var deltax = delta2[0] / this.ds.scale;
        var deltay = delta2[1] / this.ds.scale;
        this.selected_group.move(deltax, deltay, e.ctrlKey);
        if (this.selected_group._nodes.length) {
          this.dirty_canvas = true;
        }
      }
      this.dirty_bgcanvas = true;
    } else if (this.dragging_canvas) {
      this.ds.offset[0] += delta2[0] / this.ds.scale;
      this.ds.offset[1] += delta2[1] / this.ds.scale;
      this.dirty_canvas = true;
      this.dirty_bgcanvas = true;
    } else if ((this.allow_interaction || node22 && node22.flags.allow_interaction) && !this.read_only) {
      if (this.connecting_links) {
        this.dirty_canvas = true;
      }
      for (var i2 = 0, l = this.graph._nodes.length; i2 < l; ++i2) {
        if (this.graph._nodes[i2].mouseOver && node22 != this.graph._nodes[i2]) {
          this.graph._nodes[i2].mouseOver = false;
          if (this.node_over && this.node_over.onMouseLeave) {
            this.node_over.onMouseLeave(e);
          }
          this.node_over = null;
          this.dirty_canvas = true;
        }
      }
      if (node22) {
        if (node22.redraw_on_mouse)
          this.dirty_canvas = true;
        if (!node22.mouseOver) {
          node22.mouseOver = true;
          this.node_over = node22;
          this.dirty_canvas = true;
          if (node22.onMouseEnter) {
            node22.onMouseEnter(e);
          }
        }
        if (node22.onMouseMove) {
          node22.onMouseMove(e, [e.canvasX - node22.pos[0], e.canvasY - node22.pos[1]], this);
        }
        if (this.connecting_links) {
          const firstLink = this.connecting_links[0];
          if (firstLink.output) {
            var pos2 = this._highlight_input || [0, 0];
            if (this.isOverNodeBox(node22, e.canvasX, e.canvasY)) ;
            else {
              var slot = this.isOverNodeInput(node22, e.canvasX, e.canvasY, pos2);
              if (slot != -1 && node22.inputs[slot] && LiteGraph.isValidConnection(firstLink.output.type, node22.inputs[slot].type)) {
                this._highlight_input = pos2;
                this._highlight_input_slot = node22.inputs[slot];
              } else {
                this._highlight_input = null;
                this._highlight_input_slot = null;
              }
            }
          } else if (firstLink.input) {
            var pos2 = this._highlight_output || [0, 0];
            if (this.isOverNodeBox(node22, e.canvasX, e.canvasY)) ;
            else {
              var slot = this.isOverNodeOutput(node22, e.canvasX, e.canvasY, pos2);
              if (slot != -1 && node22.outputs[slot] && LiteGraph.isValidConnection(firstLink.input.type, node22.outputs[slot].type)) {
                this._highlight_output = pos2;
              } else {
                this._highlight_output = null;
              }
            }
          }
        }
        if (this.canvas) {
          if (node22.inResizeCorner(e.canvasX, e.canvasY)) {
            this.canvas.style.cursor = "se-resize";
          } else {
            this.canvas.style.cursor = "crosshair";
          }
        }
      } else {
        var over_link = null;
        for (var i2 = 0; i2 < this.visible_links.length; ++i2) {
          var link = this.visible_links[i2];
          var center = link._pos;
          if (!center || e.canvasX < center[0] - 4 || e.canvasX > center[0] + 4 || e.canvasY < center[1] - 4 || e.canvasY > center[1] + 4) {
            continue;
          }
          over_link = link;
          break;
        }
        if (over_link != this.over_link_center) {
          this.over_link_center = over_link;
          this.dirty_canvas = true;
        }
        if (this.canvas) {
          this.canvas.style.cursor = "";
        }
      }
      if (this.node_capturing_input && this.node_capturing_input != node22 && this.node_capturing_input.onMouseMove) {
        this.node_capturing_input.onMouseMove(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);
      }
      if (this.node_dragged && !this.live_mode) {
        for (var i2 in this.selected_nodes) {
          var n = this.selected_nodes[i2];
          n.pos[0] += delta2[0] / this.ds.scale;
          n.pos[1] += delta2[1] / this.ds.scale;
          if (!n.is_selected) this.processNodeSelected(n, e);
        }
        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
      }
      if (this.resizing_node && !this.live_mode) {
        var desired_size = [e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1]];
        var min_size = this.resizing_node.computeSize();
        desired_size[0] = Math.max(min_size[0], desired_size[0]);
        desired_size[1] = Math.max(min_size[1], desired_size[1]);
        this.resizing_node.setSize(desired_size);
        this.canvas.style.cursor = "se-resize";
        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
      }
    }
    e.preventDefault();
    return false;
  };
  LGraphCanvas.prototype.processMouseUp = function(e) {
    var is_primary = e.isPrimary === void 0 || e.isPrimary;
    if (!is_primary) {
      return false;
    }
    if (!this.graph)
      return;
    var window2 = this.getCanvasWindow();
    var document2 = window2.document;
    LGraphCanvas.active_canvas = this;
    if (!this.options.skip_events) {
      LiteGraph.pointerListenerRemove(document2, "move", this._mousemove_callback, true);
      LiteGraph.pointerListenerAdd(this.canvas, "move", this._mousemove_callback, true);
      LiteGraph.pointerListenerRemove(document2, "up", this._mouseup_callback, true);
    }
    this.adjustMouseEvent(e);
    var now2 = LiteGraph.getTime();
    e.click_time = now2 - this.last_mouseclick;
    this.last_mouse_dragging = false;
    this.last_click_position = null;
    if (this.block_click) {
      this.block_click = false;
    }
    if (e.which == 1) {
      if (this.node_widget) {
        this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);
      }
      this.node_widget = null;
      if (this.selected_group) {
        var diffx = this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]);
        var diffy = this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]);
        this.selected_group.move(diffx, diffy, e.ctrlKey);
        this.selected_group.pos[0] = Math.round(
          this.selected_group.pos[0]
        );
        this.selected_group.pos[1] = Math.round(
          this.selected_group.pos[1]
        );
        if (this.selected_group._nodes.length) {
          this.dirty_canvas = true;
        }
        this.selected_group = null;
      }
      this.selected_group_resizing = false;
      var node22 = this.graph.getNodeOnPos(
        e.canvasX,
        e.canvasY,
        this.visible_nodes
      );
      if (this.dragging_rectangle) {
        if (this.graph) {
          var nodes = this.graph._nodes;
          var node_bounding = new Float32Array(4);
          var w2 = Math.abs(this.dragging_rectangle[2]);
          var h2 = Math.abs(this.dragging_rectangle[3]);
          var startx = this.dragging_rectangle[2] < 0 ? this.dragging_rectangle[0] - w2 : this.dragging_rectangle[0];
          var starty = this.dragging_rectangle[3] < 0 ? this.dragging_rectangle[1] - h2 : this.dragging_rectangle[1];
          this.dragging_rectangle[0] = startx;
          this.dragging_rectangle[1] = starty;
          this.dragging_rectangle[2] = w2;
          this.dragging_rectangle[3] = h2;
          if (!node22 || w2 > 10 && h2 > 10) {
            var to_select = [];
            for (var i2 = 0; i2 < nodes.length; ++i2) {
              var nodeX = nodes[i2];
              nodeX.getBounding(node_bounding);
              if (!overlapBounding(
                this.dragging_rectangle,
                node_bounding
              )) {
                continue;
              }
              to_select.push(nodeX);
            }
            if (to_select.length) {
              this.selectNodes(to_select, e.shiftKey);
            }
          } else {
            this.selectNodes([node22], e.shiftKey || e.ctrlKey);
          }
        }
        this.dragging_rectangle = null;
      } else if (this.connecting_links) {
        if (node22) {
          for (const link of this.connecting_links) {
            this.dirty_canvas = true;
            this.dirty_bgcanvas = true;
            if (link.output) {
              var slot = this.isOverNodeInput(
                node22,
                e.canvasX,
                e.canvasY
              );
              if (slot != -1) {
                link.node.connect(link.slot, node22, slot);
              } else {
                link.node.connectByType(link.slot, node22, link.output.type);
              }
            } else if (link.input) {
              var slot = this.isOverNodeOutput(
                node22,
                e.canvasX,
                e.canvasY
              );
              if (slot != -1) {
                node22.connect(slot, link.node, link.slot);
              } else {
                link.node.connectByTypeOutput(link.slot, node22, link.input.type);
              }
            }
          }
        } else {
          const firstLink = this.connecting_links[0];
          const linkReleaseContext = firstLink.output ? {
            node_from: firstLink.node,
            slot_from: firstLink.output,
            type_filter_in: firstLink.output.type
          } : {
            node_to: firstLink.node,
            slot_from: firstLink.input,
            type_filter_out: firstLink.input.type
          };
          const linkReleaseContextExtended = {
            links: this.connecting_links
          };
          this.canvas.dispatchEvent(new CustomEvent(
            "litegraph:canvas",
            {
              bubbles: true,
              detail: {
                subType: "empty-release",
                originalEvent: e,
                linkReleaseContext: linkReleaseContextExtended
              }
            }
          ));
          if (LiteGraph.release_link_on_empty_shows_menu) {
            if (e.shiftKey) {
              if (this.allow_searchbox) {
                this.showSearchBox(e, linkReleaseContext);
              }
            } else {
              if (firstLink.output) {
                this.showConnectionMenu({ nodeFrom: firstLink.node, slotFrom: firstLink.output, e });
              } else if (firstLink.input) {
                this.showConnectionMenu({ nodeTo: firstLink.node, slotTo: firstLink.input, e });
              }
            }
          }
        }
        this.connecting_links = null;
      } else if (this.resizing_node) {
        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
        this.graph.afterChange(this.resizing_node);
        this.resizing_node = null;
      } else if (this.node_dragged) {
        var node22 = this.node_dragged;
        if (node22 && e.click_time < 300 && isInsideRectangle(e.canvasX, e.canvasY, node22.pos[0], node22.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT)) {
          node22.collapse();
        }
        this.dirty_canvas = true;
        this.dirty_bgcanvas = true;
        this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);
        this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);
        if (this.graph.config.align_to_grid || this.align_to_grid) {
          this.node_dragged.alignToGrid();
        }
        if (this.onNodeMoved)
          this.onNodeMoved(this.node_dragged);
        this.graph.afterChange(this.node_dragged);
        this.node_dragged = null;
      } else {
        var node22 = this.graph.getNodeOnPos(
          e.canvasX,
          e.canvasY,
          this.visible_nodes
        );
        if (!node22 && e.click_time < 300) {
          this.deselectAllNodes();
        }
        this.dirty_canvas = true;
        this.dragging_canvas = false;
        if (this.node_over && this.node_over.onMouseUp) {
          this.node_over.onMouseUp(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);
        }
        if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {
          this.node_capturing_input.onMouseUp(e, [
            e.canvasX - this.node_capturing_input.pos[0],
            e.canvasY - this.node_capturing_input.pos[1]
          ]);
        }
      }
    } else if (e.which == 2) {
      this.dirty_canvas = true;
      this.dragging_canvas = false;
    } else if (e.which == 3) {
      this.dirty_canvas = true;
      this.dragging_canvas = false;
    }
    if (is_primary) {
      this.pointer_is_down = false;
      this.pointer_is_double = false;
    }
    this.graph.change();
    e.stopPropagation();
    e.preventDefault();
    return false;
  };
  LGraphCanvas.prototype.processMouseWheel = function(e) {
    if (!this.graph || !this.allow_dragcanvas) {
      return;
    }
    var delta2 = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;
    this.adjustMouseEvent(e);
    var x2 = e.clientX;
    var y2 = e.clientY;
    var is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
    if (!is_inside)
      return;
    var scale = this.ds.scale;
    if (delta2 > 0) {
      scale *= 1.1;
    } else if (delta2 < 0) {
      scale *= 1 / 1.1;
    }
    this.ds.changeScale(scale, [e.clientX, e.clientY]);
    this.graph.change();
    e.preventDefault();
    return false;
  };
  LGraphCanvas.prototype.isOverNodeBox = function(node22, canvasx, canvasy) {
    var title_height = LiteGraph.NODE_TITLE_HEIGHT;
    if (isInsideRectangle(
      canvasx,
      canvasy,
      node22.pos[0] + 2,
      node22.pos[1] + 2 - title_height,
      title_height - 4,
      title_height - 4
    )) {
      return true;
    }
    return false;
  };
  LGraphCanvas.prototype.isOverNodeInput = function(node22, canvasx, canvasy, slot_pos) {
    var _a3;
    var _a2, _b;
    if (node22.inputs) {
      for (var i2 = 0, l = node22.inputs.length; i2 < l; ++i2) {
        var input = node22.inputs[i2];
        var link_pos = node22.getConnectionPos(true, i2);
        var is_inside = false;
        if (node22.horizontal) {
          is_inside = isInsideRectangle(
            canvasx,
            canvasy,
            link_pos[0] - 5,
            link_pos[1] - 10,
            10,
            20
          );
        } else {
          const width2 = 20 + (((_a3 = (_a2 = input.label) == null ? void 0 : _a2.length) != null ? _a3 : (_b = input.name) == null ? void 0 : _b.length) || 3) * 7;
          is_inside = isInsideRectangle(
            canvasx,
            canvasy,
            link_pos[0] - 10,
            link_pos[1] - 10,
            width2,
            20
          );
        }
        if (is_inside) {
          if (slot_pos) {
            slot_pos[0] = link_pos[0];
            slot_pos[1] = link_pos[1];
          }
          return i2;
        }
      }
    }
    return -1;
  };
  LGraphCanvas.prototype.isOverNodeOutput = function(node22, canvasx, canvasy, slot_pos) {
    if (node22.outputs) {
      for (var i2 = 0, l = node22.outputs.length; i2 < l; ++i2) {
        node22.outputs[i2];
        var link_pos = node22.getConnectionPos(false, i2);
        var is_inside = false;
        if (node22.horizontal) {
          is_inside = isInsideRectangle(
            canvasx,
            canvasy,
            link_pos[0] - 5,
            link_pos[1] - 10,
            10,
            20
          );
        } else {
          is_inside = isInsideRectangle(
            canvasx,
            canvasy,
            link_pos[0] - 10,
            link_pos[1] - 10,
            40,
            20
          );
        }
        if (is_inside) {
          if (slot_pos) {
            slot_pos[0] = link_pos[0];
            slot_pos[1] = link_pos[1];
          }
          return i2;
        }
      }
    }
    return -1;
  };
  LGraphCanvas.prototype.processKey = function(e) {
    if (!this.graph) {
      return;
    }
    var block_default = false;
    if (e.target.localName == "input") {
      return;
    }
    if (e.type == "keydown") {
      if (e.keyCode == 32) {
        this.dragging_canvas = true;
        block_default = true;
      }
      if (e.keyCode == 27) {
        if (this.node_panel) this.node_panel.close();
        if (this.options_panel) this.options_panel.close();
        block_default = true;
      }
      if (e.keyCode == 65 && e.ctrlKey) {
        this.selectNodes();
        block_default = true;
      }
      if (e.keyCode === 67 && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
        if (this.selected_nodes) {
          this.copyToClipboard();
          block_default = true;
        }
      }
      if (e.keyCode === 86 && (e.metaKey || e.ctrlKey)) {
        this.pasteFromClipboard(e.shiftKey);
      }
      if (e.keyCode == 46 || e.keyCode == 8) {
        if (e.target.localName != "input" && e.target.localName != "textarea") {
          this.deleteSelectedNodes();
          block_default = true;
        }
      }
      if (this.selected_nodes) {
        for (var i2 in this.selected_nodes) {
          if (this.selected_nodes[i2].onKeyDown) {
            this.selected_nodes[i2].onKeyDown(e);
          }
        }
      }
    } else if (e.type == "keyup") {
      if (e.keyCode == 32) {
        this.dragging_canvas = false;
      }
      if (this.selected_nodes) {
        for (var i2 in this.selected_nodes) {
          if (this.selected_nodes[i2].onKeyUp) {
            this.selected_nodes[i2].onKeyUp(e);
          }
        }
      }
    }
    this.graph.change();
    if (block_default) {
      e.preventDefault();
      e.stopImmediatePropagation();
      return false;
    }
  };
  LGraphCanvas.prototype.copyToClipboard = function(nodes) {
    var clipboard_info = {
      nodes: [],
      links: []
    };
    var index2 = 0;
    var selected_nodes_array = [];
    if (!nodes) nodes = this.selected_nodes;
    for (var i2 in nodes) {
      var node22 = nodes[i2];
      if (node22.clonable === false)
        continue;
      node22._relative_id = index2;
      selected_nodes_array.push(node22);
      index2 += 1;
    }
    for (var i2 = 0; i2 < selected_nodes_array.length; ++i2) {
      var node22 = selected_nodes_array[i2];
      var cloned = node22.clone();
      if (!cloned) {
        console.warn("node type not found: " + node22.type);
        continue;
      }
      clipboard_info.nodes.push(cloned.serialize());
      if (node22.inputs && node22.inputs.length) {
        for (var j = 0; j < node22.inputs.length; ++j) {
          var input = node22.inputs[j];
          if (!input || input.link == null) {
            continue;
          }
          var link_info = this.graph.links[input.link];
          if (!link_info) {
            continue;
          }
          var target_node = this.graph.getNodeById(
            link_info.origin_id
          );
          if (!target_node) {
            continue;
          }
          clipboard_info.links.push([
            target_node._relative_id,
            link_info.origin_slot,
            //j,
            node22._relative_id,
            link_info.target_slot,
            target_node.id
          ]);
        }
      }
    }
    localStorage.setItem(
      "litegrapheditor_clipboard",
      JSON.stringify(clipboard_info)
    );
  };
  LGraphCanvas.prototype.pasteFromClipboard = function(isConnectUnselected = false) {
    if (!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {
      return;
    }
    var data28 = localStorage.getItem("litegrapheditor_clipboard");
    if (!data28) {
      return;
    }
    this.graph.beforeChange();
    var clipboard_info = JSON.parse(data28);
    var posMin = false;
    var posMinIndexes = false;
    for (var i2 = 0; i2 < clipboard_info.nodes.length; ++i2) {
      if (posMin) {
        if (posMin[0] > clipboard_info.nodes[i2].pos[0]) {
          posMin[0] = clipboard_info.nodes[i2].pos[0];
          posMinIndexes[0] = i2;
        }
        if (posMin[1] > clipboard_info.nodes[i2].pos[1]) {
          posMin[1] = clipboard_info.nodes[i2].pos[1];
          posMinIndexes[1] = i2;
        }
      } else {
        posMin = [clipboard_info.nodes[i2].pos[0], clipboard_info.nodes[i2].pos[1]];
        posMinIndexes = [i2, i2];
      }
    }
    var nodes = [];
    for (var i2 = 0; i2 < clipboard_info.nodes.length; ++i2) {
      var node_data = clipboard_info.nodes[i2];
      var node22 = LiteGraph.createNode(node_data.type);
      if (node22) {
        node22.configure(node_data);
        node22.pos[0] += this.graph_mouse[0] - posMin[0];
        node22.pos[1] += this.graph_mouse[1] - posMin[1];
        this.graph.add(node22, { doProcessChange: false });
        nodes.push(node22);
      }
    }
    for (var i2 = 0; i2 < clipboard_info.links.length; ++i2) {
      var link_info = clipboard_info.links[i2];
      var origin_node = void 0;
      var origin_node_relative_id = link_info[0];
      if (origin_node_relative_id != null) {
        origin_node = nodes[origin_node_relative_id];
      } else if (LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {
        var origin_node_id = link_info[4];
        if (origin_node_id) {
          origin_node = this.graph.getNodeById(origin_node_id);
        }
      }
      var target_node = nodes[link_info[2]];
      if (origin_node && target_node)
        origin_node.connect(link_info[1], target_node, link_info[3]);
      else
        console.warn("Warning, nodes missing on pasting");
    }
    this.selectNodes(nodes);
    this.graph.afterChange();
  };
  LGraphCanvas.prototype.processDrop = function(e) {
    e.preventDefault();
    this.adjustMouseEvent(e);
    var x2 = e.clientX;
    var y2 = e.clientY;
    var is_inside = !this.viewport || this.viewport && x2 >= this.viewport[0] && x2 < this.viewport[0] + this.viewport[2] && y2 >= this.viewport[1] && y2 < this.viewport[1] + this.viewport[3];
    if (!is_inside) {
      return;
    }
    var pos2 = [e.canvasX, e.canvasY];
    var node22 = this.graph ? this.graph.getNodeOnPos(pos2[0], pos2[1]) : null;
    if (!node22) {
      var r = null;
      if (this.onDropItem) {
        r = this.onDropItem(event);
      }
      if (!r) {
        this.checkDropItem(e);
      }
      return;
    }
    if (node22.onDropFile || node22.onDropData) {
      var files = e.dataTransfer.files;
      if (files && files.length) {
        for (var i2 = 0; i2 < files.length; i2++) {
          var file = e.dataTransfer.files[0];
          var filename = file.name;
          LGraphCanvas.getFileExtension(filename);
          if (node22.onDropFile) {
            node22.onDropFile(file);
          }
          if (node22.onDropData) {
            var reader = new FileReader();
            reader.onload = function(event2) {
              var data28 = event2.target.result;
              node22.onDropData(data28, filename, file);
            };
            var type = file.type.split("/")[0];
            if (type == "text" || type == "") {
              reader.readAsText(file);
            } else if (type == "image") {
              reader.readAsDataURL(file);
            } else {
              reader.readAsArrayBuffer(file);
            }
          }
        }
      }
    }
    if (node22.onDropItem) {
      if (node22.onDropItem(event)) {
        return true;
      }
    }
    if (this.onDropItem) {
      return this.onDropItem(event);
    }
    return false;
  };
  LGraphCanvas.prototype.checkDropItem = function(e) {
    if (e.dataTransfer.files.length) {
      var file = e.dataTransfer.files[0];
      var ext = LGraphCanvas.getFileExtension(file.name).toLowerCase();
      var nodetype = LiteGraph.node_types_by_file_extension[ext];
      if (nodetype) {
        this.graph.beforeChange();
        var node22 = LiteGraph.createNode(nodetype.type);
        node22.pos = [e.canvasX, e.canvasY];
        this.graph.add(node22);
        if (node22.onDropFile) {
          node22.onDropFile(file);
        }
        this.graph.afterChange();
      }
    }
  };
  LGraphCanvas.prototype.processNodeDblClicked = function(n) {
    if (this.onShowNodePanel) {
      this.onShowNodePanel(n);
    }
    if (this.onNodeDblClicked) {
      this.onNodeDblClicked(n);
    }
    this.setDirty(true);
  };
  LGraphCanvas.prototype.processNodeSelected = function(node22, e) {
    this.selectNode(node22, e && (e.shiftKey || e.ctrlKey || this.multi_select));
    if (this.onNodeSelected) {
      this.onNodeSelected(node22);
    }
  };
  LGraphCanvas.prototype.selectNode = function(node22, add_to_current_selection) {
    if (node22 == null) {
      this.deselectAllNodes();
    } else {
      this.selectNodes([node22], add_to_current_selection);
    }
  };
  LGraphCanvas.prototype.selectNodes = function(nodes, add_to_current_selection) {
    if (!add_to_current_selection) {
      this.deselectAllNodes();
    }
    nodes = nodes || this.graph._nodes;
    if (typeof nodes == "string") nodes = [nodes];
    for (var i2 in nodes) {
      var node22 = nodes[i2];
      if (node22.is_selected) {
        this.deselectNode(node22);
        continue;
      }
      if (!node22.is_selected && node22.onSelected) {
        node22.onSelected();
      }
      node22.is_selected = true;
      this.selected_nodes[node22.id] = node22;
      if (node22.inputs) {
        for (var j = 0; j < node22.inputs.length; ++j) {
          this.highlighted_links[node22.inputs[j].link] = true;
        }
      }
      if (node22.outputs) {
        for (var j = 0; j < node22.outputs.length; ++j) {
          var out = node22.outputs[j];
          if (out.links) {
            for (var k = 0; k < out.links.length; ++k) {
              this.highlighted_links[out.links[k]] = true;
            }
          }
        }
      }
    }
    if (this.onSelectionChange)
      this.onSelectionChange(this.selected_nodes);
    this.setDirty(true);
  };
  LGraphCanvas.prototype.deselectNode = function(node22) {
    if (!node22.is_selected) {
      return;
    }
    if (node22.onDeselected) {
      node22.onDeselected();
    }
    node22.is_selected = false;
    delete this.selected_nodes[node22.id];
    if (this.onNodeDeselected) {
      this.onNodeDeselected(node22);
    }
    if (node22.inputs) {
      for (var i2 = 0; i2 < node22.inputs.length; ++i2) {
        delete this.highlighted_links[node22.inputs[i2].link];
      }
    }
    if (node22.outputs) {
      for (var i2 = 0; i2 < node22.outputs.length; ++i2) {
        var out = node22.outputs[i2];
        if (out.links) {
          for (var j = 0; j < out.links.length; ++j) {
            delete this.highlighted_links[out.links[j]];
          }
        }
      }
    }
  };
  LGraphCanvas.prototype.deselectAllNodes = function() {
    if (!this.graph) {
      return;
    }
    var nodes = this.graph._nodes;
    for (var i2 = 0, l = nodes.length; i2 < l; ++i2) {
      var node22 = nodes[i2];
      if (!node22.is_selected) {
        continue;
      }
      if (node22.onDeselected) {
        node22.onDeselected();
      }
      node22.is_selected = false;
      if (this.onNodeDeselected) {
        this.onNodeDeselected(node22);
      }
    }
    this.selected_nodes = {};
    this.current_node = null;
    this.highlighted_links = {};
    if (this.onSelectionChange)
      this.onSelectionChange(this.selected_nodes);
    this.setDirty(true);
  };
  LGraphCanvas.prototype.deleteSelectedNodes = function() {
    this.graph.beforeChange();
    for (var i2 in this.selected_nodes) {
      var node22 = this.selected_nodes[i2];
      if (node22.block_delete)
        continue;
      if (node22.inputs && node22.inputs.length && node22.outputs && node22.outputs.length && LiteGraph.isValidConnection(node22.inputs[0].type, node22.outputs[0].type) && node22.inputs[0].link && node22.outputs[0].links && node22.outputs[0].links.length) {
        var input_link = node22.graph.links[node22.inputs[0].link];
        var output_link = node22.graph.links[node22.outputs[0].links[0]];
        var input_node = node22.getInputNode(0);
        var output_node = node22.getOutputNodes(0)[0];
        if (input_node && output_node)
          input_node.connect(input_link.origin_slot, output_node, output_link.target_slot);
      }
      this.graph.remove(node22);
      if (this.onNodeDeselected) {
        this.onNodeDeselected(node22);
      }
    }
    this.selected_nodes = {};
    this.current_node = null;
    this.highlighted_links = {};
    this.setDirty(true);
    this.graph.afterChange();
  };
  LGraphCanvas.prototype.centerOnNode = function(node22) {
    const dpi = (window == null ? void 0 : window.devicePixelRatio) || 1;
    this.ds.offset[0] = -node22.pos[0] - node22.size[0] * 0.5 + this.canvas.width * 0.5 / (this.ds.scale * dpi);
    this.ds.offset[1] = -node22.pos[1] - node22.size[1] * 0.5 + this.canvas.height * 0.5 / (this.ds.scale * dpi);
    this.setDirty(true, true);
  };
  LGraphCanvas.prototype.adjustMouseEvent = function(e) {
    var clientX_rel = 0;
    var clientY_rel = 0;
    if (this.canvas) {
      var b = this.canvas.getBoundingClientRect();
      clientX_rel = e.clientX - b.left;
      clientY_rel = e.clientY - b.top;
    } else {
      clientX_rel = e.clientX;
      clientY_rel = e.clientY;
    }
    if (e.deltaX === void 0)
      e.deltaX = clientX_rel - this.last_mouse_position[0];
    if (e.deltaY === void 0)
      e.deltaY = clientY_rel - this.last_mouse_position[1];
    this.last_mouse_position[0] = clientX_rel;
    this.last_mouse_position[1] = clientY_rel;
    e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0];
    e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1];
  };
  LGraphCanvas.prototype.setZoom = function(value3, zooming_center) {
    this.ds.changeScale(value3, zooming_center);
    this.dirty_canvas = true;
    this.dirty_bgcanvas = true;
  };
  LGraphCanvas.prototype.convertOffsetToCanvas = function(pos2, out) {
    return this.ds.convertOffsetToCanvas(pos2, out);
  };
  LGraphCanvas.prototype.convertCanvasToOffset = function(pos2, out) {
    return this.ds.convertCanvasToOffset(pos2, out);
  };
  LGraphCanvas.prototype.convertEventToCanvasOffset = function(e) {
    var rect = this.canvas.getBoundingClientRect();
    return this.convertCanvasToOffset([
      e.clientX - rect.left,
      e.clientY - rect.top
    ]);
  };
  LGraphCanvas.prototype.bringToFront = function(node22) {
    var i2 = this.graph._nodes.indexOf(node22);
    if (i2 == -1) {
      return;
    }
    this.graph._nodes.splice(i2, 1);
    this.graph._nodes.push(node22);
  };
  LGraphCanvas.prototype.sendToBack = function(node22) {
    var i2 = this.graph._nodes.indexOf(node22);
    if (i2 == -1) {
      return;
    }
    this.graph._nodes.splice(i2, 1);
    this.graph._nodes.unshift(node22);
  };
  var temp = new Float32Array(4);
  LGraphCanvas.prototype.computeVisibleNodes = function(nodes, out) {
    var visible_nodes = out || [];
    visible_nodes.length = 0;
    nodes = nodes || this.graph._nodes;
    for (var i2 = 0, l = nodes.length; i2 < l; ++i2) {
      var n = nodes[i2];
      if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {
        continue;
      }
      if (!overlapBounding(this.visible_area, n.getBounding(temp, true))) {
        continue;
      }
      visible_nodes.push(n);
    }
    return visible_nodes;
  };
  LGraphCanvas.prototype.draw = function(force_canvas, force_bgcanvas) {
    if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {
      return;
    }
    var now2 = LiteGraph.getTime();
    this.render_time = (now2 - this.last_draw_time) * 1e-3;
    this.last_draw_time = now2;
    if (this.graph) {
      this.ds.computeVisibleArea(this.viewport);
    }
    if (this.dirty_bgcanvas || force_bgcanvas || this.always_render_background || this.graph && this.graph._last_trigger_time && now2 - this.graph._last_trigger_time < 1e3) {
      this.drawBackCanvas();
    }
    if (this.dirty_canvas || force_canvas) {
      this.drawFrontCanvas();
    }
    this.fps = this.render_time ? 1 / this.render_time : 0;
    this.frame += 1;
  };
  LGraphCanvas.prototype.drawFrontCanvas = function() {
    this.dirty_canvas = false;
    if (!this.ctx) {
      this.ctx = this.bgcanvas.getContext("2d");
    }
    var ctx = this.ctx;
    if (!ctx) {
      return;
    }
    var canvas = this.canvas;
    if (ctx.start2D && !this.viewport) {
      ctx.start2D();
      ctx.restore();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    var area = this.viewport || this.dirty_area;
    if (area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area[0], area[1], area[2], area[3]);
      ctx.clip();
    }
    if (this.clear_background) {
      if (area)
        ctx.clearRect(area[0], area[1], area[2], area[3]);
      else
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    if (this.bgcanvas == this.canvas) {
      this.drawBackCanvas();
    } else {
      ctx.drawImage(this.bgcanvas, 0, 0);
    }
    if (this.onRender) {
      this.onRender(canvas, ctx);
    }
    if (this.show_info) {
      this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0);
    }
    if (this.graph) {
      ctx.save();
      this.ds.toCanvasContext(ctx);
      var visible_nodes = this.computeVisibleNodes(
        null,
        this.visible_nodes
      );
      for (var i2 = 0; i2 < visible_nodes.length; ++i2) {
        var node22 = visible_nodes[i2];
        ctx.save();
        ctx.translate(node22.pos[0], node22.pos[1]);
        this.drawNode(node22, ctx);
        ctx.restore();
      }
      if (this.render_execution_order) {
        this.drawExecutionOrder(ctx);
      }
      if (this.graph.config.links_ontop) {
        if (!this.live_mode) {
          this.drawConnections(ctx);
        }
      }
      if (this.connecting_links) {
        for (const link of this.connecting_links) {
          ctx.lineWidth = this.connections_width;
          var link_color = null;
          var connInOrOut = link.output || link.input;
          var connType = connInOrOut.type;
          var connDir = connInOrOut.dir;
          if (connDir == null) {
            if (link.output)
              connDir = link.node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT;
            else
              connDir = link.node.horizontal ? LiteGraph.UP : LiteGraph.LEFT;
          }
          var connShape = connInOrOut.shape;
          switch (connType) {
            case LiteGraph.EVENT:
              link_color = LiteGraph.EVENT_LINK_COLOR;
              break;
            default:
              link_color = LiteGraph.CONNECTING_LINK_COLOR;
          }
          this.renderLink(
            ctx,
            link.pos,
            [this.graph_mouse[0], this.graph_mouse[1]],
            null,
            false,
            null,
            link_color,
            connDir,
            LiteGraph.CENTER
          );
          ctx.beginPath();
          if (connType === LiteGraph.EVENT || connShape === LiteGraph.BOX_SHAPE) {
            ctx.rect(
              link.pos[0] - 6 + 0.5,
              link.pos[1] - 5 + 0.5,
              14,
              10
            );
            ctx.fill();
            ctx.beginPath();
            ctx.rect(
              this.graph_mouse[0] - 6 + 0.5,
              this.graph_mouse[1] - 5 + 0.5,
              14,
              10
            );
          } else if (connShape === LiteGraph.ARROW_SHAPE) {
            ctx.moveTo(link.pos[0] + 8, link.pos[1] + 0.5);
            ctx.lineTo(link.pos[0] - 4, link.pos[1] + 6 + 0.5);
            ctx.lineTo(link.pos[0] - 4, link.pos[1] - 6 + 0.5);
            ctx.closePath();
          } else {
            ctx.arc(
              link.pos[0],
              link.pos[1],
              4,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.beginPath();
            ctx.arc(
              this.graph_mouse[0],
              this.graph_mouse[1],
              4,
              0,
              Math.PI * 2
            );
          }
          ctx.fill();
          ctx.fillStyle = "#ffcc00";
          if (this._highlight_input) {
            ctx.beginPath();
            var shape = this._highlight_input_slot.shape;
            if (shape === LiteGraph.ARROW_SHAPE) {
              ctx.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5);
              ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5);
              ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5);
              ctx.closePath();
            } else {
              ctx.arc(
                this._highlight_input[0],
                this._highlight_input[1],
                6,
                0,
                Math.PI * 2
              );
            }
            ctx.fill();
          }
          if (this._highlight_output) {
            ctx.beginPath();
            if (shape === LiteGraph.ARROW_SHAPE) {
              ctx.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + 0.5);
              ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + 0.5);
              ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + 0.5);
              ctx.closePath();
            } else {
              ctx.arc(
                this._highlight_output[0],
                this._highlight_output[1],
                6,
                0,
                Math.PI * 2
              );
            }
            ctx.fill();
          }
        }
      }
      if (this.dragging_rectangle) {
        ctx.strokeStyle = "#FFF";
        ctx.strokeRect(
          this.dragging_rectangle[0],
          this.dragging_rectangle[1],
          this.dragging_rectangle[2],
          this.dragging_rectangle[3]
        );
      }
      if (this.over_link_center && this.render_link_tooltip)
        this.drawLinkTooltip(ctx, this.over_link_center);
      else if (this.onDrawLinkTooltip)
        this.onDrawLinkTooltip(ctx, null);
      if (this.onDrawForeground) {
        this.onDrawForeground(ctx, this.visible_rect);
      }
      ctx.restore();
    }
    if (this._graph_stack && this._graph_stack.length) {
      this.drawSubgraphPanel(ctx);
    }
    if (this.onDrawOverlay) {
      this.onDrawOverlay(ctx);
    }
    if (area) {
      ctx.restore();
    }
    if (ctx.finish2D) {
      ctx.finish2D();
    }
  };
  LGraphCanvas.prototype.drawSubgraphPanel = function(ctx) {
    var subgraph = this.graph;
    var subnode = subgraph._subgraph_node;
    if (!subnode) {
      console.warn("subgraph without subnode");
      return;
    }
    this.drawSubgraphPanelLeft(subgraph, subnode, ctx);
    this.drawSubgraphPanelRight(subgraph, subnode, ctx);
  };
  LGraphCanvas.prototype.drawSubgraphPanelLeft = function(subgraph, subnode, ctx) {
    var num = subnode.inputs ? subnode.inputs.length : 0;
    var w2 = 200;
    var h2 = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);
    ctx.fillStyle = "#111";
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.roundRect(10, 10, w2, (num + 1) * h2 + 50, [8]);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#888";
    ctx.font = "14px Arial";
    ctx.textAlign = "left";
    ctx.fillText("Graph Inputs", 20, 34);
    if (this.drawButton(w2 - 20, 20, 20, 20, "X", "#151515")) {
      this.closeSubgraph();
      return;
    }
    var y2 = 50;
    ctx.font = "14px Arial";
    if (subnode.inputs)
      for (var i2 = 0; i2 < subnode.inputs.length; ++i2) {
        var input = subnode.inputs[i2];
        if (input.not_subgraph_input)
          continue;
        if (this.drawButton(20, y2 + 2, w2 - 20, h2 - 2)) {
          var type = subnode.constructor.input_node_type || "graph/input";
          this.graph.beforeChange();
          var newnode = LiteGraph.createNode(type);
          if (newnode) {
            subgraph.add(newnode);
            this.block_click = false;
            this.last_click_position = null;
            this.selectNodes([newnode]);
            this.node_dragged = newnode;
            this.dragging_canvas = false;
            newnode.setProperty("name", input.name);
            newnode.setProperty("type", input.type);
            this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
            this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
            this.graph.afterChange();
          } else
            console.error("graph input node not found:", type);
        }
        ctx.fillStyle = "#9C9";
        ctx.beginPath();
        ctx.arc(w2 - 16, y2 + h2 * 0.5, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = "#AAA";
        ctx.fillText(input.name, 30, y2 + h2 * 0.75);
        ctx.fillStyle = "#777";
        ctx.fillText(input.type, 130, y2 + h2 * 0.75);
        y2 += h2;
      }
    if (this.drawButton(20, y2 + 2, w2 - 20, h2 - 2, "+", "#151515", "#222")) {
      this.showSubgraphPropertiesDialog(subnode);
    }
  };
  LGraphCanvas.prototype.drawSubgraphPanelRight = function(subgraph, subnode, ctx) {
    var num = subnode.outputs ? subnode.outputs.length : 0;
    var canvas_w = this.bgcanvas.width;
    var w2 = 200;
    var h2 = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);
    ctx.fillStyle = "#111";
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.roundRect(canvas_w - w2 - 10, 10, w2, (num + 1) * h2 + 50, [8]);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#888";
    ctx.font = "14px Arial";
    ctx.textAlign = "left";
    var title_text = "Graph Outputs";
    var tw = ctx.measureText(title_text).width;
    ctx.fillText(title_text, canvas_w - tw - 20, 34);
    if (this.drawButton(canvas_w - w2, 20, 20, 20, "X", "#151515")) {
      this.closeSubgraph();
      return;
    }
    var y2 = 50;
    ctx.font = "14px Arial";
    if (subnode.outputs)
      for (var i2 = 0; i2 < subnode.outputs.length; ++i2) {
        var output = subnode.outputs[i2];
        if (output.not_subgraph_input)
          continue;
        if (this.drawButton(canvas_w - w2, y2 + 2, w2 - 20, h2 - 2)) {
          var type = subnode.constructor.output_node_type || "graph/output";
          this.graph.beforeChange();
          var newnode = LiteGraph.createNode(type);
          if (newnode) {
            subgraph.add(newnode);
            this.block_click = false;
            this.last_click_position = null;
            this.selectNodes([newnode]);
            this.node_dragged = newnode;
            this.dragging_canvas = false;
            newnode.setProperty("name", output.name);
            newnode.setProperty("type", output.type);
            this.node_dragged.pos[0] = this.graph_mouse[0] - 5;
            this.node_dragged.pos[1] = this.graph_mouse[1] - 5;
            this.graph.afterChange();
          } else
            console.error("graph input node not found:", type);
        }
        ctx.fillStyle = "#9C9";
        ctx.beginPath();
        ctx.arc(canvas_w - w2 + 16, y2 + h2 * 0.5, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = "#AAA";
        ctx.fillText(output.name, canvas_w - w2 + 30, y2 + h2 * 0.75);
        ctx.fillStyle = "#777";
        ctx.fillText(output.type, canvas_w - w2 + 130, y2 + h2 * 0.75);
        y2 += h2;
      }
    if (this.drawButton(canvas_w - w2, y2 + 2, w2 - 20, h2 - 2, "+", "#151515", "#222")) {
      this.showSubgraphPropertiesDialogRight(subnode);
    }
  };
  LGraphCanvas.prototype.drawButton = function(x2, y2, w2, h2, text2, bgcolor, hovercolor, textcolor) {
    var ctx = this.ctx;
    bgcolor = bgcolor || LiteGraph.NODE_DEFAULT_COLOR;
    hovercolor = hovercolor || "#555";
    textcolor = textcolor || LiteGraph.NODE_TEXT_COLOR;
    var pos2 = this.ds.convertOffsetToCanvas(this.graph_mouse);
    var hover = LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
    pos2 = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null;
    if (pos2) {
      var rect = this.canvas.getBoundingClientRect();
      pos2[0] -= rect.left;
      pos2[1] -= rect.top;
    }
    var clicked = pos2 && LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
    ctx.fillStyle = hover ? hovercolor : bgcolor;
    if (clicked)
      ctx.fillStyle = "#AAA";
    ctx.beginPath();
    ctx.roundRect(x2, y2, w2, h2, [4]);
    ctx.fill();
    if (text2 != null) {
      if (text2.constructor == String) {
        ctx.fillStyle = textcolor;
        ctx.textAlign = "center";
        ctx.font = (h2 * 0.65 | 0) + "px Arial";
        ctx.fillText(text2, x2 + w2 * 0.5, y2 + h2 * 0.75);
        ctx.textAlign = "left";
      }
    }
    var was_clicked = clicked && !this.block_click;
    if (clicked)
      this.blockClick();
    return was_clicked;
  };
  LGraphCanvas.prototype.isAreaClicked = function(x2, y2, w2, h2, hold_click) {
    var pos2 = this.mouse;
    LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
    pos2 = this.last_click_position;
    var clicked = pos2 && LiteGraph.isInsideRectangle(pos2[0], pos2[1], x2, y2, w2, h2);
    var was_clicked = clicked && !this.block_click;
    if (clicked && hold_click)
      this.blockClick();
    return was_clicked;
  };
  LGraphCanvas.prototype.renderInfo = function(ctx, x2, y2) {
    x2 = x2 || 10;
    y2 = y2 || this.canvas.offsetHeight - 80;
    ctx.save();
    ctx.translate(x2, y2);
    ctx.font = "10px Arial";
    ctx.fillStyle = "#888";
    ctx.textAlign = "left";
    if (this.graph) {
      ctx.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13 * 1);
      ctx.fillText("I: " + this.graph.iteration, 5, 13 * 2);
      ctx.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 13 * 3);
      ctx.fillText("V: " + this.graph._version, 5, 13 * 4);
      ctx.fillText("FPS:" + this.fps.toFixed(2), 5, 13 * 5);
    } else {
      ctx.fillText("No graph selected", 5, 13 * 1);
    }
    ctx.restore();
  };
  LGraphCanvas.prototype.drawBackCanvas = function() {
    var canvas = this.bgcanvas;
    if (canvas.width != this.canvas.width || canvas.height != this.canvas.height) {
      canvas.width = this.canvas.width;
      canvas.height = this.canvas.height;
    }
    if (!this.bgctx) {
      this.bgctx = this.bgcanvas.getContext("2d");
    }
    var ctx = this.bgctx;
    if (ctx.start) {
      ctx.start();
    }
    var viewport = this.viewport || [0, 0, ctx.canvas.width, ctx.canvas.height];
    if (this.clear_background) {
      ctx.clearRect(viewport[0], viewport[1], viewport[2], viewport[3]);
    }
    if (this._graph_stack && this._graph_stack.length) {
      ctx.save();
      this._graph_stack[this._graph_stack.length - 1];
      var subgraph_node = this.graph._subgraph_node;
      ctx.strokeStyle = subgraph_node.bgcolor;
      ctx.lineWidth = 10;
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      ctx.lineWidth = 1;
      ctx.font = "40px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = subgraph_node.bgcolor || "#AAA";
      var title = "";
      for (var i2 = 1; i2 < this._graph_stack.length; ++i2) {
        title += this._graph_stack[i2]._subgraph_node.getTitle() + " >> ";
      }
      ctx.fillText(
        title + subgraph_node.getTitle(),
        canvas.width * 0.5,
        40
      );
      ctx.restore();
    }
    var bg_already_painted = false;
    if (this.onRenderBackground) {
      bg_already_painted = this.onRenderBackground(canvas, ctx);
    }
    if (!this.viewport) {
      ctx.restore();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    this.visible_links.length = 0;
    if (this.graph) {
      ctx.save();
      this.ds.toCanvasContext(ctx);
      if (this.ds.scale < 1.5 && !bg_already_painted && this.clear_background_color) {
        ctx.fillStyle = this.clear_background_color;
        ctx.fillRect(
          this.visible_area[0],
          this.visible_area[1],
          this.visible_area[2],
          this.visible_area[3]
        );
      }
      if (this.background_image && this.ds.scale > 0.5 && !bg_already_painted) {
        if (this.zoom_modify_alpha) {
          ctx.globalAlpha = (1 - 0.5 / this.ds.scale) * this.editor_alpha;
        } else {
          ctx.globalAlpha = this.editor_alpha;
        }
        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = false;
        if (!this._bg_img || this._bg_img.name != this.background_image) {
          this._bg_img = new Image();
          this._bg_img.name = this.background_image;
          this._bg_img.src = this.background_image;
          var that2 = this;
          this._bg_img.onload = function() {
            that2.draw(true, true);
          };
        }
        var pattern = null;
        if (this._pattern == null && this._bg_img.width > 0) {
          pattern = ctx.createPattern(this._bg_img, "repeat");
          this._pattern_img = this._bg_img;
          this._pattern = pattern;
        } else {
          pattern = this._pattern;
        }
        if (pattern) {
          ctx.fillStyle = pattern;
          ctx.fillRect(
            this.visible_area[0],
            this.visible_area[1],
            this.visible_area[2],
            this.visible_area[3]
          );
          ctx.fillStyle = "transparent";
        }
        ctx.globalAlpha = 1;
        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = true;
      }
      if (this.graph._groups.length && !this.live_mode) {
        this.drawGroups(canvas, ctx);
      }
      if (this.onDrawBackground) {
        this.onDrawBackground(ctx, this.visible_area);
      }
      if (this.onBackgroundRender) {
        console.error(
          "WARNING! onBackgroundRender deprecated, now is named onDrawBackground "
        );
        this.onBackgroundRender = null;
      }
      if (this.render_canvas_border) {
        ctx.strokeStyle = "#235";
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
      }
      if (this.render_connections_shadows) {
        ctx.shadowColor = "#000";
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 6;
      } else {
        ctx.shadowColor = "rgba(0,0,0,0)";
      }
      if (!this.live_mode) {
        this.drawConnections(ctx);
      }
      ctx.shadowColor = "rgba(0,0,0,0)";
      ctx.restore();
    }
    if (ctx.finish) {
      ctx.finish();
    }
    this.dirty_bgcanvas = false;
    this.dirty_canvas = true;
  };
  var temp_vec2 = new Float32Array(2);
  LGraphCanvas.prototype.drawNode = function(node22, ctx) {
    this.current_node = node22;
    var color = node22.color || node22.constructor.color || LiteGraph.NODE_DEFAULT_COLOR;
    var bgcolor = node22.bgcolor || node22.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;
    if (node22.mouseOver) ;
    var low_quality = this.ds.scale < 0.6;
    if (this.live_mode) {
      if (!node22.flags.collapsed) {
        ctx.shadowColor = "transparent";
        if (node22.onDrawForeground) {
          node22.onDrawForeground(ctx, this, this.canvas);
        }
      }
      return;
    }
    var editor_alpha = this.editor_alpha;
    ctx.globalAlpha = editor_alpha;
    if (this.render_shadows && !low_quality) {
      ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
      ctx.shadowOffsetX = 2 * this.ds.scale;
      ctx.shadowOffsetY = 2 * this.ds.scale;
      ctx.shadowBlur = 3 * this.ds.scale;
    } else {
      ctx.shadowColor = "transparent";
    }
    if (node22.flags.collapsed && node22.onDrawCollapsed && node22.onDrawCollapsed(ctx, this) == true) {
      return;
    }
    var shape = node22._shape || LiteGraph.BOX_SHAPE;
    var size2 = temp_vec2;
    temp_vec2.set(node22.size);
    var horizontal3 = node22.horizontal;
    if (node22.flags.collapsed) {
      ctx.font = this.inner_text_font;
      var title = node22.getTitle ? node22.getTitle() : node22.title;
      if (title != null) {
        node22._collapsed_width = Math.min(
          node22.size[0],
          ctx.measureText(title).width + LiteGraph.NODE_TITLE_HEIGHT * 2
        );
        size2[0] = node22._collapsed_width;
        size2[1] = 0;
      }
    }
    if (node22.clip_area) {
      ctx.save();
      ctx.beginPath();
      if (shape == LiteGraph.BOX_SHAPE) {
        ctx.rect(0, 0, size2[0], size2[1]);
      } else if (shape == LiteGraph.ROUND_SHAPE) {
        ctx.roundRect(0, 0, size2[0], size2[1], [10]);
      } else if (shape == LiteGraph.CIRCLE_SHAPE) {
        ctx.arc(
          size2[0] * 0.5,
          size2[1] * 0.5,
          size2[0] * 0.5,
          0,
          Math.PI * 2
        );
      }
      ctx.clip();
    }
    if (node22.has_errors) {
      bgcolor = "red";
    }
    this.drawNodeShape(
      node22,
      ctx,
      size2,
      color,
      bgcolor,
      node22.is_selected,
      node22.mouseOver
    );
    ctx.shadowColor = "transparent";
    if (node22.onDrawForeground) {
      node22.onDrawForeground(ctx, this, this.canvas);
    }
    ctx.textAlign = horizontal3 ? "center" : "left";
    ctx.font = this.inner_text_font;
    var render_text = !low_quality;
    var out_slot = this.connecting_links ? this.connecting_links[0].output : null;
    var in_slot = this.connecting_links ? this.connecting_links[0].input : null;
    ctx.lineWidth = 1;
    var max_y = 0;
    var slot_pos = new Float32Array(2);
    if (!node22.flags.collapsed) {
      if (node22.inputs) {
        for (var i2 = 0; i2 < node22.inputs.length; i2++) {
          var slot = node22.inputs[i2];
          var slot_type = slot.type;
          var slot_shape = slot.shape;
          ctx.globalAlpha = editor_alpha;
          if (out_slot && !LiteGraph.isValidConnection(slot.type, out_slot.type)) {
            ctx.globalAlpha = 0.4 * editor_alpha;
          }
          ctx.fillStyle = slot.link != null ? slot.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_on : slot.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.input_off;
          var pos2 = node22.getConnectionPos(true, i2, slot_pos);
          pos2[0] -= node22.pos[0];
          pos2[1] -= node22.pos[1];
          if (max_y < pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
            max_y = pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
          }
          ctx.beginPath();
          if (slot_type == "array") {
            slot_shape = LiteGraph.GRID_SHAPE;
          }
          var doStroke = true;
          if (slot.type === LiteGraph.EVENT || slot.shape === LiteGraph.BOX_SHAPE) {
            if (horizontal3) {
              ctx.rect(
                pos2[0] - 5 + 0.5,
                pos2[1] - 8 + 0.5,
                10,
                14
              );
            } else {
              ctx.rect(
                pos2[0] - 6 + 0.5,
                pos2[1] - 5 + 0.5,
                14,
                10
              );
            }
          } else if (slot_shape === LiteGraph.ARROW_SHAPE) {
            ctx.moveTo(pos2[0] + 8, pos2[1] + 0.5);
            ctx.lineTo(pos2[0] - 4, pos2[1] + 6 + 0.5);
            ctx.lineTo(pos2[0] - 4, pos2[1] - 6 + 0.5);
            ctx.closePath();
          } else if (slot_shape === LiteGraph.GRID_SHAPE) {
            ctx.rect(pos2[0] - 4, pos2[1] - 4, 2, 2);
            ctx.rect(pos2[0] - 1, pos2[1] - 4, 2, 2);
            ctx.rect(pos2[0] + 2, pos2[1] - 4, 2, 2);
            ctx.rect(pos2[0] - 4, pos2[1] - 1, 2, 2);
            ctx.rect(pos2[0] - 1, pos2[1] - 1, 2, 2);
            ctx.rect(pos2[0] + 2, pos2[1] - 1, 2, 2);
            ctx.rect(pos2[0] - 4, pos2[1] + 2, 2, 2);
            ctx.rect(pos2[0] - 1, pos2[1] + 2, 2, 2);
            ctx.rect(pos2[0] + 2, pos2[1] + 2, 2, 2);
            doStroke = false;
          } else {
            if (low_quality)
              ctx.rect(pos2[0] - 4, pos2[1] - 4, 8, 8);
            else
              ctx.arc(pos2[0], pos2[1], 4, 0, Math.PI * 2);
          }
          ctx.fill();
          if (render_text) {
            var text2 = slot.label != null ? slot.label : slot.name;
            if (text2) {
              ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
              if (horizontal3 || slot.dir == LiteGraph.UP) {
                ctx.fillText(text2, pos2[0], pos2[1] - 10);
              } else {
                ctx.fillText(text2, pos2[0] + 10, pos2[1] + 5);
              }
            }
          }
        }
      }
      ctx.textAlign = horizontal3 ? "center" : "right";
      ctx.strokeStyle = "black";
      if (node22.outputs) {
        for (var i2 = 0; i2 < node22.outputs.length; i2++) {
          var slot = node22.outputs[i2];
          var slot_type = slot.type;
          var slot_shape = slot.shape;
          if (in_slot && !LiteGraph.isValidConnection(slot_type, in_slot.type)) {
            ctx.globalAlpha = 0.4 * editor_alpha;
          }
          var pos2 = node22.getConnectionPos(false, i2, slot_pos);
          pos2[0] -= node22.pos[0];
          pos2[1] -= node22.pos[1];
          if (max_y < pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {
            max_y = pos2[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;
          }
          ctx.fillStyle = slot.links && slot.links.length ? slot.color_on || this.default_connection_color_byType[slot_type] || this.default_connection_color.output_on : slot.color_off || this.default_connection_color_byTypeOff[slot_type] || this.default_connection_color_byType[slot_type] || this.default_connection_color.output_off;
          ctx.beginPath();
          if (slot_type == "array") {
            slot_shape = LiteGraph.GRID_SHAPE;
          }
          var doStroke = true;
          if (slot_type === LiteGraph.EVENT || slot_shape === LiteGraph.BOX_SHAPE) {
            if (horizontal3) {
              ctx.rect(
                pos2[0] - 5 + 0.5,
                pos2[1] - 8 + 0.5,
                10,
                14
              );
            } else {
              ctx.rect(
                pos2[0] - 6 + 0.5,
                pos2[1] - 5 + 0.5,
                14,
                10
              );
            }
          } else if (slot_shape === LiteGraph.ARROW_SHAPE) {
            ctx.moveTo(pos2[0] + 8, pos2[1] + 0.5);
            ctx.lineTo(pos2[0] - 4, pos2[1] + 6 + 0.5);
            ctx.lineTo(pos2[0] - 4, pos2[1] - 6 + 0.5);
            ctx.closePath();
          } else if (slot_shape === LiteGraph.GRID_SHAPE) {
            ctx.rect(pos2[0] - 4, pos2[1] - 4, 2, 2);
            ctx.rect(pos2[0] - 1, pos2[1] - 4, 2, 2);
            ctx.rect(pos2[0] + 2, pos2[1] - 4, 2, 2);
            ctx.rect(pos2[0] - 4, pos2[1] - 1, 2, 2);
            ctx.rect(pos2[0] - 1, pos2[1] - 1, 2, 2);
            ctx.rect(pos2[0] + 2, pos2[1] - 1, 2, 2);
            ctx.rect(pos2[0] - 4, pos2[1] + 2, 2, 2);
            ctx.rect(pos2[0] - 1, pos2[1] + 2, 2, 2);
            ctx.rect(pos2[0] + 2, pos2[1] + 2, 2, 2);
            doStroke = false;
          } else {
            if (low_quality)
              ctx.rect(pos2[0] - 4, pos2[1] - 4, 8, 8);
            else
              ctx.arc(pos2[0], pos2[1], 4, 0, Math.PI * 2);
          }
          ctx.fill();
          if (!low_quality && doStroke)
            ctx.stroke();
          if (render_text) {
            var text2 = slot.label != null ? slot.label : slot.name;
            if (text2) {
              ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;
              if (horizontal3 || slot.dir == LiteGraph.DOWN) {
                ctx.fillText(text2, pos2[0], pos2[1] - 8);
              } else {
                ctx.fillText(text2, pos2[0] - 10, pos2[1] + 5);
              }
            }
          }
        }
      }
      ctx.textAlign = "left";
      ctx.globalAlpha = 1;
      if (node22.widgets) {
        var widgets_y = max_y;
        if (horizontal3 || node22.widgets_up) {
          widgets_y = 2;
        }
        if (node22.widgets_start_y != null)
          widgets_y = node22.widgets_start_y;
        this.drawNodeWidgets(
          node22,
          widgets_y,
          ctx,
          this.node_widget && this.node_widget[0] == node22 ? this.node_widget[1] : null
        );
      }
    } else if (this.render_collapsed_slots) {
      var input_slot = null;
      var output_slot = null;
      if (node22.inputs) {
        for (var i2 = 0; i2 < node22.inputs.length; i2++) {
          var slot = node22.inputs[i2];
          if (slot.link == null) {
            continue;
          }
          input_slot = slot;
          break;
        }
      }
      if (node22.outputs) {
        for (var i2 = 0; i2 < node22.outputs.length; i2++) {
          var slot = node22.outputs[i2];
          if (!slot.links || !slot.links.length) {
            continue;
          }
          output_slot = slot;
        }
      }
      if (input_slot) {
        var x2 = 0;
        var y2 = LiteGraph.NODE_TITLE_HEIGHT * -0.5;
        if (horizontal3) {
          x2 = node22._collapsed_width * 0.5;
          y2 = -LiteGraph.NODE_TITLE_HEIGHT;
        }
        ctx.fillStyle = "#686";
        ctx.beginPath();
        if (slot.type === LiteGraph.EVENT || slot.shape === LiteGraph.BOX_SHAPE) {
          ctx.rect(x2 - 7 + 0.5, y2 - 4, 14, 8);
        } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
          ctx.moveTo(x2 + 8, y2);
          ctx.lineTo(x2 + -4, y2 - 4);
          ctx.lineTo(x2 + -4, y2 + 4);
          ctx.closePath();
        } else {
          ctx.arc(x2, y2, 4, 0, Math.PI * 2);
        }
        ctx.fill();
      }
      if (output_slot) {
        var x2 = node22._collapsed_width;
        var y2 = LiteGraph.NODE_TITLE_HEIGHT * -0.5;
        if (horizontal3) {
          x2 = node22._collapsed_width * 0.5;
          y2 = 0;
        }
        ctx.fillStyle = "#686";
        ctx.strokeStyle = "black";
        ctx.beginPath();
        if (slot.type === LiteGraph.EVENT || slot.shape === LiteGraph.BOX_SHAPE) {
          ctx.rect(x2 - 7 + 0.5, y2 - 4, 14, 8);
        } else if (slot.shape === LiteGraph.ARROW_SHAPE) {
          ctx.moveTo(x2 + 6, y2);
          ctx.lineTo(x2 - 6, y2 - 4);
          ctx.lineTo(x2 - 6, y2 + 4);
          ctx.closePath();
        } else {
          ctx.arc(x2, y2, 4, 0, Math.PI * 2);
        }
        ctx.fill();
      }
    }
    if (node22.clip_area) {
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  };
  LGraphCanvas.prototype.drawLinkTooltip = function(ctx, link) {
    var pos2 = link._pos;
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(pos2[0], pos2[1], 3, 0, Math.PI * 2);
    ctx.fill();
    if (link.data == null)
      return;
    if (this.onDrawLinkTooltip) {
      if (this.onDrawLinkTooltip(ctx, link, this) == true)
        return;
    }
    var data28 = link.data;
    var text2 = null;
    if (data28.constructor === Number)
      text2 = data28.toFixed(2);
    else if (data28.constructor === String)
      text2 = '"' + data28 + '"';
    else if (data28.constructor === Boolean)
      text2 = String(data28);
    else if (data28.toToolTip)
      text2 = data28.toToolTip();
    else
      text2 = "[" + data28.constructor.name + "]";
    if (text2 == null)
      return;
    text2 = text2.substr(0, 30);
    ctx.font = "14px Courier New";
    var info = ctx.measureText(text2);
    var w2 = info.width + 20;
    var h2 = 24;
    ctx.shadowColor = "black";
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.shadowBlur = 3;
    ctx.fillStyle = "#454";
    ctx.beginPath();
    ctx.roundRect(pos2[0] - w2 * 0.5, pos2[1] - 15 - h2, w2, h2, [3]);
    ctx.moveTo(pos2[0] - 10, pos2[1] - 15);
    ctx.lineTo(pos2[0] + 10, pos2[1] - 15);
    ctx.lineTo(pos2[0], pos2[1] - 5);
    ctx.fill();
    ctx.shadowColor = "transparent";
    ctx.textAlign = "center";
    ctx.fillStyle = "#CEC";
    ctx.fillText(text2, pos2[0], pos2[1] - 15 - h2 * 0.3);
  };
  var tmp_area = new Float32Array(4);
  LGraphCanvas.prototype.drawNodeShape = function(node22, ctx, size2, fgcolor, bgcolor, selected2, mouse_over) {
    ctx.strokeStyle = fgcolor;
    ctx.fillStyle = bgcolor;
    var title_height = LiteGraph.NODE_TITLE_HEIGHT;
    var low_quality = this.ds.scale < 0.5;
    var shape = node22._shape || node22.constructor.shape || LiteGraph.ROUND_SHAPE;
    var title_mode = node22.constructor.title_mode;
    var render_title = true;
    if (title_mode == LiteGraph.TRANSPARENT_TITLE || title_mode == LiteGraph.NO_TITLE) {
      render_title = false;
    } else if (title_mode == LiteGraph.AUTOHIDE_TITLE && mouse_over) {
      render_title = true;
    }
    var area = tmp_area;
    area[0] = 0;
    area[1] = render_title ? -title_height : 0;
    area[2] = size2[0] + 1;
    area[3] = render_title ? size2[1] + title_height : size2[1];
    var old_alpha = ctx.globalAlpha;
    {
      ctx.beginPath();
      if (shape == LiteGraph.BOX_SHAPE || low_quality) {
        ctx.fillRect(area[0], area[1], area[2], area[3]);
      } else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE) {
        ctx.roundRect(
          area[0],
          area[1],
          area[2],
          area[3],
          shape == LiteGraph.CARD_SHAPE ? [this.round_radius, this.round_radius, 0, 0] : [this.round_radius]
        );
      } else if (shape == LiteGraph.CIRCLE_SHAPE) {
        ctx.arc(
          size2[0] * 0.5,
          size2[1] * 0.5,
          size2[0] * 0.5,
          0,
          Math.PI * 2
        );
      }
      ctx.fill();
      if (!node22.flags.collapsed && render_title) {
        ctx.shadowColor = "transparent";
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(0, -1, area[2], 2);
      }
    }
    ctx.shadowColor = "transparent";
    if (node22.onDrawBackground) {
      node22.onDrawBackground(ctx, this, this.canvas, this.graph_mouse);
    }
    if (render_title || title_mode == LiteGraph.TRANSPARENT_TITLE) {
      if (node22.onDrawTitleBar) {
        node22.onDrawTitleBar(ctx, title_height, size2, this.ds.scale, fgcolor);
      } else if (title_mode != LiteGraph.TRANSPARENT_TITLE && (node22.constructor.title_color || this.render_title_colored)) {
        var title_color = node22.constructor.title_color || fgcolor;
        if (node22.flags.collapsed) {
          ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;
        }
        if (this.use_gradients) {
          var grad = LGraphCanvas.gradients[title_color];
          if (!grad) {
            grad = LGraphCanvas.gradients[title_color] = ctx.createLinearGradient(0, 0, 400, 0);
            grad.addColorStop(0, title_color);
            grad.addColorStop(1, "#000");
          }
          ctx.fillStyle = grad;
        } else {
          ctx.fillStyle = title_color;
        }
        ctx.beginPath();
        if (shape == LiteGraph.BOX_SHAPE || low_quality) {
          ctx.rect(0, -title_height, size2[0] + 1, title_height);
        } else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE) {
          ctx.roundRect(
            0,
            -title_height,
            size2[0] + 1,
            title_height,
            node22.flags.collapsed ? [this.round_radius] : [this.round_radius, this.round_radius, 0, 0]
          );
        }
        ctx.fill();
        ctx.shadowColor = "transparent";
      }
      var colState = false;
      if (LiteGraph.node_box_coloured_by_mode) {
        if (LiteGraph.NODE_MODES_COLORS[node22.mode]) {
          colState = LiteGraph.NODE_MODES_COLORS[node22.mode];
        }
      }
      if (LiteGraph.node_box_coloured_when_on) {
        colState = node22.action_triggered ? "#FFF" : node22.execute_triggered ? "#AAA" : colState;
      }
      var box_size = 10;
      if (node22.onDrawTitleBox) {
        node22.onDrawTitleBox(ctx, title_height, size2, this.ds.scale);
      } else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CIRCLE_SHAPE || shape == LiteGraph.CARD_SHAPE) {
        if (low_quality) {
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(
            title_height * 0.5,
            title_height * -0.5,
            box_size * 0.5 + 1,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        ctx.fillStyle = node22.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;
        if (low_quality)
          ctx.fillRect(title_height * 0.5 - box_size * 0.5, title_height * -0.5 - box_size * 0.5, box_size, box_size);
        else {
          ctx.beginPath();
          ctx.arc(
            title_height * 0.5,
            title_height * -0.5,
            box_size * 0.5,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      } else {
        if (low_quality) {
          ctx.fillStyle = "black";
          ctx.fillRect(
            (title_height - box_size) * 0.5 - 1,
            (title_height + box_size) * -0.5 - 1,
            box_size + 2,
            box_size + 2
          );
        }
        ctx.fillStyle = node22.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;
        ctx.fillRect(
          (title_height - box_size) * 0.5,
          (title_height + box_size) * -0.5,
          box_size,
          box_size
        );
      }
      ctx.globalAlpha = old_alpha;
      if (node22.onDrawTitleText) {
        node22.onDrawTitleText(
          ctx,
          title_height,
          size2,
          this.ds.scale,
          this.title_text_font,
          selected2
        );
      }
      if (!low_quality) {
        ctx.font = this.title_text_font;
        var title = String(node22.getTitle());
        if (title) {
          if (selected2) {
            ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR;
          } else {
            ctx.fillStyle = node22.constructor.title_text_color || this.node_title_color;
          }
          if (node22.flags.collapsed) {
            ctx.textAlign = "left";
            ctx.measureText(title);
            ctx.fillText(
              title.substr(0, 20),
              //avoid urls too long
              title_height,
              // + measure.width * 0.5,
              LiteGraph.NODE_TITLE_TEXT_Y - title_height
            );
            ctx.textAlign = "left";
          } else {
            ctx.textAlign = "left";
            ctx.fillText(
              title,
              title_height,
              LiteGraph.NODE_TITLE_TEXT_Y - title_height
            );
          }
        }
      }
      if (!node22.flags.collapsed && node22.subgraph && !node22.skip_subgraph_button) {
        var w2 = LiteGraph.NODE_TITLE_HEIGHT;
        var x2 = node22.size[0] - w2;
        var over = LiteGraph.isInsideRectangle(this.graph_mouse[0] - node22.pos[0], this.graph_mouse[1] - node22.pos[1], x2 + 2, -w2 + 2, w2 - 4, w2 - 4);
        ctx.fillStyle = over ? "#888" : "#555";
        if (shape == LiteGraph.BOX_SHAPE || low_quality)
          ctx.fillRect(x2 + 2, -w2 + 2, w2 - 4, w2 - 4);
        else {
          ctx.beginPath();
          ctx.roundRect(x2 + 2, -w2 + 2, w2 - 4, w2 - 4, [4]);
          ctx.fill();
        }
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(x2 + w2 * 0.2, -w2 * 0.6);
        ctx.lineTo(x2 + w2 * 0.8, -w2 * 0.6);
        ctx.lineTo(x2 + w2 * 0.5, -w2 * 0.3);
        ctx.fill();
      }
      if (node22.onDrawTitle) {
        node22.onDrawTitle(ctx);
      }
    }
    if (selected2) {
      if (node22.onBounding) {
        node22.onBounding(area);
      }
      if (title_mode == LiteGraph.TRANSPARENT_TITLE) {
        area[1] -= title_height;
        area[3] += title_height;
      }
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      if (shape == LiteGraph.BOX_SHAPE) {
        ctx.rect(
          -6 + area[0],
          -6 + area[1],
          12 + area[2],
          12 + area[3]
        );
      } else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE && node22.flags.collapsed) {
        ctx.roundRect(
          -6 + area[0],
          -6 + area[1],
          12 + area[2],
          12 + area[3],
          [this.round_radius * 2]
        );
      } else if (shape == LiteGraph.CARD_SHAPE) {
        ctx.roundRect(
          -6 + area[0],
          -6 + area[1],
          12 + area[2],
          12 + area[3],
          [this.round_radius * 2, 2, this.round_radius * 2, 2]
        );
      } else if (shape == LiteGraph.CIRCLE_SHAPE) {
        ctx.arc(
          size2[0] * 0.5,
          size2[1] * 0.5,
          size2[0] * 0.5 + 6,
          0,
          Math.PI * 2
        );
      }
      ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR;
      ctx.stroke();
      ctx.strokeStyle = fgcolor;
      ctx.globalAlpha = 1;
    }
    if (node22.execute_triggered > 0) node22.execute_triggered--;
    if (node22.action_triggered > 0) node22.action_triggered--;
  };
  var margin_area = new Float32Array(4);
  var link_bounding = new Float32Array(4);
  var tempA = new Float32Array(2);
  var tempB = new Float32Array(2);
  LGraphCanvas.prototype.drawConnections = function(ctx) {
    var now2 = LiteGraph.getTime();
    var visible_area = this.visible_area;
    margin_area[0] = visible_area[0] - 20;
    margin_area[1] = visible_area[1] - 20;
    margin_area[2] = visible_area[2] + 40;
    margin_area[3] = visible_area[3] + 40;
    ctx.lineWidth = this.connections_width;
    ctx.fillStyle = "#AAA";
    ctx.strokeStyle = "#AAA";
    ctx.globalAlpha = this.editor_alpha;
    var nodes = this.graph._nodes;
    for (var n = 0, l = nodes.length; n < l; ++n) {
      var node22 = nodes[n];
      if (!node22.inputs || !node22.inputs.length) {
        continue;
      }
      for (var i2 = 0; i2 < node22.inputs.length; ++i2) {
        var input = node22.inputs[i2];
        if (!input || input.link == null) {
          continue;
        }
        var link_id = input.link;
        var link = this.graph.links[link_id];
        if (!link) {
          continue;
        }
        var start_node = this.graph.getNodeById(link.origin_id);
        if (start_node == null) {
          continue;
        }
        var start_node_slot = link.origin_slot;
        var start_node_slotpos = null;
        if (start_node_slot == -1) {
          start_node_slotpos = [
            start_node.pos[0] + 10,
            start_node.pos[1] + 10
          ];
        } else {
          start_node_slotpos = start_node.getConnectionPos(
            false,
            start_node_slot,
            tempA
          );
        }
        var end_node_slotpos = node22.getConnectionPos(true, i2, tempB);
        link_bounding[0] = start_node_slotpos[0];
        link_bounding[1] = start_node_slotpos[1];
        link_bounding[2] = end_node_slotpos[0] - start_node_slotpos[0];
        link_bounding[3] = end_node_slotpos[1] - start_node_slotpos[1];
        if (link_bounding[2] < 0) {
          link_bounding[0] += link_bounding[2];
          link_bounding[2] = Math.abs(link_bounding[2]);
        }
        if (link_bounding[3] < 0) {
          link_bounding[1] += link_bounding[3];
          link_bounding[3] = Math.abs(link_bounding[3]);
        }
        if (!overlapBounding(link_bounding, margin_area)) {
          continue;
        }
        var start_slot = start_node.outputs[start_node_slot];
        var end_slot = node22.inputs[i2];
        if (!start_slot || !end_slot) {
          continue;
        }
        var start_dir = start_slot.dir || (start_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT);
        var end_dir = end_slot.dir || (node22.horizontal ? LiteGraph.UP : LiteGraph.LEFT);
        this.renderLink(
          ctx,
          start_node_slotpos,
          end_node_slotpos,
          link,
          false,
          0,
          null,
          start_dir,
          end_dir
        );
        if (link && link._last_time && now2 - link._last_time < 1e3) {
          var f = 2 - (now2 - link._last_time) * 2e-3;
          var tmp = ctx.globalAlpha;
          ctx.globalAlpha = tmp * f;
          this.renderLink(
            ctx,
            start_node_slotpos,
            end_node_slotpos,
            link,
            true,
            f,
            "white",
            start_dir,
            end_dir
          );
          ctx.globalAlpha = tmp;
        }
      }
    }
    ctx.globalAlpha = 1;
  };
  LGraphCanvas.prototype.renderLink = function(ctx, a, b, link, skip_border, flow, color, start_dir, end_dir, num_sublines) {
    if (link) {
      this.visible_links.push(link);
    }
    if (!color && link) {
      color = link.color || LGraphCanvas.link_type_colors[link.type];
    }
    if (!color) {
      color = this.default_link_color;
    }
    if (link != null && this.highlighted_links[link.id]) {
      color = "#FFF";
    }
    start_dir = start_dir || LiteGraph.RIGHT;
    end_dir = end_dir || LiteGraph.LEFT;
    var dist2 = distance(a, b);
    if (this.render_connections_border && this.ds.scale > 0.6) {
      ctx.lineWidth = this.connections_width + 4;
    }
    ctx.lineJoin = "round";
    num_sublines = num_sublines || 1;
    if (num_sublines > 1) {
      ctx.lineWidth = 0.5;
    }
    ctx.beginPath();
    for (var i2 = 0; i2 < num_sublines; i2 += 1) {
      var offsety = (i2 - (num_sublines - 1) * 0.5) * 5;
      if (this.links_render_mode == LiteGraph.SPLINE_LINK) {
        ctx.moveTo(a[0], a[1] + offsety);
        var start_offset_x = 0;
        var start_offset_y = 0;
        var end_offset_x = 0;
        var end_offset_y = 0;
        switch (start_dir) {
          case LiteGraph.LEFT:
            start_offset_x = dist2 * -0.25;
            break;
          case LiteGraph.RIGHT:
            start_offset_x = dist2 * 0.25;
            break;
          case LiteGraph.UP:
            start_offset_y = dist2 * -0.25;
            break;
          case LiteGraph.DOWN:
            start_offset_y = dist2 * 0.25;
            break;
        }
        switch (end_dir) {
          case LiteGraph.LEFT:
            end_offset_x = dist2 * -0.25;
            break;
          case LiteGraph.RIGHT:
            end_offset_x = dist2 * 0.25;
            break;
          case LiteGraph.UP:
            end_offset_y = dist2 * -0.25;
            break;
          case LiteGraph.DOWN:
            end_offset_y = dist2 * 0.25;
            break;
        }
        ctx.bezierCurveTo(
          a[0] + start_offset_x,
          a[1] + start_offset_y + offsety,
          b[0] + end_offset_x,
          b[1] + end_offset_y + offsety,
          b[0],
          b[1] + offsety
        );
      } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) {
        ctx.moveTo(a[0], a[1] + offsety);
        var start_offset_x = 0;
        var start_offset_y = 0;
        var end_offset_x = 0;
        var end_offset_y = 0;
        switch (start_dir) {
          case LiteGraph.LEFT:
            start_offset_x = -1;
            break;
          case LiteGraph.RIGHT:
            start_offset_x = 1;
            break;
          case LiteGraph.UP:
            start_offset_y = -1;
            break;
          case LiteGraph.DOWN:
            start_offset_y = 1;
            break;
        }
        switch (end_dir) {
          case LiteGraph.LEFT:
            end_offset_x = -1;
            break;
          case LiteGraph.RIGHT:
            end_offset_x = 1;
            break;
          case LiteGraph.UP:
            end_offset_y = -1;
            break;
          case LiteGraph.DOWN:
            end_offset_y = 1;
            break;
        }
        var l = 15;
        ctx.lineTo(
          a[0] + start_offset_x * l,
          a[1] + start_offset_y * l + offsety
        );
        ctx.lineTo(
          b[0] + end_offset_x * l,
          b[1] + end_offset_y * l + offsety
        );
        ctx.lineTo(b[0], b[1] + offsety);
      } else if (this.links_render_mode == LiteGraph.STRAIGHT_LINK) {
        ctx.moveTo(a[0], a[1]);
        var start_x = a[0];
        var start_y = a[1];
        var end_x = b[0];
        var end_y = b[1];
        if (start_dir == LiteGraph.RIGHT) {
          start_x += 10;
        } else {
          start_y += 10;
        }
        if (end_dir == LiteGraph.LEFT) {
          end_x -= 10;
        } else {
          end_y -= 10;
        }
        ctx.lineTo(start_x, start_y);
        ctx.lineTo((start_x + end_x) * 0.5, start_y);
        ctx.lineTo((start_x + end_x) * 0.5, end_y);
        ctx.lineTo(end_x, end_y);
        ctx.lineTo(b[0], b[1]);
      } else {
        return;
      }
    }
    if (this.render_connections_border && this.ds.scale > 0.6 && !skip_border) {
      ctx.strokeStyle = "rgba(0,0,0,0.5)";
      ctx.stroke();
    }
    ctx.lineWidth = this.connections_width;
    ctx.fillStyle = ctx.strokeStyle = color;
    ctx.stroke();
    var pos2 = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);
    if (link && link._pos) {
      link._pos[0] = pos2[0];
      link._pos[1] = pos2[1];
    }
    if (this.ds.scale >= 0.6 && this.highquality_render && end_dir != LiteGraph.CENTER) {
      if (this.render_connection_arrows) {
        var posA = this.computeConnectionPoint(
          a,
          b,
          0.25,
          start_dir,
          end_dir
        );
        var posB = this.computeConnectionPoint(
          a,
          b,
          0.26,
          start_dir,
          end_dir
        );
        var posC = this.computeConnectionPoint(
          a,
          b,
          0.75,
          start_dir,
          end_dir
        );
        var posD = this.computeConnectionPoint(
          a,
          b,
          0.76,
          start_dir,
          end_dir
        );
        var angleA = 0;
        var angleB = 0;
        if (this.render_curved_connections) {
          angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);
          angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);
        } else {
          angleB = angleA = b[1] > a[1] ? 0 : Math.PI;
        }
        ctx.save();
        ctx.translate(posA[0], posA[1]);
        ctx.rotate(angleA);
        ctx.beginPath();
        ctx.moveTo(-5, -3);
        ctx.lineTo(0, 7);
        ctx.lineTo(5, -3);
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.translate(posC[0], posC[1]);
        ctx.rotate(angleB);
        ctx.beginPath();
        ctx.moveTo(-5, -3);
        ctx.lineTo(0, 7);
        ctx.lineTo(5, -3);
        ctx.fill();
        ctx.restore();
      }
      ctx.beginPath();
      ctx.arc(pos2[0], pos2[1], 5, 0, Math.PI * 2);
      ctx.fill();
    }
    if (flow) {
      ctx.fillStyle = color;
      for (var i2 = 0; i2 < 5; ++i2) {
        var f = (LiteGraph.getTime() * 1e-3 + i2 * 0.2) % 1;
        var pos2 = this.computeConnectionPoint(
          a,
          b,
          f,
          start_dir,
          end_dir
        );
        ctx.beginPath();
        ctx.arc(pos2[0], pos2[1], 5, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
  };
  LGraphCanvas.prototype.computeConnectionPoint = function(a, b, t, start_dir, end_dir) {
    start_dir = start_dir || LiteGraph.RIGHT;
    end_dir = end_dir || LiteGraph.LEFT;
    var dist2 = distance(a, b);
    var p0 = a;
    var p1 = [a[0], a[1]];
    var p2 = [b[0], b[1]];
    var p3 = b;
    switch (start_dir) {
      case LiteGraph.LEFT:
        p1[0] += dist2 * -0.25;
        break;
      case LiteGraph.RIGHT:
        p1[0] += dist2 * 0.25;
        break;
      case LiteGraph.UP:
        p1[1] += dist2 * -0.25;
        break;
      case LiteGraph.DOWN:
        p1[1] += dist2 * 0.25;
        break;
    }
    switch (end_dir) {
      case LiteGraph.LEFT:
        p2[0] += dist2 * -0.25;
        break;
      case LiteGraph.RIGHT:
        p2[0] += dist2 * 0.25;
        break;
      case LiteGraph.UP:
        p2[1] += dist2 * -0.25;
        break;
      case LiteGraph.DOWN:
        p2[1] += dist2 * 0.25;
        break;
    }
    var c1 = (1 - t) * (1 - t) * (1 - t);
    var c2 = 3 * ((1 - t) * (1 - t)) * t;
    var c3 = 3 * (1 - t) * (t * t);
    var c4 = t * t * t;
    var x2 = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];
    var y2 = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];
    return [x2, y2];
  };
  LGraphCanvas.prototype.drawExecutionOrder = function(ctx) {
    ctx.shadowColor = "transparent";
    ctx.globalAlpha = 0.25;
    ctx.textAlign = "center";
    ctx.strokeStyle = "white";
    ctx.globalAlpha = 0.75;
    var visible_nodes = this.visible_nodes;
    for (var i2 = 0; i2 < visible_nodes.length; ++i2) {
      var node22 = visible_nodes[i2];
      ctx.fillStyle = "black";
      ctx.fillRect(
        node22.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,
        node22.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,
        LiteGraph.NODE_TITLE_HEIGHT,
        LiteGraph.NODE_TITLE_HEIGHT
      );
      if (node22.order == 0) {
        ctx.strokeRect(
          node22.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
          node22.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
          LiteGraph.NODE_TITLE_HEIGHT,
          LiteGraph.NODE_TITLE_HEIGHT
        );
      }
      ctx.fillStyle = "#FFF";
      ctx.fillText(
        node22.order,
        node22.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,
        node22.pos[1] - 6
      );
    }
    ctx.globalAlpha = 1;
  };
  LGraphCanvas.prototype.drawNodeWidgets = function(node22, posY, ctx, active_widget2) {
    if (!node22.widgets || !node22.widgets.length) {
      return 0;
    }
    var width2 = node22.size[0];
    var widgets = node22.widgets;
    posY += 2;
    var H = LiteGraph.NODE_WIDGET_HEIGHT;
    var show_text = this.ds.scale > 0.5;
    ctx.save();
    ctx.globalAlpha = this.editor_alpha;
    var outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;
    var background_color = LiteGraph.WIDGET_BGCOLOR;
    var text_color = LiteGraph.WIDGET_TEXT_COLOR;
    var secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;
    var margin = 15;
    for (var i2 = 0; i2 < widgets.length; ++i2) {
      var w2 = widgets[i2];
      var y2 = posY;
      if (w2.y) {
        y2 = w2.y;
      }
      w2.last_y = y2;
      ctx.strokeStyle = outline_color;
      ctx.fillStyle = "#222";
      ctx.textAlign = "left";
      if (w2.disabled)
        ctx.globalAlpha *= 0.5;
      var widget_width2 = w2.width || width2;
      switch (w2.type) {
        case "button":
          ctx.fillStyle = background_color;
          if (w2.clicked) {
            ctx.fillStyle = "#AAA";
            w2.clicked = false;
            this.dirty_canvas = true;
          }
          ctx.fillRect(margin, y2, widget_width2 - margin * 2, H);
          if (show_text && !w2.disabled)
            ctx.strokeRect(margin, y2, widget_width2 - margin * 2, H);
          if (show_text) {
            ctx.textAlign = "center";
            ctx.fillStyle = text_color;
            ctx.fillText(w2.label || w2.name, widget_width2 * 0.5, y2 + H * 0.7);
          }
          break;
        case "toggle":
          ctx.textAlign = "left";
          ctx.strokeStyle = outline_color;
          ctx.fillStyle = background_color;
          ctx.beginPath();
          if (show_text)
            ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
          else
            ctx.rect(margin, y2, widget_width2 - margin * 2, H);
          ctx.fill();
          if (show_text && !w2.disabled)
            ctx.stroke();
          ctx.fillStyle = w2.value ? "#89A" : "#333";
          ctx.beginPath();
          ctx.arc(widget_width2 - margin * 2, y2 + H * 0.5, H * 0.36, 0, Math.PI * 2);
          ctx.fill();
          if (show_text) {
            ctx.fillStyle = secondary_text_color;
            const label5 = w2.label || w2.name;
            if (label5 != null) {
              ctx.fillText(label5, margin * 2, y2 + H * 0.7);
            }
            ctx.fillStyle = w2.value ? text_color : secondary_text_color;
            ctx.textAlign = "right";
            ctx.fillText(
              w2.value ? w2.options.on || "true" : w2.options.off || "false",
              widget_width2 - 40,
              y2 + H * 0.7
            );
          }
          break;
        case "slider":
          ctx.fillStyle = background_color;
          ctx.fillRect(margin, y2, widget_width2 - margin * 2, H);
          var range2 = w2.options.max - w2.options.min;
          var nvalue2 = (w2.value - w2.options.min) / range2;
          if (nvalue2 < 0) nvalue2 = 0;
          if (nvalue2 > 1) nvalue2 = 1;
          ctx.fillStyle = w2.options.hasOwnProperty("slider_color") ? w2.options.slider_color : active_widget2 == w2 ? "#89A" : "#678";
          ctx.fillRect(margin, y2, nvalue2 * (widget_width2 - margin * 2), H);
          if (show_text && !w2.disabled)
            ctx.strokeRect(margin, y2, widget_width2 - margin * 2, H);
          if (w2.marker) {
            var marker_nvalue = (w2.marker - w2.options.min) / range2;
            if (marker_nvalue < 0) marker_nvalue = 0;
            if (marker_nvalue > 1) marker_nvalue = 1;
            ctx.fillStyle = w2.options.hasOwnProperty("marker_color") ? w2.options.marker_color : "#AA9";
            ctx.fillRect(margin + marker_nvalue * (widget_width2 - margin * 2), y2, 2, H);
          }
          if (show_text) {
            ctx.textAlign = "center";
            ctx.fillStyle = text_color;
            ctx.fillText(
              w2.label || w2.name + "  " + Number(w2.value).toFixed(
                w2.options.precision != null ? w2.options.precision : 3
              ),
              widget_width2 * 0.5,
              y2 + H * 0.7
            );
          }
          break;
        case "number":
        case "combo":
          ctx.textAlign = "left";
          ctx.strokeStyle = outline_color;
          ctx.fillStyle = background_color;
          ctx.beginPath();
          if (show_text)
            ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
          else
            ctx.rect(margin, y2, widget_width2 - margin * 2, H);
          ctx.fill();
          if (show_text) {
            if (!w2.disabled)
              ctx.stroke();
            ctx.fillStyle = text_color;
            if (!w2.disabled) {
              ctx.beginPath();
              ctx.moveTo(margin + 16, y2 + 5);
              ctx.lineTo(margin + 6, y2 + H * 0.5);
              ctx.lineTo(margin + 16, y2 + H - 5);
              ctx.fill();
              ctx.beginPath();
              ctx.moveTo(widget_width2 - margin - 16, y2 + 5);
              ctx.lineTo(widget_width2 - margin - 6, y2 + H * 0.5);
              ctx.lineTo(widget_width2 - margin - 16, y2 + H - 5);
              ctx.fill();
            }
            ctx.fillStyle = secondary_text_color;
            ctx.fillText(w2.label || w2.name, margin * 2 + 5, y2 + H * 0.7);
            ctx.fillStyle = text_color;
            ctx.textAlign = "right";
            if (w2.type == "number") {
              ctx.fillText(
                Number(w2.value).toFixed(
                  w2.options.precision !== void 0 ? w2.options.precision : 3
                ),
                widget_width2 - margin * 2 - 20,
                y2 + H * 0.7
              );
            } else {
              var v2 = w2.value;
              if (w2.options.values) {
                var values2 = w2.options.values;
                if (values2.constructor === Function)
                  values2 = values2();
                if (values2 && values2.constructor !== Array)
                  v2 = values2[w2.value];
              }
              const labelWidth = ctx.measureText(w2.label || w2.name).width + margin * 2;
              const inputWidth = widget_width2 - margin * 4;
              const availableWidth = inputWidth - labelWidth;
              const textWidth = ctx.measureText(v2).width;
              if (textWidth > availableWidth) {
                const ELLIPSIS = "…";
                const ellipsisWidth = ctx.measureText(ELLIPSIS).width;
                const charWidthAvg = ctx.measureText("a").width;
                if (availableWidth <= ellipsisWidth) {
                  v2 = "․";
                } else {
                  const overflowWidth = textWidth + ellipsisWidth - availableWidth;
                  if (overflowWidth + charWidthAvg * 3 > availableWidth) {
                    const preciseRange = availableWidth + charWidthAvg * 3;
                    const preTruncateCt = Math.floor((preciseRange - ellipsisWidth) / charWidthAvg);
                    v2 = v2.substr(0, preTruncateCt);
                  }
                  while (ctx.measureText(v2).width + ellipsisWidth > availableWidth) {
                    v2 = v2.substr(0, v2.length - 1);
                  }
                  v2 += ELLIPSIS;
                }
              }
              ctx.fillText(
                v2,
                widget_width2 - margin * 2 - 20,
                y2 + H * 0.7
              );
            }
          }
          break;
        case "string":
        case "text":
          ctx.textAlign = "left";
          ctx.strokeStyle = outline_color;
          ctx.fillStyle = background_color;
          ctx.beginPath();
          if (show_text)
            ctx.roundRect(margin, y2, widget_width2 - margin * 2, H, [H * 0.5]);
          else
            ctx.rect(margin, y2, widget_width2 - margin * 2, H);
          ctx.fill();
          if (show_text) {
            if (!w2.disabled)
              ctx.stroke();
            ctx.save();
            ctx.beginPath();
            ctx.rect(margin, y2, widget_width2 - margin * 2, H);
            ctx.clip();
            ctx.fillStyle = secondary_text_color;
            const label5 = w2.label || w2.name;
            if (label5 != null) {
              ctx.fillText(label5, margin * 2, y2 + H * 0.7);
            }
            ctx.fillStyle = text_color;
            ctx.textAlign = "right";
            ctx.fillText(String(w2.value).substr(0, 30), widget_width2 - margin * 2, y2 + H * 0.7);
            ctx.restore();
          }
          break;
        default:
          if (w2.draw) {
            w2.draw(ctx, node22, widget_width2, y2, H);
          }
          break;
      }
      posY += (w2.computeSize ? w2.computeSize(widget_width2)[1] : H) + 4;
      ctx.globalAlpha = this.editor_alpha;
    }
    ctx.restore();
    ctx.textAlign = "left";
  };
  LGraphCanvas.prototype.processNodeWidgets = function(node, pos, event, active_widget) {
    if (!node.widgets || !node.widgets.length || !this.allow_interaction && !node.flags.allow_interaction) {
      return null;
    }
    var x = pos[0] - node.pos[0];
    var y = pos[1] - node.pos[1];
    var width = node.size[0];
    var that = this;
    var ref_window = this.getCanvasWindow();
    for (var i = 0; i < node.widgets.length; ++i) {
      var w = node.widgets[i];
      if (!w || w.disabled)
        continue;
      var widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT;
      var widget_width = w.width || width;
      if (w != active_widget && (x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === void 0))
        continue;
      var old_value = w.value;
      switch (w.type) {
        case "button":
          if (event.type === LiteGraph.pointerevents_method + "down") {
            if (w.callback) {
              setTimeout(function() {
                w.callback(w, that, node, pos, event);
              }, 20);
            }
            w.clicked = true;
            this.dirty_canvas = true;
          }
          break;
        case "slider":
          var old_value = w.value;
          var nvalue = clamp((x - 15) / (widget_width - 30), 0, 1);
          if (w.options.read_only) break;
          w.value = w.options.min + (w.options.max - w.options.min) * nvalue;
          if (old_value != w.value) {
            setTimeout(function() {
              inner_value_change(w, w.value);
            }, 20);
          }
          this.dirty_canvas = true;
          break;
        case "number":
        case "combo":
          var old_value = w.value;
          var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
          var allow_scroll = true;
          if (delta) {
            if (x > -3 && x < widget_width + 3) {
              allow_scroll = false;
            }
          }
          if (allow_scroll && event.type == LiteGraph.pointerevents_method + "move" && w.type == "number") {
            if (event.deltaX)
              w.value += event.deltaX * 0.1 * (w.options.step || 1);
            if (w.options.min != null && w.value < w.options.min) {
              w.value = w.options.min;
            }
            if (w.options.max != null && w.value > w.options.max) {
              w.value = w.options.max;
            }
          } else if (event.type == LiteGraph.pointerevents_method + "down") {
            var values = w.options.values;
            if (values && values.constructor === Function) {
              values = w.options.values(w, node);
            }
            var values_list = null;
            if (w.type != "number")
              values_list = values.constructor === Array ? values : Object.keys(values);
            var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
            if (w.type == "number") {
              w.value += delta * 0.1 * (w.options.step || 1);
              if (w.options.min != null && w.value < w.options.min) {
                w.value = w.options.min;
              }
              if (w.options.max != null && w.value > w.options.max) {
                w.value = w.options.max;
              }
            } else if (delta) {
              var index = -1;
              this.last_mouseclick = 0;
              if (values.constructor === Object)
                index = values_list.indexOf(String(w.value)) + delta;
              else
                index = values_list.indexOf(w.value) + delta;
              if (index >= values_list.length) {
                index = values_list.length - 1;
              }
              if (index < 0) {
                index = 0;
              }
              if (values.constructor === Array)
                w.value = values[index];
              else
                w.value = index;
            } else {
              let inner_clicked = function(v2, option4, event2) {
                if (values != values_list)
                  v2 = text_values.indexOf(v2);
                this.value = v2;
                inner_value_change(this, v2);
                that.dirty_canvas = true;
                return false;
              };
              var text_values = values != values_list ? Object.values(values) : values;
              new LiteGraph.ContextMenu(
                text_values,
                {
                  scale: Math.max(1, this.ds.scale),
                  event,
                  className: "dark",
                  callback: inner_clicked.bind(w)
                },
                ref_window
              );
            }
          } else if (event.type == LiteGraph.pointerevents_method + "up" && w.type == "number") {
            var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
            if (event.click_time < 200 && delta == 0) {
              this.prompt(
                "Value",
                w.value,
                function(v) {
                  if (/^[0-9+\-*/()\s]+|\d+\.\d+$/.test(v)) {
                    try {
                      v = eval(v);
                    } catch (e) {
                    }
                  }
                  this.value = Number(v);
                  inner_value_change(this, this.value);
                }.bind(w),
                event
              );
            }
          }
          if (old_value != w.value)
            setTimeout(
              function() {
                inner_value_change(this, this.value);
              }.bind(w),
              20
            );
          this.dirty_canvas = true;
          break;
        case "toggle":
          if (event.type == LiteGraph.pointerevents_method + "down") {
            w.value = !w.value;
            setTimeout(function() {
              inner_value_change(w, w.value);
            }, 20);
          }
          break;
        case "string":
        case "text":
          if (event.type == LiteGraph.pointerevents_method + "down") {
            this.prompt(
              "Value",
              w.value,
              function(v2) {
                inner_value_change(this, v2);
              }.bind(w),
              event,
              w.options ? w.options.multiline : false
            );
          }
          break;
        default:
          if (w.mouse) {
            this.dirty_canvas = w.mouse(event, [x, y], node);
          }
          break;
      }
      if (old_value != w.value) {
        if (node.onWidgetChanged)
          node.onWidgetChanged(w.name, w.value, old_value, w);
        node.graph._version++;
      }
      return w;
    }
    function inner_value_change(widget, value3) {
      if (widget.type == "number") {
        value3 = Number(value3);
      }
      widget.value = value3;
      if (widget.options && widget.options.property && node.properties[widget.options.property] !== void 0) {
        node.setProperty(widget.options.property, value3);
      }
      if (widget.callback) {
        widget.callback(widget.value, that, node, pos, event);
      }
    }
    return null;
  };
  LGraphCanvas.prototype.drawGroups = function(canvas, ctx) {
    if (!this.graph) {
      return;
    }
    var groups = this.graph._groups;
    ctx.save();
    ctx.globalAlpha = 0.5 * this.editor_alpha;
    for (var i2 = 0; i2 < groups.length; ++i2) {
      var group = groups[i2];
      if (!overlapBounding(this.visible_area, group._bounding)) {
        continue;
      }
      ctx.fillStyle = group.color || "#335";
      ctx.strokeStyle = group.color || "#335";
      var pos2 = group._pos;
      var size2 = group._size;
      ctx.globalAlpha = 0.25 * this.editor_alpha;
      ctx.beginPath();
      ctx.rect(pos2[0] + 0.5, pos2[1] + 0.5, size2[0], size2[1]);
      ctx.fill();
      ctx.globalAlpha = this.editor_alpha;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pos2[0] + size2[0], pos2[1] + size2[1]);
      ctx.lineTo(pos2[0] + size2[0] - 10, pos2[1] + size2[1]);
      ctx.lineTo(pos2[0] + size2[0], pos2[1] + size2[1] - 10);
      ctx.fill();
      var font_size = group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
      ctx.font = font_size + "px Arial";
      ctx.textAlign = "left";
      ctx.fillText(group.title, pos2[0] + 4, pos2[1] + font_size);
    }
    ctx.restore();
  };
  LGraphCanvas.prototype.adjustNodesSize = function() {
    var nodes = this.graph._nodes;
    for (var i2 = 0; i2 < nodes.length; ++i2) {
      nodes[i2].size = nodes[i2].computeSize();
    }
    this.setDirty(true, true);
  };
  LGraphCanvas.prototype.resize = function(width2, height) {
    if (!width2 && !height) {
      var parent = this.canvas.parentNode;
      width2 = parent.offsetWidth;
      height = parent.offsetHeight;
    }
    if (this.canvas.width == width2 && this.canvas.height == height) {
      return;
    }
    this.canvas.width = width2;
    this.canvas.height = height;
    this.bgcanvas.width = this.canvas.width;
    this.bgcanvas.height = this.canvas.height;
    this.setDirty(true, true);
  };
  LGraphCanvas.prototype.switchLiveMode = function(transition) {
    if (!transition) {
      this.live_mode = !this.live_mode;
      this.dirty_canvas = true;
      this.dirty_bgcanvas = true;
      return;
    }
    var self2 = this;
    var delta2 = this.live_mode ? 1.1 : 0.9;
    if (this.live_mode) {
      this.live_mode = false;
      this.editor_alpha = 0.1;
    }
    var t = setInterval(function() {
      self2.editor_alpha *= delta2;
      self2.dirty_canvas = true;
      self2.dirty_bgcanvas = true;
      if (delta2 < 1 && self2.editor_alpha < 0.01) {
        clearInterval(t);
        if (delta2 < 1) {
          self2.live_mode = true;
        }
      }
      if (delta2 > 1 && self2.editor_alpha > 0.99) {
        clearInterval(t);
        self2.editor_alpha = 1;
      }
    }, 1);
  };
  LGraphCanvas.prototype.onNodeSelectionChange = function(node22) {
    return;
  };
  LGraphCanvas.onGroupAdd = function(info, entry, mouse_event) {
    var canvas = LGraphCanvas.active_canvas;
    canvas.getCanvasWindow();
    var group = new LiteGraph.LGraphGroup();
    group.pos = canvas.convertEventToCanvasOffset(mouse_event);
    canvas.graph.add(group);
  };
  LGraphCanvas.getBoundaryNodes = function(nodes) {
    let top = null;
    let right = null;
    let bottom = null;
    let left = null;
    for (const nID in nodes) {
      const node22 = nodes[nID];
      const [x2, y2] = node22.pos;
      const [width2, height] = node22.size;
      if (top === null || y2 < top.pos[1]) {
        top = node22;
      }
      if (right === null || x2 + width2 > right.pos[0] + right.size[0]) {
        right = node22;
      }
      if (bottom === null || y2 + height > bottom.pos[1] + bottom.size[1]) {
        bottom = node22;
      }
      if (left === null || x2 < left.pos[0]) {
        left = node22;
      }
    }
    return {
      "top": top,
      "right": right,
      "bottom": bottom,
      "left": left
    };
  };
  LGraphCanvas.prototype.boundaryNodesForSelection = function() {
    return LGraphCanvas.getBoundaryNodes(Object.values(this.selected_nodes));
  };
  LGraphCanvas.alignNodes = function(nodes, direction, align_to) {
    if (!nodes) {
      return;
    }
    const canvas = LGraphCanvas.active_canvas;
    let boundaryNodes = [];
    if (align_to === void 0) {
      boundaryNodes = LGraphCanvas.getBoundaryNodes(nodes);
    } else {
      boundaryNodes = {
        "top": align_to,
        "right": align_to,
        "bottom": align_to,
        "left": align_to
      };
    }
    for (const [_2, node22] of Object.entries(canvas.selected_nodes)) {
      switch (direction) {
        case "right":
          node22.pos[0] = boundaryNodes["right"].pos[0] + boundaryNodes["right"].size[0] - node22.size[0];
          break;
        case "left":
          node22.pos[0] = boundaryNodes["left"].pos[0];
          break;
        case "top":
          node22.pos[1] = boundaryNodes["top"].pos[1];
          break;
        case "bottom":
          node22.pos[1] = boundaryNodes["bottom"].pos[1] + boundaryNodes["bottom"].size[1] - node22.size[1];
          break;
      }
    }
    canvas.dirty_canvas = true;
    canvas.dirty_bgcanvas = true;
  };
  LGraphCanvas.onNodeAlign = function(value3, options3, event2, prev_menu, node22) {
    new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
      event: event2,
      callback: inner_clicked,
      parentMenu: prev_menu
    });
    function inner_clicked(value22) {
      LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value22.toLowerCase(), node22);
    }
  };
  LGraphCanvas.onGroupAlign = function(value3, options3, event2, prev_menu) {
    new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
      event: event2,
      callback: inner_clicked,
      parentMenu: prev_menu
    });
    function inner_clicked(value22) {
      LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value22.toLowerCase());
    }
  };
  LGraphCanvas.onMenuAdd = function(node22, options3, e, prev_menu, callback) {
    var canvas = LGraphCanvas.active_canvas;
    var ref_window2 = canvas.getCanvasWindow();
    var graph = canvas.graph;
    if (!graph)
      return;
    function inner_onMenuAdded(base_category, prev_menu2) {
      var categories = LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function(category) {
        return category.startsWith(base_category);
      });
      var entries = [];
      categories.map(function(category) {
        if (!category)
          return;
        var base_category_regex = new RegExp("^(" + base_category + ")");
        var category_name = category.replace(base_category_regex, "").split("/")[0];
        var category_path = base_category === "" ? category_name + "/" : base_category + category_name + "/";
        var name = category_name;
        if (name.indexOf("::") != -1)
          name = name.split("::")[1];
        var index2 = entries.findIndex(function(entry) {
          return entry.value === category_path;
        });
        if (index2 === -1) {
          entries.push({ value: category_path, content: name, has_submenu: true, callback: function(value3, event2, mouseEvent, contextMenu) {
            inner_onMenuAdded(value3.value, contextMenu);
          } });
        }
      });
      var nodes = LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);
      nodes.map(function(node3) {
        if (node3.skip_list)
          return;
        var entry = {
          value: node3.type,
          content: node3.title,
          has_submenu: false,
          callback: function(value3, event2, mouseEvent, contextMenu) {
            var first_event = contextMenu.getFirstEvent();
            canvas.graph.beforeChange();
            var node4 = LiteGraph.createNode(value3.value);
            if (node4) {
              node4.pos = canvas.convertEventToCanvasOffset(first_event);
              canvas.graph.add(node4);
            }
            if (callback)
              callback(node4);
            canvas.graph.afterChange();
          }
        };
        entries.push(entry);
      });
      new LiteGraph.ContextMenu(entries, { event: e, parentMenu: prev_menu2 }, ref_window2);
    }
    inner_onMenuAdded("", prev_menu);
    return false;
  };
  LGraphCanvas.onMenuCollapseAll = function() {
  };
  LGraphCanvas.onMenuNodeEdit = function() {
  };
  LGraphCanvas.showMenuNodeOptionalInputs = function(v2, options3, e, prev_menu, node22) {
    if (!node22) {
      return;
    }
    var that2 = this;
    var canvas = LGraphCanvas.active_canvas;
    var ref_window2 = canvas.getCanvasWindow();
    var options3 = node22.optional_inputs;
    if (node22.onGetInputs) {
      options3 = node22.onGetInputs();
    }
    var entries = [];
    if (options3) {
      for (var i2 = 0; i2 < options3.length; i2++) {
        var entry = options3[i2];
        if (!entry) {
          entries.push(null);
          continue;
        }
        var label5 = entry[0];
        if (!entry[2])
          entry[2] = {};
        if (entry[2].label) {
          label5 = entry[2].label;
        }
        entry[2].removable = true;
        var data28 = { content: label5, value: entry };
        if (entry[1] == LiteGraph.ACTION) {
          data28.className = "event";
        }
        entries.push(data28);
      }
    }
    if (node22.onMenuNodeInputs) {
      var retEntries = node22.onMenuNodeInputs(entries);
      if (retEntries) entries = retEntries;
    }
    if (!entries.length) {
      console.log("no input entries");
      return;
    }
    new LiteGraph.ContextMenu(
      entries,
      {
        event: e,
        callback: inner_clicked,
        parentMenu: prev_menu,
        node: node22
      },
      ref_window2
    );
    function inner_clicked(v3, e2, prev2) {
      if (!node22) {
        return;
      }
      if (v3.callback) {
        v3.callback.call(that2, node22, v3, e2, prev2);
      }
      if (v3.value) {
        node22.graph.beforeChange();
        node22.addInput(v3.value[0], v3.value[1], v3.value[2]);
        if (node22.onNodeInputAdd) {
          node22.onNodeInputAdd(v3.value);
        }
        node22.setDirtyCanvas(true, true);
        node22.graph.afterChange();
      }
    }
    return false;
  };
  LGraphCanvas.showMenuNodeOptionalOutputs = function(v2, options3, e, prev_menu, node22) {
    if (!node22) {
      return;
    }
    var that2 = this;
    var canvas = LGraphCanvas.active_canvas;
    var ref_window2 = canvas.getCanvasWindow();
    var options3 = node22.optional_outputs;
    if (node22.onGetOutputs) {
      options3 = node22.onGetOutputs();
    }
    var entries = [];
    if (options3) {
      for (var i2 = 0; i2 < options3.length; i2++) {
        var entry = options3[i2];
        if (!entry) {
          entries.push(null);
          continue;
        }
        if (node22.flags && node22.flags.skip_repeated_outputs && node22.findOutputSlot(entry[0]) != -1) {
          continue;
        }
        var label5 = entry[0];
        if (!entry[2])
          entry[2] = {};
        if (entry[2].label) {
          label5 = entry[2].label;
        }
        entry[2].removable = true;
        var data28 = { content: label5, value: entry };
        if (entry[1] == LiteGraph.EVENT) {
          data28.className = "event";
        }
        entries.push(data28);
      }
    }
    if (this.onMenuNodeOutputs) {
      entries = this.onMenuNodeOutputs(entries);
    }
    if (LiteGraph.do_add_triggers_slots) {
      if (node22.findOutputSlot("onExecuted") == -1) {
        entries.push({ content: "On Executed", value: ["onExecuted", LiteGraph.EVENT, { nameLocked: true }], className: "event" });
      }
    }
    if (node22.onMenuNodeOutputs) {
      var retEntries = node22.onMenuNodeOutputs(entries);
      if (retEntries) entries = retEntries;
    }
    if (!entries.length) {
      return;
    }
    new LiteGraph.ContextMenu(
      entries,
      {
        event: e,
        callback: inner_clicked,
        parentMenu: prev_menu,
        node: node22
      },
      ref_window2
    );
    function inner_clicked(v3, e2, prev2) {
      if (!node22) {
        return;
      }
      if (v3.callback) {
        v3.callback.call(that2, node22, v3, e2, prev2);
      }
      if (!v3.value) {
        return;
      }
      var value3 = v3.value[1];
      if (value3 && (value3.constructor === Object || value3.constructor === Array)) {
        var entries2 = [];
        for (var i3 in value3) {
          entries2.push({ content: i3, value: value3[i3] });
        }
        new LiteGraph.ContextMenu(entries2, {
          event: e2,
          callback: inner_clicked,
          parentMenu: prev_menu,
          node: node22
        });
        return false;
      } else {
        node22.graph.beforeChange();
        node22.addOutput(v3.value[0], v3.value[1], v3.value[2]);
        if (node22.onNodeOutputAdd) {
          node22.onNodeOutputAdd(v3.value);
        }
        node22.setDirtyCanvas(true, true);
        node22.graph.afterChange();
      }
    }
    return false;
  };
  LGraphCanvas.onShowMenuNodeProperties = function(value3, options3, e, prev_menu, node22) {
    if (!node22 || !node22.properties) {
      return;
    }
    var canvas = LGraphCanvas.active_canvas;
    var ref_window2 = canvas.getCanvasWindow();
    var entries = [];
    for (var i2 in node22.properties) {
      var value3 = node22.properties[i2] !== void 0 ? node22.properties[i2] : " ";
      if (typeof value3 == "object")
        value3 = JSON.stringify(value3);
      var info = node22.getPropertyInfo(i2);
      if (info.type == "enum" || info.type == "combo")
        value3 = LGraphCanvas.getPropertyPrintableValue(value3, info.values);
      value3 = LGraphCanvas.decodeHTML(value3);
      entries.push({
        content: "<span class='property_name'>" + (info.label ? info.label : i2) + "</span><span class='property_value'>" + value3 + "</span>",
        value: i2
      });
    }
    if (!entries.length) {
      return;
    }
    new LiteGraph.ContextMenu(
      entries,
      {
        event: e,
        callback: inner_clicked,
        parentMenu: prev_menu,
        allow_html: true,
        node: node22
      },
      ref_window2
    );
    function inner_clicked(v2, options22, e2, prev2) {
      if (!node22) {
        return;
      }
      var rect = this.getBoundingClientRect();
      canvas.showEditPropertyValue(node22, v2.value, {
        position: [rect.left, rect.top]
      });
    }
    return false;
  };
  LGraphCanvas.decodeHTML = function(str) {
    var e = document.createElement("div");
    e.innerText = str;
    return e.innerHTML;
  };
  LGraphCanvas.onMenuResizeNode = function(value3, options3, e, menu, node22) {
    if (!node22) {
      return;
    }
    var fApplyMultiNode = function(node3) {
      node3.size = node3.computeSize();
      if (node3.onResize)
        node3.onResize(node3.size);
    };
    var graphcanvas = LGraphCanvas.active_canvas;
    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22);
    } else {
      for (var i2 in graphcanvas.selected_nodes) {
        fApplyMultiNode(graphcanvas.selected_nodes[i2]);
      }
    }
    node22.setDirtyCanvas(true, true);
  };
  LGraphCanvas.prototype.showLinkMenu = function(link, e) {
    var that2 = this;
    var node_left = that2.graph.getNodeById(link.origin_id);
    var node_right = that2.graph.getNodeById(link.target_id);
    var fromType = false;
    if (node_left && node_left.outputs && node_left.outputs[link.origin_slot]) fromType = node_left.outputs[link.origin_slot].type;
    var destType = false;
    if (node_right && node_right.outputs && node_right.outputs[link.target_slot]) destType = node_right.inputs[link.target_slot].type;
    var options3 = ["Add Node", null, "Delete", null];
    var menu = new LiteGraph.ContextMenu(options3, {
      event: e,
      title: link.data != null ? link.data.constructor.name : null,
      callback: inner_clicked
    });
    function inner_clicked(v2, options22, e2) {
      switch (v2) {
        case "Add Node":
          LGraphCanvas.onMenuAdd(null, null, e2, menu, function(node22) {
            if (!node22.inputs || !node22.inputs.length || !node22.outputs || !node22.outputs.length) {
              return;
            }
            if (node_left.connectByType(link.origin_slot, node22, fromType)) {
              node22.connectByType(link.target_slot, node_right, destType);
              node22.pos[0] -= node22.size[0] * 0.5;
            }
          });
          break;
        case "Delete":
          that2.graph.removeLink(link.id);
          break;
      }
    }
    return false;
  };
  LGraphCanvas.prototype.createDefaultNodeForSlot = function(optPass) {
    var optPass = optPass || {};
    var opts = Object.assign(
      {
        nodeFrom: null,
        slotFrom: null,
        nodeTo: null,
        slotTo: null,
        position: [],
        nodeType: null,
        posAdd: [0, 0],
        posSizeFix: [0, 0]
        // alpha, adjust the position x,y based on the new node size w,h
      },
      optPass
    );
    var that2 = this;
    var isFrom = opts.nodeFrom && opts.slotFrom !== null;
    var isTo = !isFrom && opts.nodeTo && opts.slotTo !== null;
    if (!isFrom && !isTo) {
      console.warn("No data passed to createDefaultNodeForSlot " + opts.nodeFrom + " " + opts.slotFrom + " " + opts.nodeTo + " " + opts.slotTo);
      return false;
    }
    if (!opts.nodeType) {
      console.warn("No type to createDefaultNodeForSlot");
      return false;
    }
    var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;
    var slotX = isFrom ? opts.slotFrom : opts.slotTo;
    var iSlotConn = false;
    switch (typeof slotX) {
      case "string":
        iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);
        slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
        break;
      case "object":
        iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);
        break;
      case "number":
        iSlotConn = slotX;
        slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
        break;
      case "undefined":
      default:
        console.warn("Cant get slot information " + slotX);
        return false;
    }
    if (slotX === false || iSlotConn === false) {
      console.warn("createDefaultNodeForSlot bad slotX " + slotX + " " + iSlotConn);
    }
    var fromSlotType = slotX.type == LiteGraph.EVENT ? "_event_" : slotX.type;
    var slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
    if (slotTypesDefault && slotTypesDefault[fromSlotType]) {
      if (slotX.link !== null) ;
      let nodeNewType = false;
      if (typeof slotTypesDefault[fromSlotType] == "object" || typeof slotTypesDefault[fromSlotType] == "array") {
        for (var typeX in slotTypesDefault[fromSlotType]) {
          if (opts.nodeType == slotTypesDefault[fromSlotType][typeX] || opts.nodeType == "AUTO") {
            nodeNewType = slotTypesDefault[fromSlotType][typeX];
            break;
          }
        }
      } else {
        if (opts.nodeType == slotTypesDefault[fromSlotType] || opts.nodeType == "AUTO") nodeNewType = slotTypesDefault[fromSlotType];
      }
      if (nodeNewType) {
        var nodeNewOpts = false;
        if (typeof nodeNewType == "object" && nodeNewType.node) {
          nodeNewOpts = nodeNewType;
          nodeNewType = nodeNewType.node;
        }
        var newNode = LiteGraph.createNode(nodeNewType);
        if (newNode) {
          if (nodeNewOpts) {
            if (nodeNewOpts.properties) {
              for (var i2 in nodeNewOpts.properties) {
                newNode.addProperty(i2, nodeNewOpts.properties[i2]);
              }
            }
            if (nodeNewOpts.inputs) {
              newNode.inputs = [];
              for (var i2 in nodeNewOpts.inputs) {
                newNode.addOutput(
                  nodeNewOpts.inputs[i2][0],
                  nodeNewOpts.inputs[i2][1]
                );
              }
            }
            if (nodeNewOpts.outputs) {
              newNode.outputs = [];
              for (var i2 in nodeNewOpts.outputs) {
                newNode.addOutput(
                  nodeNewOpts.outputs[i2][0],
                  nodeNewOpts.outputs[i2][1]
                );
              }
            }
            if (nodeNewOpts.title) {
              newNode.title = nodeNewOpts.title;
            }
            if (nodeNewOpts.json) {
              newNode.configure(nodeNewOpts.json);
            }
          }
          that2.graph.add(newNode);
          newNode.pos = [
            opts.position[0] + opts.posAdd[0] + (opts.posSizeFix[0] ? opts.posSizeFix[0] * newNode.size[0] : 0),
            opts.position[1] + opts.posAdd[1] + (opts.posSizeFix[1] ? opts.posSizeFix[1] * newNode.size[1] : 0)
          ];
          if (isFrom) {
            opts.nodeFrom.connectByType(iSlotConn, newNode, fromSlotType);
          } else {
            opts.nodeTo.connectByTypeOutput(iSlotConn, newNode, fromSlotType);
          }
          return true;
        } else {
          console.log("failed creating " + nodeNewType);
        }
      }
    }
    return false;
  };
  LGraphCanvas.prototype.showConnectionMenu = function(optPass) {
    var optPass = optPass || {};
    var opts = Object.assign(
      {
        nodeFrom: null,
        slotFrom: null,
        nodeTo: null,
        slotTo: null,
        e: null
      },
      optPass
    );
    var that2 = this;
    var isFrom = opts.nodeFrom && opts.slotFrom;
    var isTo = !isFrom && opts.nodeTo && opts.slotTo;
    if (!isFrom && !isTo) {
      console.warn("No data passed to showConnectionMenu");
      return false;
    }
    var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;
    var slotX = isFrom ? opts.slotFrom : opts.slotTo;
    var iSlotConn = false;
    switch (typeof slotX) {
      case "string":
        iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false);
        slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
        break;
      case "object":
        iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);
        break;
      case "number":
        iSlotConn = slotX;
        slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];
        break;
      default:
        console.warn("Cant get slot information " + slotX);
        return false;
    }
    var options3 = ["Add Node", null];
    if (that2.allow_searchbox) {
      options3.push("Search");
      options3.push(null);
    }
    var fromSlotType = slotX.type == LiteGraph.EVENT ? "_event_" : slotX.type;
    var slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
    if (slotTypesDefault && slotTypesDefault[fromSlotType]) {
      if (typeof slotTypesDefault[fromSlotType] == "object" || typeof slotTypesDefault[fromSlotType] == "array") {
        for (var typeX in slotTypesDefault[fromSlotType]) {
          options3.push(slotTypesDefault[fromSlotType][typeX]);
        }
      } else {
        options3.push(slotTypesDefault[fromSlotType]);
      }
    }
    var menu = new LiteGraph.ContextMenu(options3, {
      event: opts.e,
      title: (slotX && slotX.name != "" ? slotX.name + (fromSlotType ? " | " : "") : "") + (slotX && fromSlotType ? fromSlotType : ""),
      callback: inner_clicked
    });
    function inner_clicked(v2, options22, e) {
      switch (v2) {
        case "Add Node":
          LGraphCanvas.onMenuAdd(null, null, e, menu, function(node22) {
            if (isFrom) {
              opts.nodeFrom.connectByType(iSlotConn, node22, fromSlotType);
            } else {
              opts.nodeTo.connectByTypeOutput(iSlotConn, node22, fromSlotType);
            }
          });
          break;
        case "Search":
          if (isFrom) {
            that2.showSearchBox(e, { node_from: opts.nodeFrom, slot_from: slotX, type_filter_in: fromSlotType });
          } else {
            that2.showSearchBox(e, { node_to: opts.nodeTo, slot_from: slotX, type_filter_out: fromSlotType });
          }
          break;
        default:
          that2.createDefaultNodeForSlot(Object.assign(opts, {
            position: [opts.e.canvasX, opts.e.canvasY],
            nodeType: v2
          }));
          break;
      }
    }
    return false;
  };
  LGraphCanvas.onShowPropertyEditor = function(item, options3, e, menu, node22) {
    var property = item.property || "title";
    var value3 = node22[property];
    var dialog = document.createElement("div");
    dialog.is_modified = false;
    dialog.className = "graphdialog";
    dialog.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
    dialog.close = function() {
      if (dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
      }
    };
    var title = dialog.querySelector(".name");
    title.innerText = property;
    var input = dialog.querySelector(".value");
    if (input) {
      input.value = value3;
      input.addEventListener("blur", function(e2) {
        this.focus();
      });
      input.addEventListener("keydown", function(e2) {
        dialog.is_modified = true;
        if (e2.keyCode == 27) {
          dialog.close();
        } else if (e2.keyCode == 13) {
          inner();
        } else if (e2.keyCode != 13 && e2.target.localName != "textarea") {
          return;
        }
        e2.preventDefault();
        e2.stopPropagation();
      });
    }
    var graphcanvas = LGraphCanvas.active_canvas;
    var canvas = graphcanvas.canvas;
    var rect = canvas.getBoundingClientRect();
    var offsetx = -20;
    var offsety = -20;
    if (rect) {
      offsetx -= rect.left;
      offsety -= rect.top;
    }
    if (event) {
      dialog.style.left = event.clientX + offsetx + "px";
      dialog.style.top = event.clientY + offsety + "px";
    } else {
      dialog.style.left = canvas.width * 0.5 + offsetx + "px";
      dialog.style.top = canvas.height * 0.5 + offsety + "px";
    }
    var button = dialog.querySelector("button");
    button.addEventListener("click", inner);
    canvas.parentNode.appendChild(dialog);
    if (input) input.focus();
    var dialogCloseTimer = null;
    dialog.addEventListener("mouseleave", function(e2) {
      if (LiteGraph.dialog_close_on_mouse_leave) {
        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
          dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
      }
    });
    dialog.addEventListener("mouseenter", function(e2) {
      if (LiteGraph.dialog_close_on_mouse_leave) {
        if (dialogCloseTimer) clearTimeout(dialogCloseTimer);
      }
    });
    function inner() {
      if (input) setValue2(input.value);
    }
    function setValue2(value22) {
      if (item.type == "Number") {
        value22 = Number(value22);
      } else if (item.type == "Boolean") {
        value22 = Boolean(value22);
      }
      node22[property] = value22;
      if (dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
      }
      node22.setDirtyCanvas(true, true);
    }
  };
  LGraphCanvas.prototype.prompt = function(title, value3, callback, event2, multiline) {
    var that2 = this;
    title = title || "";
    var dialog = document.createElement("div");
    dialog.is_modified = false;
    dialog.className = "graphdialog rounded";
    if (multiline)
      dialog.innerHTML = "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>";
    else
      dialog.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
    dialog.close = function() {
      that2.prompt_box = null;
      if (dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
      }
    };
    var graphcanvas = LGraphCanvas.active_canvas;
    var canvas = graphcanvas.canvas;
    canvas.parentNode.appendChild(dialog);
    if (this.ds.scale > 1) {
      dialog.style.transform = "scale(" + this.ds.scale + ")";
    }
    var dialogCloseTimer = null;
    var prevent_timeout = false;
    LiteGraph.pointerListenerAdd(dialog, "leave", function(e) {
      if (prevent_timeout)
        return;
      if (LiteGraph.dialog_close_on_mouse_leave) {
        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
          dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
      }
    });
    LiteGraph.pointerListenerAdd(dialog, "enter", function(e) {
      if (LiteGraph.dialog_close_on_mouse_leave) {
        if (dialogCloseTimer) clearTimeout(dialogCloseTimer);
      }
    });
    var selInDia = dialog.querySelectorAll("select");
    if (selInDia) {
      selInDia.forEach(function(selIn) {
        selIn.addEventListener("click", function(e) {
          prevent_timeout++;
        });
        selIn.addEventListener("blur", function(e) {
          prevent_timeout = 0;
        });
        selIn.addEventListener("change", function(e) {
          prevent_timeout = -1;
        });
      });
    }
    if (that2.prompt_box) {
      that2.prompt_box.close();
    }
    that2.prompt_box = dialog;
    var name_element = dialog.querySelector(".name");
    name_element.innerText = title;
    var value_element = dialog.querySelector(".value");
    value_element.value = value3;
    value_element.select();
    var input = value_element;
    input.addEventListener("keydown", function(e) {
      dialog.is_modified = true;
      if (e.keyCode == 27) {
        dialog.close();
      } else if (e.keyCode == 13 && e.target.localName != "textarea") {
        if (callback) {
          callback(this.value);
        }
        dialog.close();
      } else {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
    });
    var button = dialog.querySelector("button");
    button.addEventListener("click", function(e) {
      if (callback) {
        callback(input.value);
      }
      that2.setDirty(true);
      dialog.close();
    });
    var rect = canvas.getBoundingClientRect();
    var offsetx = -20;
    var offsety = -20;
    if (rect) {
      offsetx -= rect.left;
      offsety -= rect.top;
    }
    if (event2) {
      dialog.style.left = event2.clientX + offsetx + "px";
      dialog.style.top = event2.clientY + offsety + "px";
    } else {
      dialog.style.left = canvas.width * 0.5 + offsetx + "px";
      dialog.style.top = canvas.height * 0.5 + offsety + "px";
    }
    setTimeout(function() {
      input.focus();
    }, 10);
    return dialog;
  };
  LGraphCanvas.search_limit = -1;
  LGraphCanvas.prototype.showSearchBox = function(event2, options3) {
    var def_options = {
      slot_from: null,
      node_from: null,
      node_to: null,
      do_type_filter: LiteGraph.search_filter_enabled,
      type_filter_in: false,
      type_filter_out: false,
      show_general_if_none_on_typefilter: true,
      show_general_after_typefiltered: true,
      hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave,
      show_all_if_empty: true,
      show_all_on_open: LiteGraph.search_show_all_on_open
    };
    options3 = Object.assign(def_options, options3 || {});
    var that2 = this;
    var graphcanvas = LGraphCanvas.active_canvas;
    var canvas = graphcanvas.canvas;
    var root_document = canvas.ownerDocument || document;
    var dialog = document.createElement("div");
    dialog.className = "litegraph litesearchbox graphdialog rounded";
    dialog.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>";
    if (options3.do_type_filter) {
      dialog.innerHTML += "<select class='slot_in_type_filter'><option value=''></option></select>";
      dialog.innerHTML += "<select class='slot_out_type_filter'><option value=''></option></select>";
    }
    dialog.innerHTML += "<div class='helper'></div>";
    if (root_document.fullscreenElement)
      root_document.fullscreenElement.appendChild(dialog);
    else {
      root_document.body.appendChild(dialog);
      root_document.body.style.overflow = "hidden";
    }
    if (options3.do_type_filter) {
      var selIn = dialog.querySelector(".slot_in_type_filter");
      var selOut = dialog.querySelector(".slot_out_type_filter");
    }
    dialog.close = function() {
      that2.search_box = null;
      this.blur();
      canvas.focus();
      root_document.body.style.overflow = "";
      setTimeout(function() {
        that2.canvas.focus();
      }, 20);
      if (dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
      }
    };
    if (this.ds.scale > 1) {
      dialog.style.transform = "scale(" + this.ds.scale + ")";
    }
    if (options3.hide_on_mouse_leave) {
      var prevent_timeout = false;
      var timeout_close = null;
      LiteGraph.pointerListenerAdd(dialog, "enter", function(e) {
        if (timeout_close) {
          clearTimeout(timeout_close);
          timeout_close = null;
        }
      });
      LiteGraph.pointerListenerAdd(dialog, "leave", function(e) {
        if (prevent_timeout) {
          return;
        }
        timeout_close = setTimeout(function() {
          dialog.close();
        }, typeof options3.hide_on_mouse_leave === "number" ? options3.hide_on_mouse_leave : 500);
      });
      if (options3.do_type_filter) {
        selIn.addEventListener("click", function(e) {
          prevent_timeout++;
        });
        selIn.addEventListener("blur", function(e) {
          prevent_timeout = 0;
        });
        selIn.addEventListener("change", function(e) {
          prevent_timeout = -1;
        });
        selOut.addEventListener("click", function(e) {
          prevent_timeout++;
        });
        selOut.addEventListener("blur", function(e) {
          prevent_timeout = 0;
        });
        selOut.addEventListener("change", function(e) {
          prevent_timeout = -1;
        });
      }
    }
    if (that2.search_box) {
      that2.search_box.close();
    }
    that2.search_box = dialog;
    var helper = dialog.querySelector(".helper");
    var first4 = null;
    var timeout = null;
    var selected2 = null;
    var input = dialog.querySelector("input");
    if (input) {
      input.addEventListener("blur", function(e) {
        this.focus();
      });
      input.addEventListener("keydown", function(e) {
        if (e.keyCode == 38) {
          changeSelection(false);
        } else if (e.keyCode == 40) {
          changeSelection(true);
        } else if (e.keyCode == 27) {
          dialog.close();
        } else if (e.keyCode == 13) {
          if (selected2) {
            select(unescape(selected2.dataset["type"]));
          } else if (first4) {
            select(first4);
          } else {
            dialog.close();
          }
        } else {
          if (timeout) {
            clearInterval(timeout);
          }
          timeout = setTimeout(refreshHelper, 10);
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        return true;
      });
    }
    if (options3.do_type_filter) {
      if (selIn) {
        var aSlots = LiteGraph.slot_types_in;
        var nSlots = aSlots.length;
        if (options3.type_filter_in == LiteGraph.EVENT || options3.type_filter_in == LiteGraph.ACTION)
          options3.type_filter_in = "_event_";
        for (var iK = 0; iK < nSlots; iK++) {
          var opt = document.createElement("option");
          opt.value = aSlots[iK];
          opt.innerHTML = aSlots[iK];
          selIn.appendChild(opt);
          if (options3.type_filter_in !== false && (options3.type_filter_in + "").toLowerCase() == (aSlots[iK] + "").toLowerCase()) {
            opt.selected = true;
          }
        }
        selIn.addEventListener("change", function() {
          refreshHelper();
        });
      }
      if (selOut) {
        var aSlots = LiteGraph.slot_types_out;
        var nSlots = aSlots.length;
        if (options3.type_filter_out == LiteGraph.EVENT || options3.type_filter_out == LiteGraph.ACTION)
          options3.type_filter_out = "_event_";
        for (var iK = 0; iK < nSlots; iK++) {
          var opt = document.createElement("option");
          opt.value = aSlots[iK];
          opt.innerHTML = aSlots[iK];
          selOut.appendChild(opt);
          if (options3.type_filter_out !== false && (options3.type_filter_out + "").toLowerCase() == (aSlots[iK] + "").toLowerCase()) {
            opt.selected = true;
          }
        }
        selOut.addEventListener("change", function() {
          refreshHelper();
        });
      }
    }
    var rect = canvas.getBoundingClientRect();
    var left = (event2 ? event2.clientX : rect.left + rect.width * 0.5) - 80;
    var top = (event2 ? event2.clientY : rect.top + rect.height * 0.5) - 20;
    dialog.style.left = left + "px";
    dialog.style.top = top + "px";
    if (event2.layerY > rect.height - 200)
      helper.style.maxHeight = rect.height - event2.layerY - 20 + "px";
    input.focus();
    if (options3.show_all_on_open) refreshHelper();
    function select(name) {
      if (name) {
        if (that2.onSearchBoxSelection) {
          that2.onSearchBoxSelection(name, event2, graphcanvas);
        } else {
          var extra = LiteGraph.searchbox_extras[name.toLowerCase()];
          if (extra) {
            name = extra.type;
          }
          graphcanvas.graph.beforeChange();
          var node22 = LiteGraph.createNode(name);
          if (node22) {
            node22.pos = graphcanvas.convertEventToCanvasOffset(
              event2
            );
            graphcanvas.graph.add(node22, false);
          }
          if (extra && extra.data) {
            if (extra.data.properties) {
              for (var i2 in extra.data.properties) {
                node22.addProperty(i2, extra.data.properties[i2]);
              }
            }
            if (extra.data.inputs) {
              node22.inputs = [];
              for (var i2 in extra.data.inputs) {
                node22.addOutput(
                  extra.data.inputs[i2][0],
                  extra.data.inputs[i2][1]
                );
              }
            }
            if (extra.data.outputs) {
              node22.outputs = [];
              for (var i2 in extra.data.outputs) {
                node22.addOutput(
                  extra.data.outputs[i2][0],
                  extra.data.outputs[i2][1]
                );
              }
            }
            if (extra.data.title) {
              node22.title = extra.data.title;
            }
            if (extra.data.json) {
              node22.configure(extra.data.json);
            }
          }
          if (options3.node_from) {
            var iS = false;
            switch (typeof options3.slot_from) {
              case "string":
                iS = options3.node_from.findOutputSlot(options3.slot_from);
                break;
              case "object":
                if (options3.slot_from.name) {
                  iS = options3.node_from.findOutputSlot(options3.slot_from.name);
                } else {
                  iS = -1;
                }
                if (iS == -1 && typeof options3.slot_from.slot_index !== "undefined") iS = options3.slot_from.slot_index;
                break;
              case "number":
                iS = options3.slot_from;
                break;
              default:
                iS = 0;
            }
            if (typeof options3.node_from.outputs[iS] !== "undefined") {
              if (iS !== false && iS > -1) {
                options3.node_from.connectByType(iS, node22, options3.node_from.outputs[iS].type);
              }
            }
          }
          if (options3.node_to) {
            var iS = false;
            switch (typeof options3.slot_from) {
              case "string":
                iS = options3.node_to.findInputSlot(options3.slot_from);
                break;
              case "object":
                if (options3.slot_from.name) {
                  iS = options3.node_to.findInputSlot(options3.slot_from.name);
                } else {
                  iS = -1;
                }
                if (iS == -1 && typeof options3.slot_from.slot_index !== "undefined") iS = options3.slot_from.slot_index;
                break;
              case "number":
                iS = options3.slot_from;
                break;
              default:
                iS = 0;
            }
            if (typeof options3.node_to.inputs[iS] !== "undefined") {
              if (iS !== false && iS > -1) {
                options3.node_to.connectByTypeOutput(iS, node22, options3.node_to.inputs[iS].type);
              }
            }
          }
          graphcanvas.graph.afterChange();
        }
      }
      dialog.close();
    }
    function changeSelection(forward) {
      var prev2 = selected2;
      if (selected2) {
        selected2.classList.remove("selected");
      }
      if (!selected2) {
        selected2 = forward ? helper.childNodes[0] : helper.childNodes[helper.childNodes.length];
      } else {
        selected2 = forward ? selected2.nextSibling : selected2.previousSibling;
        if (!selected2) {
          selected2 = prev2;
        }
      }
      if (!selected2) {
        return;
      }
      selected2.classList.add("selected");
      selected2.scrollIntoView({ block: "end", behavior: "smooth" });
    }
    function refreshHelper() {
      timeout = null;
      var str = input.value;
      first4 = null;
      helper.innerHTML = "";
      if (!str && !options3.show_all_if_empty) {
        return;
      }
      if (that2.onSearchBox) {
        var list = that2.onSearchBox(helper, str, graphcanvas);
        if (list) {
          for (var i2 = 0; i2 < list.length; ++i2) {
            addResult(list[i2]);
          }
        }
      } else {
        let inner_test_filter = function(type, optsIn) {
          var optsIn = optsIn || {};
          var optsDef = {
            skipFilter: false,
            inTypeOverride: false,
            outTypeOverride: false
          };
          var opts = Object.assign(optsDef, optsIn);
          var ctor2 = LiteGraph.registered_node_types[type];
          if (filter5 && ctor2.filter != filter5)
            return false;
          if ((!options3.show_all_if_empty || str) && type.toLowerCase().indexOf(str) === -1 && (!ctor2.title || ctor2.title.toLowerCase().indexOf(str) === -1))
            return false;
          if (options3.do_type_filter && !opts.skipFilter) {
            var sType = type;
            var sV = sIn.value;
            if (opts.inTypeOverride !== false) sV = opts.inTypeOverride;
            if (sIn && sV) {
              if (LiteGraph.registered_slot_in_types[sV] && LiteGraph.registered_slot_in_types[sV].nodes) {
                var doesInc = LiteGraph.registered_slot_in_types[sV].nodes.includes(sType);
                if (doesInc !== false) ;
                else {
                  return false;
                }
              }
            }
            var sV = sOut.value;
            if (opts.outTypeOverride !== false) sV = opts.outTypeOverride;
            if (sOut && sV) {
              if (LiteGraph.registered_slot_out_types[sV] && LiteGraph.registered_slot_out_types[sV].nodes) {
                var doesInc = LiteGraph.registered_slot_out_types[sV].nodes.includes(sType);
                if (doesInc !== false) ;
                else {
                  return false;
                }
              }
            }
          }
          return true;
        };
        var c = 0;
        str = str.toLowerCase();
        var filter5 = graphcanvas.filter || graphcanvas.graph.filter;
        if (options3.do_type_filter && that2.search_box) {
          var sIn = that2.search_box.querySelector(".slot_in_type_filter");
          var sOut = that2.search_box.querySelector(".slot_out_type_filter");
        } else {
          var sIn = false;
          var sOut = false;
        }
        for (var i2 in LiteGraph.searchbox_extras) {
          var extra = LiteGraph.searchbox_extras[i2];
          if ((!options3.show_all_if_empty || str) && extra.desc.toLowerCase().indexOf(str) === -1) {
            continue;
          }
          var ctor = LiteGraph.registered_node_types[extra.type];
          if (ctor && ctor.filter != filter5)
            continue;
          if (!inner_test_filter(extra.type))
            continue;
          addResult(extra.desc, "searchbox_extra");
          if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {
            break;
          }
        }
        var filtered = null;
        if (Array.prototype.filter) {
          var keys = Object.keys(LiteGraph.registered_node_types);
          var filtered = keys.filter(inner_test_filter);
        } else {
          filtered = [];
          for (var i2 in LiteGraph.registered_node_types) {
            if (inner_test_filter(i2))
              filtered.push(i2);
          }
        }
        for (var i2 = 0; i2 < filtered.length; i2++) {
          addResult(filtered[i2]);
          if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {
            break;
          }
        }
        if (options3.show_general_after_typefiltered && (sIn.value || sOut.value)) {
          filtered_extra = [];
          for (var i2 in LiteGraph.registered_node_types) {
            if (inner_test_filter(i2, { inTypeOverride: sIn && sIn.value ? "*" : false, outTypeOverride: sOut && sOut.value ? "*" : false }))
              filtered_extra.push(i2);
          }
          for (var i2 = 0; i2 < filtered_extra.length; i2++) {
            addResult(filtered_extra[i2], "generic_type");
            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {
              break;
            }
          }
        }
        if ((sIn.value || sOut.value) && (helper.childNodes.length == 0 && options3.show_general_if_none_on_typefilter)) {
          filtered_extra = [];
          for (var i2 in LiteGraph.registered_node_types) {
            if (inner_test_filter(i2, { skipFilter: true }))
              filtered_extra.push(i2);
          }
          for (var i2 = 0; i2 < filtered_extra.length; i2++) {
            addResult(filtered_extra[i2], "not_in_filter");
            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {
              break;
            }
          }
        }
      }
      function addResult(type, className) {
        var help = document.createElement("div");
        if (!first4) {
          first4 = type;
        }
        const nodeType = LiteGraph.registered_node_types[type];
        if (nodeType == null ? void 0 : nodeType.title) {
          help.innerText = nodeType == null ? void 0 : nodeType.title;
          const typeEl = document.createElement("span");
          typeEl.className = "litegraph lite-search-item-type";
          typeEl.textContent = type;
          help.append(typeEl);
        } else {
          help.innerText = type;
        }
        help.dataset["type"] = escape(type);
        help.className = "litegraph lite-search-item";
        if (className) {
          help.className += " " + className;
        }
        help.addEventListener("click", function(e) {
          select(unescape(this.dataset["type"]));
        });
        helper.appendChild(help);
      }
    }
    return dialog;
  };
  LGraphCanvas.prototype.showEditPropertyValue = function(node22, property, options3) {
    if (!node22 || node22.properties[property] === void 0) {
      return;
    }
    options3 = options3 || {};
    var info = node22.getPropertyInfo(property);
    var type = info.type;
    var input_html = "";
    if (type == "string" || type == "number" || type == "array" || type == "object") {
      input_html = "<input autofocus type='text' class='value'/>";
    } else if ((type == "enum" || type == "combo") && info.values) {
      input_html = "<select autofocus type='text' class='value'>";
      for (var i2 in info.values) {
        var v2 = i2;
        if (info.values.constructor === Array)
          v2 = info.values[i2];
        input_html += "<option value='" + v2 + "' " + (v2 == node22.properties[property] ? "selected" : "") + ">" + info.values[i2] + "</option>";
      }
      input_html += "</select>";
    } else if (type == "boolean" || type == "toggle") {
      input_html = "<input autofocus type='checkbox' class='value' " + (node22.properties[property] ? "checked" : "") + "/>";
    } else {
      console.warn("unknown type: " + type);
      return;
    }
    var dialog = this.createDialog(
      "<span class='name'>" + (info.label ? info.label : property) + "</span>" + input_html + "<button>OK</button>",
      options3
    );
    var input = false;
    if ((type == "enum" || type == "combo") && info.values) {
      input = dialog.querySelector("select");
      input.addEventListener("change", function(e) {
        dialog.modified();
        setValue2(e.target.value);
      });
    } else if (type == "boolean" || type == "toggle") {
      input = dialog.querySelector("input");
      if (input) {
        input.addEventListener("click", function(e) {
          dialog.modified();
          setValue2(!!input.checked);
        });
      }
    } else {
      input = dialog.querySelector("input");
      if (input) {
        input.addEventListener("blur", function(e) {
          this.focus();
        });
        var v2 = node22.properties[property] !== void 0 ? node22.properties[property] : "";
        if (type !== "string") {
          v2 = JSON.stringify(v2);
        }
        input.value = v2;
        input.addEventListener("keydown", function(e) {
          if (e.keyCode == 27) {
            dialog.close();
          } else if (e.keyCode == 13) {
            inner();
          } else if (e.keyCode != 13) {
            dialog.modified();
            return;
          }
          e.preventDefault();
          e.stopPropagation();
        });
      }
    }
    if (input) input.focus();
    var button = dialog.querySelector("button");
    button.addEventListener("click", inner);
    function inner() {
      setValue2(input.value);
    }
    function setValue2(value3) {
      if (info && info.values && info.values.constructor === Object && info.values[value3] != void 0)
        value3 = info.values[value3];
      if (typeof node22.properties[property] == "number") {
        value3 = Number(value3);
      }
      if (type == "array" || type == "object") {
        value3 = JSON.parse(value3);
      }
      node22.properties[property] = value3;
      if (node22.graph) {
        node22.graph._version++;
      }
      if (node22.onPropertyChanged) {
        node22.onPropertyChanged(property, value3);
      }
      if (options3.onclose)
        options3.onclose();
      dialog.close();
      node22.setDirtyCanvas(true, true);
    }
    return dialog;
  };
  LGraphCanvas.prototype.createDialog = function(html, options3) {
    var def_options = { checkForInput: false, closeOnLeave: true, closeOnLeave_checkModified: true };
    options3 = Object.assign(def_options, options3 || {});
    var dialog = document.createElement("div");
    dialog.className = "graphdialog";
    dialog.innerHTML = html;
    dialog.is_modified = false;
    var rect = this.canvas.getBoundingClientRect();
    var offsetx = -20;
    var offsety = -20;
    if (rect) {
      offsetx -= rect.left;
      offsety -= rect.top;
    }
    if (options3.position) {
      offsetx += options3.position[0];
      offsety += options3.position[1];
    } else if (options3.event) {
      offsetx += options3.event.clientX;
      offsety += options3.event.clientY;
    } else {
      offsetx += this.canvas.width * 0.5;
      offsety += this.canvas.height * 0.5;
    }
    dialog.style.left = offsetx + "px";
    dialog.style.top = offsety + "px";
    this.canvas.parentNode.appendChild(dialog);
    if (options3.checkForInput) {
      var aI = [];
      var focused = false;
      if (aI = dialog.querySelectorAll("input")) {
        aI.forEach(function(iX) {
          iX.addEventListener("keydown", function(e) {
            dialog.modified();
            if (e.keyCode == 27) {
              dialog.close();
            } else if (e.keyCode != 13) {
              return;
            }
            e.preventDefault();
            e.stopPropagation();
          });
          if (!focused) iX.focus();
        });
      }
    }
    dialog.modified = function() {
      dialog.is_modified = true;
    };
    dialog.close = function() {
      if (dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
      }
    };
    var dialogCloseTimer = null;
    var prevent_timeout = false;
    dialog.addEventListener("mouseleave", function(e) {
      if (prevent_timeout)
        return;
      if (options3.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) {
        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)
          dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay);
      }
    });
    dialog.addEventListener("mouseenter", function(e) {
      if (options3.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) {
        if (dialogCloseTimer) clearTimeout(dialogCloseTimer);
      }
    });
    var selInDia = dialog.querySelectorAll("select");
    if (selInDia) {
      selInDia.forEach(function(selIn) {
        selIn.addEventListener("click", function(e) {
          prevent_timeout++;
        });
        selIn.addEventListener("blur", function(e) {
          prevent_timeout = 0;
        });
        selIn.addEventListener("change", function(e) {
          prevent_timeout = -1;
        });
      });
    }
    return dialog;
  };
  LGraphCanvas.prototype.createPanel = function(title, options3) {
    options3 = options3 || {};
    var ref_window2 = options3.window || window;
    var root27 = document.createElement("div");
    root27.className = "litegraph dialog";
    root27.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>";
    root27.header = root27.querySelector(".dialog-header");
    if (options3.width)
      root27.style.width = options3.width + (options3.width.constructor === Number ? "px" : "");
    if (options3.height)
      root27.style.height = options3.height + (options3.height.constructor === Number ? "px" : "");
    if (options3.closable) {
      var close4 = document.createElement("span");
      close4.innerHTML = "&#10005;";
      close4.classList.add("close");
      close4.addEventListener("click", function() {
        root27.close();
      });
      root27.header.appendChild(close4);
    }
    root27.title_element = root27.querySelector(".dialog-title");
    root27.title_element.innerText = title;
    root27.content = root27.querySelector(".dialog-content");
    root27.alt_content = root27.querySelector(".dialog-alt-content");
    root27.footer = root27.querySelector(".dialog-footer");
    root27.close = function() {
      if (root27.onClose && typeof root27.onClose == "function") {
        root27.onClose();
      }
      if (root27.parentNode)
        root27.parentNode.removeChild(root27);
      if (this.parentNode) {
        this.parentNode.removeChild(this);
      }
    };
    root27.toggleAltContent = function(force) {
      if (typeof force != "undefined") {
        var vTo = force ? "block" : "none";
        var vAlt = force ? "none" : "block";
      } else {
        var vTo = root27.alt_content.style.display != "block" ? "block" : "none";
        var vAlt = root27.alt_content.style.display != "block" ? "none" : "block";
      }
      root27.alt_content.style.display = vTo;
      root27.content.style.display = vAlt;
    };
    root27.toggleFooterVisibility = function(force) {
      if (typeof force != "undefined") {
        var vTo = force ? "block" : "none";
      } else {
        var vTo = root27.footer.style.display != "block" ? "block" : "none";
      }
      root27.footer.style.display = vTo;
    };
    root27.clear = function() {
      this.content.innerHTML = "";
    };
    root27.addHTML = function(code2, classname, on_footer) {
      var elem = document.createElement("div");
      if (classname)
        elem.className = classname;
      elem.innerHTML = code2;
      if (on_footer)
        root27.footer.appendChild(elem);
      else
        root27.content.appendChild(elem);
      return elem;
    };
    root27.addButton = function(name, callback, options22) {
      var elem = document.createElement("button");
      elem.innerText = name;
      elem.options = options22;
      elem.classList.add("btn");
      elem.addEventListener("click", callback);
      root27.footer.appendChild(elem);
      return elem;
    };
    root27.addSeparator = function() {
      var elem = document.createElement("div");
      elem.className = "separator";
      root27.content.appendChild(elem);
    };
    root27.addWidget = function(type, name, value3, options22, callback) {
      options22 = options22 || {};
      var str_value = String(value3);
      type = type.toLowerCase();
      if (type == "number")
        str_value = value3.toFixed(3);
      var elem = document.createElement("div");
      elem.className = "property";
      elem.innerHTML = "<span class='property_name'></span><span class='property_value'></span>";
      elem.querySelector(".property_name").innerText = options22.label || name;
      var value_element = elem.querySelector(".property_value");
      value_element.innerText = str_value;
      elem.dataset["property"] = name;
      elem.dataset["type"] = options22.type || type;
      elem.options = options22;
      elem.value = value3;
      if (type == "code")
        elem.addEventListener("click", function(e) {
          root27.inner_showCodePad(this.dataset["property"]);
        });
      else if (type == "boolean") {
        elem.classList.add("boolean");
        if (value3)
          elem.classList.add("bool-on");
        elem.addEventListener("click", function() {
          var propname = this.dataset["property"];
          this.value = !this.value;
          this.classList.toggle("bool-on");
          this.querySelector(".property_value").innerText = this.value ? "true" : "false";
          innerChange(propname, this.value);
        });
      } else if (type == "string" || type == "number") {
        value_element.setAttribute("contenteditable", true);
        value_element.addEventListener("keydown", function(e) {
          if (e.code == "Enter" && (type != "string" || !e.shiftKey)) {
            e.preventDefault();
            this.blur();
          }
        });
        value_element.addEventListener("blur", function() {
          var v2 = this.innerText;
          var propname = this.parentNode.dataset["property"];
          var proptype = this.parentNode.dataset["type"];
          if (proptype == "number")
            v2 = Number(v2);
          innerChange(propname, v2);
        });
      } else if (type == "enum" || type == "combo") {
        var str_value = LGraphCanvas.getPropertyPrintableValue(value3, options22.values);
        value_element.innerText = str_value;
        value_element.addEventListener("click", function(event2) {
          var values2 = options22.values || [];
          var propname = this.parentNode.dataset["property"];
          var elem_that = this;
          new LiteGraph.ContextMenu(
            values2,
            {
              event: event2,
              className: "dark",
              callback: inner_clicked
            },
            ref_window2
          );
          function inner_clicked(v2, option4, event3) {
            elem_that.innerText = v2;
            innerChange(propname, v2);
            return false;
          }
        });
      }
      root27.content.appendChild(elem);
      function innerChange(name2, value22) {
        if (options22.callback)
          options22.callback(name2, value22, options22);
        if (callback)
          callback(name2, value22, options22);
      }
      return elem;
    };
    if (root27.onOpen && typeof root27.onOpen == "function") root27.onOpen();
    return root27;
  };
  LGraphCanvas.getPropertyPrintableValue = function(value3, values2) {
    if (!values2)
      return String(value3);
    if (values2.constructor === Array) {
      return String(value3);
    }
    if (values2.constructor === Object) {
      var desc_value = "";
      for (var k in values2) {
        if (values2[k] != value3)
          continue;
        desc_value = k;
        break;
      }
      return String(value3) + " (" + desc_value + ")";
    }
  };
  LGraphCanvas.prototype.closePanels = function() {
    var panel2 = document.querySelector("#node-panel");
    if (panel2)
      panel2.close();
    var panel2 = document.querySelector("#option-panel");
    if (panel2)
      panel2.close();
  };
  LGraphCanvas.prototype.showShowGraphOptionsPanel = function(refOpts, obEv, refMenu, refMenu2) {
    if (this.constructor && this.constructor.name == "HTMLDivElement") {
      if (!obEv || !obEv.event || !obEv.event.target || !obEv.event.target.lgraphcanvas) {
        console.warn("Canvas not found");
        return;
      }
      var graphcanvas = obEv.event.target.lgraphcanvas;
    } else {
      var graphcanvas = this;
    }
    graphcanvas.closePanels();
    var ref_window2 = graphcanvas.getCanvasWindow();
    panel = graphcanvas.createPanel("Options", {
      closable: true,
      window: ref_window2,
      onOpen: function() {
        graphcanvas.OPTIONPANEL_IS_OPEN = true;
      },
      onClose: function() {
        graphcanvas.OPTIONPANEL_IS_OPEN = false;
        graphcanvas.options_panel = null;
      }
    });
    graphcanvas.options_panel = panel;
    panel.id = "option-panel";
    panel.classList.add("settings");
    function inner_refresh() {
      panel.content.innerHTML = "";
      var fUpdate = function(name, value3, options3) {
        switch (name) {
          default:
            if (options3 && options3.key) {
              name = options3.key;
            }
            if (options3.values) {
              value3 = Object.values(options3.values).indexOf(value3);
            }
            graphcanvas[name] = value3;
            break;
        }
      };
      var aProps = LiteGraph.availableCanvasOptions;
      aProps.sort();
      for (var pI in aProps) {
        var pX = aProps[pI];
        panel.addWidget("boolean", pX, graphcanvas[pX], { key: pX, on: "True", off: "False" }, fUpdate);
      }
      [graphcanvas.links_render_mode];
      panel.addWidget("combo", "Render mode", LiteGraph.LINK_RENDER_MODES[graphcanvas.links_render_mode], { key: "links_render_mode", values: LiteGraph.LINK_RENDER_MODES }, fUpdate);
      panel.addSeparator();
      panel.footer.innerHTML = "";
    }
    inner_refresh();
    graphcanvas.canvas.parentNode.appendChild(panel);
  };
  LGraphCanvas.prototype.showShowNodePanel = function(node22) {
    this.SELECTED_NODE = node22;
    this.closePanels();
    var ref_window2 = this.getCanvasWindow();
    var graphcanvas = this;
    var panel2 = this.createPanel(node22.title || "", {
      closable: true,
      window: ref_window2,
      onOpen: function() {
        graphcanvas.NODEPANEL_IS_OPEN = true;
      },
      onClose: function() {
        graphcanvas.NODEPANEL_IS_OPEN = false;
        graphcanvas.node_panel = null;
      }
    });
    graphcanvas.node_panel = panel2;
    panel2.id = "node-panel";
    panel2.node = node22;
    panel2.classList.add("settings");
    function inner_refresh() {
      panel2.content.innerHTML = "";
      panel2.addHTML("<span class='node_type'>" + node22.type + "</span><span class='node_desc'>" + (node22.constructor.desc || "") + "</span><span class='separator'></span>");
      panel2.addHTML("<h3>Properties</h3>");
      var fUpdate = function(name, value22) {
        graphcanvas.graph.beforeChange(node22);
        switch (name) {
          case "Title":
            node22.title = value22;
            break;
          case "Mode":
            var kV = Object.values(LiteGraph.NODE_MODES).indexOf(value22);
            if (kV >= 0 && LiteGraph.NODE_MODES[kV]) {
              node22.changeMode(kV);
            } else {
              console.warn("unexpected mode: " + value22);
            }
            break;
          case "Color":
            if (LGraphCanvas.node_colors[value22]) {
              node22.color = LGraphCanvas.node_colors[value22].color;
              node22.bgcolor = LGraphCanvas.node_colors[value22].bgcolor;
            } else {
              console.warn("unexpected color: " + value22);
            }
            break;
          default:
            node22.setProperty(name, value22);
            break;
        }
        graphcanvas.graph.afterChange();
        graphcanvas.dirty_canvas = true;
      };
      panel2.addWidget("string", "Title", node22.title, {}, fUpdate);
      panel2.addWidget("combo", "Mode", LiteGraph.NODE_MODES[node22.mode], { values: LiteGraph.NODE_MODES }, fUpdate);
      var nodeCol = "";
      if (node22.color !== void 0) {
        nodeCol = Object.keys(LGraphCanvas.node_colors).filter(function(nK) {
          return LGraphCanvas.node_colors[nK].color == node22.color;
        });
      }
      panel2.addWidget("combo", "Color", nodeCol, { values: Object.keys(LGraphCanvas.node_colors) }, fUpdate);
      for (var pName in node22.properties) {
        var value3 = node22.properties[pName];
        var info = node22.getPropertyInfo(pName);
        info.type || "string";
        if (node22.onAddPropertyToPanel && node22.onAddPropertyToPanel(pName, panel2))
          continue;
        panel2.addWidget(info.widget || info.type, pName, value3, info, fUpdate);
      }
      panel2.addSeparator();
      if (node22.onShowCustomPanelInfo)
        node22.onShowCustomPanelInfo(panel2);
      panel2.footer.innerHTML = "";
      panel2.addButton("Delete", function() {
        if (node22.block_delete)
          return;
        node22.graph.remove(node22);
        panel2.close();
      }).classList.add("delete");
    }
    panel2.inner_showCodePad = function(propname) {
      panel2.classList.remove("settings");
      panel2.classList.add("centered");
      panel2.alt_content.innerHTML = "<textarea class='code'></textarea>";
      var textarea = panel2.alt_content.querySelector("textarea");
      var fDoneWith = function() {
        panel2.toggleAltContent(false);
        panel2.toggleFooterVisibility(true);
        textarea.parentNode.removeChild(textarea);
        panel2.classList.add("settings");
        panel2.classList.remove("centered");
        inner_refresh();
      };
      textarea.value = node22.properties[propname];
      textarea.addEventListener("keydown", function(e) {
        if (e.code == "Enter" && e.ctrlKey) {
          node22.setProperty(propname, textarea.value);
          fDoneWith();
        }
      });
      panel2.toggleAltContent(true);
      panel2.toggleFooterVisibility(false);
      textarea.style.height = "calc(100% - 40px)";
      var assign2 = panel2.addButton("Assign", function() {
        node22.setProperty(propname, textarea.value);
        fDoneWith();
      });
      panel2.alt_content.appendChild(assign2);
      var button = panel2.addButton("Close", fDoneWith);
      button.style.float = "right";
      panel2.alt_content.appendChild(button);
    };
    inner_refresh();
    this.canvas.parentNode.appendChild(panel2);
  };
  LGraphCanvas.prototype.showSubgraphPropertiesDialog = function(node22) {
    console.log("showing subgraph properties dialog");
    var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
    if (old_panel)
      old_panel.close();
    var panel2 = this.createPanel("Subgraph Inputs", { closable: true, width: 500 });
    panel2.node = node22;
    panel2.classList.add("subgraph_dialog");
    function inner_refresh() {
      panel2.clear();
      if (node22.inputs)
        for (var i2 = 0; i2 < node22.inputs.length; ++i2) {
          var input = node22.inputs[i2];
          if (input.not_subgraph_input)
            continue;
          var html2 = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
          var elem2 = panel2.addHTML(html2, "subgraph_property");
          elem2.dataset["name"] = input.name;
          elem2.dataset["slot"] = i2;
          elem2.querySelector(".name").innerText = input.name;
          elem2.querySelector(".type").innerText = input.type;
          elem2.querySelector("button").addEventListener("click", function(e) {
            node22.removeInput(Number(this.parentNode.dataset["slot"]));
            inner_refresh();
          });
        }
    }
    var html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
    var elem = panel2.addHTML(html, "subgraph_property extra", true);
    elem.querySelector("button").addEventListener("click", function(e) {
      var elem2 = this.parentNode;
      var name = elem2.querySelector(".name").value;
      var type = elem2.querySelector(".type").value;
      if (!name || node22.findInputSlot(name) != -1)
        return;
      node22.addInput(name, type);
      elem2.querySelector(".name").value = "";
      elem2.querySelector(".type").value = "";
      inner_refresh();
    });
    inner_refresh();
    this.canvas.parentNode.appendChild(panel2);
    return panel2;
  };
  LGraphCanvas.prototype.showSubgraphPropertiesDialogRight = function(node22) {
    var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");
    if (old_panel)
      old_panel.close();
    var panel2 = this.createPanel("Subgraph Outputs", { closable: true, width: 500 });
    panel2.node = node22;
    panel2.classList.add("subgraph_dialog");
    function inner_refresh() {
      panel2.clear();
      if (node22.outputs)
        for (var i2 = 0; i2 < node22.outputs.length; ++i2) {
          var input = node22.outputs[i2];
          if (input.not_subgraph_output)
            continue;
          var html2 = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>";
          var elem2 = panel2.addHTML(html2, "subgraph_property");
          elem2.dataset["name"] = input.name;
          elem2.dataset["slot"] = i2;
          elem2.querySelector(".name").innerText = input.name;
          elem2.querySelector(".type").innerText = input.type;
          elem2.querySelector("button").addEventListener("click", function(e) {
            node22.removeOutput(Number(this.parentNode.dataset["slot"]));
            inner_refresh();
          });
        }
    }
    var html = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>";
    var elem = panel2.addHTML(html, "subgraph_property extra", true);
    elem.querySelector(".name").addEventListener("keydown", function(e) {
      if (e.keyCode == 13) {
        addOutput.apply(this);
      }
    });
    elem.querySelector("button").addEventListener("click", function(e) {
      addOutput.apply(this);
    });
    function addOutput() {
      var elem2 = this.parentNode;
      var name = elem2.querySelector(".name").value;
      var type = elem2.querySelector(".type").value;
      if (!name || node22.findOutputSlot(name) != -1)
        return;
      node22.addOutput(name, type);
      elem2.querySelector(".name").value = "";
      elem2.querySelector(".type").value = "";
      inner_refresh();
    }
    inner_refresh();
    this.canvas.parentNode.appendChild(panel2);
    return panel2;
  };
  LGraphCanvas.prototype.checkPanels = function() {
    if (!this.canvas)
      return;
    var panels2 = this.canvas.parentNode.querySelectorAll(".litegraph.dialog");
    for (var i2 = 0; i2 < panels2.length; ++i2) {
      var panel2 = panels2[i2];
      if (!panel2.node)
        continue;
      if (!panel2.node.graph || panel2.graph != this.graph)
        panel2.close();
    }
  };
  LGraphCanvas.onMenuNodeCollapse = function(value3, options3, e, menu, node22) {
    node22.graph.beforeChange(
      /*?*/
    );
    var fApplyMultiNode = function(node3) {
      node3.collapse();
    };
    var graphcanvas = LGraphCanvas.active_canvas;
    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22);
    } else {
      for (var i2 in graphcanvas.selected_nodes) {
        fApplyMultiNode(graphcanvas.selected_nodes[i2]);
      }
    }
    node22.graph.afterChange(
      /*?*/
    );
  };
  LGraphCanvas.onMenuNodePin = function(value3, options3, e, menu, node22) {
    node22.pin();
  };
  LGraphCanvas.onMenuNodeMode = function(value3, options3, e, menu, node22) {
    new LiteGraph.ContextMenu(
      LiteGraph.NODE_MODES,
      { event: e, callback: inner_clicked, parentMenu: menu, node: node22 }
    );
    function inner_clicked(v2) {
      if (!node22) {
        return;
      }
      var kV = Object.values(LiteGraph.NODE_MODES).indexOf(v2);
      var fApplyMultiNode = function(node3) {
        if (kV >= 0 && LiteGraph.NODE_MODES[kV])
          node3.changeMode(kV);
        else {
          console.warn("unexpected mode: " + v2);
          node3.changeMode(LiteGraph.ALWAYS);
        }
      };
      var graphcanvas = LGraphCanvas.active_canvas;
      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
        fApplyMultiNode(node22);
      } else {
        for (var i2 in graphcanvas.selected_nodes) {
          fApplyMultiNode(graphcanvas.selected_nodes[i2]);
        }
      }
    }
    return false;
  };
  LGraphCanvas.onMenuNodeColors = function(value3, options3, e, menu, node22) {
    if (!node22) {
      throw "no node for color";
    }
    var values2 = [];
    values2.push({
      value: null,
      content: "<span style='display: block; padding-left: 4px;'>No color</span>"
    });
    for (var i2 in LGraphCanvas.node_colors) {
      var color = LGraphCanvas.node_colors[i2];
      var value3 = {
        value: i2,
        content: "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + color.color + "; background-color:" + color.bgcolor + "'>" + i2 + "</span>"
      };
      values2.push(value3);
    }
    new LiteGraph.ContextMenu(values2, {
      event: e,
      callback: inner_clicked,
      parentMenu: menu,
      node: node22
    });
    function inner_clicked(v2) {
      if (!node22) {
        return;
      }
      var color2 = v2.value ? LGraphCanvas.node_colors[v2.value] : null;
      var fApplyColor = function(node3) {
        if (color2) {
          if (node3.constructor === LiteGraph.LGraphGroup) {
            node3.color = color2.groupcolor;
          } else {
            node3.color = color2.color;
            node3.bgcolor = color2.bgcolor;
          }
        } else {
          delete node3.color;
          delete node3.bgcolor;
        }
      };
      var graphcanvas = LGraphCanvas.active_canvas;
      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
        fApplyColor(node22);
      } else {
        for (var i3 in graphcanvas.selected_nodes) {
          fApplyColor(graphcanvas.selected_nodes[i3]);
        }
      }
      node22.setDirtyCanvas(true, true);
    }
    return false;
  };
  LGraphCanvas.onMenuNodeShapes = function(value3, options3, e, menu, node22) {
    if (!node22) {
      throw "no node passed";
    }
    new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {
      event: e,
      callback: inner_clicked,
      parentMenu: menu,
      node: node22
    });
    function inner_clicked(v2) {
      if (!node22) {
        return;
      }
      node22.graph.beforeChange(
        /*?*/
      );
      var fApplyMultiNode = function(node3) {
        node3.shape = v2;
      };
      var graphcanvas = LGraphCanvas.active_canvas;
      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
        fApplyMultiNode(node22);
      } else {
        for (var i2 in graphcanvas.selected_nodes) {
          fApplyMultiNode(graphcanvas.selected_nodes[i2]);
        }
      }
      node22.graph.afterChange(
        /*?*/
      );
      node22.setDirtyCanvas(true);
    }
    return false;
  };
  LGraphCanvas.onMenuNodeRemove = function(value3, options3, e, menu, node22) {
    if (!node22) {
      throw "no node passed";
    }
    var graph = node22.graph;
    graph.beforeChange();
    var fApplyMultiNode = function(node3) {
      if (node3.removable === false) {
        return;
      }
      graph.remove(node3);
    };
    var graphcanvas = LGraphCanvas.active_canvas;
    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22);
    } else {
      for (var i2 in graphcanvas.selected_nodes) {
        fApplyMultiNode(graphcanvas.selected_nodes[i2]);
      }
    }
    graph.afterChange();
    node22.setDirtyCanvas(true, true);
  };
  LGraphCanvas.onMenuNodeToSubgraph = function(value3, options3, e, menu, node22) {
    var graph = node22.graph;
    var graphcanvas = LGraphCanvas.active_canvas;
    if (!graphcanvas)
      return;
    var nodes_list = Object.values(graphcanvas.selected_nodes || {});
    if (!nodes_list.length)
      nodes_list = [node22];
    var subgraph_node = LiteGraph.createNode("graph/subgraph");
    subgraph_node.pos = node22.pos.concat();
    graph.add(subgraph_node);
    subgraph_node.buildFromNodes(nodes_list);
    graphcanvas.deselectAllNodes();
    node22.setDirtyCanvas(true, true);
  };
  LGraphCanvas.onMenuNodeClone = function(value3, options3, e, menu, node22) {
    node22.graph.beforeChange();
    var newSelected = {};
    var fApplyMultiNode = function(node3) {
      if (node3.clonable === false) {
        return;
      }
      var newnode = node3.clone();
      if (!newnode) {
        return;
      }
      newnode.pos = [node3.pos[0] + 5, node3.pos[1] + 5];
      node3.graph.add(newnode);
      newSelected[newnode.id] = newnode;
    };
    var graphcanvas = LGraphCanvas.active_canvas;
    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {
      fApplyMultiNode(node22);
    } else {
      for (var i2 in graphcanvas.selected_nodes) {
        fApplyMultiNode(graphcanvas.selected_nodes[i2]);
      }
    }
    if (Object.keys(newSelected).length) {
      graphcanvas.selectNodes(newSelected);
    }
    node22.graph.afterChange();
    node22.setDirtyCanvas(true, true);
  };
  LGraphCanvas.node_colors = {
    red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" },
    brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" },
    green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" },
    blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" },
    pale_blue: {
      color: "#2a363b",
      bgcolor: "#3f5159",
      groupcolor: "#3f789e"
    },
    cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" },
    purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" },
    yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" },
    black: { color: "#222", bgcolor: "#000", groupcolor: "#444" }
  };
  LGraphCanvas.prototype.getCanvasMenuOptions = function() {
    var options3 = null;
    if (this.getMenuOptions) {
      options3 = this.getMenuOptions();
    } else {
      options3 = [
        {
          content: "Add Node",
          has_submenu: true,
          callback: LGraphCanvas.onMenuAdd
        },
        { content: "Add Group", callback: LGraphCanvas.onGroupAdd }
        //{ content: "Arrange", callback: that.graph.arrange },
        //{content:"Collapse All", callback: LGraphCanvas.onMenuCollapseAll }
      ];
      if (Object.keys(this.selected_nodes).length > 1) {
        options3.push({
          content: "Align",
          has_submenu: true,
          callback: LGraphCanvas.onGroupAlign
        });
      }
      if (this._graph_stack && this._graph_stack.length > 0) {
        options3.push(null, {
          content: "Close subgraph",
          callback: this.closeSubgraph.bind(this)
        });
      }
    }
    if (this.getExtraMenuOptions) {
      var extra = this.getExtraMenuOptions(this, options3);
      if (extra) {
        options3 = options3.concat(extra);
      }
    }
    return options3;
  };
  LGraphCanvas.prototype.getNodeMenuOptions = function(node22) {
    var _a2;
    var options3 = null;
    if (node22.getMenuOptions) {
      options3 = node22.getMenuOptions(this);
    } else {
      options3 = [
        {
          content: "Inputs",
          has_submenu: true,
          disabled: true,
          callback: LGraphCanvas.showMenuNodeOptionalInputs
        },
        {
          content: "Outputs",
          has_submenu: true,
          disabled: true,
          callback: LGraphCanvas.showMenuNodeOptionalOutputs
        },
        null,
        {
          content: "Properties",
          has_submenu: true,
          callback: LGraphCanvas.onShowMenuNodeProperties
        },
        {
          content: "Properties Panel",
          callback: function(item, options22, e, menu, node3) {
            LGraphCanvas.active_canvas.showShowNodePanel(node3);
          }
        },
        null,
        {
          content: "Title",
          callback: LGraphCanvas.onShowPropertyEditor
        },
        {
          content: "Mode",
          has_submenu: true,
          callback: LGraphCanvas.onMenuNodeMode
        }
      ];
      if (node22.resizable !== false) {
        options3.push({
          content: "Resize",
          callback: LGraphCanvas.onMenuResizeNode
        });
      }
      options3.push(
        {
          content: "Collapse",
          callback: LGraphCanvas.onMenuNodeCollapse
        },
        {
          content: ((_a2 = node22.flags) == null ? void 0 : _a2.pinned) ? "Unpin" : "Pin",
          callback: LGraphCanvas.onMenuNodePin
        },
        {
          content: "Colors",
          has_submenu: true,
          callback: LGraphCanvas.onMenuNodeColors
        },
        {
          content: "Shapes",
          has_submenu: true,
          callback: LGraphCanvas.onMenuNodeShapes
        },
        null
      );
    }
    if (node22.onGetInputs) {
      var inputs = node22.onGetInputs();
      if (inputs && inputs.length) {
        options3[0].disabled = false;
      }
    }
    if (node22.onGetOutputs) {
      var outputs = node22.onGetOutputs();
      if (outputs && outputs.length) {
        options3[1].disabled = false;
      }
    }
    if (node22.getExtraMenuOptions) {
      var extra = node22.getExtraMenuOptions(this, options3);
      if (extra) {
        extra.push(null);
        options3 = extra.concat(options3);
      }
    }
    if (node22.clonable !== false) {
      options3.push({
        content: "Clone",
        callback: LGraphCanvas.onMenuNodeClone
      });
    }
    if (Object.keys(this.selected_nodes).length > 1) {
      options3.push({
        content: "Align Selected To",
        has_submenu: true,
        callback: LGraphCanvas.onNodeAlign
      });
    }
    options3.push(null, {
      content: "Remove",
      disabled: !(node22.removable !== false && !node22.block_delete),
      callback: LGraphCanvas.onMenuNodeRemove
    });
    if (node22.graph && node22.graph.onGetNodeMenuOptions) {
      node22.graph.onGetNodeMenuOptions(options3, node22);
    }
    return options3;
  };
  LGraphCanvas.prototype.getGroupMenuOptions = function(node22) {
    var o = [
      { content: "Title", callback: LGraphCanvas.onShowPropertyEditor },
      {
        content: "Color",
        has_submenu: true,
        callback: LGraphCanvas.onMenuNodeColors
      },
      {
        content: "Font size",
        property: "font_size",
        type: "Number",
        callback: LGraphCanvas.onShowPropertyEditor
      },
      null,
      { content: "Remove", callback: LGraphCanvas.onMenuNodeRemove }
    ];
    return o;
  };
  LGraphCanvas.prototype.processContextMenu = function(node22, event2) {
    var that2 = this;
    var canvas = LGraphCanvas.active_canvas;
    var ref_window2 = canvas.getCanvasWindow();
    var menu_info = null;
    var options3 = {
      event: event2,
      callback: inner_option_clicked,
      extra: node22
    };
    if (node22)
      options3.title = node22.type;
    var slot = null;
    if (node22) {
      slot = node22.getSlotInPosition(event2.canvasX, event2.canvasY);
      LGraphCanvas.active_node = node22;
    }
    if (slot) {
      menu_info = [];
      if (node22.getSlotMenuOptions) {
        menu_info = node22.getSlotMenuOptions(slot);
      } else {
        if (slot && slot.output && slot.output.links && slot.output.links.length) {
          menu_info.push({ content: "Disconnect Links", slot });
        }
        var _slot = slot.input || slot.output;
        if (_slot.removable) {
          menu_info.push(
            _slot.locked ? "Cannot remove" : { content: "Remove Slot", slot }
          );
        }
        if (!_slot.nameLocked) {
          menu_info.push({ content: "Rename Slot", slot });
        }
      }
      options3.title = (slot.input ? slot.input.type : slot.output.type) || "*";
      if (slot.input && slot.input.type == LiteGraph.ACTION) {
        options3.title = "Action";
      }
      if (slot.output && slot.output.type == LiteGraph.EVENT) {
        options3.title = "Event";
      }
    } else {
      if (node22) {
        menu_info = this.getNodeMenuOptions(node22);
      } else {
        menu_info = this.getCanvasMenuOptions();
        var group = this.graph.getGroupOnPos(
          event2.canvasX,
          event2.canvasY
        );
        if (group) {
          menu_info.push(null, {
            content: "Edit Group",
            has_submenu: true,
            submenu: {
              title: "Group",
              extra: group,
              options: this.getGroupMenuOptions(group)
            }
          });
        }
      }
    }
    if (!menu_info) {
      return;
    }
    new LiteGraph.ContextMenu(menu_info, options3, ref_window2);
    function inner_option_clicked(v2, options22, e) {
      if (!v2) {
        return;
      }
      if (v2.content == "Remove Slot") {
        var info = v2.slot;
        node22.graph.beforeChange();
        if (info.input) {
          node22.removeInput(info.slot);
        } else if (info.output) {
          node22.removeOutput(info.slot);
        }
        node22.graph.afterChange();
        return;
      } else if (v2.content == "Disconnect Links") {
        var info = v2.slot;
        node22.graph.beforeChange();
        if (info.output) {
          node22.disconnectOutput(info.slot);
        } else if (info.input) {
          node22.disconnectInput(info.slot);
        }
        node22.graph.afterChange();
        return;
      } else if (v2.content == "Rename Slot") {
        var info = v2.slot;
        var slot_info = info.input ? node22.getInputInfo(info.slot) : node22.getOutputInfo(info.slot);
        var dialog = that2.createDialog(
          "<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>",
          options22
        );
        var input = dialog.querySelector("input");
        if (input && slot_info) {
          input.value = slot_info.label || "";
        }
        var inner = function() {
          node22.graph.beforeChange();
          if (input.value) {
            if (slot_info) {
              slot_info.label = input.value;
            }
            that2.setDirty(true);
          }
          dialog.close();
          node22.graph.afterChange();
        };
        dialog.querySelector("button").addEventListener("click", inner);
        input.addEventListener("keydown", function(e2) {
          dialog.is_modified = true;
          if (e2.keyCode == 27) {
            dialog.close();
          } else if (e2.keyCode == 13) {
            inner();
          } else if (e2.keyCode != 13 && e2.target.localName != "textarea") {
            return;
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        input.focus();
      }
    }
  };
  if (typeof window != "undefined" && window.CanvasRenderingContext2D && !window.CanvasRenderingContext2D.prototype.roundRect) {
    window.CanvasRenderingContext2D.prototype.roundRect = function(x2, y2, w2, h2, radius, radius_low) {
      var top_left_radius = 0;
      var top_right_radius = 0;
      var bottom_left_radius = 0;
      var bottom_right_radius = 0;
      if (radius === 0) {
        this.rect(x2, y2, w2, h2);
        return;
      }
      if (radius_low === void 0)
        radius_low = radius;
      if (radius != null && radius.constructor === Array) {
        if (radius.length == 1)
          top_left_radius = top_right_radius = bottom_left_radius = bottom_right_radius = radius[0];
        else if (radius.length == 2) {
          top_left_radius = bottom_right_radius = radius[0];
          top_right_radius = bottom_left_radius = radius[1];
        } else if (radius.length == 4) {
          top_left_radius = radius[0];
          top_right_radius = radius[1];
          bottom_left_radius = radius[2];
          bottom_right_radius = radius[3];
        } else
          return;
      } else {
        top_left_radius = radius || 0;
        top_right_radius = radius || 0;
        bottom_left_radius = radius_low || 0;
        bottom_right_radius = radius_low || 0;
      }
      this.moveTo(x2 + top_left_radius, y2);
      this.lineTo(x2 + w2 - top_right_radius, y2);
      this.quadraticCurveTo(x2 + w2, y2, x2 + w2, y2 + top_right_radius);
      this.lineTo(x2 + w2, y2 + h2 - bottom_right_radius);
      this.quadraticCurveTo(
        x2 + w2,
        y2 + h2,
        x2 + w2 - bottom_right_radius,
        y2 + h2
      );
      this.lineTo(x2 + bottom_right_radius, y2 + h2);
      this.quadraticCurveTo(x2, y2 + h2, x2, y2 + h2 - bottom_left_radius);
      this.lineTo(x2, y2 + bottom_left_radius);
      this.quadraticCurveTo(x2, y2, x2 + top_left_radius, y2);
    };
  }
  function compareObjects(a, b) {
    for (var i2 in a) {
      if (a[i2] != b[i2]) {
        return false;
      }
    }
    return true;
  }
  LiteGraph.compareObjects = compareObjects;
  function distance(a, b) {
    return Math.sqrt(
      (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])
    );
  }
  LiteGraph.distance = distance;
  function colorToString(c) {
    return "rgba(" + Math.round(c[0] * 255).toFixed() + "," + Math.round(c[1] * 255).toFixed() + "," + Math.round(c[2] * 255).toFixed() + "," + (c.length == 4 ? c[3].toFixed(2) : "1.0") + ")";
  }
  LiteGraph.colorToString = colorToString;
  function isInsideRectangle(x2, y2, left, top, width2, height) {
    if (left < x2 && left + width2 > x2 && top < y2 && top + height > y2) {
      return true;
    }
    return false;
  }
  LiteGraph.isInsideRectangle = isInsideRectangle;
  function growBounding(bounding, x2, y2) {
    if (x2 < bounding[0]) {
      bounding[0] = x2;
    } else if (x2 > bounding[2]) {
      bounding[2] = x2;
    }
    if (y2 < bounding[1]) {
      bounding[1] = y2;
    } else if (y2 > bounding[3]) {
      bounding[3] = y2;
    }
  }
  LiteGraph.growBounding = growBounding;
  function isInsideBounding(p2, bb) {
    if (p2[0] < bb[0][0] || p2[1] < bb[0][1] || p2[0] > bb[1][0] || p2[1] > bb[1][1]) {
      return false;
    }
    return true;
  }
  LiteGraph.isInsideBounding = isInsideBounding;
  function overlapBounding(a, b) {
    var A_end_x = a[0] + a[2];
    var A_end_y = a[1] + a[3];
    var B_end_x = b[0] + b[2];
    var B_end_y = b[1] + b[3];
    if (a[0] > B_end_x || a[1] > B_end_y || A_end_x < b[0] || A_end_y < b[1]) {
      return false;
    }
    return true;
  }
  LiteGraph.overlapBounding = overlapBounding;
  function hex2num(hex) {
    if (hex.charAt(0) == "#") {
      hex = hex.slice(1);
    }
    hex = hex.toUpperCase();
    var hex_alphabets = "0123456789ABCDEF";
    var value3 = new Array(3);
    var k = 0;
    var int1, int2;
    for (var i2 = 0; i2 < 6; i2 += 2) {
      int1 = hex_alphabets.indexOf(hex.charAt(i2));
      int2 = hex_alphabets.indexOf(hex.charAt(i2 + 1));
      value3[k] = int1 * 16 + int2;
      k++;
    }
    return value3;
  }
  LiteGraph.hex2num = hex2num;
  function num2hex(triplet) {
    var hex_alphabets = "0123456789ABCDEF";
    var hex = "#";
    var int1, int2;
    for (var i2 = 0; i2 < 3; i2++) {
      int1 = triplet[i2] / 16;
      int2 = triplet[i2] % 16;
      hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);
    }
    return hex;
  }
  LiteGraph.num2hex = num2hex;
  function ContextMenu(values2, options3) {
    options3 = options3 || {};
    this.options = options3;
    var that2 = this;
    if (options3.parentMenu) {
      if (options3.parentMenu.constructor !== this.constructor) {
        console.error(
          "parentMenu must be of class ContextMenu, ignoring it"
        );
        options3.parentMenu = null;
      } else {
        this.parentMenu = options3.parentMenu;
        this.parentMenu.lock = true;
        this.parentMenu.current_submenu = this;
      }
    }
    var eventClass = null;
    if (options3.event)
      eventClass = options3.event.constructor.name;
    if (eventClass !== "MouseEvent" && eventClass !== "CustomEvent" && eventClass !== "PointerEvent") {
      console.error(
        "Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (" + eventClass + ")"
      );
      options3.event = null;
    }
    var root27 = document.createElement("div");
    root27.className = "litegraph litecontextmenu litemenubar-panel";
    if (options3.className) {
      root27.className += " " + options3.className;
    }
    root27.style.minWidth = 100;
    root27.style.minHeight = 100;
    root27.style.pointerEvents = "none";
    setTimeout(function() {
      root27.style.pointerEvents = "auto";
    }, 100);
    LiteGraph.pointerListenerAdd(
      root27,
      "up",
      function(e) {
        e.preventDefault();
        return true;
      },
      true
    );
    root27.addEventListener(
      "contextmenu",
      function(e) {
        if (e.button != 2) {
          return false;
        }
        e.preventDefault();
        return false;
      },
      true
    );
    LiteGraph.pointerListenerAdd(
      root27,
      "down",
      function(e) {
        if (e.button == 2) {
          that2.close();
          e.preventDefault();
          return true;
        }
      },
      true
    );
    function on_mouse_wheel(e) {
      var pos2 = parseInt(root27.style.top);
      root27.style.top = (pos2 + e.deltaY * options3.scroll_speed).toFixed() + "px";
      e.preventDefault();
      return true;
    }
    if (!options3.scroll_speed) {
      options3.scroll_speed = 0.1;
    }
    root27.addEventListener("wheel", on_mouse_wheel, true);
    root27.addEventListener("mousewheel", on_mouse_wheel, true);
    this.root = root27;
    if (options3.title) {
      var element = document.createElement("div");
      element.className = "litemenu-title";
      element.innerHTML = options3.title;
      root27.appendChild(element);
    }
    for (var i2 = 0; i2 < values2.length; i2++) {
      var name = values2.constructor == Array ? values2[i2] : i2;
      if (name != null && name.constructor !== String) {
        name = name.content === void 0 ? String(name) : name.content;
      }
      var value3 = values2[i2];
      this.addItem(name, value3, options3);
    }
    LiteGraph.pointerListenerAdd(root27, "enter", function(e) {
      if (root27.closing_timer) {
        clearTimeout(root27.closing_timer);
      }
    });
    var root_document = document;
    if (options3.event) {
      root_document = options3.event.target.ownerDocument;
    }
    if (!root_document) {
      root_document = document;
    }
    if (root_document.fullscreenElement)
      root_document.fullscreenElement.appendChild(root27);
    else
      root_document.body.appendChild(root27);
    var left = options3.left || 0;
    var top = options3.top || 0;
    if (options3.event) {
      left = options3.event.clientX - 10;
      top = options3.event.clientY - 10;
      if (options3.title) {
        top -= 20;
      }
      if (options3.parentMenu) {
        var rect = options3.parentMenu.root.getBoundingClientRect();
        left = rect.left + rect.width;
      }
      var body_rect = document.body.getBoundingClientRect();
      var root_rect = root27.getBoundingClientRect();
      if (body_rect.height == 0)
        console.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }");
      if (body_rect.width && left > body_rect.width - root_rect.width - 10) {
        left = body_rect.width - root_rect.width - 10;
      }
      if (body_rect.height && top > body_rect.height - root_rect.height - 10) {
        top = body_rect.height - root_rect.height - 10;
      }
    }
    root27.style.left = left + "px";
    root27.style.top = top + "px";
    if (options3.scale) {
      root27.style.transform = "scale(" + options3.scale + ")";
    }
  }
  ContextMenu.prototype.addItem = function(name, value3, options3) {
    var that2 = this;
    options3 = options3 || {};
    var element = document.createElement("div");
    element.className = "litemenu-entry submenu";
    var disabled2 = false;
    if (value3 === null) {
      element.classList.add("separator");
    } else {
      element.innerHTML = value3 && value3.title ? value3.title : name;
      element.value = value3;
      element.setAttribute("role", "menuitem");
      if (value3) {
        if (value3.disabled) {
          disabled2 = true;
          element.classList.add("disabled");
          element.setAttribute("aria-disabled", "true");
        }
        if (value3.submenu || value3.has_submenu) {
          element.classList.add("has_submenu");
          element.setAttribute("aria-haspopup", "true");
          element.setAttribute("aria-expanded", "false");
        }
      }
      if (typeof value3 == "function") {
        element.dataset["value"] = name;
        element.onclick_callback = value3;
      } else {
        element.dataset["value"] = value3;
      }
      if (value3.className) {
        element.className += " " + value3.className;
      }
    }
    this.root.appendChild(element);
    if (!disabled2) {
      element.addEventListener("click", inner_onclick);
    }
    if (!disabled2 && options3.autoopen) {
      LiteGraph.pointerListenerAdd(element, "enter", inner_over);
    }
    function setAriaExpanded() {
      const entries = that2.root.querySelectorAll("div.litemenu-entry.has_submenu");
      if (entries) {
        for (let i2 = 0; i2 < entries.length; i2++) {
          entries[i2].setAttribute("aria-expanded", "false");
        }
      }
      element.setAttribute("aria-expanded", "true");
    }
    function inner_over(e) {
      var value22 = this.value;
      if (!value22 || !value22.has_submenu) {
        return;
      }
      inner_onclick.call(this, e);
      setAriaExpanded();
    }
    function inner_onclick(e) {
      var value22 = this.value;
      var close_parent = true;
      if (that2.current_submenu) {
        that2.current_submenu.close(e);
      }
      if ((value22 == null ? void 0 : value22.has_submenu) || (value22 == null ? void 0 : value22.submenu)) {
        setAriaExpanded();
      }
      if (options3.callback) {
        var r = options3.callback.call(
          this,
          value22,
          options3,
          e,
          that2,
          options3.node
        );
        if (r === true) {
          close_parent = false;
        }
      }
      if (value22) {
        if (value22.callback && !options3.ignore_item_callbacks && value22.disabled !== true) {
          var r = value22.callback.call(
            this,
            value22,
            options3,
            e,
            that2,
            options3.extra
          );
          if (r === true) {
            close_parent = false;
          }
        }
        if (value22.submenu) {
          if (!value22.submenu.options) {
            throw "ContextMenu submenu needs options";
          }
          new that2.constructor(value22.submenu.options, {
            callback: value22.submenu.callback,
            event: e,
            parentMenu: that2,
            ignore_item_callbacks: value22.submenu.ignore_item_callbacks,
            title: value22.submenu.title,
            extra: value22.submenu.extra,
            autoopen: options3.autoopen
          });
          close_parent = false;
        }
      }
      if (close_parent && !that2.lock) {
        that2.close();
      }
    }
    return element;
  };
  ContextMenu.prototype.close = function(e, ignore_parent_menu) {
    if (this.root.parentNode) {
      this.root.parentNode.removeChild(this.root);
    }
    if (this.parentMenu && !ignore_parent_menu) {
      this.parentMenu.lock = false;
      this.parentMenu.current_submenu = null;
      if (e === void 0) {
        this.parentMenu.close();
      } else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {
        ContextMenu.trigger(this.parentMenu.root, LiteGraph.pointerevents_method + "leave", e);
      }
    }
    if (this.current_submenu) {
      this.current_submenu.close(e, true);
    }
    if (this.root.closing_timer) {
      clearTimeout(this.root.closing_timer);
    }
  };
  ContextMenu.trigger = function(element, event_name, params, origin) {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(event_name, true, true, params);
    evt.srcElement = origin;
    if (element.dispatchEvent) {
      element.dispatchEvent(evt);
    } else if (element.__events) {
      element.__events.dispatchEvent(evt);
    }
    return evt;
  };
  ContextMenu.prototype.getTopMenu = function() {
    if (this.options.parentMenu) {
      return this.options.parentMenu.getTopMenu();
    }
    return this;
  };
  ContextMenu.prototype.getFirstEvent = function() {
    if (this.options.parentMenu) {
      return this.options.parentMenu.getFirstEvent();
    }
    return this.options.event;
  };
  ContextMenu.isCursorOverElement = function(event2, element) {
    var left = event2.clientX;
    var top = event2.clientY;
    var rect = element.getBoundingClientRect();
    if (!rect) {
      return false;
    }
    if (top > rect.top && top < rect.top + rect.height && left > rect.left && left < rect.left + rect.width) {
      return true;
    }
    return false;
  };
  LiteGraph.ContextMenu = ContextMenu;
  LiteGraph.closeAllContextMenus = function(ref_window2) {
    ref_window2 = ref_window2 || window;
    var elements = ref_window2.document.querySelectorAll(".litecontextmenu");
    if (!elements.length) {
      return;
    }
    var result = [];
    for (var i2 = 0; i2 < elements.length; i2++) {
      result.push(elements[i2]);
    }
    for (var i2 = 0; i2 < result.length; i2++) {
      if (result[i2].close) {
        result[i2].close();
      } else if (result[i2].parentNode) {
        result[i2].parentNode.removeChild(result[i2]);
      }
    }
  };
  LiteGraph.extendClass = function(target, origin) {
    for (var i2 in origin) {
      if (target.hasOwnProperty(i2)) {
        continue;
      }
      target[i2] = origin[i2];
    }
    if (origin.prototype) {
      for (var i2 in origin.prototype) {
        if (!origin.prototype.hasOwnProperty(i2)) {
          continue;
        }
        if (target.prototype.hasOwnProperty(i2)) {
          continue;
        }
        if (origin.prototype.__lookupGetter__(i2)) {
          target.prototype.__defineGetter__(
            i2,
            origin.prototype.__lookupGetter__(i2)
          );
        } else {
          target.prototype[i2] = origin.prototype[i2];
        }
        if (origin.prototype.__lookupSetter__(i2)) {
          target.prototype.__defineSetter__(
            i2,
            origin.prototype.__lookupSetter__(i2)
          );
        }
      }
    }
  };
  function CurveEditor(points) {
    this.points = points;
    this.selected = -1;
    this.nearest = -1;
    this.size = null;
    this.must_update = true;
    this.margin = 5;
  }
  CurveEditor.sampleCurve = function(f, points) {
    if (!points)
      return;
    for (var i2 = 0; i2 < points.length - 1; ++i2) {
      var p2 = points[i2];
      var pn = points[i2 + 1];
      if (pn[0] < f)
        continue;
      var r = pn[0] - p2[0];
      if (Math.abs(r) < 1e-5)
        return p2[1];
      var local_f = (f - p2[0]) / r;
      return p2[1] * (1 - local_f) + pn[1] * local_f;
    }
    return 0;
  };
  CurveEditor.prototype.draw = function(ctx, size2, graphcanvas, background_color, line_color, inactive) {
    var points = this.points;
    if (!points)
      return;
    this.size = size2;
    var w2 = size2[0] - this.margin * 2;
    var h2 = size2[1] - this.margin * 2;
    line_color = line_color || "#666";
    ctx.save();
    ctx.translate(this.margin, this.margin);
    if (background_color) {
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, w2, h2);
      ctx.fillStyle = "#222";
      ctx.fillRect(w2 * 0.5, 0, 1, h2);
      ctx.strokeStyle = "#333";
      ctx.strokeRect(0, 0, w2, h2);
    }
    ctx.strokeStyle = line_color;
    if (inactive)
      ctx.globalAlpha = 0.5;
    ctx.beginPath();
    for (var i2 = 0; i2 < points.length; ++i2) {
      var p2 = points[i2];
      ctx.lineTo(p2[0] * w2, (1 - p2[1]) * h2);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
    if (!inactive)
      for (var i2 = 0; i2 < points.length; ++i2) {
        var p2 = points[i2];
        ctx.fillStyle = this.selected == i2 ? "#FFF" : this.nearest == i2 ? "#DDD" : "#AAA";
        ctx.beginPath();
        ctx.arc(p2[0] * w2, (1 - p2[1]) * h2, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    ctx.restore();
  };
  CurveEditor.prototype.onMouseDown = function(localpos, graphcanvas) {
    var points = this.points;
    if (!points)
      return;
    if (localpos[1] < 0)
      return;
    var w2 = this.size[0] - this.margin * 2;
    var h2 = this.size[1] - this.margin * 2;
    var x2 = localpos[0] - this.margin;
    var y2 = localpos[1] - this.margin;
    var pos2 = [x2, y2];
    var max_dist = 30 / graphcanvas.ds.scale;
    this.selected = this.getCloserPoint(pos2, max_dist);
    if (this.selected == -1) {
      var point = [x2 / w2, 1 - y2 / h2];
      points.push(point);
      points.sort(function(a, b) {
        return a[0] - b[0];
      });
      this.selected = points.indexOf(point);
      this.must_update = true;
    }
    if (this.selected != -1)
      return true;
  };
  CurveEditor.prototype.onMouseMove = function(localpos, graphcanvas) {
    var points = this.points;
    if (!points)
      return;
    var s = this.selected;
    if (s < 0)
      return;
    var x2 = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2);
    var y2 = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2);
    var curvepos = [localpos[0] - this.margin, localpos[1] - this.margin];
    var max_dist = 30 / graphcanvas.ds.scale;
    this._nearest = this.getCloserPoint(curvepos, max_dist);
    var point = points[s];
    if (point) {
      var is_edge_point = s == 0 || s == points.length - 1;
      if (!is_edge_point && (localpos[0] < -10 || localpos[0] > this.size[0] + 10 || localpos[1] < -10 || localpos[1] > this.size[1] + 10)) {
        points.splice(s, 1);
        this.selected = -1;
        return;
      }
      if (!is_edge_point)
        point[0] = clamp(x2, 0, 1);
      else
        point[0] = s == 0 ? 0 : 1;
      point[1] = 1 - clamp(y2, 0, 1);
      points.sort(function(a, b) {
        return a[0] - b[0];
      });
      this.selected = points.indexOf(point);
      this.must_update = true;
    }
  };
  CurveEditor.prototype.onMouseUp = function(localpos, graphcanvas) {
    this.selected = -1;
    return false;
  };
  CurveEditor.prototype.getCloserPoint = function(pos2, max_dist) {
    var points = this.points;
    if (!points)
      return -1;
    max_dist = max_dist || 30;
    var w2 = this.size[0] - this.margin * 2;
    var h2 = this.size[1] - this.margin * 2;
    var num = points.length;
    var p2 = [0, 0];
    var min_dist = 1e6;
    var closest = -1;
    for (var i2 = 0; i2 < num; ++i2) {
      var p3 = points[i2];
      p2[0] = p3[0] * w2;
      p2[1] = (1 - p3[1]) * h2;
      if (p2[0] < pos2[0])
        ;
      var dist2 = vec2.distance(pos2, p2);
      if (dist2 > min_dist || dist2 > max_dist)
        continue;
      closest = i2;
      min_dist = dist2;
    }
    return closest;
  };
  LiteGraph.CurveEditor = CurveEditor;
  LiteGraph.getParameterNames = function(func) {
    return (func + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean);
  };
  LiteGraph.pointerListenerAdd = function(oDOM, sEvIn, fCall, capture = false) {
    if (!oDOM || !oDOM.addEventListener || !sEvIn || typeof fCall !== "function") {
      return;
    }
    var sMethod = LiteGraph.pointerevents_method;
    var sEvent = sEvIn;
    if (sMethod == "pointer" && !window.PointerEvent) {
      console.warn("sMethod=='pointer' && !window.PointerEvent");
      console.log("Converting pointer[" + sEvent + "] : down move up cancel enter TO touchstart touchmove touchend, etc ..");
      switch (sEvent) {
        case "down": {
          sMethod = "touch";
          sEvent = "start";
          break;
        }
        case "move": {
          sMethod = "touch";
          break;
        }
        case "up": {
          sMethod = "touch";
          sEvent = "end";
          break;
        }
        case "cancel": {
          sMethod = "touch";
          break;
        }
        case "enter": {
          console.log("debug: Should I send a move event?");
          break;
        }
        default: {
          console.warn("PointerEvent not available in this browser ? The event " + sEvent + " would not be called");
        }
      }
    }
    switch (sEvent) {
      case "down":
      case "up":
      case "move":
      case "over":
      case "out":
      case "enter": {
        oDOM.addEventListener(sMethod + sEvent, fCall, capture);
      }
      case "leave":
      case "cancel":
      case "gotpointercapture":
      case "lostpointercapture": {
        if (sMethod != "mouse") {
          return oDOM.addEventListener(sMethod + sEvent, fCall, capture);
        }
      }
      default:
        return oDOM.addEventListener(sEvent, fCall, capture);
    }
  };
  LiteGraph.pointerListenerRemove = function(oDOM, sEvent, fCall, capture = false) {
    if (!oDOM || !oDOM.removeEventListener || !sEvent || typeof fCall !== "function") {
      return;
    }
    switch (sEvent) {
      case "down":
      case "up":
      case "move":
      case "over":
      case "out":
      case "enter": {
        if (LiteGraph.pointerevents_method == "pointer" || LiteGraph.pointerevents_method == "mouse") {
          oDOM.removeEventListener(LiteGraph.pointerevents_method + sEvent, fCall, capture);
        }
      }
      case "leave":
      case "cancel":
      case "gotpointercapture":
      case "lostpointercapture": {
        if (LiteGraph.pointerevents_method == "pointer") {
          return oDOM.removeEventListener(LiteGraph.pointerevents_method + sEvent, fCall, capture);
        }
      }
      default:
        return oDOM.removeEventListener(sEvent, fCall, capture);
    }
  };
  function clamp(v2, a, b) {
    return a > v2 ? a : b < v2 ? b : v2;
  }
  globalThis.clamp = clamp;
  if (typeof window != "undefined" && !window["requestAnimationFrame"]) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
      window.setTimeout(callback, 1e3 / 60);
    };
  }
})(globalExport);
const LiteGraph = globalExport.LiteGraph;
const LGraphES6 = globalExport.LGraph;
const LGraph = globalExport.LegacyLGraph;
const LLink = globalExport.LLink;
const LGraphNode = globalExport.LGraphNode;
const LGraphGroup = globalExport.LGraphGroup;
const DragAndScale = globalExport.DragAndScale;
const LGraphCanvas = globalExport.LGraphCanvas;
const ContextMenu = globalExport.ContextMenu;
const SIZE = Symbol();
function intersect(a, b) {
  const x2 = Math.max(a.x, b.x);
  const num1 = Math.min(a.x + a.width, b.x + b.width);
  const y2 = Math.max(a.y, b.y);
  const num2 = Math.min(a.y + a.height, b.y + b.height);
  if (num1 >= x2 && num2 >= y2) return [x2, y2, num1 - x2, num2 - y2];
  else return null;
}
function getClipPath(node3, element) {
  const selectedNode = Object.values(
    app$1.canvas.selected_nodes
  )[0];
  if (selectedNode && selectedNode !== node3) {
    const elRect = element.getBoundingClientRect();
    const MARGIN = 7;
    const scale = app$1.canvas.ds.scale;
    const bounding = selectedNode.getBounding();
    const intersection = intersect(
      {
        x: elRect.x / scale,
        y: elRect.y / scale,
        width: elRect.width / scale,
        height: elRect.height / scale
      },
      {
        x: selectedNode.pos[0] + app$1.canvas.ds.offset[0] - MARGIN,
        y: selectedNode.pos[1] + app$1.canvas.ds.offset[1] - LiteGraph.NODE_TITLE_HEIGHT - MARGIN,
        width: bounding[2] + MARGIN + MARGIN,
        height: bounding[3] + MARGIN + MARGIN
      }
    );
    if (!intersection) {
      return "";
    }
    const widgetRect = element.getBoundingClientRect();
    const clipX = elRect.left + intersection[0] - widgetRect.x / scale + "px";
    const clipY = elRect.top + intersection[1] - widgetRect.y / scale + "px";
    const clipWidth = intersection[2] + "px";
    const clipHeight = intersection[3] + "px";
    const path = `polygon(0% 0%, 0% 100%, ${clipX} 100%, ${clipX} ${clipY}, calc(${clipX} + ${clipWidth}) ${clipY}, calc(${clipX} + ${clipWidth}) calc(${clipY} + ${clipHeight}), ${clipX} calc(${clipY} + ${clipHeight}), ${clipX} 100%, 100% 100%, 100% 0%)`;
    return path;
  }
  return "";
}
function computeSize(size2) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  if (((_b = (_a2 = this.widgets) == null ? void 0 : _a2[0]) == null ? void 0 : _b.last_y) == null) return;
  let y2 = this.widgets[0].last_y;
  let freeSpace = size2[1] - y2;
  let widgetHeight = 0;
  let dom = [];
  for (const w2 of this.widgets) {
    if (w2.type === "converted-widget") {
      delete w2.computedHeight;
    } else if (w2.computeSize) {
      widgetHeight += w2.computeSize()[1] + 4;
    } else if (w2.element) {
      const styles = getComputedStyle(w2.element);
      let minHeight = (_e = (_d = (_c = w2.options).getMinHeight) == null ? void 0 : _d.call(_c)) != null ? _e : parseInt(styles.getPropertyValue("--comfy-widget-min-height"));
      let maxHeight = (_h = (_g = (_f = w2.options).getMaxHeight) == null ? void 0 : _g.call(_f)) != null ? _h : parseInt(styles.getPropertyValue("--comfy-widget-max-height"));
      let prefHeight = (_k = (_j = (_i = w2.options).getHeight) == null ? void 0 : _j.call(_i)) != null ? _k : styles.getPropertyValue("--comfy-widget-height");
      if ((_l = prefHeight.endsWith) == null ? void 0 : _l.call(prefHeight, "%")) {
        prefHeight = size2[1] * (parseFloat(prefHeight.substring(0, prefHeight.length - 1)) / 100);
      } else {
        prefHeight = parseInt(prefHeight);
        if (isNaN(minHeight)) {
          minHeight = prefHeight;
        }
      }
      if (isNaN(minHeight)) {
        minHeight = 50;
      }
      if (!isNaN(maxHeight)) {
        if (!isNaN(prefHeight)) {
          prefHeight = Math.min(prefHeight, maxHeight);
        } else {
          prefHeight = maxHeight;
        }
      }
      dom.push({
        minHeight,
        prefHeight,
        w: w2
      });
    } else {
      widgetHeight += LiteGraph.NODE_WIDGET_HEIGHT + 4;
    }
  }
  freeSpace -= widgetHeight;
  const prefGrow = [];
  const canGrow = [];
  let growBy = 0;
  for (const d of dom) {
    freeSpace -= d.minHeight;
    if (isNaN(d.prefHeight)) {
      canGrow.push(d);
      d.w.computedHeight = d.minHeight;
    } else {
      const diff = d.prefHeight - d.minHeight;
      if (diff > 0) {
        prefGrow.push(d);
        growBy += diff;
        d.diff = diff;
      } else {
        d.w.computedHeight = d.minHeight;
      }
    }
  }
  if (this.imgs && !this.widgets.find((w2) => w2.name === ANIM_PREVIEW_WIDGET)) {
    freeSpace -= 220;
  }
  this.freeWidgetSpace = freeSpace;
  if (freeSpace < 0) {
    size2[1] -= freeSpace;
    this.graph.setDirtyCanvas(true);
  } else {
    const growDiff = freeSpace - growBy;
    if (growDiff > 0) {
      freeSpace = growDiff;
      for (const d of prefGrow) {
        d.w.computedHeight = d.prefHeight;
      }
    } else {
      const shared = -growDiff / prefGrow.length;
      for (const d of prefGrow) {
        d.w.computedHeight = d.prefHeight - shared;
      }
      freeSpace = 0;
    }
    if (freeSpace > 0 && canGrow.length) {
      const shared = freeSpace / canGrow.length;
      for (const d of canGrow) {
        d.w.computedHeight += shared;
      }
    }
  }
  for (const w2 of this.widgets) {
    w2.y = y2;
    if (w2.computedHeight) {
      y2 += w2.computedHeight;
    } else if (w2.computeSize) {
      y2 += w2.computeSize()[1] + 4;
    } else {
      y2 += LiteGraph.NODE_WIDGET_HEIGHT + 4;
    }
  }
}
const elementWidgets = /* @__PURE__ */ new Set();
const computeVisibleNodes = LGraphCanvas.prototype.computeVisibleNodes;
LGraphCanvas.prototype.computeVisibleNodes = function() {
  var _a2, _b;
  const visibleNodes = computeVisibleNodes.apply(this, arguments);
  for (const node3 of app$1.graph._nodes) {
    if (elementWidgets.has(node3)) {
      const hidden = visibleNodes.indexOf(node3) === -1;
      for (const w2 of node3.widgets) {
        if (w2.element) {
          w2.element.hidden = hidden;
          w2.element.style.display = hidden ? "none" : void 0;
          if (hidden) {
            (_b = (_a2 = w2.options).onHide) == null ? void 0 : _b.call(_a2, w2);
          }
        }
      }
    }
  }
  return visibleNodes;
};
let enableDomClipping = true;
function addDomClippingSetting() {
  app$1.ui.settings.addSetting({
    id: "Comfy.DOMClippingEnabled",
    name: "Enable DOM element clipping (enabling may reduce performance)",
    type: "boolean",
    defaultValue: enableDomClipping,
    onChange(value3) {
      enableDomClipping = !!value3;
    }
  });
}
LGraphNode.prototype.addDOMWidget = function(name, type, element, options3) {
  var _a2, _b, _c, _d, _e;
  options3 = __spreadValues2({ hideOnZoom: true, selectOn: ["focus", "click"] }, options3);
  if (!element.parentElement) {
    app$1.canvasContainer.append(element);
  }
  element.hidden = true;
  element.style.display = "none";
  let mouseDownHandler;
  if (element.blur) {
    mouseDownHandler = (event2) => {
      if (!element.contains(event2.target)) {
        element.blur();
      }
    };
    document.addEventListener("mousedown", mouseDownHandler);
  }
  const { nodeData } = this.constructor;
  const tooltip = (_e = (_d = (_c = (_a2 = nodeData == null ? void 0 : nodeData.input.required) == null ? void 0 : _a2[name]) != null ? _c : (_b = nodeData == null ? void 0 : nodeData.input.optional) == null ? void 0 : _b[name]) == null ? void 0 : _d[1]) == null ? void 0 : _e.tooltip;
  if (tooltip && !element.title) {
    element.title = tooltip;
  }
  const widget = {
    type,
    name,
    get value() {
      var _a3, _b2;
      return (_b2 = (_a3 = options3.getValue) == null ? void 0 : _a3.call(options3)) != null ? _b2 : void 0;
    },
    set value(v2) {
      var _a3, _b2;
      (_a3 = options3.setValue) == null ? void 0 : _a3.call(options3, v2);
      (_b2 = widget.callback) == null ? void 0 : _b2.call(widget, widget.value);
    },
    draw: function(ctx, node3, widgetWidth, y2, widgetHeight) {
      var _a3, _b2, _c2, _d2, _e2, _f;
      if (widget.computedHeight == null) {
        computeSize.call(node3, node3.size);
      }
      const hidden = ((_a3 = node3.flags) == null ? void 0 : _a3.collapsed) || !!options3.hideOnZoom && app$1.canvas.ds.scale < 0.5 || widget.computedHeight <= 0 || widget.type === "converted-widget" || widget.type === "hidden";
      element.hidden = hidden;
      element.style.display = hidden ? "none" : null;
      if (hidden) {
        (_c2 = (_b2 = widget.options).onHide) == null ? void 0 : _c2.call(_b2, widget);
        return;
      }
      const margin = 10;
      const elRect = ctx.canvas.getBoundingClientRect();
      const transform2 = new DOMMatrix().scaleSelf(
        elRect.width / ctx.canvas.width,
        elRect.height / ctx.canvas.height
      ).multiplySelf(ctx.getTransform()).translateSelf(margin, margin + y2);
      const scale = new DOMMatrix().scaleSelf(transform2.a, transform2.d);
      Object.assign(element.style, {
        transformOrigin: "0 0",
        transform: scale,
        left: `${transform2.a + transform2.e}px`,
        top: `${transform2.d + transform2.f}px`,
        width: `${widgetWidth - margin * 2}px`,
        height: `${((_d2 = widget.computedHeight) != null ? _d2 : 50) - margin * 2}px`,
        position: "absolute",
        // @ts-expect-error
        zIndex: app$1.graph._nodes.indexOf(node3)
      });
      if (enableDomClipping) {
        element.style.clipPath = getClipPath(node3, element);
        element.style.willChange = "clip-path";
      }
      (_f = (_e2 = this.options).onDraw) == null ? void 0 : _f.call(_e2, widget);
    },
    element,
    options: options3,
    onRemove() {
      if (mouseDownHandler) {
        document.removeEventListener("mousedown", mouseDownHandler);
      }
      element.remove();
    }
  };
  for (const evt of options3.selectOn) {
    element.addEventListener(evt, () => {
      app$1.canvas.selectNode(this);
      app$1.canvas.bringToFront(this);
    });
  }
  this.addCustomWidget(widget);
  elementWidgets.add(this);
  const collapse = this.collapse;
  this.collapse = function() {
    var _a3;
    collapse.apply(this, arguments);
    if ((_a3 = this.flags) == null ? void 0 : _a3.collapsed) {
      element.hidden = true;
      element.style.display = "none";
    }
  };
  const onRemoved = this.onRemoved;
  this.onRemoved = function() {
    element.remove();
    elementWidgets.delete(this);
    onRemoved == null ? void 0 : onRemoved.apply(this, arguments);
  };
  if (!this[SIZE]) {
    this[SIZE] = true;
    const onResize3 = this.onResize;
    this.onResize = function(size2) {
      var _a3, _b2;
      (_a3 = options3.beforeResize) == null ? void 0 : _a3.call(widget, this);
      computeSize.call(this, size2);
      onResize3 == null ? void 0 : onResize3.apply(this, arguments);
      (_b2 = options3.afterResize) == null ? void 0 : _b2.call(widget, this);
    };
  }
  return widget;
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.domWidget = window.comfyAPI.domWidget || {};
window.comfyAPI.domWidget.addDomClippingSetting = addDomClippingSetting;
let controlValueRunBefore = false;
function updateControlWidgetLabel(widget) {
  var _a2;
  let replacement = "after";
  let find2 = "before";
  if (controlValueRunBefore) {
    ;
    [find2, replacement] = [replacement, find2];
  }
  widget.label = ((_a2 = widget.label) != null ? _a2 : widget.name).replace(find2, replacement);
}
const IS_CONTROL_WIDGET = Symbol();
const HAS_EXECUTED = Symbol();
function getNumberDefaults(inputData, defaultStep, precision, enable_rounding) {
  let defaultVal = inputData[1]["default"];
  let { min, max, step, round } = inputData[1];
  if (defaultVal == void 0) defaultVal = 0;
  if (min == void 0) min = 0;
  if (max == void 0) max = 2048;
  if (step == void 0) step = defaultStep;
  if (precision == void 0) {
    precision = Math.max(-Math.floor(Math.log10(step)), 0);
  }
  if (enable_rounding && (round == void 0 || round === true)) {
    round = Math.round(1e6 * Math.pow(0.1, precision)) / 1e6;
  }
  return {
    val: defaultVal,
    config: { min, max, step: 10 * step, round, precision }
  };
}
function addValueControlWidget(node3, targetWidget, defaultValue = "randomize", values2, widgetName, inputData) {
  var _a2;
  let name = (_a2 = inputData[1]) == null ? void 0 : _a2.control_after_generate;
  if (typeof name !== "string") {
    name = widgetName;
  }
  const widgets = addValueControlWidgets(
    node3,
    targetWidget,
    defaultValue,
    {
      addFilterList: false,
      controlAfterGenerateName: name
    },
    inputData
  );
  return widgets[0];
}
function addValueControlWidgets(node3, targetWidget, defaultValue = "randomize", options3, inputData) {
  if (!defaultValue) defaultValue = "randomize";
  if (!options3) options3 = {};
  const getName = (defaultName, optionName) => {
    var _a2, _b, _c, _d;
    let name = defaultName;
    if (options3[optionName]) {
      name = options3[optionName];
    } else if (typeof ((_a2 = inputData == null ? void 0 : inputData[1]) == null ? void 0 : _a2[defaultName]) === "string") {
      name = (_b = inputData == null ? void 0 : inputData[1]) == null ? void 0 : _b[defaultName];
    } else if ((_c = inputData == null ? void 0 : inputData[1]) == null ? void 0 : _c.control_prefix) {
      name = ((_d = inputData == null ? void 0 : inputData[1]) == null ? void 0 : _d.control_prefix) + " " + name;
    }
    return name;
  };
  const widgets = [];
  const valueControl = node3.addWidget(
    "combo",
    getName("control_after_generate", "controlAfterGenerateName"),
    defaultValue,
    function() {
    },
    {
      values: ["fixed", "increment", "decrement", "randomize"],
      serialize: false
      // Don't include this in prompt.
    }
  );
  valueControl.tooltip = "Allows the linked widget to be changed automatically, for example randomizing the noise seed.";
  valueControl[IS_CONTROL_WIDGET] = true;
  updateControlWidgetLabel(valueControl);
  widgets.push(valueControl);
  const isCombo = targetWidget.type === "combo";
  let comboFilter;
  if (isCombo) {
    valueControl.options.values.push("increment-wrap");
  }
  if (isCombo && options3.addFilterList !== false) {
    comboFilter = node3.addWidget(
      "string",
      getName("control_filter_list", "controlFilterListName"),
      "",
      function() {
      },
      {
        serialize: false
        // Don't include this in prompt.
      }
    );
    updateControlWidgetLabel(comboFilter);
    comboFilter.tooltip = "Allows for filtering the list of values when changing the value via the control generate mode. Allows for RegEx matches in the format /abc/ to only filter to values containing 'abc'.";
    widgets.push(comboFilter);
  }
  const applyWidgetControl = () => {
    var v2 = valueControl.value;
    if (isCombo && v2 !== "fixed") {
      let values2 = targetWidget.options.values;
      const filter5 = comboFilter == null ? void 0 : comboFilter.value;
      if (filter5) {
        let check;
        if (filter5.startsWith("/") && filter5.endsWith("/")) {
          try {
            const regex = new RegExp(filter5.substring(1, filter5.length - 1));
            check = (item) => regex.test(item);
          } catch (error) {
            console.error(
              "Error constructing RegExp filter for node " + node3.id,
              filter5,
              error
            );
          }
        }
        if (!check) {
          const lower = filter5.toLocaleLowerCase();
          check = (item) => item.toLocaleLowerCase().includes(lower);
        }
        values2 = values2.filter((item) => check(item));
        if (!values2.length && targetWidget.options.values.length) {
          console.warn(
            "Filter for node " + node3.id + " has filtered out all items",
            filter5
          );
        }
      }
      let current_index = values2.indexOf(targetWidget.value);
      let current_length = values2.length;
      switch (v2) {
        case "increment":
          current_index += 1;
          break;
        case "increment-wrap":
          current_index += 1;
          if (current_index >= current_length) {
            current_index = 0;
          }
          break;
        case "decrement":
          current_index -= 1;
          break;
        case "randomize":
          current_index = Math.floor(Math.random() * current_length);
          break;
        default:
          break;
      }
      current_index = Math.max(0, current_index);
      current_index = Math.min(current_length - 1, current_index);
      if (current_index >= 0) {
        let value3 = values2[current_index];
        targetWidget.value = value3;
        targetWidget.callback(value3);
      }
    } else {
      let min = targetWidget.options.min;
      let max = targetWidget.options.max;
      max = Math.min(1125899906842624, max);
      min = Math.max(-1125899906842624, min);
      let range2 = (max - min) / (targetWidget.options.step / 10);
      switch (v2) {
        case "fixed":
          break;
        case "increment":
          targetWidget.value += targetWidget.options.step / 10;
          break;
        case "decrement":
          targetWidget.value -= targetWidget.options.step / 10;
          break;
        case "randomize":
          targetWidget.value = Math.floor(Math.random() * range2) * (targetWidget.options.step / 10) + min;
          break;
        default:
          break;
      }
      if (targetWidget.value < min) targetWidget.value = min;
      if (targetWidget.value > max) targetWidget.value = max;
      targetWidget.callback(targetWidget.value);
    }
  };
  valueControl.beforeQueued = () => {
    if (controlValueRunBefore) {
      if (valueControl[HAS_EXECUTED]) {
        applyWidgetControl();
      }
    }
    valueControl[HAS_EXECUTED] = true;
  };
  valueControl.afterQueued = () => {
    if (!controlValueRunBefore) {
      applyWidgetControl();
    }
  };
  return widgets;
}
function seedWidget(node3, inputName, inputData, app2, widgetName) {
  const seed = createIntWidget(node3, inputName, inputData, app2, true);
  const seedControl = addValueControlWidget(
    node3,
    seed.widget,
    "randomize",
    void 0,
    widgetName,
    inputData
  );
  seed.widget.linkedWidgets = [seedControl];
  return seed;
}
function createIntWidget(node3, inputName, inputData, app2, isSeedInput = false) {
  var _a2;
  const control = (_a2 = inputData[1]) == null ? void 0 : _a2.control_after_generate;
  if (!isSeedInput && control) {
    return seedWidget(
      node3,
      inputName,
      inputData,
      app2,
      typeof control === "string" ? control : void 0
    );
  }
  let widgetType = isSlider(inputData[1]["display"], app2);
  const { val, config } = getNumberDefaults(inputData, 1, 0, true);
  Object.assign(config, { precision: 0 });
  return {
    widget: node3.addWidget(
      widgetType,
      inputName,
      val,
      function(v2) {
        const s = this.options.step / 10;
        let sh = this.options.min % s;
        if (isNaN(sh)) {
          sh = 0;
        }
        this.value = Math.round((v2 - sh) / s) * s + sh;
      },
      config
    )
  };
}
function addMultilineWidget(node3, name, opts, app2) {
  const inputEl = document.createElement("textarea");
  inputEl.className = "comfy-multiline-input";
  inputEl.value = opts.defaultVal;
  inputEl.placeholder = opts.placeholder || name;
  inputEl.spellcheck = opts.spellcheck || false;
  const widget = node3.addDOMWidget(name, "customtext", inputEl, {
    getValue() {
      return inputEl.value;
    },
    setValue(v2) {
      inputEl.value = v2;
    }
  });
  widget.inputEl = inputEl;
  inputEl.addEventListener("input", () => {
    var _a2;
    (_a2 = widget.callback) == null ? void 0 : _a2.call(widget, widget.value);
  });
  return { minWidth: 400, minHeight: 200, widget };
}
function isSlider(display, app2) {
  if (app2.ui.settings.getSettingValue("Comfy.DisableSliders")) {
    return "number";
  }
  return display === "slider" ? "slider" : "number";
}
function initWidgets(app2) {
  app2.ui.settings.addSetting({
    id: "Comfy.WidgetControlMode",
    name: "Widget Value Control Mode",
    type: "combo",
    defaultValue: "after",
    options: ["before", "after"],
    tooltip: "Controls when widget values are updated (randomize/increment/decrement), either before the prompt is queued or after.",
    onChange(value3) {
      controlValueRunBefore = value3 === "before";
      for (const n of app2.graph._nodes) {
        if (!n.widgets) continue;
        for (const w2 of n.widgets) {
          if (w2[IS_CONTROL_WIDGET]) {
            updateControlWidgetLabel(w2);
            if (w2.linkedWidgets) {
              for (const l of w2.linkedWidgets) {
                updateControlWidgetLabel(l);
              }
            }
          }
        }
      }
      app2.graph.setDirtyCanvas(true);
    }
  });
}
const ComfyWidgets = {
  "INT:seed": seedWidget,
  "INT:noise_seed": seedWidget,
  FLOAT(node3, inputName, inputData, app2) {
    let widgetType = isSlider(inputData[1]["display"], app2);
    let precision = app2.ui.settings.getSettingValue(
      "Comfy.FloatRoundingPrecision"
    );
    let disable_rounding = app2.ui.settings.getSettingValue(
      "Comfy.DisableFloatRounding"
    );
    if (precision == 0) precision = void 0;
    const { val, config } = getNumberDefaults(
      inputData,
      0.5,
      precision,
      !disable_rounding
    );
    return {
      widget: node3.addWidget(
        widgetType,
        inputName,
        val,
        function(v2) {
          if (config.round) {
            this.value = Math.round((v2 + Number.EPSILON) / config.round) * config.round;
            if (this.value > config.max) this.value = config.max;
            if (this.value < config.min) this.value = config.min;
          } else {
            this.value = v2;
          }
        },
        config
      )
    };
  },
  INT(node3, inputName, inputData, app2) {
    return createIntWidget(node3, inputName, inputData, app2);
  },
  BOOLEAN(node3, inputName, inputData) {
    let defaultVal = false;
    let options3 = {};
    if (inputData[1]) {
      if (inputData[1].default) defaultVal = inputData[1].default;
      if (inputData[1].label_on) options3["on"] = inputData[1].label_on;
      if (inputData[1].label_off) options3["off"] = inputData[1].label_off;
    }
    return {
      widget: node3.addWidget("toggle", inputName, defaultVal, () => {
      }, options3)
    };
  },
  STRING(node3, inputName, inputData, app2) {
    const defaultVal = inputData[1].default || "";
    const multiline = !!inputData[1].multiline;
    let res;
    if (multiline) {
      res = addMultilineWidget(
        node3,
        inputName,
        __spreadValues2({ defaultVal }, inputData[1]),
        app2
      );
    } else {
      res = {
        widget: node3.addWidget("text", inputName, defaultVal, () => {
        }, {})
      };
    }
    if (inputData[1].dynamicPrompts != void 0)
      res.widget.dynamicPrompts = inputData[1].dynamicPrompts;
    return res;
  },
  COMBO(node3, inputName, inputData) {
    var _a2;
    const type = inputData[0];
    let defaultValue = type[0];
    if (inputData[1] && inputData[1].default) {
      defaultValue = inputData[1].default;
    }
    const res = {
      widget: node3.addWidget("combo", inputName, defaultValue, () => {
      }, {
        values: type
      })
    };
    if ((_a2 = inputData[1]) == null ? void 0 : _a2.control_after_generate) {
      res.widget.linkedWidgets = addValueControlWidgets(
        node3,
        res.widget,
        void 0,
        void 0,
        inputData
      );
    }
    return res;
  },
  IMAGEUPLOAD(node3, inputName, inputData, app2) {
    const imageWidget = node3.widgets.find(
      (w2) => {
        var _a2, _b;
        return w2.name === ((_b = (_a2 = inputData[1]) == null ? void 0 : _a2.widget) != null ? _b : "image");
      }
    );
    let uploadWidget;
    function showImage(name) {
      var _a2;
      const img = new Image();
      img.onload = () => {
        node3.imgs = [img];
        app2.graph.setDirtyCanvas(true);
      };
      let folder_separator = name.lastIndexOf("/");
      let subfolder = "";
      if (folder_separator > -1) {
        subfolder = name.substring(0, folder_separator);
        name = name.substring(folder_separator + 1);
      }
      img.src = api.apiURL(
        `/view?filename=${encodeURIComponent(name)}&type=input&subfolder=${subfolder}${app2.getPreviewFormatParam()}${app2.getRandParam()}`
      );
      (_a2 = node3.setSizeForImage) == null ? void 0 : _a2.call(node3);
    }
    var default_value = imageWidget.value;
    Object.defineProperty(imageWidget, "value", {
      set: function(value3) {
        this._real_value = value3;
      },
      get: function() {
        if (!this._real_value) {
          return default_value;
        }
        let value3 = this._real_value;
        if (value3.filename) {
          let real_value = value3;
          value3 = "";
          if (real_value.subfolder) {
            value3 = real_value.subfolder + "/";
          }
          value3 += real_value.filename;
          if (real_value.type && real_value.type !== "input")
            value3 += ` [${real_value.type}]`;
        }
        return value3;
      }
    });
    const cb = node3.callback;
    imageWidget.callback = function() {
      showImage(imageWidget.value);
      if (cb) {
        return cb.apply(this, arguments);
      }
    };
    requestAnimationFrame(() => {
      if (imageWidget.value) {
        showImage(imageWidget.value);
      }
    });
    function uploadFile(file, updateNode, pasted = false) {
      return __async(this, null, function* () {
        try {
          const body = new FormData();
          body.append("image", file);
          if (pasted) body.append("subfolder", "pasted");
          const resp = yield api.fetchApi("/upload/image", {
            method: "POST",
            body
          });
          if (resp.status === 200) {
            const data28 = yield resp.json();
            let path = data28.name;
            if (data28.subfolder) path = data28.subfolder + "/" + path;
            if (!imageWidget.options.values.includes(path)) {
              imageWidget.options.values.push(path);
            }
            if (updateNode) {
              showImage(path);
              imageWidget.value = path;
            }
          } else {
            alert(resp.status + " - " + resp.statusText);
          }
        } catch (error) {
          alert(error);
        }
      });
    }
    const fileInput2 = document.createElement("input");
    Object.assign(fileInput2, {
      type: "file",
      accept: "image/jpeg,image/png,image/webp",
      style: "display: none",
      onchange: () => __async(this, null, function* () {
        if (fileInput2.files.length) {
          yield uploadFile(fileInput2.files[0], true);
        }
      })
    });
    document.body.append(fileInput2);
    uploadWidget = node3.addWidget("button", inputName, "image", () => {
      fileInput2.click();
    });
    uploadWidget.label = "choose file to upload";
    uploadWidget.serialize = false;
    node3.onDragOver = function(e) {
      if (e.dataTransfer && e.dataTransfer.items) {
        const image = [...e.dataTransfer.items].find((f) => f.kind === "file");
        return !!image;
      }
      return false;
    };
    node3.onDragDrop = function(e) {
      console.log("onDragDrop called");
      let handled = false;
      for (const file of e.dataTransfer.files) {
        if (file.type.startsWith("image/")) {
          uploadFile(file, !handled);
          handled = true;
        }
      }
      return handled;
    };
    node3.pasteFile = function(file) {
      if (file.type.startsWith("image/")) {
        const is_pasted = file.name === "image.png" && file.lastModified - Date.now() < 2e3;
        uploadFile(file, true, is_pasted);
        return true;
      }
      return false;
    };
    return { widget: uploadWidget };
  }
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.widgets = window.comfyAPI.widgets || {};
window.comfyAPI.widgets.updateControlWidgetLabel = updateControlWidgetLabel;
window.comfyAPI.widgets.addValueControlWidget = addValueControlWidget;
window.comfyAPI.widgets.addValueControlWidgets = addValueControlWidgets;
window.comfyAPI.widgets.initWidgets = initWidgets;
window.comfyAPI.widgets.ComfyWidgets = ComfyWidgets;
const defaultGraph = {
  last_node_id: 9,
  last_link_id: 9,
  nodes: [
    {
      id: 7,
      type: "CLIPTextEncode",
      pos: [413, 389],
      size: [425.27801513671875, 180.6060791015625],
      flags: {},
      order: 3,
      mode: 0,
      inputs: [{ name: "clip", type: "CLIP", link: 5 }],
      outputs: [
        {
          name: "CONDITIONING",
          type: "CONDITIONING",
          links: [6],
          slot_index: 0
        }
      ],
      properties: {},
      widgets_values: ["text, watermark"]
    },
    {
      id: 6,
      type: "CLIPTextEncode",
      pos: [415, 186],
      size: [422.84503173828125, 164.31304931640625],
      flags: {},
      order: 2,
      mode: 0,
      inputs: [{ name: "clip", type: "CLIP", link: 3 }],
      outputs: [
        {
          name: "CONDITIONING",
          type: "CONDITIONING",
          links: [4],
          slot_index: 0
        }
      ],
      properties: {},
      widgets_values: [
        "beautiful scenery nature glass bottle landscape, , purple galaxy bottle,"
      ]
    },
    {
      id: 5,
      type: "EmptyLatentImage",
      pos: [473, 609],
      size: [315, 106],
      flags: {},
      order: 1,
      mode: 0,
      outputs: [{ name: "LATENT", type: "LATENT", links: [2], slot_index: 0 }],
      properties: {},
      widgets_values: [512, 512, 1]
    },
    {
      id: 3,
      type: "KSampler",
      pos: [863, 186],
      size: [315, 262],
      flags: {},
      order: 4,
      mode: 0,
      inputs: [
        { name: "model", type: "MODEL", link: 1 },
        { name: "positive", type: "CONDITIONING", link: 4 },
        { name: "negative", type: "CONDITIONING", link: 6 },
        { name: "latent_image", type: "LATENT", link: 2 }
      ],
      outputs: [{ name: "LATENT", type: "LATENT", links: [7], slot_index: 0 }],
      properties: {},
      widgets_values: [156680208700286, true, 20, 8, "euler", "normal", 1]
    },
    {
      id: 8,
      type: "VAEDecode",
      pos: [1209, 188],
      size: [210, 46],
      flags: {},
      order: 5,
      mode: 0,
      inputs: [
        { name: "samples", type: "LATENT", link: 7 },
        { name: "vae", type: "VAE", link: 8 }
      ],
      outputs: [{ name: "IMAGE", type: "IMAGE", links: [9], slot_index: 0 }],
      properties: {}
    },
    {
      id: 9,
      type: "SaveImage",
      pos: [1451, 189],
      size: [210, 26],
      flags: {},
      order: 6,
      mode: 0,
      inputs: [{ name: "images", type: "IMAGE", link: 9 }],
      properties: {}
    },
    {
      id: 4,
      type: "CheckpointLoaderSimple",
      pos: [26, 474],
      size: [315, 98],
      flags: {},
      order: 0,
      mode: 0,
      outputs: [
        { name: "MODEL", type: "MODEL", links: [1], slot_index: 0 },
        { name: "CLIP", type: "CLIP", links: [3, 5], slot_index: 1 },
        { name: "VAE", type: "VAE", links: [8], slot_index: 2 }
      ],
      properties: {},
      widgets_values: ["v1-5-pruned-emaonly.ckpt"]
    }
  ],
  links: [
    [1, 4, 0, 3, 0, "MODEL"],
    [2, 5, 0, 3, 3, "LATENT"],
    [3, 4, 1, 6, 0, "CLIP"],
    [4, 6, 0, 3, 1, "CONDITIONING"],
    [5, 4, 1, 7, 0, "CLIP"],
    [6, 7, 0, 3, 2, "CONDITIONING"],
    [7, 3, 0, 8, 0, "LATENT"],
    [8, 4, 2, 8, 1, "VAE"],
    [9, 8, 0, 9, 0, "IMAGE"]
  ],
  groups: [],
  config: {},
  extra: {},
  version: 0.4,
  models: [
    {
      name: "v1-5-pruned-emaonly.ckpt",
      url: "https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned-emaonly.ckpt",
      hash: "cc6cb27103417325ff94f52b7a5d2dde45a7515b25c255d8e396c90014281516",
      hash_type: "SHA256",
      directory: "checkpoints"
    }
  ]
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.defaultGraph = window.comfyAPI.defaultGraph || {};
window.comfyAPI.defaultGraph.defaultGraph = defaultGraph;
function getFromPngBuffer(buffer2) {
  const pngData = new Uint8Array(buffer2);
  const dataView = new DataView(pngData.buffer);
  if (dataView.getUint32(0) !== 2303741511) {
    console.error("Not a valid PNG file");
    return;
  }
  let offset = 8;
  let txt_chunks = {};
  while (offset < pngData.length) {
    const length = dataView.getUint32(offset);
    const type = String.fromCharCode(...pngData.slice(offset + 4, offset + 8));
    if (type === "tEXt" || type == "comf" || type === "iTXt") {
      let keyword_end = offset + 8;
      while (pngData[keyword_end] !== 0) {
        keyword_end++;
      }
      const keyword = String.fromCharCode(
        ...pngData.slice(offset + 8, keyword_end)
      );
      const contentArraySegment = pngData.slice(
        keyword_end + 1,
        offset + 8 + length
      );
      const contentJson = new TextDecoder("utf-8").decode(contentArraySegment);
      txt_chunks[keyword] = contentJson;
    }
    offset += 12 + length;
  }
  return txt_chunks;
}
function getFromPngFile(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      r(getFromPngBuffer(event2.target.result));
    };
    reader.readAsArrayBuffer(file);
  });
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.png = window.comfyAPI.png || {};
window.comfyAPI.png.getFromPngBuffer = getFromPngBuffer;
window.comfyAPI.png.getFromPngFile = getFromPngFile;
function getFromFlacBuffer(buffer2) {
  const dataView = new DataView(buffer2);
  const signature = String.fromCharCode(...new Uint8Array(buffer2, 0, 4));
  if (signature !== "fLaC") {
    console.error("Not a valid FLAC file");
    return;
  }
  let offset = 4;
  let vorbisComment = null;
  while (offset < dataView.byteLength) {
    const isLastBlock = dataView.getUint8(offset) & 128;
    const blockType = dataView.getUint8(offset) & 127;
    const blockSize = dataView.getUint32(offset, false) & 16777215;
    offset += 4;
    if (blockType === 4) {
      vorbisComment = parseVorbisComment(
        new DataView(buffer2, offset, blockSize)
      );
    }
    offset += blockSize;
    if (isLastBlock) break;
  }
  return vorbisComment;
}
function getFromFlacFile(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = function(event2) {
      const arrayBuffer = event2.target.result;
      r(getFromFlacBuffer(arrayBuffer));
    };
    reader.readAsArrayBuffer(file);
  });
}
function parseVorbisComment(dataView) {
  let offset = 0;
  const vendorLength = dataView.getUint32(offset, true);
  offset += 4;
  const vendorString = getString(dataView, offset, vendorLength);
  offset += vendorLength;
  const userCommentListLength = dataView.getUint32(offset, true);
  offset += 4;
  const comments = {};
  for (let i2 = 0; i2 < userCommentListLength; i2++) {
    const commentLength = dataView.getUint32(offset, true);
    offset += 4;
    const comment = getString(dataView, offset, commentLength);
    offset += commentLength;
    const ind = comment.indexOf("=");
    const key = comment.substring(0, ind);
    comments[key] = comment.substring(ind + 1);
  }
  return comments;
}
function getString(dataView, offset, length) {
  let string = "";
  for (let i2 = 0; i2 < length; i2++) {
    string += String.fromCharCode(dataView.getUint8(offset + i2));
  }
  return string;
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.flac = window.comfyAPI.flac || {};
window.comfyAPI.flac.getFromFlacBuffer = getFromFlacBuffer;
window.comfyAPI.flac.getFromFlacFile = getFromFlacFile;
function getPngMetadata(file) {
  return getFromPngFile(file);
}
function getFlacMetadata(file) {
  return getFromFlacFile(file);
}
function parseExifData(exifData) {
  const isLittleEndian = String.fromCharCode(...exifData.slice(0, 2)) === "II";
  function readInt(offset, isLittleEndian2, length) {
    let arr = exifData.slice(offset, offset + length);
    if (length === 2) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).getUint16(
        0,
        isLittleEndian2
      );
    } else if (length === 4) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).getUint32(
        0,
        isLittleEndian2
      );
    }
  }
  const ifdOffset = readInt(4, isLittleEndian, 4);
  function parseIFD(offset) {
    const numEntries = readInt(offset, isLittleEndian, 2);
    const result = {};
    for (let i2 = 0; i2 < numEntries; i2++) {
      const entryOffset = offset + 2 + i2 * 12;
      const tag = readInt(entryOffset, isLittleEndian, 2);
      const type = readInt(entryOffset + 2, isLittleEndian, 2);
      const numValues = readInt(entryOffset + 4, isLittleEndian, 4);
      const valueOffset = readInt(entryOffset + 8, isLittleEndian, 4);
      let value3;
      if (type === 2) {
        value3 = String.fromCharCode(
          ...exifData.slice(valueOffset, valueOffset + numValues - 1)
        );
      }
      result[tag] = value3;
    }
    return result;
  }
  const ifdData = parseIFD(ifdOffset);
  return ifdData;
}
function splitValues(input) {
  var output = {};
  for (var key in input) {
    var value3 = input[key];
    var splitValues2 = value3.split(":", 2);
    output[splitValues2[0]] = splitValues2[1];
  }
  return output;
}
function getWebpMetadata(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      const webp = new Uint8Array(event2.target.result);
      const dataView = new DataView(webp.buffer);
      if (dataView.getUint32(0) !== 1380533830 || dataView.getUint32(8) !== 1464156752) {
        console.error("Not a valid WEBP file");
        r({});
        return;
      }
      let offset = 12;
      let txt_chunks = {};
      while (offset < webp.length) {
        const chunk_length = dataView.getUint32(offset + 4, true);
        const chunk_type = String.fromCharCode(
          ...webp.slice(offset, offset + 4)
        );
        if (chunk_type === "EXIF") {
          if (String.fromCharCode(...webp.slice(offset + 8, offset + 8 + 6)) == "Exif\0\0") {
            offset += 6;
          }
          let data28 = parseExifData(
            webp.slice(offset + 8, offset + 8 + chunk_length)
          );
          for (var key in data28) {
            var value3 = data28[key];
            let index2 = value3.indexOf(":");
            txt_chunks[value3.slice(0, index2)] = value3.slice(index2 + 1);
          }
          break;
        }
        offset += 8 + chunk_length;
      }
      r(txt_chunks);
    };
    reader.readAsArrayBuffer(file);
  });
}
function getLatentMetadata(file) {
  return new Promise((r) => {
    const reader = new FileReader();
    reader.onload = (event2) => {
      const safetensorsData = new Uint8Array(event2.target.result);
      const dataView = new DataView(safetensorsData.buffer);
      let header_size = dataView.getUint32(0, true);
      let offset = 8;
      let header = JSON.parse(
        new TextDecoder().decode(
          safetensorsData.slice(offset, offset + header_size)
        )
      );
      r(header.__metadata__);
    };
    var slice = file.slice(0, 1024 * 1024 * 4);
    reader.readAsArrayBuffer(slice);
  });
}
function importA1111(graph, parameters) {
  return __async(this, null, function* () {
    const p2 = parameters.lastIndexOf("\nSteps:");
    if (p2 > -1) {
      const embeddings = yield api.getEmbeddings();
      const opts = parameters.substr(p2).split("\n")[1].match(
        new RegExp('\\s*([^:]+:\\s*([^"\\{].*?|".*?"|\\{.*?\\}))\\s*(,|$)', "g")
      ).reduce((p3, n) => {
        const s = n.split(":");
        if (s[1].endsWith(",")) {
          s[1] = s[1].substr(0, s[1].length - 1);
        }
        p3[s[0].trim().toLowerCase()] = s[1].trim();
        return p3;
      }, {});
      const p22 = parameters.lastIndexOf("\nNegative prompt:", p2);
      if (p22 > -1) {
        let positive = parameters.substr(0, p22).trim();
        let negative = parameters.substring(p22 + 18, p2).trim();
        const ckptNode = LiteGraph.createNode("CheckpointLoaderSimple");
        const clipSkipNode = LiteGraph.createNode("CLIPSetLastLayer");
        const positiveNode = LiteGraph.createNode("CLIPTextEncode");
        const negativeNode = LiteGraph.createNode("CLIPTextEncode");
        const samplerNode = LiteGraph.createNode("KSampler");
        const imageNode = LiteGraph.createNode("EmptyLatentImage");
        const vaeNode = LiteGraph.createNode("VAEDecode");
        const vaeLoaderNode = LiteGraph.createNode("VAELoader");
        const saveNode = LiteGraph.createNode("SaveImage");
        let hrSamplerNode = null;
        let hrSteps = null;
        const ceil64 = (v2) => Math.ceil(v2 / 64) * 64;
        const getWidget = (node3, name) => {
          return node3.widgets.find((w2) => w2.name === name);
        };
        const setWidgetValue = (node3, name, value3, isOptionPrefix) => {
          const w2 = getWidget(node3, name);
          if (isOptionPrefix) {
            const o = w2.options.values.find((w22) => w22.startsWith(value3));
            if (o) {
              w2.value = o;
            } else {
              console.warn(`Unknown value '${value3}' for widget '${name}'`, node3);
              w2.value = value3;
            }
          } else {
            w2.value = value3;
          }
        };
        const createLoraNodes = (clipNode, text2, prevClip, prevModel) => {
          const loras = [];
          text2 = text2.replace(/<lora:([^:]+:[^>]+)>/g, function(m, c) {
            const s = c.split(":");
            const weight = parseFloat(s[1]);
            if (isNaN(weight)) {
              console.warn("Invalid LORA", m);
            } else {
              loras.push({ name: s[0], weight });
            }
            return "";
          });
          for (const l of loras) {
            const loraNode = LiteGraph.createNode("LoraLoader");
            graph.add(loraNode);
            setWidgetValue(loraNode, "lora_name", l.name, true);
            setWidgetValue(loraNode, "strength_model", l.weight);
            setWidgetValue(loraNode, "strength_clip", l.weight);
            prevModel.node.connect(prevModel.index, loraNode, 0);
            prevClip.node.connect(prevClip.index, loraNode, 1);
            prevModel = { node: loraNode, index: 0 };
            prevClip = { node: loraNode, index: 1 };
          }
          prevClip.node.connect(1, clipNode, 0);
          prevModel.node.connect(0, samplerNode, 0);
          if (hrSamplerNode) {
            prevModel.node.connect(0, hrSamplerNode, 0);
          }
          return { text: text2, prevModel, prevClip };
        };
        const replaceEmbeddings = (text2) => {
          if (!embeddings.length) return text2;
          return text2.replaceAll(
            new RegExp(
              "\\b(" + embeddings.map((e) => e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("\\b|\\b") + ")\\b",
              "ig"
            ),
            "embedding:$1"
          );
        };
        const popOpt = (name) => {
          const v2 = opts[name];
          delete opts[name];
          return v2;
        };
        graph.clear();
        graph.add(ckptNode);
        graph.add(clipSkipNode);
        graph.add(positiveNode);
        graph.add(negativeNode);
        graph.add(samplerNode);
        graph.add(imageNode);
        graph.add(vaeNode);
        graph.add(vaeLoaderNode);
        graph.add(saveNode);
        ckptNode.connect(1, clipSkipNode, 0);
        clipSkipNode.connect(0, positiveNode, 0);
        clipSkipNode.connect(0, negativeNode, 0);
        ckptNode.connect(0, samplerNode, 0);
        positiveNode.connect(0, samplerNode, 1);
        negativeNode.connect(0, samplerNode, 2);
        imageNode.connect(0, samplerNode, 3);
        vaeNode.connect(0, saveNode, 0);
        samplerNode.connect(0, vaeNode, 0);
        vaeLoaderNode.connect(0, vaeNode, 1);
        const handlers = {
          model(v2) {
            setWidgetValue(ckptNode, "ckpt_name", v2, true);
          },
          vae(v2) {
            setWidgetValue(vaeLoaderNode, "vae_name", v2, true);
          },
          "cfg scale"(v2) {
            setWidgetValue(samplerNode, "cfg", +v2);
          },
          "clip skip"(v2) {
            setWidgetValue(clipSkipNode, "stop_at_clip_layer", -v2);
          },
          sampler(v2) {
            let name = v2.toLowerCase().replace("++", "pp").replaceAll(" ", "_");
            if (name.includes("karras")) {
              name = name.replace("karras", "").replace(/_+$/, "");
              setWidgetValue(samplerNode, "scheduler", "karras");
            } else {
              setWidgetValue(samplerNode, "scheduler", "normal");
            }
            const w2 = getWidget(samplerNode, "sampler_name");
            const o = w2.options.values.find(
              (w22) => w22 === name || w22 === "sample_" + name
            );
            if (o) {
              setWidgetValue(samplerNode, "sampler_name", o);
            }
          },
          size(v2) {
            const wxh = v2.split("x");
            const w2 = ceil64(+wxh[0]);
            const h2 = ceil64(+wxh[1]);
            const hrUp = popOpt("hires upscale");
            const hrSz = popOpt("hires resize");
            hrSteps = popOpt("hires steps");
            let hrMethod = popOpt("hires upscaler");
            setWidgetValue(imageNode, "width", w2);
            setWidgetValue(imageNode, "height", h2);
            if (hrUp || hrSz) {
              let uw, uh;
              if (hrUp) {
                uw = w2 * hrUp;
                uh = h2 * hrUp;
              } else {
                const s = hrSz.split("x");
                uw = +s[0];
                uh = +s[1];
              }
              let upscaleNode;
              let latentNode;
              if (hrMethod.startsWith("Latent")) {
                latentNode = upscaleNode = LiteGraph.createNode("LatentUpscale");
                graph.add(upscaleNode);
                samplerNode.connect(0, upscaleNode, 0);
                switch (hrMethod) {
                  case "Latent (nearest-exact)":
                    hrMethod = "nearest-exact";
                    break;
                }
                setWidgetValue(upscaleNode, "upscale_method", hrMethod, true);
              } else {
                const decode = LiteGraph.createNode("VAEDecodeTiled");
                graph.add(decode);
                samplerNode.connect(0, decode, 0);
                vaeLoaderNode.connect(0, decode, 1);
                const upscaleLoaderNode = LiteGraph.createNode("UpscaleModelLoader");
                graph.add(upscaleLoaderNode);
                setWidgetValue(upscaleLoaderNode, "model_name", hrMethod, true);
                const modelUpscaleNode = LiteGraph.createNode(
                  "ImageUpscaleWithModel"
                );
                graph.add(modelUpscaleNode);
                decode.connect(0, modelUpscaleNode, 1);
                upscaleLoaderNode.connect(0, modelUpscaleNode, 0);
                upscaleNode = LiteGraph.createNode("ImageScale");
                graph.add(upscaleNode);
                modelUpscaleNode.connect(0, upscaleNode, 0);
                const vaeEncodeNode = latentNode = LiteGraph.createNode("VAEEncodeTiled");
                graph.add(vaeEncodeNode);
                upscaleNode.connect(0, vaeEncodeNode, 0);
                vaeLoaderNode.connect(0, vaeEncodeNode, 1);
              }
              setWidgetValue(upscaleNode, "width", ceil64(uw));
              setWidgetValue(upscaleNode, "height", ceil64(uh));
              hrSamplerNode = LiteGraph.createNode("KSampler");
              graph.add(hrSamplerNode);
              ckptNode.connect(0, hrSamplerNode, 0);
              positiveNode.connect(0, hrSamplerNode, 1);
              negativeNode.connect(0, hrSamplerNode, 2);
              latentNode.connect(0, hrSamplerNode, 3);
              hrSamplerNode.connect(0, vaeNode, 0);
            }
          },
          steps(v2) {
            setWidgetValue(samplerNode, "steps", +v2);
          },
          seed(v2) {
            setWidgetValue(samplerNode, "seed", +v2);
          }
        };
        for (const opt in opts) {
          if (opt in handlers) {
            handlers[opt](popOpt(opt));
          }
        }
        if (hrSamplerNode) {
          setWidgetValue(
            hrSamplerNode,
            "steps",
            hrSteps ? +hrSteps : getWidget(samplerNode, "steps").value
          );
          setWidgetValue(
            hrSamplerNode,
            "cfg",
            getWidget(samplerNode, "cfg").value
          );
          setWidgetValue(
            hrSamplerNode,
            "scheduler",
            getWidget(samplerNode, "scheduler").value
          );
          setWidgetValue(
            hrSamplerNode,
            "sampler_name",
            getWidget(samplerNode, "sampler_name").value
          );
          setWidgetValue(
            hrSamplerNode,
            "denoise",
            +(popOpt("denoising strength") || "1")
          );
        }
        let n = createLoraNodes(
          positiveNode,
          positive,
          { node: clipSkipNode, index: 0 },
          { node: ckptNode, index: 0 }
        );
        positive = n.text;
        n = createLoraNodes(negativeNode, negative, n.prevClip, n.prevModel);
        negative = n.text;
        setWidgetValue(positiveNode, "text", replaceEmbeddings(positive));
        setWidgetValue(negativeNode, "text", replaceEmbeddings(negative));
        graph.arrange();
        for (const opt of [
          "model hash",
          "ensd",
          "version",
          "vae hash",
          "ti hashes",
          "lora hashes",
          "hashes"
        ]) {
          delete opts[opt];
        }
        console.warn("Unhandled parameters:", opts);
      }
    }
  });
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.pnginfo = window.comfyAPI.pnginfo || {};
window.comfyAPI.pnginfo.getPngMetadata = getPngMetadata;
window.comfyAPI.pnginfo.getFlacMetadata = getFlacMetadata;
window.comfyAPI.pnginfo.getWebpMetadata = getWebpMetadata;
window.comfyAPI.pnginfo.getLatentMetadata = getLatentMetadata;
window.comfyAPI.pnginfo.importA1111 = importA1111;
function calculateImageGrid(imgs, dw, dh) {
  let best = 0;
  let w2 = imgs[0].naturalWidth;
  let h2 = imgs[0].naturalHeight;
  const numImages = imgs.length;
  let cellWidth, cellHeight, cols, rows3, shiftX;
  for (let c = 1; c <= numImages; c++) {
    const r = Math.ceil(numImages / c);
    const cW = dw / c;
    const cH = dh / r;
    const scaleX = cW / w2;
    const scaleY = cH / h2;
    const scale = Math.min(scaleX, scaleY, 1);
    const imageW = w2 * scale;
    const imageH = h2 * scale;
    const area = imageW * imageH * numImages;
    if (area > best) {
      best = area;
      cellWidth = imageW;
      cellHeight = imageH;
      cols = c;
      rows3 = r;
      shiftX = c * ((cW - imageW) / 2);
    }
  }
  return { cellWidth, cellHeight, cols, rows: rows3, shiftX };
}
function createImageHost(node3) {
  const el = $el("div.comfy-img-preview");
  let currentImgs;
  let first4 = true;
  function updateSize() {
    let w2 = null;
    let h2 = null;
    if (currentImgs) {
      let elH = el.clientHeight;
      if (first4) {
        first4 = false;
        if (elH < 190) {
          elH = 190;
        }
        el.style.setProperty("--comfy-widget-min-height", elH.toString());
      } else {
        el.style.setProperty("--comfy-widget-min-height", null);
      }
      const nw = node3.size[0];
      ({ cellWidth: w2, cellHeight: h2 } = calculateImageGrid(
        currentImgs,
        nw - 20,
        elH
      ));
      w2 += "px";
      h2 += "px";
      el.style.setProperty("--comfy-img-preview-width", w2);
      el.style.setProperty("--comfy-img-preview-height", h2);
    }
  }
  return {
    el,
    updateImages(imgs) {
      if (imgs !== currentImgs) {
        if (currentImgs == null) {
          requestAnimationFrame(() => {
            updateSize();
          });
        }
        el.replaceChildren(...imgs);
        currentImgs = imgs;
        node3.onResize(node3.size);
        node3.graph.setDirtyCanvas(true, true);
      }
    },
    getHeight() {
      updateSize();
    },
    onDraw() {
      el.style.pointerEvents = "all";
      const over = document.elementFromPoint(
        app$1.canvas.mouse[0],
        app$1.canvas.mouse[1]
      );
      el.style.pointerEvents = "none";
      if (!over) return;
      const idx = currentImgs.indexOf(over);
      node3.overIndex = idx;
    }
  };
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.imagePreview = window.comfyAPI.imagePreview || {};
window.comfyAPI.imagePreview.calculateImageGrid = calculateImageGrid;
window.comfyAPI.imagePreview.createImageHost = createImageHost;
$el("style", {
  parent: document.head,
  textContent: `
        .draggable-item {
            position: relative;
            will-change: transform;
            user-select: none;
        }
        .draggable-item.is-idle {
            transition: 0.25s ease transform;
        }
        .draggable-item.is-draggable {
            z-index: 10;
        }
    `
});
class DraggableList extends EventTarget {
  constructor(element, itemSelector) {
    super();
    __publicField2(this, "listContainer");
    __publicField2(this, "draggableItem");
    __publicField2(this, "pointerStartX");
    __publicField2(this, "pointerStartY");
    __publicField2(this, "scrollYMax");
    __publicField2(this, "itemsGap", 0);
    __publicField2(this, "items", []);
    __publicField2(this, "itemSelector");
    __publicField2(this, "handleClass", "drag-handle");
    __publicField2(this, "off", []);
    __publicField2(this, "offDrag", []);
    this.listContainer = element;
    this.itemSelector = itemSelector;
    if (!this.listContainer) return;
    this.off.push(this.on(this.listContainer, "mousedown", this.dragStart));
    this.off.push(this.on(this.listContainer, "touchstart", this.dragStart));
    this.off.push(this.on(document, "mouseup", this.dragEnd));
    this.off.push(this.on(document, "touchend", this.dragEnd));
  }
  getAllItems() {
    var _a2;
    if (!((_a2 = this.items) == null ? void 0 : _a2.length)) {
      this.items = Array.from(
        this.listContainer.querySelectorAll(this.itemSelector)
      );
      this.items.forEach((element) => {
        element.classList.add("is-idle");
      });
    }
    return this.items;
  }
  getIdleItems() {
    return this.getAllItems().filter(
      (item) => item.classList.contains("is-idle")
    );
  }
  isItemAbove(item) {
    return item.hasAttribute("data-is-above");
  }
  isItemToggled(item) {
    return item.hasAttribute("data-is-toggled");
  }
  on(source, event2, listener, options3) {
    listener = listener.bind(this);
    source.addEventListener(event2, listener, options3);
    return () => source.removeEventListener(event2, listener);
  }
  dragStart(e) {
    if (e.target.classList.contains(this.handleClass)) {
      this.draggableItem = e.target.closest(this.itemSelector);
    }
    if (!this.draggableItem) return;
    this.pointerStartX = e.clientX || e.touches[0].clientX;
    this.pointerStartY = e.clientY || e.touches[0].clientY;
    this.scrollYMax = this.listContainer.scrollHeight - this.listContainer.clientHeight;
    this.setItemsGap();
    this.initDraggableItem();
    this.initItemsState();
    this.offDrag.push(this.on(document, "mousemove", this.drag));
    this.offDrag.push(
      this.on(document, "touchmove", this.drag, { passive: false })
    );
    this.dispatchEvent(
      new CustomEvent("dragstart", {
        detail: {
          element: this.draggableItem,
          position: this.getAllItems().indexOf(this.draggableItem)
        }
      })
    );
  }
  setItemsGap() {
    if (this.getIdleItems().length <= 1) {
      this.itemsGap = 0;
      return;
    }
    const item1 = this.getIdleItems()[0];
    const item2 = this.getIdleItems()[1];
    const item1Rect = item1.getBoundingClientRect();
    const item2Rect = item2.getBoundingClientRect();
    this.itemsGap = Math.abs(item1Rect.bottom - item2Rect.top);
  }
  initItemsState() {
    this.getIdleItems().forEach((item, i2) => {
      if (this.getAllItems().indexOf(this.draggableItem) > i2) {
        item.dataset.isAbove = "";
      }
    });
  }
  initDraggableItem() {
    this.draggableItem.classList.remove("is-idle");
    this.draggableItem.classList.add("is-draggable");
  }
  drag(e) {
    if (!this.draggableItem) return;
    e.preventDefault();
    const clientX = e.clientX || e.touches[0].clientX;
    const clientY = e.clientY || e.touches[0].clientY;
    const listRect = this.listContainer.getBoundingClientRect();
    if (clientY > listRect.bottom) {
      if (this.listContainer.scrollTop < this.scrollYMax) {
        this.listContainer.scrollBy(0, 10);
        this.pointerStartY -= 10;
      }
    } else if (clientY < listRect.top && this.listContainer.scrollTop > 0) {
      this.pointerStartY += 10;
      this.listContainer.scrollBy(0, -10);
    }
    const pointerOffsetX = clientX - this.pointerStartX;
    const pointerOffsetY = clientY - this.pointerStartY;
    this.updateIdleItemsStateAndPosition();
    this.draggableItem.style.transform = `translate(${pointerOffsetX}px, ${pointerOffsetY}px)`;
  }
  updateIdleItemsStateAndPosition() {
    const draggableItemRect = this.draggableItem.getBoundingClientRect();
    const draggableItemY = draggableItemRect.top + draggableItemRect.height / 2;
    this.getIdleItems().forEach((item) => {
      const itemRect = item.getBoundingClientRect();
      const itemY = itemRect.top + itemRect.height / 2;
      if (this.isItemAbove(item)) {
        if (draggableItemY <= itemY) {
          item.dataset.isToggled = "";
        } else {
          delete item.dataset.isToggled;
        }
      } else {
        if (draggableItemY >= itemY) {
          item.dataset.isToggled = "";
        } else {
          delete item.dataset.isToggled;
        }
      }
    });
    this.getIdleItems().forEach((item) => {
      if (this.isItemToggled(item)) {
        const direction = this.isItemAbove(item) ? 1 : -1;
        item.style.transform = `translateY(${direction * (draggableItemRect.height + this.itemsGap)}px)`;
      } else {
        item.style.transform = "";
      }
    });
  }
  dragEnd() {
    if (!this.draggableItem) return;
    this.applyNewItemsOrder();
    this.cleanup();
  }
  applyNewItemsOrder() {
    const reorderedItems = [];
    let oldPosition = -1;
    this.getAllItems().forEach((item, index2) => {
      if (item === this.draggableItem) {
        oldPosition = index2;
        return;
      }
      if (!this.isItemToggled(item)) {
        reorderedItems[index2] = item;
        return;
      }
      const newIndex = this.isItemAbove(item) ? index2 + 1 : index2 - 1;
      reorderedItems[newIndex] = item;
    });
    for (let index2 = 0; index2 < this.getAllItems().length; index2++) {
      const item = reorderedItems[index2];
      if (typeof item === "undefined") {
        reorderedItems[index2] = this.draggableItem;
      }
    }
    reorderedItems.forEach((item) => {
      this.listContainer.appendChild(item);
    });
    this.items = reorderedItems;
    this.dispatchEvent(
      new CustomEvent("dragend", {
        detail: {
          element: this.draggableItem,
          oldPosition,
          newPosition: reorderedItems.indexOf(this.draggableItem)
        }
      })
    );
  }
  cleanup() {
    this.itemsGap = 0;
    this.items = [];
    this.unsetDraggableItem();
    this.unsetItemState();
    this.offDrag.forEach((f) => f());
    this.offDrag = [];
  }
  unsetDraggableItem() {
    this.draggableItem.style = null;
    this.draggableItem.classList.remove("is-draggable");
    this.draggableItem.classList.add("is-idle");
    this.draggableItem = null;
  }
  unsetItemState() {
    this.getIdleItems().forEach((item, i2) => {
      delete item.dataset.isAbove;
      delete item.dataset.isToggled;
      item.style.transform = "";
    });
  }
  dispose() {
    this.off.forEach((f) => f());
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.draggableList = window.comfyAPI.draggableList || {};
window.comfyAPI.draggableList.DraggableList = DraggableList;
const parts = {
  d: (d) => d.getDate(),
  M: (d) => d.getMonth() + 1,
  h: (d) => d.getHours(),
  m: (d) => d.getMinutes(),
  s: (d) => d.getSeconds()
};
const format$4 = Object.keys(parts).map((k) => k + k + "?").join("|") + "|yyy?y?";
function formatDate(text2, date) {
  return text2.replace(new RegExp(format$4, "g"), (text22) => {
    if (text22 === "yy") return (date.getFullYear() + "").substring(2);
    if (text22 === "yyyy") return date.getFullYear().toString();
    if (text22[0] in parts) {
      const p2 = parts[text22[0]](date);
      return (p2 + "").padStart(text22.length, "0");
    }
    return text22;
  });
}
function clone(obj) {
  try {
    if (typeof structuredClone !== "undefined") {
      return structuredClone(obj);
    }
  } catch (error) {
  }
  return JSON.parse(JSON.stringify(obj));
}
function applyTextReplacements(app2, value3) {
  return value3.replace(/%([^%]+)%/g, function(match, text2) {
    var _a2, _b;
    const split = text2.split(".");
    if (split.length !== 2) {
      if (split[0].startsWith("date:")) {
        return formatDate(split[0].substring(5), /* @__PURE__ */ new Date());
      }
      if (text2 !== "width" && text2 !== "height") {
        console.warn("Invalid replacement pattern", text2);
      }
      return match;
    }
    let nodes = app2.graph._nodes.filter(
      (n) => {
        var _a3;
        return ((_a3 = n.properties) == null ? void 0 : _a3["Node name for S&R"]) === split[0];
      }
    );
    if (!nodes.length) {
      nodes = app2.graph._nodes.filter((n) => n.title === split[0]);
    }
    if (!nodes.length) {
      console.warn("Unable to find node", split[0]);
      return match;
    }
    if (nodes.length > 1) {
      console.warn("Multiple nodes matched", split[0], "using first match");
    }
    const node3 = nodes[0];
    const widget = (_a2 = node3.widgets) == null ? void 0 : _a2.find((w2) => w2.name === split[1]);
    if (!widget) {
      console.warn("Unable to find widget", split[1], "on node", split[0], node3);
      return match;
    }
    return (((_b = widget.value) != null ? _b : "") + "").replaceAll(/\/|\\/g, "_");
  });
}
function addStylesheet(urlOrFile, relativeTo) {
  return __async(this, null, function* () {
    return new Promise((res, rej) => {
      let url;
      if (urlOrFile.endsWith(".js")) {
        url = urlOrFile.substr(0, urlOrFile.length - 2) + "css";
      } else {
        url = new URL(
          urlOrFile,
          relativeTo != null ? relativeTo : `${window.location.protocol}//${window.location.host}`
        ).toString();
      }
      $el("link", {
        parent: document.head,
        rel: "stylesheet",
        type: "text/css",
        href: url,
        onload: res,
        onerror: rej
      });
    });
  });
}
function downloadBlob(filename, blob) {
  const url = URL.createObjectURL(blob);
  const a = $el("a", {
    href: url,
    download: filename,
    style: { display: "none" },
    parent: document.body
  });
  a.click();
  setTimeout(function() {
    a.remove();
    window.URL.revokeObjectURL(url);
  }, 0);
}
function prop(target, name, defaultValue, onChanged) {
  let currentValue;
  Object.defineProperty(target, name, {
    get() {
      return currentValue;
    },
    set(newValue) {
      const prevValue = currentValue;
      currentValue = newValue;
      onChanged == null ? void 0 : onChanged(currentValue, prevValue, target, name);
    }
  });
  return defaultValue;
}
function getStorageValue(id2) {
  var _a2, _b;
  const clientId = (_a2 = api.clientId) != null ? _a2 : api.initialClientId;
  return (_b = clientId && sessionStorage.getItem(`${id2}:${clientId}`)) != null ? _b : localStorage.getItem(id2);
}
function setStorageValue(id2, value3) {
  var _a2;
  const clientId = (_a2 = api.clientId) != null ? _a2 : api.initialClientId;
  if (clientId) {
    sessionStorage.setItem(`${id2}:${clientId}`, value3);
  }
  localStorage.setItem(id2, value3);
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.utils = window.comfyAPI.utils || {};
window.comfyAPI.utils.clone = clone;
window.comfyAPI.utils.applyTextReplacements = applyTextReplacements;
window.comfyAPI.utils.addStylesheet = addStylesheet;
window.comfyAPI.utils.downloadBlob = downloadBlob;
window.comfyAPI.utils.prop = prop;
window.comfyAPI.utils.getStorageValue = getStorageValue;
window.comfyAPI.utils.setStorageValue = setStorageValue;
function rgbToHsl({ r, g, b }) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h2, s;
  const l = (max + min) / 2;
  if (max === min) {
    h2 = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, l };
}
function hslToRgb({ h: h2, s, l }) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p22, q2, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p22 + (q2 - p22) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p22 + (q2 - p22) * (2 / 3 - t) * 6;
      return p22;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p2 = 2 * l - q;
    r = hue2rgb(p2, q, h2 + 1 / 3);
    g = hue2rgb(p2, q, h2);
    b = hue2rgb(p2, q, h2 - 1 / 3);
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
function hexToRgb(hex) {
  let r = 0, g = 0, b = 0;
  if (hex.length == 4) {
    r = parseInt(hex[1] + hex[1], 16);
    g = parseInt(hex[2] + hex[2], 16);
    b = parseInt(hex[3] + hex[3], 16);
  } else if (hex.length == 7) {
    r = parseInt(hex.slice(1, 3), 16);
    g = parseInt(hex.slice(3, 5), 16);
    b = parseInt(hex.slice(5, 7), 16);
  }
  return { r, g, b };
}
function rgbToHex({ r, g, b }) {
  return "#" + [r, g, b].map((x2) => {
    const hex = x2.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("");
}
function lightenColor(hex, amount) {
  let rgb = hexToRgb(hex);
  const hsl = rgbToHsl(rgb);
  hsl.l = Math.min(1, hsl.l + amount);
  rgb = hslToRgb(hsl);
  return rgbToHex(rgb);
}
function applyClasses(element, classList, ...requiredClasses) {
  classList != null ? classList : classList = "";
  let str;
  if (typeof classList === "string") {
    str = classList;
  } else if (classList instanceof Array) {
    str = classList.join(" ");
  } else {
    str = Object.entries(classList).reduce((p2, c) => {
      if (c[1]) {
        p2 += (p2.length ? " " : "") + c[0];
      }
      return p2;
    }, "");
  }
  element.className = str;
  if (requiredClasses) {
    element.classList.add(...requiredClasses);
  }
}
function toggleElement(element, {
  onHide: onHide2,
  onShow
} = {}) {
  let placeholder;
  let hidden;
  return (value3) => {
    if (value3) {
      if (hidden) {
        hidden = false;
        placeholder.replaceWith(element);
      }
      onShow == null ? void 0 : onShow(element, value3);
    } else {
      if (!placeholder) {
        placeholder = document.createComment("");
      }
      hidden = true;
      element.replaceWith(placeholder);
      onHide2 == null ? void 0 : onHide2(element);
    }
  };
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.utils = window.comfyAPI.utils || {};
window.comfyAPI.utils.applyClasses = applyClasses;
window.comfyAPI.utils.toggleElement = toggleElement;
class ComfyButton {
  constructor({
    icon: icon2,
    overIcon,
    iconSize,
    content,
    tooltip,
    action,
    classList = "comfyui-button",
    visibilitySetting,
    app: app2,
    enabled = true
  }) {
    __privateAdd(this, _over, 0);
    __privateAdd(this, _popupOpen, false);
    __publicField2(this, "isOver", false);
    __publicField2(this, "iconElement", $el("i.mdi"));
    __publicField2(this, "contentElement", $el("span"));
    __publicField2(this, "popup");
    __publicField2(this, "element");
    __publicField2(this, "overIcon");
    __publicField2(this, "iconSize");
    __publicField2(this, "content");
    __publicField2(this, "icon");
    __publicField2(this, "tooltip");
    __publicField2(this, "classList");
    __publicField2(this, "hidden");
    __publicField2(this, "enabled");
    __publicField2(this, "action");
    __publicField2(this, "updateIcon", () => this.iconElement.className = `mdi mdi-${this.isOver && this.overIcon || this.icon}${this.iconSize ? " mdi-" + this.iconSize + "px" : ""}`);
    __publicField2(this, "updateClasses", () => {
      const internalClasses = [];
      if (this.hidden) {
        internalClasses.push("hidden");
      }
      if (!this.enabled) {
        internalClasses.push("disabled");
      }
      if (this.popup) {
        if (__privateGet(this, _popupOpen)) {
          internalClasses.push("popup-open");
        } else {
          internalClasses.push("popup-closed");
        }
      }
      applyClasses(this.element, this.classList, ...internalClasses);
    });
    this.element = $el(
      "button",
      {
        onmouseenter: () => {
          this.isOver = true;
          if (this.overIcon) {
            this.updateIcon();
          }
        },
        onmouseleave: () => {
          this.isOver = false;
          if (this.overIcon) {
            this.updateIcon();
          }
        }
      },
      [this.iconElement, this.contentElement]
    );
    this.icon = prop(
      this,
      "icon",
      icon2,
      toggleElement(this.iconElement, { onShow: this.updateIcon })
    );
    this.overIcon = prop(this, "overIcon", overIcon, () => {
      if (this.isOver) {
        this.updateIcon();
      }
    });
    this.iconSize = prop(this, "iconSize", iconSize, this.updateIcon);
    this.content = prop(
      this,
      "content",
      content,
      toggleElement(this.contentElement, {
        onShow: (el, v2) => {
          if (typeof v2 === "string") {
            el.textContent = v2;
          } else {
            el.replaceChildren(v2);
          }
        }
      })
    );
    this.tooltip = prop(this, "tooltip", tooltip, (v2) => {
      if (v2) {
        this.element.title = v2;
      } else {
        this.element.removeAttribute("title");
      }
    });
    this.classList = prop(this, "classList", classList, this.updateClasses);
    this.hidden = prop(this, "hidden", false, this.updateClasses);
    this.enabled = prop(this, "enabled", enabled, () => {
      this.updateClasses();
      this.element.disabled = !this.enabled;
    });
    this.action = prop(this, "action", action);
    this.element.addEventListener("click", (e) => {
      var _a2;
      if (this.popup) {
        if (!__privateGet(this, _over)) {
          this.popup.toggle();
        }
      }
      (_a2 = this.action) == null ? void 0 : _a2.call(this, e, this);
    });
    if (visibilitySetting == null ? void 0 : visibilitySetting.id) {
      const settingUpdated = () => {
        this.hidden = app2.ui.settings.getSettingValue(visibilitySetting.id) !== visibilitySetting.showValue;
      };
      app2.ui.settings.addEventListener(
        visibilitySetting.id + ".change",
        settingUpdated
      );
      settingUpdated();
    }
  }
  withPopup(popup, mode2 = "click") {
    this.popup = popup;
    if (mode2 === "hover") {
      for (const el of [this.element, this.popup.element]) {
        el.addEventListener("mouseenter", () => {
          this.popup.open = !!++__privateWrapper(this, _over)._;
        });
        el.addEventListener("mouseleave", () => {
          this.popup.open = !!--__privateWrapper(this, _over)._;
        });
      }
    }
    popup.addEventListener("change", () => {
      __privateSet(this, _popupOpen, popup.open);
      this.updateClasses();
    });
    return this;
  }
}
_over = new WeakMap();
_popupOpen = new WeakMap();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.button = window.comfyAPI.button || {};
window.comfyAPI.button.ComfyButton = ComfyButton;
class ComfyButtonGroup {
  constructor(...buttons) {
    __publicField2(this, "element", $el("div.comfyui-button-group"));
    __publicField2(this, "buttons");
    this.buttons = prop(this, "buttons", buttons, () => this.update());
  }
  insert(button, index2) {
    this.buttons.splice(index2, 0, button);
    this.update();
  }
  append(button) {
    this.buttons.push(button);
    this.update();
  }
  remove(indexOrButton) {
    if (typeof indexOrButton !== "number") {
      indexOrButton = this.buttons.indexOf(indexOrButton);
    }
    if (indexOrButton > -1) {
      const r = this.buttons.splice(indexOrButton, 1);
      this.update();
      return r;
    }
  }
  update() {
    this.element.replaceChildren(...this.buttons.map((b) => {
      var _a2;
      return (_a2 = b["element"]) != null ? _a2 : b;
    }));
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.buttonGroup = window.comfyAPI.buttonGroup || {};
window.comfyAPI.buttonGroup.ComfyButtonGroup = ComfyButtonGroup;
class ComfyPopup extends EventTarget {
  constructor({
    target,
    container = document.body,
    classList = "",
    ignoreTarget = true,
    closeOnEscape = true,
    position = "absolute",
    horizontal: horizontal3 = "left"
  }, ...children) {
    super();
    __privateAdd(this, _ComfyPopup_instances);
    __publicField2(this, "element", $el("div.comfyui-popup"));
    __publicField2(this, "open");
    __publicField2(this, "children");
    __publicField2(this, "target");
    __publicField2(this, "ignoreTarget");
    __publicField2(this, "container");
    __publicField2(this, "position");
    __publicField2(this, "closeOnEscape");
    __publicField2(this, "horizontal");
    __publicField2(this, "classList");
    __privateAdd(this, _escHandler, (e) => {
      if (e.key === "Escape") {
        this.open = false;
        e.preventDefault();
        e.stopImmediatePropagation();
      }
    });
    __privateAdd(this, _clickHandler, (e) => {
      const target = e.target;
      if (!this.element.contains(target) && this.ignoreTarget && !this.target.contains(target)) {
        this.open = false;
      }
    });
    __publicField2(this, "update", () => {
      const rect = this.target.getBoundingClientRect();
      this.element.style.setProperty("--bottom", "unset");
      if (this.position === "absolute") {
        if (this.horizontal === "left") {
          this.element.style.setProperty("--left", rect.left + "px");
        } else {
          this.element.style.setProperty(
            "--left",
            rect.right - this.element.clientWidth + "px"
          );
        }
        this.element.style.setProperty("--top", rect.bottom + "px");
        this.element.style.setProperty("--limit", rect.bottom + "px");
      } else {
        this.element.style.setProperty("--left", "0px");
        this.element.style.setProperty("--top", rect.height + "px");
        this.element.style.setProperty("--limit", rect.height + "px");
      }
      const thisRect = this.element.getBoundingClientRect();
      if (thisRect.height < 30) {
        this.element.style.setProperty("--top", "unset");
        this.element.style.setProperty("--bottom", rect.height + 5 + "px");
        this.element.style.setProperty("--limit", rect.height + 5 + "px");
      }
    });
    this.target = target;
    this.ignoreTarget = ignoreTarget;
    this.container = container;
    this.position = position;
    this.closeOnEscape = closeOnEscape;
    this.horizontal = horizontal3;
    container.append(this.element);
    this.children = prop(this, "children", children, () => {
      this.element.replaceChildren(...this.children);
      this.update();
    });
    this.classList = prop(
      this,
      "classList",
      classList,
      () => applyClasses(this.element, this.classList, "comfyui-popup", horizontal3)
    );
    this.open = prop(this, "open", false, (v2, o) => {
      if (v2 === o) return;
      if (v2) {
        __privateMethod(this, _ComfyPopup_instances, show_fn).call(this);
      } else {
        __privateMethod(this, _ComfyPopup_instances, hide_fn).call(this);
      }
    });
  }
  toggle() {
    this.open = !this.open;
  }
}
_ComfyPopup_instances = new WeakSet();
hide_fn = function() {
  this.element.classList.remove("open");
  window.removeEventListener("resize", this.update);
  window.removeEventListener("click", __privateGet(this, _clickHandler), { capture: true });
  window.removeEventListener("keydown", __privateGet(this, _escHandler), { capture: true });
  this.dispatchEvent(new CustomEvent("close"));
  this.dispatchEvent(new CustomEvent("change"));
};
show_fn = function() {
  this.element.classList.add("open");
  this.update();
  window.addEventListener("resize", this.update);
  window.addEventListener("click", __privateGet(this, _clickHandler), { capture: true });
  if (this.closeOnEscape) {
    window.addEventListener("keydown", __privateGet(this, _escHandler), { capture: true });
  }
  this.dispatchEvent(new CustomEvent("open"));
  this.dispatchEvent(new CustomEvent("change"));
};
_escHandler = new WeakMap();
_clickHandler = new WeakMap();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.popup = window.comfyAPI.popup || {};
window.comfyAPI.popup.ComfyPopup = ComfyPopup;
class ComfySplitButton {
  constructor({
    primary,
    mode: mode2,
    horizontal: horizontal3 = "left",
    position = "relative"
  }, ...items2) {
    __publicField2(this, "arrow");
    __publicField2(this, "element");
    __publicField2(this, "popup");
    __publicField2(this, "items");
    this.arrow = new ComfyButton({
      icon: "chevron-down"
    });
    this.element = $el(
      "div.comfyui-split-button" + (mode2 === "hover" ? ".hover" : ""),
      [
        $el("div.comfyui-split-primary", primary.element),
        $el("div.comfyui-split-arrow", this.arrow.element)
      ]
    );
    this.popup = new ComfyPopup({
      target: this.element,
      container: position === "relative" ? this.element : document.body,
      classList: "comfyui-split-button-popup" + (mode2 === "hover" ? " hover" : ""),
      closeOnEscape: mode2 === "click",
      position,
      horizontal: horizontal3
    });
    this.arrow.withPopup(this.popup, mode2);
    this.items = prop(this, "items", items2, () => this.update());
  }
  update() {
    this.popup.element.replaceChildren(
      ...this.items.map((b) => "element" in b ? b.element : b)
    );
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.splitButton = window.comfyAPI.splitButton || {};
window.comfyAPI.splitButton.ComfySplitButton = ComfySplitButton;
class ComfyQueueOptions extends EventTarget {
  constructor(app2) {
    super();
    __publicField2(this, "element", $el("div.comfyui-queue-options"));
    __publicField2(this, "app");
    __publicField2(this, "batchCountInput");
    __publicField2(this, "batchCount");
    __publicField2(this, "batchCountRange");
    __publicField2(this, "autoQueueMode");
    __publicField2(this, "autoQueueEl");
    this.app = app2;
    this.batchCountInput = $el("input", {
      className: "comfyui-queue-batch-value",
      type: "number",
      min: "1",
      value: "1",
      oninput: () => this.batchCount = +this.batchCountInput.value
    });
    this.batchCountRange = $el("input", {
      type: "range",
      min: "1",
      max: "100",
      value: "1",
      oninput: () => this.batchCount = +this.batchCountRange.value
    });
    this.element.append(
      $el("div.comfyui-queue-batch", [
        $el(
          "label",
          {
            textContent: "Batch count: "
          },
          this.batchCountInput
        ),
        this.batchCountRange
      ])
    );
    const createOption = (text2, value3, checked5 = false) => $el(
      "label",
      { textContent: text2 },
      $el("input", {
        type: "radio",
        name: "AutoQueueMode",
        checked: checked5,
        value: value3,
        oninput: (e) => this.autoQueueMode = e.target["value"]
      })
    );
    this.autoQueueEl = $el("div.comfyui-queue-mode", [
      $el("span", "Auto Queue:"),
      createOption("Disabled", "", true),
      createOption("Instant", "instant"),
      createOption("On Change", "change")
    ]);
    this.element.append(this.autoQueueEl);
    this.batchCount = prop(this, "batchCount", 1, () => {
      this.batchCountInput.value = this.batchCount + "";
      this.batchCountRange.value = this.batchCount + "";
    });
    this.autoQueueMode = prop(this, "autoQueueMode", "Disabled", () => {
      this.dispatchEvent(
        new CustomEvent("autoQueueMode", {
          detail: this.autoQueueMode
        })
      );
    });
  }
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.queueOptions = window.comfyAPI.queueOptions || {};
window.comfyAPI.queueOptions.ComfyQueueOptions = ComfyQueueOptions;
class ComfyQueueButton {
  constructor(app2) {
    __publicField2(this, "element", $el("div.comfyui-queue-button"));
    __privateAdd(this, _internalQueueSize, 0);
    __publicField2(this, "queuePrompt", (e) => __async(this, null, function* () {
      __privateSet(this, _internalQueueSize, __privateGet(this, _internalQueueSize) + this.queueOptions.batchCount);
      yield this.app.queuePrompt(
        (e == null ? void 0 : e.shiftKey) ? -1 : 0,
        this.queueOptions.batchCount
      );
    }));
    __publicField2(this, "queueOptions");
    __publicField2(this, "app");
    __publicField2(this, "autoQueueMode");
    __publicField2(this, "graphHasChanged");
    this.app = app2;
    const queue2 = new ComfyButton({
      content: $el("div", [
        $el("span", {
          textContent: "Queue"
        })
      ]),
      icon: "play",
      classList: "comfyui-button",
      action: this.queuePrompt
    });
    this.queueOptions = new ComfyQueueOptions(app2);
    const btn = new ComfySplitButton(
      {
        primary: queue2,
        mode: "click",
        position: "absolute",
        horizontal: "right"
      },
      this.queueOptions.element
    );
    btn.element.classList.add("primary");
    this.element.append(btn.element);
    this.autoQueueMode = prop(this, "autoQueueMode", "", () => {
      switch (this.autoQueueMode) {
        case "instant":
          queue2.icon = "infinity";
          break;
        case "change":
          queue2.icon = "auto-mode";
          break;
        default:
          queue2.icon = "play";
          break;
      }
    });
    this.queueOptions.addEventListener(
      "autoQueueMode",
      (e) => this.autoQueueMode = e["detail"]
    );
    api.addEventListener("graphChanged", () => {
      if (this.autoQueueMode === "change") {
        if (__privateGet(this, _internalQueueSize)) {
          this.graphHasChanged = true;
        } else {
          this.graphHasChanged = false;
          this.queuePrompt();
        }
      }
    });
    api.addEventListener(
      "status",
      ({ detail }) => {
        var _a2;
        __privateSet(this, _internalQueueSize, (_a2 = detail == null ? void 0 : detail.exec_info) == null ? void 0 : _a2.queue_remaining);
        if (__privateGet(this, _internalQueueSize) != null) {
          if (!__privateGet(this, _internalQueueSize) && !app2.lastExecutionError) {
            if (this.autoQueueMode === "instant" || this.autoQueueMode === "change" && this.graphHasChanged) {
              this.graphHasChanged = false;
              this.queuePrompt();
            }
          }
        }
      }
    );
  }
}
_internalQueueSize = new WeakMap();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.queueButton = window.comfyAPI.queueButton || {};
window.comfyAPI.queueButton.ComfyQueueButton = ComfyQueueButton;
function createSpinner() {
  const div = document.createElement("div");
  div.innerHTML = `<div class="lds-ring"><div></div><div></div><div></div><div></div></div>`;
  return div.firstElementChild;
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.spinner = window.comfyAPI.spinner || {};
window.comfyAPI.spinner.createSpinner = createSpinner;
const _ChangeTracker = class _ChangeTracker {
  constructor(workflow) {
    __privateAdd(this, _ChangeTracker_instances);
    __privateAdd(this, _app);
    __publicField2(this, "undo", []);
    __publicField2(this, "redo", []);
    __publicField2(this, "activeState", null);
    __publicField2(this, "isOurLoad", false);
    __publicField2(this, "workflow");
    __publicField2(this, "ds");
    __publicField2(this, "nodeOutputs");
    this.workflow = workflow;
  }
  get app() {
    var _a2;
    return (_a2 = __privateGet(this, _app)) != null ? _a2 : this.workflow.manager.app;
  }
  store() {
    this.ds = {
      scale: this.app.canvas.ds.scale,
      offset: [...this.app.canvas.ds.offset]
    };
  }
  restore() {
    if (this.ds) {
      this.app.canvas.ds.scale = this.ds.scale;
      this.app.canvas.ds.offset = this.ds.offset;
    }
    if (this.nodeOutputs) {
      this.app.nodeOutputs = this.nodeOutputs;
    }
  }
  checkState() {
    if (!this.app.graph) return;
    const currentState2 = this.app.graph.serialize();
    if (!this.activeState) {
      this.activeState = clone(currentState2);
      return;
    }
    if (!_ChangeTracker.graphEqual(this.activeState, currentState2)) {
      this.undo.push(this.activeState);
      if (this.undo.length > _ChangeTracker.MAX_HISTORY) {
        this.undo.shift();
      }
      this.activeState = clone(currentState2);
      this.redo.length = 0;
      this.workflow.unsaved = true;
      api.dispatchEvent(
        new CustomEvent("graphChanged", { detail: this.activeState })
      );
    }
  }
  updateState(source, target) {
    return __async(this, null, function* () {
      const prevState = source.pop();
      if (prevState) {
        target.push(this.activeState);
        this.isOurLoad = true;
        yield this.app.loadGraphData(prevState, false, false, this.workflow);
        this.activeState = prevState;
      }
    });
  }
  undoRedo(e) {
    return __async(this, null, function* () {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === "y") {
          this.updateState(this.redo, this.undo);
          return true;
        } else if (e.key === "z") {
          this.updateState(this.undo, this.redo);
          return true;
        }
      }
    });
  }
  static init(app2) {
    var _a2;
    const changeTracker = () => {
      var _a3, _b;
      return (_b = (_a3 = app2.workflowManager.activeWorkflow) == null ? void 0 : _a3.changeTracker) != null ? _b : globalTracker;
    };
    __privateMethod(_a2 = globalTracker, _ChangeTracker_instances, setApp_fn).call(_a2, app2);
    const loadGraphData = app2.loadGraphData;
    app2.loadGraphData = function() {
      return __async(this, arguments, function* () {
        const v2 = yield loadGraphData.apply(this, arguments);
        const ct = changeTracker();
        if (ct.isOurLoad) {
          ct.isOurLoad = false;
        } else {
          ct.checkState();
        }
        return v2;
      });
    };
    let keyIgnored = false;
    window.addEventListener(
      "keydown",
      (e) => {
        const activeEl = document.activeElement;
        requestAnimationFrame(() => __async(this, null, function* () {
          let bindInputEl;
          if (!app2.ui.autoQueueEnabled || app2.ui.autoQueueMode === "instant") {
            if ((activeEl == null ? void 0 : activeEl.tagName) === "INPUT" || (activeEl == null ? void 0 : activeEl["type"]) === "textarea") {
              return;
            }
            bindInputEl = activeEl;
          }
          keyIgnored = e.key === "Control" || e.key === "Shift" || e.key === "Alt" || e.key === "Meta";
          if (keyIgnored) return;
          if (yield changeTracker().undoRedo(e)) return;
          if (_ChangeTracker.bindInput(app2, bindInputEl)) return;
          changeTracker().checkState();
        }));
      },
      true
    );
    window.addEventListener("keyup", (e) => {
      if (keyIgnored) {
        keyIgnored = false;
        changeTracker().checkState();
      }
    });
    window.addEventListener("mouseup", () => {
      changeTracker().checkState();
    });
    api.addEventListener("promptQueued", () => {
      changeTracker().checkState();
    });
    api.addEventListener("graphCleared", () => {
      changeTracker().checkState();
    });
    const processMouseUp = LGraphCanvas.prototype.processMouseUp;
    LGraphCanvas.prototype.processMouseUp = function(e) {
      const v2 = processMouseUp.apply(this, arguments);
      changeTracker().checkState();
      return v2;
    };
    const processMouseDown = LGraphCanvas.prototype.processMouseDown;
    LGraphCanvas.prototype.processMouseDown = function(e) {
      const v2 = processMouseDown.apply(this, arguments);
      changeTracker().checkState();
      return v2;
    };
    const close4 = LiteGraph.ContextMenu.prototype.close;
    LiteGraph.ContextMenu.prototype.close = function(e) {
      const v2 = close4.apply(this, arguments);
      changeTracker().checkState();
      return v2;
    };
    const onNodeAdded = LiteGraph.LGraph.prototype.onNodeAdded;
    LiteGraph.LGraph.prototype.onNodeAdded = function() {
      const v2 = onNodeAdded == null ? void 0 : onNodeAdded.apply(this, arguments);
      if (!(app2 == null ? void 0 : app2.configuringGraph)) {
        const ct = changeTracker();
        if (!ct.isOurLoad) {
          ct.checkState();
        }
      }
      return v2;
    };
    api.addEventListener("executed", ({ detail }) => {
      var _a3, _b, _c;
      const prompt2 = app2.workflowManager.queuedPrompts[detail.prompt_id];
      if (!(prompt2 == null ? void 0 : prompt2.workflow)) return;
      const nodeOutputs = (_b = (_a3 = prompt2.workflow.changeTracker).nodeOutputs) != null ? _b : _a3.nodeOutputs = {};
      const output = nodeOutputs[detail.node];
      if (detail.merge && output) {
        for (const k in (_c = detail.output) != null ? _c : {}) {
          const v2 = output[k];
          if (v2 instanceof Array) {
            output[k] = v2.concat(detail.output[k]);
          } else {
            output[k] = detail.output[k];
          }
        }
      } else {
        nodeOutputs[detail.node] = detail.output;
      }
    });
  }
  static bindInput(app2, activeEl) {
    if (activeEl && activeEl.tagName !== "CANVAS" && activeEl.tagName !== "BODY") {
      for (const evt of ["change", "input", "blur"]) {
        if (`on${evt}` in activeEl) {
          const listener = () => {
            app2.workflowManager.activeWorkflow.changeTracker.checkState();
            activeEl.removeEventListener(evt, listener);
          };
          activeEl.addEventListener(evt, listener);
          return true;
        }
      }
    }
  }
  static graphEqual(a, b, path = "") {
    if (a === b) return true;
    if (typeof a == "object" && a && typeof b == "object" && b) {
      const keys = Object.getOwnPropertyNames(a);
      if (keys.length != Object.getOwnPropertyNames(b).length) {
        return false;
      }
      for (const key of keys) {
        let av = a[key];
        let bv = b[key];
        if (!path && key === "nodes") {
          av = [...av].sort((a2, b2) => a2.id - b2.id);
          bv = [...bv].sort((a2, b2) => a2.id - b2.id);
        } else if (path === "extra.ds") {
          continue;
        }
        if (!_ChangeTracker.graphEqual(av, bv, path + (path ? "." : "") + key)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
};
_app = new WeakMap();
_ChangeTracker_instances = new WeakSet();
setApp_fn = function(app2) {
  __privateSet(this, _app, app2);
};
__publicField2(_ChangeTracker, "MAX_HISTORY", 50);
let ChangeTracker = _ChangeTracker;
const globalTracker = new ChangeTracker({});
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.changeTracker = window.comfyAPI.changeTracker || {};
window.comfyAPI.changeTracker.ChangeTracker = ChangeTracker;
const _ComfyAsyncDialog = class _ComfyAsyncDialog extends ComfyDialog$1 {
  constructor(actions) {
    super(
      "dialog.comfy-dialog.comfyui-dialog",
      actions == null ? void 0 : actions.map((opt) => {
        if (typeof opt === "string") {
          opt = { text: opt };
        }
        return $el("button.comfyui-button", {
          type: "button",
          textContent: opt.text,
          onclick: () => {
            var _a2;
            return this.close((_a2 = opt.value) != null ? _a2 : opt.text);
          }
        });
      })
    );
    __privateAdd(this, _resolve);
  }
  show(html) {
    this.element.addEventListener("close", () => {
      this.close();
    });
    super.show(html);
    return new Promise((resolve8) => {
      __privateSet(this, _resolve, resolve8);
    });
  }
  showModal(html) {
    this.element.addEventListener("close", () => {
      this.close();
    });
    super.show(html);
    this.element.showModal();
    return new Promise((resolve8) => {
      __privateSet(this, _resolve, resolve8);
    });
  }
  close(result = null) {
    __privateGet(this, _resolve).call(this, result);
    this.element.close();
    super.close();
  }
  static prompt(_0) {
    return __async(this, arguments, function* ({ title = null, message: message3, actions }) {
      const dialog = new _ComfyAsyncDialog(actions);
      const content = [$el("span", message3)];
      if (title) {
        content.unshift($el("h3", title));
      }
      const res = yield dialog.showModal(content);
      dialog.element.remove();
      return res;
    });
  }
};
_resolve = new WeakMap();
let ComfyAsyncDialog = _ComfyAsyncDialog;
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.asyncDialog = window.comfyAPI.asyncDialog || {};
window.comfyAPI.asyncDialog.ComfyAsyncDialog = ComfyAsyncDialog;
function appendJsonExt(path) {
  if (!path.toLowerCase().endsWith(".json")) {
    path += ".json";
  }
  return path;
}
function trimJsonExt(path) {
  return path == null ? void 0 : path.replace(/\.json$/, "");
}
class ComfyWorkflowManager extends EventTarget {
  constructor(app2) {
    super();
    __privateAdd(this, _ComfyWorkflowManager_instances);
    __privateAdd(this, _activePromptId, null);
    __privateAdd(this, _unsavedCount, 0);
    __privateAdd(this, _activeWorkflow);
    __publicField2(this, "workflowLookup", {});
    __publicField2(this, "workflows", []);
    __publicField2(this, "openWorkflows", []);
    __publicField2(this, "queuedPrompts", {});
    __publicField2(this, "app");
    this.app = app2;
    ChangeTracker.init(app2);
    __privateMethod(this, _ComfyWorkflowManager_instances, bindExecutionEvents_fn).call(this);
  }
  get activeWorkflow() {
    var _a2;
    return (_a2 = __privateGet(this, _activeWorkflow)) != null ? _a2 : this.openWorkflows[0];
  }
  get activePromptId() {
    return __privateGet(this, _activePromptId);
  }
  get activePrompt() {
    return this.queuedPrompts[__privateGet(this, _activePromptId)];
  }
  loadWorkflows() {
    return __async(this, null, function* () {
      var _a2, _b;
      try {
        let favorites;
        const resp = yield api.getUserData("workflows/.index.json");
        let info;
        if (resp.status === 200) {
          info = yield resp.json();
          favorites = new Set((_a2 = info == null ? void 0 : info.favorites) != null ? _a2 : []);
        } else {
          favorites = /* @__PURE__ */ new Set();
        }
        const workflows = (yield api.listUserData("workflows", true, true)).map(
          (w2) => {
            let workflow = this.workflowLookup[w2[0]];
            if (!workflow) {
              workflow = new ComfyWorkflow(
                this,
                w2[0],
                w2.slice(1),
                favorites.has(w2[0])
              );
              this.workflowLookup[workflow.path] = workflow;
            }
            return workflow;
          }
        );
        this.workflows = workflows;
      } catch (error) {
        alert("Error loading workflows: " + ((_b = error.message) != null ? _b : error));
        this.workflows = [];
      }
    });
  }
  saveWorkflowMetadata() {
    return __async(this, null, function* () {
      yield api.storeUserData("workflows/.index.json", {
        favorites: [
          ...this.workflows.filter((w2) => w2.isFavorite).map((w2) => w2.path)
        ]
      });
    });
  }
  /**
   * @param {string | ComfyWorkflow | null} workflow
   */
  setWorkflow(workflow) {
    var _a2;
    if (workflow && typeof workflow === "string") {
      const found = this.workflows.find((w2) => w2.path === workflow);
      if (found) {
        workflow = found;
        workflow.unsaved = !workflow || getStorageValue("Comfy.PreviousWorkflowUnsaved") === "true";
      }
    }
    if (!(workflow instanceof ComfyWorkflow)) {
      workflow = new ComfyWorkflow(
        this,
        workflow || "Unsaved Workflow" + (__privateWrapper(this, _unsavedCount)._++ ? ` (${__privateGet(this, _unsavedCount)})` : "")
      );
    }
    const index2 = this.openWorkflows.indexOf(workflow);
    if (index2 === -1) {
      this.openWorkflows.push(workflow);
    }
    __privateSet(this, _activeWorkflow, workflow);
    setStorageValue("Comfy.PreviousWorkflow", (_a2 = this.activeWorkflow.path) != null ? _a2 : "");
    this.dispatchEvent(new CustomEvent("changeWorkflow"));
  }
  storePrompt({ nodes, id: id2 }) {
    var _a2, _b;
    (_b = (_a2 = this.queuedPrompts)[id2]) != null ? _b : _a2[id2] = {};
    this.queuedPrompts[id2].nodes = __spreadValues2(__spreadValues2({}, nodes.reduce((p2, n) => {
      p2[n] = false;
      return p2;
    }, {})), this.queuedPrompts[id2].nodes);
    this.queuedPrompts[id2].workflow = this.activeWorkflow;
  }
  /**
   * @param {ComfyWorkflow} workflow
   */
  closeWorkflow(workflow, warnIfUnsaved = true) {
    return __async(this, null, function* () {
      var _a2;
      if (!workflow.isOpen) {
        return true;
      }
      if (workflow.unsaved && warnIfUnsaved) {
        const res = yield ComfyAsyncDialog.prompt({
          title: "Save Changes?",
          message: `Do you want to save changes to "${(_a2 = workflow.path) != null ? _a2 : workflow.name}" before closing?`,
          actions: ["Yes", "No", "Cancel"]
        });
        if (res === "Yes") {
          const active3 = this.activeWorkflow;
          if (active3 !== workflow) {
            yield workflow.load();
          }
          if (!(yield workflow.save())) {
            if (active3 !== workflow) {
              yield active3.load();
            }
            return;
          }
        } else if (res === "Cancel") {
          return;
        }
      }
      workflow.changeTracker = null;
      this.openWorkflows.splice(this.openWorkflows.indexOf(workflow), 1);
      if (this.openWorkflows.length) {
        __privateSet(this, _activeWorkflow, this.openWorkflows[0]);
        yield __privateGet(this, _activeWorkflow).load();
      } else {
        yield this.app.loadGraphData();
      }
    });
  }
}
_activePromptId = new WeakMap();
_unsavedCount = new WeakMap();
_activeWorkflow = new WeakMap();
_ComfyWorkflowManager_instances = new WeakSet();
bindExecutionEvents_fn = function() {
  const emit2 = () => this.dispatchEvent(
    new CustomEvent("execute", { detail: this.activePrompt })
  );
  let executing = null;
  api.addEventListener("execution_start", (e) => {
    var _a2, _b, _c;
    __privateSet(this, _activePromptId, e.detail.prompt_id);
    (_c = (_a2 = this.queuedPrompts)[_b = __privateGet(this, _activePromptId)]) != null ? _c : _a2[_b] = { nodes: {} };
    emit2();
  });
  api.addEventListener("execution_cached", (e) => {
    if (!this.activePrompt) return;
    for (const n of e.detail.nodes) {
      this.activePrompt.nodes[n] = true;
    }
    emit2();
  });
  api.addEventListener("executed", (e) => {
    if (!this.activePrompt) return;
    this.activePrompt.nodes[e.detail.node] = true;
    emit2();
  });
  api.addEventListener("executing", (e) => {
    if (!this.activePrompt) return;
    if (executing) {
      this.activePrompt.nodes[executing] = true;
    }
    executing = e.detail;
    if (!executing) {
      delete this.queuedPrompts[__privateGet(this, _activePromptId)];
      __privateSet(this, _activePromptId, null);
    }
    emit2();
  });
};
class ComfyWorkflow {
  constructor(manager, path, pathParts, isFavorite) {
    __privateAdd(this, _ComfyWorkflow_instances);
    __privateAdd(this, _name);
    __privateAdd(this, _path);
    __privateAdd(this, _pathParts);
    __privateAdd(this, _isFavorite, false);
    __publicField2(this, "changeTracker", null);
    __publicField2(this, "unsaved", false);
    __publicField2(this, "manager");
    __publicField2(this, "load", () => __async(this, null, function* () {
      if (this.isOpen) {
        yield this.manager.app.loadGraphData(
          this.changeTracker.activeState,
          true,
          true,
          this
        );
      } else {
        const data28 = yield this.getWorkflowData();
        if (!data28) return;
        yield this.manager.app.loadGraphData(data28, true, true, this);
      }
    }));
    this.manager = manager;
    if (pathParts) {
      __privateMethod(this, _ComfyWorkflow_instances, updatePath_fn).call(this, path, pathParts);
      __privateSet(this, _isFavorite, isFavorite);
    } else {
      __privateSet(this, _name, path);
      this.unsaved = true;
    }
  }
  get name() {
    return __privateGet(this, _name);
  }
  get path() {
    return __privateGet(this, _path);
  }
  get pathParts() {
    return __privateGet(this, _pathParts);
  }
  get isFavorite() {
    return __privateGet(this, _isFavorite);
  }
  get isOpen() {
    return !!this.changeTracker;
  }
  getWorkflowData() {
    return __async(this, null, function* () {
      const resp = yield api.getUserData("workflows/" + this.path);
      if (resp.status !== 200) {
        alert(
          `Error loading workflow file '${this.path}': ${resp.status} ${resp.statusText}`
        );
        return;
      }
      return yield resp.json();
    });
  }
  save(saveAs2 = false) {
    return __async(this, null, function* () {
      if (!this.path || saveAs2) {
        return !!(yield __privateMethod(this, _ComfyWorkflow_instances, save_fn).call(this, null, false));
      } else {
        return !!(yield __privateMethod(this, _ComfyWorkflow_instances, save_fn).call(this, this.path, true));
      }
    });
  }
  favorite(value3) {
    return __async(this, null, function* () {
      var _a2;
      try {
        if (__privateGet(this, _isFavorite) === value3) return;
        __privateSet(this, _isFavorite, value3);
        yield this.manager.saveWorkflowMetadata();
        this.manager.dispatchEvent(new CustomEvent("favorite", { detail: this }));
      } catch (error) {
        alert(
          "Error favoriting workflow " + this.path + "\n" + ((_a2 = error.message) != null ? _a2 : error)
        );
      }
    });
  }
  rename(path) {
    return __async(this, null, function* () {
      var _a2;
      path = appendJsonExt(path);
      let resp = yield api.moveUserData(
        "workflows/" + this.path,
        "workflows/" + path
      );
      if (resp.status === 409) {
        if (!confirm(
          `Workflow '${path}' already exists, do you want to overwrite it?`
        ))
          return resp;
        resp = yield api.moveUserData(
          "workflows/" + this.path,
          "workflows/" + path,
          { overwrite: true }
        );
      }
      if (resp.status !== 200) {
        alert(
          `Error renaming workflow file '${this.path}': ${resp.status} ${resp.statusText}`
        );
        return;
      }
      const isFav = this.isFavorite;
      if (isFav) {
        yield this.favorite(false);
      }
      path = (yield resp.json()).substring("workflows/".length);
      __privateMethod(this, _ComfyWorkflow_instances, updatePath_fn).call(this, path, null);
      if (isFav) {
        yield this.favorite(true);
      }
      this.manager.dispatchEvent(new CustomEvent("rename", { detail: this }));
      setStorageValue("Comfy.PreviousWorkflow", (_a2 = this.path) != null ? _a2 : "");
    });
  }
  insert() {
    return __async(this, null, function* () {
      const data28 = yield this.getWorkflowData();
      if (!data28) return;
      const old = localStorage.getItem("litegrapheditor_clipboard");
      const graph = new LGraph(data28);
      const canvas = new LGraphCanvas(null, graph, {
        // @ts-expect-error
        skip_events: true,
        skip_render: true
      });
      canvas.selectNodes();
      canvas.copyToClipboard();
      this.manager.app.canvas.pasteFromClipboard();
      localStorage.setItem("litegrapheditor_clipboard", old);
    });
  }
  delete() {
    return __async(this, null, function* () {
      try {
        if (this.isFavorite) {
          yield this.favorite(false);
        }
        yield api.deleteUserData("workflows/" + this.path);
        this.unsaved = true;
        __privateSet(this, _path, null);
        __privateSet(this, _pathParts, null);
        this.manager.workflows.splice(this.manager.workflows.indexOf(this), 1);
        this.manager.dispatchEvent(new CustomEvent("delete", { detail: this }));
      } catch (error) {
        alert(`Error deleting workflow: ${error.message || error}`);
      }
    });
  }
  track() {
    if (this.changeTracker) {
      this.changeTracker.restore();
    } else {
      this.changeTracker = new ChangeTracker(this);
    }
  }
}
_name = new WeakMap();
_path = new WeakMap();
_pathParts = new WeakMap();
_isFavorite = new WeakMap();
_ComfyWorkflow_instances = new WeakSet();
updatePath_fn = function(path, pathParts) {
  __privateSet(this, _path, path);
  if (!pathParts) {
    if (!path.includes("\\")) {
      pathParts = path.split("/");
    } else {
      pathParts = path.split("\\");
    }
  }
  __privateSet(this, _pathParts, pathParts);
  __privateSet(this, _name, trimJsonExt(pathParts[pathParts.length - 1]));
};
save_fn = function(path, overwrite) {
  return __async(this, null, function* () {
    var _a2, _b, _c;
    if (!path) {
      path = prompt(
        "Save workflow as:",
        (_b = (_a2 = trimJsonExt(this.path)) != null ? _a2 : this.name) != null ? _b : "workflow"
      );
      if (!path) return;
    }
    path = appendJsonExt(path);
    const p2 = yield this.manager.app.graphToPrompt();
    const json = JSON.stringify(p2.workflow, null, 2);
    let resp = yield api.storeUserData("workflows/" + path, json, {
      stringify: false,
      throwOnError: false,
      overwrite
    });
    if (resp.status === 409) {
      if (!confirm(
        `Workflow '${path}' already exists, do you want to overwrite it?`
      ))
        return;
      resp = yield api.storeUserData("workflows/" + path, json, {
        stringify: false
      });
    }
    if (resp.status !== 200) {
      alert(
        `Error saving workflow '${this.path}': ${resp.status} ${resp.statusText}`
      );
      return;
    }
    path = (yield resp.json()).substring("workflows/".length);
    if (!this.path) {
      __privateMethod(this, _ComfyWorkflow_instances, updatePath_fn).call(this, path, null);
      yield this.manager.loadWorkflows();
      this.unsaved = false;
      this.manager.dispatchEvent(new CustomEvent("rename", { detail: this }));
      setStorageValue("Comfy.PreviousWorkflow", (_c = this.path) != null ? _c : "");
    } else if (path !== this.path) {
      yield this.manager.loadWorkflows();
      const workflow = this.manager.workflowLookup[path];
      yield workflow.load();
    } else {
      this.unsaved = false;
      this.manager.dispatchEvent(new CustomEvent("save", { detail: this }));
    }
    return true;
  });
};
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.workflows = window.comfyAPI.workflows || {};
window.comfyAPI.workflows.trimJsonExt = trimJsonExt;
window.comfyAPI.workflows.ComfyWorkflowManager = ComfyWorkflowManager;
window.comfyAPI.workflows.ComfyWorkflow = ComfyWorkflow;
class ComfyWorkflowsMenu {
  constructor(app2) {
    __privateAdd(this, _ComfyWorkflowsMenu_instances);
    __privateAdd(this, _first, true);
    __publicField2(this, "element", $el("div.comfyui-workflows"));
    __publicField2(this, "popup");
    __publicField2(this, "app");
    __publicField2(this, "buttonProgress");
    __publicField2(this, "workflowLabel");
    __publicField2(this, "button");
    __publicField2(this, "content");
    __publicField2(this, "unsaved");
    __privateAdd(this, _updateProgress, () => {
      const prompt2 = this.app.workflowManager.activePrompt;
      let percent = 0;
      if (this.app.workflowManager.activeWorkflow === (prompt2 == null ? void 0 : prompt2.workflow)) {
        const total = Object.values(prompt2.nodes);
        const done = total.filter(Boolean);
        percent = done.length / total.length * 100;
      }
      this.buttonProgress.style.width = percent + "%";
    });
    __privateAdd(this, _updateActive, () => {
      const active3 = this.app.workflowManager.activeWorkflow;
      this.button.tooltip = active3.path;
      this.workflowLabel.textContent = active3.name;
      this.unsaved = active3.unsaved;
      if (__privateGet(this, _first)) {
        __privateSet(this, _first, false);
        this.content.load();
      }
      __privateGet(this, _updateProgress).call(this);
    });
    this.app = app2;
    __privateMethod(this, _ComfyWorkflowsMenu_instances, bindEvents_fn).call(this);
    const classList = {
      "comfyui-workflows-button": true,
      "comfyui-button": true,
      unsaved: getStorageValue("Comfy.PreviousWorkflowUnsaved") === "true",
      running: false
    };
    this.buttonProgress = $el("div.comfyui-workflows-button-progress");
    this.workflowLabel = $el("span.comfyui-workflows-label", "");
    this.button = new ComfyButton({
      content: $el("div.comfyui-workflows-button-inner", [
        $el("i.mdi.mdi-graph"),
        this.workflowLabel,
        this.buttonProgress
      ]),
      icon: "chevron-down",
      classList
    });
    this.element.append(this.button.element);
    this.popup = new ComfyPopup({
      target: this.element,
      classList: "comfyui-workflows-popup"
    });
    this.content = new ComfyWorkflowsContent(app2, this.popup);
    this.popup.children = [this.content.element];
    this.popup.addEventListener("change", () => {
      this.button.icon = "chevron-" + (this.popup.open ? "up" : "down");
    });
    this.button.withPopup(this.popup);
    this.unsaved = prop(this, "unsaved", classList.unsaved, (v2) => {
      classList.unsaved = v2;
      this.button.classList = classList;
      setStorageValue("Comfy.PreviousWorkflowUnsaved", v2);
    });
  }
  get open() {
    return this.popup.open;
  }
  set open(open2) {
    this.popup.open = open2;
  }
  registerExtension(app2) {
    const self2 = this;
    app2.registerExtension({
      name: "Comfy.Workflows",
      beforeRegisterNodeDef(nodeType) {
        return __async(this, null, function* () {
          function getImageWidget(node3) {
            var _a3, _b, _c, _d, _e, _f;
            const inputs = __spreadValues2(__spreadValues2({}, (_c = (_b = (_a3 = node3.constructor) == null ? void 0 : _a3.nodeData) == null ? void 0 : _b.input) == null ? void 0 : _c.required), (_f = (_e = (_d = node3.constructor) == null ? void 0 : _d.nodeData) == null ? void 0 : _e.input) == null ? void 0 : _f.optional);
            for (const input in inputs) {
              if (inputs[input][0] === "IMAGEUPLOAD") {
                const imageWidget = node3.widgets.find(
                  (w2) => {
                    var _a4, _b2, _c2;
                    return w2.name === ((_c2 = (_b2 = (_a4 = inputs[input]) == null ? void 0 : _a4[1]) == null ? void 0 : _b2.widget) != null ? _c2 : "image");
                  }
                );
                if (imageWidget) return imageWidget;
              }
            }
          }
          function setWidgetImage(node3, widget, img) {
            const url = new URL(img.src);
            const filename = url.searchParams.get("filename");
            const subfolder = url.searchParams.get("subfolder");
            const type = url.searchParams.get("type");
            const imageId = `${subfolder ? subfolder + "/" : ""}${filename} [${type}]`;
            widget.value = imageId;
            node3.imgs = [img];
            app2.graph.setDirtyCanvas(true, true);
          }
          function sendToWorkflow(img, workflow) {
            return __async(this, null, function* () {
              var _a3;
              const openWorkflow = app2.workflowManager.openWorkflows.find(
                (w2) => w2.path === workflow.path
              );
              if (openWorkflow) {
                workflow = openWorkflow;
              }
              yield workflow.load();
              let options3 = [];
              const nodes = app2.graph.computeExecutionOrder(false);
              for (const node3 of nodes) {
                const widget = getImageWidget(node3);
                if (widget == null) continue;
                if ((_a3 = node3.title) == null ? void 0 : _a3.toLowerCase().includes("input")) {
                  options3 = [{ widget, node: node3 }];
                  break;
                } else {
                  options3.push({ widget, node: node3 });
                }
              }
              if (!options3.length) {
                alert("No image nodes have been found in this workflow!");
                return;
              } else if (options3.length > 1) {
                const dialog = new WidgetSelectionDialog(options3);
                const res = yield dialog.show(app2);
                if (!res) return;
                options3 = [res];
              }
              setWidgetImage(options3[0].node, options3[0].widget, img);
            });
          }
          const getExtraMenuOptions = nodeType.prototype["getExtraMenuOptions"];
          nodeType.prototype["getExtraMenuOptions"] = function(_2, options3) {
            var _a3, _b, _c, _d, _e;
            const r = (_a3 = getExtraMenuOptions == null ? void 0 : getExtraMenuOptions.apply) == null ? void 0 : _a3.call(getExtraMenuOptions, this, arguments);
            const setting = app2.ui.settings.getSettingValue(
              "Comfy.UseNewMenu",
              false
            );
            if (setting && setting != "Disabled") {
              const t = this;
              let img;
              if (t.imageIndex != null) {
                img = (_b = t.imgs) == null ? void 0 : _b[t.imageIndex];
              } else if (t.overIndex != null) {
                img = (_c = t.imgs) == null ? void 0 : _c[t.overIndex];
              }
              if (img) {
                let pos2 = options3.findIndex((o) => o.content === "Save Image");
                if (pos2 === -1) {
                  pos2 = 0;
                } else {
                  pos2++;
                }
                options3.splice(pos2, 0, {
                  content: "Send to workflow",
                  has_submenu: true,
                  submenu: {
                    options: [
                      {
                        callback: () => sendToWorkflow(img, app2.workflowManager.activeWorkflow),
                        title: "[Current workflow]"
                      },
                      ...__privateMethod(_d = self2, _ComfyWorkflowsMenu_instances, getFavoriteMenuOptions_fn).call(_d, sendToWorkflow.bind(null, img)),
                      null,
                      ...__privateMethod(_e = self2, _ComfyWorkflowsMenu_instances, getMenuOptions_fn).call(_e, sendToWorkflow.bind(null, img))
                    ]
                  }
                });
              }
            }
            return r;
          };
        });
      }
    });
  }
}
_first = new WeakMap();
_updateProgress = new WeakMap();
_updateActive = new WeakMap();
_ComfyWorkflowsMenu_instances = new WeakSet();
bindEvents_fn = function() {
  this.app.workflowManager.addEventListener(
    "changeWorkflow",
    __privateGet(this, _updateActive)
  );
  this.app.workflowManager.addEventListener("rename", __privateGet(this, _updateActive));
  this.app.workflowManager.addEventListener("delete", __privateGet(this, _updateActive));
  this.app.workflowManager.addEventListener("save", () => {
    this.unsaved = this.app.workflowManager.activeWorkflow.unsaved;
  });
  this.app.workflowManager.addEventListener("execute", (e) => {
    __privateGet(this, _updateProgress).call(this);
  });
  api.addEventListener("graphChanged", () => {
    this.unsaved = true;
  });
};
getMenuOptions_fn = function(callback) {
  const menu = [];
  const directories = /* @__PURE__ */ new Map();
  for (const workflow of this.app.workflowManager.workflows || []) {
    const path = workflow.pathParts;
    if (!path) continue;
    let parent = menu;
    let currentPath = "";
    for (let i2 = 0; i2 < path.length - 1; i2++) {
      currentPath += "/" + path[i2];
      let newParent = directories.get(currentPath);
      if (!newParent) {
        newParent = {
          title: path[i2],
          has_submenu: true,
          submenu: {
            options: []
          }
        };
        parent.push(newParent);
        newParent = newParent.submenu.options;
        directories.set(currentPath, newParent);
      }
      parent = newParent;
    }
    parent.push({
      title: trimJsonExt(path[path.length - 1]),
      callback: () => callback(workflow)
    });
  }
  return menu;
};
getFavoriteMenuOptions_fn = function(callback) {
  const menu = [];
  for (const workflow of this.app.workflowManager.workflows || []) {
    if (workflow.isFavorite) {
      menu.push({
        title: "⭐ " + workflow.name,
        callback: () => callback(workflow)
      });
    }
  }
  return menu;
};
class ComfyWorkflowsContent {
  constructor(app2, popup) {
    __privateAdd(this, _ComfyWorkflowsContent_instances);
    __publicField2(this, "element", $el("div.comfyui-workflows-panel"));
    __publicField2(this, "treeState", {});
    __publicField2(this, "treeFiles", {});
    __publicField2(this, "openFiles", /* @__PURE__ */ new Map());
    __publicField2(this, "activeElement", null);
    __publicField2(this, "spinner");
    __publicField2(this, "openElement");
    __publicField2(this, "favoritesElement");
    __publicField2(this, "treeElement");
    __publicField2(this, "app");
    __publicField2(this, "popup");
    __publicField2(this, "actions");
    __publicField2(this, "filterText");
    __publicField2(this, "treeRoot");
    this.app = app2;
    this.popup = popup;
    this.actions = $el("div.comfyui-workflows-actions", [
      new ComfyButton({
        content: "Default",
        icon: "file-code",
        iconSize: 18,
        classList: "comfyui-button primary",
        tooltip: "Load default workflow",
        action: () => {
          popup.open = false;
          app2.loadGraphData();
          app2.resetView();
        }
      }).element,
      new ComfyButton({
        content: "Browse",
        icon: "folder",
        iconSize: 18,
        tooltip: "Browse for an image or exported workflow",
        action: () => {
          popup.open = false;
          app2.ui.loadFile();
        }
      }).element,
      new ComfyButton({
        content: "Blank",
        icon: "plus-thick",
        iconSize: 18,
        tooltip: "Create a new blank workflow",
        action: () => {
          app2.workflowManager.setWorkflow(null);
          app2.clean();
          app2.graph.clear();
          app2.workflowManager.activeWorkflow.track();
          popup.open = false;
        }
      }).element
    ]);
    this.spinner = createSpinner();
    this.element.replaceChildren(this.actions, this.spinner);
    this.popup.addEventListener("open", () => this.load());
    this.popup.addEventListener(
      "close",
      () => this.element.replaceChildren(this.actions, this.spinner)
    );
    this.app.workflowManager.addEventListener("favorite", (e) => {
      var _a2;
      const workflow = e["detail"];
      const button = (_a2 = this.treeFiles[workflow.path]) == null ? void 0 : _a2.primary;
      if (!button) return;
      button.icon = __privateMethod(this, _ComfyWorkflowsContent_instances, getFavoriteIcon_fn).call(this, workflow);
      button.overIcon = __privateMethod(this, _ComfyWorkflowsContent_instances, getFavoriteOverIcon_fn).call(this, workflow);
      this.updateFavorites();
    });
    for (const e of ["save", "open", "close", "changeWorkflow"]) {
      app2.workflowManager.addEventListener(e, () => this.updateOpen());
    }
    this.app.workflowManager.addEventListener("rename", () => this.load());
    this.app.workflowManager.addEventListener(
      "execute",
      (e) => __privateMethod(this, _ComfyWorkflowsContent_instances, updateActive_fn).call(this)
    );
  }
  load() {
    return __async(this, null, function* () {
      yield this.app.workflowManager.loadWorkflows();
      this.updateTree();
      this.updateFavorites();
      this.updateOpen();
      this.element.replaceChildren(
        this.actions,
        this.openElement,
        this.favoritesElement,
        this.treeElement
      );
    });
  }
  updateOpen() {
    const current = this.openElement;
    this.openFiles.clear();
    this.openElement = $el("div.comfyui-workflows-open", [
      $el("h3", "Open"),
      ...this.app.workflowManager.openWorkflows.map((w2) => {
        const wrapper = new WorkflowElement(this, w2, {
          primary: { element: $el("i.mdi.mdi-18px.mdi-progress-pencil") },
          buttons: [
            __privateMethod(this, _ComfyWorkflowsContent_instances, getRenameButton_fn).call(this, w2),
            new ComfyButton({
              icon: "close",
              iconSize: 18,
              classList: "comfyui-button comfyui-workflows-file-action",
              tooltip: "Close workflow",
              action: (e) => {
                e.stopImmediatePropagation();
                this.app.workflowManager.closeWorkflow(w2);
              }
            })
          ]
        });
        if (w2.unsaved) {
          wrapper.element.classList.add("unsaved");
        }
        if (w2 === this.app.workflowManager.activeWorkflow) {
          wrapper.element.classList.add("active");
        }
        this.openFiles.set(w2, wrapper);
        return wrapper.element;
      })
    ]);
    __privateMethod(this, _ComfyWorkflowsContent_instances, updateActive_fn).call(this);
    current == null ? void 0 : current.replaceWith(this.openElement);
  }
  updateFavorites() {
    const current = this.favoritesElement;
    const favorites = [
      ...this.app.workflowManager.workflows.filter((w2) => w2.isFavorite)
    ];
    this.favoritesElement = $el("div.comfyui-workflows-favorites", [
      $el("h3", "Favorites"),
      ...favorites.map((w2) => {
        return __privateMethod(this, _ComfyWorkflowsContent_instances, getWorkflowElement_fn).call(this, w2).element;
      }).filter(Boolean)
    ]);
    current == null ? void 0 : current.replaceWith(this.favoritesElement);
  }
  filterTree() {
    if (!this.filterText) {
      this.treeRoot.classList.remove("filtered");
      for (const item of Object.values(this.treeFiles)) {
        item.element.parentElement.style.removeProperty("display");
        this.showTreeParents(item.element.parentElement);
      }
      return;
    }
    this.treeRoot.classList.add("filtered");
    const searchTerms = this.filterText.toLocaleLowerCase().split(" ");
    for (const item of Object.values(this.treeFiles)) {
      const parts2 = item.workflow.pathParts;
      let termIndex = 0;
      let valid = false;
      for (const part of parts2) {
        let currentIndex = 0;
        do {
          currentIndex = part.indexOf(searchTerms[termIndex], currentIndex);
          if (currentIndex > -1) currentIndex += searchTerms[termIndex].length;
        } while (currentIndex !== -1 && ++termIndex < searchTerms.length);
        if (termIndex >= searchTerms.length) {
          valid = true;
          break;
        }
      }
      if (valid) {
        item.element.parentElement.style.removeProperty("display");
        this.showTreeParents(item.element.parentElement);
      } else {
        item.element.parentElement.style.display = "none";
        this.hideTreeParents(item.element.parentElement);
      }
    }
  }
  hideTreeParents(element) {
    var _a2;
    if (((_a2 = element.parentElement) == null ? void 0 : _a2.classList.contains("comfyui-workflows-tree")) === false) {
      for (let i2 = 1; i2 < element.parentElement.children.length; i2++) {
        const c = element.parentElement.children[i2];
        if (c.style.display !== "none") {
          return;
        }
      }
      element.parentElement.style.display = "none";
      this.hideTreeParents(element.parentElement);
    }
  }
  showTreeParents(element) {
    var _a2;
    if (((_a2 = element.parentElement) == null ? void 0 : _a2.classList.contains("comfyui-workflows-tree")) === false) {
      element.parentElement.style.removeProperty("display");
      this.showTreeParents(element.parentElement);
    }
  }
  updateTree() {
    var _a2, _b;
    const current = this.treeElement;
    const nodes = {};
    let typingTimeout;
    this.treeFiles = {};
    this.treeRoot = $el("ul.comfyui-workflows-tree");
    this.treeElement = $el("section", [
      $el("header", [
        $el("h3", "Browse"),
        $el("div.comfy-ui-workflows-search", [
          $el("i.mdi.mdi-18px.mdi-magnify"),
          $el("input", {
            placeholder: "Search",
            value: (_a2 = this.filterText) != null ? _a2 : "",
            oninput: (e) => {
              var _a3;
              this.filterText = (_a3 = e.target["value"]) == null ? void 0 : _a3.trim();
              clearTimeout(typingTimeout);
              typingTimeout = setTimeout(() => this.filterTree(), 250);
            }
          })
        ])
      ]),
      this.treeRoot
    ]);
    for (const workflow of this.app.workflowManager.workflows) {
      if (!workflow.pathParts) continue;
      let currentPath = "";
      let currentRoot = this.treeRoot;
      for (let i2 = 0; i2 < workflow.pathParts.length; i2++) {
        currentPath += (currentPath ? "\\" : "") + workflow.pathParts[i2];
        const parentNode = (_b = nodes[currentPath]) != null ? _b : __privateMethod(this, _ComfyWorkflowsContent_instances, createNode_fn).call(this, currentPath, workflow, i2, currentRoot);
        nodes[currentPath] = parentNode;
        currentRoot = parentNode;
      }
    }
    current == null ? void 0 : current.replaceWith(this.treeElement);
    this.filterTree();
  }
}
_ComfyWorkflowsContent_instances = new WeakSet();
expandNode_fn = function(el, workflow, thisPath, i2) {
  const expanded2 = !el.classList.toggle("closed");
  if (expanded2) {
    let c = "";
    for (let j = 0; j <= i2; j++) {
      c += (c ? "\\" : "") + workflow.pathParts[j];
      this.treeState[c] = true;
    }
  } else {
    let c = thisPath;
    for (let j = i2 + 1; j < workflow.pathParts.length; j++) {
      c += (c ? "\\" : "") + workflow.pathParts[j];
      delete this.treeState[c];
    }
    delete this.treeState[thisPath];
  }
};
updateActive_fn = function() {
  __privateMethod(this, _ComfyWorkflowsContent_instances, removeActive_fn).call(this);
  const active3 = this.app.workflowManager.activePrompt;
  if (!(active3 == null ? void 0 : active3.workflow)) return;
  const open2 = this.openFiles.get(active3.workflow);
  if (!open2) return;
  this.activeElement = open2;
  const total = Object.values(active3.nodes);
  const done = total.filter(Boolean);
  const percent = done.length / total.length;
  open2.element.classList.add("running");
  open2.element.style.setProperty("--progress", percent * 100 + "%");
  open2.primary.element.classList.remove("mdi-progress-pencil");
  open2.primary.element.classList.add("mdi-play");
};
removeActive_fn = function() {
  if (!this.activeElement) return;
  this.activeElement.element.classList.remove("running");
  this.activeElement.element.style.removeProperty("--progress");
  this.activeElement.primary.element.classList.add("mdi-progress-pencil");
  this.activeElement.primary.element.classList.remove("mdi-play");
};
getFavoriteIcon_fn = function(workflow) {
  return workflow.isFavorite ? "star" : "file-outline";
};
getFavoriteOverIcon_fn = function(workflow) {
  return workflow.isFavorite ? "star-off" : "star-outline";
};
getFavoriteTooltip_fn = function(workflow) {
  return workflow.isFavorite ? "Remove this workflow from your favorites" : "Add this workflow to your favorites";
};
getFavoriteButton_fn = function(workflow, primary) {
  return new ComfyButton({
    icon: __privateMethod(this, _ComfyWorkflowsContent_instances, getFavoriteIcon_fn).call(this, workflow),
    overIcon: __privateMethod(this, _ComfyWorkflowsContent_instances, getFavoriteOverIcon_fn).call(this, workflow),
    iconSize: 18,
    classList: "comfyui-button comfyui-workflows-file-action-favorite" + (primary ? " comfyui-workflows-file-action-primary" : ""),
    tooltip: __privateMethod(this, _ComfyWorkflowsContent_instances, getFavoriteTooltip_fn).call(this, workflow),
    action: (e) => {
      e.stopImmediatePropagation();
      workflow.favorite(!workflow.isFavorite);
    }
  });
};
getDeleteButton_fn = function(workflow) {
  const deleteButton = new ComfyButton({
    icon: "delete",
    tooltip: "Delete this workflow",
    classList: "comfyui-button comfyui-workflows-file-action",
    iconSize: 18,
    action: (e, btn) => __async(this, null, function* () {
      e.stopImmediatePropagation();
      if (btn.icon === "delete-empty") {
        btn.enabled = false;
        yield workflow.delete();
        yield this.load();
      } else {
        btn.icon = "delete-empty";
        btn.element.style.background = "red";
      }
    })
  });
  deleteButton.element.addEventListener("mouseleave", () => {
    deleteButton.icon = "delete";
    deleteButton.element.style.removeProperty("background");
  });
  return deleteButton;
};
getInsertButton_fn = function(workflow) {
  return new ComfyButton({
    icon: "file-move-outline",
    iconSize: 18,
    tooltip: "Insert this workflow into the current workflow",
    classList: "comfyui-button comfyui-workflows-file-action",
    action: (e) => {
      if (!this.app.shiftDown) {
        this.popup.open = false;
      }
      e.stopImmediatePropagation();
      if (!this.app.shiftDown) {
        this.popup.open = false;
      }
      workflow.insert();
    }
  });
};
/** @param {ComfyWorkflow} workflow */
getRenameButton_fn = function(workflow) {
  return new ComfyButton({
    icon: "pencil",
    tooltip: workflow.path ? "Rename this workflow" : "This workflow can't be renamed as it hasn't been saved.",
    classList: "comfyui-button comfyui-workflows-file-action",
    iconSize: 18,
    enabled: !!workflow.path,
    action: (e) => __async(this, null, function* () {
      e.stopImmediatePropagation();
      const newName = prompt("Enter new name", workflow.path);
      if (newName) {
        yield workflow.rename(newName);
      }
    })
  });
};
getWorkflowElement_fn = function(workflow) {
  return new WorkflowElement(this, workflow, {
    primary: __privateMethod(this, _ComfyWorkflowsContent_instances, getFavoriteButton_fn).call(this, workflow, true),
    buttons: [
      __privateMethod(this, _ComfyWorkflowsContent_instances, getInsertButton_fn).call(this, workflow),
      __privateMethod(this, _ComfyWorkflowsContent_instances, getRenameButton_fn).call(this, workflow),
      __privateMethod(this, _ComfyWorkflowsContent_instances, getDeleteButton_fn).call(this, workflow)
    ]
  });
};
createLeafNode_fn = function(workflow) {
  const fileNode = __privateMethod(this, _ComfyWorkflowsContent_instances, getWorkflowElement_fn).call(this, workflow);
  this.treeFiles[workflow.path] = fileNode;
  return fileNode;
};
createNode_fn = function(currentPath, workflow, i2, currentRoot) {
  const part = workflow.pathParts[i2];
  const parentNode = $el(
    "ul" + (this.treeState[currentPath] ? "" : ".closed"),
    {
      $: (el) => {
        el.onclick = (e) => {
          __privateMethod(this, _ComfyWorkflowsContent_instances, expandNode_fn).call(this, el, workflow, currentPath, i2);
          e.stopImmediatePropagation();
        };
      }
    }
  );
  currentRoot.append(parentNode);
  const leaf2 = i2 === workflow.pathParts.length - 1;
  let nodeElement;
  if (leaf2) {
    nodeElement = __privateMethod(this, _ComfyWorkflowsContent_instances, createLeafNode_fn).call(this, workflow).element;
  } else {
    nodeElement = $el("li", [
      $el("i.mdi.mdi-18px.mdi-folder"),
      $el("span", part)
    ]);
  }
  parentNode.append(nodeElement);
  return parentNode;
};
class WorkflowElement {
  constructor(parent, workflow, {
    tagName = "li",
    primary,
    buttons
  }) {
    __publicField2(this, "parent");
    __publicField2(this, "workflow");
    __publicField2(this, "primary");
    __publicField2(this, "buttons");
    __publicField2(this, "element");
    var _a2;
    this.parent = parent;
    this.workflow = workflow;
    this.primary = primary;
    this.buttons = buttons;
    this.element = $el(
      tagName + ".comfyui-workflows-tree-file",
      {
        onclick: () => {
          workflow.load();
          this.parent.popup.open = false;
        },
        title: this.workflow.path
      },
      [
        (_a2 = this.primary) == null ? void 0 : _a2.element,
        $el("span", workflow.name),
        ...buttons.map((b) => b.element)
      ]
    );
  }
}
class WidgetSelectionDialog extends ComfyAsyncDialog {
  constructor(options3) {
    super();
    __privateAdd(this, _options);
    __privateSet(this, _options, options3);
  }
  show(app2) {
    this.element.classList.add("comfy-widget-selection-dialog");
    return super.show(
      $el("div", [
        $el("h2", "Select image target"),
        $el(
          "p",
          "This workflow has multiple image loader nodes, you can rename a node to include 'input' in the title for it to be automatically selected, or select one below."
        ),
        $el(
          "section",
          __privateGet(this, _options).map((opt) => {
            var _a2;
            return $el("div.comfy-widget-selection-item", [
              $el(
                "span",
                { dataset: { id: opt.node.id } },
                `${(_a2 = opt.node.title) != null ? _a2 : opt.node.type} ${opt.widget.name}`
              ),
              $el(
                "button.comfyui-button",
                {
                  onclick: () => {
                    app2.canvas.ds.offset[0] = -opt.node.pos[0] + 50;
                    app2.canvas.ds.offset[1] = -opt.node.pos[1] + 50;
                    app2.canvas.selectNode(opt.node);
                    app2.graph.setDirtyCanvas(true, true);
                  }
                },
                "Show"
              ),
              $el(
                "button.comfyui-button.primary",
                {
                  onclick: () => {
                    this.close(opt);
                  }
                },
                "Select"
              )
            ]);
          })
        )
      ])
    );
  }
}
_options = new WeakMap();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.workflows = window.comfyAPI.workflows || {};
window.comfyAPI.workflows.ComfyWorkflowsMenu = ComfyWorkflowsMenu;
window.comfyAPI.workflows.ComfyWorkflowsContent = ComfyWorkflowsContent;
function getInterruptButton(visibility) {
  const btn = new ComfyButton({
    icon: "close",
    tooltip: "Cancel current generation",
    enabled: false,
    action: () => {
      api.interrupt();
    },
    classList: ["comfyui-button", "comfyui-interrupt-button", visibility]
  });
  api.addEventListener(
    "status",
    ({ detail }) => {
      var _a2;
      const sz = (_a2 = detail == null ? void 0 : detail.exec_info) == null ? void 0 : _a2.queue_remaining;
      btn.enabled = sz > 0;
    }
  );
  return btn;
}
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.interruptButton = window.comfyAPI.interruptButton || {};
window.comfyAPI.interruptButton.getInterruptButton = getInterruptButton;
const collapseOnMobile = (t) => {
  var _a2;
  ;
  ((_a2 = t.element) != null ? _a2 : t).classList.add("comfyui-menu-mobile-collapse");
  return t;
};
const showOnMobile = (t) => {
  var _a2;
  ;
  ((_a2 = t.element) != null ? _a2 : t).classList.add("lt-lg-show");
  return t;
};
class ComfyAppMenu {
  constructor(app2) {
    __privateAdd(this, _sizeBreak, "lg");
    __privateAdd(this, _lastSizeBreaks, {
      lg: null,
      md: null,
      sm: null,
      xs: null
    });
    __privateAdd(this, _sizeBreaks, Object.keys(__privateGet(this, _lastSizeBreaks)));
    __privateAdd(this, _cachedInnerSize, null);
    __privateAdd(this, _cacheTimeout, null);
    __publicField2(this, "app");
    __publicField2(this, "workflows");
    __publicField2(this, "logo");
    __publicField2(this, "saveButton");
    __publicField2(this, "actionsGroup");
    __publicField2(this, "settingsGroup");
    __publicField2(this, "viewGroup");
    __publicField2(this, "mobileMenuButton");
    __publicField2(this, "queueButton");
    __publicField2(this, "element");
    __publicField2(this, "menuPositionSetting");
    __publicField2(this, "position");
    this.app = app2;
    this.workflows = new ComfyWorkflowsMenu(app2);
    const getSaveButton = (t) => new ComfyButton({
      icon: "content-save",
      tooltip: "Save the current workflow",
      action: () => app2.workflowManager.activeWorkflow.save(),
      content: t
    });
    this.logo = $el("h1.comfyui-logo.nlg-hide", { title: "ComfyUI" }, "ComfyUI");
    this.saveButton = new ComfySplitButton(
      {
        primary: getSaveButton(),
        mode: "hover",
        position: "absolute"
      },
      getSaveButton("Save"),
      new ComfyButton({
        icon: "content-save-edit",
        content: "Save As",
        tooltip: "Save the current graph as a new workflow",
        action: () => app2.workflowManager.activeWorkflow.save(true)
      }),
      new ComfyButton({
        icon: "download",
        content: "Export",
        tooltip: "Export the current workflow as JSON",
        action: () => this.exportWorkflow("workflow", "workflow")
      }),
      new ComfyButton({
        icon: "api",
        content: "Export (API Format)",
        tooltip: "Export the current workflow as JSON for use with the ComfyUI API",
        action: () => this.exportWorkflow("workflow_api", "output"),
        visibilitySetting: { id: "Comfy.DevMode", showValue: true },
        app: app2
      })
    );
    this.actionsGroup = new ComfyButtonGroup(
      new ComfyButton({
        icon: "refresh",
        content: "Refresh",
        tooltip: "Refresh widgets in nodes to find new models or files",
        action: () => app2.refreshComboInNodes()
      }),
      new ComfyButton({
        icon: "clipboard-edit-outline",
        content: "Clipspace",
        tooltip: "Open Clipspace window",
        action: () => app2["openClipspace"]()
      }),
      new ComfyButton({
        icon: "fit-to-page-outline",
        content: "Reset View",
        tooltip: "Reset the canvas view",
        action: () => app2.resetView()
      }),
      new ComfyButton({
        icon: "cancel",
        content: "Clear",
        tooltip: "Clears current workflow",
        action: () => {
          if (!app2.ui.settings.getSettingValue("Comfy.ConfirmClear", true) || confirm("Clear workflow?")) {
            app2.clean();
            app2.graph.clear();
            api.dispatchEvent(new CustomEvent("graphCleared"));
          }
        }
      })
    );
    this.settingsGroup = new ComfyButtonGroup();
    this.viewGroup = new ComfyButtonGroup(
      getInterruptButton("nlg-hide").element
    );
    this.mobileMenuButton = new ComfyButton({
      icon: "menu",
      action: (_2, btn) => {
        btn.icon = this.element.classList.toggle("expanded") ? "menu-open" : "menu";
        window.dispatchEvent(new Event("resize"));
      },
      classList: "comfyui-button comfyui-menu-button"
    });
    this.queueButton = new ComfyQueueButton(app2);
    this.element = $el("nav.comfyui-menu.lg", { style: { display: "none" } }, [
      this.logo,
      this.workflows.element,
      this.saveButton.element,
      collapseOnMobile(this.actionsGroup).element,
      $el("section.comfyui-menu-push"),
      collapseOnMobile(this.settingsGroup).element,
      collapseOnMobile(this.viewGroup).element,
      getInterruptButton("lt-lg-show").element,
      this.queueButton.element,
      showOnMobile(this.mobileMenuButton).element
    ]);
    let resizeHandler;
    this.menuPositionSetting = app2.ui.settings.addSetting({
      id: "Comfy.UseNewMenu",
      defaultValue: "Disabled",
      name: "[Beta] Use new menu and workflow management. Note: On small screens the menu will always be at the top.",
      type: "combo",
      options: ["Disabled", "Top", "Bottom"],
      onChange: (v2) => __async(this, null, function* () {
        if (v2 && v2 !== "Disabled") {
          if (!resizeHandler) {
            resizeHandler = () => {
              this.calculateSizeBreak();
            };
            window.addEventListener("resize", resizeHandler);
          }
          this.updatePosition(v2);
        } else {
          if (resizeHandler) {
            window.removeEventListener("resize", resizeHandler);
            resizeHandler = null;
          }
          document.body.style.removeProperty("display");
          app2.ui.menuContainer.style.removeProperty("display");
          this.element.style.display = "none";
          app2.ui.restoreMenuPosition();
        }
        window.dispatchEvent(new Event("resize"));
      })
    });
  }
  updatePosition(v2) {
    document.body.style.display = "grid";
    this.app.ui.menuContainer.style.display = "none";
    this.element.style.removeProperty("display");
    this.position = v2;
    if (v2 === "Bottom") {
      this.app.bodyBottom.append(this.element);
    } else {
      this.app.bodyTop.prepend(this.element);
    }
    this.calculateSizeBreak();
  }
  updateSizeBreak(idx, prevIdx, direction) {
    const newSize = __privateGet(this, _sizeBreaks)[idx];
    if (newSize === __privateGet(this, _sizeBreak)) return;
    __privateSet(this, _cachedInnerSize, null);
    clearTimeout(__privateGet(this, _cacheTimeout));
    __privateSet(this, _sizeBreak, __privateGet(this, _sizeBreaks)[idx]);
    for (let i2 = 0; i2 < __privateGet(this, _sizeBreaks).length; i2++) {
      const sz = __privateGet(this, _sizeBreaks)[i2];
      if (sz === __privateGet(this, _sizeBreak)) {
        this.element.classList.add(sz);
      } else {
        this.element.classList.remove(sz);
      }
      if (i2 < idx) {
        this.element.classList.add("lt-" + sz);
      } else {
        this.element.classList.remove("lt-" + sz);
      }
    }
    if (idx) {
      if (this.position !== "Top") {
        this.updatePosition("Top");
      }
    } else if (this.position != this.menuPositionSetting.value) {
      this.updatePosition(this.menuPositionSetting.value);
    }
    if (!direction) {
      direction = prevIdx - idx;
    } else if (direction != prevIdx - idx) {
      return;
    }
    this.calculateSizeBreak(direction);
  }
  calculateSizeBreak(direction = 0) {
    let idx = __privateGet(this, _sizeBreaks).indexOf(__privateGet(this, _sizeBreak));
    const currIdx = idx;
    const innerSize = this.calculateInnerSize(idx);
    if (window.innerWidth >= __privateGet(this, _lastSizeBreaks)[__privateGet(this, _sizeBreaks)[idx - 1]]) {
      if (idx > 0) {
        idx--;
      }
    } else if (innerSize > this.element.clientWidth) {
      __privateGet(this, _lastSizeBreaks)[__privateGet(this, _sizeBreak)] = Math.max(
        window.innerWidth,
        innerSize
      );
      if (idx < __privateGet(this, _sizeBreaks).length - 1) {
        idx++;
      }
    }
    this.updateSizeBreak(idx, currIdx, direction);
  }
  calculateInnerSize(idx) {
    clearTimeout(__privateGet(this, _cacheTimeout));
    if (__privateGet(this, _cachedInnerSize)) {
      __privateSet(this, _cacheTimeout, setTimeout(() => __privateSet(this, _cachedInnerSize, null), 100));
    } else {
      let innerSize = 0;
      let count = 1;
      for (const c of this.element.children) {
        if (c.classList.contains("comfyui-menu-push")) continue;
        if (idx && c.classList.contains("comfyui-menu-mobile-collapse"))
          continue;
        innerSize += c.clientWidth;
        count++;
      }
      innerSize += 8 * count;
      __privateSet(this, _cachedInnerSize, innerSize);
      __privateSet(this, _cacheTimeout, setTimeout(() => __privateSet(this, _cachedInnerSize, null), 100));
    }
    return __privateGet(this, _cachedInnerSize);
  }
  getFilename(defaultName) {
    if (this.app.ui.settings.getSettingValue("Comfy.PromptFilename", true)) {
      defaultName = prompt("Save workflow as:", defaultName);
      if (!defaultName) return;
      if (!defaultName.toLowerCase().endsWith(".json")) {
        defaultName += ".json";
      }
    }
    return defaultName;
  }
  exportWorkflow(filename, promptProperty) {
    return __async(this, null, function* () {
      var _a2;
      if ((_a2 = this.app.workflowManager.activeWorkflow) == null ? void 0 : _a2.path) {
        filename = this.app.workflowManager.activeWorkflow.name;
      }
      const p2 = yield this.app.graphToPrompt();
      const json = JSON.stringify(p2[promptProperty], null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const file = this.getFilename(filename);
      if (!file) return;
      downloadBlob(file, blob);
    });
  }
}
_sizeBreak = new WeakMap();
_lastSizeBreaks = new WeakMap();
_sizeBreaks = new WeakMap();
_cachedInnerSize = new WeakMap();
_cacheTimeout = new WeakMap();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.index = window.comfyAPI.index || {};
window.comfyAPI.index.ComfyAppMenu = ComfyAppMenu;
const getNodeSource = (python_module) => {
  const modules = python_module.split(".");
  if (["nodes", "comfy_extras"].includes(modules[0])) {
    return {
      type: "core",
      className: "comfy-core",
      displayText: "Comfy Core"
    };
  } else if (modules[0] === "custom_nodes") {
    return {
      type: "custom_nodes",
      className: "comfy-custom-nodes",
      displayText: modules[1]
    };
  } else {
    throw new Error(`Unknown node source: ${python_module}`);
  }
};
function isArray$1(value3) {
  return !Array.isArray ? getTag(value3) === "[object Array]" : Array.isArray(value3);
}
const INFINITY = 1 / 0;
function baseToString(value3) {
  if (typeof value3 == "string") {
    return value3;
  }
  let result = value3 + "";
  return result == "0" && 1 / value3 == -INFINITY ? "-0" : result;
}
function toString(value3) {
  return value3 == null ? "" : baseToString(value3);
}
function isString$2(value3) {
  return typeof value3 === "string";
}
function isNumber$1(value3) {
  return typeof value3 === "number";
}
function isBoolean$1(value3) {
  return value3 === true || value3 === false || isObjectLike(value3) && getTag(value3) == "[object Boolean]";
}
function isObject$2(value3) {
  return typeof value3 === "object";
}
function isObjectLike(value3) {
  return isObject$2(value3) && value3 !== null;
}
function isDefined(value3) {
  return value3 !== void 0 && value3 !== null;
}
function isBlank(value3) {
  return !value3.trim().length;
}
function getTag(value3) {
  return value3 == null ? value3 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value3);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn$1 = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString$2(key) || isArray$1(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn$1.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn$1.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray$1(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray$1(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index2]) {
      list.push(obj2);
    } else {
      let key = path2[index2];
      const value3 = obj2[key];
      if (!isDefined(value3)) {
        return;
      }
      if (index2 === path2.length - 1 && (isString$2(value3) || isNumber$1(value3) || isBoolean$1(value3))) {
        list.push(toString(value3));
      } else if (isArray$1(value3)) {
        arr = true;
        for (let i2 = 0, len = value3.length; i2 < len; i2 += 1) {
          deepGet(value3[i2], path2, index2 + 1);
        }
      } else if (path2.length) {
        deepGet(value3, path2, index2 + 1);
      }
    }
  };
  deepGet(obj, isString$2(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = __spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache2 = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value3) {
      const numTokens = value3.match(SPACE).length;
      if (cache2.has(numTokens)) {
        return cache2.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache2.set(numTokens, n);
      return n;
    },
    clear() {
      cache2.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString$2(this.docs[0])) {
      this.docs.forEach((doc2, docIndex) => {
        this._addString(doc2, docIndex);
      });
    } else {
      this.docs.forEach((doc2, docIndex) => {
        this._addObject(doc2, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc2) {
    const idx = this.size();
    if (isString$2(doc2)) {
      this._addString(doc2, idx);
    } else {
      this._addObject(doc2, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
      this.records[i2].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc2, docIndex) {
    if (!isDefined(doc2) || isBlank(doc2)) {
      return;
    }
    let record = {
      v: doc2,
      i: docIndex,
      n: this.norm.get(doc2)
    };
    this.records.push(record);
  }
  _addObject(doc2, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value3 = key.getFn ? key.getFn(doc2) : this.getFn(doc2, key.path);
      if (!isDefined(value3)) {
        return;
      }
      if (isArray$1(value3)) {
        let subRecords = [];
        const stack2 = [{ nestedArrIndex: -1, value: value3 }];
        while (stack2.length) {
          const { nestedArrIndex, value: value4 } = stack2.pop();
          if (!isDefined(value4)) {
            continue;
          }
          if (isString$2(value4) && !isBlank(value4)) {
            let subRecord = {
              v: value4,
              i: nestedArrIndex,
              n: this.norm.get(value4)
            };
            subRecords.push(subRecord);
          } else if (isArray$1(value4)) {
            value4.forEach((item, k) => {
              stack2.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString$2(value3) && !isBlank(value3)) {
        let subRecord = {
          v: value3,
          n: this.norm.get(value3)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data28, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data28;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance: distance2 = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance2) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance2;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end = -1;
  let i2 = 0;
  for (let len = matchmask.length; i2 < len; i2 += 1) {
    let match = matchmask[i2];
    if (match && start2 === -1) {
      start2 = i2;
    } else if (!match && start2 !== -1) {
      end = i2 - 1;
      if (end - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i2 - 1] && i2 - start2 >= minMatchCharLength) {
    indices.push([start2, i2 - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location: location2 = Config.location,
  distance: distance2 = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i2 = 0;
      while (i2 < patternLen) {
        matchMask[index2 + i2] = 1;
        i2 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask3 = 1 << patternLen - 1;
  for (let i2 = 0; i2 < patternLen; i2 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i2,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance: distance2,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i2) - 1;
    for (let j = finish; j >= start2; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i2) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask3) {
        finalScore = computeScore$1(pattern, {
          errors: i2,
          currentLocation,
          expectedLocation,
          distance: distance2,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i2 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask3 = {};
  for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
    const char = pattern.charAt(i2);
    mask3[char] = (mask3[char] || 0) | 1 << len - i2 - 1;
  }
  return mask3;
}
class BitapSearch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i2 = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i2 < end) {
        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
        i2 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance: distance2,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location2 + startIndex,
        distance: distance2,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches2 = pattern.match(exp);
  return matches2 ? matches2[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index2 = text2.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location2 = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text2.indexOf(this.pattern, location2)) > -1) {
      location2 = index2 + patternLen;
      indices.push([index2, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options3 = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
      const queryItem = query[i2];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options3));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options3));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance: distance2
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_2, options3) {
    return options3.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
      const searchers2 = query[i2];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register$1(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options3) {
  for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
    let searcherClass = registeredSearchers[i2];
    if (searcherClass.condition(pattern, options3)) {
      return new searcherClass(pattern, options3);
    }
  }
  return new BitapSearch(pattern, options3);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray$1(query) && isObject$2(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse$1(query, options3, { auto = true } = {}) {
  const next2 = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next2(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString$2(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options3);
      }
      return obj;
    }
    let node3 = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value3 = query2[key];
      if (isArray$1(value3)) {
        value3.forEach((item) => {
          node3.children.push(next2(item));
        });
      }
    });
    return node3;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next2(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data28) {
  const matches2 = result.matches;
  data28.matches = [];
  if (!isDefined(matches2)) {
    return;
  }
  matches2.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value: value3 } = match;
    let obj = {
      indices,
      value: value3
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data28.matches.push(obj);
  });
}
function transformScore(result, data28) {
  data28.score = result.score;
}
function format$3(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data28 = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data28);
      });
    }
    return data28;
  });
}
class Fuse {
  constructor(docs, options3 = {}, index2) {
    this.options = __spreadValues2(__spreadValues2({}, Config), options3);
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc2) {
    if (!isDefined(doc2)) {
      return;
    }
    this._docs.push(doc2);
    this._myIndex.add(doc2);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
      const doc2 = this._docs[i2];
      if (predicate(doc2, i2)) {
        this.removeAt(i2);
        i2 -= 1;
        len -= 1;
        results.push(doc2);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString$2(query) ? isString$2(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber$1(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format$3(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse$1(query, this.options);
    const evaluate = (node3, item, idx) => {
      if (!node3.children) {
        const { keyId, searcher } = node3;
        const matches2 = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches2 && matches2.length) {
          return [
            {
              idx,
              item,
              matches: matches2
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i2 = 0, len = node3.children.length; i2 < len; i2 += 1) {
        const child = node3.children[i2];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node3.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches: matches2 }) => {
            resultMap[idx].matches.push(...matches2);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches2 = [];
      keys.forEach((key, keyIndex) => {
        matches2.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches2.length) {
        results.push({
          idx,
          item,
          matches: matches2
        });
      }
    });
    return results;
  }
  _findMatches({ key, value: value3, searcher }) {
    if (!isDefined(value3)) {
      return [];
    }
    let matches2 = [];
    if (isArray$1(value3)) {
      value3.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches2.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value3;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches2.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches2;
  }
}
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse$1;
}
{
  register$1(ExtendedSearch);
}
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;
(function(module, exports) {
  ;
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root27 = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value3 = array[index2];
        setter(accumulator, value3, iteratee(value3), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value3 = array[index2];
        if (predicate(value3, index2, array)) {
          result[resIndex++] = value3;
        }
      }
      return result;
    }
    function arrayIncludes(array, value3) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value3, 0) > -1;
    }
    function arrayIncludesWith(array, value3, comparator2) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator2(value3, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values2) {
      var index2 = -1, length = values2.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values2[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value3, key, collection2) {
        if (predicate(value3, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value3, fromIndex) {
      return value3 === value3 ? strictIndexOf(array, value3, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value3, fromIndex, comparator2) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator2(array[index2], value3)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value3) {
      return value3 !== value3;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value3, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value3) : iteratee(accumulator, value3, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value3) {
        return func(value3);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data28, result = [];
      while (!(data28 = iterator.next()).done) {
        result.push(data28.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value3, key) {
        result[++index2] = [key, value3];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value3 = array[index2];
        if (value3 === placeholder || value3 === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value3) {
        result[++index2] = value3;
      });
      return result;
    }
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value3) {
        result[++index2] = [value3, value3];
      });
      return result;
    }
    function strictIndexOf(array, value3, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value3) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value3, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value3) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root27 : _2.defaults(root27.Object(), context, _2.pick(root27, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root27._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root27.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root27.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root27.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value3) {
        if (isObjectLike2(value3) && !isArray3(value3) && !(value3 instanceof LazyWrapper)) {
          if (value3 instanceof LodashWrapper) {
            return value3;
          }
          if (hasOwnProperty2.call(value3, "__wrapped__")) {
            return wrapperClone(value3);
          }
        }
        return new LodashWrapper(value3);
      }
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject3(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value3, chainAll) {
        this.__wrapped__ = value3;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value3) {
        this.__wrapped__ = value3;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray3(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value3 = array[index2];
            while (++iterIndex < iterLength) {
              var data28 = iteratees[iterIndex], iteratee2 = data28.iteratee, type = data28.type, computed2 = iteratee2(value3);
              if (type == LAZY_MAP_FLAG) {
                value3 = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value3;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data28 = this.__data__;
        if (nativeCreate) {
          var result2 = data28[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data28, key) ? data28[key] : undefined$1;
      }
      function hashHas(key) {
        var data28 = this.__data__;
        return nativeCreate ? data28[key] !== undefined$1 : hasOwnProperty2.call(data28, key);
      }
      function hashSet(key, value3) {
        var data28 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data28[key] = nativeCreate && value3 === undefined$1 ? HASH_UNDEFINED : value3;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data28 = this.__data__, index2 = assocIndexOf(data28, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data28.length - 1;
        if (index2 == lastIndex) {
          data28.pop();
        } else {
          splice.call(data28, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data28 = this.__data__, index2 = assocIndexOf(data28, key);
        return index2 < 0 ? undefined$1 : data28[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value3) {
        var data28 = this.__data__, index2 = assocIndexOf(data28, key);
        if (index2 < 0) {
          ++this.size;
          data28.push([key, value3]);
        } else {
          data28[index2][1] = value3;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value3) {
        var data28 = getMapData(this, key), size3 = data28.size;
        data28.set(key, value3);
        this.size += data28.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values3) {
        var index2 = -1, length = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values3[index2]);
        }
      }
      function setCacheAdd(value3) {
        this.__data__.set(value3, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value3) {
        return this.__data__.has(value3);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data28 = this.__data__ = new ListCache(entries);
        this.size = data28.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data28 = this.__data__, result2 = data28["delete"](key);
        this.size = data28.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value3) {
        var data28 = this.__data__;
        if (data28 instanceof ListCache) {
          var pairs = data28.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value3]);
            this.size = ++data28.size;
            return this;
          }
          data28 = this.__data__ = new MapCache(pairs);
        }
        data28.set(key, value3);
        this.size = data28.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value3, inherited) {
        var isArr = isArray3(value3), isArg = !isArr && isArguments(value3), isBuff = !isArr && !isArg && isBuffer(value3), isType = !isArr && !isArg && !isBuff && isTypedArray(value3), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value3.length, String2) : [], length = result2.length;
        for (var key in value3) {
          if ((inherited || hasOwnProperty2.call(value3, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value3) {
        if (value3 !== undefined$1 && !eq(object[key], value3) || value3 === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value3);
        }
      }
      function assignValue(object, key, value3) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value3)) || value3 === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value3);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value3, key, collection2) {
          setter(accumulator, value3, iteratee2(value3), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value3) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value3,
            "writable": true
          });
        } else {
          object[key] = value3;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number2, lower, upper) {
        if (number2 === number2) {
          if (upper !== undefined$1) {
            number2 = number2 <= upper ? number2 : upper;
          }
          if (lower !== undefined$1) {
            number2 = number2 >= lower ? number2 : lower;
          }
        }
        return number2;
      }
      function baseClone(value3, bitmask, customizer, key, object, stack2) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value3, key, object, stack2) : customizer(value3);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject3(value3)) {
          return value3;
        }
        var isArr = isArray3(value3);
        if (isArr) {
          result2 = initCloneArray(value3);
          if (!isDeep) {
            return copyArray(value3, result2);
          }
        } else {
          var tag = getTag2(value3), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value3)) {
            return cloneBuffer(value3, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value3);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value3, baseAssignIn(result2, value3)) : copySymbols(value3, baseAssign(result2, value3));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value3 : {};
            }
            result2 = initCloneByTag(value3, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack());
        var stacked = stack2.get(value3);
        if (stacked) {
          return stacked;
        }
        stack2.set(value3, result2);
        if (isSet2(value3)) {
          value3.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value3, stack2));
          });
        } else if (isMap2(value3)) {
          value3.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value3, stack2));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value3);
        arrayEach(props || value3, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value3[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value3, stack2));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value3 = object[key];
          if (value3 === undefined$1 && !(key in object) || !predicate(value3)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values3, iteratee2, comparator2) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values3 = arrayMap(values3, baseUnary(iteratee2));
        }
        if (comparator2) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values3 = new SetCache(values3);
        }
        outer:
          while (++index2 < length) {
            var value3 = array[index2], computed2 = iteratee2 == null ? value3 : iteratee2(value3);
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value3);
            } else if (!includes2(values3, computed2, comparator2)) {
              result2.push(value3);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value3, index2, collection2) {
          result2 = !!predicate(value3, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator2) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value3 = array[index2], current = iteratee2(value3);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator2(current, computed2))) {
            var computed2 = current, result2 = value3;
          }
        }
        return result2;
      }
      function baseFill(array, value3, start2, end) {
        var length = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start2 > end ? 0 : toLength(end);
        while (start2 < end) {
          array[start2++] = value3;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value3, index2, collection2) {
          if (predicate(value3, index2, collection2)) {
            result2.push(value3);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value3 = array[index2];
          if (depth > 0 && predicate(value3)) {
            if (depth > 1) {
              baseFlatten(value3, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value3);
            }
          } else if (!isStrict) {
            result2[result2.length] = value3;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction3(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray3(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value3) {
        if (value3 == null) {
          return value3 === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value3) ? getRawTag(value3) : objectToString2(value3);
      }
      function baseGt(value3, other) {
        return value3 > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number2, start2, end) {
        return number2 >= nativeMin(start2, end) && number2 < nativeMax(start2, end);
      }
      function baseIntersection(arrays, iteratee2, comparator2) {
        var includes2 = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator2 && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen2 = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (!(seen2 ? cacheHas(seen2, computed2) : includes2(result2, computed2, comparator2))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator2))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value3, key, object2) {
          setter(accumulator, iteratee2(value3), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last2(path))];
        return func == null ? undefined$1 : apply2(func, object, args);
      }
      function baseIsArguments(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == argsTag;
      }
      function baseIsArrayBuffer(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == arrayBufferTag;
      }
      function baseIsDate(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == dateTag;
      }
      function baseIsEqual(value3, other, bitmask, customizer, stack2) {
        if (value3 === other) {
          return true;
        }
        if (value3 == null || other == null || !isObjectLike2(value3) && !isObjectLike2(other)) {
          return value3 !== value3 && other !== other;
        }
        return baseIsEqualDeep(value3, other, bitmask, customizer, baseIsEqual, stack2);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray3(object), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsMap(value3) {
        return isObjectLike2(value3) && getTag2(value3) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data28 = matchData[index2];
          if (noCustomizer && data28[2] ? data28[1] !== object[data28[0]] : !(data28[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data28 = matchData[index2];
          var key = data28[0], objValue = object[key], srcValue = data28[1];
          if (noCustomizer && data28[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack2);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value3) {
        if (!isObject3(value3) || isMasked(value3)) {
          return false;
        }
        var pattern = isFunction3(value3) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value3));
      }
      function baseIsRegExp(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == regexpTag;
      }
      function baseIsSet(value3) {
        return isObjectLike2(value3) && getTag2(value3) == setTag;
      }
      function baseIsTypedArray(value3) {
        return isObjectLike2(value3) && isLength(value3.length) && !!typedArrayTags[baseGetTag(value3)];
      }
      function baseIteratee(value3) {
        if (typeof value3 == "function") {
          return value3;
        }
        if (value3 == null) {
          return identity;
        }
        if (typeof value3 == "object") {
          return isArray3(value3) ? baseMatchesProperty(value3[0], value3[1]) : baseMatches(value3);
        }
        return property(value3);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject3(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value3, other) {
        return value3 < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value3, key, collection2) {
          result2[++index2] = iteratee2(value3, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack2) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack2 || (stack2 = new Stack());
          if (isObject3(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray3(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray3(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject3(objValue) || isFunction3(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray3(iteratee2)) {
              return function(value3) {
                return baseGet(value3, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value3, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value3);
          });
          return { "criteria": criteria, "index": ++index2, "value": value3 };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value3, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value3 = baseGet(object, path);
          if (predicate(value3, path)) {
            baseSet(result2, castPath(path, object), value3);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values3, iteratee2, comparator2) {
        var indexOf2 = comparator2 ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values3.length, seen2 = array;
        if (array === values3) {
          values3 = copyArray(values3);
        }
        if (iteratee2) {
          seen2 = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value3 = values3[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
          while ((fromIndex = indexOf2(seen2, computed2, fromIndex, comparator2)) > -1) {
            if (seen2 !== array) {
              splice.call(seen2, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values2(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value3, customizer) {
        if (!isObject3(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value3;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject3(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data28) {
        metaMap.set(func, data28);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      function baseSlice(array, start2, end) {
        var index2 = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start2 > end ? 0 : end - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value3, index2, collection2) {
          result2 = predicate(value3, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value3, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value3 == "number" && value3 === value3 && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value3 : computed2 < value3)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value3, identity, retHighest);
      }
      function baseSortedIndexBy(array, value3, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value3 = iteratee2(value3);
        var valIsNaN = value3 !== value3, valIsNull = value3 === null, valIsSymbol = isSymbol2(value3), valIsUndefined = value3 === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value3 : computed2 < value3;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
          if (!index2 || !eq(computed2, seen2)) {
            var seen2 = computed2;
            result2[resIndex++] = value3 === 0 ? 0 : value3;
          }
        }
        return result2;
      }
      function baseToNumber(value3) {
        if (typeof value3 == "number") {
          return value3;
        }
        if (isSymbol2(value3)) {
          return NAN;
        }
        return +value3;
      }
      function baseToString2(value3) {
        if (typeof value3 == "string") {
          return value3;
        }
        if (isArray3(value3)) {
          return arrayMap(value3, baseToString2) + "";
        }
        if (isSymbol2(value3)) {
          return symbolToString ? symbolToString.call(value3) : "";
        }
        var result2 = value3 + "";
        return result2 == "0" && 1 / value3 == -INFINITY2 ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator2) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen2 = result2;
        if (comparator2) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen2 = new SetCache();
        } else {
          seen2 = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value3 = array[index2], computed2 = iteratee2 ? iteratee2(value3) : value3;
            value3 = comparator2 || value3 !== 0 ? value3 : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            } else if (!includes2(seen2, computed2, comparator2)) {
              if (seen2 !== result2) {
                seen2.push(computed2);
              }
              result2.push(value3);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last2(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value3, actions) {
        var result2 = value3;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator2) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator2);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator2);
      }
      function baseZipObject(props, values3, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values3.length, result2 = {};
        while (++index2 < length) {
          var value3 = index2 < valsLength ? values3[index2] : undefined$1;
          assignFunc(result2, props[index2], value3);
        }
        return result2;
      }
      function castArrayLikeObject(value3) {
        return isArrayLikeObject(value3) ? value3 : [];
      }
      function castFunction(value3) {
        return typeof value3 == "function" ? value3 : identity;
      }
      function castPath(value3, object) {
        if (isArray3(value3)) {
          return value3;
        }
        return isKey(value3, object) ? [value3] : stringToPath(toString2(value3));
      }
      var castRest = baseRest;
      function castSlice(array, start2, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start2 && end >= length ? array : baseSlice(array, start2, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root27.clearTimeout(id2);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value3, other) {
        if (value3 !== other) {
          var valIsDefined = value3 !== undefined$1, valIsNull = value3 === null, valIsReflexive = value3 === value3, valIsSymbol = isSymbol2(value3);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value3 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value3 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray3(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root27 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject3(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn = this && this !== root27 && this instanceof wrapper ? Ctor : func;
          return apply2(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data28 = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data28 && isLaziable(data28[0]) && data28[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data28[4].length && data28[9] == 1) {
              wrapper = wrapper[getFuncName(data28[0])].apply(wrapper, data28[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value3 = args[0];
            if (wrapper && args.length == 1 && isArray3(value3)) {
              return wrapper.plant(value3).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value3;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root27 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator2, defaultValue) {
        return function(value3, other) {
          var result2;
          if (value3 === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value3 !== undefined$1) {
            result2 = value3;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value3 == "string" || typeof other == "string") {
              value3 = baseToString2(value3);
              other = baseToString2(other);
            } else {
              value3 = baseToNumber(value3);
              other = baseToNumber(other);
            }
            result2 = operator2(value3, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root27 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
            end = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end === undefined$1) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start2 < end ? 1 : -1 : toFinite(step);
          return baseRange(start2, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator2) {
        return function(value3, other) {
          if (!(typeof value3 == "string" && typeof other == "string")) {
            value3 = toNumber2(value3);
            other = toNumber2(other);
          }
          return operator2(value3, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber2(number2);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString2(number2) + "e").split("e"), value3 = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value3) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values3) {
        return new Set2(values3);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag2(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data28 = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data28) {
          mergeData(newData, data28);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data28 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
        if (isObject3(objValue) && isObject3(srcValue)) {
          stack2.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2);
          stack2["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value3) {
        return isPlainObject2(value3) ? undefined$1 : value3;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack2.set(array, other);
        stack2.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen2.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result2 = false;
            break;
          }
        }
        stack2["delete"](array);
        stack2["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack2.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data28 = array[length], otherFunc = data28.func;
          if (otherFunc == null || otherFunc == func) {
            return data28.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data28 = map3.__data__;
        return isKeyable(key) ? data28[typeof key == "string" ? "string" : "hash"] : data28.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value3 = object[key];
          result2[length] = [key, value3, isStrictComparable(value3)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value3 = getValue2(object, key);
        return baseIsNative(value3) ? value3 : undefined$1;
      }
      function getRawTag(value3) {
        var isOwn = hasOwnProperty2.call(value3, symToStringTag), tag = value3[symToStringTag];
        try {
          value3[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value3);
        if (unmasked) {
          if (isOwn) {
            value3[symToStringTag] = tag;
          } else {
            delete value3[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag2 = baseGetTag;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
        getTag2 = function(value3) {
          var result2 = baseGetTag(value3), Ctor = result2 == objectTag ? value3.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start2, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data28 = transforms[index2], size3 = data28.size;
          switch (data28.type) {
            case "drop":
              start2 += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin(end, start2 + size3);
              break;
            case "takeRight":
              start2 = nativeMax(start2, end - size3);
              break;
          }
        }
        return { "start": start2, "end": end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray3(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value3) {
        return isArray3(value3) || isArguments(value3) || !!(spreadableSymbol && value3 && value3[spreadableSymbol]);
      }
      function isIndex(value3, length) {
        var type = typeof value3;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value3)) && (value3 > -1 && value3 % 1 == 0 && value3 < length);
      }
      function isIterateeCall(value3, index2, object) {
        if (!isObject3(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value3);
        }
        return false;
      }
      function isKey(value3, object) {
        if (isArray3(value3)) {
          return false;
        }
        var type = typeof value3;
        if (type == "number" || type == "symbol" || type == "boolean" || value3 == null || isSymbol2(value3)) {
          return true;
        }
        return reIsPlainProp.test(value3) || !reIsDeepProp.test(value3) || object != null && value3 in Object2(object);
      }
      function isKeyable(value3) {
        var type = typeof value3;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value3 !== "__proto__" : value3 === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data28 = getData(other);
        return !!data28 && func === data28[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction3 : stubFalse;
      function isPrototype(value3) {
        var Ctor = value3 && value3.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value3 === proto;
      }
      function isStrictComparable(value3) {
        return value3 === value3 && !isObject3(value3);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data28, source) {
        var bitmask = data28[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data28[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data28;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data28[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value3 = source[3];
        if (value3) {
          var partials = data28[3];
          data28[3] = partials ? composeArgs(partials, value3, source[4]) : value3;
          data28[4] = partials ? replaceHolders(data28[3], PLACEHOLDER) : source[4];
        }
        value3 = source[5];
        if (value3) {
          partials = data28[5];
          data28[5] = partials ? composeArgsRight(partials, value3, source[6]) : value3;
          data28[6] = partials ? replaceHolders(data28[5], PLACEHOLDER) : source[6];
        }
        value3 = source[7];
        if (value3) {
          data28[7] = value3;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data28[8] = data28[8] == null ? source[8] : nativeMin(data28[8], source[8]);
        }
        if (data28[9] == null) {
          data28[9] = source[9];
        }
        data28[0] = source[0];
        data28[1] = newBitmask;
        return data28;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value3) {
        return nativeObjectToString.call(value3);
      }
      function overRest(func, start2, transform3) {
        start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform3(array);
          return apply2(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root27.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size3) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size3 = size3 === undefined$1 ? length : size3;
        while (++index2 < size3) {
          var rand = baseRandom(index2, lastIndex), value3 = array[rand];
          array[rand] = array[index2];
          array[index2] = value3;
        }
        array.length = size3;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
        });
        return result2;
      });
      function toKey(value3) {
        if (typeof value3 == "string" || isSymbol2(value3)) {
          return value3;
        }
        var result2 = value3 + "";
        return result2 == "0" && 1 / value3 == -INFINITY2 ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value3 = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value3)) {
            details.push(value3);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size3, guard) {
        if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined$1) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger(size3), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size3);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value3 = array[index2];
          if (value3) {
            result2[resIndex++] = value3;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray3(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values3) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values3) {
        var iteratee2 = last2(values3);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values3) {
        var comparator2 = last2(values3);
        if (isArrayLikeObject(comparator2)) {
          comparator2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined$1, comparator2) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value3, start2, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array, value3, start2)) {
          start2 = 0;
          end = length;
        }
        return baseFill(array, value3, start2, end);
      }
      function findIndex3(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY2) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value3, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value3, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last2(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        if (comparator2) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator2) : [];
      });
      function join2(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last2(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value3, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value3 === value3 ? strictLastIndexOf(array, value3, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values3) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
      }
      function pullAllBy(array, values3, iteratee2) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values3, comparator2) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined$1, comparator2) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove5(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value3 = array[index2];
          if (predicate(value3, index2, array)) {
            result2.push(value3);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start2, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
          start2 = 0;
          end = length;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start2, end);
      }
      function sortedIndex(array, value3) {
        return baseSortedIndex(array, value3);
      }
      function sortedIndexBy(array, value3, iteratee2) {
        return baseSortedIndexBy(array, value3, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value3) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value3);
          if (index2 < length && eq(array[index2], value3)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value3) {
        return baseSortedIndex(array, value3, true);
      }
      function sortedLastIndexBy(array, value3, iteratee2) {
        return baseSortedIndexBy(array, value3, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value3) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value3, true) - 1;
          if (eq(array[index2], value3)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator2 = last2(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator2);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator2) {
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator2) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply2(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values3) {
        return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator2 = last2(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator2);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values3) {
        return baseZipObject(props || [], values3 || [], assignValue);
      }
      function zipObjectDeep(props, values3) {
        return baseZipObject(props || [], values3 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value3) {
        var result2 = lodash2(value3);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value3, interceptor) {
        interceptor(value3);
        return value3;
      }
      function thru(value3, interceptor) {
        return interceptor(value3);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value3 = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value3 instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value3 = value3.slice(start2, +start2 + (length ? 1 : 0));
        value3.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value3, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value3 = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value3 };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value3) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value3;
        return result2;
      }
      function wrapperReverse() {
        var value3 = this.__wrapped__;
        if (value3 instanceof LazyWrapper) {
          var wrapped = value3;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value3, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray3(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter5(collection, predicate) {
        var func = isArray3(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex3);
      var findLast2 = createFind(findLastIndex2);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY2);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray3(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray3(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value3, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value3);
        } else {
          baseAssignValue(result2, key, [value3]);
        }
      });
      function includes(collection, value3, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString3(collection) ? fromIndex <= length && collection.indexOf(value3, fromIndex) > -1 : !!length && baseIndexOf(collection, value3, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value3) {
          result2[++index2] = isFunc ? apply2(path, value3, args) : baseInvoke(value3, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value3, key) {
        baseAssignValue(result2, key, value3);
      });
      function map2(collection, iteratee2) {
        var func = isArray3(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray3(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray3(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value3, key) {
        result2[key ? 0 : 1].push(value3);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray3(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray3(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject2(collection, predicate) {
        var func = isArray3(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray3(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray3(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray3(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString3(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray3(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root27.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind3 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind3));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options3) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject3(options3)) {
          leading = !!options3.leading;
          maxing = "maxWait" in options3;
          maxWait = maxing ? nativeMax(toNumber2(options3.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options3 ? !!options3.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once2(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray3(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply2(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
        return baseRest(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply2(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options3) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject3(options3)) {
          leading = "leading" in options3 ? !!options3.leading : leading;
          trailing = "trailing" in options3 ? !!options3.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value3, wrapper) {
        return partial(castFunction(wrapper), value3);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value3 = arguments[0];
        return isArray3(value3) ? value3 : [value3];
      }
      function clone2(value3) {
        return baseClone(value3, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value3, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value3) {
        return baseClone(value3, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value3, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value3, other) {
        return value3 === other || value3 !== value3 && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte2 = createRelationalOperation(function(value3, other) {
        return value3 >= other;
      });
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value3) {
        return isObjectLike2(value3) && hasOwnProperty2.call(value3, "callee") && !propertyIsEnumerable.call(value3, "callee");
      };
      var isArray3 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value3) {
        return value3 != null && isLength(value3.length) && !isFunction3(value3);
      }
      function isArrayLikeObject(value3) {
        return isObjectLike2(value3) && isArrayLike(value3);
      }
      function isBoolean2(value3) {
        return value3 === true || value3 === false || isObjectLike2(value3) && baseGetTag(value3) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value3) {
        return isObjectLike2(value3) && value3.nodeType === 1 && !isPlainObject2(value3);
      }
      function isEmpty3(value3) {
        if (value3 == null) {
          return true;
        }
        if (isArrayLike(value3) && (isArray3(value3) || typeof value3 == "string" || typeof value3.splice == "function" || isBuffer(value3) || isTypedArray(value3) || isArguments(value3))) {
          return !value3.length;
        }
        var tag = getTag2(value3);
        if (tag == mapTag || tag == setTag) {
          return !value3.size;
        }
        if (isPrototype(value3)) {
          return !baseKeys(value3).length;
        }
        for (var key in value3) {
          if (hasOwnProperty2.call(value3, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value3, other) {
        return baseIsEqual(value3, other);
      }
      function isEqualWith(value3, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value3, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value3, other, undefined$1, customizer) : !!result2;
      }
      function isError(value3) {
        if (!isObjectLike2(value3)) {
          return false;
        }
        var tag = baseGetTag(value3);
        return tag == errorTag || tag == domExcTag || typeof value3.message == "string" && typeof value3.name == "string" && !isPlainObject2(value3);
      }
      function isFinite2(value3) {
        return typeof value3 == "number" && nativeIsFinite(value3);
      }
      function isFunction3(value3) {
        if (!isObject3(value3)) {
          return false;
        }
        var tag = baseGetTag(value3);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value3) {
        return typeof value3 == "number" && value3 == toInteger(value3);
      }
      function isLength(value3) {
        return typeof value3 == "number" && value3 > -1 && value3 % 1 == 0 && value3 <= MAX_SAFE_INTEGER;
      }
      function isObject3(value3) {
        var type = typeof value3;
        return value3 != null && (type == "object" || type == "function");
      }
      function isObjectLike2(value3) {
        return value3 != null && typeof value3 == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value3) {
        return isNumber3(value3) && value3 != +value3;
      }
      function isNative(value3) {
        if (isMaskable(value3)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value3);
      }
      function isNull(value3) {
        return value3 === null;
      }
      function isNil(value3) {
        return value3 == null;
      }
      function isNumber3(value3) {
        return typeof value3 == "number" || isObjectLike2(value3) && baseGetTag(value3) == numberTag;
      }
      function isPlainObject2(value3) {
        if (!isObjectLike2(value3) || baseGetTag(value3) != objectTag) {
          return false;
        }
        var proto = getPrototype(value3);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value3) {
        return isInteger(value3) && value3 >= -MAX_SAFE_INTEGER && value3 <= MAX_SAFE_INTEGER;
      }
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString3(value3) {
        return typeof value3 == "string" || !isArray3(value3) && isObjectLike2(value3) && baseGetTag(value3) == stringTag;
      }
      function isSymbol2(value3) {
        return typeof value3 == "symbol" || isObjectLike2(value3) && baseGetTag(value3) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value3) {
        return value3 === undefined$1;
      }
      function isWeakMap(value3) {
        return isObjectLike2(value3) && getTag2(value3) == weakMapTag;
      }
      function isWeakSet(value3) {
        return isObjectLike2(value3) && baseGetTag(value3) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte2 = createRelationalOperation(function(value3, other) {
        return value3 <= other;
      });
      function toArray(value3) {
        if (!value3) {
          return [];
        }
        if (isArrayLike(value3)) {
          return isString3(value3) ? stringToArray(value3) : copyArray(value3);
        }
        if (symIterator && value3[symIterator]) {
          return iteratorToArray(value3[symIterator]());
        }
        var tag = getTag2(value3), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
        return func(value3);
      }
      function toFinite(value3) {
        if (!value3) {
          return value3 === 0 ? value3 : 0;
        }
        value3 = toNumber2(value3);
        if (value3 === INFINITY2 || value3 === -INFINITY2) {
          var sign = value3 < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value3 === value3 ? value3 : 0;
      }
      function toInteger(value3) {
        var result2 = toFinite(value3), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value3) {
        return value3 ? baseClamp(toInteger(value3), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value3) {
        if (typeof value3 == "number") {
          return value3;
        }
        if (isSymbol2(value3)) {
          return NAN;
        }
        if (isObject3(value3)) {
          var other = typeof value3.valueOf == "function" ? value3.valueOf() : value3;
          value3 = isObject3(other) ? other + "" : other;
        }
        if (typeof value3 != "string") {
          return value3 === 0 ? value3 : +value3;
        }
        value3 = baseTrim(value3);
        var isBinary = reIsBinary.test(value3);
        return isBinary || reIsOctal.test(value3) ? freeParseInt(value3.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value3) ? NAN : +value3;
      }
      function toPlainObject(value3) {
        return copyObject(value3, keysIn(value3));
      }
      function toSafeInteger(value3) {
        return value3 ? baseClamp(toInteger(value3), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value3 === 0 ? value3 : 0;
      }
      function toString2(value3) {
        return value3 == null ? "" : baseToString2(value3);
      }
      var assign2 = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value3 = object[key];
            if (value3 === undefined$1 || eq(value3, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply2(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value3, key) {
        if (value3 != null && typeof value3.toString != "function") {
          value3 = nativeObjectToString.call(value3);
        }
        result2[value3] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value3, key) {
        if (value3 != null && typeof value3.toString != "function") {
          value3 = nativeObjectToString.call(value3);
        }
        if (hasOwnProperty2.call(result2, value3)) {
          result2[value3].push(key);
        } else {
          result2[value3] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value3, key, object2) {
          baseAssignValue(result2, iteratee2(value3, key, object2), value3);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value3, key, object2) {
          baseAssignValue(result2, key, iteratee2(value3, key, object2));
        });
        return result2;
      }
      var merge3 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop2) {
          return [prop2];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value3, path) {
          return predicate(value3, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value3 = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value3 === undefined$1) {
            index2 = length;
            value3 = defaultValue;
          }
          object = isFunction3(value3) ? value3.call(object) : value3;
        }
        return object;
      }
      function set2(object, path, value3) {
        return object == null ? object : baseSet(object, path, value3);
      }
      function setWith(object, path, value3, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value3, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray3(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject3(object)) {
            accumulator = isFunction3(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value3, index2, object2) {
          return iteratee2(accumulator, value3, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update2(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values2(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number2, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number2), lower, upper);
      }
      function inRange(number2, start2, end) {
        start2 = toFinite(start2);
        if (end === undefined$1) {
          end = start2;
          start2 = 0;
        } else {
          end = toFinite(end);
        }
        number2 = toNumber2(number2);
        return baseInRange(number2, start2, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp2 = lower;
          lower = upper;
          upper = temp2;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith2(string, target, position) {
        string = toString2(string);
        target = baseToString2(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp2(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat3(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString2(string), n);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString2(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith2(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString2(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options3, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options3, guard)) {
          options3 = undefined$1;
        }
        string = toString2(string);
        options3 = assignInWith({}, options3, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options3.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options3.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options3.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options3.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options3, "sourceURL") ? (options3.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options3, "variable") && options3.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value3) {
        return toString2(value3).toLowerCase();
      }
      function toUpper(value3) {
        return toString2(value3).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string, options3) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject3(options3)) {
          var separator = "separator" in options3 ? options3.separator : separator;
          length = "length" in options3 ? toInteger(options3.length) : length;
          omission = "omission" in options3 ? baseToString2(options3.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString2(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply2(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll2 = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind3(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply2(pair[0], this, args)) {
              return apply2(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value3) {
        return function() {
          return value3;
        };
      }
      function defaultTo(value3, defaultValue) {
        return value3 == null || value3 !== value3 ? defaultValue : value3;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value3) {
        return value3;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches2(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options3) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options3 == null && !(isObject3(source) && (methodNames.length || !props.length))) {
          options3 = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject3(options3) && "chain" in options3) || !!options3.chain, isFunc = isFunction3(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root27._ === this) {
          root27._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value3) {
        if (isArray3(value3)) {
          return arrayMap(value3, toKey);
        }
        return isSymbol2(value3) ? [value3] : copyArray(stringToPath(toString2(value3)));
      }
      function uniqueId(prefix2) {
        var id2 = ++idCounter;
        return toString2(prefix2) + id2;
      }
      var add3 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind3;
      lodash2.bindAll = bindAll2;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter5;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge3;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once2;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject2;
      lodash2.remove = remove5;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update2;
      lodash2.updateWith = updateWith;
      lodash2.values = values2;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add3;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith2;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp2;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex3;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast2;
      lodash2.findLastIndex = findLastIndex2;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte2;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray3;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty3;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction3;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber3;
      lodash2.isObject = isObject3;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString3;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join2;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last2;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte2;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat3;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith2;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value3) {
          return baseInvoke(value3, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value3 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value3 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray3(value3);
          var interceptor = function(value4) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value4], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value3 = onlyLazy ? value3 : new LazyWrapper(this);
            var result2 = func.apply(value3, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value3 = this.value();
            return func.apply(isArray3(value3) ? value3 : [], args);
          }
          return this[chainName](function(value4) {
            return func.apply(isArray3(value4) ? value4 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (typeof undefined$1 == "function" && typeof undefined$1.amd == "object" && undefined$1.amd) {
      root27._ = _2;
      undefined$1(function() {
        return _2;
      });
    } else if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root27._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash$1, lodash$1.exports);
var lodashExports = lodash$1.exports;
const _ = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
class FuseSearch {
  constructor(data28, options3, createIndex2 = true) {
    __publicField2(this, "fuse");
    __publicField2(this, "data");
    this.data = data28;
    const index2 = createIndex2 && (options3 == null ? void 0 : options3.keys) ? Fuse.createIndex(options3.keys, data28) : void 0;
    this.fuse = new Fuse(data28, options3, index2);
  }
  search(query, options3) {
    if (!query || query === "") {
      return [...this.data];
    }
    return this.fuse.search(query, options3).map((result) => result.item);
  }
}
class NodeFilter {
  constructor(nodeDefs, options3) {
    __publicField2(this, "fuseSearch");
    this.fuseSearch = new FuseSearch(this.getAllNodeOptions(nodeDefs), options3);
  }
  getAllNodeOptions(nodeDefs) {
    return [
      ...new Set(
        nodeDefs.reduce((acc, nodeDef) => {
          return [...acc, ...this.getNodeOptions(nodeDef)];
        }, [])
      )
    ];
  }
  matches(node3, value3) {
    return this.getNodeOptions(node3).includes(value3);
  }
}
class InputTypeFilter extends NodeFilter {
  constructor() {
    super(...arguments);
    __publicField2(this, "id", "input");
    __publicField2(this, "name", "Input Type");
    __publicField2(this, "invokeSequence", "i");
    __publicField2(this, "longInvokeSequence", "input");
  }
  getNodeOptions(node3) {
    return node3.input.all.map((input) => input.type);
  }
}
class OutputTypeFilter extends NodeFilter {
  constructor() {
    super(...arguments);
    __publicField2(this, "id", "output");
    __publicField2(this, "name", "Output Type");
    __publicField2(this, "invokeSequence", "o");
    __publicField2(this, "longInvokeSequence", "output");
  }
  getNodeOptions(node3) {
    return node3.output.all.map((output) => output.type);
  }
}
class NodeSourceFilter extends NodeFilter {
  constructor() {
    super(...arguments);
    __publicField2(this, "id", "source");
    __publicField2(this, "name", "Source");
    __publicField2(this, "invokeSequence", "s");
    __publicField2(this, "longInvokeSequence", "source");
  }
  getNodeOptions(node3) {
    return [getNodeSource(node3.python_module).displayText];
  }
}
class NodeCategoryFilter extends NodeFilter {
  constructor() {
    super(...arguments);
    __publicField2(this, "id", "category");
    __publicField2(this, "name", "Category");
    __publicField2(this, "invokeSequence", "c");
    __publicField2(this, "longInvokeSequence", "category");
  }
  getNodeOptions(node3) {
    return [node3.category];
  }
}
class NodeSearchService {
  constructor(data28) {
    __publicField2(this, "nodeFuseSearch");
    __publicField2(this, "nodeFilters");
    this.nodeFuseSearch = new FuseSearch(data28, {
      keys: ["name", "display_name"],
      includeScore: true,
      threshold: 0.3,
      shouldSort: true,
      useExtendedSearch: true
    });
    const filterSearchOptions = {
      includeScore: true,
      threshold: 0.3,
      shouldSort: true
    };
    this.nodeFilters = [
      new InputTypeFilter(data28, filterSearchOptions),
      new OutputTypeFilter(data28, filterSearchOptions),
      new NodeCategoryFilter(data28, filterSearchOptions)
    ];
    if (data28[0].python_module !== void 0) {
      this.nodeFilters.push(new NodeSourceFilter(data28, filterSearchOptions));
    }
  }
  endsWithFilterStartSequence(query) {
    return query.endsWith(":");
  }
  searchNode(query, filters = [], options3) {
    const matchedNodes = this.nodeFuseSearch.search(query);
    const results = matchedNodes.filter((node3) => {
      return _.every(filters, (filterAndValue) => {
        const [filter5, value3] = filterAndValue;
        return filter5.matches(node3, value3);
      });
    });
    return (options3 == null ? void 0 : options3.limit) ? results.slice(0, options3.limit) : results;
  }
  getFilterById(id2) {
    return this.nodeFilters.find((filter5) => filter5.id === id2);
  }
}
var isVue2 = false;
var isVue3 = true;
var Vue2 = void 0;
function install() {
}
function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a2;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof globalThis !== "undefined" && ((_a2 = globalThis.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
    supported = true;
    perf = globalThis.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id2 in plugin.settings) {
        const item = plugin.settings[id2];
        defaultSettings[id2] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data28 = JSON.parse(raw);
      Object.assign(currentSettings, data28);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value3) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value3));
        } catch (e) {
        }
        currentSettings = value3;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value3) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value3);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop2) => {
        if (this.target) {
          return this.target.on[prop2];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop2,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop2) => {
        if (this.target) {
          return this.target[prop2];
        } else if (prop2 === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop2)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop2,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop2](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve8) => {
              this.targetQueue.push({
                method: prop2,
                args,
                resolve: resolve8
              });
            });
          };
        }
      }
    });
  }
  setRealTarget(target) {
    return __async(this, null, function* () {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(yield this.target[item.method](...item.args));
      }
    });
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) {
      setupFn(proxy.proxiedTarget);
    }
  }
}
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia2) => activePinia = pinia2;
const getActivePinia = () => hasInjectionContext() && inject(piniaSymbol) || activePinia;
const piniaSymbol = false ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$1(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
const IS_CLIENT = typeof window !== "undefined";
const USE_DEVTOOLS = false;
const _global = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
function bom(blob, { autoBom = false } = {}) {
  if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
    return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
  }
  return blob;
}
function download(url, name, opts) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.responseType = "blob";
  xhr.onload = function() {
    saveAs(xhr.response, name, opts);
  };
  xhr.onerror = function() {
    console.error("could not download file");
  };
  xhr.send();
}
function corsEnabled(url) {
  const xhr = new XMLHttpRequest();
  xhr.open("HEAD", url, false);
  try {
    xhr.send();
  } catch (e) {
  }
  return xhr.status >= 200 && xhr.status <= 299;
}
function click(node3) {
  try {
    node3.dispatchEvent(new MouseEvent("click"));
  } catch (e) {
    const evt = document.createEvent("MouseEvents");
    evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
    node3.dispatchEvent(evt);
  }
}
const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
const saveAs = !IS_CLIENT ? () => {
} : (
  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
  typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
    // Use msSaveOrOpenBlob as a second approach
    "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
      // Fallback to using FileReader and a popup
      fileSaverSaveAs
    )
  )
);
function downloadSaveAs(blob, name = "download", opts) {
  const a = document.createElement("a");
  a.download = name;
  a.rel = "noopener";
  if (typeof blob === "string") {
    a.href = blob;
    if (a.origin !== location.origin) {
      if (corsEnabled(a.href)) {
        download(blob, name, opts);
      } else {
        a.target = "_blank";
        click(a);
      }
    } else {
      click(a);
    }
  } else {
    a.href = URL.createObjectURL(blob);
    setTimeout(function() {
      URL.revokeObjectURL(a.href);
    }, 4e4);
    setTimeout(function() {
      click(a);
    }, 0);
  }
}
function msSaveAs(blob, name = "download", opts) {
  if (typeof blob === "string") {
    if (corsEnabled(blob)) {
      download(blob, name, opts);
    } else {
      const a = document.createElement("a");
      a.href = blob;
      a.target = "_blank";
      setTimeout(function() {
        click(a);
      });
    }
  } else {
    navigator.msSaveOrOpenBlob(bom(blob, opts), name);
  }
}
function fileSaverSaveAs(blob, name, opts, popup) {
  popup = popup || open("", "_blank");
  if (popup) {
    popup.document.title = popup.document.body.innerText = "downloading...";
  }
  if (typeof blob === "string")
    return download(blob, name, opts);
  const force = blob.type === "application/octet-stream";
  const isSafari3 = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
  const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((isChromeIOS || force && isSafari3 || isMacOSWebView) && typeof FileReader !== "undefined") {
    const reader = new FileReader();
    reader.onloadend = function() {
      let url = reader.result;
      if (typeof url !== "string") {
        popup = null;
        throw new Error("Wrong reader.result type");
      }
      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
      if (popup) {
        popup.location.href = url;
      } else {
        location.assign(url);
      }
      popup = null;
    };
    reader.readAsDataURL(blob);
  } else {
    const url = URL.createObjectURL(blob);
    if (popup)
      popup.location.assign(url);
    else
      location.href = url;
    popup = null;
    setTimeout(function() {
      URL.revokeObjectURL(url);
    }, 4e4);
  }
}
function toastMessage(message3, type) {
  const piniaMessage = "🍍 " + message3;
  if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
  } else if (type === "error") {
    console.error(piniaMessage);
  } else if (type === "warn") {
    console.warn(piniaMessage);
  } else {
    console.log(piniaMessage);
  }
}
function isPinia(o) {
  return "_a" in o && "install" in o;
}
function checkClipboardAccess() {
  if (!("clipboard" in navigator)) {
    toastMessage(`Your browser doesn't support the Clipboard API`, "error");
    return true;
  }
}
function checkNotFocusedError(error) {
  if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
    toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
    return true;
  }
  return false;
}
function actionGlobalCopyState(pinia2) {
  return __async(this, null, function* () {
    if (checkClipboardAccess())
      return;
    try {
      yield navigator.clipboard.writeText(JSON.stringify(pinia2.state.value));
      toastMessage("Global state copied to clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
      console.error(error);
    }
  });
}
function actionGlobalPasteState(pinia2) {
  return __async(this, null, function* () {
    if (checkClipboardAccess())
      return;
    try {
      loadStoresState(pinia2, JSON.parse(yield navigator.clipboard.readText()));
      toastMessage("Global state pasted from clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
      console.error(error);
    }
  });
}
function actionGlobalSaveState(pinia2) {
  return __async(this, null, function* () {
    try {
      saveAs(new Blob([JSON.stringify(pinia2.state.value)], {
        type: "text/plain;charset=utf-8"
      }), "pinia-state.json");
    } catch (error) {
      toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  });
}
let fileInput;
function getFileOpener() {
  if (!fileInput) {
    fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".json";
  }
  function openFile() {
    return new Promise((resolve8, reject2) => {
      fileInput.onchange = () => __async(this, null, function* () {
        const files = fileInput.files;
        if (!files)
          return resolve8(null);
        const file = files.item(0);
        if (!file)
          return resolve8(null);
        return resolve8({ text: yield file.text(), file });
      });
      fileInput.oncancel = () => resolve8(null);
      fileInput.onerror = reject2;
      fileInput.click();
    });
  }
  return openFile;
}
function actionGlobalOpenStateFile(pinia2) {
  return __async(this, null, function* () {
    try {
      const open2 = getFileOpener();
      const result = yield open2();
      if (!result)
        return;
      const { text: text2, file } = result;
      loadStoresState(pinia2, JSON.parse(text2));
      toastMessage(`Global state imported from "${file.name}".`);
    } catch (error) {
      toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  });
}
function loadStoresState(pinia2, state) {
  for (const key in state) {
    const storeState = pinia2.state.value[key];
    if (storeState) {
      Object.assign(storeState, state[key]);
    } else {
      pinia2.state.value[key] = state[key];
    }
  }
}
function formatDisplay(display) {
  return {
    _custom: {
      display
    }
  };
}
const PINIA_ROOT_LABEL = "🍍 Pinia (root)";
const PINIA_ROOT_ID = "_root";
function formatStoreForInspectorTree(store) {
  return isPinia(store) ? {
    id: PINIA_ROOT_ID,
    label: PINIA_ROOT_LABEL
  } : {
    id: store.$id,
    label: store.$id
  };
}
function formatStoreForInspectorState(store) {
  if (isPinia(store)) {
    const storeNames = Array.from(store._s.keys());
    const storeMap = store._s;
    const state2 = {
      state: storeNames.map((storeId) => ({
        editable: true,
        key: storeId,
        value: store.state.value[storeId]
      })),
      getters: storeNames.filter((id2) => storeMap.get(id2)._getters).map((id2) => {
        const store2 = storeMap.get(id2);
        return {
          editable: false,
          key: id2,
          value: store2._getters.reduce((getters, key) => {
            getters[key] = store2[key];
            return getters;
          }, {})
        };
      })
    };
    return state2;
  }
  const state = {
    state: Object.keys(store.$state).map((key) => ({
      editable: true,
      key,
      value: store.$state[key]
    }))
  };
  if (store._getters && store._getters.length) {
    state.getters = store._getters.map((getterName) => ({
      editable: false,
      key: getterName,
      value: store[getterName]
    }));
  }
  if (store._customProperties.size) {
    state.customProperties = Array.from(store._customProperties).map((key) => ({
      editable: true,
      key,
      value: store[key]
    }));
  }
  return state;
}
function formatEventData(events) {
  if (!events)
    return {};
  if (Array.isArray(events)) {
    return events.reduce((data28, event2) => {
      data28.keys.push(event2.key);
      data28.operations.push(event2.type);
      data28.oldValue[event2.key] = event2.oldValue;
      data28.newValue[event2.key] = event2.newValue;
      return data28;
    }, {
      oldValue: {},
      keys: [],
      operations: [],
      newValue: {}
    });
  } else {
    return {
      operation: formatDisplay(events.type),
      key: formatDisplay(events.key),
      oldValue: events.oldValue,
      newValue: events.newValue
    };
  }
}
function formatMutationType(type) {
  switch (type) {
    case MutationType.direct:
      return "mutation";
    case MutationType.patchFunction:
      return "$patch";
    case MutationType.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = "pinia:mutations";
const INSPECTOR_ID = "pinia";
const { assign: assign$1$1 } = Object;
const getStoreType = (id2) => "🍍 " + id2;
function registerPiniaDevtools(app2, pinia2) {
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia 🍍",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app: app2
  }, (api2) => {
    if (typeof api2.now !== "function") {
      toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
    }
    api2.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: `Pinia 🍍`,
      color: 15064968
    });
    api2.addInspector({
      id: INSPECTOR_ID,
      label: "Pinia 🍍",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            actionGlobalCopyState(pinia2);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: () => __async(this, null, function* () {
            yield actionGlobalPasteState(pinia2);
            api2.sendInspectorTree(INSPECTOR_ID);
            api2.sendInspectorState(INSPECTOR_ID);
          }),
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            actionGlobalSaveState(pinia2);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: () => __async(this, null, function* () {
            yield actionGlobalOpenStateFile(pinia2);
            api2.sendInspectorTree(INSPECTOR_ID);
            api2.sendInspectorState(INSPECTOR_ID);
          }),
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: 'Reset the state (with "$reset")',
          action: (nodeId) => {
            const store = pinia2._s.get(nodeId);
            if (!store) {
              toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
            } else if (typeof store.$reset !== "function") {
              toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
            } else {
              store.$reset();
              toastMessage(`Store "${nodeId}" reset.`);
            }
          }
        }
      ]
    });
    api2.on.inspectComponent((payload, ctx) => {
      const proxy = payload.componentInstance && payload.componentInstance.proxy;
      if (proxy && proxy._pStores) {
        const piniaStores = payload.componentInstance.proxy._pStores;
        Object.values(piniaStores).forEach((store) => {
          payload.instanceData.state.push({
            type: getStoreType(store.$id),
            key: "state",
            editable: true,
            value: store._isOptionsAPI ? {
              _custom: {
                value: toRaw(store.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => store.$reset()
                  }
                ]
              }
            } : (
              // NOTE: workaround to unwrap transferred refs
              Object.keys(store.$state).reduce((state, key) => {
                state[key] = store.$state[key];
                return state;
              }, {})
            )
          });
          if (store._getters && store._getters.length) {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "getters",
              editable: false,
              value: store._getters.reduce((getters, key) => {
                try {
                  getters[key] = store[key];
                } catch (error) {
                  getters[key] = error;
                }
                return getters;
              }, {})
            });
          }
        });
      }
    });
    api2.on.getInspectorTree((payload) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        let stores = [pinia2];
        stores = stores.concat(Array.from(pinia2._s.values()));
        payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
      }
    });
    api2.on.getInspectorState((payload) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
        if (!inspectedStore) {
          return;
        }
        if (inspectedStore) {
          payload.state = formatStoreForInspectorState(inspectedStore);
        }
      }
    });
    api2.on.editInspectorState((payload, ctx) => {
      if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
        if (!inspectedStore) {
          return toastMessage(`store "${payload.nodeId}" not found`, "error");
        }
        const { path } = payload;
        if (!isPinia(inspectedStore)) {
          if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
            path.unshift("$state");
          }
        } else {
          path.unshift("state");
        }
        isTimelineActive = false;
        payload.set(inspectedStore, path, payload.state.value);
        isTimelineActive = true;
      }
    });
    api2.on.editComponentState((payload) => {
      if (payload.type.startsWith("🍍")) {
        const storeId = payload.type.replace(/^🍍\s*/, "");
        const store = pinia2._s.get(storeId);
        if (!store) {
          return toastMessage(`store "${storeId}" not found`, "error");
        }
        const { path } = payload;
        if (path[0] !== "state") {
          return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
        }
        path[0] = "$state";
        isTimelineActive = false;
        payload.set(store, path, payload.state.value);
        isTimelineActive = true;
      }
    });
  });
}
function addStoreToDevtools(app2, store) {
  if (!componentStateTypes.includes(getStoreType(store.$id))) {
    componentStateTypes.push(getStoreType(store.$id));
  }
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia 🍍",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app: app2,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: true
      }
      // useEmojis: {
      //   label: 'Use emojis in messages ⚡️',
      //   type: 'boolean',
      //   defaultValue: true,
      // },
    }
  }, (api2) => {
    const now2 = typeof api2.now === "function" ? api2.now.bind(api2) : Date.now;
    store.$onAction(({ after, onError, name, args }) => {
      const groupId = runningActionId++;
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: "🛫 " + name,
          subtitle: "start",
          data: {
            store: formatDisplay(store.$id),
            action: formatDisplay(name),
            args
          },
          groupId
        }
      });
      after((result) => {
        activeAction = void 0;
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "🛬 " + name,
            subtitle: "end",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name),
              args,
              result
            },
            groupId
          }
        });
      });
      onError((error) => {
        activeAction = void 0;
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            logType: "error",
            title: "💥 " + name,
            subtitle: "end",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name),
              args,
              error
            },
            groupId
          }
        });
      });
    }, true);
    store._customProperties.forEach((name) => {
      watch(() => unref(store[name]), (newValue, oldValue) => {
        api2.notifyComponentUpdate();
        api2.sendInspectorState(INSPECTOR_ID);
        if (isTimelineActive) {
          api2.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "Change",
              subtitle: name,
              data: {
                newValue,
                oldValue
              },
              groupId: activeAction
            }
          });
        }
      }, { deep: true });
    });
    store.$subscribe(({ events, type }, state) => {
      api2.notifyComponentUpdate();
      api2.sendInspectorState(INSPECTOR_ID);
      if (!isTimelineActive)
        return;
      const eventData = {
        time: now2(),
        title: formatMutationType(type),
        data: assign$1$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
        groupId: activeAction
      };
      if (type === MutationType.patchFunction) {
        eventData.subtitle = "⤵️";
      } else if (type === MutationType.patchObject) {
        eventData.subtitle = "🧩";
      } else if (events && !Array.isArray(events)) {
        eventData.subtitle = events.type;
      }
      if (events) {
        eventData.data["rawEvent(s)"] = {
          _custom: {
            display: "DebuggerEvent",
            type: "object",
            tooltip: "raw DebuggerEvent[]",
            value: events
          }
        };
      }
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: eventData
      });
    }, { detached: true, flush: "sync" });
    const hotUpdate = store._hotUpdate;
    store._hotUpdate = markRaw((newStore) => {
      hotUpdate(newStore);
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: "🔥 " + store.$id,
          subtitle: "HMR update",
          data: {
            store: formatDisplay(store.$id),
            info: formatDisplay(`HMR update`)
          }
        }
      });
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(INSPECTOR_ID);
      api2.sendInspectorState(INSPECTOR_ID);
    });
    const { $dispose } = store;
    store.$dispose = () => {
      $dispose();
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(INSPECTOR_ID);
      api2.sendInspectorState(INSPECTOR_ID);
      api2.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store 🗑`);
    };
    api2.notifyComponentUpdate();
    api2.sendInspectorTree(INSPECTOR_ID);
    api2.sendInspectorState(INSPECTOR_ID);
    api2.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed 🆕`);
  });
}
let runningActionId = 0;
let activeAction;
function patchActionForGrouping(store, actionNames, wrapWithProxy) {
  const actions = actionNames.reduce((storeActions, actionName) => {
    storeActions[actionName] = toRaw(store)[actionName];
    return storeActions;
  }, {});
  for (const actionName in actions) {
    store[actionName] = function() {
      const _actionId = runningActionId;
      const trackedStore = wrapWithProxy ? new Proxy(store, {
        get(...args) {
          activeAction = _actionId;
          return Reflect.get(...args);
        },
        set(...args) {
          activeAction = _actionId;
          return Reflect.set(...args);
        }
      }) : store;
      activeAction = _actionId;
      const retValue = actions[actionName].apply(trackedStore, arguments);
      activeAction = void 0;
      return retValue;
    };
  }
}
function devtoolsPlugin({ app: app2, store, options: options3 }) {
  if (store.$id.startsWith("__hot:")) {
    return;
  }
  store._isOptionsAPI = !!options3.state;
  patchActionForGrouping(store, Object.keys(options3.actions), store._isOptionsAPI);
  const originalHotUpdate = store._hotUpdate;
  toRaw(store)._hotUpdate = function(newStore) {
    originalHotUpdate.apply(this, arguments);
    patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
  };
  addStoreToDevtools(
    app2,
    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
    store
  );
}
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app2) {
      setActivePinia(pinia2);
      if (!isVue2) {
        pinia2._a = app2;
        app2.provide(piniaSymbol, pinia2);
        app2.config.globalProperties.$pinia = pinia2;
        if (USE_DEVTOOLS) {
          registerPiniaDevtools(app2, pinia2);
        }
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
    pinia2.use(devtoolsPlugin);
  }
  return pinia2;
}
const isUseStore = (fn) => {
  return typeof fn === "function" && typeof fn.$id === "string";
};
function patchObject(newState, oldState) {
  for (const key in oldState) {
    const subPatch = oldState[key];
    if (!(key in newState)) {
      continue;
    }
    const targetValue = newState[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      newState[key] = patchObject(targetValue, subPatch);
    } else {
      if (isVue2) {
        set(newState, key, subPatch);
      } else {
        newState[key] = subPatch;
      }
    }
  }
  return newState;
}
function acceptHMRUpdate(initialUseStore, hot) {
  if (true) {
    return () => {
    };
  }
  return (newModule) => {
    const pinia2 = hot.data.pinia || initialUseStore._pinia;
    if (!pinia2) {
      return;
    }
    hot.data.pinia = pinia2;
    for (const exportName in newModule) {
      const useStore = newModule[exportName];
      if (isUseStore(useStore) && pinia2._s.has(useStore.$id)) {
        const id2 = useStore.$id;
        if (id2 !== initialUseStore.$id) {
          console.warn(`The id of the store changed from "${initialUseStore.$id}" to "${id2}". Reloading.`);
          return hot.invalidate();
        }
        const existingStore = pinia2._s.get(id2);
        if (!existingStore) {
          console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);
          return;
        }
        useStore(pinia2, existingStore);
      }
    }
  };
}
const noop = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value3, key) => target.set(key, value3));
  }
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = false ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
const skipHydrateMap = /* @__PURE__ */ new WeakMap();
function skipHydrate(obj) {
  return isVue2 ? (
    // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...
    /* istanbul ignore next */
    skipHydrateMap.set(obj, 1) && obj
  ) : Object.defineProperty(obj, skipHydrateSymbol, {});
}
function shouldHydrate(obj) {
  return isVue2 ? (
    /* istanbul ignore next */
    !skipHydrateMap.has(obj)
  ) : !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$2 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id2, options3, pinia2, hot) {
  const { state, actions, getters } = options3;
  const initialState = pinia2.state.value[id2];
  let store;
  function setup2() {
    if (!initialState && true) {
      if (isVue2) {
        set(pinia2.state.value, id2, state ? state() : {});
      } else {
        pinia2.state.value[id2] = state ? state() : {};
      }
    }
    const localState = false ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      toRefs(ref(state ? state() : {}).value)
    ) : toRefs(pinia2.state.value[id2]);
    return assign$2(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      if (false) {
        console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id2}".`);
      }
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store2 = pinia2._s.get(id2);
        if (isVue2 && !store2._r)
          return;
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id2, setup2, options3, pinia2, hot, true);
  return store;
}
function createSetupStore($id, setup2, options3 = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$2({ actions: {} }, options3);
  if (false) {
    throw new Error("Pinia destroyed");
  }
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  if (false) {
    $subscribeOptions.onTrigger = (event2) => {
      if (isListening) {
        debuggerEvents = event2;
      } else if (isListening == false && !store._hotUpdating) {
        if (Array.isArray(debuggerEvents)) {
          debuggerEvents.push(event2);
        } else {
          console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.");
        }
      }
    };
  }
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia2.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    if (isVue2) {
      set(pinia2.state.value, $id, {});
    } else {
      pinia2.state.value[$id] = {};
    }
  }
  const hotState = ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (false) {
      debuggerEvents = [];
    }
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options3;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$2($state, newState);
    });
  } : (
    /* istanbul ignore next */
    false ? () => {
      throw new Error(`🍍: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
    } : noop
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia2._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value3) => {
          triggerSubscriptions(afterCallbackList, value3);
          return value3;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const _hmrPayload = /* @__PURE__ */ markRaw({
    actions: {},
    getters: {},
    state: [],
    hotState
  });
  const partialStore = {
    _p: pinia2,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options22 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options22.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
        if (options22.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$2({}, $subscribeOptions, options22)));
      return removeSubscription;
    },
    $dispose
  };
  if (isVue2) {
    partialStore._r = false;
  }
  const store = reactive(USE_DEVTOOLS ? assign$2(
    {
      _hmrPayload,
      _customProperties: markRaw(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    partialStore
    // must be added later
    // setupStore
  ) : partialStore);
  pinia2._s.set($id, store);
  const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(setup2)));
  for (const key in setupStore) {
    const prop2 = setupStore[key];
    if (isRef(prop2) && !isComputed(prop2) || isReactive(prop2)) {
      if (false) {
        set(hotState.value, key, toRef(setupStore, key));
      } else if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop2)) {
          if (isRef(prop2)) {
            prop2.value = initialState[key];
          } else {
            mergeReactiveObjects(prop2, initialState[key]);
          }
        }
        if (isVue2) {
          set(pinia2.state.value[$id], key, prop2);
        } else {
          pinia2.state.value[$id][key] = prop2;
        }
      }
      if (false) {
        _hmrPayload.state.push(key);
      }
    } else if (typeof prop2 === "function") {
      const actionValue = false ? prop2 : wrapAction(key, prop2);
      if (isVue2) {
        set(setupStore, key, actionValue);
      } else {
        setupStore[key] = actionValue;
      }
      if (false) {
        _hmrPayload.actions[key] = prop2;
      }
      optionsForPlugin.actions[key] = prop2;
    } else if (false) {
      if (isComputed(prop2)) {
        _hmrPayload.getters[key] = isOptionsStore ? (
          // @ts-expect-error
          options3.getters[key]
        ) : prop2;
        if (IS_CLIENT) {
          const getters = setupStore._getters || // @ts-expect-error: same
          (setupStore._getters = markRaw([]));
          getters.push(key);
        }
      }
    }
  }
  if (isVue2) {
    Object.keys(setupStore).forEach((key) => {
      set(store, key, setupStore[key]);
    });
  } else {
    assign$2(store, setupStore);
    assign$2(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => false ? hotState.value : pinia2.state.value[$id],
    set: (state) => {
      if (false) {
        throw new Error("cannot set hotState");
      }
      $patch(($state) => {
        assign$2($state, state);
      });
    }
  });
  if (false) {
    store._hotUpdate = markRaw((newStore) => {
      store._hotUpdating = true;
      newStore._hmrPayload.state.forEach((stateKey) => {
        if (stateKey in store.$state) {
          const newStateTarget = newStore.$state[stateKey];
          const oldStateSource = store.$state[stateKey];
          if (typeof newStateTarget === "object" && isPlainObject$1(newStateTarget) && isPlainObject$1(oldStateSource)) {
            patchObject(newStateTarget, oldStateSource);
          } else {
            newStore.$state[stateKey] = oldStateSource;
          }
        }
        set(store, stateKey, toRef(newStore.$state, stateKey));
      });
      Object.keys(store.$state).forEach((stateKey) => {
        if (!(stateKey in newStore.$state)) {
          del(store, stateKey);
        }
      });
      isListening = false;
      isSyncListening = false;
      pinia2.state.value[$id] = toRef(newStore._hmrPayload, "hotState");
      isSyncListening = true;
      nextTick().then(() => {
        isListening = true;
      });
      for (const actionName in newStore._hmrPayload.actions) {
        const action = newStore[actionName];
        set(store, actionName, wrapAction(actionName, action));
      }
      for (const getterName in newStore._hmrPayload.getters) {
        const getter = newStore._hmrPayload.getters[getterName];
        const getterValue = isOptionsStore ? (
          // special handling of options api
          computed(() => {
            setActivePinia(pinia2);
            return getter.call(store, store);
          })
        ) : getter;
        set(store, getterName, getterValue);
      }
      Object.keys(store._hmrPayload.getters).forEach((key) => {
        if (!(key in newStore._hmrPayload.getters)) {
          del(store, key);
        }
      });
      Object.keys(store._hmrPayload.actions).forEach((key) => {
        if (!(key in newStore._hmrPayload.actions)) {
          del(store, key);
        }
      });
      store._hmrPayload = newStore._hmrPayload;
      store._getters = newStore._getters;
      store._hotUpdating = false;
    });
  }
  if (USE_DEVTOOLS) {
    const nonEnumerable = {
      writable: true,
      configurable: true,
      // avoid warning on devtools trying to display this property
      enumerable: false
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
      Object.defineProperty(store, p2, assign$2({ value: store[p2] }, nonEnumerable));
    });
  }
  if (isVue2) {
    store._r = true;
  }
  pinia2._p.forEach((extender) => {
    if (USE_DEVTOOLS) {
      const extensions = scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      }));
      Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
      assign$2(store, extensions);
    } else {
      assign$2(store, scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (false) {
    console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
  }
  if (initialState && isOptionsStore && options3.hydrate) {
    options3.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup2, setupOptions) {
  let id2;
  let options3;
  const isSetupStore = typeof setup2 === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options3 = isSetupStore ? setupOptions : setup2;
  } else {
    options3 = idOrOptions;
    id2 = idOrOptions.id;
    if (false) {
      throw new Error(`[🍍]: "defineStore()" must be passed a store id as its first argument.`);
    }
  }
  function useStore(pinia2, hot) {
    const hasContext = hasInjectionContext();
    pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (false ? null : pinia2) || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia2)
      setActivePinia(pinia2);
    if (false) {
      throw new Error(`[🍍]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
    }
    pinia2 = activePinia;
    if (!pinia2._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup2, options3, pinia2);
      } else {
        createOptionsStore(id2, options3, pinia2);
      }
      if (false) {
        useStore._pinia = pinia2;
      }
    }
    const store = pinia2._s.get(id2);
    if (false) {
      const hotId = "__hot:" + id2;
      const newStore = isSetupStore ? createSetupStore(hotId, setup2, options3, pinia2, true) : createOptionsStore(hotId, assign$2({}, options3), pinia2, true);
      hot._hotUpdate(newStore);
      delete pinia2.state.value[hotId];
      pinia2._s.delete(hotId);
    }
    if (false) {
      const currentInstance2 = getCurrentInstance();
      if (currentInstance2 && currentInstance2.proxy && // avoid adding stores that are just built for hot module replacement
      !hot) {
        const vm = currentInstance2.proxy;
        const cache2 = "_pStores" in vm ? vm._pStores : vm._pStores = {};
        cache2[id2] = store;
      }
    }
    return store;
  }
  useStore.$id = id2;
  return useStore;
}
let mapStoreSuffix = "Store";
function setMapStoreSuffix(suffix2) {
  mapStoreSuffix = suffix2;
}
function mapStores(...stores) {
  if (false) {
    console.warn(`[🍍]: Directly pass all stores to "mapStores()" without putting them in an array:
Replace
	mapStores([useAuthStore, useCartStore])
with
	mapStores(useAuthStore, useCartStore)
This will fail in production if not fixed.`);
    stores = stores[0];
  }
  return stores.reduce((reduced, useStore) => {
    reduced[useStore.$id + mapStoreSuffix] = function() {
      return useStore(this.$pinia);
    };
    return reduced;
  }, {});
}
function mapState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function() {
      return useStore(this.$pinia)[key];
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function() {
      const store = useStore(this.$pinia);
      const storeKey = keysOrMapper[key];
      return typeof storeKey === "function" ? storeKey.call(this, store) : store[storeKey];
    };
    return reduced;
  }, {});
}
const mapGetters = mapState;
function mapActions(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return useStore(this.$pinia)[key](...args);
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return useStore(this.$pinia)[keysOrMapper[key]](...args);
    };
    return reduced;
  }, {});
}
function mapWritableState(useStore, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return useStore(this.$pinia)[key];
      },
      set(value3) {
        return useStore(this.$pinia)[key] = value3;
      }
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return useStore(this.$pinia)[keysOrMapper[key]];
      },
      set(value3) {
        return useStore(this.$pinia)[keysOrMapper[key]] = value3;
      }
    };
    return reduced;
  }, {});
}
function storeToRefs(store) {
  if (isVue2) {
    return toRefs(store);
  } else {
    store = toRaw(store);
    const refs = {};
    for (const key in store) {
      const value3 = store[key];
      if (isRef(value3) || isReactive(value3)) {
        refs[key] = // ---
        toRef(store, key);
      }
    }
    return refs;
  }
}
const PiniaVuePlugin = function(_Vue) {
  _Vue.mixin({
    beforeCreate() {
      const options3 = this.$options;
      if (options3.pinia) {
        const pinia2 = options3.pinia;
        if (!this._provided) {
          const provideCache = {};
          Object.defineProperty(this, "_provided", {
            get: () => provideCache,
            set: (v2) => Object.assign(provideCache, v2)
          });
        }
        this._provided[piniaSymbol] = pinia2;
        if (!this.$pinia) {
          this.$pinia = pinia2;
        }
        pinia2._a = this;
        if (IS_CLIENT) {
          setActivePinia(pinia2);
        }
        if (USE_DEVTOOLS) {
          registerPiniaDevtools(pinia2._a, pinia2);
        }
      } else if (!this.$pinia && options3.parent && options3.parent.$pinia) {
        this.$pinia = options3.parent.$pinia;
      }
    },
    destroyed() {
      delete this._pStores;
    }
  });
};
var TransformationType;
(function(TransformationType2) {
  TransformationType2[TransformationType2["PLAIN_TO_CLASS"] = 0] = "PLAIN_TO_CLASS";
  TransformationType2[TransformationType2["CLASS_TO_PLAIN"] = 1] = "CLASS_TO_PLAIN";
  TransformationType2[TransformationType2["CLASS_TO_CLASS"] = 2] = "CLASS_TO_CLASS";
})(TransformationType || (TransformationType = {}));
var MetadataStorage = (
  /** @class */
  function() {
    function MetadataStorage2() {
      this._typeMetadatas = /* @__PURE__ */ new Map();
      this._transformMetadatas = /* @__PURE__ */ new Map();
      this._exposeMetadatas = /* @__PURE__ */ new Map();
      this._excludeMetadatas = /* @__PURE__ */ new Map();
      this._ancestorsMap = /* @__PURE__ */ new Map();
    }
    MetadataStorage2.prototype.addTypeMetadata = function(metadata) {
      if (!this._typeMetadatas.has(metadata.target)) {
        this._typeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
      }
      this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    };
    MetadataStorage2.prototype.addTransformMetadata = function(metadata) {
      if (!this._transformMetadatas.has(metadata.target)) {
        this._transformMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
      }
      if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
        this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
      }
      this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
    };
    MetadataStorage2.prototype.addExposeMetadata = function(metadata) {
      if (!this._exposeMetadatas.has(metadata.target)) {
        this._exposeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
      }
      this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    };
    MetadataStorage2.prototype.addExcludeMetadata = function(metadata) {
      if (!this._excludeMetadatas.has(metadata.target)) {
        this._excludeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
      }
      this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    };
    MetadataStorage2.prototype.findTransformMetadatas = function(target, propertyName, transformationType) {
      return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function(metadata) {
        if (!metadata.options)
          return true;
        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
          return true;
        if (metadata.options.toClassOnly === true) {
          return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
        }
        if (metadata.options.toPlainOnly === true) {
          return transformationType === TransformationType.CLASS_TO_PLAIN;
        }
        return true;
      });
    };
    MetadataStorage2.prototype.findExcludeMetadata = function(target, propertyName) {
      return this.findMetadata(this._excludeMetadatas, target, propertyName);
    };
    MetadataStorage2.prototype.findExposeMetadata = function(target, propertyName) {
      return this.findMetadata(this._exposeMetadatas, target, propertyName);
    };
    MetadataStorage2.prototype.findExposeMetadataByCustomName = function(target, name) {
      return this.getExposedMetadatas(target).find(function(metadata) {
        return metadata.options && metadata.options.name === name;
      });
    };
    MetadataStorage2.prototype.findTypeMetadata = function(target, propertyName) {
      return this.findMetadata(this._typeMetadatas, target, propertyName);
    };
    MetadataStorage2.prototype.getStrategy = function(target) {
      var excludeMap = this._excludeMetadatas.get(target);
      var exclude = excludeMap && excludeMap.get(void 0);
      var exposeMap = this._exposeMetadatas.get(target);
      var expose = exposeMap && exposeMap.get(void 0);
      if (exclude && expose || !exclude && !expose)
        return "none";
      return exclude ? "excludeAll" : "exposeAll";
    };
    MetadataStorage2.prototype.getExposedMetadatas = function(target) {
      return this.getMetadata(this._exposeMetadatas, target);
    };
    MetadataStorage2.prototype.getExcludedMetadatas = function(target) {
      return this.getMetadata(this._excludeMetadatas, target);
    };
    MetadataStorage2.prototype.getExposedProperties = function(target, transformationType) {
      return this.getExposedMetadatas(target).filter(function(metadata) {
        if (!metadata.options)
          return true;
        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
          return true;
        if (metadata.options.toClassOnly === true) {
          return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
        }
        if (metadata.options.toPlainOnly === true) {
          return transformationType === TransformationType.CLASS_TO_PLAIN;
        }
        return true;
      }).map(function(metadata) {
        return metadata.propertyName;
      });
    };
    MetadataStorage2.prototype.getExcludedProperties = function(target, transformationType) {
      return this.getExcludedMetadatas(target).filter(function(metadata) {
        if (!metadata.options)
          return true;
        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
          return true;
        if (metadata.options.toClassOnly === true) {
          return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
        }
        if (metadata.options.toPlainOnly === true) {
          return transformationType === TransformationType.CLASS_TO_PLAIN;
        }
        return true;
      }).map(function(metadata) {
        return metadata.propertyName;
      });
    };
    MetadataStorage2.prototype.clear = function() {
      this._typeMetadatas.clear();
      this._exposeMetadatas.clear();
      this._excludeMetadatas.clear();
      this._ancestorsMap.clear();
    };
    MetadataStorage2.prototype.getMetadata = function(metadatas, target) {
      var metadataFromTargetMap = metadatas.get(target);
      var metadataFromTarget;
      if (metadataFromTargetMap) {
        metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function(meta) {
          return meta.propertyName !== void 0;
        });
      }
      var metadataFromAncestors = [];
      for (var _i = 0, _a2 = this.getAncestors(target); _i < _a2.length; _i++) {
        var ancestor = _a2[_i];
        var ancestorMetadataMap = metadatas.get(ancestor);
        if (ancestorMetadataMap) {
          var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function(meta) {
            return meta.propertyName !== void 0;
          });
          metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);
        }
      }
      return metadataFromAncestors.concat(metadataFromTarget || []);
    };
    MetadataStorage2.prototype.findMetadata = function(metadatas, target, propertyName) {
      var metadataFromTargetMap = metadatas.get(target);
      if (metadataFromTargetMap) {
        var metadataFromTarget = metadataFromTargetMap.get(propertyName);
        if (metadataFromTarget) {
          return metadataFromTarget;
        }
      }
      for (var _i = 0, _a2 = this.getAncestors(target); _i < _a2.length; _i++) {
        var ancestor = _a2[_i];
        var ancestorMetadataMap = metadatas.get(ancestor);
        if (ancestorMetadataMap) {
          var ancestorResult = ancestorMetadataMap.get(propertyName);
          if (ancestorResult) {
            return ancestorResult;
          }
        }
      }
      return void 0;
    };
    MetadataStorage2.prototype.findMetadatas = function(metadatas, target, propertyName) {
      var metadataFromTargetMap = metadatas.get(target);
      var metadataFromTarget;
      if (metadataFromTargetMap) {
        metadataFromTarget = metadataFromTargetMap.get(propertyName);
      }
      var metadataFromAncestorsTarget = [];
      for (var _i = 0, _a2 = this.getAncestors(target); _i < _a2.length; _i++) {
        var ancestor = _a2[_i];
        var ancestorMetadataMap = metadatas.get(ancestor);
        if (ancestorMetadataMap) {
          if (ancestorMetadataMap.has(propertyName)) {
            metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));
          }
        }
      }
      return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());
    };
    MetadataStorage2.prototype.getAncestors = function(target) {
      if (!target)
        return [];
      if (!this._ancestorsMap.has(target)) {
        var ancestors = [];
        for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== "undefined"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
          ancestors.push(baseClass);
        }
        this._ancestorsMap.set(target, ancestors);
      }
      return this._ancestorsMap.get(target);
    };
    return MetadataStorage2;
  }()
);
var defaultMetadataStorage = new MetadataStorage();
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof self !== "undefined") {
    return self;
  }
}
function isPromise$1(p2) {
  return p2 !== null && typeof p2 === "object" && typeof p2.then === "function";
}
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function instantiateArrayType(arrayType2) {
  var array = new arrayType2();
  if (!(array instanceof Set) && !("push" in array)) {
    return [];
  }
  return array;
}
var TransformOperationExecutor = (
  /** @class */
  function() {
    function TransformOperationExecutor2(transformationType, options3) {
      this.transformationType = transformationType;
      this.options = options3;
      this.recursionStack = /* @__PURE__ */ new Set();
    }
    TransformOperationExecutor2.prototype.transform = function(source, value3, targetType, arrayType2, isMap2, level) {
      var _this = this;
      if (level === void 0) {
        level = 0;
      }
      if (Array.isArray(value3) || value3 instanceof Set) {
        var newValue_1 = arrayType2 && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType2) : [];
        value3.forEach(function(subValue, index2) {
          var subSource = source ? source[index2] : void 0;
          if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {
            var realTargetType = void 0;
            if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
              if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {
                realTargetType = targetType.options.discriminator.subTypes.find(function(subType) {
                  return subType.name === subValue[targetType.options.discriminator.property];
                });
                var options3 = { newObject: newValue_1, object: subValue, property: void 0 };
                var newType = targetType.typeFunction(options3);
                realTargetType === void 0 ? realTargetType = newType : realTargetType = realTargetType.value;
                if (!targetType.options.keepDiscriminatorProperty)
                  delete subValue[targetType.options.discriminator.property];
              }
              if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
                realTargetType = subValue.constructor;
              }
              if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {
                subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function(subType) {
                  return subType.value === subValue.constructor;
                }).name;
              }
            } else {
              realTargetType = targetType;
            }
            var value_1 = _this.transform(subSource, subValue, realTargetType, void 0, subValue instanceof Map, level + 1);
            if (newValue_1 instanceof Set) {
              newValue_1.add(value_1);
            } else {
              newValue_1.push(value_1);
            }
          } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
            if (newValue_1 instanceof Set) {
              newValue_1.add(subValue);
            } else {
              newValue_1.push(subValue);
            }
          }
        });
        return newValue_1;
      } else if (targetType === String && !isMap2) {
        if (value3 === null || value3 === void 0)
          return value3;
        return String(value3);
      } else if (targetType === Number && !isMap2) {
        if (value3 === null || value3 === void 0)
          return value3;
        return Number(value3);
      } else if (targetType === Boolean && !isMap2) {
        if (value3 === null || value3 === void 0)
          return value3;
        return Boolean(value3);
      } else if ((targetType === Date || value3 instanceof Date) && !isMap2) {
        if (value3 instanceof Date) {
          return new Date(value3.valueOf());
        }
        if (value3 === null || value3 === void 0)
          return value3;
        return new Date(value3);
      } else if (!!getGlobal().Buffer && (targetType === Buffer || value3 instanceof Buffer) && !isMap2) {
        if (value3 === null || value3 === void 0)
          return value3;
        return Buffer.from(value3);
      } else if (isPromise$1(value3) && !isMap2) {
        return new Promise(function(resolve8, reject2) {
          value3.then(function(data28) {
            return resolve8(_this.transform(void 0, data28, targetType, void 0, void 0, level + 1));
          }, reject2);
        });
      } else if (!isMap2 && value3 !== null && typeof value3 === "object" && typeof value3.then === "function") {
        return value3;
      } else if (typeof value3 === "object" && value3 !== null) {
        if (!targetType && value3.constructor !== Object)
          if (!Array.isArray(value3) && value3.constructor === Array) {
          } else {
            targetType = value3.constructor;
          }
        if (!targetType && source)
          targetType = source.constructor;
        if (this.options.enableCircularCheck) {
          this.recursionStack.add(value3);
        }
        var keys = this.getKeys(targetType, value3, isMap2);
        var newValue = source ? source : {};
        if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {
          if (isMap2) {
            newValue = /* @__PURE__ */ new Map();
          } else if (targetType) {
            newValue = new targetType();
          } else {
            newValue = {};
          }
        }
        var _loop_1 = function(key2) {
          if (key2 === "__proto__" || key2 === "constructor") {
            return "continue";
          }
          var valueKey = key2;
          var newValueKey = key2, propertyName = key2;
          if (!this_1.options.ignoreDecorators && targetType) {
            if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key2);
              if (exposeMetadata) {
                propertyName = exposeMetadata.propertyName;
                newValueKey = exposeMetadata.propertyName;
              }
            } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key2);
              if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                newValueKey = exposeMetadata.options.name;
              }
            }
          }
          var subValue = void 0;
          if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
            subValue = value3[valueKey];
          } else {
            if (value3 instanceof Map) {
              subValue = value3.get(valueKey);
            } else if (value3[valueKey] instanceof Function) {
              subValue = value3[valueKey]();
            } else {
              subValue = value3[valueKey];
            }
          }
          var type = void 0, isSubValueMap = subValue instanceof Map;
          if (targetType && isMap2) {
            type = targetType;
          } else if (targetType) {
            var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);
            if (metadata_1) {
              var options3 = { newObject: newValue, object: value3, property: propertyName };
              var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options3) : metadata_1.reflectedType;
              if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {
                if (!(value3[valueKey] instanceof Array)) {
                  if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                    type = metadata_1.options.discriminator.subTypes.find(function(subType) {
                      if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                        return subType.name === subValue[metadata_1.options.discriminator.property];
                      }
                    });
                    type === void 0 ? type = newType : type = type.value;
                    if (!metadata_1.options.keepDiscriminatorProperty) {
                      if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                        delete subValue[metadata_1.options.discriminator.property];
                      }
                    }
                  }
                  if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
                    type = subValue.constructor;
                  }
                  if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
                    if (subValue) {
                      subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function(subType) {
                        return subType.value === subValue.constructor;
                      }).name;
                    }
                  }
                } else {
                  type = metadata_1;
                }
              } else {
                type = newType;
              }
              isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;
            } else if (this_1.options.targetMaps) {
              this_1.options.targetMaps.filter(function(map2) {
                return map2.target === targetType && !!map2.properties[propertyName];
              }).forEach(function(map2) {
                return type = map2.properties[propertyName];
              });
            } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
              var reflectedType = Reflect.getMetadata("design:type", targetType.prototype, propertyName);
              if (reflectedType) {
                type = reflectedType;
              }
            }
          }
          var arrayType_1 = Array.isArray(value3[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : void 0;
          var subSource = source ? source[valueKey] : void 0;
          if (newValue.constructor.prototype) {
            var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
            if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && // eslint-disable-next-line @typescript-eslint/unbound-method
            (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function))
              return "continue";
          }
          if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {
            var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key2;
            var finalValue = void 0;
            if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
              finalValue = value3[transformKey];
              finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value3, this_1.transformationType);
              finalValue = value3[transformKey] === finalValue ? subValue : finalValue;
              finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);
            } else {
              if (subValue === void 0 && this_1.options.exposeDefaultValues) {
                finalValue = newValue[newValueKey];
              } else {
                finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);
                finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value3, this_1.transformationType);
              }
            }
            if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
              if (newValue instanceof Map) {
                newValue.set(newValueKey, finalValue);
              } else {
                newValue[newValueKey] = finalValue;
              }
            }
          } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
            var finalValue = subValue;
            finalValue = this_1.applyCustomTransformations(finalValue, targetType, key2, value3, this_1.transformationType);
            if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
              if (newValue instanceof Map) {
                newValue.set(newValueKey, finalValue);
              } else {
                newValue[newValueKey] = finalValue;
              }
            }
          }
        };
        var this_1 = this;
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          _loop_1(key);
        }
        if (this.options.enableCircularCheck) {
          this.recursionStack.delete(value3);
        }
        return newValue;
      } else {
        return value3;
      }
    };
    TransformOperationExecutor2.prototype.applyCustomTransformations = function(value3, target, key, obj, transformationType) {
      var _this = this;
      var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
      if (this.options.version !== void 0) {
        metadatas = metadatas.filter(function(metadata) {
          if (!metadata.options)
            return true;
          return _this.checkVersion(metadata.options.since, metadata.options.until);
        });
      }
      if (this.options.groups && this.options.groups.length) {
        metadatas = metadatas.filter(function(metadata) {
          if (!metadata.options)
            return true;
          return _this.checkGroups(metadata.options.groups);
        });
      } else {
        metadatas = metadatas.filter(function(metadata) {
          return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
        });
      }
      metadatas.forEach(function(metadata) {
        value3 = metadata.transformFn({ value: value3, key, obj, type: transformationType, options: _this.options });
      });
      return value3;
    };
    TransformOperationExecutor2.prototype.isCircular = function(object) {
      return this.recursionStack.has(object);
    };
    TransformOperationExecutor2.prototype.getReflectedType = function(target, propertyName) {
      if (!target)
        return void 0;
      var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
      return meta ? meta.reflectedType : void 0;
    };
    TransformOperationExecutor2.prototype.getKeys = function(target, object, isMap2) {
      var _this = this;
      var strategy = defaultMetadataStorage.getStrategy(target);
      if (strategy === "none")
        strategy = this.options.strategy || "exposeAll";
      var keys = [];
      if (strategy === "exposeAll" || isMap2) {
        if (object instanceof Map) {
          keys = Array.from(object.keys());
        } else {
          keys = Object.keys(object);
        }
      }
      if (isMap2) {
        return keys;
      }
      if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {
        var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
        var excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
        keys = __spreadArray(__spreadArray([], exposedProperties, true), excludedProperties, true);
      }
      if (!this.options.ignoreDecorators && target) {
        var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
          exposedProperties = exposedProperties.map(function(key) {
            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
              return exposeMetadata.options.name;
            }
            return key;
          });
        }
        if (this.options.excludeExtraneousValues) {
          keys = exposedProperties;
        } else {
          keys = keys.concat(exposedProperties);
        }
        var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
        if (excludedProperties_1.length > 0) {
          keys = keys.filter(function(key) {
            return !excludedProperties_1.includes(key);
          });
        }
        if (this.options.version !== void 0) {
          keys = keys.filter(function(key) {
            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
            if (!exposeMetadata || !exposeMetadata.options)
              return true;
            return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
          });
        }
        if (this.options.groups && this.options.groups.length) {
          keys = keys.filter(function(key) {
            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
            if (!exposeMetadata || !exposeMetadata.options)
              return true;
            return _this.checkGroups(exposeMetadata.options.groups);
          });
        } else {
          keys = keys.filter(function(key) {
            var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
            return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
          });
        }
      }
      if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
        keys = keys.filter(function(key) {
          return _this.options.excludePrefixes.every(function(prefix2) {
            return key.substr(0, prefix2.length) !== prefix2;
          });
        });
      }
      keys = keys.filter(function(key, index2, self2) {
        return self2.indexOf(key) === index2;
      });
      return keys;
    };
    TransformOperationExecutor2.prototype.checkVersion = function(since, until) {
      var decision = true;
      if (decision && since)
        decision = this.options.version >= since;
      if (decision && until)
        decision = this.options.version < until;
      return decision;
    };
    TransformOperationExecutor2.prototype.checkGroups = function(groups) {
      if (!groups)
        return true;
      return this.options.groups.some(function(optionGroup) {
        return groups.includes(optionGroup);
      });
    };
    return TransformOperationExecutor2;
  }()
);
var defaultOptions = {
  enableCircularCheck: false,
  enableImplicitConversion: false,
  excludeExtraneousValues: false,
  excludePrefixes: void 0,
  exposeDefaultValues: false,
  exposeUnsetFields: true,
  groups: void 0,
  ignoreDecorators: false,
  strategy: void 0,
  targetMaps: void 0,
  version: void 0
};
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2))
        t[p2] = s[p2];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var ClassTransformer = (
  /** @class */
  function() {
    function ClassTransformer2() {
    }
    ClassTransformer2.prototype.instanceToPlain = function(object, options3) {
      var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.classToPlainFromExist = function(object, plainObject, options3) {
      var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(plainObject, object, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.plainToInstance = function(cls, plain, options3) {
      var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(void 0, plain, cls, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.plainToClassFromExist = function(clsObject, plain, options3) {
      var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(clsObject, plain, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.instanceToInstance = function(object, options3) {
      var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.classToClassFromExist = function(object, fromObject, options3) {
      var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), options3));
      return executor.transform(fromObject, object, void 0, void 0, void 0, void 0);
    };
    ClassTransformer2.prototype.serialize = function(object, options3) {
      return JSON.stringify(this.instanceToPlain(object, options3));
    };
    ClassTransformer2.prototype.deserialize = function(cls, json, options3) {
      var jsonObject = JSON.parse(json);
      return this.plainToInstance(cls, jsonObject, options3);
    };
    ClassTransformer2.prototype.deserializeArray = function(cls, json, options3) {
      var jsonObject = JSON.parse(json);
      return this.plainToInstance(cls, jsonObject, options3);
    };
    return ClassTransformer2;
  }()
);
function Exclude(options3) {
  if (options3 === void 0) {
    options3 = {};
  }
  return function(object, propertyName) {
    defaultMetadataStorage.addExcludeMetadata({
      target: object instanceof Function ? object : object.constructor,
      propertyName,
      options: options3
    });
  };
}
function Expose(options3) {
  if (options3 === void 0) {
    options3 = {};
  }
  return function(object, propertyName) {
    defaultMetadataStorage.addExposeMetadata({
      target: object instanceof Function ? object : object.constructor,
      propertyName,
      options: options3
    });
  };
}
function TransformInstanceToInstance(params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = originalMethod.apply(this, args);
      var isPromise2 = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
      return isPromise2 ? result.then(function(data28) {
        return classTransformer2.instanceToInstance(data28, params);
      }) : classTransformer2.instanceToInstance(result, params);
    };
  };
}
function TransformInstanceToPlain(params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = originalMethod.apply(this, args);
      var isPromise2 = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
      return isPromise2 ? result.then(function(data28) {
        return classTransformer2.instanceToPlain(data28, params);
      }) : classTransformer2.instanceToPlain(result, params);
    };
  };
}
function TransformPlainToInstance(classType, params) {
  return function(target, propertyKey, descriptor) {
    var classTransformer2 = new ClassTransformer();
    var originalMethod = descriptor.value;
    descriptor.value = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = originalMethod.apply(this, args);
      var isPromise2 = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
      return isPromise2 ? result.then(function(data28) {
        return classTransformer2.plainToInstance(classType, data28, params);
      }) : classTransformer2.plainToInstance(classType, result, params);
    };
  };
}
function Transform(transformFn, options3) {
  if (options3 === void 0) {
    options3 = {};
  }
  return function(target, propertyName) {
    defaultMetadataStorage.addTransformMetadata({
      target: target.constructor,
      propertyName,
      transformFn,
      options: options3
    });
  };
}
function Type(typeFunction, options3) {
  if (options3 === void 0) {
    options3 = {};
  }
  return function(target, propertyName) {
    var reflectedType = Reflect.getMetadata("design:type", target, propertyName);
    defaultMetadataStorage.addTypeMetadata({
      target: target.constructor,
      propertyName,
      reflectedType,
      typeFunction,
      options: options3
    });
  };
}
var classTransformer = new ClassTransformer();
function classToPlain(object, options3) {
  return classTransformer.instanceToPlain(object, options3);
}
function instanceToPlain(object, options3) {
  return classTransformer.instanceToPlain(object, options3);
}
function classToPlainFromExist(object, plainObject, options3) {
  return classTransformer.classToPlainFromExist(object, plainObject, options3);
}
function plainToClass(cls, plain, options3) {
  return classTransformer.plainToInstance(cls, plain, options3);
}
function plainToInstance(cls, plain, options3) {
  return classTransformer.plainToInstance(cls, plain, options3);
}
function plainToClassFromExist(clsObject, plain, options3) {
  return classTransformer.plainToClassFromExist(clsObject, plain, options3);
}
function instanceToInstance(object, options3) {
  return classTransformer.instanceToInstance(object, options3);
}
function classToClassFromExist(object, fromObject, options3) {
  return classTransformer.classToClassFromExist(object, fromObject, options3);
}
function serialize(object, options3) {
  return classTransformer.serialize(object, options3);
}
function deserialize(cls, json, options3) {
  return classTransformer.deserialize(cls, json, options3);
}
function deserializeArray(cls, json, options3) {
  return classTransformer.deserializeArray(cls, json, options3);
}
function buildTree(items2, key) {
  const root27 = {
    key: "root",
    label: "root",
    children: []
  };
  const map2 = {
    root: root27
  };
  for (const item of items2) {
    const keys = typeof key === "string" ? item[key] : key(item);
    let parent = root27;
    for (const k of keys) {
      const id2 = parent.key + "/" + k;
      if (!map2[id2]) {
        const node3 = {
          key: id2,
          label: k,
          leaf: false,
          children: []
        };
        map2[id2] = node3;
        parent.children.push(node3);
      }
      parent = map2[id2];
    }
    parent.leaf = true;
    parent.data = item;
  }
  return root27;
}
function flattenTree(tree) {
  const result = [];
  const stack2 = [tree];
  while (stack2.length) {
    const node3 = stack2.pop();
    if (node3.leaf && node3.data) result.push(node3.data);
    stack2.push(...node3.children || []);
  }
  return result;
}
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
class BaseInputSpec {
  constructor() {
    __publicField2(this, "name");
    __publicField2(this, "type");
    __publicField2(this, "tooltip");
    __publicField2(this, "default");
    __publicField2(this, "forceInput");
  }
  static isInputSpec(obj) {
    return Array.isArray(obj) && obj.length >= 1 && (typeof obj[0] === "string" || Array.isArray(obj[0]));
  }
}
__decorateClass([
  Type(() => Boolean)
], BaseInputSpec.prototype, "forceInput", 2);
class NumericInputSpec extends BaseInputSpec {
  constructor() {
    super(...arguments);
    __publicField2(this, "min");
    __publicField2(this, "max");
    __publicField2(this, "step");
  }
}
__decorateClass([
  Type(() => Number)
], NumericInputSpec.prototype, "min", 2);
__decorateClass([
  Type(() => Number)
], NumericInputSpec.prototype, "max", 2);
__decorateClass([
  Type(() => Number)
], NumericInputSpec.prototype, "step", 2);
class IntInputSpec extends NumericInputSpec {
  constructor() {
    super(...arguments);
    __publicField2(this, "type", "INT");
  }
}
class FloatInputSpec extends NumericInputSpec {
  constructor() {
    super(...arguments);
    __publicField2(this, "type", "FLOAT");
    __publicField2(this, "round");
  }
}
__decorateClass([
  Type(() => Number)
], FloatInputSpec.prototype, "round", 2);
class BooleanInputSpec extends BaseInputSpec {
  constructor() {
    super(...arguments);
    __publicField2(this, "type", "BOOLEAN");
    __publicField2(this, "labelOn");
    __publicField2(this, "labelOff");
  }
}
class StringInputSpec extends BaseInputSpec {
  constructor() {
    super(...arguments);
    __publicField2(this, "type", "STRING");
    __publicField2(this, "multiline");
    __publicField2(this, "dynamicPrompts");
  }
}
__decorateClass([
  Type(() => Boolean)
], StringInputSpec.prototype, "multiline", 2);
__decorateClass([
  Type(() => Boolean)
], StringInputSpec.prototype, "dynamicPrompts", 2);
class ComboInputSpec extends BaseInputSpec {
  constructor() {
    super(...arguments);
    __publicField2(this, "type", "COMBO");
    __publicField2(this, "comboOptions");
    __publicField2(this, "controlAfterGenerate");
    __publicField2(this, "imageUpload");
  }
}
__decorateClass([
  Transform(({ value: value3 }) => value3[0])
], ComboInputSpec.prototype, "comboOptions", 2);
__decorateClass([
  Type(() => Boolean)
], ComboInputSpec.prototype, "controlAfterGenerate", 2);
__decorateClass([
  Type(() => Boolean)
], ComboInputSpec.prototype, "imageUpload", 2);
class CustomInputSpec extends BaseInputSpec {
}
const _ComfyInputsSpec = class _ComfyInputsSpec2 {
  constructor() {
    __publicField2(this, "required", {});
    __publicField2(this, "optional", {});
    __publicField2(this, "hidden");
  }
  static transformInputSpecRecord(record) {
    if (!record) return record;
    const result = {};
    for (const [key, value3] of Object.entries(record)) {
      result[key] = _ComfyInputsSpec2.transformSingleInputSpec(key, value3);
    }
    return result;
  }
  static transformSingleInputSpec(name, value3) {
    var _a2;
    if (!BaseInputSpec.isInputSpec(value3)) return value3;
    const [typeRaw, spec] = value3;
    const type = Array.isArray(typeRaw) ? "COMBO" : value3[0];
    switch (type) {
      case "INT":
        return plainToClass(IntInputSpec, __spreadValues2({ name, type }, spec));
      case "FLOAT":
        return plainToClass(FloatInputSpec, __spreadValues2({ name, type }, spec));
      case "BOOLEAN":
        return plainToClass(BooleanInputSpec, __spreadValues2({ name, type }, spec));
      case "STRING":
        return plainToClass(StringInputSpec, __spreadValues2({ name, type }, spec));
      case "COMBO":
        return plainToClass(ComboInputSpec, __spreadProps2(__spreadValues2({
          name,
          type
        }, spec), {
          comboOptions: typeRaw,
          default: (_a2 = spec.default) != null ? _a2 : typeRaw[0]
        }));
      default:
        return plainToClass(CustomInputSpec, __spreadValues2({ name, type }, spec));
    }
  }
  get all() {
    return [...Object.values(this.required), ...Object.values(this.optional)];
  }
  getInput(name) {
    var _a2;
    return (_a2 = this.required[name]) != null ? _a2 : this.optional[name];
  }
};
__decorateClass([
  Transform(({ value: value3 }) => _ComfyInputsSpec.transformInputSpecRecord(value3))
], _ComfyInputsSpec.prototype, "required", 2);
__decorateClass([
  Transform(({ value: value3 }) => _ComfyInputsSpec.transformInputSpecRecord(value3))
], _ComfyInputsSpec.prototype, "optional", 2);
let ComfyInputsSpec = _ComfyInputsSpec;
class ComfyOutputSpec {
  constructor(index2, name, type, is_list, comboOptions, tooltip) {
    this.index = index2;
    this.name = name;
    this.type = type;
    this.is_list = is_list;
    this.comboOptions = comboOptions;
    this.tooltip = tooltip;
  }
}
class ComfyOutputsSpec {
  constructor(outputs) {
    this.outputs = outputs;
  }
  get all() {
    return this.outputs;
  }
}
const _ComfyNodeDefImpl = class _ComfyNodeDefImpl2 {
  constructor() {
    __publicField2(this, "name");
    __publicField2(this, "display_name");
    __publicField2(this, "category");
    __publicField2(this, "python_module");
    __publicField2(this, "description");
    __publicField2(this, "input");
    __publicField2(this, "output");
  }
  static transformOutputSpec(obj) {
    const { output, output_is_list, output_name, output_tooltips } = obj;
    const result = output.map((type, index2) => {
      const typeString = Array.isArray(type) ? "COMBO" : type;
      return new ComfyOutputSpec(
        index2,
        output_name[index2],
        typeString,
        output_is_list[index2],
        Array.isArray(type) ? type : void 0,
        output_tooltips == null ? void 0 : output_tooltips[index2]
      );
    });
    return new ComfyOutputsSpec(result);
  }
};
__decorateClass([
  Type(() => ComfyInputsSpec)
], _ComfyNodeDefImpl.prototype, "input", 2);
__decorateClass([
  Transform(({ obj }) => _ComfyNodeDefImpl.transformOutputSpec(obj))
], _ComfyNodeDefImpl.prototype, "output", 2);
let ComfyNodeDefImpl = _ComfyNodeDefImpl;
const SYSTEM_NODE_DEFS = [
  {
    name: "PrimitiveNode",
    display_name: "Primitive",
    category: "utils",
    input: { required: {}, optional: {} },
    output: ["*"],
    output_name: ["connect to widget input"],
    output_is_list: [false],
    python_module: "nodes",
    description: "Primitive values like numbers, strings, and booleans."
  },
  {
    name: "Reroute",
    display_name: "Reroute",
    category: "utils",
    input: { required: { "": ["*"] }, optional: {} },
    output: ["*"],
    output_name: [""],
    output_is_list: [false],
    python_module: "nodes",
    description: "Reroute the connection to another node."
  },
  {
    name: "Note",
    display_name: "Note",
    category: "utils",
    input: { required: {}, optional: {} },
    output: [],
    output_name: [],
    output_is_list: [],
    python_module: "nodes",
    description: "Node that add notes to your project"
  }
];
function sortedTree(node3) {
  const newNode = __spreadValues2({}, node3);
  if (node3.children) {
    const sortedChildren = [...node3.children].sort(
      (a, b) => a.label.localeCompare(b.label)
    );
    newNode.children = [];
    for (const child of sortedChildren) {
      newNode.children.push(sortedTree(child));
    }
  }
  return newNode;
}
const useNodeDefStore = defineStore("nodeDef", {
  state: () => ({
    nodeDefsByName: {},
    widgets: {}
  }),
  getters: {
    nodeDefs(state) {
      return Object.values(state.nodeDefsByName);
    },
    nodeSearchService(state) {
      return new NodeSearchService(Object.values(state.nodeDefsByName));
    },
    nodeTree() {
      return buildTree(this.nodeDefs, (nodeDef) => [
        ...nodeDef.category.split("/"),
        nodeDef.display_name
      ]);
    },
    sortedNodeTree() {
      return sortedTree(this.nodeTree);
    }
  },
  actions: {
    updateNodeDefs(nodeDefs) {
      const newNodeDefsByName = {};
      for (const nodeDef of nodeDefs) {
        newNodeDefsByName[nodeDef.name] = plainToClass(
          ComfyNodeDefImpl,
          nodeDef
        );
      }
      this.nodeDefsByName = newNodeDefsByName;
    },
    updateWidgets(widgets) {
      this.widgets = widgets;
    },
    getWidgetType(type, inputName) {
      if (type === "COMBO") {
        return "COMBO";
      } else if (`${type}:${inputName}` in this.widgets) {
        return `${type}:${inputName}`;
      } else if (type in this.widgets) {
        return type;
      } else {
        return null;
      }
    },
    inputIsWidget(spec) {
      return this.getWidgetType(spec.type, spec.name) !== null;
    }
  }
});
const useDialogStore = defineStore("dialog", {
  state: () => ({
    isVisible: false,
    title: "",
    headerComponent: null,
    component: null,
    props: {}
  }),
  actions: {
    showDialog(options3) {
      this.title = options3.title;
      this.headerComponent = markRaw(options3.headerComponent);
      this.component = markRaw(options3.component);
      this.props = options3.props || {};
      this.isVisible = true;
    },
    closeDialog() {
      this.isVisible = false;
    }
  }
});
var script$12 = {
  name: "BlankIcon",
  "extends": script$15
};
var _hoisted_1$11 = /* @__PURE__ */ createBaseVNode("rect", {
  width: "1",
  height: "1",
  fill: "currentColor",
  "fill-opacity": "0"
}, null, -1);
var _hoisted_2$Q = [_hoisted_1$11];
function render$11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$Q, 16);
}
script$12.render = render$11;
var script$11 = {
  name: "CheckIcon",
  "extends": script$15
};
var _hoisted_1$10 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M4.86199 11.5948C4.78717 11.5923 4.71366 11.5745 4.64596 11.5426C4.57826 11.5107 4.51779 11.4652 4.46827 11.4091L0.753985 7.69483C0.683167 7.64891 0.623706 7.58751 0.580092 7.51525C0.536478 7.44299 0.509851 7.36177 0.502221 7.27771C0.49459 7.19366 0.506156 7.10897 0.536046 7.03004C0.565935 6.95111 0.613367 6.88 0.674759 6.82208C0.736151 6.76416 0.8099 6.72095 0.890436 6.69571C0.970973 6.67046 1.05619 6.66385 1.13966 6.67635C1.22313 6.68886 1.30266 6.72017 1.37226 6.76792C1.44186 6.81567 1.4997 6.8786 1.54141 6.95197L4.86199 10.2503L12.6397 2.49483C12.7444 2.42694 12.8689 2.39617 12.9932 2.40745C13.1174 2.41873 13.2343 2.47141 13.3251 2.55705C13.4159 2.64268 13.4753 2.75632 13.4938 2.87973C13.5123 3.00315 13.4888 3.1292 13.4271 3.23768L5.2557 11.4091C5.20618 11.4652 5.14571 11.5107 5.07801 11.5426C5.01031 11.5745 4.9368 11.5923 4.86199 11.5948Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$P = [_hoisted_1$10];
function render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$P, 16);
}
script$11.render = render$10;
var script$10 = {
  name: "SearchIcon",
  "extends": script$15
};
var _hoisted_1$$ = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M2.67602 11.0265C3.6661 11.688 4.83011 12.0411 6.02086 12.0411C6.81149 12.0411 7.59438 11.8854 8.32483 11.5828C8.87005 11.357 9.37808 11.0526 9.83317 10.6803L12.9769 13.8241C13.0323 13.8801 13.0983 13.9245 13.171 13.9548C13.2438 13.985 13.3219 14.0003 13.4007 14C13.4795 14.0003 13.5575 13.985 13.6303 13.9548C13.7031 13.9245 13.7691 13.8801 13.8244 13.8241C13.9367 13.7116 13.9998 13.5592 13.9998 13.4003C13.9998 13.2414 13.9367 13.089 13.8244 12.9765L10.6807 9.8328C11.053 9.37773 11.3573 8.86972 11.5831 8.32452C11.8857 7.59408 12.0414 6.81119 12.0414 6.02056C12.0414 4.8298 11.6883 3.66579 11.0268 2.67572C10.3652 1.68564 9.42494 0.913972 8.32483 0.45829C7.22472 0.00260857 6.01418 -0.116618 4.84631 0.115686C3.67844 0.34799 2.60568 0.921393 1.76369 1.76338C0.921698 2.60537 0.348296 3.67813 0.115991 4.84601C-0.116313 6.01388 0.00291375 7.22441 0.458595 8.32452C0.914277 9.42464 1.68595 10.3649 2.67602 11.0265ZM3.35565 2.0158C4.14456 1.48867 5.07206 1.20731 6.02086 1.20731C7.29317 1.20731 8.51338 1.71274 9.41304 2.6124C10.3127 3.51206 10.8181 4.73226 10.8181 6.00457C10.8181 6.95337 10.5368 7.88088 10.0096 8.66978C9.48251 9.45868 8.73328 10.0736 7.85669 10.4367C6.98011 10.7997 6.01554 10.8947 5.08496 10.7096C4.15439 10.5245 3.2996 10.0676 2.62869 9.39674C1.95778 8.72583 1.50089 7.87104 1.31579 6.94046C1.13068 6.00989 1.22568 5.04532 1.58878 4.16874C1.95187 3.29215 2.56675 2.54292 3.35565 2.0158Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$O = [_hoisted_1$$];
function render$$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$O, 16);
}
script$10.render = render$$;
var theme$p = function theme10(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-iconfield {\n    position: relative;\n}\n\n.p-inputicon {\n    position: absolute;\n    top: 50%;\n    margin-top: calc(-1 * (".concat(dt3("icon.size"), " / 2));\n    color: ").concat(dt3("iconfield.icon.color"), ";\n}\n\n.p-iconfield .p-inputicon:first-child {\n    left: ").concat(dt3("form.field.padding.x"), ";\n}\n\n.p-iconfield .p-inputicon:last-child {\n    right: ").concat(dt3("form.field.padding.x"), ";\n}\n\n.p-iconfield .p-inputtext:last-child {\n    padding-left: calc((").concat(dt3("form.field.padding.x"), " * 2) + ").concat(dt3("icon.size"), ");\n}\n\n.p-iconfield .p-inputtext:first-child {\n    padding-right: calc((").concat(dt3("form.field.padding.x"), " * 2) + ").concat(dt3("icon.size"), ");\n}\n");
};
var classes$s = {
  root: "p-iconfield"
};
var IconFieldStyle = BaseStyle.extend({
  name: "iconfield",
  theme: theme$p,
  classes: classes$s
});
var script$1$u = {
  name: "BaseIconField",
  "extends": script$1a,
  style: IconFieldStyle,
  provide: function provide8() {
    return {
      $pcIconField: this,
      $parentInstance: this
    };
  }
};
var script$$ = {
  name: "IconField",
  "extends": script$1$u,
  inheritAttrs: false
};
function render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
script$$.render = render$_;
var classes$r = {
  root: "p-inputicon"
};
var InputIconStyle = BaseStyle.extend({
  name: "inputicon",
  classes: classes$r
});
var script$1$t = {
  name: "BaseInputIcon",
  "extends": script$1a,
  style: InputIconStyle,
  props: {
    "class": null
  },
  provide: function provide9() {
    return {
      $pcInputIcon: this,
      $parentInstance: this
    };
  }
};
var script$_ = {
  name: "InputIcon",
  "extends": script$1$t,
  inheritAttrs: false,
  computed: {
    containerClass: function containerClass() {
      return [this.cx("root"), this["class"]];
    }
  }
};
function render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": $options.containerClass
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
script$_.render = render$Z;
var theme$o = function theme11(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-inputtext {\n    font-family: inherit;\n    font-feature-settings: inherit;\n    font-size: 1rem;\n    color: ".concat(dt3("inputtext.color"), ";\n    background: ").concat(dt3("inputtext.background"), ";\n    padding: ").concat(dt3("inputtext.padding.y"), " ").concat(dt3("inputtext.padding.x"), ";\n    border: 1px solid ").concat(dt3("inputtext.border.color"), ";\n    transition: background ").concat(dt3("inputtext.transition.duration"), ", color ").concat(dt3("inputtext.transition.duration"), ", border-color ").concat(dt3("inputtext.transition.duration"), ", outline-color ").concat(dt3("inputtext.transition.duration"), ", box-shadow ").concat(dt3("inputtext.transition.duration"), ";\n    appearance: none;\n    border-radius: ").concat(dt3("inputtext.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("inputtext.shadow"), ";\n}\n\n.p-inputtext:enabled:hover {\n    border-color: ").concat(dt3("inputtext.hover.border.color"), ";\n}\n\n.p-inputtext:enabled:focus {\n    border-color: ").concat(dt3("inputtext.focus.border.color"), ";\n    box-shadow: ").concat(dt3("inputtext.focus.ring.shadow"), ";\n    outline: ").concat(dt3("inputtext.focus.ring.width"), " ").concat(dt3("inputtext.focus.ring.style"), " ").concat(dt3("inputtext.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("inputtext.focus.ring.offset"), ";\n}\n\n.p-inputtext.p-invalid {\n    border-color: ").concat(dt3("inputtext.invalid.border.color"), ";\n}\n\n.p-inputtext.p-variant-filled {\n    background: ").concat(dt3("inputtext.filled.background"), ";\n}\n\n.p-inputtext.p-variant-filled:enabled:focus {\n    background: ").concat(dt3("inputtext.filled.focus.background"), ";\n}\n\n.p-inputtext:disabled {\n    opacity: 1;\n    background: ").concat(dt3("inputtext.disabled.background"), ";\n    color: ").concat(dt3("inputtext.disabled.color"), ";\n}\n\n.p-inputtext::placeholder {\n    color: ").concat(dt3("inputtext.placeholder.color"), ";\n}\n\n.p-inputtext-sm {\n    font-size: ").concat(dt3("inputtext.sm.font.size"), ";\n    padding: ").concat(dt3("inputtext.sm.padding.y"), " ").concat(dt3("inputtext.sm.padding.x"), ";\n}\n\n.p-inputtext-lg {\n    font-size: ").concat(dt3("inputtext.lg.font.size"), ";\n    padding: ").concat(dt3("inputtext.lg.padding.y"), " ").concat(dt3("inputtext.lg.padding.x"), ";\n}\n\n.p-inputtext-fluid {\n    width: 100%;\n}\n");
};
var classes$q = {
  root: function root3(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-inputtext p-component", {
      "p-filled": instance.filled,
      "p-inputtext-sm": props.size === "small",
      "p-inputtext-lg": props.size === "large",
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled",
      "p-inputtext-fluid": props.fluid
    }];
  }
};
var InputTextStyle = BaseStyle.extend({
  name: "inputtext",
  theme: theme$o,
  classes: classes$q
});
var script$1$s = {
  name: "BaseInputText",
  "extends": script$1a,
  props: {
    modelValue: null,
    size: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    fluid: {
      type: Boolean,
      "default": false
    }
  },
  style: InputTextStyle,
  provide: function provide10() {
    return {
      $pcInputText: this,
      $parentInstance: this
    };
  }
};
var script$Z = {
  name: "InputText",
  "extends": script$1$s,
  inheritAttrs: false,
  emits: ["update:modelValue"],
  methods: {
    getPTOptions: function getPTOptions2(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          filled: this.filled,
          disabled: this.$attrs.disabled || this.$attrs.disabled === ""
        }
      });
    },
    onInput: function onInput(event2) {
      this.$emit("update:modelValue", event2.target.value);
    }
  },
  computed: {
    filled: function filled() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    }
  }
};
var _hoisted_1$_ = ["value", "aria-invalid"];
function render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("input", mergeProps({
    type: "text",
    "class": _ctx.cx("root"),
    value: _ctx.modelValue,
    "aria-invalid": _ctx.invalid || void 0,
    onInput: _cache[0] || (_cache[0] = function() {
      return $options.onInput && $options.onInput.apply($options, arguments);
    })
  }, $options.getPTOptions("root")), null, 16, _hoisted_1$_);
}
script$Z.render = render$Y;
var theme$n = function theme12(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-virtualscroller {\n    position: relative;\n    overflow: auto;\n    contain: strict;\n    transform: translateZ(0);\n    will-change: scroll-position;\n    outline: 0 none;\n}\n\n.p-virtualscroller-content {\n    position: absolute;\n    top: 0;\n    left: 0;\n    min-height: 100%;\n    min-width: 100%;\n    will-change: transform;\n}\n\n.p-virtualscroller-spacer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 1px;\n    width: 1px;\n    transform-origin: 0 0;\n    pointer-events: none;\n}\n\n.p-virtualscroller-loader {\n    position: sticky;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: ".concat(dt3("virtualscroller.loader.mask.background"), ";\n    color: ").concat(dt3("virtualscroller.loader.mask.color"), ";\n}\n\n.p-virtualscroller-loader-mask {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-virtualscroller-loading-icon {\n    font-size: ").concat(dt3("virtualscroller.loader.icon.size"), ";\n    width: ").concat(dt3("virtualscroller.loader.icon.size"), ";\n    height: ").concat(dt3("virtualscroller.loader.icon.size"), ";\n}\n\n.p-virtualscroller-horizontal > .p-virtualscroller-content {\n    display: flex;\n}\n\n.p-virtualscroller-inline .p-virtualscroller-content {\n    position: static;\n}\n");
};
var VirtualScrollerStyle = BaseStyle.extend({
  name: "virtualscroller",
  theme: theme$n
});
var script$1$r = {
  name: "BaseVirtualScroller",
  "extends": script$1a,
  props: {
    id: {
      type: String,
      "default": null
    },
    style: null,
    "class": null,
    items: {
      type: Array,
      "default": null
    },
    itemSize: {
      type: [Number, Array],
      "default": 0
    },
    scrollHeight: null,
    scrollWidth: null,
    orientation: {
      type: String,
      "default": "vertical"
    },
    numToleratedItems: {
      type: Number,
      "default": null
    },
    delay: {
      type: Number,
      "default": 0
    },
    resizeDelay: {
      type: Number,
      "default": 10
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    loaderDisabled: {
      type: Boolean,
      "default": false
    },
    columns: {
      type: Array,
      "default": null
    },
    loading: {
      type: Boolean,
      "default": false
    },
    showSpacer: {
      type: Boolean,
      "default": true
    },
    showLoader: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    inline: {
      type: Boolean,
      "default": false
    },
    step: {
      type: Number,
      "default": 0
    },
    appendOnly: {
      type: Boolean,
      "default": false
    },
    autoSize: {
      type: Boolean,
      "default": false
    }
  },
  style: VirtualScrollerStyle,
  provide: function provide11() {
    return {
      $pcVirtualScroller: this,
      $parentInstance: this
    };
  },
  beforeMount: function beforeMount3() {
    var _this$$primevueConfig;
    VirtualScrollerStyle.loadCSS({
      nonce: (_this$$primevueConfig = this.$primevueConfig) === null || _this$$primevueConfig === void 0 || (_this$$primevueConfig = _this$$primevueConfig.csp) === null || _this$$primevueConfig === void 0 ? void 0 : _this$$primevueConfig.nonce
    });
  }
};
function _typeof$k(o) {
  "@babel/helpers - typeof";
  return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$k(o);
}
function ownKeys$k(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$k(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$k(Object(t), true).forEach(function(r2) {
      _defineProperty$j(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$j(e, r, t) {
  return (r = _toPropertyKey$i(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$i(t) {
  var i2 = _toPrimitive$i(t, "string");
  return "symbol" == _typeof$k(i2) ? i2 : i2 + "";
}
function _toPrimitive$i(t, r) {
  if ("object" != _typeof$k(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$k(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var script$Y = {
  name: "VirtualScroller",
  "extends": script$1$r,
  inheritAttrs: false,
  emits: ["update:numToleratedItems", "scroll", "scroll-index-change", "lazy-load"],
  data: function data2() {
    var both = this.isBoth();
    return {
      first: both ? {
        rows: 0,
        cols: 0
      } : 0,
      last: both ? {
        rows: 0,
        cols: 0
      } : 0,
      page: both ? {
        rows: 0,
        cols: 0
      } : 0,
      numItemsInViewport: both ? {
        rows: 0,
        cols: 0
      } : 0,
      lastScrollPos: both ? {
        top: 0,
        left: 0
      } : 0,
      d_numToleratedItems: this.numToleratedItems,
      d_loading: this.loading,
      loaderArr: [],
      spacerStyle: {},
      contentStyle: {}
    };
  },
  element: null,
  content: null,
  lastScrollPos: null,
  scrollTimeout: null,
  resizeTimeout: null,
  defaultWidth: 0,
  defaultHeight: 0,
  defaultContentWidth: 0,
  defaultContentHeight: 0,
  isRangeChanged: false,
  lazyLoadState: {},
  resizeListener: null,
  initialized: false,
  watch: {
    numToleratedItems: function numToleratedItems(newValue) {
      this.d_numToleratedItems = newValue;
    },
    loading: function loading(newValue, oldValue) {
      if (this.lazy && newValue !== oldValue && newValue !== this.d_loading) {
        this.d_loading = newValue;
      }
    },
    items: function items(newValue, oldValue) {
      if (!oldValue || oldValue.length !== (newValue || []).length) {
        this.init();
        this.calculateAutoSize();
      }
    },
    itemSize: function itemSize() {
      this.init();
      this.calculateAutoSize();
    },
    orientation: function orientation() {
      this.lastScrollPos = this.isBoth() ? {
        top: 0,
        left: 0
      } : 0;
    },
    scrollHeight: function scrollHeight() {
      this.init();
      this.calculateAutoSize();
    },
    scrollWidth: function scrollWidth() {
      this.init();
      this.calculateAutoSize();
    }
  },
  mounted: function mounted3() {
    this.viewInit();
    this.lastScrollPos = this.isBoth() ? {
      top: 0,
      left: 0
    } : 0;
    this.lazyLoadState = this.lazyLoadState || {};
  },
  updated: function updated3() {
    !this.initialized && this.viewInit();
  },
  unmounted: function unmounted4() {
    this.unbindResizeListener();
    this.initialized = false;
  },
  methods: {
    viewInit: function viewInit() {
      if (isVisible(this.element)) {
        this.setContentEl(this.content);
        this.init();
        this.calculateAutoSize();
        this.bindResizeListener();
        this.defaultWidth = getWidth(this.element);
        this.defaultHeight = getHeight(this.element);
        this.defaultContentWidth = getWidth(this.content);
        this.defaultContentHeight = getHeight(this.content);
        this.initialized = true;
      }
    },
    init: function init() {
      if (!this.disabled) {
        this.setSize();
        this.calculateOptions();
        this.setSpacerSize();
      }
    },
    isVertical: function isVertical() {
      return this.orientation === "vertical";
    },
    isHorizontal: function isHorizontal() {
      return this.orientation === "horizontal";
    },
    isBoth: function isBoth() {
      return this.orientation === "both";
    },
    scrollTo: function scrollTo(options3) {
      this.element && this.element.scrollTo(options3);
    },
    scrollToIndex: function scrollToIndex(index2) {
      var _this = this;
      var behavior = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "auto";
      var both = this.isBoth();
      var horizontal3 = this.isHorizontal();
      var valid = both ? index2.every(function(i2) {
        return i2 > -1;
      }) : index2 > -1;
      if (valid) {
        var first4 = this.first;
        var _this$element = this.element, _this$element$scrollT = _this$element.scrollTop, scrollTop = _this$element$scrollT === void 0 ? 0 : _this$element$scrollT, _this$element$scrollL = _this$element.scrollLeft, scrollLeft = _this$element$scrollL === void 0 ? 0 : _this$element$scrollL;
        var _this$calculateNumIte = this.calculateNumItems(), numToleratedItems2 = _this$calculateNumIte.numToleratedItems;
        var contentPos = this.getContentPosition();
        var itemSize2 = this.itemSize;
        var calculateFirst = function calculateFirst2() {
          var _index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var _numT = arguments.length > 1 ? arguments[1] : void 0;
          return _index <= _numT ? 0 : _index;
        };
        var calculateCoord = function calculateCoord2(_first2, _size, _cpos) {
          return _first2 * _size + _cpos;
        };
        var scrollTo2 = function scrollTo3() {
          var left = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return _this.scrollTo({
            left,
            top,
            behavior
          });
        };
        var newFirst = both ? {
          rows: 0,
          cols: 0
        } : 0;
        var isRangeChanged = false, isScrollChanged = false;
        if (both) {
          newFirst = {
            rows: calculateFirst(index2[0], numToleratedItems2[0]),
            cols: calculateFirst(index2[1], numToleratedItems2[1])
          };
          scrollTo2(calculateCoord(newFirst.cols, itemSize2[1], contentPos.left), calculateCoord(newFirst.rows, itemSize2[0], contentPos.top));
          isScrollChanged = this.lastScrollPos.top !== scrollTop || this.lastScrollPos.left !== scrollLeft;
          isRangeChanged = newFirst.rows !== first4.rows || newFirst.cols !== first4.cols;
        } else {
          newFirst = calculateFirst(index2, numToleratedItems2);
          horizontal3 ? scrollTo2(calculateCoord(newFirst, itemSize2, contentPos.left), scrollTop) : scrollTo2(scrollLeft, calculateCoord(newFirst, itemSize2, contentPos.top));
          isScrollChanged = this.lastScrollPos !== (horizontal3 ? scrollLeft : scrollTop);
          isRangeChanged = newFirst !== first4;
        }
        this.isRangeChanged = isRangeChanged;
        isScrollChanged && (this.first = newFirst);
      }
    },
    scrollInView: function scrollInView2(index2, to) {
      var _this2 = this;
      var behavior = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "auto";
      if (to) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var valid = both ? index2.every(function(i2) {
          return i2 > -1;
        }) : index2 > -1;
        if (valid) {
          var _this$getRenderedRang = this.getRenderedRange(), first4 = _this$getRenderedRang.first, viewport = _this$getRenderedRang.viewport;
          var scrollTo2 = function scrollTo3() {
            var left = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return _this2.scrollTo({
              left,
              top,
              behavior
            });
          };
          var isToStart = to === "to-start";
          var isToEnd = to === "to-end";
          if (isToStart) {
            if (both) {
              if (viewport.first.rows - first4.rows > index2[0]) {
                scrollTo2(viewport.first.cols * this.itemSize[1], (viewport.first.rows - 1) * this.itemSize[0]);
              } else if (viewport.first.cols - first4.cols > index2[1]) {
                scrollTo2((viewport.first.cols - 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);
              }
            } else {
              if (viewport.first - first4 > index2) {
                var pos2 = (viewport.first - 1) * this.itemSize;
                horizontal3 ? scrollTo2(pos2, 0) : scrollTo2(0, pos2);
              }
            }
          } else if (isToEnd) {
            if (both) {
              if (viewport.last.rows - first4.rows <= index2[0] + 1) {
                scrollTo2(viewport.first.cols * this.itemSize[1], (viewport.first.rows + 1) * this.itemSize[0]);
              } else if (viewport.last.cols - first4.cols <= index2[1] + 1) {
                scrollTo2((viewport.first.cols + 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);
              }
            } else {
              if (viewport.last - first4 <= index2 + 1) {
                var _pos2 = (viewport.first + 1) * this.itemSize;
                horizontal3 ? scrollTo2(_pos2, 0) : scrollTo2(0, _pos2);
              }
            }
          }
        }
      } else {
        this.scrollToIndex(index2, behavior);
      }
    },
    getRenderedRange: function getRenderedRange() {
      var calculateFirstInViewport = function calculateFirstInViewport2(_pos, _size) {
        return Math.floor(_pos / (_size || _pos));
      };
      var firstInViewport = this.first;
      var lastInViewport = 0;
      if (this.element) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var _this$element2 = this.element, scrollTop = _this$element2.scrollTop, scrollLeft = _this$element2.scrollLeft;
        if (both) {
          firstInViewport = {
            rows: calculateFirstInViewport(scrollTop, this.itemSize[0]),
            cols: calculateFirstInViewport(scrollLeft, this.itemSize[1])
          };
          lastInViewport = {
            rows: firstInViewport.rows + this.numItemsInViewport.rows,
            cols: firstInViewport.cols + this.numItemsInViewport.cols
          };
        } else {
          var scrollPos = horizontal3 ? scrollLeft : scrollTop;
          firstInViewport = calculateFirstInViewport(scrollPos, this.itemSize);
          lastInViewport = firstInViewport + this.numItemsInViewport;
        }
      }
      return {
        first: this.first,
        last: this.last,
        viewport: {
          first: firstInViewport,
          last: lastInViewport
        }
      };
    },
    calculateNumItems: function calculateNumItems() {
      var both = this.isBoth();
      var horizontal3 = this.isHorizontal();
      var itemSize2 = this.itemSize;
      var contentPos = this.getContentPosition();
      var contentWidth = this.element ? this.element.offsetWidth - contentPos.left : 0;
      var contentHeight = this.element ? this.element.offsetHeight - contentPos.top : 0;
      var calculateNumItemsInViewport = function calculateNumItemsInViewport2(_contentSize, _itemSize) {
        return Math.ceil(_contentSize / (_itemSize || _contentSize));
      };
      var calculateNumToleratedItems = function calculateNumToleratedItems2(_numItems) {
        return Math.ceil(_numItems / 2);
      };
      var numItemsInViewport = both ? {
        rows: calculateNumItemsInViewport(contentHeight, itemSize2[0]),
        cols: calculateNumItemsInViewport(contentWidth, itemSize2[1])
      } : calculateNumItemsInViewport(horizontal3 ? contentWidth : contentHeight, itemSize2);
      var numToleratedItems2 = this.d_numToleratedItems || (both ? [calculateNumToleratedItems(numItemsInViewport.rows), calculateNumToleratedItems(numItemsInViewport.cols)] : calculateNumToleratedItems(numItemsInViewport));
      return {
        numItemsInViewport,
        numToleratedItems: numToleratedItems2
      };
    },
    calculateOptions: function calculateOptions() {
      var _this3 = this;
      var both = this.isBoth();
      var first4 = this.first;
      var _this$calculateNumIte2 = this.calculateNumItems(), numItemsInViewport = _this$calculateNumIte2.numItemsInViewport, numToleratedItems2 = _this$calculateNumIte2.numToleratedItems;
      var calculateLast = function calculateLast2(_first2, _num, _numT) {
        var _isCols = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        return _this3.getLast(_first2 + _num + (_first2 < _numT ? 2 : 3) * _numT, _isCols);
      };
      var last2 = both ? {
        rows: calculateLast(first4.rows, numItemsInViewport.rows, numToleratedItems2[0]),
        cols: calculateLast(first4.cols, numItemsInViewport.cols, numToleratedItems2[1], true)
      } : calculateLast(first4, numItemsInViewport, numToleratedItems2);
      this.last = last2;
      this.numItemsInViewport = numItemsInViewport;
      this.d_numToleratedItems = numToleratedItems2;
      this.$emit("update:numToleratedItems", this.d_numToleratedItems);
      if (this.showLoader) {
        this.loaderArr = both ? Array.from({
          length: numItemsInViewport.rows
        }).map(function() {
          return Array.from({
            length: numItemsInViewport.cols
          });
        }) : Array.from({
          length: numItemsInViewport
        });
      }
      if (this.lazy) {
        Promise.resolve().then(function() {
          var _this3$items;
          _this3.lazyLoadState = {
            first: _this3.step ? both ? {
              rows: 0,
              cols: first4.cols
            } : 0 : first4,
            last: Math.min(_this3.step ? _this3.step : last2, ((_this3$items = _this3.items) === null || _this3$items === void 0 ? void 0 : _this3$items.length) || 0)
          };
          _this3.$emit("lazy-load", _this3.lazyLoadState);
        });
      }
    },
    calculateAutoSize: function calculateAutoSize() {
      var _this4 = this;
      if (this.autoSize && !this.d_loading) {
        Promise.resolve().then(function() {
          if (_this4.content) {
            var both = _this4.isBoth();
            var horizontal3 = _this4.isHorizontal();
            var vertical2 = _this4.isVertical();
            _this4.content.style.minHeight = _this4.content.style.minWidth = "auto";
            _this4.content.style.position = "relative";
            _this4.element.style.contain = "none";
            var _ref = [getWidth(_this4.element), getHeight(_this4.element)], width2 = _ref[0], height = _ref[1];
            (both || horizontal3) && (_this4.element.style.width = width2 < _this4.defaultWidth ? width2 + "px" : _this4.scrollWidth || _this4.defaultWidth + "px");
            (both || vertical2) && (_this4.element.style.height = height < _this4.defaultHeight ? height + "px" : _this4.scrollHeight || _this4.defaultHeight + "px");
            _this4.content.style.minHeight = _this4.content.style.minWidth = "";
            _this4.content.style.position = "";
            _this4.element.style.contain = "";
          }
        });
      }
    },
    getLast: function getLast() {
      var _ref2, _this$items;
      var last2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var isCols = arguments.length > 1 ? arguments[1] : void 0;
      return this.items ? Math.min(isCols ? ((_ref2 = this.columns || this.items[0]) === null || _ref2 === void 0 ? void 0 : _ref2.length) || 0 : ((_this$items = this.items) === null || _this$items === void 0 ? void 0 : _this$items.length) || 0, last2) : 0;
    },
    getContentPosition: function getContentPosition() {
      if (this.content) {
        var style = getComputedStyle(this.content);
        var left = parseFloat(style.paddingLeft) + Math.max(parseFloat(style.left) || 0, 0);
        var right = parseFloat(style.paddingRight) + Math.max(parseFloat(style.right) || 0, 0);
        var top = parseFloat(style.paddingTop) + Math.max(parseFloat(style.top) || 0, 0);
        var bottom = parseFloat(style.paddingBottom) + Math.max(parseFloat(style.bottom) || 0, 0);
        return {
          left,
          right,
          top,
          bottom,
          x: left + right,
          y: top + bottom
        };
      }
      return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        x: 0,
        y: 0
      };
    },
    setSize: function setSize() {
      var _this5 = this;
      if (this.element) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var parentElement = this.element.parentElement;
        var width2 = this.scrollWidth || "".concat(this.element.offsetWidth || parentElement.offsetWidth, "px");
        var height = this.scrollHeight || "".concat(this.element.offsetHeight || parentElement.offsetHeight, "px");
        var setProp = function setProp2(_name2, _value) {
          return _this5.element.style[_name2] = _value;
        };
        if (both || horizontal3) {
          setProp("height", height);
          setProp("width", width2);
        } else {
          setProp("height", height);
        }
      }
    },
    setSpacerSize: function setSpacerSize() {
      var _this6 = this;
      var items2 = this.items;
      if (items2) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var contentPos = this.getContentPosition();
        var setProp = function setProp2(_name2, _value, _size) {
          var _cpos = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          return _this6.spacerStyle = _objectSpread$k(_objectSpread$k({}, _this6.spacerStyle), _defineProperty$j({}, "".concat(_name2), (_value || []).length * _size + _cpos + "px"));
        };
        if (both) {
          setProp("height", items2, this.itemSize[0], contentPos.y);
          setProp("width", this.columns || items2[1], this.itemSize[1], contentPos.x);
        } else {
          horizontal3 ? setProp("width", this.columns || items2, this.itemSize, contentPos.x) : setProp("height", items2, this.itemSize, contentPos.y);
        }
      }
    },
    setContentPosition: function setContentPosition(pos2) {
      var _this7 = this;
      if (this.content && !this.appendOnly) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        var first4 = pos2 ? pos2.first : this.first;
        var calculateTranslateVal = function calculateTranslateVal2(_first2, _size) {
          return _first2 * _size;
        };
        var setTransform = function setTransform2() {
          var _x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var _y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return _this7.contentStyle = _objectSpread$k(_objectSpread$k({}, _this7.contentStyle), {
            transform: "translate3d(".concat(_x, "px, ").concat(_y, "px, 0)")
          });
        };
        if (both) {
          setTransform(calculateTranslateVal(first4.cols, this.itemSize[1]), calculateTranslateVal(first4.rows, this.itemSize[0]));
        } else {
          var translateVal = calculateTranslateVal(first4, this.itemSize);
          horizontal3 ? setTransform(translateVal, 0) : setTransform(0, translateVal);
        }
      }
    },
    onScrollPositionChange: function onScrollPositionChange(event2) {
      var _this8 = this;
      var target = event2.target;
      var both = this.isBoth();
      var horizontal3 = this.isHorizontal();
      var contentPos = this.getContentPosition();
      var calculateScrollPos = function calculateScrollPos2(_pos, _cpos) {
        return _pos ? _pos > _cpos ? _pos - _cpos : _pos : 0;
      };
      var calculateCurrentIndex = function calculateCurrentIndex2(_pos, _size) {
        return Math.floor(_pos / (_size || _pos));
      };
      var calculateTriggerIndex = function calculateTriggerIndex2(_currentIndex, _first2, _last, _num, _numT, _isScrollDownOrRight) {
        return _currentIndex <= _numT ? _numT : _isScrollDownOrRight ? _last - _num - _numT : _first2 + _numT - 1;
      };
      var calculateFirst = function calculateFirst2(_currentIndex, _triggerIndex, _first2, _last, _num, _numT, _isScrollDownOrRight) {
        if (_currentIndex <= _numT) return 0;
        else return Math.max(0, _isScrollDownOrRight ? _currentIndex < _triggerIndex ? _first2 : _currentIndex - _numT : _currentIndex > _triggerIndex ? _first2 : _currentIndex - 2 * _numT);
      };
      var calculateLast = function calculateLast2(_currentIndex, _first2, _last, _num, _numT, _isCols) {
        var lastValue = _first2 + _num + 2 * _numT;
        if (_currentIndex >= _numT) {
          lastValue += _numT + 1;
        }
        return _this8.getLast(lastValue, _isCols);
      };
      var scrollTop = calculateScrollPos(target.scrollTop, contentPos.top);
      var scrollLeft = calculateScrollPos(target.scrollLeft, contentPos.left);
      var newFirst = both ? {
        rows: 0,
        cols: 0
      } : 0;
      var newLast = this.last;
      var isRangeChanged = false;
      var newScrollPos = this.lastScrollPos;
      if (both) {
        var isScrollDown = this.lastScrollPos.top <= scrollTop;
        var isScrollRight = this.lastScrollPos.left <= scrollLeft;
        if (!this.appendOnly || this.appendOnly && (isScrollDown || isScrollRight)) {
          var currentIndex = {
            rows: calculateCurrentIndex(scrollTop, this.itemSize[0]),
            cols: calculateCurrentIndex(scrollLeft, this.itemSize[1])
          };
          var triggerIndex = {
            rows: calculateTriggerIndex(currentIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),
            cols: calculateTriggerIndex(currentIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)
          };
          newFirst = {
            rows: calculateFirst(currentIndex.rows, triggerIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),
            cols: calculateFirst(currentIndex.cols, triggerIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)
          };
          newLast = {
            rows: calculateLast(currentIndex.rows, newFirst.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0]),
            cols: calculateLast(currentIndex.cols, newFirst.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], true)
          };
          isRangeChanged = newFirst.rows !== this.first.rows || newLast.rows !== this.last.rows || newFirst.cols !== this.first.cols || newLast.cols !== this.last.cols || this.isRangeChanged;
          newScrollPos = {
            top: scrollTop,
            left: scrollLeft
          };
        }
      } else {
        var scrollPos = horizontal3 ? scrollLeft : scrollTop;
        var isScrollDownOrRight = this.lastScrollPos <= scrollPos;
        if (!this.appendOnly || this.appendOnly && isScrollDownOrRight) {
          var _currentIndex2 = calculateCurrentIndex(scrollPos, this.itemSize);
          var _triggerIndex2 = calculateTriggerIndex(_currentIndex2, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);
          newFirst = calculateFirst(_currentIndex2, _triggerIndex2, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);
          newLast = calculateLast(_currentIndex2, newFirst, this.last, this.numItemsInViewport, this.d_numToleratedItems);
          isRangeChanged = newFirst !== this.first || newLast !== this.last || this.isRangeChanged;
          newScrollPos = scrollPos;
        }
      }
      return {
        first: newFirst,
        last: newLast,
        isRangeChanged,
        scrollPos: newScrollPos
      };
    },
    onScrollChange: function onScrollChange(event2) {
      var _this$onScrollPositio = this.onScrollPositionChange(event2), first4 = _this$onScrollPositio.first, last2 = _this$onScrollPositio.last, isRangeChanged = _this$onScrollPositio.isRangeChanged, scrollPos = _this$onScrollPositio.scrollPos;
      if (isRangeChanged) {
        var newState = {
          first: first4,
          last: last2
        };
        this.setContentPosition(newState);
        this.first = first4;
        this.last = last2;
        this.lastScrollPos = scrollPos;
        this.$emit("scroll-index-change", newState);
        if (this.lazy && this.isPageChanged(first4)) {
          var _this$items2, _this$items3;
          var lazyLoadState = {
            first: this.step ? Math.min(this.getPageByFirst(first4) * this.step, (((_this$items2 = this.items) === null || _this$items2 === void 0 ? void 0 : _this$items2.length) || 0) - this.step) : first4,
            last: Math.min(this.step ? (this.getPageByFirst(first4) + 1) * this.step : last2, ((_this$items3 = this.items) === null || _this$items3 === void 0 ? void 0 : _this$items3.length) || 0)
          };
          var isLazyStateChanged = this.lazyLoadState.first !== lazyLoadState.first || this.lazyLoadState.last !== lazyLoadState.last;
          isLazyStateChanged && this.$emit("lazy-load", lazyLoadState);
          this.lazyLoadState = lazyLoadState;
        }
      }
    },
    onScroll: function onScroll(event2) {
      var _this9 = this;
      this.$emit("scroll", event2);
      if (this.delay) {
        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }
        if (this.isPageChanged()) {
          if (!this.d_loading && this.showLoader) {
            var _this$onScrollPositio2 = this.onScrollPositionChange(event2), isRangeChanged = _this$onScrollPositio2.isRangeChanged;
            var changed = isRangeChanged || (this.step ? this.isPageChanged() : false);
            changed && (this.d_loading = true);
          }
          this.scrollTimeout = setTimeout(function() {
            _this9.onScrollChange(event2);
            if (_this9.d_loading && _this9.showLoader && (!_this9.lazy || _this9.loading === void 0)) {
              _this9.d_loading = false;
              _this9.page = _this9.getPageByFirst();
            }
          }, this.delay);
        }
      } else {
        this.onScrollChange(event2);
      }
    },
    onResize: function onResize() {
      var _this10 = this;
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }
      this.resizeTimeout = setTimeout(function() {
        if (isVisible(_this10.element)) {
          var both = _this10.isBoth();
          var vertical2 = _this10.isVertical();
          var horizontal3 = _this10.isHorizontal();
          var _ref3 = [getWidth(_this10.element), getHeight(_this10.element)], width2 = _ref3[0], height = _ref3[1];
          var isDiffWidth = width2 !== _this10.defaultWidth, isDiffHeight = height !== _this10.defaultHeight;
          var reinit = both ? isDiffWidth || isDiffHeight : horizontal3 ? isDiffWidth : vertical2 ? isDiffHeight : false;
          if (reinit) {
            _this10.d_numToleratedItems = _this10.numToleratedItems;
            _this10.defaultWidth = width2;
            _this10.defaultHeight = height;
            _this10.defaultContentWidth = getWidth(_this10.content);
            _this10.defaultContentHeight = getHeight(_this10.content);
            _this10.init();
          }
        }
      }, this.resizeDelay);
    },
    bindResizeListener: function bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = this.onResize.bind(this);
        window.addEventListener("resize", this.resizeListener);
        window.addEventListener("orientationchange", this.resizeListener);
      }
    },
    unbindResizeListener: function unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        window.removeEventListener("orientationchange", this.resizeListener);
        this.resizeListener = null;
      }
    },
    getOptions: function getOptions2(renderedIndex) {
      var count = (this.items || []).length;
      var index2 = this.isBoth() ? this.first.rows + renderedIndex : this.first + renderedIndex;
      return {
        index: index2,
        count,
        first: index2 === 0,
        last: index2 === count - 1,
        even: index2 % 2 === 0,
        odd: index2 % 2 !== 0
      };
    },
    getLoaderOptions: function getLoaderOptions(index2, extOptions) {
      var count = this.loaderArr.length;
      return _objectSpread$k({
        index: index2,
        count,
        first: index2 === 0,
        last: index2 === count - 1,
        even: index2 % 2 === 0,
        odd: index2 % 2 !== 0
      }, extOptions);
    },
    getPageByFirst: function getPageByFirst(first4) {
      return Math.floor(((first4 !== null && first4 !== void 0 ? first4 : this.first) + this.d_numToleratedItems * 4) / (this.step || 1));
    },
    isPageChanged: function isPageChanged(first4) {
      return this.step ? this.page !== this.getPageByFirst(first4 !== null && first4 !== void 0 ? first4 : this.first) : true;
    },
    setContentEl: function setContentEl(el) {
      this.content = el || this.content || findSingle(this.element, '[data-pc-section="content"]');
    },
    elementRef: function elementRef(el) {
      this.element = el;
    },
    contentRef: function contentRef(el) {
      this.content = el;
    }
  },
  computed: {
    containerClass: function containerClass2() {
      return ["p-virtualscroller", this["class"], {
        "p-virtualscroller-inline": this.inline,
        "p-virtualscroller-both p-both-scroll": this.isBoth(),
        "p-virtualscroller-horizontal p-horizontal-scroll": this.isHorizontal()
      }];
    },
    contentClass: function contentClass() {
      return ["p-virtualscroller-content", {
        "p-virtualscroller-loading": this.d_loading
      }];
    },
    loaderClass: function loaderClass() {
      return ["p-virtualscroller-loader", {
        "p-virtualscroller-loader-mask": !this.$slots.loader
      }];
    },
    loadedItems: function loadedItems() {
      var _this11 = this;
      if (this.items && !this.d_loading) {
        if (this.isBoth()) return this.items.slice(this.appendOnly ? 0 : this.first.rows, this.last.rows).map(function(item) {
          return _this11.columns ? item : item.slice(_this11.appendOnly ? 0 : _this11.first.cols, _this11.last.cols);
        });
        else if (this.isHorizontal() && this.columns) return this.items;
        else return this.items.slice(this.appendOnly ? 0 : this.first, this.last);
      }
      return [];
    },
    loadedRows: function loadedRows() {
      return this.d_loading ? this.loaderDisabled ? this.loaderArr : [] : this.loadedItems;
    },
    loadedColumns: function loadedColumns() {
      if (this.columns) {
        var both = this.isBoth();
        var horizontal3 = this.isHorizontal();
        if (both || horizontal3) {
          return this.d_loading && this.loaderDisabled ? both ? this.loaderArr[0] : this.loaderArr : this.columns.slice(both ? this.first.cols : this.first, both ? this.last.cols : this.last);
        }
      }
      return this.columns;
    }
  },
  components: {
    SpinnerIcon: script$14
  }
};
var _hoisted_1$Z = ["tabindex"];
function render$X(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  return !_ctx.disabled ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    ref: $options.elementRef,
    "class": $options.containerClass,
    tabindex: _ctx.tabindex,
    style: _ctx.style,
    onScroll: _cache[0] || (_cache[0] = function() {
      return $options.onScroll && $options.onScroll.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "content", {
    styleClass: $options.contentClass,
    items: $options.loadedItems,
    getItemOptions: $options.getOptions,
    loading: $data.d_loading,
    getLoaderOptions: $options.getLoaderOptions,
    itemSize: _ctx.itemSize,
    rows: $options.loadedRows,
    columns: $options.loadedColumns,
    contentRef: $options.contentRef,
    spacerStyle: $data.spacerStyle,
    contentStyle: $data.contentStyle,
    vertical: $options.isVertical(),
    horizontal: $options.isHorizontal(),
    both: $options.isBoth()
  }, function() {
    return [createBaseVNode("div", mergeProps({
      ref: $options.contentRef,
      "class": $options.contentClass,
      style: $data.contentStyle
    }, _ctx.ptm("content")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.loadedItems, function(item, index2) {
      return renderSlot(_ctx.$slots, "item", {
        key: index2,
        item,
        options: $options.getOptions(index2)
      });
    }), 128))], 16)];
  }), _ctx.showSpacer ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": "p-virtualscroller-spacer",
    style: $data.spacerStyle
  }, _ctx.ptm("spacer")), null, 16)) : createCommentVNode("", true), !_ctx.loaderDisabled && _ctx.showLoader && $data.d_loading ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": $options.loaderClass
  }, _ctx.ptm("loader")), [_ctx.$slots && _ctx.$slots.loader ? (openBlock(true), createElementBlock(Fragment, {
    key: 0
  }, renderList($data.loaderArr, function(_2, index2) {
    return renderSlot(_ctx.$slots, "loader", {
      key: index2,
      options: $options.getLoaderOptions(index2, $options.isBoth() && {
        numCols: _ctx.d_numItemsInViewport.cols
      })
    });
  }), 128)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "loadingicon", {}, function() {
    return [createVNode(_component_SpinnerIcon, mergeProps({
      spin: "",
      "class": "p-virtualscroller-loading-icon"
    }, _ctx.ptm("loadingIcon")), null, 16)];
  })], 16)) : createCommentVNode("", true)], 16, _hoisted_1$Z)) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [renderSlot(_ctx.$slots, "default"), renderSlot(_ctx.$slots, "content", {
    items: _ctx.items,
    rows: _ctx.items,
    columns: $options.loadedColumns
  })], 64));
}
script$Y.render = render$X;
var theme$m = function theme13(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-listbox {\n    background: ".concat(dt3("listbox.background"), ";\n    color: ").concat(dt3("listbox.color"), ";\n    border: 1px solid ").concat(dt3("listbox.border.color"), ";\n    border-radius: ").concat(dt3("listbox.border.radius"), ";\n    transition: background ").concat(dt3("listbox.transition.duration"), ", color ").concat(dt3("listbox.transition.duration"), ", border-color ").concat(dt3("listbox.transition.duration"), ",\n            box-shadow ").concat(dt3("listbox.transition.duration"), ", outline-color ").concat(dt3("listbox.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("listbox.shadow"), ";\n}\n\n.p-listbox.p-focus {\n    border-color: ").concat(dt3("listbox.focus.border.color"), ";\n    box-shadow: ").concat(dt3("listbox.focus.ring.shadow"), ";\n    outline: ").concat(dt3("listbox.focus.ring.width"), " ").concat(dt3("listbox.focus.ring.style"), " ").concat(dt3("listbox.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("listbox.focus.ring.offset"), ";\n}\n\n.p-listbox.p-disabled {\n    opacity: 1;\n    background: ").concat(dt3("listbox.disabled.background"), ";\n    color: ").concat(dt3("listbox.disabled.color"), ";\n}\n\n.p-listbox.p-disabled .p-listbox-option {\n    color: ").concat(dt3("listbox.disabled.color"), ";\n}\n\n.p-listbox.p-invalid {\n    border-color: ").concat(dt3("listbox.invalid.border.color"), ";\n}\n\n.p-listbox-header {\n    padding: ").concat(dt3("listbox.list.header.padding"), ";\n}\n\n.p-listbox-filter {\n    width: 100%;\n}\n\n.p-listbox-list-container {\n    overflow: auto;\n}\n\n.p-listbox-list {\n    list-style-type: none;\n    margin: 0;\n    padding: ").concat(dt3("listbox.list.padding"), ";\n    outline: 0 none;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("listbox.list.gap"), ";\n}\n\n.p-listbox-option {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    position: relative;\n    overflow: hidden;\n    padding: ").concat(dt3("listbox.option.padding"), ";\n    border: 0 none;\n    border-radius: ").concat(dt3("listbox.option.border.radius"), ";\n    color: ").concat(dt3("listbox.option.color"), ";\n    transition: background ").concat(dt3("listbox.transition.duration"), ", color ").concat(dt3("listbox.transition.duration"), ", border-color ").concat(dt3("listbox.transition.duration"), ",\n            box-shadow ").concat(dt3("listbox.transition.duration"), ", outline-color ").concat(dt3("listbox.transition.duration"), ";\n}\n\n.p-listbox-striped li:nth-child(even of .p-listbox-option) {\n    background: ").concat(dt3("listbox.option.striped.background"), ";\n}\n\n.p-listbox .p-listbox-list .p-listbox-option.p-listbox-option-selected {\n    background: ").concat(dt3("listbox.option.selected.background"), ";\n    color: ").concat(dt3("listbox.option.selected.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option.p-listbox-option-selected.p-focus {\n    background: ").concat(dt3("listbox.option.selected.focus.background"), ";\n    color: ").concat(dt3("listbox.option.selected.focus.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled).p-focus {\n    background: ").concat(dt3("listbox.option.focus.background"), ";\n    color: ").concat(dt3("listbox.option.focus.color"), ";\n}\n\n.p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled):hover {\n    background: ").concat(dt3("listbox.option.focus.background"), ";\n    color: ").concat(dt3("listbox.option.focus.color"), ";\n}\n\n.p-listbox-option-check-icon {\n    position: relative;\n    margin-inline-start: ").concat(dt3("listbox.checkmark.gutter.start"), ";\n    margin-inline-end: ").concat(dt3("listbox.checkmark.gutter.end"), ";\n    color: ").concat(dt3("listbox.checkmark.color"), ";\n}\n\n.p-listbox-option-group {\n    margin: 0;\n    padding: ").concat(dt3("listbox.option.group.padding"), ";\n    color: ").concat(dt3("listbox.option.group.color"), ";\n    background: ").concat(dt3("listbox.option.group.background"), ";\n    font-weight: ").concat(dt3("listbox.option.group.font.weight"), ";\n}\n\n.p-listbox-empty-message {\n    padding: ").concat(dt3("listbox.empty.message.padding"), ";\n}\n");
};
var classes$p = {
  root: function root4(_ref2) {
    var props = _ref2.props;
    return ["p-listbox p-component", {
      "p-listbox-striped": props.striped,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid
    }];
  },
  header: "p-listbox-header",
  pcFilter: "p-listbox-filter",
  listContainer: "p-listbox-list-container",
  list: "p-listbox-list",
  optionGroup: "p-listbox-option-group",
  option: function option(_ref3) {
    var instance = _ref3.instance, props = _ref3.props, _option = _ref3.option, index2 = _ref3.index, getItemOptions = _ref3.getItemOptions;
    return ["p-listbox-option", {
      "p-listbox-option-selected": instance.isSelected(_option) && props.highlightOnSelect,
      "p-focus": instance.focusedOptionIndex === instance.getOptionIndex(index2, getItemOptions),
      "p-disabled": instance.isOptionDisabled(_option)
    }];
  },
  optionCheckIcon: "p-listbox-option-check-icon",
  optionBlankIcon: "p-listbox-option-blank-icon",
  emptyMessage: "p-listbox-empty-message"
};
var ListboxStyle = BaseStyle.extend({
  name: "listbox",
  theme: theme$m,
  classes: classes$p
});
var script$1$q = {
  name: "BaseListbox",
  "extends": script$1a,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: null,
    optionValue: null,
    optionDisabled: null,
    optionGroupLabel: null,
    optionGroupChildren: null,
    listStyle: null,
    scrollHeight: {
      type: String,
      "default": "14rem"
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    dataKey: null,
    multiple: {
      type: Boolean,
      "default": false
    },
    metaKeySelection: {
      type: Boolean,
      "default": false
    },
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      "default": "contains"
    },
    filterFields: {
      type: Array,
      "default": null
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    autoOptionFocus: {
      type: Boolean,
      "default": true
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    focusOnHover: {
      type: Boolean,
      "default": true
    },
    highlightOnSelect: {
      type: Boolean,
      "default": true
    },
    checkmark: {
      type: Boolean,
      "default": false
    },
    filterMessage: {
      type: String,
      "default": null
    },
    selectionMessage: {
      type: String,
      "default": null
    },
    emptySelectionMessage: {
      type: String,
      "default": null
    },
    emptyFilterMessage: {
      type: String,
      "default": null
    },
    emptyMessage: {
      type: String,
      "default": null
    },
    filterIcon: {
      type: String,
      "default": void 0
    },
    striped: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: ListboxStyle,
  provide: function provide12() {
    return {
      $pcListbox: this,
      $parentInstance: this
    };
  }
};
function _toConsumableArray$d(r) {
  return _arrayWithoutHoles$d(r) || _iterableToArray$d(r) || _unsupportedIterableToArray$f(r) || _nonIterableSpread$d();
}
function _nonIterableSpread$d() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$f(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$f(r, a) : void 0;
  }
}
function _iterableToArray$d(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$d(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$f(r);
}
function _arrayLikeToArray$f(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$X = {
  name: "Listbox",
  "extends": script$1$q,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "filter", "item-dblclick", "option-dblclick"],
  list: null,
  virtualScroller: null,
  optionTouched: false,
  startRangeIndex: -1,
  searchTimeout: null,
  searchValue: "",
  data: function data3() {
    return {
      id: this.$attrs.id,
      filterValue: null,
      focused: false,
      focusedOptionIndex: -1
    };
  },
  watch: {
    "$attrs.id": function $attrsId(newValue) {
      this.id = newValue || UniqueComponentId();
    },
    options: function options() {
      this.autoUpdateModel();
    }
  },
  mounted: function mounted4() {
    this.id = this.id || UniqueComponentId();
    this.autoUpdateModel();
  },
  methods: {
    getOptionIndex: function getOptionIndex(index2, fn) {
      return this.virtualScrollerDisabled ? index2 : fn && fn(index2)["index"];
    },
    getOptionLabel: function getOptionLabel(option4) {
      return this.optionLabel ? resolveFieldData(option4, this.optionLabel) : typeof option4 === "string" ? option4 : null;
    },
    getOptionValue: function getOptionValue2(option4) {
      return this.optionValue ? resolveFieldData(option4, this.optionValue) : option4;
    },
    getOptionRenderKey: function getOptionRenderKey(option4, index2) {
      return (this.dataKey ? resolveFieldData(option4, this.dataKey) : this.getOptionLabel(option4)) + "_" + index2;
    },
    getPTOptions: function getPTOptions3(option4, itemOptions, index2, key) {
      return this.ptm(key, {
        context: {
          selected: this.isSelected(option4),
          focused: this.focusedOptionIndex === this.getOptionIndex(index2, itemOptions),
          disabled: this.isOptionDisabled(option4)
        }
      });
    },
    isOptionDisabled: function isOptionDisabled(option4) {
      return this.optionDisabled ? resolveFieldData(option4, this.optionDisabled) : false;
    },
    isOptionGroup: function isOptionGroup(option4) {
      return this.optionGroupLabel && option4.optionGroup && option4.group;
    },
    getOptionGroupLabel: function getOptionGroupLabel(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupLabel);
    },
    getOptionGroupChildren: function getOptionGroupChildren(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupChildren);
    },
    getAriaPosInset: function getAriaPosInset(index2) {
      var _this = this;
      return (this.optionGroupLabel ? index2 - this.visibleOptions.slice(0, index2).filter(function(option4) {
        return _this.isOptionGroup(option4);
      }).length : index2) + 1;
    },
    onFirstHiddenFocus: function onFirstHiddenFocus() {
      focus(this.list);
      var firstFocusableEl = getFirstFocusableElement(this.$el, ':not([data-p-hidden-focusable="true"])');
      this.$refs.lastHiddenFocusableElement.tabIndex = isElement(firstFocusableEl) ? void 0 : -1;
      this.$refs.firstHiddenFocusableElement.tabIndex = -1;
    },
    onLastHiddenFocus: function onLastHiddenFocus(event2) {
      var relatedTarget = event2.relatedTarget;
      if (relatedTarget === this.list) {
        var firstFocusableEl = getFirstFocusableElement(this.$el, ':not([data-p-hidden-focusable="true"])');
        focus(firstFocusableEl);
        this.$refs.firstHiddenFocusableElement.tabIndex = void 0;
      } else {
        focus(this.$refs.firstHiddenFocusableElement);
      }
      this.$refs.lastHiddenFocusableElement.tabIndex = -1;
    },
    onFocusout: function onFocusout(event2) {
      if (!this.$el.contains(event2.relatedTarget) && this.$refs.lastHiddenFocusableElement && this.$refs.firstHiddenFocusableElement) {
        this.$refs.lastHiddenFocusableElement.tabIndex = this.$refs.firstHiddenFocusableElement.tabIndex = void 0;
      }
    },
    onListFocus: function onListFocus(event2) {
      this.focused = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.findSelectedOptionIndex();
      this.autoUpdateModel();
      this.$emit("focus", event2);
    },
    onListBlur: function onListBlur(event2) {
      this.focused = false;
      this.focusedOptionIndex = this.startRangeIndex = -1;
      this.searchValue = "";
      this.$emit("blur", event2);
    },
    onListKeyDown: function onListKeyDown(event2) {
      var _this2 = this;
      var metaKey = event2.metaKey || event2.ctrlKey;
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "Home":
          this.onHomeKey(event2);
          break;
        case "End":
          this.onEndKey(event2);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.onSpaceKey(event2);
          break;
        case "Tab":
          break;
        case "ShiftLeft":
        case "ShiftRight":
          this.onShiftKey(event2);
          break;
        default:
          if (this.multiple && event2.code === "KeyA" && metaKey) {
            var value3 = this.visibleOptions.filter(function(option4) {
              return _this2.isValidOption(option4);
            }).map(function(option4) {
              return _this2.getOptionValue(option4);
            });
            this.updateModel(event2, value3);
            event2.preventDefault();
            break;
          }
          if (!metaKey && isPrintableCharacter(event2.key)) {
            this.searchOptions(event2, event2.key);
            event2.preventDefault();
          }
          break;
      }
    },
    onOptionSelect: function onOptionSelect(event2, option4) {
      var index2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      if (this.disabled || this.isOptionDisabled(option4)) {
        return;
      }
      this.multiple ? this.onOptionSelectMultiple(event2, option4) : this.onOptionSelectSingle(event2, option4);
      this.optionTouched = false;
      index2 !== -1 && (this.focusedOptionIndex = index2);
    },
    onOptionMouseDown: function onOptionMouseDown(event2, index2) {
      this.changeFocusedOptionIndex(event2, index2);
    },
    onOptionMouseMove: function onOptionMouseMove(event2, index2) {
      if (this.focusOnHover && this.focused) {
        this.changeFocusedOptionIndex(event2, index2);
      }
    },
    onOptionTouchEnd: function onOptionTouchEnd() {
      if (this.disabled) {
        return;
      }
      this.optionTouched = true;
    },
    onOptionDblClick: function onOptionDblClick(event2, item) {
      this.$emit("item-dblclick", {
        originalEvent: event2,
        value: item
      });
      this.$emit("option-dblclick", {
        originalEvent: event2,
        value: item
      });
    },
    onOptionSelectSingle: function onOptionSelectSingle(event2, option4) {
      var selected2 = this.isSelected(option4);
      var valueChanged = false;
      var value3 = null;
      var metaSelection = this.optionTouched ? false : this.metaKeySelection;
      if (metaSelection) {
        var metaKey = event2 && (event2.metaKey || event2.ctrlKey);
        if (selected2) {
          if (metaKey) {
            value3 = null;
            valueChanged = true;
          }
        } else {
          value3 = this.getOptionValue(option4);
          valueChanged = true;
        }
      } else {
        value3 = selected2 ? null : this.getOptionValue(option4);
        valueChanged = true;
      }
      if (valueChanged) {
        this.updateModel(event2, value3);
      }
    },
    onOptionSelectMultiple: function onOptionSelectMultiple(event2, option4) {
      var selected2 = this.isSelected(option4);
      var value3 = null;
      var metaSelection = this.optionTouched ? false : this.metaKeySelection;
      if (metaSelection) {
        var metaKey = event2.metaKey || event2.ctrlKey;
        if (selected2) {
          value3 = metaKey ? this.removeOption(option4) : [this.getOptionValue(option4)];
        } else {
          value3 = metaKey ? this.modelValue || [] : [];
          value3 = [].concat(_toConsumableArray$d(value3), [this.getOptionValue(option4)]);
        }
      } else {
        value3 = selected2 ? this.removeOption(option4) : [].concat(_toConsumableArray$d(this.modelValue || []), [this.getOptionValue(option4)]);
      }
      this.updateModel(event2, value3);
    },
    onOptionSelectRange: function onOptionSelectRange(event2) {
      var _this3 = this;
      var start2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      start2 === -1 && (start2 = this.findNearestSelectedOptionIndex(end, true));
      end === -1 && (end = this.findNearestSelectedOptionIndex(start2));
      if (start2 !== -1 && end !== -1) {
        var rangeStart = Math.min(start2, end);
        var rangeEnd = Math.max(start2, end);
        var value3 = this.visibleOptions.slice(rangeStart, rangeEnd + 1).filter(function(option4) {
          return _this3.isValidOption(option4);
        }).map(function(option4) {
          return _this3.getOptionValue(option4);
        });
        this.updateModel(event2, value3);
      }
    },
    onFilterChange: function onFilterChange(event2) {
      this.$emit("filter", {
        originalEvent: event2,
        value: event2.target.value
      });
      this.focusedOptionIndex = this.startRangeIndex = -1;
    },
    onFilterBlur: function onFilterBlur() {
      this.focusedOptionIndex = this.startRangeIndex = -1;
    },
    onFilterKeyDown: function onFilterKeyDown(event2) {
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, true);
          break;
        case "Home":
          this.onHomeKey(event2, true);
          break;
        case "End":
          this.onEndKey(event2, true);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "ShiftLeft":
        case "ShiftRight":
          this.onShiftKey(event2);
          break;
      }
    },
    onArrowDownKey: function onArrowDownKey(event2) {
      var optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.findFirstFocusedOptionIndex();
      if (this.multiple && event2.shiftKey) {
        this.onOptionSelectRange(event2, this.startRangeIndex, optionIndex);
      }
      this.changeFocusedOptionIndex(event2, optionIndex);
      event2.preventDefault();
    },
    onArrowUpKey: function onArrowUpKey(event2) {
      var optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.findLastFocusedOptionIndex();
      if (this.multiple && event2.shiftKey) {
        this.onOptionSelectRange(event2, optionIndex, this.startRangeIndex);
      }
      this.changeFocusedOptionIndex(event2, optionIndex);
      event2.preventDefault();
    },
    onArrowLeftKey: function onArrowLeftKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      pressedInInputText && (this.focusedOptionIndex = -1);
    },
    onHomeKey: function onHomeKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(0, event2.target.selectionStart);
        } else {
          target.setSelectionRange(0, 0);
          this.focusedOptionIndex = -1;
        }
      } else {
        var metaKey = event2.metaKey || event2.ctrlKey;
        var optionIndex = this.findFirstOptionIndex();
        if (this.multiple && event2.shiftKey && metaKey) {
          this.onOptionSelectRange(event2, optionIndex, this.startRangeIndex);
        }
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    },
    onEndKey: function onEndKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(event2.target.selectionStart, target.value.length);
        } else {
          var len = target.value.length;
          target.setSelectionRange(len, len);
          this.focusedOptionIndex = -1;
        }
      } else {
        var metaKey = event2.metaKey || event2.ctrlKey;
        var optionIndex = this.findLastOptionIndex();
        if (this.multiple && event2.shiftKey && metaKey) {
          this.onOptionSelectRange(event2, this.startRangeIndex, optionIndex);
        }
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    },
    onPageUpKey: function onPageUpKey(event2) {
      this.scrollInView(0);
      event2.preventDefault();
    },
    onPageDownKey: function onPageDownKey(event2) {
      this.scrollInView(this.visibleOptions.length - 1);
      event2.preventDefault();
    },
    onEnterKey: function onEnterKey(event2) {
      if (this.focusedOptionIndex !== -1) {
        if (this.multiple && event2.shiftKey) this.onOptionSelectRange(event2, this.focusedOptionIndex);
        else this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
      }
    },
    onSpaceKey: function onSpaceKey(event2) {
      event2.preventDefault();
      this.onEnterKey(event2);
    },
    onShiftKey: function onShiftKey() {
      this.startRangeIndex = this.focusedOptionIndex;
    },
    isOptionMatched: function isOptionMatched(option4) {
      var _this$getOptionLabel;
      return this.isValidOption(option4) && typeof this.getOptionLabel(option4) === "string" && ((_this$getOptionLabel = this.getOptionLabel(option4)) === null || _this$getOptionLabel === void 0 ? void 0 : _this$getOptionLabel.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale)));
    },
    isValidOption: function isValidOption(option4) {
      return isNotEmpty(option4) && !(this.isOptionDisabled(option4) || this.isOptionGroup(option4));
    },
    isValidSelectedOption: function isValidSelectedOption(option4) {
      return this.isValidOption(option4) && this.isSelected(option4);
    },
    isEquals: function isEquals(value1, value22) {
      return equals(value1, value22, this.equalityKey);
    },
    isSelected: function isSelected(option4) {
      var _this4 = this;
      var optionValue = this.getOptionValue(option4);
      if (this.multiple) return (this.modelValue || []).some(function(value3) {
        return _this4.isEquals(value3, optionValue);
      });
      else return this.isEquals(this.modelValue, optionValue);
    },
    findFirstOptionIndex: function findFirstOptionIndex() {
      var _this5 = this;
      return this.visibleOptions.findIndex(function(option4) {
        return _this5.isValidOption(option4);
      });
    },
    findLastOptionIndex: function findLastOptionIndex() {
      var _this6 = this;
      return findLastIndex(this.visibleOptions, function(option4) {
        return _this6.isValidOption(option4);
      });
    },
    findNextOptionIndex: function findNextOptionIndex(index2) {
      var _this7 = this;
      var matchedOptionIndex = index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option4) {
        return _this7.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : index2;
    },
    findPrevOptionIndex: function findPrevOptionIndex(index2) {
      var _this8 = this;
      var matchedOptionIndex = index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option4) {
        return _this8.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    },
    findSelectedOptionIndex: function findSelectedOptionIndex() {
      var _this9 = this;
      if (this.hasSelectedOption) {
        if (this.multiple) {
          var _loop = function _loop2() {
            var value3 = _this9.modelValue[index2];
            var matchedOptionIndex = _this9.visibleOptions.findIndex(function(option4) {
              return _this9.isValidSelectedOption(option4) && _this9.isEquals(value3, _this9.getOptionValue(option4));
            });
            if (matchedOptionIndex > -1) return {
              v: matchedOptionIndex
            };
          }, _ret;
          for (var index2 = this.modelValue.length - 1; index2 >= 0; index2--) {
            _ret = _loop();
            if (_ret) return _ret.v;
          }
        } else {
          return this.visibleOptions.findIndex(function(option4) {
            return _this9.isValidSelectedOption(option4);
          });
        }
      }
      return -1;
    },
    findFirstSelectedOptionIndex: function findFirstSelectedOptionIndex() {
      var _this10 = this;
      return this.hasSelectedOption ? this.visibleOptions.findIndex(function(option4) {
        return _this10.isValidSelectedOption(option4);
      }) : -1;
    },
    findLastSelectedOptionIndex: function findLastSelectedOptionIndex() {
      var _this11 = this;
      return this.hasSelectedOption ? findLastIndex(this.visibleOptions, function(option4) {
        return _this11.isValidSelectedOption(option4);
      }) : -1;
    },
    findNextSelectedOptionIndex: function findNextSelectedOptionIndex(index2) {
      var _this12 = this;
      var matchedOptionIndex = this.hasSelectedOption && index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option4) {
        return _this12.isValidSelectedOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : -1;
    },
    findPrevSelectedOptionIndex: function findPrevSelectedOptionIndex(index2) {
      var _this13 = this;
      var matchedOptionIndex = this.hasSelectedOption && index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option4) {
        return _this13.isValidSelectedOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : -1;
    },
    findNearestSelectedOptionIndex: function findNearestSelectedOptionIndex(index2) {
      var firstCheckUp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var matchedOptionIndex = -1;
      if (this.hasSelectedOption) {
        if (firstCheckUp) {
          matchedOptionIndex = this.findPrevSelectedOptionIndex(index2);
          matchedOptionIndex = matchedOptionIndex === -1 ? this.findNextSelectedOptionIndex(index2) : matchedOptionIndex;
        } else {
          matchedOptionIndex = this.findNextSelectedOptionIndex(index2);
          matchedOptionIndex = matchedOptionIndex === -1 ? this.findPrevSelectedOptionIndex(index2) : matchedOptionIndex;
        }
      }
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    },
    findFirstFocusedOptionIndex: function findFirstFocusedOptionIndex() {
      var selectedIndex = this.findFirstSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    },
    findLastFocusedOptionIndex: function findLastFocusedOptionIndex() {
      var selectedIndex = this.findLastSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    },
    searchOptions: function searchOptions(event2, _char) {
      var _this14 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var optionIndex = -1;
      if (isNotEmpty(this.searchValue)) {
        if (this.focusedOptionIndex !== -1) {
          optionIndex = this.visibleOptions.slice(this.focusedOptionIndex).findIndex(function(option4) {
            return _this14.isOptionMatched(option4);
          });
          optionIndex = optionIndex === -1 ? this.visibleOptions.slice(0, this.focusedOptionIndex).findIndex(function(option4) {
            return _this14.isOptionMatched(option4);
          }) : optionIndex + this.focusedOptionIndex;
        } else {
          optionIndex = this.visibleOptions.findIndex(function(option4) {
            return _this14.isOptionMatched(option4);
          });
        }
        if (optionIndex === -1 && this.focusedOptionIndex === -1) {
          optionIndex = this.findFirstFocusedOptionIndex();
        }
        if (optionIndex !== -1) {
          this.changeFocusedOptionIndex(event2, optionIndex);
        }
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this14.searchValue = "";
        _this14.searchTimeout = null;
      }, 500);
    },
    removeOption: function removeOption(option4) {
      var _this15 = this;
      return this.modelValue.filter(function(val) {
        return !equals(val, _this15.getOptionValue(option4), _this15.equalityKey);
      });
    },
    changeFocusedOptionIndex: function changeFocusedOptionIndex(event2, index2) {
      if (this.focusedOptionIndex !== index2) {
        this.focusedOptionIndex = index2;
        this.scrollInView();
        if (this.selectOnFocus && !this.multiple) {
          this.onOptionSelect(event2, this.visibleOptions[index2]);
        }
      }
    },
    scrollInView: function scrollInView3() {
      var _this16 = this;
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var id2 = index2 !== -1 ? "".concat(_this16.id, "_").concat(index2) : _this16.focusedOptionId;
        var element = findSingle(_this16.list, 'li[id="'.concat(id2, '"]'));
        if (element) {
          element.scrollIntoView && element.scrollIntoView({
            block: "nearest",
            inline: "nearest",
            behavior: "smooth"
          });
        } else if (!_this16.virtualScrollerDisabled) {
          _this16.virtualScroller && _this16.virtualScroller.scrollToIndex(index2 !== -1 ? index2 : _this16.focusedOptionIndex);
        }
      });
    },
    autoUpdateModel: function autoUpdateModel() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption && !this.multiple && this.focused) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex]);
      }
    },
    updateModel: function updateModel(event2, value3) {
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        originalEvent: event2,
        value: value3
      });
    },
    flatOptions: function flatOptions(options3) {
      var _this17 = this;
      return (options3 || []).reduce(function(result, option4, index2) {
        result.push({
          optionGroup: option4,
          group: true,
          index: index2
        });
        var optionGroupChildren = _this17.getOptionGroupChildren(option4);
        optionGroupChildren && optionGroupChildren.forEach(function(o) {
          return result.push(o);
        });
        return result;
      }, []);
    },
    listRef: function listRef(el, contentRef3) {
      this.list = el;
      contentRef3 && contentRef3(el);
    },
    virtualScrollerRef: function virtualScrollerRef(el) {
      this.virtualScroller = el;
    }
  },
  computed: {
    visibleOptions: function visibleOptions() {
      var options3 = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
      return this.filterValue ? FilterService.filter(options3, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale) : options3;
    },
    hasSelectedOption: function hasSelectedOption() {
      return isNotEmpty(this.modelValue);
    },
    equalityKey: function equalityKey() {
      return this.optionValue ? null : this.dataKey;
    },
    searchFields: function searchFields() {
      return this.filterFields || [this.optionLabel];
    },
    filterResultMessageText: function filterResultMessageText() {
      return isNotEmpty(this.visibleOptions) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptyFilterMessageText;
    },
    filterMessageText: function filterMessageText() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || "";
    },
    emptyFilterMessageText: function emptyFilterMessageText() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || "";
    },
    emptyMessageText: function emptyMessageText() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || "";
    },
    selectionMessageText: function selectionMessageText() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    },
    emptySelectionMessageText: function emptySelectionMessageText() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    },
    selectedMessageText: function selectedMessageText() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll("{0}", this.multiple ? this.modelValue.length : "1") : this.emptySelectionMessageText;
    },
    focusedOptionId: function focusedOptionId() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.id, "_").concat(this.focusedOptionIndex) : null;
    },
    ariaSetSize: function ariaSetSize() {
      var _this18 = this;
      return this.visibleOptions.filter(function(option4) {
        return !_this18.isOptionGroup(option4);
      }).length;
    },
    virtualScrollerDisabled: function virtualScrollerDisabled() {
      return !this.virtualScrollerOptions;
    }
  },
  directives: {
    ripple: Ripple
  },
  components: {
    InputText: script$Z,
    VirtualScroller: script$Y,
    InputIcon: script$_,
    IconField: script$$,
    SearchIcon: script$10,
    CheckIcon: script$11,
    BlankIcon: script$12
  }
};
var _hoisted_1$Y = ["id"];
var _hoisted_2$N = ["tabindex"];
var _hoisted_3$e = ["id", "aria-multiselectable", "aria-label", "aria-labelledby", "aria-activedescendant", "aria-disabled"];
var _hoisted_4$c = ["id"];
var _hoisted_5$8 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousedown", "onMousemove", "onDblclick", "data-p-selected", "data-p-focused", "data-p-disabled"];
var _hoisted_6$7 = ["tabindex"];
function render$W(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_BlankIcon = resolveComponent("BlankIcon");
  var _component_VirtualScroller = resolveComponent("VirtualScroller");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    id: $data.id,
    "class": _ctx.cx("root"),
    onFocusout: _cache[7] || (_cache[7] = function() {
      return $options.onFocusout && $options.onFocusout.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [createBaseVNode("span", mergeProps({
    ref: "firstHiddenFocusableElement",
    role: "presentation",
    "aria-hidden": "true",
    "class": "p-hidden-accessible p-hidden-focusable",
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFirstHiddenFocus && $options.onFirstHiddenFocus.apply($options, arguments);
    })
  }, _ctx.ptm("hiddenFirstFocusableEl"), {
    "data-p-hidden-accessible": true,
    "data-p-hidden-focusable": true
  }), null, 16, _hoisted_2$N), _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
    key: 0,
    "class": normalizeClass(_ctx.cx("header"))
  }, [renderSlot(_ctx.$slots, "header", {
    value: _ctx.modelValue,
    options: $options.visibleOptions
  })], 2)) : createCommentVNode("", true), _ctx.filter ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("header")
  }, _ctx.ptm("header")), [createVNode(_component_IconField, mergeProps({
    unstyled: _ctx.unstyled
  }, _ctx.ptm("pcFilterContainer")), {
    "default": withCtx(function() {
      return [createVNode(_component_InputText, {
        modelValue: $data.filterValue,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = function($event) {
          return $data.filterValue = $event;
        }),
        type: "text",
        "class": normalizeClass(_ctx.cx("pcFilter")),
        placeholder: _ctx.filterPlaceholder,
        role: "searchbox",
        autocomplete: "off",
        disabled: _ctx.disabled,
        unstyled: _ctx.unstyled,
        "aria-owns": $data.id + "_list",
        "aria-activedescendant": $options.focusedOptionId,
        tabindex: !_ctx.disabled && !$data.focused ? _ctx.tabindex : -1,
        onInput: $options.onFilterChange,
        onBlur: $options.onFilterBlur,
        onKeydown: $options.onFilterKeyDown,
        pt: _ctx.ptm("pcFilter")
      }, null, 8, ["modelValue", "class", "placeholder", "disabled", "unstyled", "aria-owns", "aria-activedescendant", "tabindex", "onInput", "onBlur", "onKeydown", "pt"]), createVNode(_component_InputIcon, mergeProps({
        unstyled: _ctx.unstyled
      }, _ctx.ptm("pcFilterIconContainer")), {
        "default": withCtx(function() {
          return [renderSlot(_ctx.$slots, "filtericon", {}, function() {
            return [_ctx.filterIcon ? (openBlock(), createElementBlock("span", mergeProps({
              key: 0,
              "class": _ctx.filterIcon
            }, _ctx.ptm("filterIcon")), null, 16)) : (openBlock(), createBlock(_component_SearchIcon, normalizeProps(mergeProps({
              key: 1
            }, _ctx.ptm("filterIcon"))), null, 16))];
          })];
        }),
        _: 3
      }, 16, ["unstyled"])];
    }),
    _: 3
  }, 16, ["unstyled"]), createBaseVNode("span", mergeProps({
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenFilterResult"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.filterResultMessageText), 17)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("listContainer"),
    style: [{
      "max-height": $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
    }, _ctx.listStyle]
  }, _ctx.ptm("listContainer")), [createVNode(_component_VirtualScroller, mergeProps({
    ref: $options.virtualScrollerRef
  }, _ctx.virtualScrollerOptions, {
    items: $options.visibleOptions,
    style: [{
      height: _ctx.scrollHeight
    }, _ctx.listStyle],
    tabindex: -1,
    disabled: $options.virtualScrollerDisabled,
    pt: _ctx.ptm("virtualScroller")
  }), createSlots({
    content: withCtx(function(_ref) {
      var styleClass = _ref.styleClass, contentRef3 = _ref.contentRef, items2 = _ref.items, getItemOptions = _ref.getItemOptions, contentStyle = _ref.contentStyle, itemSize2 = _ref.itemSize;
      return [createBaseVNode("ul", mergeProps({
        ref: function ref2(el) {
          return $options.listRef(el, contentRef3);
        },
        id: $data.id + "_list",
        "class": [_ctx.cx("list"), styleClass],
        style: contentStyle,
        tabindex: -1,
        role: "listbox",
        "aria-multiselectable": _ctx.multiple,
        "aria-label": _ctx.ariaLabel,
        "aria-labelledby": _ctx.ariaLabelledby,
        "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
        "aria-disabled": _ctx.disabled,
        onFocus: _cache[3] || (_cache[3] = function() {
          return $options.onListFocus && $options.onListFocus.apply($options, arguments);
        }),
        onBlur: _cache[4] || (_cache[4] = function() {
          return $options.onListBlur && $options.onListBlur.apply($options, arguments);
        }),
        onKeydown: _cache[5] || (_cache[5] = function() {
          return $options.onListKeyDown && $options.onListKeyDown.apply($options, arguments);
        })
      }, _ctx.ptm("list")), [(openBlock(true), createElementBlock(Fragment, null, renderList(items2, function(option4, i2) {
        return openBlock(), createElementBlock(Fragment, {
          key: $options.getOptionRenderKey(option4, $options.getOptionIndex(i2, getItemOptions))
        }, [$options.isOptionGroup(option4) ? (openBlock(), createElementBlock("li", mergeProps({
          key: 0,
          id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
          style: {
            height: itemSize2 ? itemSize2 + "px" : void 0
          },
          "class": _ctx.cx("optionGroup"),
          role: "option",
          ref_for: true
        }, _ctx.ptm("optionGroup")), [renderSlot(_ctx.$slots, "optiongroup", {
          option: option4.optionGroup,
          index: $options.getOptionIndex(i2, getItemOptions)
        }, function() {
          return [createTextVNode(toDisplayString$1($options.getOptionGroupLabel(option4.optionGroup)), 1)];
        })], 16, _hoisted_4$c)) : withDirectives((openBlock(), createElementBlock("li", mergeProps({
          key: 1,
          id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
          style: {
            height: itemSize2 ? itemSize2 + "px" : void 0
          },
          "class": _ctx.cx("option", {
            option: option4,
            index: i2,
            getItemOptions
          }),
          role: "option",
          "aria-label": $options.getOptionLabel(option4),
          "aria-selected": $options.isSelected(option4),
          "aria-disabled": $options.isOptionDisabled(option4),
          "aria-setsize": $options.ariaSetSize,
          "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i2, getItemOptions)),
          onClick: function onClick5($event) {
            return $options.onOptionSelect($event, option4, $options.getOptionIndex(i2, getItemOptions));
          },
          onMousedown: function onMousedown($event) {
            return $options.onOptionMouseDown($event, $options.getOptionIndex(i2, getItemOptions));
          },
          onMousemove: function onMousemove($event) {
            return $options.onOptionMouseMove($event, $options.getOptionIndex(i2, getItemOptions));
          },
          onTouchend: _cache[2] || (_cache[2] = function($event) {
            return $options.onOptionTouchEnd();
          }),
          onDblclick: function onDblclick($event) {
            return $options.onOptionDblClick($event, option4);
          },
          ref_for: true
        }, $options.getPTOptions(option4, getItemOptions, i2, "option"), {
          "data-p-selected": $options.isSelected(option4),
          "data-p-focused": $data.focusedOptionIndex === $options.getOptionIndex(i2, getItemOptions),
          "data-p-disabled": $options.isOptionDisabled(option4)
        }), [_ctx.checkmark ? (openBlock(), createElementBlock(Fragment, {
          key: 0
        }, [$options.isSelected(option4) ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
          key: 0,
          "class": _ctx.cx("optionCheckIcon"),
          ref_for: true
        }, _ctx.ptm("optionCheckIcon")), null, 16, ["class"])) : (openBlock(), createBlock(_component_BlankIcon, mergeProps({
          key: 1,
          "class": _ctx.cx("optionBlankIcon"),
          ref_for: true
        }, _ctx.ptm("optionBlankIcon")), null, 16, ["class"]))], 64)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "option", {
          option: option4,
          selected: $options.isSelected(option4),
          index: $options.getOptionIndex(i2, getItemOptions)
        }, function() {
          return [createTextVNode(toDisplayString$1($options.getOptionLabel(option4)), 1)];
        })], 16, _hoisted_5$8)), [[_directive_ripple]])], 64);
      }), 128)), $data.filterValue && (!items2 || items2 && items2.length === 0) ? (openBlock(), createElementBlock("li", mergeProps({
        key: 0,
        "class": _ctx.cx("emptyMessage"),
        role: "option"
      }, _ctx.ptm("emptyMessage")), [renderSlot(_ctx.$slots, "emptyfilter", {}, function() {
        return [createTextVNode(toDisplayString$1($options.emptyFilterMessageText), 1)];
      })], 16)) : !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("li", mergeProps({
        key: 1,
        "class": _ctx.cx("emptyMessage"),
        role: "option"
      }, _ctx.ptm("emptyMessage")), [renderSlot(_ctx.$slots, "empty", {}, function() {
        return [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)];
      })], 16)) : createCommentVNode("", true)], 16, _hoisted_3$e)];
    }),
    _: 2
  }, [_ctx.$slots.loader ? {
    name: "loader",
    fn: withCtx(function(_ref2) {
      var options3 = _ref2.options;
      return [renderSlot(_ctx.$slots, "loader", {
        options: options3
      })];
    }),
    key: "0"
  } : void 0]), 1040, ["items", "style", "disabled", "pt"])], 16), renderSlot(_ctx.$slots, "footer", {
    value: _ctx.modelValue,
    options: $options.visibleOptions
  }), !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenEmptyMessage"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.emptyMessageText), 17)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenSelectedMessage"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.selectedMessageText), 17), createBaseVNode("span", mergeProps({
    ref: "lastHiddenFocusableElement",
    role: "presentation",
    "aria-hidden": "true",
    "class": "p-hidden-accessible p-hidden-focusable",
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    onFocus: _cache[6] || (_cache[6] = function() {
      return $options.onLastHiddenFocus && $options.onLastHiddenFocus.apply($options, arguments);
    })
  }, _ctx.ptm("hiddenLastFocusableEl"), {
    "data-p-hidden-accessible": true,
    "data-p-hidden-focusable": true
  }), null, 16, _hoisted_6$7)], 16, _hoisted_1$Y);
}
script$X.render = render$W;
const _withScopeId$c = (n) => (pushScopeId("data-v-286402f2"), n = n(), popScopeId(), n);
const _hoisted_1$X = { class: "comfy-missing-nodes" };
const _hoisted_2$M = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("h4", { class: "warning-title" }, "Warning: Missing Node Types", -1));
const _hoisted_3$d = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("p", { class: "warning-description" }, " When loading the graph, the following node types were not found: ", -1));
const _hoisted_4$b = { class: "missing-node-item" };
const _hoisted_5$7 = { class: "node-type" };
const _hoisted_6$6 = {
  key: 0,
  class: "node-hint"
};
const _hoisted_7$2 = {
  key: 0,
  class: "added-nodes-warning"
};
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "LoadWorkflowWarning",
  props: {
    missingNodeTypes: {},
    hasAddedNodes: { type: Boolean },
    maximized: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const uniqueNodes = computed(() => {
      const seenTypes = /* @__PURE__ */ new Set();
      return props.missingNodeTypes.filter((node3) => {
        const type = typeof node3 === "object" ? node3.type : node3;
        if (seenTypes.has(type)) return false;
        seenTypes.add(type);
        return true;
      }).map((node3) => {
        if (typeof node3 === "object") {
          return {
            label: node3.type,
            hint: node3.hint,
            action: node3.action
          };
        }
        return { label: node3 };
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$X, [
        _hoisted_2$M,
        _hoisted_3$d,
        createVNode(unref(script$X), {
          options: uniqueNodes.value,
          optionLabel: "label",
          scrollHeight: "100%",
          class: normalizeClass("missing-nodes-list" + (props.maximized ? " maximized" : "")),
          pt: {
            list: { class: "border-none" }
          }
        }, {
          option: withCtx((slotProps) => [
            createBaseVNode("div", _hoisted_4$b, [
              createBaseVNode("span", _hoisted_5$7, toDisplayString$1(slotProps.option.label), 1),
              slotProps.option.hint ? (openBlock(), createElementBlock("span", _hoisted_6$6, toDisplayString$1(slotProps.option.hint), 1)) : createCommentVNode("", true),
              slotProps.option.action ? (openBlock(), createBlock(unref(script$13), {
                key: 1,
                onClick: slotProps.option.action.callback,
                label: slotProps.option.action.text,
                class: "p-button-sm p-button-outlined"
              }, null, 8, ["onClick", "label"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 8, ["options", "class"]),
        _ctx.hasAddedNodes ? (openBlock(), createElementBlock("p", _hoisted_7$2, " Nodes that have failed to load will show as red on the graph. ")) : createCommentVNode("", true)
      ]);
    };
  }
});
const LoadWorkflowWarning = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-286402f2"]]);
function showLoadWorkflowWarning(props) {
  const dialogStore = useDialogStore();
  dialogStore.showDialog({
    component: markRaw(LoadWorkflowWarning),
    props
  });
}
const ANIM_PREVIEW_WIDGET = "$$comfy_animation_preview";
function sanitizeNodeName(string) {
  let entityMap = {
    "&": "",
    "<": "",
    ">": "",
    '"': "",
    "'": "",
    "`": "",
    "=": ""
  };
  return String(string).replace(/[&<>"'`=]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
const _ComfyApp = class _ComfyApp {
  constructor() {
    __privateAdd(this, _ComfyApp_instances);
    /**
     * List of entries to queue
     * @type {{number: number, batchCount: number}[]}
     */
    __privateAdd(this, _queueItems, []);
    /**
     * If the queue is currently being processed
     * @type {boolean}
     */
    __privateAdd(this, _processingQueue, false);
    __publicField2(this, "vueAppReady");
    __publicField2(this, "ui");
    __publicField2(this, "logging");
    __publicField2(this, "extensions");
    __publicField2(this, "extensionManager");
    __publicField2(this, "_nodeOutputs");
    __publicField2(this, "nodePreviewImages");
    __publicField2(this, "shiftDown");
    __publicField2(this, "graph");
    __publicField2(this, "enableWorkflowViewRestore");
    __publicField2(this, "canvas");
    __publicField2(this, "dragOverNode");
    __publicField2(this, "canvasEl");
    // x, y, scale
    __publicField2(this, "zoom_drag_start");
    __publicField2(this, "lastNodeErrors");
    __publicField2(this, "runningNodeId");
    __publicField2(this, "lastExecutionError");
    __publicField2(this, "progress");
    __publicField2(this, "configuringGraph");
    __publicField2(this, "isNewUserSession");
    __publicField2(this, "storageLocation");
    __publicField2(this, "multiUserServer");
    __publicField2(this, "ctx");
    __publicField2(this, "widgets");
    __publicField2(this, "workflowManager");
    __publicField2(this, "bodyTop");
    __publicField2(this, "bodyLeft");
    __publicField2(this, "bodyRight");
    __publicField2(this, "bodyBottom");
    __publicField2(this, "canvasContainer");
    __publicField2(this, "menu");
    this.vueAppReady = false;
    this.ui = new ComfyUI(this);
    this.logging = new ComfyLogging(this);
    this.workflowManager = new ComfyWorkflowManager(this);
    this.bodyTop = $el("div.comfyui-body-top", { parent: document.body });
    this.bodyLeft = $el("div.comfyui-body-left", { parent: document.body });
    this.bodyRight = $el("div.comfyui-body-right", { parent: document.body });
    this.bodyBottom = $el("div.comfyui-body-bottom", { parent: document.body });
    this.canvasContainer = $el("div.graph-canvas-container", {
      parent: document.body
    });
    this.menu = new ComfyAppMenu(this);
    this.extensions = [];
    this.nodeOutputs = {};
    this.nodePreviewImages = {};
    this.shiftDown = false;
  }
  get nodeOutputs() {
    return this._nodeOutputs;
  }
  set nodeOutputs(value3) {
    this._nodeOutputs = value3;
    __privateMethod(this, _ComfyApp_instances, invokeExtensions_fn).call(this, "onNodeOutputsUpdated", value3);
  }
  getPreviewFormatParam() {
    let preview_format = this.ui.settings.getSettingValue("Comfy.PreviewFormat");
    if (preview_format) return `&preview=${preview_format}`;
    else return "";
  }
  getRandParam() {
    return "&rand=" + Math.random();
  }
  static isImageNode(node3) {
    return node3.imgs || node3 && node3.widgets && node3.widgets.findIndex((obj) => obj.name === "image") >= 0;
  }
  static onClipspaceEditorSave() {
    if (_ComfyApp.clipspace_return_node) {
      _ComfyApp.pasteFromClipspace(_ComfyApp.clipspace_return_node);
    }
  }
  static onClipspaceEditorClosed() {
    _ComfyApp.clipspace_return_node = null;
  }
  static copyToClipspace(node3) {
    var widgets = null;
    if (node3.widgets) {
      widgets = node3.widgets.map(({ type, name, value: value3 }) => ({
        type,
        name,
        value: value3
      }));
    }
    var imgs = void 0;
    var orig_imgs = void 0;
    if (node3.imgs != void 0) {
      imgs = [];
      orig_imgs = [];
      for (let i2 = 0; i2 < node3.imgs.length; i2++) {
        imgs[i2] = new Image();
        imgs[i2].src = node3.imgs[i2].src;
        orig_imgs[i2] = imgs[i2];
      }
    }
    var selectedIndex = 0;
    if (node3.imageIndex) {
      selectedIndex = node3.imageIndex;
    }
    _ComfyApp.clipspace = {
      widgets,
      imgs,
      original_imgs: orig_imgs,
      images: node3.images,
      selectedIndex,
      img_paste_mode: "selected"
      // reset to default im_paste_mode state on copy action
    };
    _ComfyApp.clipspace_return_node = null;
    if (_ComfyApp.clipspace_invalidate_handler) {
      _ComfyApp.clipspace_invalidate_handler();
    }
  }
  static pasteFromClipspace(node3) {
    if (_ComfyApp.clipspace) {
      if (_ComfyApp.clipspace.imgs && node3.imgs) {
        if (node3.images && _ComfyApp.clipspace.images) {
          if (_ComfyApp.clipspace["img_paste_mode"] == "selected") {
            node3.images = [
              _ComfyApp.clipspace.images[_ComfyApp.clipspace["selectedIndex"]]
            ];
          } else {
            node3.images = _ComfyApp.clipspace.images;
          }
          if (app$1.nodeOutputs[node3.id + ""])
            app$1.nodeOutputs[node3.id + ""].images = node3.images;
        }
        if (_ComfyApp.clipspace.imgs) {
          if (_ComfyApp.clipspace["img_paste_mode"] == "selected") {
            const img = new Image();
            img.src = _ComfyApp.clipspace.imgs[_ComfyApp.clipspace["selectedIndex"]].src;
            node3.imgs = [img];
            node3.imageIndex = 0;
          } else {
            const imgs = [];
            for (let i2 = 0; i2 < _ComfyApp.clipspace.imgs.length; i2++) {
              imgs[i2] = new Image();
              imgs[i2].src = _ComfyApp.clipspace.imgs[i2].src;
              node3.imgs = imgs;
            }
          }
        }
      }
      if (node3.widgets) {
        if (_ComfyApp.clipspace.images) {
          const clip_image = _ComfyApp.clipspace.images[_ComfyApp.clipspace["selectedIndex"]];
          const index2 = node3.widgets.findIndex((obj) => obj.name === "image");
          if (index2 >= 0) {
            if (node3.widgets[index2].type != "image" && typeof node3.widgets[index2].value == "string" && clip_image.filename) {
              node3.widgets[index2].value = (clip_image.subfolder ? clip_image.subfolder + "/" : "") + clip_image.filename + (clip_image.type ? ` [${clip_image.type}]` : "");
            } else {
              node3.widgets[index2].value = clip_image;
            }
          }
        }
        if (_ComfyApp.clipspace.widgets) {
          _ComfyApp.clipspace.widgets.forEach(({ type, name, value: value3 }) => {
            const prop2 = Object.values(node3.widgets).find(
              // @ts-expect-errorg
              (obj) => obj.type === type && obj.name === name
            );
            if (prop2 && prop2.type != "button") {
              if (
                // @ts-expect-error
                prop2.type != "image" && // @ts-expect-error
                typeof prop2.value == "string" && value3.filename
              ) {
                prop2.value = (value3.subfolder ? value3.subfolder + "/" : "") + value3.filename + (value3.type ? ` [${value3.type}]` : "");
              } else {
                prop2.value = value3;
                prop2.callback(value3);
              }
            }
          });
        }
      }
      app$1.graph.setDirtyCanvas(true);
    }
  }
  /**
   * Set up the app on the page
   */
  setup(canvasEl) {
    return __async(this, null, function* () {
      var _a2;
      this.canvasEl = canvasEl;
      yield __privateMethod(this, _ComfyApp_instances, setUser_fn).call(this);
      const mainCanvas = document.createElement("canvas");
      mainCanvas.style.touchAction = "none";
      this.resizeCanvas();
      yield Promise.all([
        this.workflowManager.loadWorkflows(),
        this.ui.settings.load()
      ]);
      yield __privateMethod(this, _ComfyApp_instances, loadExtensions_fn).call(this);
      addDomClippingSetting();
      __privateMethod(this, _ComfyApp_instances, addProcessMouseHandler_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addProcessKeyHandler_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addConfigureHandler_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addApiUpdateHandlers_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addRestoreWorkflowView_fn).call(this);
      this.graph = new LGraph();
      __privateMethod(this, _ComfyApp_instances, addAfterConfigureHandler_fn).call(this);
      this.canvas = new LGraphCanvas(canvasEl, this.graph);
      this.ctx = canvasEl.getContext("2d");
      LiteGraph.alt_drag_do_clone_nodes = true;
      this.graph.start();
      this.resizeCanvas();
      window.addEventListener("resize", () => this.resizeCanvas());
      const ro = new ResizeObserver(() => this.resizeCanvas());
      ro.observe(this.bodyTop);
      ro.observe(this.bodyLeft);
      ro.observe(this.bodyRight);
      ro.observe(this.bodyBottom);
      yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "init");
      yield this.registerNodes();
      initWidgets(this);
      let restored = false;
      try {
        const loadWorkflow = (json) => __async(this, null, function* () {
          if (json) {
            const workflow = JSON.parse(json);
            const workflowName = getStorageValue("Comfy.PreviousWorkflow");
            yield this.loadGraphData(workflow, true, true, workflowName);
            return true;
          }
        });
        const clientId = (_a2 = api.initialClientId) != null ? _a2 : api.clientId;
        restored = clientId && (yield loadWorkflow(
          sessionStorage.getItem(`workflow:${clientId}`)
        )) || (yield loadWorkflow(localStorage.getItem("workflow")));
      } catch (err) {
        console.error("Error loading previous workflow", err);
      }
      if (!restored) {
        yield this.loadGraphData();
      }
      setInterval(() => {
        const workflow = JSON.stringify(this.graph.serialize());
        localStorage.setItem("workflow", workflow);
        if (api.clientId) {
          sessionStorage.setItem(`workflow:${api.clientId}`, workflow);
        }
      }, 1e3);
      __privateMethod(this, _ComfyApp_instances, addDrawNodeHandler_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addDrawGroupsHandler_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addDropHandler_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addCopyHandler_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addPasteHandler_fn).call(this);
      __privateMethod(this, _ComfyApp_instances, addKeyboardHandler_fn).call(this);
      yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "setup");
    });
  }
  resizeCanvas() {
    var _a2;
    const scale = Math.max(window.devicePixelRatio, 1);
    this.canvasEl.height = this.canvasEl.width = NaN;
    const { width: width2, height } = this.canvasEl.getBoundingClientRect();
    this.canvasEl.width = Math.round(width2 * scale);
    this.canvasEl.height = Math.round(height * scale);
    this.canvasEl.getContext("2d").scale(scale, scale);
    (_a2 = this.canvas) == null ? void 0 : _a2.draw(true, true);
  }
  /**
   * Registers nodes with the graph
   */
  registerNodes() {
    return __async(this, null, function* () {
      const defs = yield api.getNodeDefs();
      yield this.registerNodesFromDefs(defs);
      if (this.vueAppReady) {
        const nodeDefStore = useNodeDefStore();
        nodeDefStore.updateNodeDefs([...Object.values(defs), ...SYSTEM_NODE_DEFS]);
        nodeDefStore.updateWidgets(this.widgets);
      }
      yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "registerCustomNodes");
    });
  }
  getWidgetType(inputData, inputName) {
    const type = inputData[0];
    if (Array.isArray(type)) {
      return "COMBO";
    } else if (`${type}:${inputName}` in this.widgets) {
      return `${type}:${inputName}`;
    } else if (type in this.widgets) {
      return type;
    } else {
      return null;
    }
  }
  registerNodeDef(nodeId, nodeData) {
    return __async(this, null, function* () {
      const self2 = this;
      const node3 = Object.assign(
        function ComfyNode() {
          var _a2, _b, _c;
          var inputs = nodeData["input"]["required"];
          if (nodeData["input"]["optional"] != void 0) {
            inputs = Object.assign(
              {},
              nodeData["input"]["required"],
              nodeData["input"]["optional"]
            );
          }
          const config = { minWidth: 1, minHeight: 1 };
          for (const inputName in inputs) {
            const inputData = inputs[inputName];
            const type = inputData[0];
            let widgetCreated = true;
            const widgetType = self2.getWidgetType(inputData, inputName);
            if (widgetType) {
              if (widgetType === "COMBO") {
                Object.assign(
                  config,
                  self2.widgets.COMBO(this, inputName, inputData, app$1) || {}
                );
              } else {
                Object.assign(
                  config,
                  self2.widgets[widgetType](this, inputName, inputData, app$1) || {}
                );
              }
            } else {
              this.addInput(inputName, type);
              widgetCreated = false;
            }
            if (widgetCreated && ((_a2 = inputData[1]) == null ? void 0 : _a2.forceInput) && (config == null ? void 0 : config.widget)) {
              if (!config.widget.options) config.widget.options = {};
              config.widget.options.forceInput = inputData[1].forceInput;
            }
            if (widgetCreated && ((_b = inputData[1]) == null ? void 0 : _b.defaultInput) && (config == null ? void 0 : config.widget)) {
              if (!config.widget.options) config.widget.options = {};
              config.widget.options.defaultInput = inputData[1].defaultInput;
            }
          }
          for (const o in nodeData["output"]) {
            let output = nodeData["output"][o];
            if (output instanceof Array) output = "COMBO";
            const outputName = nodeData["output_name"][o] || output;
            const outputShape = nodeData["output_is_list"][o] ? LiteGraph.GRID_SHAPE : LiteGraph.CIRCLE_SHAPE;
            this.addOutput(outputName, output, { shape: outputShape });
          }
          const s = this.computeSize();
          s[0] = Math.max(config.minWidth, s[0] * 1.5);
          s[1] = Math.max(config.minHeight, s[1]);
          this.size = s;
          this.serialize_widgets = true;
          __privateMethod(_c = app$1, _ComfyApp_instances, invokeExtensionsAsync_fn).call(_c, "nodeCreated", this);
        },
        {
          title: nodeData.display_name || nodeData.name,
          comfyClass: nodeData.name,
          nodeData
        }
      );
      node3.prototype.comfyClass = nodeData.name;
      __privateMethod(this, _ComfyApp_instances, addNodeContextMenuHandler_fn).call(this, node3);
      __privateMethod(this, _ComfyApp_instances, addDrawBackgroundHandler_fn).call(this, node3);
      __privateMethod(this, _ComfyApp_instances, addNodeKeyHandler_fn).call(this, node3);
      yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "beforeRegisterNodeDef", node3, nodeData);
      LiteGraph.registerNodeType(nodeId, node3);
      node3.category = nodeData.category;
    });
  }
  registerNodesFromDefs(defs) {
    return __async(this, null, function* () {
      yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "addCustomNodeDefs", defs);
      this.widgets = Object.assign(
        {},
        ComfyWidgets,
        ...(yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "getCustomWidgets")).filter(Boolean)
      );
      for (const nodeId in defs) {
        this.registerNodeDef(nodeId, defs[nodeId]);
      }
    });
  }
  loadTemplateData(templateData) {
    if (!(templateData == null ? void 0 : templateData.templates)) {
      return;
    }
    const old = localStorage.getItem("litegrapheditor_clipboard");
    var maxY, nodeBottom, node3;
    for (const template of templateData.templates) {
      if (!(template == null ? void 0 : template.data)) {
        continue;
      }
      localStorage.setItem("litegrapheditor_clipboard", template.data);
      app$1.canvas.pasteFromClipboard();
      maxY = false;
      for (const i2 in app$1.canvas.selected_nodes) {
        node3 = app$1.canvas.selected_nodes[i2];
        nodeBottom = node3.pos[1] + node3.size[1];
        if (maxY === false || nodeBottom > maxY) {
          maxY = nodeBottom;
        }
      }
      app$1.canvas.graph_mouse[1] = maxY + 50;
    }
    localStorage.setItem("litegrapheditor_clipboard", old);
  }
  showMissingNodesError(missingNodeTypes, hasAddedNodes = true) {
    if (this.vueAppReady)
      showLoadWorkflowWarning({
        missingNodeTypes,
        hasAddedNodes,
        maximizable: true
      });
    this.logging.addEntry("Comfy.App", "warn", {
      MissingNodes: missingNodeTypes
    });
  }
  changeWorkflow(callback, workflow = null) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      try {
        (_b = (_a2 = this.workflowManager.activeWorkflow) == null ? void 0 : _a2.changeTracker) == null ? void 0 : _b.store();
      } catch (error) {
        console.error(error);
      }
      yield callback();
      try {
        this.workflowManager.setWorkflow(workflow);
        (_c = this.workflowManager.activeWorkflow) == null ? void 0 : _c.track();
      } catch (error) {
        console.error(error);
      }
    });
  }
  loadGraphData(graphData, clean = true, restore_view = true, workflow = null) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      if (clean !== false) {
        this.clean();
      }
      let reset_invalid_values = false;
      if (!graphData) {
        graphData = defaultGraph;
        reset_invalid_values = true;
      }
      if (typeof structuredClone === "undefined") {
        graphData = JSON.parse(JSON.stringify(graphData));
      } else {
        graphData = structuredClone(graphData);
      }
      try {
        this.workflowManager.setWorkflow(workflow);
      } catch (error) {
        console.error(error);
      }
      if (this.vueAppReady && useSettingStore().get("Comfy.Validation.Workflows")) {
        graphData = yield validateComfyWorkflow(
          graphData,
          /* onError=*/
          alert
        );
        if (!graphData) return;
      }
      const missingNodeTypes = [];
      yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "beforeConfigureGraph", graphData, missingNodeTypes);
      for (let n of graphData.nodes) {
        if (n.type == "T2IAdapterLoader") n.type = "ControlNetLoader";
        if (n.type == "ConditioningAverage ") n.type = "ConditioningAverage";
        if (n.type == "SDV_img2vid_Conditioning")
          n.type = "SVD_img2vid_Conditioning";
        if (!(n.type in LiteGraph.registered_node_types)) {
          missingNodeTypes.push(n.type);
          n.type = sanitizeNodeName(n.type);
        }
      }
      try {
        this.graph.configure(graphData);
        if (restore_view && this.enableWorkflowViewRestore.value && ((_a2 = graphData.extra) == null ? void 0 : _a2.ds)) {
          this.canvas.ds.offset = graphData.extra.ds.offset;
          this.canvas.ds.scale = graphData.extra.ds.scale;
        }
        try {
          (_b = this.workflowManager.activeWorkflow) == null ? void 0 : _b.track();
        } catch (error) {
        }
      } catch (error) {
        let errorHint = [];
        const filename = error.fileName || ((_c = (error.stack || "").match(/(\/extensions\/.*\.js)/)) == null ? void 0 : _c[1]);
        const pos2 = (filename || "").indexOf("/extensions/");
        if (pos2 > -1) {
          errorHint.push(
            $el("span", {
              textContent: "This may be due to the following script:"
            }),
            $el("br"),
            $el("span", {
              style: {
                fontWeight: "bold"
              },
              textContent: filename.substring(pos2)
            })
          );
        }
        this.ui.dialog.show(
          $el("div", [
            $el("p", {
              textContent: "Loading aborted due to error reloading workflow data"
            }),
            $el("pre", {
              style: { padding: "5px", backgroundColor: "rgba(255,0,0,0.2)" },
              textContent: error.toString()
            }),
            $el("pre", {
              style: {
                padding: "5px",
                color: "#ccc",
                fontSize: "10px",
                maxHeight: "50vh",
                overflow: "auto",
                backgroundColor: "rgba(0,0,0,0.2)"
              },
              textContent: error.stack || "No stacktrace available"
            }),
            ...errorHint
          ]).outerHTML
        );
        return;
      }
      for (const node3 of this.graph._nodes) {
        const size2 = node3.computeSize();
        size2[0] = Math.max(node3.size[0], size2[0]);
        size2[1] = Math.max(node3.size[1], size2[1]);
        node3.size = size2;
        if (node3.widgets) {
          for (let widget of node3.widgets) {
            if (node3.type == "KSampler" || node3.type == "KSamplerAdvanced") {
              if (widget.name == "sampler_name") {
                if (widget.value.startsWith("sample_")) {
                  widget.value = widget.value.slice(7);
                }
              }
            }
            if (node3.type == "KSampler" || node3.type == "KSamplerAdvanced" || node3.type == "PrimitiveNode") {
              if (widget.name == "control_after_generate") {
                if (widget.value === true) {
                  widget.value = "randomize";
                } else if (widget.value === false) {
                  widget.value = "fixed";
                }
              }
            }
            if (reset_invalid_values) {
              if (widget.type == "combo") {
                if (!widget.options.values.includes(widget.value) && widget.options.values.length > 0) {
                  widget.value = widget.options.values[0];
                }
              }
            }
          }
        }
        __privateMethod(this, _ComfyApp_instances, invokeExtensions_fn).call(this, "loadedGraphNode", node3);
      }
      if (missingNodeTypes.length) {
        this.showMissingNodesError(missingNodeTypes);
      }
      yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "afterConfigureGraph", missingNodeTypes);
      requestAnimationFrame(() => {
        this.graph.setDirtyCanvas(true, true);
      });
    });
  }
  /**
   * Converts the current graph workflow for sending to the API
   * @returns The workflow and node links
   */
  graphToPrompt() {
    return __async(this, arguments, function* (graph = this.graph, clean = true) {
      var _a2, _b;
      for (const outerNode of this.graph.computeExecutionOrder(false)) {
        if (outerNode.widgets) {
          for (const widget of outerNode.widgets) {
            (_a2 = widget.beforeQueued) == null ? void 0 : _a2.call(widget);
          }
        }
        const innerNodes = outerNode.getInnerNodes ? outerNode.getInnerNodes() : [outerNode];
        for (const node3 of innerNodes) {
          if (node3.isVirtualNode) {
            if (node3.applyToGraph) {
              node3.applyToGraph();
            }
          }
        }
      }
      const workflow = graph.serialize();
      const output = {};
      for (const outerNode of graph.computeExecutionOrder(false)) {
        const skipNode = outerNode.mode === 2 || outerNode.mode === 4;
        const innerNodes = !skipNode && outerNode.getInnerNodes ? outerNode.getInnerNodes() : [outerNode];
        for (const node3 of innerNodes) {
          if (node3.isVirtualNode) {
            continue;
          }
          if (node3.mode === 2 || node3.mode === 4) {
            continue;
          }
          const inputs = {};
          const widgets = node3.widgets;
          if (widgets) {
            for (const i2 in widgets) {
              const widget = widgets[i2];
              if (!widget.options || widget.options.serialize !== false) {
                inputs[widget.name] = widget.serializeValue ? yield widget.serializeValue(node3, i2) : widget.value;
              }
            }
          }
          for (let i2 in node3.inputs) {
            let parent = node3.getInputNode(i2);
            if (parent) {
              let link = node3.getInputLink(i2);
              while (parent.mode === 4 || parent.isVirtualNode) {
                let found = false;
                if (parent.isVirtualNode) {
                  link = parent.getInputLink(link.origin_slot);
                  if (link) {
                    parent = parent.getInputNode(link.target_slot);
                    if (parent) {
                      found = true;
                    }
                  }
                } else if (link && parent.mode === 4) {
                  let all_inputs = [link.origin_slot];
                  if (parent.inputs) {
                    all_inputs = all_inputs.concat(Object.keys(parent.inputs));
                    for (let parent_input in all_inputs) {
                      parent_input = all_inputs[parent_input];
                      if (((_b = parent.inputs[parent_input]) == null ? void 0 : _b.type) === node3.inputs[i2].type) {
                        link = parent.getInputLink(parent_input);
                        if (link) {
                          parent = parent.getInputNode(parent_input);
                        }
                        found = true;
                        break;
                      }
                    }
                  }
                }
                if (!found) {
                  break;
                }
              }
              if (link) {
                if (parent == null ? void 0 : parent.updateLink) {
                  link = parent.updateLink(link);
                }
                if (link) {
                  inputs[node3.inputs[i2].name] = [
                    String(link.origin_id),
                    parseInt(link.origin_slot)
                  ];
                }
              }
            }
          }
          let node_data = {
            inputs,
            class_type: node3.comfyClass
          };
          if (this.ui.settings.getSettingValue("Comfy.DevMode")) {
            node_data["_meta"] = {
              title: node3.title
            };
          }
          output[String(node3.id)] = node_data;
        }
      }
      if (clean) {
        for (const o in output) {
          for (const i2 in output[o].inputs) {
            if (Array.isArray(output[o].inputs[i2]) && output[o].inputs[i2].length === 2 && !output[output[o].inputs[i2][0]]) {
              delete output[o].inputs[i2];
            }
          }
        }
      }
      return { workflow, output };
    });
  }
  queuePrompt(number2, batchCount = 1) {
    return __async(this, null, function* () {
      __privateGet(this, _queueItems).push({ number: number2, batchCount });
      if (__privateGet(this, _processingQueue)) {
        return;
      }
      __privateSet(this, _processingQueue, true);
      this.lastNodeErrors = null;
      try {
        while (__privateGet(this, _queueItems).length) {
          ;
          ({ number: number2, batchCount } = __privateGet(this, _queueItems).pop());
          for (let i2 = 0; i2 < batchCount; i2++) {
            const p2 = yield this.graphToPrompt();
            try {
              const res = yield api.queuePrompt(number2, p2);
              this.lastNodeErrors = res.node_errors;
              if (this.lastNodeErrors.length > 0) {
                this.canvas.draw(true, true);
              } else {
                try {
                  this.workflowManager.storePrompt({
                    id: res.prompt_id,
                    nodes: Object.keys(p2.output)
                  });
                } catch (error) {
                }
              }
            } catch (error) {
              const formattedError = __privateMethod(this, _ComfyApp_instances, formatPromptError_fn).call(this, error);
              this.ui.dialog.show(formattedError);
              if (error.response) {
                this.lastNodeErrors = error.response.node_errors;
                this.canvas.draw(true, true);
              }
              break;
            }
            for (const n of p2.workflow.nodes) {
              const node3 = this.graph.getNodeById(n.id);
              if (node3.widgets) {
                for (const widget of node3.widgets) {
                  if (widget.afterQueued) {
                    widget.afterQueued();
                  }
                }
              }
            }
            this.canvas.draw(true, true);
            yield this.ui.queue.update();
          }
        }
      } finally {
        __privateSet(this, _processingQueue, false);
      }
      api.dispatchEvent(
        new CustomEvent("promptQueued", { detail: { number: number2, batchCount } })
      );
      return !this.lastNodeErrors;
    });
  }
  showErrorOnFileLoad(file) {
    this.ui.dialog.show(
      $el("div", [
        $el("p", { textContent: `Unable to find workflow in ${file.name}` })
      ]).outerHTML
    );
  }
  /**
   * Loads workflow data from the specified file
   * @param {File} file
   */
  handleFile(file) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      const removeExt = (f) => {
        if (!f) return f;
        const p2 = f.lastIndexOf(".");
        if (p2 === -1) return f;
        return f.substring(0, p2);
      };
      const fileName = removeExt(file.name);
      if (file.type === "image/png") {
        const pngInfo = yield getPngMetadata(file);
        if (pngInfo == null ? void 0 : pngInfo.workflow) {
          yield this.loadGraphData(
            JSON.parse(pngInfo.workflow),
            true,
            true,
            fileName
          );
        } else if (pngInfo == null ? void 0 : pngInfo.prompt) {
          this.loadApiJson(JSON.parse(pngInfo.prompt), fileName);
        } else if (pngInfo == null ? void 0 : pngInfo.parameters) {
          this.changeWorkflow(() => {
            importA1111(this.graph, pngInfo.parameters);
          }, fileName);
        } else {
          this.showErrorOnFileLoad(file);
        }
      } else if (file.type === "image/webp") {
        const pngInfo = yield getWebpMetadata(file);
        const workflow = (pngInfo == null ? void 0 : pngInfo.workflow) || (pngInfo == null ? void 0 : pngInfo.Workflow);
        const prompt2 = (pngInfo == null ? void 0 : pngInfo.prompt) || (pngInfo == null ? void 0 : pngInfo.Prompt);
        if (workflow) {
          this.loadGraphData(JSON.parse(workflow), true, true, fileName);
        } else if (prompt2) {
          this.loadApiJson(JSON.parse(prompt2), fileName);
        } else {
          this.showErrorOnFileLoad(file);
        }
      } else if (file.type === "audio/flac" || file.type === "audio/x-flac") {
        const pngInfo = yield getFlacMetadata(file);
        const workflow = (pngInfo == null ? void 0 : pngInfo.workflow) || (pngInfo == null ? void 0 : pngInfo.Workflow);
        const prompt2 = (pngInfo == null ? void 0 : pngInfo.prompt) || (pngInfo == null ? void 0 : pngInfo.Prompt);
        if (workflow) {
          this.loadGraphData(JSON.parse(workflow), true, true, fileName);
        } else if (prompt2) {
          this.loadApiJson(JSON.parse(prompt2), fileName);
        } else {
          this.showErrorOnFileLoad(file);
        }
      } else if (file.type === "application/json" || ((_a2 = file.name) == null ? void 0 : _a2.endsWith(".json"))) {
        const reader = new FileReader();
        reader.onload = () => __async(this, null, function* () {
          const readerResult = reader.result;
          const jsonContent = JSON.parse(readerResult);
          if (jsonContent == null ? void 0 : jsonContent.templates) {
            this.loadTemplateData(jsonContent);
          } else if (this.isApiJson(jsonContent)) {
            this.loadApiJson(jsonContent, fileName);
          } else {
            yield this.loadGraphData(JSON.parse(readerResult), true, fileName);
          }
        });
        reader.readAsText(file);
      } else if (((_b = file.name) == null ? void 0 : _b.endsWith(".latent")) || ((_c = file.name) == null ? void 0 : _c.endsWith(".safetensors"))) {
        const info = yield getLatentMetadata(file);
        if (info.workflow) {
          yield this.loadGraphData(
            // @ts-expect-error
            JSON.parse(info.workflow),
            true,
            true,
            fileName
          );
        } else if (info.prompt) {
          this.loadApiJson(JSON.parse(info.prompt));
        } else {
          this.showErrorOnFileLoad(file);
        }
      } else {
        this.showErrorOnFileLoad(file);
      }
    });
  }
  isApiJson(data28) {
    return Object.values(data28).every((v2) => v2.class_type);
  }
  loadApiJson(apiData, fileName) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
    const missingNodeTypes = Object.values(apiData).filter(
      // @ts-expect-error
      (n) => !LiteGraph.registered_node_types[n.class_type]
    );
    if (missingNodeTypes.length) {
      this.showMissingNodesError(
        // @ts-expect-error
        missingNodeTypes.map((t) => t.class_type),
        false
      );
      return;
    }
    const ids = Object.keys(apiData);
    app$1.graph.clear();
    for (const id2 of ids) {
      const data28 = apiData[id2];
      const node3 = LiteGraph.createNode(data28.class_type);
      node3.id = isNaN(+id2) ? id2 : +id2;
      node3.title = (_b = (_a2 = data28._meta) == null ? void 0 : _a2.title) != null ? _b : node3.title;
      app$1.graph.add(node3);
    }
    this.changeWorkflow(() => {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2;
      for (const id2 of ids) {
        const data28 = apiData[id2];
        const node3 = app$1.graph.getNodeById(Number.parseInt(id2));
        for (const input in (_a3 = data28.inputs) != null ? _a3 : {}) {
          const value3 = data28.inputs[input];
          if (value3 instanceof Array) {
            const [fromId, fromSlot] = value3;
            const fromNode = app$1.graph.getNodeById(fromId);
            let toSlot = (_b2 = node3.inputs) == null ? void 0 : _b2.findIndex((inp) => inp.name === input);
            if (toSlot == null || toSlot === -1) {
              try {
                const widget = (_c2 = node3.widgets) == null ? void 0 : _c2.find((w2) => w2.name === input);
                if (widget && ((_d2 = node3.convertWidgetToInput) == null ? void 0 : _d2.call(node3, widget))) {
                  toSlot = ((_e2 = node3.inputs) == null ? void 0 : _e2.length) - 1;
                }
              } catch (error) {
              }
            }
            if (toSlot != null || toSlot !== -1) {
              fromNode.connect(fromSlot, node3, toSlot);
            }
          } else {
            const widget = (_f2 = node3.widgets) == null ? void 0 : _f2.find((w2) => w2.name === input);
            if (widget) {
              widget.value = value3;
              (_g2 = widget.callback) == null ? void 0 : _g2.call(widget, value3);
            }
          }
        }
      }
      app$1.graph.arrange();
    }, fileName);
    for (const id2 of ids) {
      const data28 = apiData[id2];
      const node3 = app$1.graph.getNodeById(Number.parseInt(id2));
      for (const input in (_c = data28.inputs) != null ? _c : {}) {
        const value3 = data28.inputs[input];
        if (value3 instanceof Array) {
          const [fromId, fromSlot] = value3;
          const fromNode = app$1.graph.getNodeById(fromId);
          let toSlot = (_d = node3.inputs) == null ? void 0 : _d.findIndex((inp) => inp.name === input);
          if (toSlot == null || toSlot === -1) {
            try {
              const widget = (_e = node3.widgets) == null ? void 0 : _e.find((w2) => w2.name === input);
              if (widget && ((_f = node3.convertWidgetToInput) == null ? void 0 : _f.call(node3, widget))) {
                toSlot = ((_g = node3.inputs) == null ? void 0 : _g.length) - 1;
              }
            } catch (error) {
            }
          }
          if (toSlot != null || toSlot !== -1) {
            fromNode.connect(fromSlot, node3, toSlot);
          }
        } else {
          const widget = (_h = node3.widgets) == null ? void 0 : _h.find((w2) => w2.name === input);
          if (widget) {
            widget.value = value3;
            (_i = widget.callback) == null ? void 0 : _i.call(widget, value3);
          }
        }
      }
    }
    app$1.graph.arrange();
  }
  /**
   * Registers a Comfy web extension with the app
   * @param {ComfyExtension} extension
   */
  registerExtension(extension) {
    if (!extension.name) {
      throw new Error("Extensions must have a 'name' property.");
    }
    if (this.extensions.find((ext) => ext.name === extension.name)) {
      throw new Error(`Extension named '${extension.name}' already registered.`);
    }
    this.extensions.push(extension);
  }
  /**
   * Refresh combo list on whole nodes
   */
  refreshComboInNodes() {
    return __async(this, null, function* () {
      var _a2;
      const defs = yield api.getNodeDefs();
      for (const nodeId in defs) {
        this.registerNodeDef(nodeId, defs[nodeId]);
      }
      for (let nodeNum in this.graph._nodes) {
        const node3 = this.graph._nodes[nodeNum];
        const def2 = defs[node3.type];
        (_a2 = node3.refreshComboInNode) == null ? void 0 : _a2.call(node3, defs);
        if (!def2) continue;
        for (const widgetNum in node3.widgets) {
          const widget = node3.widgets[widgetNum];
          if (widget.type == "combo" && def2["input"]["required"][widget.name] !== void 0) {
            widget.options.values = def2["input"]["required"][widget.name][0];
            if (widget.name != "image" && !widget.options.values.includes(widget.value)) {
              widget.value = widget.options.values[0];
              widget.callback(widget.value);
            }
          }
        }
      }
      yield __privateMethod(this, _ComfyApp_instances, invokeExtensionsAsync_fn).call(this, "refreshComboInNodes", defs);
    });
  }
  resetView() {
    app$1.canvas.ds.scale = 1;
    app$1.canvas.ds.offset = [0, 0];
    app$1.graph.setDirtyCanvas(true, true);
  }
  /**
   * Clean current state
   */
  clean() {
    this.nodeOutputs = {};
    this.nodePreviewImages = {};
    this.lastNodeErrors = null;
    this.lastExecutionError = null;
    this.runningNodeId = null;
  }
  addNodeOnGraph(nodeDef, options3 = {}) {
    const node3 = LiteGraph.createNode(
      nodeDef.name,
      nodeDef.display_name,
      options3
    );
    this.graph.add(node3);
    return node3;
  }
  clientPosToCanvasPos(pos2) {
    const rect = this.canvasContainer.getBoundingClientRect();
    const containerOffsets = [rect.left, rect.top];
    return _.zip(pos2, this.canvas.ds.offset, containerOffsets).map(
      ([p2, o1, o2]) => (p2 - o2) / this.canvas.ds.scale - o1
    );
  }
};
_queueItems = new WeakMap();
_processingQueue = new WeakMap();
_ComfyApp_instances = new WeakSet();
/**
 * Invoke an extension callback
 * @param {keyof ComfyExtension} method The extension callback to execute
 * @param  {any[]} args Any arguments to pass to the callback
 * @returns
 */
invokeExtensions_fn = function(method, ...args) {
  let results = [];
  for (const ext of this.extensions) {
    if (method in ext) {
      try {
        results.push(ext[method](...args, this));
      } catch (error) {
        console.error(
          `Error calling extension '${ext.name}' method '${method}'`,
          { error },
          { extension: ext },
          { args }
        );
      }
    }
  }
  return results;
};
invokeExtensionsAsync_fn = function(method, ...args) {
  return __async(this, null, function* () {
    return yield Promise.all(
      this.extensions.map((ext) => __async(this, null, function* () {
        if (method in ext) {
          try {
            return yield ext[method](...args, this);
          } catch (error) {
            console.error(
              `Error calling extension '${ext.name}' method '${method}'`,
              { error },
              { extension: ext },
              { args }
            );
          }
        }
      }))
    );
  });
};
addRestoreWorkflowView_fn = function() {
  const serialize2 = LGraph.prototype.serialize;
  const self2 = this;
  LGraph.prototype.serialize = function() {
    var _a2;
    const workflow = serialize2.apply(this, arguments);
    if (self2.enableWorkflowViewRestore.value) {
      if (!workflow.extra) {
        workflow.extra = {};
      }
      workflow.extra.ds = {
        scale: self2.canvas.ds.scale,
        offset: self2.canvas.ds.offset
      };
    } else if ((_a2 = workflow.extra) == null ? void 0 : _a2.ds) {
      delete workflow.extra.ds;
    }
    return workflow;
  };
  this.enableWorkflowViewRestore = this.ui.settings.addSetting({
    id: "Comfy.EnableWorkflowViewRestore",
    name: "Save and restore canvas position and zoom level in workflows",
    type: "boolean",
    defaultValue: true
  });
};
/**
 * Adds special context menu handling for nodes
 * e.g. this adds Open Image functionality for nodes that show images
 * @param {*} node The node to add the menu handler
 */
addNodeContextMenuHandler_fn = function(node3) {
  function getCopyImageOption(img) {
    if (typeof window.ClipboardItem === "undefined") return [];
    return [
      {
        content: "Copy Image",
        callback: () => __async(this, null, function* () {
          var _a2;
          const url = new URL(img.src);
          url.searchParams.delete("preview");
          const writeImage = (blob) => __async(this, null, function* () {
            yield navigator.clipboard.write([
              new ClipboardItem({
                [blob.type]: blob
              })
            ]);
          });
          try {
            const data28 = yield fetch(url);
            const blob = yield data28.blob();
            try {
              yield writeImage(blob);
            } catch (error) {
              if (blob.type !== "image/png") {
                const canvas = $el("canvas", {
                  width: img.naturalWidth,
                  height: img.naturalHeight
                });
                const ctx = canvas.getContext("2d");
                let image;
                if (typeof window.createImageBitmap === "undefined") {
                  image = new Image();
                  const p2 = new Promise((resolve8, reject2) => {
                    image.onload = resolve8;
                    image.onerror = reject2;
                  }).finally(() => {
                    URL.revokeObjectURL(image.src);
                  });
                  image.src = URL.createObjectURL(blob);
                  yield p2;
                } else {
                  image = yield createImageBitmap(blob);
                }
                try {
                  ctx.drawImage(image, 0, 0);
                  canvas.toBlob(writeImage, "image/png");
                } finally {
                  if (typeof image.close === "function") {
                    image.close();
                  }
                }
                return;
              }
              throw error;
            }
          } catch (error) {
            alert("Error copying image: " + ((_a2 = error.message) != null ? _a2 : error));
          }
        })
      }
    ];
  }
  node3.prototype.getExtraMenuOptions = function(_2, options3) {
    if (this.imgs) {
      let img;
      if (this.imageIndex != null) {
        img = this.imgs[this.imageIndex];
      } else if (this.overIndex != null) {
        img = this.imgs[this.overIndex];
      }
      if (img) {
        options3.unshift(
          {
            content: "Open Image",
            callback: () => {
              let url = new URL(img.src);
              url.searchParams.delete("preview");
              window.open(url, "_blank");
            }
          },
          ...getCopyImageOption(img),
          {
            content: "Save Image",
            callback: () => {
              const a = document.createElement("a");
              let url = new URL(img.src);
              url.searchParams.delete("preview");
              a.href = url.toString();
              a.setAttribute(
                "download",
                new URLSearchParams(url.search).get("filename")
              );
              document.body.append(a);
              a.click();
              requestAnimationFrame(() => a.remove());
            }
          }
        );
      }
    }
    options3.push({
      content: "Bypass",
      callback: (obj) => {
        if (this.mode === 4) this.mode = 0;
        else this.mode = 4;
        this.graph.change();
      }
    });
    if (!_ComfyApp.clipspace_return_node) {
      options3.push({
        content: "Copy (Clipspace)",
        callback: (obj) => {
          _ComfyApp.copyToClipspace(this);
        }
      });
      if (_ComfyApp.clipspace != null) {
        options3.push({
          content: "Paste (Clipspace)",
          callback: () => {
            _ComfyApp.pasteFromClipspace(this);
          }
        });
      }
      if (_ComfyApp.isImageNode(this)) {
        options3.push({
          content: "Open in MaskEditor",
          callback: (obj) => {
            _ComfyApp.copyToClipspace(this);
            _ComfyApp.clipspace_return_node = this;
            _ComfyApp.open_maskeditor();
          }
        });
      }
    }
  };
};
addNodeKeyHandler_fn = function(node3) {
  const app2 = this;
  const origNodeOnKeyDown = node3.prototype.onKeyDown;
  node3.prototype.onKeyDown = function(e) {
    if (origNodeOnKeyDown && origNodeOnKeyDown.apply(this, e) === false) {
      return false;
    }
    if (this.flags.collapsed || !this.imgs || this.imageIndex === null) {
      return;
    }
    let handled = false;
    if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
      if (e.key === "ArrowLeft") {
        this.imageIndex -= 1;
      } else if (e.key === "ArrowRight") {
        this.imageIndex += 1;
      }
      this.imageIndex %= this.imgs.length;
      if (this.imageIndex < 0) {
        this.imageIndex = this.imgs.length + this.imageIndex;
      }
      handled = true;
    } else if (e.key === "Escape") {
      this.imageIndex = null;
      handled = true;
    }
    if (handled === true) {
      e.preventDefault();
      e.stopImmediatePropagation();
      return false;
    }
  };
};
/**
 * Adds Custom drawing logic for nodes
 * e.g. Draws images and handles thumbnail navigation on nodes that output images
 * @param {*} node The node to add the draw handler
 */
addDrawBackgroundHandler_fn = function(node3) {
  const app2 = this;
  function getImageTop(node22) {
    var _a2;
    let shiftY;
    if (node22.imageOffset != null) {
      shiftY = node22.imageOffset;
    } else {
      if ((_a2 = node22.widgets) == null ? void 0 : _a2.length) {
        const w2 = node22.widgets[node22.widgets.length - 1];
        shiftY = w2.last_y;
        if (w2.computeSize) {
          shiftY += w2.computeSize()[1] + 4;
        } else if (w2.computedHeight) {
          shiftY += w2.computedHeight;
        } else {
          shiftY += LiteGraph.NODE_WIDGET_HEIGHT + 4;
        }
      } else {
        shiftY = node22.computeSize()[1];
      }
    }
    return shiftY;
  }
  node3.prototype.setSizeForImage = function(force) {
    if (!force && this.animatedImages) return;
    if (this.inputHeight || this.freeWidgetSpace > 210) {
      this.setSize(this.size);
      return;
    }
    const minHeight = getImageTop(this) + 220;
    if (this.size[1] < minHeight) {
      this.setSize([this.size[0], minHeight]);
    }
  };
  function unsafeDrawBackground(ctx) {
    var _a2, _b, _c, _d, _e;
    if (!this.flags.collapsed) {
      let imgURLs = [];
      let imagesChanged = false;
      const output = app2.nodeOutputs[this.id + ""];
      if (output == null ? void 0 : output.images) {
        this.animatedImages = (_a2 = output == null ? void 0 : output.animated) == null ? void 0 : _a2.find(Boolean);
        if (this.images !== output.images) {
          this.images = output.images;
          imagesChanged = true;
          imgURLs = imgURLs.concat(
            output.images.map((params) => {
              return api.apiURL(
                "/view?" + new URLSearchParams(params).toString() + (this.animatedImages ? "" : app2.getPreviewFormatParam()) + app2.getRandParam()
              );
            })
          );
        }
      }
      const preview = app2.nodePreviewImages[this.id + ""];
      if (this.preview !== preview) {
        this.preview = preview;
        imagesChanged = true;
        if (preview != null) {
          imgURLs.push(preview);
        }
      }
      if (imagesChanged) {
        this.imageIndex = null;
        if (imgURLs.length > 0) {
          Promise.all(
            imgURLs.map((src) => {
              return new Promise((r) => {
                const img = new Image();
                img.onload = () => r(img);
                img.onerror = () => r(null);
                img.src = src;
              });
            })
          ).then((imgs) => {
            var _a3;
            if ((!output || this.images === output.images) && (!preview || this.preview === preview)) {
              this.imgs = imgs.filter(Boolean);
              (_a3 = this.setSizeForImage) == null ? void 0 : _a3.call(this);
              app2.graph.setDirtyCanvas(true);
            }
          });
        } else {
          this.imgs = null;
        }
      }
      const calculateGrid = (w2, h2, n) => {
        let columns2, rows3, cellsize;
        if (w2 > h2) {
          cellsize = h2;
          columns2 = Math.ceil(w2 / cellsize);
          rows3 = Math.ceil(n / columns2);
        } else {
          cellsize = w2;
          rows3 = Math.ceil(h2 / cellsize);
          columns2 = Math.ceil(n / rows3);
        }
        while (columns2 * rows3 < n) {
          cellsize++;
          if (w2 >= h2) {
            columns2 = Math.ceil(w2 / cellsize);
            rows3 = Math.ceil(n / columns2);
          } else {
            rows3 = Math.ceil(h2 / cellsize);
            columns2 = Math.ceil(n / rows3);
          }
        }
        const cell_size = Math.min(w2 / columns2, h2 / rows3);
        return { cell_size, columns: columns2, rows: rows3 };
      };
      const is_all_same_aspect_ratio = (imgs) => {
        let ratio2 = imgs[0].naturalWidth / imgs[0].naturalHeight;
        for (let i2 = 1; i2 < imgs.length; i2++) {
          let this_ratio = imgs[i2].naturalWidth / imgs[i2].naturalHeight;
          if (ratio2 != this_ratio) return false;
        }
        return true;
      };
      if ((_b = this.imgs) == null ? void 0 : _b.length) {
        const widgetIdx = (_c = this.widgets) == null ? void 0 : _c.findIndex(
          (w2) => w2.name === ANIM_PREVIEW_WIDGET
        );
        if (this.animatedImages) {
          if (widgetIdx > -1) {
            const widget = this.widgets[widgetIdx];
            widget.options.host.updateImages(this.imgs);
          } else {
            const host = createImageHost(this);
            this.setSizeForImage(true);
            const widget = this.addDOMWidget(
              ANIM_PREVIEW_WIDGET,
              "img",
              host.el,
              {
                host,
                getHeight: host.getHeight,
                onDraw: host.onDraw,
                hideOnZoom: false
              }
            );
            widget.serializeValue = () => void 0;
            widget.options.host.updateImages(this.imgs);
          }
          return;
        }
        if (widgetIdx > -1) {
          (_e = (_d = this.widgets[widgetIdx]).onRemove) == null ? void 0 : _e.call(_d);
          this.widgets.splice(widgetIdx, 1);
        }
        const canvas = app2.graph.list_of_graphcanvas[0];
        const mouse = canvas.graph_mouse;
        if (!canvas.pointer_is_down && this.pointerDown) {
          if (mouse[0] === this.pointerDown.pos[0] && mouse[1] === this.pointerDown.pos[1]) {
            this.imageIndex = this.pointerDown.index;
          }
          this.pointerDown = null;
        }
        let imageIndex = this.imageIndex;
        const numImages = this.imgs.length;
        if (numImages === 1 && !imageIndex) {
          this.imageIndex = imageIndex = 0;
        }
        const top = getImageTop(this);
        var shiftY = top;
        let dw = this.size[0];
        let dh = this.size[1];
        dh -= shiftY;
        if (imageIndex == null) {
          var cellWidth, cellHeight, shiftX, cell_padding, cols;
          const compact_mode = is_all_same_aspect_ratio(this.imgs);
          if (!compact_mode) {
            cell_padding = 2;
            const { cell_size, columns: columns2, rows: rows3 } = calculateGrid(
              dw,
              dh,
              numImages
            );
            cols = columns2;
            cellWidth = cell_size;
            cellHeight = cell_size;
            shiftX = (dw - cell_size * cols) / 2;
            shiftY = (dh - cell_size * rows3) / 2 + top;
          } else {
            cell_padding = 0;
            ({ cellWidth, cellHeight, cols, shiftX } = calculateImageGrid(
              this.imgs,
              dw,
              dh
            ));
          }
          let anyHovered = false;
          this.imageRects = [];
          for (let i2 = 0; i2 < numImages; i2++) {
            const img = this.imgs[i2];
            const row2 = Math.floor(i2 / cols);
            const col = i2 % cols;
            const x2 = col * cellWidth + shiftX;
            const y2 = row2 * cellHeight + shiftY;
            if (!anyHovered) {
              anyHovered = LiteGraph.isInsideRectangle(
                mouse[0],
                mouse[1],
                x2 + this.pos[0],
                y2 + this.pos[1],
                cellWidth,
                cellHeight
              );
              if (anyHovered) {
                this.overIndex = i2;
                let value3 = 110;
                if (canvas.pointer_is_down) {
                  if (!this.pointerDown || this.pointerDown.index !== i2) {
                    this.pointerDown = { index: i2, pos: [...mouse] };
                  }
                  value3 = 125;
                }
                ctx.filter = `contrast(${value3}%) brightness(${value3}%)`;
                canvas.canvas.style.cursor = "pointer";
              }
            }
            this.imageRects.push([x2, y2, cellWidth, cellHeight]);
            let wratio = cellWidth / img.width;
            let hratio = cellHeight / img.height;
            var ratio = Math.min(wratio, hratio);
            let imgHeight = ratio * img.height;
            let imgY = row2 * cellHeight + shiftY + (cellHeight - imgHeight) / 2;
            let imgWidth = ratio * img.width;
            let imgX = col * cellWidth + shiftX + (cellWidth - imgWidth) / 2;
            ctx.drawImage(
              img,
              imgX + cell_padding,
              imgY + cell_padding,
              imgWidth - cell_padding * 2,
              imgHeight - cell_padding * 2
            );
            if (!compact_mode) {
              ctx.strokeStyle = "#8F8F8F";
              ctx.lineWidth = 1;
              ctx.strokeRect(
                x2 + cell_padding,
                y2 + cell_padding,
                cellWidth - cell_padding * 2,
                cellHeight - cell_padding * 2
              );
            }
            ctx.filter = "none";
          }
          if (!anyHovered) {
            this.pointerDown = null;
            this.overIndex = null;
          }
        } else {
          let w2 = this.imgs[imageIndex].naturalWidth;
          let h2 = this.imgs[imageIndex].naturalHeight;
          const scaleX = dw / w2;
          const scaleY = dh / h2;
          const scale = Math.min(scaleX, scaleY, 1);
          w2 *= scale;
          h2 *= scale;
          let x2 = (dw - w2) / 2;
          let y2 = (dh - h2) / 2 + shiftY;
          ctx.drawImage(this.imgs[imageIndex], x2, y2, w2, h2);
          const drawButton = (x22, y22, sz, text2) => {
            const hovered = LiteGraph.isInsideRectangle(
              mouse[0],
              mouse[1],
              x22 + this.pos[0],
              y22 + this.pos[1],
              sz,
              sz
            );
            let fill = "#333";
            let textFill = "#fff";
            let isClicking = false;
            if (hovered) {
              canvas.canvas.style.cursor = "pointer";
              if (canvas.pointer_is_down) {
                fill = "#1e90ff";
                isClicking = true;
              } else {
                fill = "#eee";
                textFill = "#000";
              }
            } else {
              this.pointerWasDown = null;
            }
            ctx.fillStyle = fill;
            ctx.beginPath();
            ctx.roundRect(x22, y22, sz, sz, [4]);
            ctx.fill();
            ctx.fillStyle = textFill;
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.fillText(text2, x22 + 15, y22 + 20);
            return isClicking;
          };
          if (numImages > 1) {
            if (drawButton(
              dw - 40,
              dh + top - 40,
              30,
              `${this.imageIndex + 1}/${numImages}`
            )) {
              let i2 = this.imageIndex + 1 >= numImages ? 0 : this.imageIndex + 1;
              if (!this.pointerDown || !this.pointerDown.index === i2) {
                this.pointerDown = { index: i2, pos: [...mouse] };
              }
            }
            if (drawButton(dw - 40, top + 10, 30, `x`)) {
              if (!this.pointerDown || !this.pointerDown.index === null) {
                this.pointerDown = { index: null, pos: [...mouse] };
              }
            }
          }
        }
      }
    }
  }
  node3.prototype.onDrawBackground = function(ctx) {
    try {
      unsafeDrawBackground.call(this, ctx);
    } catch (error) {
      console.error("Error drawing node background", error);
    }
  };
};
/**
 * Adds a handler allowing drag+drop of files onto the window to load workflows
 */
addDropHandler_fn = function() {
  document.addEventListener("drop", (event2) => __async(this, null, function* () {
    var _a2, _b;
    event2.preventDefault();
    event2.stopPropagation();
    const n = this.dragOverNode;
    this.dragOverNode = null;
    if (n && n.onDragDrop && (yield n.onDragDrop(event2))) {
      return;
    }
    if (event2.dataTransfer.files.length && event2.dataTransfer.files[0].type !== "image/bmp") {
      yield this.handleFile(event2.dataTransfer.files[0]);
    } else {
      const validTypes = ["text/uri-list", "text/x-moz-url"];
      const match = [...event2.dataTransfer.types].find(
        (t) => validTypes.find((v2) => t === v2)
      );
      if (match) {
        const uri = (_b = (_a2 = event2.dataTransfer.getData(match)) == null ? void 0 : _a2.split("\n")) == null ? void 0 : _b[0];
        if (uri) {
          yield this.handleFile(yield (yield fetch(uri)).blob());
        }
      }
    }
  }));
  this.canvasEl.addEventListener("dragleave", () => __async(this, null, function* () {
    if (this.dragOverNode) {
      this.dragOverNode = null;
      this.graph.setDirtyCanvas(false, true);
    }
  }));
  this.canvasEl.addEventListener(
    "dragover",
    (e) => {
      this.canvas.adjustMouseEvent(e);
      const node3 = this.graph.getNodeOnPos(e.canvasX, e.canvasY);
      if (node3) {
        if (node3.onDragOver && node3.onDragOver(e)) {
          this.dragOverNode = node3;
          requestAnimationFrame(() => {
            this.graph.setDirtyCanvas(false, true);
          });
          return;
        }
      }
      this.dragOverNode = null;
    },
    false
  );
};
/**
 * Adds a handler on paste that extracts and loads images or workflows from pasted JSON data
 */
addPasteHandler_fn = function() {
  document.addEventListener("paste", (e) => __async(this, null, function* () {
    if (this.shiftDown) return;
    let data28 = e.clipboardData || window.clipboardData;
    const items2 = data28.items;
    for (const item of items2) {
      if (item.type.startsWith("image/")) {
        var imageNode = null;
        if (this.canvas.current_node && this.canvas.current_node.is_selected && _ComfyApp.isImageNode(this.canvas.current_node)) {
          imageNode = this.canvas.current_node;
        }
        if (!imageNode) {
          const newNode = LiteGraph.createNode("LoadImage");
          newNode.pos = [...this.canvas.graph_mouse];
          imageNode = this.graph.add(newNode);
          this.graph.change();
        }
        const blob = item.getAsFile();
        imageNode.pasteFile(blob);
        return;
      }
    }
    data28 = data28.getData("text/plain");
    let workflow;
    try {
      data28 = data28.slice(data28.indexOf("{"));
      workflow = JSON.parse(data28);
    } catch (err) {
      try {
        data28 = data28.slice(data28.indexOf("workflow\n"));
        data28 = data28.slice(data28.indexOf("{"));
        workflow = JSON.parse(data28);
      } catch (error) {
        console.error(error);
      }
    }
    if (workflow && workflow.version && workflow.nodes && workflow.extra) {
      yield this.loadGraphData(workflow);
    } else {
      if (e.target instanceof HTMLTextAreaElement && e.target.type === "textarea" || e.target instanceof HTMLInputElement && e.target.type === "text") {
        return;
      }
      this.canvas.pasteFromClipboard();
    }
  }));
};
/**
 * Adds a handler on copy that serializes selected nodes to JSON
 */
addCopyHandler_fn = function() {
  document.addEventListener("copy", (e) => {
    if (!(e.target instanceof Element)) {
      return;
    }
    if (e.target instanceof HTMLTextAreaElement && e.target.type === "textarea" || e.target instanceof HTMLInputElement && e.target.type === "text") {
      return;
    }
    const isTargetInGraph = e.target.classList.contains("litegraph") || e.target.classList.contains("graph-canvas-container");
    if (isTargetInGraph && this.canvas.selected_nodes) {
      this.canvas.copyToClipboard();
      e.clipboardData.setData("text", " ");
      e.preventDefault();
      e.stopImmediatePropagation();
      return false;
    }
  });
};
/**
 * Handle mouse
 *
 * Move group by header
 */
addProcessMouseHandler_fn = function() {
  const self2 = this;
  const origProcessMouseDown = LGraphCanvas.prototype.processMouseDown;
  LGraphCanvas.prototype.processMouseDown = function(e) {
    if (e.ctrlKey && e.shiftKey && e.buttons) {
      self2.zoom_drag_start = [e.x, e.y, this.ds.scale];
      return;
    }
    const res = origProcessMouseDown.apply(this, arguments);
    this.selected_group_moving = false;
    if (this.selected_group && !this.selected_group_resizing) {
      var font_size = this.selected_group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
      var height = font_size * 1.4;
      if (LiteGraph.isInsideRectangle(
        // @ts-expect-error
        e.canvasX,
        // @ts-expect-error
        e.canvasY,
        this.selected_group.pos[0],
        this.selected_group.pos[1],
        this.selected_group.size[0],
        height
      )) {
        this.selected_group_moving = true;
      }
    }
    return res;
  };
  const origProcessMouseMove = LGraphCanvas.prototype.processMouseMove;
  LGraphCanvas.prototype.processMouseMove = function(e) {
    if (e.ctrlKey && e.shiftKey && self2.zoom_drag_start) {
      if (!e.buttons) {
        self2.zoom_drag_start = null;
        return;
      }
      let deltaY = e.y - self2.zoom_drag_start[1];
      let startScale = self2.zoom_drag_start[2];
      let scale = startScale - deltaY / 100;
      this.ds.changeScale(scale, [
        this.ds.element.width / 2,
        this.ds.element.height / 2
      ]);
      this.graph.change();
      return;
    }
    const orig_selected_group = this.selected_group;
    if (this.selected_group && !this.selected_group_resizing && !this.selected_group_moving) {
      this.selected_group = null;
    }
    const res = origProcessMouseMove.apply(this, arguments);
    if (orig_selected_group && !this.selected_group_resizing && !this.selected_group_moving) {
      this.selected_group = orig_selected_group;
    }
    return res;
  };
};
/**
 * Handle keypress
 *
 * Ctrl + M mute/unmute selected nodes
 */
addProcessKeyHandler_fn = function() {
  const self2 = this;
  const origProcessKey = LGraphCanvas.prototype.processKey;
  LGraphCanvas.prototype.processKey = function(e) {
    if (!this.graph) {
      return;
    }
    var block_default = false;
    if (e.target instanceof Element && e.target.localName == "input") {
      return;
    }
    if (e.type == "keydown" && !e.repeat) {
      if (e.key === "m" && e.ctrlKey) {
        if (this.selected_nodes) {
          for (var i2 in this.selected_nodes) {
            if (this.selected_nodes[i2].mode === 2) {
              this.selected_nodes[i2].mode = 0;
            } else {
              this.selected_nodes[i2].mode = 2;
            }
          }
        }
        block_default = true;
      }
      if (e.key === "b" && e.ctrlKey) {
        if (this.selected_nodes) {
          for (var i2 in this.selected_nodes) {
            if (this.selected_nodes[i2].mode === 4) {
              this.selected_nodes[i2].mode = 0;
            } else {
              this.selected_nodes[i2].mode = 4;
            }
          }
        }
        block_default = true;
      }
      if (e.key === "c" && e.altKey) {
        if (this.selected_nodes) {
          for (var i2 in this.selected_nodes) {
            this.selected_nodes[i2].collapse();
          }
        }
        block_default = true;
      }
      if (e.key === "c" && (e.metaKey || e.ctrlKey)) {
        return true;
      }
      if ((e.key === "v" || e.key == "V") && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
        return true;
      }
      if (e.key === "+" && e.altKey) {
        block_default = true;
        let scale = this.ds.scale * 1.1;
        this.ds.changeScale(scale, [
          this.ds.element.width / 2,
          this.ds.element.height / 2
        ]);
        this.graph.change();
      }
      if (e.key === "-" && e.altKey) {
        block_default = true;
        let scale = this.ds.scale * 1 / 1.1;
        this.ds.changeScale(scale, [
          this.ds.element.width / 2,
          this.ds.element.height / 2
        ]);
        this.graph.change();
      }
    }
    this.graph.change();
    if (block_default) {
      e.preventDefault();
      e.stopImmediatePropagation();
      return false;
    }
    return origProcessKey.apply(this, arguments);
  };
};
/**
 * Draws group header bar
 */
addDrawGroupsHandler_fn = function() {
  const self2 = this;
  const origDrawGroups = LGraphCanvas.prototype.drawGroups;
  LGraphCanvas.prototype.drawGroups = function(canvas, ctx) {
    if (!this.graph) {
      return;
    }
    var groups = this.graph._groups;
    ctx.save();
    ctx.globalAlpha = 0.7 * this.editor_alpha;
    for (var i2 = 0; i2 < groups.length; ++i2) {
      var group = groups[i2];
      if (!LiteGraph.overlapBounding(this.visible_area, group._bounding)) {
        continue;
      }
      ctx.fillStyle = group.color || "#335";
      ctx.strokeStyle = group.color || "#335";
      var pos2 = group._pos;
      var size2 = group._size;
      ctx.globalAlpha = 0.25 * this.editor_alpha;
      ctx.beginPath();
      var font_size = group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
      ctx.rect(pos2[0] + 0.5, pos2[1] + 0.5, size2[0], font_size * 1.4);
      ctx.fill();
      ctx.globalAlpha = this.editor_alpha;
    }
    ctx.restore();
    const res = origDrawGroups.apply(this, arguments);
    return res;
  };
};
/**
 * Draws node highlights (executing, drag drop) and progress bar
 */
addDrawNodeHandler_fn = function() {
  const origDrawNodeShape = LGraphCanvas.prototype.drawNodeShape;
  const self2 = this;
  LGraphCanvas.prototype.drawNodeShape = function(node3, ctx, size2, fgcolor, bgcolor, selected2, mouse_over) {
    var _a2;
    const res = origDrawNodeShape.apply(this, arguments);
    const nodeErrors = (_a2 = self2.lastNodeErrors) == null ? void 0 : _a2[node3.id];
    let color = null;
    let lineWidth = 1;
    if (node3.id === +self2.runningNodeId) {
      color = "#0f0";
    } else if (self2.dragOverNode && node3.id === self2.dragOverNode.id) {
      color = "dodgerblue";
    } else if (nodeErrors == null ? void 0 : nodeErrors.errors) {
      color = "red";
      lineWidth = 2;
    } else if (self2.lastExecutionError && +self2.lastExecutionError.node_id === node3.id) {
      color = "#f0f";
      lineWidth = 2;
    }
    if (color) {
      const shape = (
        // @ts-expect-error
        node3._shape || node3.constructor.shape || LiteGraph.ROUND_SHAPE
      );
      ctx.lineWidth = lineWidth;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      if (shape == LiteGraph.BOX_SHAPE)
        ctx.rect(
          -6,
          -6 - LiteGraph.NODE_TITLE_HEIGHT,
          12 + size2[0] + 1,
          12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT
        );
      else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE && node3.flags.collapsed)
        ctx.roundRect(
          -6,
          -6 - LiteGraph.NODE_TITLE_HEIGHT,
          12 + size2[0] + 1,
          12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT,
          this.round_radius * 2
        );
      else if (shape == LiteGraph.CARD_SHAPE)
        ctx.roundRect(
          -6,
          -6 - LiteGraph.NODE_TITLE_HEIGHT,
          12 + size2[0] + 1,
          12 + size2[1] + LiteGraph.NODE_TITLE_HEIGHT,
          [this.round_radius * 2, this.round_radius * 2, 2, 2]
        );
      else if (shape == LiteGraph.CIRCLE_SHAPE)
        ctx.arc(
          size2[0] * 0.5,
          size2[1] * 0.5,
          size2[0] * 0.5 + 6,
          0,
          Math.PI * 2
        );
      ctx.strokeStyle = color;
      ctx.stroke();
      ctx.strokeStyle = fgcolor;
      ctx.globalAlpha = 1;
    }
    if (self2.progress && node3.id === +self2.runningNodeId) {
      ctx.fillStyle = "green";
      ctx.fillRect(
        0,
        0,
        size2[0] * (self2.progress.value / self2.progress.max),
        6
      );
      ctx.fillStyle = bgcolor;
    }
    if (nodeErrors) {
      ctx.lineWidth = 2;
      ctx.strokeStyle = "red";
      for (const error of nodeErrors.errors) {
        if (error.extra_info && error.extra_info.input_name) {
          const inputIndex = node3.findInputSlot(error.extra_info.input_name);
          if (inputIndex !== -1) {
            let pos2 = node3.getConnectionPos(true, inputIndex);
            ctx.beginPath();
            ctx.arc(
              pos2[0] - node3.pos[0],
              pos2[1] - node3.pos[1],
              12,
              0,
              2 * Math.PI,
              false
            );
            ctx.stroke();
          }
        }
      }
    }
    return res;
  };
  const origDrawNode = LGraphCanvas.prototype.drawNode;
  LGraphCanvas.prototype.drawNode = function(node3, ctx) {
    var editor_alpha = this.editor_alpha;
    var old_color = node3.color;
    var old_bgcolor = node3.bgcolor;
    if (node3.mode === 2) {
      this.editor_alpha = 0.4;
    }
    if (node3.mode === 4) {
      node3.bgcolor = "#FF00FF";
      this.editor_alpha = 0.2;
    }
    const adjustColor = (color) => {
      return color ? lightenColor(color, 0.5) : color;
    };
    if (app$1.ui.settings.getSettingValue("Comfy.ColorPalette") === "light") {
      node3.bgcolor = adjustColor(node3.bgcolor);
      node3.color = adjustColor(node3.color);
    }
    const res = origDrawNode.apply(this, arguments);
    this.editor_alpha = editor_alpha;
    node3.color = old_color;
    node3.bgcolor = old_bgcolor;
    return res;
  };
};
/**
 * Handles updates from the API socket
 */
addApiUpdateHandlers_fn = function() {
  api.addEventListener(
    "status",
    ({ detail }) => {
      this.ui.setStatus(detail);
    }
  );
  api.addEventListener("reconnecting", () => {
    this.ui.dialog.show("Reconnecting...");
  });
  api.addEventListener("reconnected", () => {
    this.ui.dialog.close();
  });
  api.addEventListener("progress", ({ detail }) => {
    var _a2;
    if (((_a2 = this.workflowManager.activePrompt) == null ? void 0 : _a2.workflow) && this.workflowManager.activePrompt.workflow !== this.workflowManager.activeWorkflow)
      return;
    this.progress = detail;
    this.graph.setDirtyCanvas(true, false);
  });
  api.addEventListener("executing", ({ detail }) => {
    var _a2;
    if (((_a2 = this.workflowManager.activePrompt) == null ? void 0 : _a2.workflow) && this.workflowManager.activePrompt.workflow !== this.workflowManager.activeWorkflow)
      return;
    this.progress = null;
    this.runningNodeId = detail;
    this.graph.setDirtyCanvas(true, false);
    delete this.nodePreviewImages[this.runningNodeId];
  });
  api.addEventListener("executed", ({ detail }) => {
    var _a2, _b;
    if (((_a2 = this.workflowManager.activePrompt) == null ? void 0 : _a2.workflow) && this.workflowManager.activePrompt.workflow !== this.workflowManager.activeWorkflow)
      return;
    const output = this.nodeOutputs[detail.display_node || detail.node];
    if (detail.merge && output) {
      for (const k in (_b = detail.output) != null ? _b : {}) {
        const v2 = output[k];
        if (v2 instanceof Array) {
          output[k] = v2.concat(detail.output[k]);
        } else {
          output[k] = detail.output[k];
        }
      }
    } else {
      this.nodeOutputs[detail.display_node || detail.node] = detail.output;
    }
    const node3 = this.graph.getNodeById(detail.display_node || detail.node);
    if (node3) {
      if (node3.onExecuted)
        node3.onExecuted(detail.output);
    }
  });
  api.addEventListener("execution_start", ({ detail }) => {
    this.runningNodeId = null;
    this.lastExecutionError = null;
    this.graph._nodes.forEach((node3) => {
      if (node3.onExecutionStart)
        node3.onExecutionStart();
    });
  });
  api.addEventListener("execution_error", ({ detail }) => {
    this.lastExecutionError = detail;
    const formattedError = __privateMethod(this, _ComfyApp_instances, formatExecutionError_fn).call(this, detail);
    this.ui.dialog.show(formattedError);
    this.canvas.draw(true, true);
  });
  api.addEventListener("b_preview", ({ detail }) => {
    const id2 = this.runningNodeId;
    if (id2 == null) return;
    const blob = detail;
    const blobUrl = URL.createObjectURL(blob);
    this.nodePreviewImages[id2] = [blobUrl];
  });
  api.init();
};
addKeyboardHandler_fn = function() {
  window.addEventListener("keydown", (e) => {
    this.shiftDown = e.shiftKey;
  });
  window.addEventListener("keyup", (e) => {
    this.shiftDown = e.shiftKey;
  });
};
addConfigureHandler_fn = function() {
  const app2 = this;
  const configure = LGraph.prototype.configure;
  LGraph.prototype.configure = function() {
    app2.configuringGraph = true;
    try {
      return configure.apply(this, arguments);
    } finally {
      app2.configuringGraph = false;
    }
  };
};
addAfterConfigureHandler_fn = function() {
  const app2 = this;
  const onConfigure = app2.graph.onConfigure;
  app2.graph.onConfigure = function() {
    var _a2, _b;
    for (const node3 of app2.graph._nodes) {
      (_a2 = node3.onGraphConfigured) == null ? void 0 : _a2.call(node3);
    }
    const r = onConfigure == null ? void 0 : onConfigure.apply(this, arguments);
    for (const node3 of app2.graph._nodes) {
      (_b = node3.onAfterGraphConfigured) == null ? void 0 : _b.call(node3);
    }
    return r;
  };
};
loadExtensions_fn = function() {
  return __async(this, null, function* () {
    const extensions = yield api.getExtensions();
    this.logging.addEntry("Comfy.App", "debug", { Extensions: extensions });
    yield __vitePreload(() => import("./index-DJRcbqp_.js"), true ? __vite__mapDeps([0,1]) : void 0);
    yield Promise.all(
      extensions.filter((extension) => !extension.includes("extensions/core")).map((ext) => __async(this, null, function* () {
        try {
          yield import(
            /* @vite-ignore */
            api.fileURL(ext)
          );
        } catch (error) {
          console.error("Error loading extension", ext, error);
        }
      }))
    );
    try {
      this.menu.workflows.registerExtension(this);
    } catch (error) {
      console.error(error);
    }
  });
};
migrateSettings_fn = function() {
  return __async(this, null, function* () {
    this.isNewUserSession = true;
    const settings = Object.keys(this.ui.settings).reduce((p2, n) => {
      const v2 = localStorage[`Comfy.Settings.${n}`];
      if (v2) {
        try {
          p2[n] = JSON.parse(v2);
        } catch (error) {
        }
      }
      return p2;
    }, {});
    yield api.storeSettings(settings);
  });
};
setUser_fn = function() {
  return __async(this, null, function* () {
    var _a2;
    const userConfig = yield api.getUserConfig();
    this.storageLocation = userConfig.storage;
    if (typeof userConfig.migrated == "boolean") {
      if (!userConfig.migrated && this.storageLocation === "server") {
        yield __privateMethod(this, _ComfyApp_instances, migrateSettings_fn).call(this);
      }
      return;
    }
    this.multiUserServer = true;
    let user = localStorage["Comfy.userId"];
    const users = (_a2 = userConfig.users) != null ? _a2 : {};
    if (!user || !users[user]) {
      const { UserSelectionScreen } = yield __vitePreload(() => __async(this, null, function* () {
        const { UserSelectionScreen: UserSelectionScreen2 } = yield import("./userSelection-BifVfRyx.js");
        return { UserSelectionScreen: UserSelectionScreen2 };
      }), true ? __vite__mapDeps([2,3]) : void 0);
      this.ui.menuContainer.style.display = "none";
      const { userId, username, created: created3 } = yield new UserSelectionScreen().show(users, user);
      this.ui.menuContainer.style.display = "";
      user = userId;
      localStorage["Comfy.userName"] = username;
      localStorage["Comfy.userId"] = user;
      if (created3) {
        api.user = user;
        yield __privateMethod(this, _ComfyApp_instances, migrateSettings_fn).call(this);
      }
    }
    api.user = user;
    this.ui.settings.addSetting({
      id: "Comfy.SwitchUser",
      name: "Switch User",
      type: (name) => {
        let currentUser = localStorage["Comfy.userName"];
        if (currentUser) {
          currentUser = ` (${currentUser})`;
        }
        return $el("tr", [
          $el("td", [
            $el("label", {
              textContent: name
            })
          ]),
          $el("td", [
            $el("button", {
              textContent: name + (currentUser != null ? currentUser : ""),
              onclick: () => {
                delete localStorage["Comfy.userId"];
                delete localStorage["Comfy.userName"];
                window.location.reload();
              }
            })
          ])
        ]);
      },
      // TODO: Is that the correct default value?
      defaultValue: void 0
    });
  });
};
formatPromptError_fn = function(error) {
  if (error == null) {
    return "(unknown error)";
  } else if (typeof error === "string") {
    return error;
  } else if (error.stack && error.message) {
    return error.toString();
  } else if (error.response) {
    let message3 = error.response.error.message;
    if (error.response.error.details)
      message3 += ": " + error.response.error.details;
    for (const [nodeID, nodeError] of Object.entries(
      error.response.node_errors
    )) {
      message3 += "\n" + nodeError.class_type + ":";
      for (const errorReason of nodeError.errors) {
        message3 += "\n    - " + errorReason.message + ": " + errorReason.details;
      }
    }
    return message3;
  }
  return "(unknown error)";
};
formatExecutionError_fn = function(error) {
  if (error == null) {
    return "(unknown error)";
  }
  const traceback = error.traceback.join("");
  const nodeId = error.node_id;
  const nodeType = error.node_type;
  return `Error occurred when executing ${nodeType}:

${error.exception_message}

${traceback}`;
};
/**
 * Content Clipboard
 * @type {serialized node object}
 */
__publicField2(_ComfyApp, "clipspace", null);
__publicField2(_ComfyApp, "clipspace_invalidate_handler", null);
__publicField2(_ComfyApp, "open_maskeditor", null);
__publicField2(_ComfyApp, "clipspace_return_node", null);
// Force vite to import utils.ts as part of index.
// Force import of DraggableList.
__publicField2(_ComfyApp, "utils", {
  applyTextReplacements,
  addStylesheet,
  DraggableList
});
let ComfyApp = _ComfyApp;
const app$1 = new ComfyApp();
window.comfyAPI = window.comfyAPI || {};
window.comfyAPI.app = window.comfyAPI.app || {};
window.comfyAPI.app.ANIM_PREVIEW_WIDGET = ANIM_PREVIEW_WIDGET;
window.comfyAPI.app.ComfyApp = ComfyApp;
window.comfyAPI.app.app = app$1;
var LinkReleaseTriggerMode = /* @__PURE__ */ ((LinkReleaseTriggerMode2) => {
  LinkReleaseTriggerMode2["ALWAYS"] = "always";
  LinkReleaseTriggerMode2["HOLD_SHIFT"] = "hold shift";
  LinkReleaseTriggerMode2["NOT_HOLD_SHIFT"] = "NOT hold shift";
  return LinkReleaseTriggerMode2;
})(LinkReleaseTriggerMode || {});
const useSettingStore = defineStore("setting", {
  state: () => ({
    settingValues: {},
    settings: {}
  }),
  getters: {
    settingTree() {
      const root27 = buildTree(
        Object.values(this.settings),
        (setting) => setting.id.split(".")
      );
      const floatingSettings = root27.children.filter((node3) => node3.leaf);
      if (floatingSettings.length) {
        root27.children = root27.children.filter((node3) => !node3.leaf);
        root27.children.push({
          key: "Other",
          label: "Other",
          leaf: false,
          children: floatingSettings
        });
      }
      return root27;
    }
  },
  actions: {
    addSettings(settings) {
      for (const id2 in settings.settingsLookup) {
        const value3 = settings.getSettingValue(id2);
        this.settingValues[id2] = value3;
      }
      this.settings = settings.settingsParamLookup;
      app$1.ui.settings.addSetting({
        id: "Comfy.Validation.Workflows",
        name: "Validate workflows",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeSearchBoxImpl",
        name: "Node Search box implementation",
        type: "combo",
        options: ["default", "litegraph (legacy)"],
        defaultValue: "default"
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeSearchBoxImpl.LinkReleaseTrigger",
        name: "Trigger on link release",
        tooltip: "Only applies to the default implementation",
        type: "combo",
        options: Object.values(LinkReleaseTriggerMode),
        defaultValue: LinkReleaseTriggerMode.ALWAYS
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.NodeSearchBoxImpl.NodePreview",
        name: "Node Preview",
        tooltip: "Only applies to the default implementation",
        type: "boolean",
        defaultValue: true
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Sidebar.Location",
        name: "Sidebar location",
        type: "combo",
        options: ["left", "right"],
        defaultValue: "left"
      });
      app$1.ui.settings.addSetting({
        id: "Comfy.Sidebar.Size",
        name: "Sidebar size",
        type: "combo",
        options: ["normal", "small"],
        defaultValue: window.innerWidth < 1600 ? "small" : "normal"
      });
    },
    set(key, value3) {
      this.settingValues[key] = value3;
      app$1.ui.settings.setSettingValue(key, value3);
    },
    get(key) {
      var _a2;
      return (_a2 = this.settingValues[key]) != null ? _a2 : app$1.ui.settings.getSettingDefaultValue(key);
    }
  }
});
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "SidebarThemeToggleIcon",
  setup(__props) {
    const previousDarkTheme = ref("dark");
    const currentTheme = computed(() => useSettingStore().get("Comfy.ColorPalette"));
    const isDarkMode = computed(() => currentTheme.value !== "light");
    const icon2 = computed(() => isDarkMode.value ? "pi pi-moon" : "pi pi-sun");
    const toggleTheme = () => {
      if (isDarkMode.value) {
        previousDarkTheme.value = currentTheme.value;
        useSettingStore().set("Comfy.ColorPalette", "light");
      } else {
        useSettingStore().set("Comfy.ColorPalette", previousDarkTheme.value);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(SidebarIcon, {
        icon: icon2.value,
        onClick: toggleTheme,
        tooltip: _ctx.$t("sideToolbar.themeToggle"),
        class: "comfy-vue-theme-toggle"
      }, null, 8, ["icon", "tooltip"]);
    };
  }
});
var theme$l = function theme14(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-tabs {\n    display: flex;\n    flex-direction: column;\n}\n\n.p-tablist {\n    position: relative;\n}\n\n.p-tabs-scrollable > .p-tablist {\n    overflow: hidden;\n}\n\n.p-tablist-viewport {\n    overflow-x: auto;\n    overflow-y: hidden;\n    scroll-behavior: smooth;\n    scrollbar-width: none;\n    overscroll-behavior: contain auto;\n}\n\n.p-tablist-viewport::-webkit-scrollbar {\n    display: none;\n}\n\n.p-tablist-tab-list {\n    position: relative;\n    display: flex;\n    background: ".concat(dt3("tabs.tablist.background"), ";\n    border-style: solid;\n    border-color: ").concat(dt3("tabs.tablist.border.color"), ";\n    border-width: ").concat(dt3("tabs.tablist.border.width"), ";\n}\n\n.p-tablist-nav-button {\n    all: unset;\n    position: absolute;\n    top: 0;\n    z-index: 2;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: ").concat(dt3("tabs.nav.button.background"), ";\n    color: ").concat(dt3("tabs.nav.button.color"), ";\n    width: ").concat(dt3("tabs.nav.button.width"), ";\n    transition: color ").concat(dt3("tabs.transition.duration"), ", outline-color ").concat(dt3("tabs.transition.duration"), ", box-shadow ").concat(dt3("tabs.transition.duration"), ";\n    box-shadow: ").concat(dt3("tabs.nav.button.shadow"), ";\n    outline-color: transparent;\n    cursor: pointer;\n}\n\n.p-tablist-nav-button:focus-visible {\n    z-index: 1;\n    box-shadow: ").concat(dt3("tabs.nav.button.focus.ring.shadow"), ";\n    outline: ").concat(dt3("tabs.nav.button.focus.ring.width"), " ").concat(dt3("tabs.nav.button.focus.ring.style"), " ").concat(dt3("tabs.nav.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("tabs.nav.button.focus.ring.offset"), ";\n}\n\n.p-tablist-nav-button:hover {\n    color: ").concat(dt3("tabs.nav.button.hover.color"), ";\n}\n\n.p-tablist-prev-button {\n    left: 0;\n}\n\n.p-tablist-next-button {\n    right: 0;\n}\n\n.p-tab {\n    cursor: pointer;\n    user-select: none;\n    position: relative;\n    border-style: solid;\n    white-space: nowrap;\n    background: ").concat(dt3("tabs.tab.background"), ";\n    border-width: ").concat(dt3("tabs.tab.border.width"), ";\n    border-color: ").concat(dt3("tabs.tab.border.color"), ";\n    color: ").concat(dt3("tabs.tab.color"), ";\n    padding: ").concat(dt3("tabs.tab.padding"), ";\n    font-weight: ").concat(dt3("tabs.tab.font.weight"), ";\n    transition: background ").concat(dt3("tabs.transition.duration"), ", border-color ").concat(dt3("tabs.transition.duration"), ", color ").concat(dt3("tabs.transition.duration"), ", outline-color ").concat(dt3("tabs.transition.duration"), ", box-shadow ").concat(dt3("tabs.transition.duration"), ";\n    margin: ").concat(dt3("tabs.tab.margin"), ";\n    outline-color: transparent;\n}\n\n.p-tab:not(.p-disabled):focus-visible {\n    z-index: 1;\n    box-shadow: ").concat(dt3("tabs.tab.focus.ring.shadow"), ";\n    outline: ").concat(dt3("tabs.tab.focus.ring.width"), " ").concat(dt3("tabs.tab.focus.ring.style"), " ").concat(dt3("tabs.tab.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("tabs.tab.focus.ring.offset"), ";\n}\n\n.p-tab:not(.p-tab-active):not(.p-disabled):hover {\n    background: ").concat(dt3("tabs.tab.hover.background"), ";\n    border-color: ").concat(dt3("tabs.tab.hover.border.color"), ";\n    color: ").concat(dt3("tabs.tab.hover.color"), ";\n}\n\n.p-tab-active {\n    background: ").concat(dt3("tabs.tab.active.background"), ";\n    border-color: ").concat(dt3("tabs.tab.active.border.color"), ";\n    color: ").concat(dt3("tabs.tab.active.color"), ";\n}\n\n.p-tabpanels {\n    background: ").concat(dt3("tabs.tabpanel.background"), ";\n    color: ").concat(dt3("tabs.tabpanel.color"), ";\n    padding: ").concat(dt3("tabs.tabpanel.padding"), ";\n    outline: 0 none;\n}\n\n.p-tabpanel:focus-visible {\n    box-shadow: ").concat(dt3("tabs.tabpanel.focus.ring.shadow"), ";\n    outline: ").concat(dt3("tabs.tabpanel.focus.ring.width"), " ").concat(dt3("tabs.tabpanel.focus.ring.style"), " ").concat(dt3("tabs.tabpanel.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("tabs.tabpanel.focus.ring.offset"), ";\n}\n\n.p-tablist-active-bar {\n    z-index: 1;\n    display: block;\n    position: absolute;\n    bottom: ").concat(dt3("tabs.active.bar.bottom"), ";\n    height: ").concat(dt3("tabs.active.bar.height"), ";\n    background: ").concat(dt3("tabs.active.bar.background"), ";\n    transition: 250ms cubic-bezier(0.35, 0, 0.25, 1);\n}\n");
};
var classes$o = {
  root: function root5(_ref2) {
    var props = _ref2.props;
    return ["p-tabs p-component", {
      "p-tabs-scrollable": props.scrollable
    }];
  }
};
var TabsStyle = BaseStyle.extend({
  name: "tabs",
  theme: theme$l,
  classes: classes$o
});
var script$1$p = {
  name: "BaseTabs",
  "extends": script$1a,
  props: {
    value: {
      type: String,
      "default": void 0
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    scrollable: {
      type: Boolean,
      "default": false
    },
    showNavigators: {
      type: Boolean,
      "default": true
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    }
  },
  style: TabsStyle,
  provide: function provide13() {
    return {
      $pcTabs: this,
      $parentInstance: this
    };
  }
};
var script$W = {
  name: "Tabs",
  "extends": script$1$p,
  inheritAttrs: false,
  emits: ["update:value"],
  data: function data4() {
    return {
      id: this.$attrs.id,
      d_value: this.value
    };
  },
  watch: {
    "$attrs.id": function $attrsId2(newValue) {
      this.id = newValue || UniqueComponentId();
    },
    value: function value(newValue) {
      this.d_value = newValue;
    }
  },
  mounted: function mounted5() {
    this.id = this.id || UniqueComponentId();
  },
  methods: {
    updateValue: function updateValue(newValue) {
      if (this.d_value !== newValue) {
        this.d_value = newValue;
        this.$emit("update:value", newValue);
      }
    },
    isVertical: function isVertical2() {
      return this.orientation === "vertical";
    }
  }
};
function render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
script$W.render = render$V;
var classes$n = {
  root: "p-tabpanels"
};
var TabPanelsStyle = BaseStyle.extend({
  name: "tabpanels",
  classes: classes$n
});
var script$1$o = {
  name: "BaseTabPanels",
  "extends": script$1a,
  props: {},
  style: TabPanelsStyle,
  provide: function provide14() {
    return {
      $pcTabPanels: this,
      $parentInstance: this
    };
  }
};
var script$V = {
  name: "TabPanels",
  "extends": script$1$o,
  inheritAttrs: false
};
function render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "presentation"
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default")], 16);
}
script$V.render = render$U;
var classes$m = {
  root: function root6(_ref) {
    var instance = _ref.instance;
    return ["p-tabpanel", {
      "p-tabpanel-active": instance.active
    }];
  }
};
var TabPanelStyle = BaseStyle.extend({
  name: "tabpanel",
  classes: classes$m
});
var script$1$n = {
  name: "BaseTabPanel",
  "extends": script$1a,
  props: {
    // in Tabs
    value: {
      type: String,
      "default": void 0
    },
    as: {
      type: String,
      "default": "DIV"
    },
    asChild: {
      type: Boolean,
      "default": false
    },
    // in TabView
    header: null,
    headerStyle: null,
    headerClass: null,
    headerProps: null,
    headerActionProps: null,
    contentStyle: null,
    contentClass: null,
    contentProps: null,
    disabled: Boolean
  },
  style: TabPanelStyle,
  provide: function provide15() {
    return {
      $pcTabPanel: this,
      $parentInstance: this
    };
  }
};
var script$U = {
  name: "TabPanel",
  "extends": script$1$n,
  inheritAttrs: false,
  inject: ["$pcTabs"],
  computed: {
    active: function active() {
      var _this$$pcTabs;
      return equals((_this$$pcTabs = this.$pcTabs) === null || _this$$pcTabs === void 0 ? void 0 : _this$$pcTabs.d_value, this.value);
    },
    id: function id() {
      var _this$$pcTabs2;
      return "".concat((_this$$pcTabs2 = this.$pcTabs) === null || _this$$pcTabs2 === void 0 ? void 0 : _this$$pcTabs2.id, "_tabpanel_").concat(this.value);
    },
    ariaLabelledby: function ariaLabelledby() {
      var _this$$pcTabs3;
      return "".concat((_this$$pcTabs3 = this.$pcTabs) === null || _this$$pcTabs3 === void 0 ? void 0 : _this$$pcTabs3.id, "_tab_").concat(this.value);
    },
    attrs: function attrs2() {
      return mergeProps(this.a11yAttrs, this.ptmi("root", this.ptParams));
    },
    a11yAttrs: function a11yAttrs2() {
      var _this$$pcTabs4;
      return {
        id: this.id,
        tabindex: (_this$$pcTabs4 = this.$pcTabs) === null || _this$$pcTabs4 === void 0 ? void 0 : _this$$pcTabs4.tabindex,
        role: "tabpanel",
        "aria-labelledby": this.ariaLabelledby,
        "data-pc-name": "tabpanel",
        "data-p-active": this.active
      };
    },
    ptParams: function ptParams() {
      return {
        context: {
          active: this.active
        }
      };
    }
  }
};
function render$T(_ctx, _cache, $props, $setup, $data, $options) {
  var _$options$$pcTabs, _$options$$pcTabs2;
  return !$options.$pcTabs ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [!_ctx.asChild ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [((_$options$$pcTabs = $options.$pcTabs) !== null && _$options$$pcTabs !== void 0 && _$options$$pcTabs.lazy ? $options.active : true) ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.as), mergeProps({
    key: 0,
    "class": _ctx.cx("root")
  }, $options.attrs), {
    "default": withCtx(function() {
      return [renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
  }, 16, ["class"])), [[vShow, (_$options$$pcTabs2 = $options.$pcTabs) !== null && _$options$$pcTabs2 !== void 0 && _$options$$pcTabs2.lazy ? true : $options.active]]) : createCommentVNode("", true)], 64)) : renderSlot(_ctx.$slots, "default", {
    key: 1,
    "class": normalizeClass(_ctx.cx("root")),
    active: $options.active,
    a11yAttrs: $options.a11yAttrs
  })], 64));
}
script$U.render = render$T;
var theme$k = function theme15(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-divider-horizontal {\n    display: flex;\n    width: 100%;\n    position: relative;\n    align-items: center;\n    margin: ".concat(dt3("divider.horizontal.margin"), ";\n    padding: ").concat(dt3("divider.horizontal.padding"), ';\n}\n\n.p-divider-horizontal:before {\n    position: absolute;\n    display: block;\n    top: 50%;\n    left: 0;\n    width: 100%;\n    content: "";\n    border-top: 1px solid ').concat(dt3("divider.border.color"), ";\n}\n\n.p-divider-horizontal .p-divider-content {\n    padding: ").concat(dt3("divider.horizontal.content.padding"), ";\n}\n\n.p-divider-vertical {\n    min-height: 100%;\n    margin: 0 1rem;\n    display: flex;\n    position: relative;\n    justify-content: center;\n    margin: ").concat(dt3("divider.vertical.margin"), ";\n    padding: ").concat(dt3("divider.vertical.padding"), ';\n}\n\n.p-divider-vertical:before {\n    position: absolute;\n    display: block;\n    top: 0;\n    left: 50%;\n    height: 100%;\n    content: "";\n    border-left: 1px solid ').concat(dt3("divider.border.color"), ";\n}\n\n.p-divider.p-divider-vertical .p-divider-content {\n    padding: ").concat(dt3("divider.vertical.content.padding"), ";\n}\n\n.p-divider-content {\n    z-index: 1;\n    background: ").concat(dt3("divider.content.background"), ";\n    color: ").concat(dt3("divider.content.color"), ";\n}\n\n.p-divider-solid.p-divider-horizontal:before {\n    border-top-style: solid;\n}\n\n.p-divider-solid.p-divider-vertical:before {\n    border-left-style: solid;\n}\n\n.p-divider-dashed.p-divider-horizontal:before {\n    border-top-style: dashed;\n}\n\n.p-divider-dashed.p-divider-vertical:before {\n    border-left-style: dashed;\n}\n\n.p-divider-dotted.p-divider-horizontal:before {\n    border-top-style: dotted;\n}\n\n.p-divider-dotted.p-divider-vertical:before {\n    border-left-style: dotted;\n}\n");
};
var inlineStyles$7 = {
  root: function root7(_ref2) {
    var props = _ref2.props;
    return {
      justifyContent: props.layout === "horizontal" ? props.align === "center" || props.align === null ? "center" : props.align === "left" ? "flex-start" : props.align === "right" ? "flex-end" : null : null,
      alignItems: props.layout === "vertical" ? props.align === "center" || props.align === null ? "center" : props.align === "top" ? "flex-start" : props.align === "bottom" ? "flex-end" : null : null
    };
  }
};
var classes$l = {
  root: function root8(_ref3) {
    var props = _ref3.props;
    return ["p-divider p-component", "p-divider-" + props.layout, "p-divider-" + props.type, {
      "p-divider-left": props.layout === "horizontal" && (!props.align || props.align === "left")
    }, {
      "p-divider-center": props.layout === "horizontal" && props.align === "center"
    }, {
      "p-divider-right": props.layout === "horizontal" && props.align === "right"
    }, {
      "p-divider-top": props.layout === "vertical" && props.align === "top"
    }, {
      "p-divider-center": props.layout === "vertical" && (!props.align || props.align === "center")
    }, {
      "p-divider-bottom": props.layout === "vertical" && props.align === "bottom"
    }];
  },
  content: "p-divider-content"
};
var DividerStyle = BaseStyle.extend({
  name: "divider",
  theme: theme$k,
  classes: classes$l,
  inlineStyles: inlineStyles$7
});
var script$1$m = {
  name: "BaseDivider",
  "extends": script$1a,
  props: {
    align: {
      type: String,
      "default": null
    },
    layout: {
      type: String,
      "default": "horizontal"
    },
    type: {
      type: String,
      "default": "solid"
    }
  },
  style: DividerStyle,
  provide: function provide16() {
    return {
      $pcDivider: this,
      $parentInstance: this
    };
  }
};
var script$T = {
  name: "Divider",
  "extends": script$1$m,
  inheritAttrs: false
};
var _hoisted_1$W = ["aria-orientation"];
function render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    style: _ctx.sx("root"),
    role: "separator",
    "aria-orientation": _ctx.layout
  }, _ctx.ptmi("root")), [_ctx.$slots["default"] ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("content")
  }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "default")], 16)) : createCommentVNode("", true)], 16, _hoisted_1$W);
}
script$T.render = render$S;
var script$S = {
  name: "AngleDownIcon",
  "extends": script$15
};
var _hoisted_1$V = /* @__PURE__ */ createBaseVNode("path", {
  d: "M3.58659 4.5007C3.68513 4.50023 3.78277 4.51945 3.87379 4.55723C3.9648 4.59501 4.04735 4.65058 4.11659 4.7207L7.11659 7.7207L10.1166 4.7207C10.2619 4.65055 10.4259 4.62911 10.5843 4.65956C10.7427 4.69002 10.8871 4.77074 10.996 4.88976C11.1049 5.00877 11.1726 5.15973 11.1889 5.32022C11.2052 5.48072 11.1693 5.6422 11.0866 5.7807L7.58659 9.2807C7.44597 9.42115 7.25534 9.50004 7.05659 9.50004C6.85784 9.50004 6.66722 9.42115 6.52659 9.2807L3.02659 5.7807C2.88614 5.64007 2.80725 5.44945 2.80725 5.2507C2.80725 5.05195 2.88614 4.86132 3.02659 4.7207C3.09932 4.64685 3.18675 4.58911 3.28322 4.55121C3.37969 4.51331 3.48305 4.4961 3.58659 4.5007Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$L = [_hoisted_1$V];
function render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$L, 16);
}
script$S.render = render$R;
var script$R = {
  name: "AngleUpIcon",
  "extends": script$15
};
var _hoisted_1$U = /* @__PURE__ */ createBaseVNode("path", {
  d: "M10.4134 9.49931C10.3148 9.49977 10.2172 9.48055 10.1262 9.44278C10.0352 9.405 9.95263 9.34942 9.88338 9.27931L6.88338 6.27931L3.88338 9.27931C3.73811 9.34946 3.57409 9.3709 3.41567 9.34044C3.25724 9.30999 3.11286 9.22926 3.00395 9.11025C2.89504 8.99124 2.82741 8.84028 2.8111 8.67978C2.79478 8.51928 2.83065 8.35781 2.91338 8.21931L6.41338 4.71931C6.55401 4.57886 6.74463 4.49997 6.94338 4.49997C7.14213 4.49997 7.33276 4.57886 7.47338 4.71931L10.9734 8.21931C11.1138 8.35994 11.1927 8.55056 11.1927 8.74931C11.1927 8.94806 11.1138 9.13868 10.9734 9.27931C10.9007 9.35315 10.8132 9.41089 10.7168 9.44879C10.6203 9.48669 10.5169 9.5039 10.4134 9.49931Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$K = [_hoisted_1$U];
function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$K, 16);
}
script$R.render = render$Q;
var theme$j = function theme16(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-inputnumber {\n    display: inline-flex;\n    position: relative;\n}\n\n.p-inputnumber-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex: 0 0 auto;\n    cursor: pointer;\n    background: ".concat(dt3("inputnumber.button.background"), ";\n    color: ").concat(dt3("inputnumber.button.color"), ";\n    width: ").concat(dt3("inputnumber.button.width"), ";\n    transition: background ").concat(dt3("inputnumber.transition.duration"), ", color ").concat(dt3("inputnumber.transition.duration"), ", border-color ").concat(dt3("inputnumber.transition.duration"), ", outline-color ").concat(dt3("inputnumber.transition.duration"), ";\n}\n\n.p-inputnumber-button:hover {\n    background: ").concat(dt3("inputnumber.button.hover.background"), ";\n    color: ").concat(dt3("inputnumber.button.hover.color"), ";\n}\n\n.p-inputnumber-button:active {\n    background: ").concat(dt3("inputnumber.button.active.background"), ";\n    color: ").concat(dt3("inputnumber.button.active.color"), ";\n}\n\n.p-inputnumber-stacked .p-inputnumber-button {\n    position: relative;\n    border: 0 none;\n}\n\n.p-inputnumber-stacked .p-inputnumber-button-group {\n    display: flex;\n    flex-direction: column;\n    position: absolute;\n    top: 1px;\n    right: 1px;\n    height: calc(100% - 2px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-increment-button {\n    padding: 0;\n    border-top-right-radius: calc(").concat(dt3("inputnumber.button.border.radius"), " - 1px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-decrement-button {\n    padding: 0;\n    border-bottom-right-radius: calc(").concat(dt3("inputnumber.button.border.radius"), " - 1px);\n}\n\n.p-inputnumber-stacked .p-inputnumber-button {\n    flex: 1 1 auto;\n    border: 0 none;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button {\n    border: 1px solid ").concat(dt3("inputnumber.button.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button:hover {\n    border-color: ").concat(dt3("inputnumber.button.hover.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-button:active {\n    border-color: ").concat(dt3("inputnumber.button.active.border.color"), ";\n}\n\n.p-inputnumber-horizontal .p-inputnumber-increment-button {\n    order: 3;\n    border-top-right-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-left: 0 none;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-input {\n    order: 2;\n    border-radius: 0;\n}\n\n.p-inputnumber-horizontal .p-inputnumber-decrement-button {\n    order: 1;\n    border-top-left-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-bottom-left-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-right: 0 none;\n}\n\n.p-inputnumber-vertical {\n    flex-direction: column;\n}\n\n.p-inputnumber-vertical .p-inputnumber-button {\n    border: 1px solid ").concat(dt3("inputnumber.button.border.color"), ";\n    padding: ").concat(dt3("inputnumber.button.vertical.padding"), "; 0;\n}\n\n.p-inputnumber-vertical .p-inputnumber-button:hover {\n    border-color: ").concat(dt3("inputnumber.button.hover.border.color"), ";\n}\n\n.p-inputnumber-vertical .p-inputnumber-button:active {\n    border-color: ").concat(dt3("inputnumber.button.active.border.color"), ";\n}\n\n.p-inputnumber-vertical .p-inputnumber-increment-button {\n    order: 1;\n    border-top-left-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-top-right-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    width: 100%;\n    border-bottom: 0 none;\n}\n\n.p-inputnumber-vertical .p-inputnumber-input {\n    order: 2;\n    border-radius: 0;\n    text-align: center;\n}\n\n.p-inputnumber-vertical .p-inputnumber-decrement-button {\n    order: 3;\n    border-bottom-left-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("inputnumber.button.border.radius"), ";\n    width: 100%;\n    border-top: 0 none;\n}\n\n.p-inputnumber-input {\n    flex: 1 1 auto;\n}\n\n.p-inputnumber-fluid {\n    width: 100%;\n}\n\n.p-inputnumber-fluid .p-inputnumber-input {\n    width: 1%;\n}\n\n.p-inputnumber-fluid.p-inputnumber-vertical .p-inputnumber-input {\n    width: 100%;\n}\n");
};
var classes$k = {
  root: function root9(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-inputnumber p-component p-inputwrapper", {
      "p-inputwrapper-filled": instance.filled || props.allowEmpty === false,
      "p-inputwrapper-focus": instance.focused,
      "p-inputnumber-stacked": props.showButtons && props.buttonLayout === "stacked",
      "p-inputnumber-horizontal": props.showButtons && props.buttonLayout === "horizontal",
      "p-inputnumber-vertical": props.showButtons && props.buttonLayout === "vertical",
      "p-inputnumber-fluid": instance.fluid
    }];
  },
  pcInput: "p-inputnumber-input",
  buttonGroup: "p-inputnumber-button-group",
  incrementButton: function incrementButton(_ref3) {
    var instance = _ref3.instance, props = _ref3.props;
    return ["p-inputnumber-button p-inputnumber-increment-button", {
      "p-disabled": props.showButtons && props.max !== null && instance.maxBoundry()
    }];
  },
  decrementButton: function decrementButton(_ref4) {
    var instance = _ref4.instance, props = _ref4.props;
    return ["p-inputnumber-button p-inputnumber-decrement-button", {
      "p-disabled": props.showButtons && props.min !== null && instance.minBoundry()
    }];
  }
};
var InputNumberStyle = BaseStyle.extend({
  name: "inputnumber",
  theme: theme$j,
  classes: classes$k
});
var script$1$l = {
  name: "BaseInputNumber",
  "extends": script$1a,
  props: {
    modelValue: {
      type: Number,
      "default": null
    },
    format: {
      type: Boolean,
      "default": true
    },
    showButtons: {
      type: Boolean,
      "default": false
    },
    buttonLayout: {
      type: String,
      "default": "stacked"
    },
    incrementButtonClass: {
      type: String,
      "default": null
    },
    decrementButtonClass: {
      type: String,
      "default": null
    },
    incrementButtonIcon: {
      type: String,
      "default": void 0
    },
    incrementIcon: {
      type: String,
      "default": void 0
    },
    decrementButtonIcon: {
      type: String,
      "default": void 0
    },
    decrementIcon: {
      type: String,
      "default": void 0
    },
    locale: {
      type: String,
      "default": void 0
    },
    localeMatcher: {
      type: String,
      "default": void 0
    },
    mode: {
      type: String,
      "default": "decimal"
    },
    prefix: {
      type: String,
      "default": null
    },
    suffix: {
      type: String,
      "default": null
    },
    currency: {
      type: String,
      "default": void 0
    },
    currencyDisplay: {
      type: String,
      "default": void 0
    },
    useGrouping: {
      type: Boolean,
      "default": true
    },
    minFractionDigits: {
      type: Number,
      "default": void 0
    },
    maxFractionDigits: {
      type: Number,
      "default": void 0
    },
    roundingMode: {
      type: String,
      "default": "halfExpand",
      validator: function validator(value3) {
        return ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"].includes(value3);
      }
    },
    min: {
      type: Number,
      "default": null
    },
    max: {
      type: Number,
      "default": null
    },
    step: {
      type: Number,
      "default": 1
    },
    allowEmpty: {
      type: Boolean,
      "default": true
    },
    highlightOnFocus: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    placeholder: {
      type: String,
      "default": null
    },
    fluid: {
      type: Boolean,
      "default": false
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: InputNumberStyle,
  provide: function provide17() {
    return {
      $pcInputNumber: this,
      $parentInstance: this
    };
  }
};
function _typeof$j(o) {
  "@babel/helpers - typeof";
  return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$j(o);
}
function ownKeys$j(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$j(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$j(Object(t), true).forEach(function(r2) {
      _defineProperty$i(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$i(e, r, t) {
  return (r = _toPropertyKey$h(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$h(t) {
  var i2 = _toPrimitive$h(t, "string");
  return "symbol" == _typeof$j(i2) ? i2 : i2 + "";
}
function _toPrimitive$h(t, r) {
  if ("object" != _typeof$j(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$j(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toConsumableArray$c(r) {
  return _arrayWithoutHoles$c(r) || _iterableToArray$c(r) || _unsupportedIterableToArray$e(r) || _nonIterableSpread$c();
}
function _nonIterableSpread$c() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$e(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$e(r, a) : void 0;
  }
}
function _iterableToArray$c(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$c(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$e(r);
}
function _arrayLikeToArray$e(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$Q = {
  name: "InputNumber",
  "extends": script$1$l,
  inheritAttrs: false,
  emits: ["update:modelValue", "input", "focus", "blur"],
  numberFormat: null,
  _numeral: null,
  _decimal: null,
  _group: null,
  _minusSign: null,
  _currency: null,
  _suffix: null,
  _prefix: null,
  _index: null,
  groupChar: "",
  isSpecialChar: null,
  prefixChar: null,
  suffixChar: null,
  timer: null,
  data: function data5() {
    return {
      d_modelValue: this.modelValue,
      focused: false
    };
  },
  watch: {
    modelValue: function modelValue(newValue) {
      this.d_modelValue = newValue;
    },
    locale: function locale(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    localeMatcher: function localeMatcher(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    mode: function mode(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    currency: function currency(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    currencyDisplay: function currencyDisplay(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    useGrouping: function useGrouping(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    minFractionDigits: function minFractionDigits(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    maxFractionDigits: function maxFractionDigits(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    suffix: function suffix(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },
    prefix: function prefix(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }
  },
  created: function created2() {
    this.constructParser();
  },
  methods: {
    getOptions: function getOptions3() {
      return {
        localeMatcher: this.localeMatcher,
        style: this.mode,
        currency: this.currency,
        currencyDisplay: this.currencyDisplay,
        useGrouping: this.useGrouping,
        minimumFractionDigits: this.minFractionDigits,
        maximumFractionDigits: this.maxFractionDigits,
        roundingMode: this.roundingMode
      };
    },
    constructParser: function constructParser() {
      this.numberFormat = new Intl.NumberFormat(this.locale, this.getOptions());
      var numerals = _toConsumableArray$c(new Intl.NumberFormat(this.locale, {
        useGrouping: false
      }).format(9876543210)).reverse();
      var index2 = new Map(numerals.map(function(d, i2) {
        return [d, i2];
      }));
      this._numeral = new RegExp("[".concat(numerals.join(""), "]"), "g");
      this._group = this.getGroupingExpression();
      this._minusSign = this.getMinusSignExpression();
      this._currency = this.getCurrencyExpression();
      this._decimal = this.getDecimalExpression();
      this._suffix = this.getSuffixExpression();
      this._prefix = this.getPrefixExpression();
      this._index = function(d) {
        return index2.get(d);
      };
    },
    updateConstructParser: function updateConstructParser(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.constructParser();
      }
    },
    escapeRegExp: function escapeRegExp(text2) {
      return text2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    },
    getDecimalExpression: function getDecimalExpression() {
      var formatter = new Intl.NumberFormat(this.locale, _objectSpread$j(_objectSpread$j({}, this.getOptions()), {}, {
        useGrouping: false
      }));
      return new RegExp("[".concat(formatter.format(1.1).replace(this._currency, "").trim().replace(this._numeral, ""), "]"), "g");
    },
    getGroupingExpression: function getGroupingExpression() {
      var formatter = new Intl.NumberFormat(this.locale, {
        useGrouping: true
      });
      this.groupChar = formatter.format(1e6).trim().replace(this._numeral, "").charAt(0);
      return new RegExp("[".concat(this.groupChar, "]"), "g");
    },
    getMinusSignExpression: function getMinusSignExpression() {
      var formatter = new Intl.NumberFormat(this.locale, {
        useGrouping: false
      });
      return new RegExp("[".concat(formatter.format(-1).trim().replace(this._numeral, ""), "]"), "g");
    },
    getCurrencyExpression: function getCurrencyExpression() {
      if (this.currency) {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: "currency",
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          roundingMode: this.roundingMode
        });
        return new RegExp("[".concat(formatter.format(1).replace(/\s/g, "").replace(this._numeral, "").replace(this._group, ""), "]"), "g");
      }
      return new RegExp("[]", "g");
    },
    getPrefixExpression: function getPrefixExpression() {
      if (this.prefix) {
        this.prefixChar = this.prefix;
      } else {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay
        });
        this.prefixChar = formatter.format(1).split("1")[0];
      }
      return new RegExp("".concat(this.escapeRegExp(this.prefixChar || "")), "g");
    },
    getSuffixExpression: function getSuffixExpression() {
      if (this.suffix) {
        this.suffixChar = this.suffix;
      } else {
        var formatter = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          roundingMode: this.roundingMode
        });
        this.suffixChar = formatter.format(1).split("1")[1];
      }
      return new RegExp("".concat(this.escapeRegExp(this.suffixChar || "")), "g");
    },
    formatValue: function formatValue(value3) {
      if (value3 != null) {
        if (value3 === "-") {
          return value3;
        }
        if (this.format) {
          var formatter = new Intl.NumberFormat(this.locale, this.getOptions());
          var formattedValue2 = formatter.format(value3);
          if (this.prefix) {
            formattedValue2 = this.prefix + formattedValue2;
          }
          if (this.suffix) {
            formattedValue2 = formattedValue2 + this.suffix;
          }
          return formattedValue2;
        }
        return value3.toString();
      }
      return "";
    },
    parseValue: function parseValue2(text2) {
      var filteredText = text2.replace(this._suffix, "").replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "").replace(this._group, "").replace(this._minusSign, "-").replace(this._decimal, ".").replace(this._numeral, this._index);
      if (filteredText) {
        if (filteredText === "-")
          return filteredText;
        var parsedValue = +filteredText;
        return isNaN(parsedValue) ? null : parsedValue;
      }
      return null;
    },
    repeat: function repeat(event2, interval, dir) {
      var _this = this;
      if (this.readonly) {
        return;
      }
      var i2 = interval || 500;
      this.clearTimer();
      this.timer = setTimeout(function() {
        _this.repeat(event2, 40, dir);
      }, i2);
      this.spin(event2, dir);
    },
    spin: function spin(event2, dir) {
      if (this.$refs.input) {
        var step = this.step * dir;
        var currentValue = this.parseValue(this.$refs.input.$el.value) || 0;
        var newValue = this.validateValue(currentValue + step);
        this.updateInput(newValue, null, "spin");
        this.updateModel(event2, newValue);
        this.handleOnInput(event2, currentValue, newValue);
      }
    },
    onUpButtonMouseDown: function onUpButtonMouseDown(event2) {
      if (!this.disabled) {
        this.$refs.input.$el.focus();
        this.repeat(event2, null, 1);
        event2.preventDefault();
      }
    },
    onUpButtonMouseUp: function onUpButtonMouseUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },
    onUpButtonMouseLeave: function onUpButtonMouseLeave() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },
    onUpButtonKeyUp: function onUpButtonKeyUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },
    onUpButtonKeyDown: function onUpButtonKeyDown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.repeat(event2, null, 1);
      }
    },
    onDownButtonMouseDown: function onDownButtonMouseDown(event2) {
      if (!this.disabled) {
        this.$refs.input.$el.focus();
        this.repeat(event2, null, -1);
        event2.preventDefault();
      }
    },
    onDownButtonMouseUp: function onDownButtonMouseUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },
    onDownButtonMouseLeave: function onDownButtonMouseLeave() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },
    onDownButtonKeyUp: function onDownButtonKeyUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },
    onDownButtonKeyDown: function onDownButtonKeyDown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.repeat(event2, null, -1);
      }
    },
    onUserInput: function onUserInput() {
      if (this.isSpecialChar) {
        this.$refs.input.$el.value = this.lastValue;
      }
      this.isSpecialChar = false;
    },
    onInputKeyDown: function onInputKeyDown(event2) {
      if (this.readonly) {
        return;
      }
      if (event2.altKey || event2.ctrlKey || event2.metaKey) {
        this.isSpecialChar = true;
        this.lastValue = this.$refs.input.$el.value;
        return;
      }
      this.lastValue = event2.target.value;
      var selectionStart = event2.target.selectionStart;
      var selectionEnd = event2.target.selectionEnd;
      var inputValue2 = event2.target.value;
      var newValueStr = null;
      switch (event2.code) {
        case "ArrowUp":
          this.spin(event2, 1);
          event2.preventDefault();
          break;
        case "ArrowDown":
          this.spin(event2, -1);
          event2.preventDefault();
          break;
        case "ArrowLeft":
          if (!this.isNumeralChar(inputValue2.charAt(selectionStart - 1))) {
            event2.preventDefault();
          }
          break;
        case "ArrowRight":
          if (!this.isNumeralChar(inputValue2.charAt(selectionStart))) {
            event2.preventDefault();
          }
          break;
        case "Tab":
        case "Enter":
        case "NumpadEnter":
          newValueStr = this.validateValue(this.parseValue(inputValue2));
          this.$refs.input.$el.value = this.formatValue(newValueStr);
          this.$refs.input.$el.setAttribute("aria-valuenow", newValueStr);
          this.updateModel(event2, newValueStr);
          break;
        case "Backspace": {
          event2.preventDefault();
          if (selectionStart === selectionEnd) {
            var deleteChar = inputValue2.charAt(selectionStart - 1);
            var _this$getDecimalCharI = this.getDecimalCharIndexes(inputValue2), decimalCharIndex = _this$getDecimalCharI.decimalCharIndex, decimalCharIndexWithoutPrefix = _this$getDecimalCharI.decimalCharIndexWithoutPrefix;
            if (this.isNumeralChar(deleteChar)) {
              var decimalLength = this.getDecimalLength(inputValue2);
              if (this._group.test(deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue2.slice(0, selectionStart - 2) + inputValue2.slice(selectionStart - 1);
              } else if (this._decimal.test(deleteChar)) {
                this._decimal.lastIndex = 0;
                if (decimalLength) {
                  this.$refs.input.$el.setSelectionRange(selectionStart - 1, selectionStart - 1);
                } else {
                  newValueStr = inputValue2.slice(0, selectionStart - 1) + inputValue2.slice(selectionStart);
                }
              } else if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
                var insertedText = this.isDecimalMode() && (this.minFractionDigits || 0) < decimalLength ? "" : "0";
                newValueStr = inputValue2.slice(0, selectionStart - 1) + insertedText + inputValue2.slice(selectionStart);
              } else if (decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue2.slice(0, selectionStart - 1) + "0" + inputValue2.slice(selectionStart);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : "";
              } else {
                newValueStr = inputValue2.slice(0, selectionStart - 1) + inputValue2.slice(selectionStart);
              }
            }
            this.updateValue(event2, newValueStr, null, "delete-single");
          } else {
            newValueStr = this.deleteRange(inputValue2, selectionStart, selectionEnd);
            this.updateValue(event2, newValueStr, null, "delete-range");
          }
          break;
        }
        case "Delete":
          event2.preventDefault();
          if (selectionStart === selectionEnd) {
            var _deleteChar = inputValue2.charAt(selectionStart);
            var _this$getDecimalCharI2 = this.getDecimalCharIndexes(inputValue2), _decimalCharIndex = _this$getDecimalCharI2.decimalCharIndex, _decimalCharIndexWithoutPrefix = _this$getDecimalCharI2.decimalCharIndexWithoutPrefix;
            if (this.isNumeralChar(_deleteChar)) {
              var _decimalLength = this.getDecimalLength(inputValue2);
              if (this._group.test(_deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue2.slice(0, selectionStart) + inputValue2.slice(selectionStart + 2);
              } else if (this._decimal.test(_deleteChar)) {
                this._decimal.lastIndex = 0;
                if (_decimalLength) {
                  this.$refs.input.$el.setSelectionRange(selectionStart + 1, selectionStart + 1);
                } else {
                  newValueStr = inputValue2.slice(0, selectionStart) + inputValue2.slice(selectionStart + 1);
                }
              } else if (_decimalCharIndex > 0 && selectionStart > _decimalCharIndex) {
                var _insertedText = this.isDecimalMode() && (this.minFractionDigits || 0) < _decimalLength ? "" : "0";
                newValueStr = inputValue2.slice(0, selectionStart) + _insertedText + inputValue2.slice(selectionStart + 1);
              } else if (_decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue2.slice(0, selectionStart) + "0" + inputValue2.slice(selectionStart + 1);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : "";
              } else {
                newValueStr = inputValue2.slice(0, selectionStart) + inputValue2.slice(selectionStart + 1);
              }
            }
            this.updateValue(event2, newValueStr, null, "delete-back-single");
          } else {
            newValueStr = this.deleteRange(inputValue2, selectionStart, selectionEnd);
            this.updateValue(event2, newValueStr, null, "delete-range");
          }
          break;
        case "Home":
          event2.preventDefault();
          if (isNotEmpty(this.min)) {
            this.updateModel(event2, this.min);
          }
          break;
        case "End":
          event2.preventDefault();
          if (isNotEmpty(this.max)) {
            this.updateModel(event2, this.max);
          }
          break;
      }
    },
    onInputKeyPress: function onInputKeyPress(event2) {
      if (this.readonly) {
        return;
      }
      var _char = event2.key;
      var isDecimalSign2 = this.isDecimalSign(_char);
      var isMinusSign2 = this.isMinusSign(_char);
      if (event2.code !== "Enter") {
        event2.preventDefault();
      }
      if (Number(_char) >= 0 && Number(_char) <= 9 || isMinusSign2 || isDecimalSign2) {
        this.insert(event2, _char, {
          isDecimalSign: isDecimalSign2,
          isMinusSign: isMinusSign2
        });
      }
    },
    onPaste: function onPaste(event2) {
      event2.preventDefault();
      var data28 = (event2.clipboardData || window["clipboardData"]).getData("Text");
      if (data28) {
        var filteredData = this.parseValue(data28);
        if (filteredData != null) {
          this.insert(event2, filteredData.toString());
        }
      }
    },
    allowMinusSign: function allowMinusSign() {
      return this.min === null || this.min < 0;
    },
    isMinusSign: function isMinusSign(_char2) {
      if (this._minusSign.test(_char2) || _char2 === "-") {
        this._minusSign.lastIndex = 0;
        return true;
      }
      return false;
    },
    isDecimalSign: function isDecimalSign(_char3) {
      if (this._decimal.test(_char3)) {
        this._decimal.lastIndex = 0;
        return true;
      }
      return false;
    },
    isDecimalMode: function isDecimalMode() {
      return this.mode === "decimal";
    },
    getDecimalCharIndexes: function getDecimalCharIndexes(val) {
      var decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      var filteredVal = val.replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "");
      var decimalCharIndexWithoutPrefix = filteredVal.search(this._decimal);
      this._decimal.lastIndex = 0;
      return {
        decimalCharIndex,
        decimalCharIndexWithoutPrefix
      };
    },
    getCharIndexes: function getCharIndexes(val) {
      var decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      var minusCharIndex = val.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      var suffixCharIndex = val.search(this._suffix);
      this._suffix.lastIndex = 0;
      var currencyCharIndex = val.search(this._currency);
      this._currency.lastIndex = 0;
      return {
        decimalCharIndex,
        minusCharIndex,
        suffixCharIndex,
        currencyCharIndex
      };
    },
    insert: function insert(event2, text2) {
      var sign = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        isDecimalSign: false,
        isMinusSign: false
      };
      var minusCharIndexOnText = text2.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      if (!this.allowMinusSign() && minusCharIndexOnText !== -1) {
        return;
      }
      var selectionStart = this.$refs.input.$el.selectionStart;
      var selectionEnd = this.$refs.input.$el.selectionEnd;
      var inputValue2 = this.$refs.input.$el.value.trim();
      var _this$getCharIndexes = this.getCharIndexes(inputValue2), decimalCharIndex = _this$getCharIndexes.decimalCharIndex, minusCharIndex = _this$getCharIndexes.minusCharIndex, suffixCharIndex = _this$getCharIndexes.suffixCharIndex, currencyCharIndex = _this$getCharIndexes.currencyCharIndex;
      var newValueStr;
      if (sign.isMinusSign) {
        if (selectionStart === 0) {
          newValueStr = inputValue2;
          if (minusCharIndex === -1 || selectionEnd !== 0) {
            newValueStr = this.insertText(inputValue2, text2, 0, selectionEnd);
          }
          this.updateValue(event2, newValueStr, text2, "insert");
        }
      } else if (sign.isDecimalSign) {
        if (decimalCharIndex > 0 && selectionStart === decimalCharIndex) {
          this.updateValue(event2, inputValue2, text2, "insert");
        } else if (decimalCharIndex > selectionStart && decimalCharIndex < selectionEnd) {
          newValueStr = this.insertText(inputValue2, text2, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text2, "insert");
        } else if (decimalCharIndex === -1 && this.maxFractionDigits) {
          newValueStr = this.insertText(inputValue2, text2, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text2, "insert");
        }
      } else {
        var maxFractionDigits2 = this.numberFormat.resolvedOptions().maximumFractionDigits;
        var operation = selectionStart !== selectionEnd ? "range-insert" : "insert";
        if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
          if (selectionStart + text2.length - (decimalCharIndex + 1) <= maxFractionDigits2) {
            var charIndex = currencyCharIndex >= selectionStart ? currencyCharIndex - 1 : suffixCharIndex >= selectionStart ? suffixCharIndex : inputValue2.length;
            newValueStr = inputValue2.slice(0, selectionStart) + text2 + inputValue2.slice(selectionStart + text2.length, charIndex) + inputValue2.slice(charIndex);
            this.updateValue(event2, newValueStr, text2, operation);
          }
        } else {
          newValueStr = this.insertText(inputValue2, text2, selectionStart, selectionEnd);
          this.updateValue(event2, newValueStr, text2, operation);
        }
      }
    },
    insertText: function insertText(value3, text2, start2, end) {
      var textSplit = text2 === "." ? text2 : text2.split(".");
      if (textSplit.length === 2) {
        var decimalCharIndex = value3.slice(start2, end).search(this._decimal);
        this._decimal.lastIndex = 0;
        return decimalCharIndex > 0 ? value3.slice(0, start2) + this.formatValue(text2) + value3.slice(end) : this.formatValue(text2) || value3;
      } else if (end - start2 === value3.length) {
        return this.formatValue(text2);
      } else if (start2 === 0) {
        return text2 + value3.slice(end);
      } else if (end === value3.length) {
        return value3.slice(0, start2) + text2;
      } else {
        return value3.slice(0, start2) + text2 + value3.slice(end);
      }
    },
    deleteRange: function deleteRange(value3, start2, end) {
      var newValueStr;
      if (end - start2 === value3.length) newValueStr = "";
      else if (start2 === 0) newValueStr = value3.slice(end);
      else if (end === value3.length) newValueStr = value3.slice(0, start2);
      else newValueStr = value3.slice(0, start2) + value3.slice(end);
      return newValueStr;
    },
    initCursor: function initCursor() {
      var selectionStart = this.$refs.input.$el.selectionStart;
      var inputValue2 = this.$refs.input.$el.value;
      var valueLength = inputValue2.length;
      var index2 = null;
      var prefixLength = (this.prefixChar || "").length;
      inputValue2 = inputValue2.replace(this._prefix, "");
      selectionStart = selectionStart - prefixLength;
      var _char4 = inputValue2.charAt(selectionStart);
      if (this.isNumeralChar(_char4)) {
        return selectionStart + prefixLength;
      }
      var i2 = selectionStart - 1;
      while (i2 >= 0) {
        _char4 = inputValue2.charAt(i2);
        if (this.isNumeralChar(_char4)) {
          index2 = i2 + prefixLength;
          break;
        } else {
          i2--;
        }
      }
      if (index2 !== null) {
        this.$refs.input.$el.setSelectionRange(index2 + 1, index2 + 1);
      } else {
        i2 = selectionStart;
        while (i2 < valueLength) {
          _char4 = inputValue2.charAt(i2);
          if (this.isNumeralChar(_char4)) {
            index2 = i2 + prefixLength;
            break;
          } else {
            i2++;
          }
        }
        if (index2 !== null) {
          this.$refs.input.$el.setSelectionRange(index2, index2);
        }
      }
      return index2 || 0;
    },
    onInputClick: function onInputClick() {
      var currentValue = this.$refs.input.$el.value;
      if (!this.readonly && currentValue !== getSelection()) {
        this.initCursor();
      }
    },
    isNumeralChar: function isNumeralChar(_char5) {
      if (_char5.length === 1 && (this._numeral.test(_char5) || this._decimal.test(_char5) || this._group.test(_char5) || this._minusSign.test(_char5))) {
        this.resetRegex();
        return true;
      }
      return false;
    },
    resetRegex: function resetRegex() {
      this._numeral.lastIndex = 0;
      this._decimal.lastIndex = 0;
      this._group.lastIndex = 0;
      this._minusSign.lastIndex = 0;
    },
    updateValue: function updateValue2(event2, valueStr, insertedValueStr, operation) {
      var currentValue = this.$refs.input.$el.value;
      var newValue = null;
      if (valueStr != null) {
        newValue = this.parseValue(valueStr);
        newValue = !newValue && !this.allowEmpty ? 0 : newValue;
        this.updateInput(newValue, insertedValueStr, operation, valueStr);
        this.handleOnInput(event2, currentValue, newValue);
      }
    },
    handleOnInput: function handleOnInput(event2, currentValue, newValue) {
      if (this.isValueChanged(currentValue, newValue)) {
        this.$emit("input", {
          originalEvent: event2,
          value: newValue,
          formattedValue: currentValue
        });
      }
    },
    isValueChanged: function isValueChanged(currentValue, newValue) {
      if (newValue === null && currentValue !== null) {
        return true;
      }
      if (newValue != null) {
        var parsedCurrentValue = typeof currentValue === "string" ? this.parseValue(currentValue) : currentValue;
        return newValue !== parsedCurrentValue;
      }
      return false;
    },
    validateValue: function validateValue(value3) {
      if (value3 === "-" || value3 == null) {
        return null;
      }
      if (this.min != null && value3 < this.min) {
        return this.min;
      }
      if (this.max != null && value3 > this.max) {
        return this.max;
      }
      return value3;
    },
    updateInput: function updateInput(value3, insertedValueStr, operation, valueStr) {
      insertedValueStr = insertedValueStr || "";
      var inputValue2 = this.$refs.input.$el.value;
      var newValue = this.formatValue(value3);
      var currentLength = inputValue2.length;
      if (newValue !== valueStr) {
        newValue = this.concatValues(newValue, valueStr);
      }
      if (currentLength === 0) {
        this.$refs.input.$el.value = newValue;
        this.$refs.input.$el.setSelectionRange(0, 0);
        var index2 = this.initCursor();
        var selectionEnd = index2 + insertedValueStr.length;
        this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
      } else {
        var selectionStart = this.$refs.input.$el.selectionStart;
        var _selectionEnd = this.$refs.input.$el.selectionEnd;
        this.$refs.input.$el.value = newValue;
        var newLength = newValue.length;
        if (operation === "range-insert") {
          var startValue = this.parseValue((inputValue2 || "").slice(0, selectionStart));
          var startValueStr = startValue !== null ? startValue.toString() : "";
          var startExpr = startValueStr.split("").join("(".concat(this.groupChar, ")?"));
          var sRegex = new RegExp(startExpr, "g");
          sRegex.test(newValue);
          var tExpr = insertedValueStr.split("").join("(".concat(this.groupChar, ")?"));
          var tRegex = new RegExp(tExpr, "g");
          tRegex.test(newValue.slice(sRegex.lastIndex));
          _selectionEnd = sRegex.lastIndex + tRegex.lastIndex;
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (newLength === currentLength) {
          if (operation === "insert" || operation === "delete-back-single") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd + 1, _selectionEnd + 1);
          } else if (operation === "delete-single") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd - 1, _selectionEnd - 1);
          } else if (operation === "delete-range" || operation === "spin") {
            this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
          }
        } else if (operation === "delete-back-single") {
          var prevChar = inputValue2.charAt(_selectionEnd - 1);
          var nextChar = inputValue2.charAt(_selectionEnd);
          var diff = currentLength - newLength;
          var isGroupChar = this._group.test(nextChar);
          if (isGroupChar && diff === 1) {
            _selectionEnd += 1;
          } else if (!isGroupChar && this.isNumeralChar(prevChar)) {
            _selectionEnd += -1 * diff + 1;
          }
          this._group.lastIndex = 0;
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        } else if (inputValue2 === "-" && operation === "insert") {
          this.$refs.input.$el.setSelectionRange(0, 0);
          var _index = this.initCursor();
          var _selectionEnd2 = _index + insertedValueStr.length + 1;
          this.$refs.input.$el.setSelectionRange(_selectionEnd2, _selectionEnd2);
        } else {
          _selectionEnd = _selectionEnd + (newLength - currentLength);
          this.$refs.input.$el.setSelectionRange(_selectionEnd, _selectionEnd);
        }
      }
      this.$refs.input.$el.setAttribute("aria-valuenow", value3);
    },
    concatValues: function concatValues(val1, val2) {
      if (val1 && val2) {
        var decimalCharIndex = val2.search(this._decimal);
        this._decimal.lastIndex = 0;
        if (this.suffixChar) {
          return decimalCharIndex !== -1 ? val1.replace(this.suffixChar, "").split(this._decimal)[0] + val2.replace(this.suffixChar, "").slice(decimalCharIndex) + this.suffixChar : val1;
        } else {
          return decimalCharIndex !== -1 ? val1.split(this._decimal)[0] + val2.slice(decimalCharIndex) : val1;
        }
      }
      return val1;
    },
    getDecimalLength: function getDecimalLength(value3) {
      if (value3) {
        var valueSplit = value3.split(this._decimal);
        if (valueSplit.length === 2) {
          return valueSplit[1].replace(this._suffix, "").trim().replace(/\s/g, "").replace(this._currency, "").length;
        }
      }
      return 0;
    },
    updateModel: function updateModel2(event2, value3) {
      this.d_modelValue = value3;
      this.$emit("update:modelValue", value3);
    },
    onInputFocus: function onInputFocus(event2) {
      this.focused = true;
      if (!this.disabled && !this.readonly && this.$refs.input.$el.value !== getSelection() && this.highlightOnFocus) {
        event2.target.select();
      }
      this.$emit("focus", event2);
    },
    onInputBlur: function onInputBlur(event2) {
      this.focused = false;
      var input = event2.target;
      var newValue = this.validateValue(this.parseValue(input.value));
      this.$emit("blur", {
        originalEvent: event2,
        value: input.value
      });
      input.value = this.formatValue(newValue);
      input.setAttribute("aria-valuenow", newValue);
      this.updateModel(event2, newValue);
      if (!this.disabled && !this.readonly && this.highlightOnFocus) {
        clearSelection();
      }
    },
    clearTimer: function clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
      }
    },
    maxBoundry: function maxBoundry() {
      return this.d_modelValue >= this.max;
    },
    minBoundry: function minBoundry() {
      return this.d_modelValue <= this.min;
    }
  },
  computed: {
    filled: function filled2() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    },
    upButtonListeners: function upButtonListeners() {
      var _this2 = this;
      return {
        mousedown: function mousedown(event2) {
          return _this2.onUpButtonMouseDown(event2);
        },
        mouseup: function mouseup(event2) {
          return _this2.onUpButtonMouseUp(event2);
        },
        mouseleave: function mouseleave(event2) {
          return _this2.onUpButtonMouseLeave(event2);
        },
        keydown: function keydown(event2) {
          return _this2.onUpButtonKeyDown(event2);
        },
        keyup: function keyup(event2) {
          return _this2.onUpButtonKeyUp(event2);
        }
      };
    },
    downButtonListeners: function downButtonListeners() {
      var _this3 = this;
      return {
        mousedown: function mousedown(event2) {
          return _this3.onDownButtonMouseDown(event2);
        },
        mouseup: function mouseup(event2) {
          return _this3.onDownButtonMouseUp(event2);
        },
        mouseleave: function mouseleave(event2) {
          return _this3.onDownButtonMouseLeave(event2);
        },
        keydown: function keydown(event2) {
          return _this3.onDownButtonKeyDown(event2);
        },
        keyup: function keyup(event2) {
          return _this3.onDownButtonKeyUp(event2);
        }
      };
    },
    formattedValue: function formattedValue() {
      var val = !this.modelValue && !this.allowEmpty ? 0 : this.modelValue;
      return this.formatValue(val);
    },
    getFormatter: function getFormatter() {
      return this.numberFormat;
    }
  },
  components: {
    InputText: script$Z,
    AngleUpIcon: script$R,
    AngleDownIcon: script$S
  }
};
var _hoisted_1$T = ["disabled"];
var _hoisted_2$J = ["disabled"];
var _hoisted_3$c = ["disabled"];
var _hoisted_4$a = ["disabled"];
function render$P(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_InputText = resolveComponent("InputText");
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [createVNode(_component_InputText, {
    ref: "input",
    id: _ctx.inputId,
    role: "spinbutton",
    "class": normalizeClass([_ctx.cx("pcInput"), _ctx.inputClass]),
    style: normalizeStyle(_ctx.inputStyle),
    value: $options.formattedValue,
    "aria-valuemin": _ctx.min,
    "aria-valuemax": _ctx.max,
    "aria-valuenow": _ctx.modelValue,
    inputmode: _ctx.mode === "decimal" && !_ctx.minFractionDigits ? "numeric" : "decimal",
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    placeholder: _ctx.placeholder,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    invalid: _ctx.invalid,
    variant: _ctx.variant,
    onInput: $options.onUserInput,
    onKeydown: $options.onInputKeyDown,
    onKeypress: $options.onInputKeyPress,
    onPaste: $options.onPaste,
    onClick: $options.onInputClick,
    onFocus: $options.onInputFocus,
    onBlur: $options.onInputBlur,
    pt: _ctx.ptm("pcInput"),
    unstyled: _ctx.unstyled
  }, null, 8, ["id", "class", "style", "value", "aria-valuemin", "aria-valuemax", "aria-valuenow", "inputmode", "disabled", "readonly", "placeholder", "aria-labelledby", "aria-label", "invalid", "variant", "onInput", "onKeydown", "onKeypress", "onPaste", "onClick", "onFocus", "onBlur", "pt", "unstyled"]), _ctx.showButtons && _ctx.buttonLayout === "stacked" ? (openBlock(), createElementBlock("span", mergeProps({
    key: 0,
    "class": _ctx.cx("buttonGroup")
  }, _ctx.ptm("buttonGroup")), [renderSlot(_ctx.$slots, "incrementbutton", {
    listeners: $options.upButtonListeners
  }, function() {
    return [createBaseVNode("button", mergeProps({
      "class": [_ctx.cx("incrementButton"), _ctx.incrementButtonClass]
    }, toHandlers($options.upButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("incrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.incrementIcon || _ctx.incrementButtonIcon ? "span" : "AngleUpIcon"), mergeProps({
        "class": [_ctx.incrementIcon, _ctx.incrementButtonIcon]
      }, _ctx.ptm("incrementIcon"), {
        "data-pc-section": "incrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_1$T)];
  }), renderSlot(_ctx.$slots, "decrementbutton", {
    listeners: $options.downButtonListeners
  }, function() {
    return [createBaseVNode("button", mergeProps({
      "class": [_ctx.cx("decrementButton"), _ctx.decrementButtonClass]
    }, toHandlers($options.downButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("decrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.decrementIcon || _ctx.decrementButtonIcon ? "span" : "AngleDownIcon"), mergeProps({
        "class": [_ctx.decrementIcon, _ctx.decrementButtonIcon]
      }, _ctx.ptm("decrementIcon"), {
        "data-pc-section": "decrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_2$J)];
  })], 16)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "incrementbutton", {
    listeners: $options.upButtonListeners
  }, function() {
    return [_ctx.showButtons && _ctx.buttonLayout !== "stacked" ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      "class": [_ctx.cx("incrementButton"), _ctx.incrementButtonClass]
    }, toHandlers($options.upButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("incrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.incrementIcon || _ctx.incrementButtonIcon ? "span" : "AngleUpIcon"), mergeProps({
        "class": [_ctx.incrementIcon, _ctx.incrementButtonIcon]
      }, _ctx.ptm("incrementIcon"), {
        "data-pc-section": "incrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_3$c)) : createCommentVNode("", true)];
  }), renderSlot(_ctx.$slots, "decrementbutton", {
    listeners: $options.downButtonListeners
  }, function() {
    return [_ctx.showButtons && _ctx.buttonLayout !== "stacked" ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      "class": [_ctx.cx("decrementButton"), _ctx.decrementButtonClass]
    }, toHandlers($options.downButtonListeners, true), {
      disabled: _ctx.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, _ctx.ptm("decrementButton")), [renderSlot(_ctx.$slots, _ctx.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.decrementIcon || _ctx.decrementButtonIcon ? "span" : "AngleDownIcon"), mergeProps({
        "class": [_ctx.decrementIcon, _ctx.decrementButtonIcon]
      }, _ctx.ptm("decrementIcon"), {
        "data-pc-section": "decrementicon"
      }), null, 16, ["class"]))];
    })], 16, _hoisted_4$a)) : createCommentVNode("", true)];
  })], 16);
}
script$Q.render = render$P;
var script$P = {
  name: "ChevronDownIcon",
  "extends": script$15
};
var _hoisted_1$S = /* @__PURE__ */ createBaseVNode("path", {
  d: "M7.01744 10.398C6.91269 10.3985 6.8089 10.378 6.71215 10.3379C6.61541 10.2977 6.52766 10.2386 6.45405 10.1641L1.13907 4.84913C1.03306 4.69404 0.985221 4.5065 1.00399 4.31958C1.02276 4.13266 1.10693 3.95838 1.24166 3.82747C1.37639 3.69655 1.55301 3.61742 1.74039 3.60402C1.92777 3.59062 2.11386 3.64382 2.26584 3.75424L7.01744 8.47394L11.769 3.75424C11.9189 3.65709 12.097 3.61306 12.2748 3.62921C12.4527 3.64535 12.6199 3.72073 12.7498 3.84328C12.8797 3.96582 12.9647 4.12842 12.9912 4.30502C13.0177 4.48162 12.9841 4.662 12.8958 4.81724L7.58083 10.1322C7.50996 10.2125 7.42344 10.2775 7.32656 10.3232C7.22968 10.3689 7.12449 10.3944 7.01744 10.398Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$I = [_hoisted_1$S];
function render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$I, 16);
}
script$P.render = render$O;
var script$O = {
  name: "TimesIcon",
  "extends": script$15
};
var _hoisted_1$R = /* @__PURE__ */ createBaseVNode("path", {
  d: "M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$H = [_hoisted_1$R];
function render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$H, 16);
}
script$O.render = render$N;
var OverlayEventBus = EventBus();
var script$N = {
  name: "Portal",
  props: {
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  data: function data6() {
    return {
      mounted: false
    };
  },
  mounted: function mounted6() {
    this.mounted = isClient();
  },
  computed: {
    inline: function inline() {
      return this.disabled || this.appendTo === "self";
    }
  }
};
function render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.inline ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : $data.mounted ? (openBlock(), createBlock(Teleport, {
    key: 1,
    to: $props.appendTo
  }, [renderSlot(_ctx.$slots, "default")], 8, ["to"])) : createCommentVNode("", true);
}
script$N.render = render$M;
var theme$i = function theme17(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-select {\n    display: inline-flex;\n    cursor: pointer;\n    position: relative;\n    user-select: none;\n    background: ".concat(dt3("select.background"), ";\n    border: 1px solid ").concat(dt3("select.border.color"), ";\n    transition: background ").concat(dt3("select.transition.duration"), ", color ").concat(dt3("select.transition.duration"), ", border-color ").concat(dt3("select.transition.duration"), ",\n        outline-color ").concat(dt3("select.transition.duration"), ", box-shadow ").concat(dt3("select.transition.duration"), ";\n    border-radius: ").concat(dt3("select.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("select.shadow"), ";\n}\n\n.p-select:not(.p-disabled):hover {\n    border-color: ").concat(dt3("select.hover.border.color"), ";\n}\n\n.p-select:not(.p-disabled).p-focus {\n    border-color: ").concat(dt3("select.focus.border.color"), ";\n    box-shadow: ").concat(dt3("select.focus.ring.shadow"), ";\n    outline: ").concat(dt3("select.focus.ring.width"), " ").concat(dt3("select.focus.ring.style"), " ").concat(dt3("select.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("select.focus.ring.offset"), ";\n}\n\n.p-select.p-variant-filled {\n    background: ").concat(dt3("select.filled.background"), ";\n}\n\n.p-select.p-variant-filled.p-focus {\n    background: ").concat(dt3("select.filled.focus.background"), ";\n}\n\n.p-select.p-invalid {\n    border-color: ").concat(dt3("select.invalid.border.color"), ";\n}\n\n.p-select.p-disabled {\n    opacity: 1;\n    background: ").concat(dt3("select.disabled.background"), ";\n}\n\n.p-select-clear-icon {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n    color: ").concat(dt3("select.clear.icon.color"), ";\n    right: ").concat(dt3("select.dropdown.width"), ";\n}\n\n.p-select-dropdown {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n    background: transparent;\n    color: ").concat(dt3("select.dropdown.color"), ";\n    width: ").concat(dt3("select.dropdown.width"), ";\n    border-top-right-radius: ").concat(dt3("select.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("select.border.radius"), ";\n}\n\n.p-select-label {\n    display: block;\n    white-space: nowrap;\n    overflow: hidden;\n    flex: 1 1 auto;\n    width: 1%;\n    padding: ").concat(dt3("select.padding.y"), " ").concat(dt3("select.padding.x"), ";\n    text-overflow: ellipsis;\n    cursor: pointer;\n    color: ").concat(dt3("select.color"), ";\n    background: transparent;\n    border: 0 none;\n    outline: 0 none;\n}\n\n.p-select-label.p-placeholder {\n    color: ").concat(dt3("select.placeholder.color"), ";\n}\n\n.p-select:has(.p-select-clear-icon) .p-select-label {\n    padding-right: calc(1rem + ").concat(dt3("select.padding.x"), ");\n}\n\n.p-select.p-disabled .p-select-label {\n    color: ").concat(dt3("select.disabled.color"), ";\n}\n\n.p-select-label-empty {\n    overflow: hidden;\n    opacity: 0;\n}\n\ninput.p-select-label {\n    cursor: default;\n}\n\n.p-select .p-select-overlay {\n    min-width: 100%;\n}\n\n.p-select-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    background: ").concat(dt3("select.overlay.background"), ";\n    color: ").concat(dt3("select.overlay.color"), ";\n    border: 1px solid ").concat(dt3("select.overlay.border.color"), ";\n    border-radius: ").concat(dt3("select.overlay.border.radius"), ";\n    box-shadow: ").concat(dt3("select.overlay.shadow"), ";\n}\n\n.p-select-header {\n    padding: ").concat(dt3("select.list.header.padding"), ";\n}\n\n.p-select-filter {\n    width: 100%;\n}\n\n.p-select-list-container {\n    overflow: auto;\n}\n\n.p-select-option-group {\n    cursor: auto;\n    margin: 0;\n    padding: ").concat(dt3("select.option.group.padding"), ";\n    background: ").concat(dt3("select.option.group.background"), ";\n    color: ").concat(dt3("select.option.group.color"), ";\n    font-weight: ").concat(dt3("select.option.group.font.weight"), ";\n}\n\n.p-select-list {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    padding: ").concat(dt3("select.list.padding"), ";\n    gap: ").concat(dt3("select.list.gap"), ";\n    display: flex;\n    flex-direction: column;\n}\n\n.p-select-option {\n    cursor: pointer;\n    font-weight: normal;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt3("select.option.padding"), ";\n    border: 0 none;\n    color: ").concat(dt3("select.option.color"), ";\n    background: transparent;\n    transition: background ").concat(dt3("select.transition.duration"), ", color ").concat(dt3("select.transition.duration"), ", border-color ").concat(dt3("select.transition.duration"), ",\n            box-shadow ").concat(dt3("select.transition.duration"), ", outline-color ").concat(dt3("select.transition.duration"), ";\n    border-radius: ").concat(dt3("select.option.border.radius"), ";\n}\n\n.p-select-option:not(.p-select-option-selected):not(.p-disabled).p-focus {\n    background: ").concat(dt3("select.option.focus.background"), ";\n    color: ").concat(dt3("select.option.focus.color"), ";\n}\n\n.p-select-option.p-select-option-selected {\n    background: ").concat(dt3("select.option.selected.background"), ";\n    color: ").concat(dt3("select.option.selected.color"), ";\n}\n\n.p-select-option.p-select-option-selected.p-focus {\n    background: ").concat(dt3("select.option.selected.focus.background"), ";\n    color: ").concat(dt3("select.option.selected.focus.color"), ";\n}\n\n.p-select-option-check-icon {\n    position: relative;\n    margin-inline-start: ").concat(dt3("select.checkmark.gutter.start"), ";\n    margin-inline-end: ").concat(dt3("select.checkmark.gutter.end"), ";\n    color: ").concat(dt3("select.checkmark.color"), ";\n}\n\n.p-select-empty-message {\n    padding: ").concat(dt3("select.empty.message.padding"), ";\n}\n\n.p-select-fluid {\n    display: flex;\n}\n");
};
var classes$j = {
  root: function root10(_ref2) {
    var instance = _ref2.instance, props = _ref2.props, state = _ref2.state;
    return ["p-select p-component p-inputwrapper", {
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled",
      "p-focus": state.focused,
      "p-inputwrapper-filled": instance.hasSelectedOption,
      "p-inputwrapper-focus": state.focused || state.overlayVisible,
      "p-select-open": state.overlayVisible,
      "p-select-fluid": props.fluid
    }];
  },
  label: function label(_ref3) {
    var instance = _ref3.instance, props = _ref3.props;
    return ["p-select-label", {
      "p-placeholder": !props.editable && instance.label === props.placeholder,
      "p-select-label-empty": !props.editable && !instance.$slots["value"] && (instance.label === "p-emptylabel" || instance.label.length === 0)
    }];
  },
  clearIcon: "p-select-clear-icon",
  dropdown: "p-select-dropdown",
  loadingicon: "p-select-loading-icon",
  dropdownIcon: "p-select-dropdown-icon",
  overlay: "p-select-overlay p-component",
  header: "p-select-header",
  pcFilter: "p-select-filter",
  listContainer: "p-select-list-container",
  list: "p-select-list",
  optionGroup: "p-select-option-group",
  optionGroupLabel: "p-select-option-group-label",
  option: function option2(_ref4) {
    var instance = _ref4.instance, props = _ref4.props, state = _ref4.state, _option = _ref4.option, focusedOption = _ref4.focusedOption;
    return ["p-select-option", {
      "p-select-option-selected": instance.isSelected(_option) && props.highlightOnSelect,
      "p-focus": state.focusedOptionIndex === focusedOption,
      "p-disabled": instance.isOptionDisabled(_option)
    }];
  },
  optionLabel: "p-select-option-label",
  optionCheckIcon: "p-select-option-check-icon",
  optionBlankIcon: "p-select-option-blank-icon",
  emptyMessage: "p-select-empty-message"
};
var SelectStyle = BaseStyle.extend({
  name: "select",
  theme: theme$i,
  classes: classes$j
});
var script$1$k = {
  name: "BaseSelect",
  "extends": script$1a,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: [String, Function],
    optionValue: [String, Function],
    optionDisabled: [String, Function],
    optionGroupLabel: [String, Function],
    optionGroupChildren: [String, Function],
    scrollHeight: {
      type: String,
      "default": "14rem"
    },
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      "default": "contains"
    },
    filterFields: {
      type: Array,
      "default": null
    },
    editable: Boolean,
    placeholder: {
      type: String,
      "default": null
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    dataKey: null,
    showClear: {
      type: Boolean,
      "default": false
    },
    fluid: {
      type: Boolean,
      "default": false
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    labelId: {
      type: String,
      "default": null
    },
    labelClass: {
      type: [String, Object],
      "default": null
    },
    labelStyle: {
      type: Object,
      "default": null
    },
    panelClass: {
      type: [String, Object],
      "default": null
    },
    overlayStyle: {
      type: Object,
      "default": null
    },
    overlayClass: {
      type: [String, Object],
      "default": null
    },
    panelStyle: {
      type: Object,
      "default": null
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    loading: {
      type: Boolean,
      "default": false
    },
    clearIcon: {
      type: String,
      "default": void 0
    },
    dropdownIcon: {
      type: String,
      "default": void 0
    },
    filterIcon: {
      type: String,
      "default": void 0
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    resetFilterOnHide: {
      type: Boolean,
      "default": false
    },
    resetFilterOnClear: {
      type: Boolean,
      "default": false
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    autoOptionFocus: {
      type: Boolean,
      "default": false
    },
    autoFilterFocus: {
      type: Boolean,
      "default": false
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    focusOnHover: {
      type: Boolean,
      "default": true
    },
    highlightOnSelect: {
      type: Boolean,
      "default": true
    },
    checkmark: {
      type: Boolean,
      "default": false
    },
    filterMessage: {
      type: String,
      "default": null
    },
    selectionMessage: {
      type: String,
      "default": null
    },
    emptySelectionMessage: {
      type: String,
      "default": null
    },
    emptyFilterMessage: {
      type: String,
      "default": null
    },
    emptyMessage: {
      type: String,
      "default": null
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: SelectStyle,
  provide: function provide18() {
    return {
      $pcSelect: this,
      $parentInstance: this
    };
  }
};
function _typeof$i(o) {
  "@babel/helpers - typeof";
  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$i(o);
}
function _toConsumableArray$b(r) {
  return _arrayWithoutHoles$b(r) || _iterableToArray$b(r) || _unsupportedIterableToArray$d(r) || _nonIterableSpread$b();
}
function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$d(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$d(r, a) : void 0;
  }
}
function _iterableToArray$b(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$b(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$d(r);
}
function _arrayLikeToArray$d(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function ownKeys$i(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$i(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$i(Object(t), true).forEach(function(r2) {
      _defineProperty$h(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$h(e, r, t) {
  return (r = _toPropertyKey$g(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$g(t) {
  var i2 = _toPrimitive$g(t, "string");
  return "symbol" == _typeof$i(i2) ? i2 : i2 + "";
}
function _toPrimitive$g(t, r) {
  if ("object" != _typeof$i(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$i(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var script$M = {
  name: "Select",
  "extends": script$1$k,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "before-show", "before-hide", "show", "hide", "filter"],
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  labelClickListener: null,
  overlay: null,
  list: null,
  virtualScroller: null,
  searchTimeout: null,
  searchValue: null,
  isModelValueChanged: false,
  data: function data7() {
    return {
      id: this.$attrs.id,
      clicked: false,
      focused: false,
      focusedOptionIndex: -1,
      filterValue: null,
      overlayVisible: false
    };
  },
  watch: {
    "$attrs.id": function $attrsId3(newValue) {
      this.id = newValue || UniqueComponentId();
    },
    modelValue: function modelValue2() {
      this.isModelValueChanged = true;
    },
    options: function options2() {
      this.autoUpdateModel();
    }
  },
  mounted: function mounted7() {
    this.id = this.id || UniqueComponentId();
    this.autoUpdateModel();
    this.bindLabelClickListener();
  },
  updated: function updated4() {
    if (this.overlayVisible && this.isModelValueChanged) {
      this.scrollInView(this.findSelectedOptionIndex());
    }
    this.isModelValueChanged = false;
  },
  beforeUnmount: function beforeUnmount2() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();
    this.unbindLabelClickListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    if (this.overlay) {
      ZIndex.clear(this.overlay);
      this.overlay = null;
    }
  },
  methods: {
    getOptionIndex: function getOptionIndex2(index2, fn) {
      return this.virtualScrollerDisabled ? index2 : fn && fn(index2)["index"];
    },
    getOptionLabel: function getOptionLabel2(option4) {
      return this.optionLabel ? resolveFieldData(option4, this.optionLabel) : option4;
    },
    getOptionValue: function getOptionValue3(option4) {
      return this.optionValue ? resolveFieldData(option4, this.optionValue) : option4;
    },
    getOptionRenderKey: function getOptionRenderKey2(option4, index2) {
      return (this.dataKey ? resolveFieldData(option4, this.dataKey) : this.getOptionLabel(option4)) + "_" + index2;
    },
    getPTItemOptions: function getPTItemOptions(option4, itemOptions, index2, key) {
      return this.ptm(key, {
        context: {
          option: option4,
          index: index2,
          selected: this.isSelected(option4),
          focused: this.focusedOptionIndex === this.getOptionIndex(index2, itemOptions),
          disabled: this.isOptionDisabled(option4)
        }
      });
    },
    isOptionDisabled: function isOptionDisabled2(option4) {
      return this.optionDisabled ? resolveFieldData(option4, this.optionDisabled) : false;
    },
    isOptionGroup: function isOptionGroup2(option4) {
      return this.optionGroupLabel && option4.optionGroup && option4.group;
    },
    getOptionGroupLabel: function getOptionGroupLabel2(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupLabel);
    },
    getOptionGroupChildren: function getOptionGroupChildren2(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupChildren);
    },
    getAriaPosInset: function getAriaPosInset2(index2) {
      var _this = this;
      return (this.optionGroupLabel ? index2 - this.visibleOptions.slice(0, index2).filter(function(option4) {
        return _this.isOptionGroup(option4);
      }).length : index2) + 1;
    },
    show: function show2(isFocus) {
      this.$emit("before-show");
      this.overlayVisible = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex();
      isFocus && focus(this.$refs.focusInput);
    },
    hide: function hide2(isFocus) {
      var _this2 = this;
      var _hide = function _hide2() {
        _this2.$emit("before-hide");
        _this2.overlayVisible = false;
        _this2.clicked = false;
        _this2.focusedOptionIndex = -1;
        _this2.searchValue = "";
        _this2.resetFilterOnHide && (_this2.filterValue = null);
        isFocus && focus(_this2.$refs.focusInput);
      };
      setTimeout(function() {
        _hide();
      }, 0);
    },
    onFocus: function onFocus2(event2) {
      if (this.disabled) {
        return;
      }
      this.focused = true;
      if (this.overlayVisible) {
        this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex();
        this.scrollInView(this.focusedOptionIndex);
      }
      this.$emit("focus", event2);
    },
    onBlur: function onBlur2(event2) {
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.searchValue = "";
      this.$emit("blur", event2);
    },
    onKeyDown: function onKeyDown(event2) {
      if (this.disabled || isAndroid$1()) {
        event2.preventDefault();
        return;
      }
      var metaKey = event2.metaKey || event2.ctrlKey;
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2, this.editable);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, this.editable);
          break;
        case "Home":
          this.onHomeKey(event2, this.editable);
          break;
        case "End":
          this.onEndKey(event2, this.editable);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Space":
          this.onSpaceKey(event2, this.editable);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2);
          break;
        case "Backspace":
          this.onBackspaceKey(event2, this.editable);
          break;
        case "ShiftLeft":
        case "ShiftRight":
          break;
        default:
          if (!metaKey && isPrintableCharacter(event2.key)) {
            !this.overlayVisible && this.show();
            !this.editable && this.searchOptions(event2, event2.key);
          }
          break;
      }
      this.clicked = false;
    },
    onEditableInput: function onEditableInput(event2) {
      var value3 = event2.target.value;
      this.searchValue = "";
      var matched = this.searchOptions(event2, value3);
      !matched && (this.focusedOptionIndex = -1);
      this.updateModel(event2, value3);
      !this.overlayVisible && isNotEmpty(value3) && this.show();
    },
    onContainerClick: function onContainerClick(event2) {
      if (this.disabled || this.loading) {
        return;
      }
      if (event2.target.tagName === "INPUT" || event2.target.getAttribute("data-pc-section") === "clearicon" || event2.target.closest('[data-pc-section="clearicon"]')) {
        return;
      } else if (!this.overlay || !this.overlay.contains(event2.target)) {
        this.overlayVisible ? this.hide(true) : this.show(true);
      }
      this.clicked = true;
    },
    onClearClick: function onClearClick(event2) {
      this.updateModel(event2, null);
      this.resetFilterOnClear && (this.filterValue = null);
    },
    onFirstHiddenFocus: function onFirstHiddenFocus2(event2) {
      var focusableEl = event2.relatedTarget === this.$refs.focusInput ? getFirstFocusableElement(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput;
      focus(focusableEl);
    },
    onLastHiddenFocus: function onLastHiddenFocus2(event2) {
      var focusableEl = event2.relatedTarget === this.$refs.focusInput ? getLastFocusableElement(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput;
      focus(focusableEl);
    },
    onOptionSelect: function onOptionSelect2(event2, option4) {
      var isHide = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var value3 = this.getOptionValue(option4);
      this.updateModel(event2, value3);
      isHide && this.hide(true);
    },
    onOptionMouseMove: function onOptionMouseMove2(event2, index2) {
      if (this.focusOnHover) {
        this.changeFocusedOptionIndex(event2, index2);
      }
    },
    onFilterChange: function onFilterChange2(event2) {
      var value3 = event2.target.value;
      this.filterValue = value3;
      this.focusedOptionIndex = -1;
      this.$emit("filter", {
        originalEvent: event2,
        value: value3
      });
      !this.virtualScrollerDisabled && this.virtualScroller.scrollToIndex(0);
    },
    onFilterKeyDown: function onFilterKeyDown2(event2) {
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2, true);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(event2, true);
          break;
        case "Home":
          this.onHomeKey(event2, true);
          break;
        case "End":
          this.onEndKey(event2, true);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2, true);
          break;
      }
    },
    onFilterBlur: function onFilterBlur2() {
      this.focusedOptionIndex = -1;
    },
    onFilterUpdated: function onFilterUpdated() {
      if (this.overlayVisible) {
        this.alignOverlay();
      }
    },
    onOverlayClick: function onOverlayClick(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.$el
      });
    },
    onOverlayKeyDown: function onOverlayKeyDown(event2) {
      switch (event2.code) {
        case "Escape":
          this.onEscapeKey(event2);
          break;
      }
    },
    onArrowDownKey: function onArrowDownKey2(event2) {
      if (!this.overlayVisible) {
        this.show();
        this.editable && this.changeFocusedOptionIndex(event2, this.findSelectedOptionIndex());
      } else {
        var optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findFirstOptionIndex() : this.findFirstFocusedOptionIndex();
        this.changeFocusedOptionIndex(event2, optionIndex);
      }
      event2.preventDefault();
    },
    onArrowUpKey: function onArrowUpKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (event2.altKey && !pressedInInputText) {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
        }
        this.overlayVisible && this.hide();
        event2.preventDefault();
      } else {
        var optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findLastOptionIndex() : this.findLastFocusedOptionIndex();
        this.changeFocusedOptionIndex(event2, optionIndex);
        !this.overlayVisible && this.show();
        event2.preventDefault();
      }
    },
    onArrowLeftKey: function onArrowLeftKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      pressedInInputText && (this.focusedOptionIndex = -1);
    },
    onHomeKey: function onHomeKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(0, event2.target.selectionStart);
        } else {
          target.setSelectionRange(0, 0);
          this.focusedOptionIndex = -1;
        }
      } else {
        this.changeFocusedOptionIndex(event2, this.findFirstOptionIndex());
        !this.overlayVisible && this.show();
      }
      event2.preventDefault();
    },
    onEndKey: function onEndKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        var target = event2.currentTarget;
        if (event2.shiftKey) {
          target.setSelectionRange(event2.target.selectionStart, target.value.length);
        } else {
          var len = target.value.length;
          target.setSelectionRange(len, len);
          this.focusedOptionIndex = -1;
        }
      } else {
        this.changeFocusedOptionIndex(event2, this.findLastOptionIndex());
        !this.overlayVisible && this.show();
      }
      event2.preventDefault();
    },
    onPageUpKey: function onPageUpKey2(event2) {
      this.scrollInView(0);
      event2.preventDefault();
    },
    onPageDownKey: function onPageDownKey2(event2) {
      this.scrollInView(this.visibleOptions.length - 1);
      event2.preventDefault();
    },
    onEnterKey: function onEnterKey2(event2) {
      if (!this.overlayVisible) {
        this.focusedOptionIndex = -1;
        this.onArrowDownKey(event2);
      } else {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
        }
        this.hide();
      }
      event2.preventDefault();
    },
    onSpaceKey: function onSpaceKey2(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      !pressedInInputText && this.onEnterKey(event2);
    },
    onEscapeKey: function onEscapeKey(event2) {
      this.overlayVisible && this.hide(true);
      event2.preventDefault();
      event2.stopPropagation();
    },
    onTabKey: function onTabKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!pressedInInputText) {
        if (this.overlayVisible && this.hasFocusableElements()) {
          focus(this.$refs.firstHiddenFocusableElementOnOverlay);
          event2.preventDefault();
        } else {
          if (this.focusedOptionIndex !== -1) {
            this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
          }
          this.overlayVisible && this.hide(this.filter);
        }
      }
    },
    onBackspaceKey: function onBackspaceKey(event2) {
      var pressedInInputText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (pressedInInputText) {
        !this.overlayVisible && this.show();
      }
    },
    onOverlayEnter: function onOverlayEnter(el) {
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
      addStyle(el, {
        position: "absolute",
        top: "0",
        left: "0"
      });
      this.alignOverlay();
      this.scrollInView();
      this.autoFilterFocus && focus(this.$refs.filterInput.$el);
    },
    onOverlayAfterEnter: function onOverlayAfterEnter() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.$emit("show");
    },
    onOverlayLeave: function onOverlayLeave() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit("hide");
      this.overlay = null;
    },
    onOverlayAfterLeave: function onOverlayAfterLeave(el) {
      ZIndex.clear(el);
    },
    alignOverlay: function alignOverlay2() {
      if (this.appendTo === "self") {
        relativePosition(this.overlay, this.$el);
      } else {
        this.overlay.style.minWidth = getOuterWidth(this.$el) + "px";
        absolutePosition(this.overlay, this.$el);
      }
    },
    bindOutsideClickListener: function bindOutsideClickListener() {
      var _this3 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this3.overlayVisible && _this3.overlay && !_this3.$el.contains(event2.target) && !_this3.overlay.contains(event2.target)) {
            _this3.hide();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    },
    unbindOutsideClickListener: function unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },
    bindScrollListener: function bindScrollListener2() {
      var _this4 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, function() {
          if (_this4.overlayVisible) {
            _this4.hide();
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    },
    unbindScrollListener: function unbindScrollListener2() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },
    bindResizeListener: function bindResizeListener2() {
      var _this5 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this5.overlayVisible && !isTouchDevice()) {
            _this5.hide();
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    },
    unbindResizeListener: function unbindResizeListener2() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    },
    bindLabelClickListener: function bindLabelClickListener() {
      var _this6 = this;
      if (!this.editable && !this.labelClickListener) {
        var label5 = document.querySelector('label[for="'.concat(this.inputId, '"]'));
        if (label5 && isVisible(label5)) {
          this.labelClickListener = function() {
            focus(_this6.$refs.focusInput);
          };
          label5.addEventListener("click", this.labelClickListener);
        }
      }
    },
    unbindLabelClickListener: function unbindLabelClickListener() {
      if (this.labelClickListener) {
        var label5 = document.querySelector('label[for="'.concat(this.inputId, '"]'));
        if (label5 && isVisible(label5)) {
          label5.removeEventListener("click", this.labelClickListener);
        }
      }
    },
    hasFocusableElements: function hasFocusableElements() {
      return getFocusableElements(this.overlay, ':not([data-p-hidden-focusable="true"])').length > 0;
    },
    isOptionMatched: function isOptionMatched2(option4) {
      var _this$getOptionLabel;
      return this.isValidOption(option4) && typeof this.getOptionLabel(option4) === "string" && ((_this$getOptionLabel = this.getOptionLabel(option4)) === null || _this$getOptionLabel === void 0 ? void 0 : _this$getOptionLabel.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale)));
    },
    isValidOption: function isValidOption2(option4) {
      return isNotEmpty(option4) && !(this.isOptionDisabled(option4) || this.isOptionGroup(option4));
    },
    isValidSelectedOption: function isValidSelectedOption2(option4) {
      return this.isValidOption(option4) && this.isSelected(option4);
    },
    isSelected: function isSelected2(option4) {
      return this.isValidOption(option4) && equals(this.modelValue, this.getOptionValue(option4), this.equalityKey);
    },
    findFirstOptionIndex: function findFirstOptionIndex2() {
      var _this7 = this;
      return this.visibleOptions.findIndex(function(option4) {
        return _this7.isValidOption(option4);
      });
    },
    findLastOptionIndex: function findLastOptionIndex2() {
      var _this8 = this;
      return findLastIndex(this.visibleOptions, function(option4) {
        return _this8.isValidOption(option4);
      });
    },
    findNextOptionIndex: function findNextOptionIndex2(index2) {
      var _this9 = this;
      var matchedOptionIndex = index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option4) {
        return _this9.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : index2;
    },
    findPrevOptionIndex: function findPrevOptionIndex2(index2) {
      var _this10 = this;
      var matchedOptionIndex = index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option4) {
        return _this10.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    },
    findSelectedOptionIndex: function findSelectedOptionIndex2() {
      var _this11 = this;
      return this.hasSelectedOption ? this.visibleOptions.findIndex(function(option4) {
        return _this11.isValidSelectedOption(option4);
      }) : -1;
    },
    findFirstFocusedOptionIndex: function findFirstFocusedOptionIndex2() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    },
    findLastFocusedOptionIndex: function findLastFocusedOptionIndex2() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    },
    searchOptions: function searchOptions2(event2, _char) {
      var _this12 = this;
      this.searchValue = (this.searchValue || "") + _char;
      var optionIndex = -1;
      var matched = false;
      if (isNotEmpty(this.searchValue)) {
        if (this.focusedOptionIndex !== -1) {
          optionIndex = this.visibleOptions.slice(this.focusedOptionIndex).findIndex(function(option4) {
            return _this12.isOptionMatched(option4);
          });
          optionIndex = optionIndex === -1 ? this.visibleOptions.slice(0, this.focusedOptionIndex).findIndex(function(option4) {
            return _this12.isOptionMatched(option4);
          }) : optionIndex + this.focusedOptionIndex;
        } else {
          optionIndex = this.visibleOptions.findIndex(function(option4) {
            return _this12.isOptionMatched(option4);
          });
        }
        if (optionIndex !== -1) {
          matched = true;
        }
        if (optionIndex === -1 && this.focusedOptionIndex === -1) {
          optionIndex = this.findFirstFocusedOptionIndex();
        }
        if (optionIndex !== -1) {
          this.changeFocusedOptionIndex(event2, optionIndex);
        }
      }
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(function() {
        _this12.searchValue = "";
        _this12.searchTimeout = null;
      }, 500);
      return matched;
    },
    changeFocusedOptionIndex: function changeFocusedOptionIndex2(event2, index2) {
      if (this.focusedOptionIndex !== index2) {
        this.focusedOptionIndex = index2;
        this.scrollInView();
        if (this.selectOnFocus) {
          this.onOptionSelect(event2, this.visibleOptions[index2], false);
        }
      }
    },
    scrollInView: function scrollInView4() {
      var _this13 = this;
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var id2 = index2 !== -1 ? "".concat(_this13.id, "_").concat(index2) : _this13.focusedOptionId;
        var element = findSingle(_this13.list, 'li[id="'.concat(id2, '"]'));
        if (element) {
          element.scrollIntoView && element.scrollIntoView({
            block: "nearest",
            inline: "start"
          });
        } else if (!_this13.virtualScrollerDisabled) {
          _this13.virtualScroller && _this13.virtualScroller.scrollToIndex(index2 !== -1 ? index2 : _this13.focusedOptionIndex);
        }
      });
    },
    autoUpdateModel: function autoUpdateModel2() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], false);
      }
    },
    updateModel: function updateModel3(event2, value3) {
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        originalEvent: event2,
        value: value3
      });
    },
    flatOptions: function flatOptions2(options3) {
      var _this14 = this;
      return (options3 || []).reduce(function(result, option4, index2) {
        result.push({
          optionGroup: option4,
          group: true,
          index: index2
        });
        var optionGroupChildren = _this14.getOptionGroupChildren(option4);
        optionGroupChildren && optionGroupChildren.forEach(function(o) {
          return result.push(o);
        });
        return result;
      }, []);
    },
    overlayRef: function overlayRef(el) {
      this.overlay = el;
    },
    listRef: function listRef2(el, contentRef3) {
      this.list = el;
      contentRef3 && contentRef3(el);
    },
    virtualScrollerRef: function virtualScrollerRef2(el) {
      this.virtualScroller = el;
    }
  },
  computed: {
    visibleOptions: function visibleOptions2() {
      var _this15 = this;
      var options3 = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
      if (this.filterValue) {
        var filteredOptions = FilterService.filter(options3, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale);
        if (this.optionGroupLabel) {
          var optionGroups = this.options || [];
          var filtered = [];
          optionGroups.forEach(function(group) {
            var groupChildren = _this15.getOptionGroupChildren(group);
            var filteredItems = groupChildren.filter(function(item) {
              return filteredOptions.includes(item);
            });
            if (filteredItems.length > 0) filtered.push(_objectSpread$i(_objectSpread$i({}, group), {}, _defineProperty$h({}, typeof _this15.optionGroupChildren === "string" ? _this15.optionGroupChildren : "items", _toConsumableArray$b(filteredItems))));
          });
          return this.flatOptions(filtered);
        }
        return filteredOptions;
      }
      return options3;
    },
    hasSelectedOption: function hasSelectedOption2() {
      return isNotEmpty(this.modelValue);
    },
    label: function label2() {
      var selectedOptionIndex = this.findSelectedOptionIndex();
      return selectedOptionIndex !== -1 ? this.getOptionLabel(this.visibleOptions[selectedOptionIndex]) : this.placeholder || "p-emptylabel";
    },
    editableInputValue: function editableInputValue() {
      var selectedOptionIndex = this.findSelectedOptionIndex();
      return selectedOptionIndex !== -1 ? this.getOptionLabel(this.visibleOptions[selectedOptionIndex]) : this.modelValue || "";
    },
    equalityKey: function equalityKey2() {
      return this.optionValue ? null : this.dataKey;
    },
    searchFields: function searchFields2() {
      return this.filterFields || [this.optionLabel];
    },
    filterResultMessageText: function filterResultMessageText2() {
      return isNotEmpty(this.visibleOptions) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptyFilterMessageText;
    },
    filterMessageText: function filterMessageText2() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || "";
    },
    emptyFilterMessageText: function emptyFilterMessageText2() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || "";
    },
    emptyMessageText: function emptyMessageText2() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || "";
    },
    selectionMessageText: function selectionMessageText2() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    },
    emptySelectionMessageText: function emptySelectionMessageText2() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    },
    selectedMessageText: function selectedMessageText2() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll("{0}", "1") : this.emptySelectionMessageText;
    },
    focusedOptionId: function focusedOptionId2() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.id, "_").concat(this.focusedOptionIndex) : null;
    },
    ariaSetSize: function ariaSetSize2() {
      var _this16 = this;
      return this.visibleOptions.filter(function(option4) {
        return !_this16.isOptionGroup(option4);
      }).length;
    },
    virtualScrollerDisabled: function virtualScrollerDisabled2() {
      return !this.virtualScrollerOptions;
    }
  },
  directives: {
    ripple: Ripple
  },
  components: {
    InputText: script$Z,
    VirtualScroller: script$Y,
    Portal: script$N,
    InputIcon: script$_,
    IconField: script$$,
    TimesIcon: script$O,
    ChevronDownIcon: script$P,
    SpinnerIcon: script$14,
    SearchIcon: script$10,
    CheckIcon: script$11,
    BlankIcon: script$12
  }
};
var _hoisted_1$Q = ["id"];
var _hoisted_2$G = ["id", "value", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid"];
var _hoisted_3$b = ["id", "tabindex", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-disabled"];
var _hoisted_4$9 = ["id"];
var _hoisted_5$6 = ["id"];
var _hoisted_6$5 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousemove", "data-p-selected", "data-p-focused", "data-p-disabled"];
function render$L(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_BlankIcon = resolveComponent("BlankIcon");
  var _component_VirtualScroller = resolveComponent("VirtualScroller");
  var _component_Portal = resolveComponent("Portal");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    id: $data.id,
    "class": _ctx.cx("root"),
    onClick: _cache[11] || (_cache[11] = function() {
      return $options.onContainerClick && $options.onContainerClick.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [_ctx.editable ? (openBlock(), createElementBlock("input", mergeProps({
    key: 0,
    ref: "focusInput",
    id: _ctx.labelId || _ctx.inputId,
    type: "text",
    "class": [_ctx.cx("label"), _ctx.inputClass, _ctx.labelClass],
    style: [_ctx.inputStyle, _ctx.labelStyle],
    value: $options.editableInputValue,
    placeholder: _ctx.placeholder,
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    disabled: _ctx.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $data.id + "_list",
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onKeydown: _cache[2] || (_cache[2] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    }),
    onInput: _cache[3] || (_cache[3] = function() {
      return $options.onEditableInput && $options.onEditableInput.apply($options, arguments);
    })
  }, _ctx.ptm("label")), null, 16, _hoisted_2$G)) : (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    ref: "focusInput",
    id: _ctx.labelId || _ctx.inputId,
    "class": [_ctx.cx("label"), _ctx.inputClass, _ctx.labelClass],
    style: [_ctx.inputStyle, _ctx.labelStyle],
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    role: "combobox",
    "aria-label": _ctx.ariaLabel || ($options.label === "p-emptylabel" ? void 0 : $options.label),
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $data.id + "_list",
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    "aria-disabled": _ctx.disabled,
    onFocus: _cache[4] || (_cache[4] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[5] || (_cache[5] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onKeydown: _cache[6] || (_cache[6] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    })
  }, _ctx.ptm("label")), [renderSlot(_ctx.$slots, "value", {
    value: _ctx.modelValue,
    placeholder: _ctx.placeholder
  }, function() {
    return [createTextVNode(toDisplayString$1($options.label === "p-emptylabel" ? " " : $options.label || "empty"), 1)];
  })], 16, _hoisted_3$b)), _ctx.showClear && _ctx.modelValue != null ? renderSlot(_ctx.$slots, "clearicon", {
    key: 2,
    "class": normalizeClass(_ctx.cx("clearIcon")),
    clearCallback: $options.onClearClick
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon ? "i" : "TimesIcon"), mergeProps({
      ref: "clearIcon",
      "class": [_ctx.cx("clearIcon"), _ctx.clearIcon],
      onClick: $options.onClearClick
    }, _ctx.ptm("clearIcon"), {
      "data-pc-section": "clearicon"
    }), null, 16, ["class", "onClick"]))];
  }) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("dropdown")
  }, _ctx.ptm("dropdown")), [_ctx.loading ? renderSlot(_ctx.$slots, "loadingicon", {
    key: 0,
    "class": normalizeClass(_ctx.cx("loadingIcon"))
  }, function() {
    return [_ctx.loadingIcon ? (openBlock(), createElementBlock("span", mergeProps({
      key: 0,
      "class": [_ctx.cx("loadingIcon"), "pi-spin", _ctx.loadingIcon],
      "aria-hidden": "true"
    }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
      key: 1,
      "class": _ctx.cx("loadingIcon"),
      spin: "",
      "aria-hidden": "true"
    }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
  }) : renderSlot(_ctx.$slots, "dropdownicon", {
    key: 1,
    "class": normalizeClass(_ctx.cx("dropdownIcon"))
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.dropdownIcon ? "span" : "ChevronDownIcon"), mergeProps({
      "class": [_ctx.cx("dropdownIcon"), _ctx.dropdownIcon],
      "aria-hidden": "true"
    }, _ctx.ptm("dropdownIcon")), null, 16, ["class"]))];
  })], 16), createVNode(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-connected-overlay",
        onEnter: $options.onOverlayEnter,
        onAfterEnter: $options.onOverlayAfterEnter,
        onLeave: $options.onOverlayLeave,
        onAfterLeave: $options.onOverlayAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.overlayRef,
            "class": [_ctx.cx("overlay"), _ctx.panelClass, _ctx.overlayClass],
            style: [_ctx.panelStyle, _ctx.overlayStyle],
            onClick: _cache[9] || (_cache[9] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            onKeydown: _cache[10] || (_cache[10] = function() {
              return $options.onOverlayKeyDown && $options.onOverlayKeyDown.apply($options, arguments);
            })
          }, _ctx.ptm("overlay")), [createBaseVNode("span", mergeProps({
            ref: "firstHiddenFocusableElementOnOverlay",
            role: "presentation",
            "aria-hidden": "true",
            "class": "p-hidden-accessible p-hidden-focusable",
            tabindex: 0,
            onFocus: _cache[7] || (_cache[7] = function() {
              return $options.onFirstHiddenFocus && $options.onFirstHiddenFocus.apply($options, arguments);
            })
          }, _ctx.ptm("hiddenFirstFocusableEl"), {
            "data-p-hidden-accessible": true,
            "data-p-hidden-focusable": true
          }), null, 16), renderSlot(_ctx.$slots, "header", {
            value: _ctx.modelValue,
            options: $options.visibleOptions
          }), _ctx.filter ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            "class": _ctx.cx("header")
          }, _ctx.ptm("header")), [createVNode(_component_IconField, mergeProps({
            unstyled: _ctx.unstyled
          }, _ctx.ptm("pcFilterContainer")), {
            "default": withCtx(function() {
              return [createVNode(_component_InputText, {
                ref: "filterInput",
                type: "text",
                value: $data.filterValue,
                onVnodeMounted: $options.onFilterUpdated,
                onVnodeUpdated: $options.onFilterUpdated,
                "class": normalizeClass(_ctx.cx("pcFilter")),
                placeholder: _ctx.filterPlaceholder,
                variant: _ctx.variant,
                unstyled: _ctx.unstyled,
                role: "searchbox",
                autocomplete: "off",
                "aria-owns": $data.id + "_list",
                "aria-activedescendant": $options.focusedOptionId,
                onKeydown: $options.onFilterKeyDown,
                onBlur: $options.onFilterBlur,
                onInput: $options.onFilterChange,
                pt: _ctx.ptm("pcFilter")
              }, null, 8, ["value", "onVnodeMounted", "onVnodeUpdated", "class", "placeholder", "variant", "unstyled", "aria-owns", "aria-activedescendant", "onKeydown", "onBlur", "onInput", "pt"]), createVNode(_component_InputIcon, mergeProps({
                unstyled: _ctx.unstyled
              }, _ctx.ptm("pcFilterIconContainer")), {
                "default": withCtx(function() {
                  return [renderSlot(_ctx.$slots, "filtericon", {}, function() {
                    return [_ctx.filterIcon ? (openBlock(), createElementBlock("span", mergeProps({
                      key: 0,
                      "class": _ctx.filterIcon
                    }, _ctx.ptm("filterIcon")), null, 16)) : (openBlock(), createBlock(_component_SearchIcon, normalizeProps(mergeProps({
                      key: 1
                    }, _ctx.ptm("filterIcon"))), null, 16))];
                  })];
                }),
                _: 3
              }, 16, ["unstyled"])];
            }),
            _: 3
          }, 16, ["unstyled"]), createBaseVNode("span", mergeProps({
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenFilterResult"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.filterResultMessageText), 17)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("listContainer"),
            style: {
              "max-height": $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
            }
          }, _ctx.ptm("listContainer")), [createVNode(_component_VirtualScroller, mergeProps({
            ref: $options.virtualScrollerRef
          }, _ctx.virtualScrollerOptions, {
            items: $options.visibleOptions,
            style: {
              height: _ctx.scrollHeight
            },
            tabindex: -1,
            disabled: $options.virtualScrollerDisabled,
            pt: _ctx.ptm("virtualScroller")
          }), createSlots({
            content: withCtx(function(_ref) {
              var styleClass = _ref.styleClass, contentRef3 = _ref.contentRef, items2 = _ref.items, getItemOptions = _ref.getItemOptions, contentStyle = _ref.contentStyle, itemSize2 = _ref.itemSize;
              return [createBaseVNode("ul", mergeProps({
                ref: function ref2(el) {
                  return $options.listRef(el, contentRef3);
                },
                id: $data.id + "_list",
                "class": [_ctx.cx("list"), styleClass],
                style: contentStyle,
                role: "listbox"
              }, _ctx.ptm("list")), [(openBlock(true), createElementBlock(Fragment, null, renderList(items2, function(option4, i2) {
                return openBlock(), createElementBlock(Fragment, {
                  key: $options.getOptionRenderKey(option4, $options.getOptionIndex(i2, getItemOptions))
                }, [$options.isOptionGroup(option4) ? (openBlock(), createElementBlock("li", mergeProps({
                  key: 0,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  "class": _ctx.cx("optionGroup"),
                  role: "option",
                  ref_for: true
                }, _ctx.ptm("optionGroup")), [renderSlot(_ctx.$slots, "optiongroup", {
                  option: option4.optionGroup,
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createBaseVNode("span", mergeProps({
                    "class": _ctx.cx("optionGroupLabel"),
                    ref_for: true
                  }, _ctx.ptm("optionGroupLabel")), toDisplayString$1($options.getOptionGroupLabel(option4.optionGroup)), 17)];
                })], 16, _hoisted_5$6)) : withDirectives((openBlock(), createElementBlock("li", mergeProps({
                  key: 1,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  "class": _ctx.cx("option", {
                    option: option4,
                    focusedOption: $options.getOptionIndex(i2, getItemOptions)
                  }),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  role: "option",
                  "aria-label": $options.getOptionLabel(option4),
                  "aria-selected": $options.isSelected(option4),
                  "aria-disabled": $options.isOptionDisabled(option4),
                  "aria-setsize": $options.ariaSetSize,
                  "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i2, getItemOptions)),
                  onClick: function onClick5($event) {
                    return $options.onOptionSelect($event, option4);
                  },
                  onMousemove: function onMousemove($event) {
                    return $options.onOptionMouseMove($event, $options.getOptionIndex(i2, getItemOptions));
                  },
                  "data-p-selected": $options.isSelected(option4),
                  "data-p-focused": $data.focusedOptionIndex === $options.getOptionIndex(i2, getItemOptions),
                  "data-p-disabled": $options.isOptionDisabled(option4),
                  ref_for: true
                }, $options.getPTItemOptions(option4, getItemOptions, i2, "option")), [_ctx.checkmark ? (openBlock(), createElementBlock(Fragment, {
                  key: 0
                }, [$options.isSelected(option4) ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
                  key: 0,
                  "class": _ctx.cx("optionCheckIcon"),
                  ref_for: true
                }, _ctx.ptm("optionCheckIcon")), null, 16, ["class"])) : (openBlock(), createBlock(_component_BlankIcon, mergeProps({
                  key: 1,
                  "class": _ctx.cx("optionBlankIcon"),
                  ref_for: true
                }, _ctx.ptm("optionBlankIcon")), null, 16, ["class"]))], 64)) : createCommentVNode("", true), renderSlot(_ctx.$slots, "option", {
                  option: option4,
                  selected: $options.isSelected(option4),
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createBaseVNode("span", mergeProps({
                    "class": _ctx.cx("optionLabel"),
                    ref_for: true
                  }, _ctx.ptm("optionLabel")), toDisplayString$1($options.getOptionLabel(option4)), 17)];
                })], 16, _hoisted_6$5)), [[_directive_ripple]])], 64);
              }), 128)), $data.filterValue && (!items2 || items2 && items2.length === 0) ? (openBlock(), createElementBlock("li", mergeProps({
                key: 0,
                "class": _ctx.cx("emptyMessage"),
                role: "option"
              }, _ctx.ptm("emptyMessage"), {
                "data-p-hidden-accessible": true
              }), [renderSlot(_ctx.$slots, "emptyfilter", {}, function() {
                return [createTextVNode(toDisplayString$1($options.emptyFilterMessageText), 1)];
              })], 16)) : !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("li", mergeProps({
                key: 1,
                "class": _ctx.cx("emptyMessage"),
                role: "option"
              }, _ctx.ptm("emptyMessage"), {
                "data-p-hidden-accessible": true
              }), [renderSlot(_ctx.$slots, "empty", {}, function() {
                return [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)];
              })], 16)) : createCommentVNode("", true)], 16, _hoisted_4$9)];
            }),
            _: 2
          }, [_ctx.$slots.loader ? {
            name: "loader",
            fn: withCtx(function(_ref2) {
              var options3 = _ref2.options;
              return [renderSlot(_ctx.$slots, "loader", {
                options: options3
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["items", "style", "disabled", "pt"])], 16), renderSlot(_ctx.$slots, "footer", {
            value: _ctx.modelValue,
            options: $options.visibleOptions
          }), !_ctx.options || _ctx.options && _ctx.options.length === 0 ? (openBlock(), createElementBlock("span", mergeProps({
            key: 1,
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenEmptyMessage"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.emptyMessageText), 17)) : createCommentVNode("", true), createBaseVNode("span", mergeProps({
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenSelectedMessage"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.selectedMessageText), 17), createBaseVNode("span", mergeProps({
            ref: "lastHiddenFocusableElementOnOverlay",
            role: "presentation",
            "aria-hidden": "true",
            "class": "p-hidden-accessible p-hidden-focusable",
            tabindex: 0,
            onFocus: _cache[8] || (_cache[8] = function() {
              return $options.onLastHiddenFocus && $options.onLastHiddenFocus.apply($options, arguments);
            })
          }, _ctx.ptm("hiddenLastFocusableEl"), {
            "data-p-hidden-accessible": true,
            "data-p-hidden-focusable": true
          }), null, 16)], 16)) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"])], 16, _hoisted_1$Q);
}
script$M.render = render$L;
var theme$h = function theme18(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-toggleswitch {\n    display: inline-block;\n    width: ".concat(dt3("toggleswitch.width"), ";\n    height: ").concat(dt3("toggleswitch.height"), ";\n}\n\n.p-toggleswitch-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border-radius: ").concat(dt3("toggleswitch.border.radius"), ";\n}\n\n.p-toggleswitch-slider {\n    display: inline-block;\n    cursor: pointer;\n    width: 100%;\n    height: 100%;\n    border-width: ").concat(dt3("toggleswitch.border.width"), ";\n    border-style: solid;\n    border-color: ").concat(dt3("toggleswitch.border.color"), ";\n    background: ").concat(dt3("toggleswitch.background"), ";\n    transition: background ").concat(dt3("toggleswitch.transition.duration"), ", color ").concat(dt3("toggleswitch.transition.duration"), ", border-color ").concat(dt3("toggleswitch.transition.duration"), ", outline-color ").concat(dt3("toggleswitch.transition.duration"), ", box-shadow ").concat(dt3("toggleswitch.transition.duration"), ";\n    border-radius: ").concat(dt3("toggleswitch.border.radius"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("toggleswitch.shadow"), ';\n}\n\n.p-toggleswitch-slider:before {\n    position: absolute;\n    content: "";\n    top: 50%;\n    background: ').concat(dt3("toggleswitch.handle.background"), ";\n    width: ").concat(dt3("toggleswitch.handle.size"), ";\n    height: ").concat(dt3("toggleswitch.handle.size"), ";\n    left: ").concat(dt3("toggleswitch.gap"), ";\n    margin-top: calc(-1 * calc(").concat(dt3("toggleswitch.handle.size"), " / 2));\n    border-radius: ").concat(dt3("toggleswitch.handle.border.radius"), ";\n    transition: background ").concat(dt3("toggleswitch.transition.duration"), ", left ").concat(dt3("toggleswitch.slide.duration"), ";\n}\n\n.p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-slider {\n    background: ").concat(dt3("toggleswitch.checked.background"), ";\n    border-color: ").concat(dt3("toggleswitch.checked.border.color"), ";\n}\n\n.p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-slider:before {\n    background: ").concat(dt3("toggleswitch.handle.checked.background"), ";\n    left: calc(").concat(dt3("toggleswitch.width"), " - calc(").concat(dt3("toggleswitch.handle.size"), " + ").concat(dt3("toggleswitch.gap"), "));\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-slider {\n    background: ").concat(dt3("toggleswitch.hover.background"), ";\n    border-color: ").concat(dt3("toggleswitch.hover.border.color"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-slider:before {\n    background: ").concat(dt3("toggleswitch.handle.hover.background"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-slider {\n    background: ").concat(dt3("toggleswitch.checked.hover.background"), ";\n    border-color: ").concat(dt3("toggleswitch.checked.hover.border.color"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-slider:before {\n    background: ").concat(dt3("toggleswitch.handle.checked.hover.background"), ";\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:focus-visible) .p-toggleswitch-slider {\n    box-shadow: ").concat(dt3("toggleswitch.focus.ring.shadow"), ";\n    outline: ").concat(dt3("toggleswitch.focus.ring.width"), " ").concat(dt3("toggleswitch.focus.ring.style"), " ").concat(dt3("toggleswitch.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("toggleswitch.focus.ring.offset"), ";\n}\n\n.p-toggleswitch.p-invalid > .p-toggleswitch-slider {\n    border-color: ").concat(dt3("toggleswitch.invalid.border.color"), ";\n}\n\n.p-toggleswitch.p-disabled {\n    opacity: 1;\n}\n\n.p-toggleswitch.p-disabled .p-toggleswitch-slider {\n    background: ").concat(dt3("toggleswitch.disabled.background"), ";\n}\n\n.p-toggleswitch.p-disabled .p-toggleswitch-slider:before {\n    background: ").concat(dt3("toggleswitch.handle.disabled.background"), ";\n}\n");
};
var inlineStyles$6 = {
  root: {
    position: "relative"
  }
};
var classes$i = {
  root: function root11(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-toggleswitch p-component", {
      "p-toggleswitch-checked": instance.checked,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid
    }];
  },
  input: "p-toggleswitch-input",
  slider: "p-toggleswitch-slider"
};
var ToggleSwitchStyle = BaseStyle.extend({
  name: "toggleswitch",
  theme: theme$h,
  classes: classes$i,
  inlineStyles: inlineStyles$6
});
var script$1$j = {
  name: "BaseToggleSwitch",
  "extends": script$1a,
  props: {
    modelValue: {
      type: null,
      "default": false
    },
    trueValue: {
      type: null,
      "default": true
    },
    falseValue: {
      type: null,
      "default": false
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: ToggleSwitchStyle,
  provide: function provide19() {
    return {
      $pcToggleSwitch: this,
      $parentInstance: this
    };
  }
};
var script$L = {
  name: "ToggleSwitch",
  "extends": script$1$j,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur"],
  methods: {
    getPTOptions: function getPTOptions4(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          checked: this.checked,
          disabled: this.disabled
        }
      });
    },
    onChange: function onChange(event2) {
      if (!this.disabled && !this.readonly) {
        var newValue = this.checked ? this.falseValue : this.trueValue;
        this.$emit("update:modelValue", newValue);
        this.$emit("change", event2);
      }
    },
    onFocus: function onFocus3(event2) {
      this.$emit("focus", event2);
    },
    onBlur: function onBlur3(event2) {
      this.$emit("blur", event2);
    }
  },
  computed: {
    checked: function checked() {
      return this.modelValue === this.trueValue;
    }
  }
};
var _hoisted_1$P = ["data-p-checked", "data-p-disabled"];
var _hoisted_2$F = ["id", "checked", "tabindex", "disabled", "readonly", "aria-checked", "aria-labelledby", "aria-label", "aria-invalid"];
function render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    style: _ctx.sx("root")
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.checked,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("input", mergeProps({
    id: _ctx.inputId,
    type: "checkbox",
    role: "switch",
    "class": [_ctx.cx("input"), _ctx.inputClass],
    style: _ctx.inputStyle,
    checked: $options.checked,
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    "aria-checked": $options.checked,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("input")), null, 16, _hoisted_2$F), createBaseVNode("span", mergeProps({
    "class": _ctx.cx("slider")
  }, $options.getPTOptions("slider")), null, 16)], 16, _hoisted_1$P);
}
script$L.render = render$K;
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "CustomSettingValue",
  props: {
    renderFunction: { type: Function }
  },
  setup(__props) {
    const props = __props;
    const container = ref(null);
    function renderContent() {
      if (container.value) {
        container.value.innerHTML = "";
        const element = props.renderFunction();
        container.value.appendChild(element);
      }
    }
    onMounted(renderContent);
    watch(() => props.renderFunction, renderContent);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container
      }, null, 512);
    };
  }
});
var theme$g = function theme19(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-slider {\n    position: relative;\n    background: ".concat(dt3("slider.track.background"), ";\n    border-radius: ").concat(dt3("slider.border.radius"), ";\n}\n\n.p-slider-handle {\n    cursor: grab;\n    touch-action: none;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: ").concat(dt3("slider.handle.height"), ";\n    width: ").concat(dt3("slider.handle.width"), ";\n    background: ").concat(dt3("slider.handle.background"), ";\n    border-radius: ").concat(dt3("slider.handle.border.radius"), ";\n    transition: background ").concat(dt3("slider.transition.duration"), ", color ").concat(dt3("slider.transition.duration"), ", border-color ").concat(dt3("slider.transition.duration"), ", box-shadow ").concat(dt3("slider.transition.duration"), ", outline-color ").concat(dt3("slider.transition.duration"), ';\n    outline-color: transparent;\n}\n\n.p-slider-handle::before {\n    content: "";\n    width: ').concat(dt3("slider.handle.content.width"), ";\n    height: ").concat(dt3("slider.handle.content.height"), ";\n    display: block;\n    background: ").concat(dt3("slider.handle.content.background"), ";\n    border-radius: ").concat(dt3("slider.handle.content.border.radius"), ";\n    box-shadow: ").concat(dt3("slider.handle.content.shadow"), ";\n    transition: background ").concat(dt3("slider.transition.duration"), ";\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover {\n    background: ").concat(dt3("slider.handle.hover.background"), ";\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover::before {\n    background: ").concat(dt3("slider.handle.content.hover.background"), ";\n}\n\n.p-slider-handle:focus-visible {\n    border-color: ").concat(dt3("slider.handle.focus.border.color"), ";\n    box-shadow: ").concat(dt3("slider.handle.focus.ring.shadow"), ";\n    outline: ").concat(dt3("slider.handle.focus.ring.width"), " ").concat(dt3("slider.handle.focus.ring.style"), " ").concat(dt3("slider.handle.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("slider.handle.focus.ring.offset"), ";\n}\n\n.p-slider-range {\n    display: block;\n    background: ").concat(dt3("slider.range.background"), ";\n    border-radius: ").concat(dt3("slider.border.radius"), ";\n}\n\n.p-slider.p-slider-horizontal {\n    height: ").concat(dt3("slider.track.size"), ";\n}\n\n.p-slider-horizontal .p-slider-range {\n    top: 0;\n    left: 0;\n    height: 100%;\n}\n\n.p-slider-horizontal .p-slider-handle {\n    top: 50%;\n    margin-top: calc(-1 * calc(").concat(dt3("slider.handle.height"), " / 2));\n    margin-left: calc(-1 * calc(").concat(dt3("slider.handle.width"), " / 2));\n}\n\n.p-slider-vertical {\n    min-height: 100px;\n    width: ").concat(dt3("slider.track.size"), ";\n}\n\n.p-slider-vertical .p-slider-handle {\n    left: 50%;\n    margin-left: calc(-1 * calc(").concat(dt3("slider.handle.width"), " / 2));\n    margin-bottom: calc(-1 * calc(").concat(dt3("slider.handle.height"), " / 2));\n}\n\n.p-slider-vertical .p-slider-range {\n    bottom: 0;\n    left: 0;\n    width: 100%;\n}\n");
};
var inlineStyles$5 = {
  handle: {
    position: "absolute"
  },
  range: {
    position: "absolute"
  }
};
var classes$h = {
  root: function root12(_ref2) {
    var props = _ref2.props;
    return ["p-slider p-component", {
      "p-disabled": props.disabled,
      "p-slider-horizontal": props.orientation === "horizontal",
      "p-slider-vertical": props.orientation === "vertical"
    }];
  },
  range: "p-slider-range",
  handle: "p-slider-handle"
};
var SliderStyle = BaseStyle.extend({
  name: "slider",
  theme: theme$g,
  classes: classes$h,
  inlineStyles: inlineStyles$5
});
var script$1$i = {
  name: "BaseSlider",
  "extends": script$1a,
  props: {
    modelValue: [Number, Array],
    min: {
      type: Number,
      "default": 0
    },
    max: {
      type: Number,
      "default": 100
    },
    orientation: {
      type: String,
      "default": "horizontal"
    },
    step: {
      type: Number,
      "default": null
    },
    range: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: SliderStyle,
  provide: function provide20() {
    return {
      $pcSlider: this,
      $parentInstance: this
    };
  }
};
function _toConsumableArray$a(r) {
  return _arrayWithoutHoles$a(r) || _iterableToArray$a(r) || _unsupportedIterableToArray$c(r) || _nonIterableSpread$a();
}
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$c(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$c(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$c(r, a) : void 0;
  }
}
function _iterableToArray$a(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$a(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$c(r);
}
function _arrayLikeToArray$c(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$K = {
  name: "Slider",
  "extends": script$1$i,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "slideend"],
  dragging: false,
  handleIndex: null,
  initX: null,
  initY: null,
  barWidth: null,
  barHeight: null,
  dragListener: null,
  dragEndListener: null,
  beforeUnmount: function beforeUnmount3() {
    this.unbindDragListeners();
  },
  methods: {
    updateDomData: function updateDomData() {
      var rect = this.$el.getBoundingClientRect();
      this.initX = rect.left + getWindowScrollLeft();
      this.initY = rect.top + getWindowScrollTop();
      this.barWidth = this.$el.offsetWidth;
      this.barHeight = this.$el.offsetHeight;
    },
    setValue: function setValue(event2) {
      var handleValue;
      var pageX = event2.touches ? event2.touches[0].pageX : event2.pageX;
      var pageY = event2.touches ? event2.touches[0].pageY : event2.pageY;
      if (this.orientation === "horizontal") handleValue = (pageX - this.initX) * 100 / this.barWidth;
      else handleValue = (this.initY + this.barHeight - pageY) * 100 / this.barHeight;
      var newValue = (this.max - this.min) * (handleValue / 100) + this.min;
      if (this.step) {
        var oldValue = this.range ? this.value[this.handleIndex] : this.value;
        var diff = newValue - oldValue;
        if (diff < 0) newValue = oldValue + Math.ceil(newValue / this.step - oldValue / this.step) * this.step;
        else if (diff > 0) newValue = oldValue + Math.floor(newValue / this.step - oldValue / this.step) * this.step;
      } else {
        newValue = Math.floor(newValue);
      }
      this.updateModel(event2, newValue);
    },
    updateModel: function updateModel4(event2, value3) {
      var newValue = parseFloat(value3.toFixed(10));
      var modelValue3;
      if (this.range) {
        modelValue3 = this.value ? _toConsumableArray$a(this.value) : [];
        if (this.handleIndex == 0) {
          if (newValue < this.min) newValue = this.min;
          else if (newValue >= this.max) newValue = this.max;
          modelValue3[0] = newValue;
        } else {
          if (newValue > this.max) newValue = this.max;
          else if (newValue <= this.min) newValue = this.min;
          modelValue3[1] = newValue;
        }
      } else {
        if (newValue < this.min) newValue = this.min;
        else if (newValue > this.max) newValue = this.max;
        modelValue3 = newValue;
      }
      this.$emit("update:modelValue", modelValue3);
      this.$emit("change", modelValue3);
    },
    onDragStart: function onDragStart(event2, index2) {
      if (this.disabled) {
        return;
      }
      this.$el.setAttribute("data-p-sliding", true);
      this.dragging = true;
      this.updateDomData();
      if (this.range && this.value[0] === this.max) {
        this.handleIndex = 0;
      } else {
        this.handleIndex = index2;
      }
      event2.currentTarget.focus();
      event2.preventDefault();
    },
    onDrag: function onDrag(event2) {
      if (this.dragging) {
        this.setValue(event2);
        event2.preventDefault();
      }
    },
    onDragEnd: function onDragEnd(event2) {
      if (this.dragging) {
        this.dragging = false;
        this.$el.setAttribute("data-p-sliding", false);
        this.$emit("slideend", {
          originalEvent: event2,
          value: this.value
        });
      }
    },
    onBarClick: function onBarClick(event2) {
      if (this.disabled) {
        return;
      }
      if (getAttribute(event2.target, "data-pc-section") !== "handle") {
        this.updateDomData();
        this.setValue(event2);
      }
    },
    onMouseDown: function onMouseDown2(event2, index2) {
      this.bindDragListeners();
      this.onDragStart(event2, index2);
    },
    onKeyDown: function onKeyDown2(event2, index2) {
      this.handleIndex = index2;
      switch (event2.code) {
        case "ArrowDown":
        case "ArrowLeft":
          this.decrementValue(event2, index2);
          event2.preventDefault();
          break;
        case "ArrowUp":
        case "ArrowRight":
          this.incrementValue(event2, index2);
          event2.preventDefault();
          break;
        case "PageDown":
          this.decrementValue(event2, index2, true);
          event2.preventDefault();
          break;
        case "PageUp":
          this.incrementValue(event2, index2, true);
          event2.preventDefault();
          break;
        case "Home":
          this.updateModel(event2, this.min);
          event2.preventDefault();
          break;
        case "End":
          this.updateModel(event2, this.max);
          event2.preventDefault();
          break;
      }
    },
    decrementValue: function decrementValue(event2, index2) {
      var pageKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var newValue;
      if (this.range) {
        if (this.step) newValue = this.value[index2] - this.step;
        else newValue = this.value[index2] - 1;
      } else {
        if (this.step) newValue = this.value - this.step;
        else if (!this.step && pageKey) newValue = this.value - 10;
        else newValue = this.value - 1;
      }
      this.updateModel(event2, newValue);
      event2.preventDefault();
    },
    incrementValue: function incrementValue(event2, index2) {
      var pageKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var newValue;
      if (this.range) {
        if (this.step) newValue = this.value[index2] + this.step;
        else newValue = this.value[index2] + 1;
      } else {
        if (this.step) newValue = this.value + this.step;
        else if (!this.step && pageKey) newValue = this.value + 10;
        else newValue = this.value + 1;
      }
      this.updateModel(event2, newValue);
      event2.preventDefault();
    },
    bindDragListeners: function bindDragListeners() {
      if (!this.dragListener) {
        this.dragListener = this.onDrag.bind(this);
        document.addEventListener("mousemove", this.dragListener);
      }
      if (!this.dragEndListener) {
        this.dragEndListener = this.onDragEnd.bind(this);
        document.addEventListener("mouseup", this.dragEndListener);
      }
    },
    unbindDragListeners: function unbindDragListeners() {
      if (this.dragListener) {
        document.removeEventListener("mousemove", this.dragListener);
        this.dragListener = null;
      }
      if (this.dragEndListener) {
        document.removeEventListener("mouseup", this.dragEndListener);
        this.dragEndListener = null;
      }
    }
  },
  computed: {
    value: function value2() {
      var _this$modelValue3;
      if (this.range) {
        var _this$modelValue$, _this$modelValue, _this$modelValue$2, _this$modelValue2;
        return [(_this$modelValue$ = (_this$modelValue = this.modelValue) === null || _this$modelValue === void 0 ? void 0 : _this$modelValue[0]) !== null && _this$modelValue$ !== void 0 ? _this$modelValue$ : this.min, (_this$modelValue$2 = (_this$modelValue2 = this.modelValue) === null || _this$modelValue2 === void 0 ? void 0 : _this$modelValue2[1]) !== null && _this$modelValue$2 !== void 0 ? _this$modelValue$2 : this.max];
      }
      return (_this$modelValue3 = this.modelValue) !== null && _this$modelValue3 !== void 0 ? _this$modelValue3 : this.min;
    },
    horizontal: function horizontal() {
      return this.orientation === "horizontal";
    },
    vertical: function vertical() {
      return this.orientation === "vertical";
    },
    rangeStyle: function rangeStyle() {
      if (this.range) {
        var rangeSliderWidth = this.rangeEndPosition > this.rangeStartPosition ? this.rangeEndPosition - this.rangeStartPosition : this.rangeStartPosition - this.rangeEndPosition;
        var rangeSliderPosition = this.rangeEndPosition > this.rangeStartPosition ? this.rangeStartPosition : this.rangeEndPosition;
        if (this.horizontal) return {
          left: rangeSliderPosition + "%",
          width: rangeSliderWidth + "%"
        };
        else return {
          bottom: rangeSliderPosition + "%",
          height: rangeSliderWidth + "%"
        };
      } else {
        if (this.horizontal) return {
          width: this.handlePosition + "%"
        };
        else return {
          height: this.handlePosition + "%"
        };
      }
    },
    handleStyle: function handleStyle() {
      if (this.horizontal) return {
        left: this.handlePosition + "%"
      };
      else return {
        bottom: this.handlePosition + "%"
      };
    },
    handlePosition: function handlePosition() {
      if (this.value < this.min) return 0;
      else if (this.value > this.max) return 100;
      else return (this.value - this.min) * 100 / (this.max - this.min);
    },
    rangeStartPosition: function rangeStartPosition() {
      if (this.value && this.value[0]) return (this.value[0] < this.min ? 0 : this.value[0] - this.min) * 100 / (this.max - this.min);
      else return 0;
    },
    rangeEndPosition: function rangeEndPosition() {
      if (this.value && this.value.length === 2) return (this.value[1] > this.max ? 100 : this.value[1] - this.min) * 100 / (this.max - this.min);
      else return 100;
    },
    rangeStartHandleStyle: function rangeStartHandleStyle() {
      if (this.horizontal) return {
        left: this.rangeStartPosition + "%"
      };
      else return {
        bottom: this.rangeStartPosition + "%"
      };
    },
    rangeEndHandleStyle: function rangeEndHandleStyle() {
      if (this.horizontal) return {
        left: this.rangeEndPosition + "%"
      };
      else return {
        bottom: this.rangeEndPosition + "%"
      };
    }
  }
};
var _hoisted_1$O = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
var _hoisted_2$E = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
var _hoisted_3$a = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation"];
function render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    onClick: _cache[15] || (_cache[15] = function() {
      return $options.onBarClick && $options.onBarClick.apply($options, arguments);
    })
  }, _ctx.ptmi("root"), {
    "data-p-sliding": false
  }), [createBaseVNode("span", mergeProps({
    "class": _ctx.cx("range"),
    style: [_ctx.sx("range"), $options.rangeStyle]
  }, _ctx.ptm("range")), null, 16), !_ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 0,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.handleStyle],
    onTouchstartPassive: _cache[0] || (_cache[0] = function($event) {
      return $options.onDragStart($event);
    }),
    onTouchmovePassive: _cache[1] || (_cache[1] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[2] || (_cache[2] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[3] || (_cache[3] = function($event) {
      return $options.onMouseDown($event);
    }),
    onKeydown: _cache[4] || (_cache[4] = function($event) {
      return $options.onKeyDown($event);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("handle")), null, 16, _hoisted_1$O)) : createCommentVNode("", true), _ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.rangeStartHandleStyle],
    onTouchstartPassive: _cache[5] || (_cache[5] = function($event) {
      return $options.onDragStart($event, 0);
    }),
    onTouchmovePassive: _cache[6] || (_cache[6] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[7] || (_cache[7] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[8] || (_cache[8] = function($event) {
      return $options.onMouseDown($event, 0);
    }),
    onKeydown: _cache[9] || (_cache[9] = function($event) {
      return $options.onKeyDown($event, 0);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue ? _ctx.modelValue[0] : null,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("startHandler")), null, 16, _hoisted_2$E)) : createCommentVNode("", true), _ctx.range ? (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    "class": _ctx.cx("handle"),
    style: [_ctx.sx("handle"), $options.rangeEndHandleStyle],
    onTouchstartPassive: _cache[10] || (_cache[10] = function($event) {
      return $options.onDragStart($event, 1);
    }),
    onTouchmovePassive: _cache[11] || (_cache[11] = function($event) {
      return $options.onDrag($event);
    }),
    onTouchend: _cache[12] || (_cache[12] = function($event) {
      return $options.onDragEnd($event);
    }),
    onMousedown: _cache[13] || (_cache[13] = function($event) {
      return $options.onMouseDown($event, 1);
    }),
    onKeydown: _cache[14] || (_cache[14] = function($event) {
      return $options.onKeyDown($event, 1);
    }),
    tabindex: _ctx.tabindex,
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuenow": _ctx.modelValue ? _ctx.modelValue[1] : null,
    "aria-valuemax": _ctx.max,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-orientation": _ctx.orientation
  }, _ctx.ptm("endHandler")), null, 16, _hoisted_3$a)) : createCommentVNode("", true)], 16);
}
script$K.render = render$J;
const _withScopeId$b = (n) => (pushScopeId("data-v-fbaf7a8c"), n = n(), popScopeId(), n);
const _hoisted_1$N = { class: "input-slider" };
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "InputSlider",
  props: {
    modelValue: {},
    inputClass: {},
    sliderClass: {},
    min: {},
    max: {},
    step: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const localValue = ref(props.modelValue);
    watch(
      () => props.modelValue,
      (newValue) => {
        localValue.value = newValue;
      }
    );
    const updateValue3 = (newValue) => {
      if (newValue === null) {
        newValue = Number(props.min) || 0;
      }
      const min = Number(props.min) || Number.NEGATIVE_INFINITY;
      const max = Number(props.max) || Number.POSITIVE_INFINITY;
      const step = Number(props.step) || 1;
      newValue = Math.max(min, Math.min(max, newValue));
      newValue = Math.round(newValue / step) * step;
      localValue.value = newValue;
      emit2("update:modelValue", newValue);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$N, [
        createVNode(unref(script$K), {
          modelValue: _ctx.modelValue,
          "onUpdate:modelValue": updateValue3,
          class: normalizeClass(["slider-part", _ctx.sliderClass]),
          min: _ctx.min,
          max: _ctx.max,
          step: _ctx.step
        }, null, 8, ["modelValue", "class", "min", "max", "step"]),
        createVNode(unref(script$Q), {
          modelValue: _ctx.modelValue,
          "onUpdate:modelValue": updateValue3,
          class: normalizeClass(["input-part", _ctx.inputClass]),
          min: _ctx.min,
          max: _ctx.max,
          step: _ctx.step
        }, null, 8, ["modelValue", "class", "min", "max", "step"])
      ]);
    };
  }
});
const InputSlider = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-fbaf7a8c"]]);
function formatCamelCase(str) {
  const isCamelCase = /^([A-Z][a-z]*)+$/.test(str);
  if (!isCamelCase) {
    return str;
  }
  const words = str.split(/(?=[A-Z][a-z])|\d+/);
  const processedWords = words.map((word) => {
    if (word.length > 1 && word === word.toUpperCase()) {
      return word;
    }
    return word.charAt(0).toUpperCase() + word.slice(1);
  });
  return processedWords.join(" ");
}
const _withScopeId$a = (n) => (pushScopeId("data-v-4feeb3d2"), n = n(), popScopeId(), n);
const _hoisted_1$M = { class: "setting-group" };
const _hoisted_2$D = { class: "setting-label" };
const _hoisted_3$9 = {
  key: 0,
  class: "pi pi-info-circle info-chip"
};
const _hoisted_4$8 = { class: "setting-input" };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "SettingGroup",
  props: {
    group: {},
    divider: { type: Boolean }
  },
  setup(__props) {
    const settingStore = useSettingStore();
    function getSettingAttrs(setting) {
      const attrs3 = __spreadValues2({}, setting.attrs || {});
      const settingType = setting.type;
      if (typeof settingType === "function") {
        attrs3["renderFunction"] = () => settingType(
          setting.name,
          (v2) => updateSetting(setting, v2),
          settingStore.get(setting.id),
          setting.attrs
        );
      }
      switch (setting.type) {
        case "combo":
          attrs3["options"] = setting.options;
          if (typeof setting.options[0] !== "string") {
            attrs3["optionLabel"] = "text";
            attrs3["optionValue"] = "value";
          }
          break;
      }
      return attrs3;
    }
    const updateSetting = (setting, value3) => {
      if (setting.onChange) setting.onChange(value3, settingStore.get(setting.id));
      settingStore.set(setting.id, value3);
    };
    function getSettingComponent(setting) {
      if (typeof setting.type === "function") {
        return _sfc_main$n;
      }
      switch (setting.type) {
        case "boolean":
          return script$L;
        case "number":
          return script$Q;
        case "slider":
          return InputSlider;
        case "combo":
          return script$M;
        default:
          return script$Z;
      }
    }
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$M, [
        _ctx.divider ? (openBlock(), createBlock(unref(script$T), { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("h3", null, toDisplayString$1(unref(formatCamelCase)(_ctx.group.label)), 1),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.group.settings, (setting) => {
          return openBlock(), createElementBlock("div", {
            key: setting.id,
            class: "setting-item"
          }, [
            createBaseVNode("div", _hoisted_2$D, [
              createBaseVNode("span", null, [
                createTextVNode(toDisplayString$1(setting.name) + " ", 1),
                setting.tooltip ? withDirectives((openBlock(), createElementBlock("i", _hoisted_3$9, null, 512)), [
                  [_directive_tooltip, setting.tooltip]
                ]) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_4$8, [
              (openBlock(), createBlock(resolveDynamicComponent(markRaw(getSettingComponent(setting))), mergeProps({
                id: setting.id,
                modelValue: unref(settingStore).get(setting.id),
                "onUpdate:modelValue": ($event) => updateSetting(setting, $event),
                ref_for: true
              }, getSettingAttrs(setting)), null, 16, ["id", "modelValue", "onUpdate:modelValue"]))
            ])
          ]);
        }), 128))
      ]);
    };
  }
});
const SettingGroup = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-4feeb3d2"]]);
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "SettingSearchBox",
  props: {
    class: {},
    modelValue: {}
  },
  emits: ["update:modelValue", "search"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const emitSearch = lodashExports.debounce((event2) => {
      const target = event2.target;
      emit2("search", target.value);
    }, 300);
    const handleInput = (event2) => {
      const target = event2.target;
      emit2("update:modelValue", target.value);
      emitSearch(event2);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$$), {
        class: normalizeClass(props.class)
      }, {
        default: withCtx(() => [
          createVNode(unref(script$_), { class: "pi pi-search" }),
          createVNode(unref(script$Z), {
            class: "search-box-input",
            onInput: handleInput,
            modelValue: props.modelValue,
            placeholder: _ctx.$t("searchSettings") + "..."
          }, null, 8, ["modelValue", "placeholder"])
        ]),
        _: 1
      }, 8, ["class"]);
    };
  }
});
const SettingSearchBox = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__scopeId", "data-v-3bbe5335"]]);
var theme$f = function theme20(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-card {\n    background: ".concat(dt3("card.background"), ";\n    color: ").concat(dt3("card.color"), ";\n    box-shadow: ").concat(dt3("card.shadow"), ";\n    border-radius: ").concat(dt3("card.border.radius"), ";\n    display: flex;\n    flex-direction: column;\n}\n\n.p-card-caption {\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("card.caption.gap"), ";\n}\n\n.p-card-body {\n    padding: ").concat(dt3("card.body.padding"), ";\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("card.body.gap"), ";\n}\n\n.p-card-title {\n    font-size: ").concat(dt3("card.title.font.size"), ";\n    font-weight: ").concat(dt3("card.title.font.weight"), ";\n}\n\n.p-card-subtitle {\n    color: ").concat(dt3("card.subtitle.color"), ";\n}\n");
};
var classes$g = {
  root: "p-card p-component",
  header: "p-card-header",
  body: "p-card-body",
  caption: "p-card-caption",
  title: "p-card-title",
  subtitle: "p-card-subtitle",
  content: "p-card-content",
  footer: "p-card-footer"
};
var CardStyle = BaseStyle.extend({
  name: "card",
  theme: theme$f,
  classes: classes$g
});
var script$1$h = {
  name: "BaseCard",
  "extends": script$1a,
  style: CardStyle,
  provide: function provide21() {
    return {
      $pcCard: this,
      $parentInstance: this
    };
  }
};
var script$J = {
  name: "Card",
  "extends": script$1$h,
  inheritAttrs: false
};
function render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.$slots.header ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("header")
  }, _ctx.ptm("header")), [renderSlot(_ctx.$slots, "header")], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("body")
  }, _ctx.ptm("body")), [_ctx.$slots.title || _ctx.$slots.subtitle ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("caption")
  }, _ctx.ptm("caption")), [_ctx.$slots.title ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("title")
  }, _ctx.ptm("title")), [renderSlot(_ctx.$slots, "title")], 16)) : createCommentVNode("", true), _ctx.$slots.subtitle ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("subtitle")
  }, _ctx.ptm("subtitle")), [renderSlot(_ctx.$slots, "subtitle")], 16)) : createCommentVNode("", true)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("content")
  }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "content")], 16), _ctx.$slots.footer ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("footer")
  }, _ctx.ptm("footer")), [renderSlot(_ctx.$slots, "footer")], 16)) : createCommentVNode("", true)], 16)], 16);
}
script$J.render = render$I;
const _withScopeId$9 = (n) => (pushScopeId("data-v-5a7d148a"), n = n(), popScopeId(), n);
const _hoisted_1$L = { class: "no-results-placeholder" };
const _hoisted_2$C = { class: "flex flex-column align-items-center" };
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "NoResultsPlaceholder",
  props: {
    icon: {},
    title: {},
    message: {},
    buttonLabel: {}
  },
  emits: ["action"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$L, [
        createVNode(unref(script$J), null, {
          content: withCtx(() => [
            createBaseVNode("div", _hoisted_2$C, [
              createBaseVNode("i", {
                class: normalizeClass(_ctx.icon),
                style: { "font-size": "3rem", "margin-bottom": "1rem" }
              }, null, 2),
              createBaseVNode("h3", null, toDisplayString$1(_ctx.title), 1),
              createBaseVNode("p", null, toDisplayString$1(_ctx.message), 1),
              _ctx.buttonLabel ? (openBlock(), createBlock(unref(script$13), {
                key: 0,
                label: _ctx.buttonLabel,
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("action")),
                class: "p-button-text"
              }, null, 8, ["label"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        })
      ]);
    };
  }
});
const NoResultsPlaceholder = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-5a7d148a"]]);
const _withScopeId$8 = (n) => (pushScopeId("data-v-833dbfbb"), n = n(), popScopeId(), n);
const _hoisted_1$K = { class: "settings-container" };
const _hoisted_2$B = { class: "settings-sidebar" };
const _hoisted_3$8 = { class: "settings-content" };
const _hoisted_4$7 = { key: 0 };
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "SettingDialogContent",
  setup(__props) {
    const settingStore = useSettingStore();
    const settingRoot = computed(() => settingStore.settingTree);
    const categories = computed(
      () => settingRoot.value.children || []
    );
    const activeCategory = ref(null);
    const searchResults = ref([]);
    watch(activeCategory, (newCategory, oldCategory) => {
      if (newCategory === null) {
        activeCategory.value = oldCategory;
      }
    });
    onMounted(() => {
      activeCategory.value = categories.value[0];
    });
    const sortedGroups = (category) => {
      return [...category.children || []].sort(
        (a, b) => a.label.localeCompare(b.label)
      );
    };
    const searchQuery = ref("");
    const searchInProgress = ref(false);
    watch(searchQuery, () => searchInProgress.value = true);
    const handleSearch = (query) => {
      if (!query) {
        searchResults.value = [];
        return;
      }
      const allSettings = flattenTree(settingRoot.value);
      const filteredSettings = allSettings.filter(
        (setting) => setting.id.toLowerCase().includes(query.toLowerCase()) || setting.name.toLowerCase().includes(query.toLowerCase())
      );
      const groupedSettings = {};
      filteredSettings.forEach((setting) => {
        const groupLabel = setting.id.split(".")[1];
        if (!groupedSettings[groupLabel]) {
          groupedSettings[groupLabel] = [];
        }
        groupedSettings[groupLabel].push(setting);
      });
      searchResults.value = Object.entries(groupedSettings).map(
        ([label5, settings]) => ({
          label: label5,
          settings
        })
      );
      searchInProgress.value = false;
    };
    const inSearch = computed(
      () => searchQuery.value.length > 0 && !searchInProgress.value
    );
    const tabValue = computed(
      () => {
        var _a2;
        return inSearch.value ? "Search Results" : (_a2 = activeCategory.value) == null ? void 0 : _a2.label;
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$K, [
        createBaseVNode("div", _hoisted_2$B, [
          createVNode(SettingSearchBox, {
            class: "settings-search-box",
            modelValue: searchQuery.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
            onSearch: handleSearch
          }, null, 8, ["modelValue"]),
          createVNode(unref(script$X), {
            modelValue: activeCategory.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => activeCategory.value = $event),
            options: categories.value,
            optionLabel: "label",
            scrollHeight: "100%",
            disabled: inSearch.value,
            pt: { root: { class: "border-none" } }
          }, null, 8, ["modelValue", "options", "disabled"])
        ]),
        createVNode(unref(script$T), { layout: "vertical" }),
        createBaseVNode("div", _hoisted_3$8, [
          createVNode(unref(script$W), { value: tabValue.value }, {
            default: withCtx(() => [
              createVNode(unref(script$V), { class: "settings-tab-panels" }, {
                default: withCtx(() => [
                  createVNode(unref(script$U), {
                    key: "search-results",
                    value: "Search Results"
                  }, {
                    default: withCtx(() => [
                      searchResults.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_4$7, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(searchResults.value, (group, i2) => {
                          return openBlock(), createBlock(SettingGroup, {
                            key: group.label,
                            divider: i2 !== 0,
                            group
                          }, null, 8, ["divider", "group"]);
                        }), 128))
                      ])) : (openBlock(), createBlock(NoResultsPlaceholder, {
                        key: 1,
                        icon: "pi pi-search",
                        title: _ctx.$t("noResultsFound"),
                        message: _ctx.$t("searchFailedMessage")
                      }, null, 8, ["title", "message"]))
                    ]),
                    _: 1
                  }),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(categories.value, (category) => {
                    return openBlock(), createBlock(unref(script$U), {
                      key: category.key,
                      value: category.label
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(sortedGroups(category), (group, i2) => {
                          return openBlock(), createBlock(SettingGroup, {
                            key: group.label,
                            divider: i2 !== 0,
                            group: {
                              label: group.label,
                              settings: unref(flattenTree)(group)
                            }
                          }, null, 8, ["divider", "group"]);
                        }), 128))
                      ]),
                      _: 2
                    }, 1032, ["value"]);
                  }), 128))
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["value"])
        ])
      ]);
    };
  }
});
const SettingDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-833dbfbb"]]);
var theme$e = function theme21(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-tag {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    background: ".concat(dt3("tag.primary.background"), ";\n    color: ").concat(dt3("tag.primary.color"), ";\n    font-size: ").concat(dt3("tag.font.size"), ";\n    font-weight: ").concat(dt3("tag.font.weight"), ";\n    padding: ").concat(dt3("tag.padding"), ";\n    border-radius: ").concat(dt3("tag.border.radius"), ";\n    gap: ").concat(dt3("tag.gap"), ";\n}\n\n.p-tag-icon {\n    font-size: ").concat(dt3("tag.icon.size"), ";\n    width: ").concat(dt3("tag.icon.size"), ";\n    height:").concat(dt3("tag.icon.size"), ";\n}\n\n.p-tag-rounded {\n    border-radius: ").concat(dt3("tag.rounded.border.radius"), ";\n}\n\n.p-tag-success {\n    background: ").concat(dt3("tag.success.background"), ";\n    color: ").concat(dt3("tag.success.color"), ";\n}\n\n.p-tag-info {\n    background: ").concat(dt3("tag.info.background"), ";\n    color: ").concat(dt3("tag.info.color"), ";\n}\n\n.p-tag-warn {\n    background: ").concat(dt3("tag.warn.background"), ";\n    color: ").concat(dt3("tag.warn.color"), ";\n}\n\n.p-tag-danger {\n    background: ").concat(dt3("tag.danger.background"), ";\n    color: ").concat(dt3("tag.danger.color"), ";\n}\n\n.p-tag-secondary {\n    background: ").concat(dt3("tag.secondary.background"), ";\n    color: ").concat(dt3("tag.secondary.color"), ";\n}\n\n.p-tag-contrast {\n    background: ").concat(dt3("tag.contrast.background"), ";\n    color: ").concat(dt3("tag.contrast.color"), ";\n}\n");
};
var classes$f = {
  root: function root13(_ref2) {
    var props = _ref2.props;
    return ["p-tag p-component", {
      "p-tag-info": props.severity === "info",
      "p-tag-success": props.severity === "success",
      "p-tag-warn": props.severity === "warn",
      "p-tag-danger": props.severity === "danger",
      "p-tag-secondary": props.severity === "secondary",
      "p-tag-contrast": props.severity === "contrast",
      "p-tag-rounded": props.rounded
    }];
  },
  icon: "p-tag-icon",
  label: "p-tag-label"
};
var TagStyle = BaseStyle.extend({
  name: "tag",
  theme: theme$e,
  classes: classes$f
});
var script$1$g = {
  name: "BaseTag",
  "extends": script$1a,
  props: {
    value: null,
    severity: null,
    rounded: Boolean,
    icon: String
  },
  style: TagStyle,
  provide: function provide22() {
    return {
      $pcTag: this,
      $parentInstance: this
    };
  }
};
var script$I = {
  name: "Tag",
  "extends": script$1$g,
  inheritAttrs: false
};
function render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), mergeProps({
    key: 0,
    "class": _ctx.cx("icon")
  }, _ctx.ptm("icon")), null, 16, ["class"])) : _ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    "class": [_ctx.cx("icon"), _ctx.icon]
  }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true), _ctx.value != null || _ctx.$slots["default"] ? renderSlot(_ctx.$slots, "default", {
    key: 2
  }, function() {
    return [createBaseVNode("span", mergeProps({
      "class": _ctx.cx("label")
    }, _ctx.ptm("label")), toDisplayString$1(_ctx.value), 17)];
  }) : createCommentVNode("", true)], 16);
}
script$I.render = render$H;
const _withScopeId$7 = (n) => (pushScopeId("data-v-969a1066"), n = n(), popScopeId(), n);
const _hoisted_1$J = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-cog" }, null, -1));
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "SettingDialogHeader",
  setup(__props) {
    const frontendVersion = "v" + window["__COMFYUI_FRONTEND_VERSION__"];
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("h2", null, [
          _hoisted_1$J,
          createBaseVNode("span", null, toDisplayString$1(_ctx.$t("settings")), 1),
          createVNode(unref(script$I), {
            value: frontendVersion,
            severity: "secondary",
            class: "version-tag"
          })
        ])
      ]);
    };
  }
});
const SettingDialogHeader = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-969a1066"]]);
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "SidebarSettingsToggleIcon",
  setup(__props) {
    const dialogStore = useDialogStore();
    const showSetting = () => {
      dialogStore.showDialog({
        headerComponent: SettingDialogHeader,
        component: SettingDialogContent
      });
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(SidebarIcon, {
        icon: "pi pi-cog",
        onClick: showSetting,
        tooltip: _ctx.$t("settings")
      }, null, 8, ["tooltip"]);
    };
  }
});
const useWorkspaceStore = defineStore("workspace", {
  state: () => ({
    spinner: false,
    activeSidebarTab: null,
    sidebarTabs: []
  }),
  actions: {
    updateActiveSidebarTab(tabId) {
      this.activeSidebarTab = tabId;
    },
    registerSidebarTab(tab) {
      this.sidebarTabs = [...this.sidebarTabs, tab];
    },
    unregisterSidebarTab(id2) {
      const index2 = this.sidebarTabs.findIndex((tab) => tab.id === id2);
      if (index2 !== -1) {
        const tab = this.sidebarTabs[index2];
        if (tab.type === "custom" && tab.destroy) {
          tab.destroy();
        }
        const newSidebarTabs = [...this.sidebarTabs];
        newSidebarTabs.splice(index2, 1);
        this.sidebarTabs = newSidebarTabs;
      }
    },
    getSidebarTabs() {
      return [...this.sidebarTabs];
    }
  }
});
const _withScopeId$6 = (n) => (pushScopeId("data-v-f54e0ebc"), n = n(), popScopeId(), n);
const _hoisted_1$I = { class: "side-tool-bar-end" };
const _hoisted_2$A = {
  key: 0,
  class: "sidebar-content-container"
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "SideToolbar",
  setup(__props) {
    const workspaceStore = useWorkspaceStore();
    const settingStore = useSettingStore();
    const teleportTarget = computed(
      () => settingStore.get("Comfy.Sidebar.Location") === "left" ? ".comfyui-body-left" : ".comfyui-body-right"
    );
    const isSmall = computed(
      () => settingStore.get("Comfy.Sidebar.Size") === "small"
    );
    const tabs = computed(() => workspaceStore.getSidebarTabs());
    const selectedTab = computed(() => {
      const tabId = workspaceStore.activeSidebarTab;
      return tabs.value.find((tab) => tab.id === tabId) || null;
    });
    const mountCustomTab = (tab, el) => {
      tab.render(el);
    };
    const onTabClick = (item) => {
      workspaceStore.updateActiveSidebarTab(
        workspaceStore.activeSidebarTab === item.id ? null : item.id
      );
    };
    onBeforeUnmount(() => {
      tabs.value.forEach((tab) => {
        if (tab.type === "custom" && tab.destroy) {
          tab.destroy();
        }
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (openBlock(), createBlock(Teleport, { to: teleportTarget.value }, [
          createBaseVNode("nav", {
            class: normalizeClass("side-tool-bar-container" + (isSmall.value ? " small-sidebar" : ""))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(tabs.value, (tab) => {
              return openBlock(), createBlock(SidebarIcon, {
                key: tab.id,
                icon: tab.icon,
                iconBadge: tab.iconBadge,
                tooltip: tab.tooltip,
                selected: tab === selectedTab.value,
                class: normalizeClass(tab.id + "-tab-button"),
                onClick: ($event) => onTabClick(tab)
              }, null, 8, ["icon", "iconBadge", "tooltip", "selected", "class", "onClick"]);
            }), 128)),
            createBaseVNode("div", _hoisted_1$I, [
              createVNode(_sfc_main$o),
              createVNode(_sfc_main$g)
            ])
          ], 2)
        ], 8, ["to"])),
        selectedTab.value ? (openBlock(), createElementBlock("div", _hoisted_2$A, [
          selectedTab.value.type === "vue" ? (openBlock(), createBlock(resolveDynamicComponent(selectedTab.value.component), { key: 0 })) : (openBlock(), createElementBlock("div", {
            key: 1,
            ref: (el) => {
              if (el)
                mountCustomTab(
                  selectedTab.value,
                  el
                );
            }
          }, null, 512))
        ])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const SideToolbar = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-f54e0ebc"]]);
var theme$d = function theme22(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-splitter {\n    display: flex;\n    flex-wrap: nowrap;\n    border: 1px solid ".concat(dt3("splitter.border.color"), ";\n    background: ").concat(dt3("splitter.background"), ";\n    border-radius: ").concat(dt3("border.radius.md"), ";\n    color: ").concat(dt3("splitter.color"), ";\n}\n\n.p-splitter-vertical {\n    flex-direction: column;\n}\n\n.p-splitter-gutter {\n    flex-grow: 0;\n    flex-shrink: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1;\n    background: ").concat(dt3("splitter.gutter.background"), ";\n}\n\n.p-splitter-gutter-handle {\n    border-radius: ").concat(dt3("splitter.handle.border.radius"), ";\n    background: ").concat(dt3("splitter.handle.background"), ";\n    transition: outline-color ").concat(dt3("splitter.transition.duration"), ", box-shadow ").concat(dt3("splitter.transition.duration"), ";\n    outline-color: transparent;\n}\n\n.p-splitter-gutter-handle:focus-visible {\n    box-shadow: ").concat(dt3("splitter.handle.focus.ring.shadow"), ";\n    outline: ").concat(dt3("splitter.handle.focus.ring.width"), " ").concat(dt3("splitter.handle.focus.ring.style"), " ").concat(dt3("splitter.handle.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("splitter.handle.focus.ring.offset"), ";\n}\n\n.p-splitter-horizontal.p-splitter-resizing {\n    cursor: col-resize;\n    user-select: none;\n}\n\n.p-splitter-vertical.p-splitter-resizing {\n    cursor: row-resize;\n    user-select: none;\n}\n\n.p-splitter-horizontal > .p-splitter-gutter > .p-splitter-gutter-handle {\n    height: ").concat(dt3("splitter.handle.size"), ";\n    width: 100%;\n}\n\n.p-splitter-vertical > .p-splitter-gutter > .p-splitter-gutter-handle {\n    width: ").concat(dt3("splitter.handle.size"), ";\n    height: 100%;\n}\n\n.p-splitter-horizontal > .p-splitter-gutter {\n    cursor: col-resize;\n}\n\n.p-splitter-vertical > .p-splitter-gutter {\n    cursor: row-resize;\n}\n\n.p-splitterpanel {\n    flex-grow: 1;\n    overflow: hidden;\n}\n\n.p-splitterpanel-nested {\n    display: flex;\n}\n\n.p-splitterpanel .p-splitter {\n    flex-grow: 1;\n    border: 0 none;\n}\n");
};
var classes$e = {
  root: function root14(_ref2) {
    var props = _ref2.props;
    return ["p-splitter p-component", "p-splitter-" + props.layout];
  },
  gutter: "p-splitter-gutter",
  gutterHandle: "p-splitter-gutter-handle"
};
var inlineStyles$4 = {
  root: function root15(_ref3) {
    var props = _ref3.props;
    return [{
      display: "flex",
      "flex-wrap": "nowrap"
    }, props.layout === "vertical" ? {
      "flex-direction": "column"
    } : ""];
  }
};
var SplitterStyle = BaseStyle.extend({
  name: "splitter",
  theme: theme$d,
  classes: classes$e,
  inlineStyles: inlineStyles$4
});
var script$1$f = {
  name: "BaseSplitter",
  "extends": script$1a,
  props: {
    layout: {
      type: String,
      "default": "horizontal"
    },
    gutterSize: {
      type: Number,
      "default": 4
    },
    stateKey: {
      type: String,
      "default": null
    },
    stateStorage: {
      type: String,
      "default": "session"
    },
    step: {
      type: Number,
      "default": 5
    }
  },
  style: SplitterStyle,
  provide: function provide23() {
    return {
      $pcSplitter: this,
      $parentInstance: this
    };
  }
};
function _toConsumableArray$9(r) {
  return _arrayWithoutHoles$9(r) || _iterableToArray$9(r) || _unsupportedIterableToArray$b(r) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$b(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$b(r, a) : void 0;
  }
}
function _iterableToArray$9(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$9(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$b(r);
}
function _arrayLikeToArray$b(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$H = {
  name: "Splitter",
  "extends": script$1$f,
  inheritAttrs: false,
  emits: ["resizestart", "resizeend", "resize"],
  dragging: false,
  mouseMoveListener: null,
  mouseUpListener: null,
  touchMoveListener: null,
  touchEndListener: null,
  size: null,
  gutterElement: null,
  startPos: null,
  prevPanelElement: null,
  nextPanelElement: null,
  nextPanelSize: null,
  prevPanelSize: null,
  panelSizes: null,
  prevPanelIndex: null,
  timer: null,
  data: function data8() {
    return {
      prevSize: null
    };
  },
  mounted: function mounted8() {
    var _this = this;
    if (this.panels && this.panels.length) {
      var initialized = false;
      if (this.isStateful()) {
        initialized = this.restoreState();
      }
      if (!initialized) {
        var children = _toConsumableArray$9(this.$el.children).filter(function(child) {
          return child.getAttribute("data-pc-name") === "splitterpanel";
        });
        var _panelSizes = [];
        this.panels.map(function(panel2, i2) {
          var panelInitialSize = panel2.props && panel2.props.size ? panel2.props.size : null;
          var panelSize = panelInitialSize || 100 / _this.panels.length;
          _panelSizes[i2] = panelSize;
          children[i2].style.flexBasis = "calc(" + panelSize + "% - " + (_this.panels.length - 1) * _this.gutterSize + "px)";
        });
        this.panelSizes = _panelSizes;
        this.prevSize = parseFloat(_panelSizes[0]).toFixed(4);
      }
    }
  },
  beforeUnmount: function beforeUnmount4() {
    this.clear();
    this.unbindMouseListeners();
  },
  methods: {
    isSplitterPanel: function isSplitterPanel(child) {
      return child.type.name === "SplitterPanel";
    },
    onResizeStart: function onResizeStart(event2, index2, isKeyDown) {
      this.gutterElement = event2.currentTarget || event2.target.parentElement;
      this.size = this.horizontal ? getWidth(this.$el) : getHeight(this.$el);
      if (!isKeyDown) {
        this.dragging = true;
        this.startPos = this.layout === "horizontal" ? event2.pageX || event2.changedTouches[0].pageX : event2.pageY || event2.changedTouches[0].pageY;
      }
      this.prevPanelElement = this.gutterElement.previousElementSibling;
      this.nextPanelElement = this.gutterElement.nextElementSibling;
      if (isKeyDown) {
        this.prevPanelSize = this.horizontal ? getOuterWidth(this.prevPanelElement, true) : getOuterHeight(this.prevPanelElement, true);
        this.nextPanelSize = this.horizontal ? getOuterWidth(this.nextPanelElement, true) : getOuterHeight(this.nextPanelElement, true);
      } else {
        this.prevPanelSize = 100 * (this.horizontal ? getOuterWidth(this.prevPanelElement, true) : getOuterHeight(this.prevPanelElement, true)) / this.size;
        this.nextPanelSize = 100 * (this.horizontal ? getOuterWidth(this.nextPanelElement, true) : getOuterHeight(this.nextPanelElement, true)) / this.size;
      }
      this.prevPanelIndex = index2;
      this.$emit("resizestart", {
        originalEvent: event2,
        sizes: this.panelSizes
      });
      this.$refs.gutter[index2].setAttribute("data-p-gutter-resizing", true);
      this.$el.setAttribute("data-p-resizing", true);
    },
    onResize: function onResize2(event2, step, isKeyDown) {
      var newPos, newPrevPanelSize, newNextPanelSize;
      if (isKeyDown) {
        if (this.horizontal) {
          newPrevPanelSize = 100 * (this.prevPanelSize + step) / this.size;
          newNextPanelSize = 100 * (this.nextPanelSize - step) / this.size;
        } else {
          newPrevPanelSize = 100 * (this.prevPanelSize - step) / this.size;
          newNextPanelSize = 100 * (this.nextPanelSize + step) / this.size;
        }
      } else {
        if (this.horizontal) newPos = event2.pageX * 100 / this.size - this.startPos * 100 / this.size;
        else newPos = event2.pageY * 100 / this.size - this.startPos * 100 / this.size;
        newPrevPanelSize = this.prevPanelSize + newPos;
        newNextPanelSize = this.nextPanelSize - newPos;
      }
      if (this.validateResize(newPrevPanelSize, newNextPanelSize)) {
        this.prevPanelElement.style.flexBasis = "calc(" + newPrevPanelSize + "% - " + (this.panels.length - 1) * this.gutterSize + "px)";
        this.nextPanelElement.style.flexBasis = "calc(" + newNextPanelSize + "% - " + (this.panels.length - 1) * this.gutterSize + "px)";
        this.panelSizes[this.prevPanelIndex] = newPrevPanelSize;
        this.panelSizes[this.prevPanelIndex + 1] = newNextPanelSize;
        this.prevSize = parseFloat(newPrevPanelSize).toFixed(4);
      }
      this.$emit("resize", {
        originalEvent: event2,
        sizes: this.panelSizes
      });
    },
    onResizeEnd: function onResizeEnd(event2) {
      if (this.isStateful()) {
        this.saveState();
      }
      this.$emit("resizeend", {
        originalEvent: event2,
        sizes: this.panelSizes
      });
      this.$refs.gutter.forEach(function(gutter) {
        return gutter.setAttribute("data-p-gutter-resizing", false);
      });
      this.$el.setAttribute("data-p-resizing", false);
      this.clear();
    },
    repeat: function repeat2(event2, index2, step) {
      this.onResizeStart(event2, index2, true);
      this.onResize(event2, step, true);
    },
    setTimer: function setTimer(event2, index2, step) {
      var _this2 = this;
      if (!this.timer) {
        this.timer = setInterval(function() {
          _this2.repeat(event2, index2, step);
        }, 40);
      }
    },
    clearTimer: function clearTimer2() {
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    },
    onGutterKeyUp: function onGutterKeyUp() {
      this.clearTimer();
      this.onResizeEnd();
    },
    onGutterKeyDown: function onGutterKeyDown(event2, index2) {
      switch (event2.code) {
        case "ArrowLeft": {
          if (this.layout === "horizontal") {
            this.setTimer(event2, index2, this.step * -1);
          }
          event2.preventDefault();
          break;
        }
        case "ArrowRight": {
          if (this.layout === "horizontal") {
            this.setTimer(event2, index2, this.step);
          }
          event2.preventDefault();
          break;
        }
        case "ArrowDown": {
          if (this.layout === "vertical") {
            this.setTimer(event2, index2, this.step * -1);
          }
          event2.preventDefault();
          break;
        }
        case "ArrowUp": {
          if (this.layout === "vertical") {
            this.setTimer(event2, index2, this.step);
          }
          event2.preventDefault();
          break;
        }
      }
    },
    onGutterMouseDown: function onGutterMouseDown(event2, index2) {
      this.onResizeStart(event2, index2);
      this.bindMouseListeners();
    },
    onGutterTouchStart: function onGutterTouchStart(event2, index2) {
      this.onResizeStart(event2, index2);
      this.bindTouchListeners();
      event2.preventDefault();
    },
    onGutterTouchMove: function onGutterTouchMove(event2) {
      this.onResize(event2);
      event2.preventDefault();
    },
    onGutterTouchEnd: function onGutterTouchEnd(event2) {
      this.onResizeEnd(event2);
      this.unbindTouchListeners();
      event2.preventDefault();
    },
    bindMouseListeners: function bindMouseListeners() {
      var _this3 = this;
      if (!this.mouseMoveListener) {
        this.mouseMoveListener = function(event2) {
          return _this3.onResize(event2);
        };
        document.addEventListener("mousemove", this.mouseMoveListener);
      }
      if (!this.mouseUpListener) {
        this.mouseUpListener = function(event2) {
          _this3.onResizeEnd(event2);
          _this3.unbindMouseListeners();
        };
        document.addEventListener("mouseup", this.mouseUpListener);
      }
    },
    bindTouchListeners: function bindTouchListeners() {
      var _this4 = this;
      if (!this.touchMoveListener) {
        this.touchMoveListener = function(event2) {
          return _this4.onResize(event2.changedTouches[0]);
        };
        document.addEventListener("touchmove", this.touchMoveListener);
      }
      if (!this.touchEndListener) {
        this.touchEndListener = function(event2) {
          _this4.resizeEnd(event2);
          _this4.unbindTouchListeners();
        };
        document.addEventListener("touchend", this.touchEndListener);
      }
    },
    validateResize: function validateResize(newPrevPanelSize, newNextPanelSize) {
      if (newPrevPanelSize > 100 || newPrevPanelSize < 0) return false;
      if (newNextPanelSize > 100 || newNextPanelSize < 0) return false;
      var prevPanelMinSize = getVNodeProp(this.panels[this.prevPanelIndex], "minSize");
      if (this.panels[this.prevPanelIndex].props && prevPanelMinSize && prevPanelMinSize > newPrevPanelSize) {
        return false;
      }
      var newPanelMinSize = getVNodeProp(this.panels[this.prevPanelIndex + 1], "minSize");
      if (this.panels[this.prevPanelIndex + 1].props && newPanelMinSize && newPanelMinSize > newNextPanelSize) {
        return false;
      }
      return true;
    },
    unbindMouseListeners: function unbindMouseListeners() {
      if (this.mouseMoveListener) {
        document.removeEventListener("mousemove", this.mouseMoveListener);
        this.mouseMoveListener = null;
      }
      if (this.mouseUpListener) {
        document.removeEventListener("mouseup", this.mouseUpListener);
        this.mouseUpListener = null;
      }
    },
    unbindTouchListeners: function unbindTouchListeners() {
      if (this.touchMoveListener) {
        document.removeEventListener("touchmove", this.touchMoveListener);
        this.touchMoveListener = null;
      }
      if (this.touchEndListener) {
        document.removeEventListener("touchend", this.touchEndListener);
        this.touchEndListener = null;
      }
    },
    clear: function clear2() {
      this.dragging = false;
      this.size = null;
      this.startPos = null;
      this.prevPanelElement = null;
      this.nextPanelElement = null;
      this.prevPanelSize = null;
      this.nextPanelSize = null;
      this.gutterElement = null;
      this.prevPanelIndex = null;
    },
    isStateful: function isStateful() {
      return this.stateKey != null;
    },
    getStorage: function getStorage() {
      switch (this.stateStorage) {
        case "local":
          return window.localStorage;
        case "session":
          return window.sessionStorage;
        default:
          throw new Error(this.stateStorage + ' is not a valid value for the state storage, supported values are "local" and "session".');
      }
    },
    saveState: function saveState() {
      if (isArray$2(this.panelSizes)) {
        this.getStorage().setItem(this.stateKey, JSON.stringify(this.panelSizes));
      }
    },
    restoreState: function restoreState() {
      var _this5 = this;
      var storage = this.getStorage();
      var stateString = storage.getItem(this.stateKey);
      if (stateString) {
        this.panelSizes = JSON.parse(stateString);
        var children = _toConsumableArray$9(this.$el.children).filter(function(child) {
          return child.getAttribute("data-pc-name") === "splitterpanel";
        });
        children.forEach(function(child, i2) {
          child.style.flexBasis = "calc(" + _this5.panelSizes[i2] + "% - " + (_this5.panels.length - 1) * _this5.gutterSize + "px)";
        });
        return true;
      }
      return false;
    }
  },
  computed: {
    panels: function panels() {
      var _this6 = this;
      var panels2 = [];
      this.$slots["default"]().forEach(function(child) {
        if (_this6.isSplitterPanel(child)) {
          panels2.push(child);
        } else if (child.children instanceof Array) {
          child.children.forEach(function(nestedChild) {
            if (_this6.isSplitterPanel(nestedChild)) {
              panels2.push(nestedChild);
            }
          });
        }
      });
      return panels2;
    },
    gutterStyle: function gutterStyle() {
      if (this.horizontal) return {
        width: this.gutterSize + "px"
      };
      else return {
        height: this.gutterSize + "px"
      };
    },
    horizontal: function horizontal2() {
      return this.layout === "horizontal";
    },
    getPTOptions: function getPTOptions5() {
      var _this$$parentInstance;
      return {
        context: {
          nested: (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.nestedState
        }
      };
    }
  }
};
var _hoisted_1$H = ["onMousedown", "onTouchstart", "onTouchmove", "onTouchend"];
var _hoisted_2$z = ["aria-orientation", "aria-valuenow", "onKeydown"];
function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    style: _ctx.sx("root"),
    "data-p-resizing": false
  }, _ctx.ptmi("root", $options.getPTOptions)), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.panels, function(panel2, i2) {
    return openBlock(), createElementBlock(Fragment, {
      key: i2
    }, [(openBlock(), createBlock(resolveDynamicComponent(panel2), {
      tabindex: "-1"
    })), i2 !== $options.panels.length - 1 ? (openBlock(), createElementBlock("div", mergeProps({
      key: 0,
      ref_for: true,
      ref: "gutter",
      "class": _ctx.cx("gutter"),
      role: "separator",
      tabindex: "-1",
      onMousedown: function onMousedown($event) {
        return $options.onGutterMouseDown($event, i2);
      },
      onTouchstart: function onTouchstart($event) {
        return $options.onGutterTouchStart($event, i2);
      },
      onTouchmove: function onTouchmove($event) {
        return $options.onGutterTouchMove($event, i2);
      },
      onTouchend: function onTouchend($event) {
        return $options.onGutterTouchEnd($event, i2);
      },
      "data-p-gutter-resizing": false
    }, _ctx.ptm("gutter")), [createBaseVNode("div", mergeProps({
      "class": _ctx.cx("gutterHandle"),
      tabindex: "0",
      style: [$options.gutterStyle],
      "aria-orientation": _ctx.layout,
      "aria-valuenow": $data.prevSize,
      onKeyup: _cache[0] || (_cache[0] = function() {
        return $options.onGutterKeyUp && $options.onGutterKeyUp.apply($options, arguments);
      }),
      onKeydown: function onKeydown3($event) {
        return $options.onGutterKeyDown($event, i2);
      },
      ref_for: true
    }, _ctx.ptm("gutterHandle")), null, 16, _hoisted_2$z)], 16, _hoisted_1$H)) : createCommentVNode("", true)], 64);
  }), 128))], 16);
}
script$H.render = render$G;
var classes$d = {
  root: function root16(_ref) {
    var instance = _ref.instance;
    return ["p-splitterpanel", {
      "p-splitterpanel-nested": instance.isNested
    }];
  }
};
var SplitterPanelStyle = BaseStyle.extend({
  name: "splitterpanel",
  classes: classes$d
});
var script$1$e = {
  name: "BaseSplitterPanel",
  "extends": script$1a,
  props: {
    size: {
      type: Number,
      "default": null
    },
    minSize: {
      type: Number,
      "default": null
    }
  },
  style: SplitterPanelStyle,
  provide: function provide24() {
    return {
      $pcSplitterPanel: this,
      $parentInstance: this
    };
  }
};
var script$G = {
  name: "SplitterPanel",
  "extends": script$1$e,
  inheritAttrs: false,
  data: function data9() {
    return {
      nestedState: null
    };
  },
  computed: {
    isNested: function isNested() {
      var _this = this;
      return this.$slots["default"]().some(function(child) {
        _this.nestedState = child.type.name === "Splitter" ? true : null;
        return _this.nestedState;
      });
    },
    getPTOptions: function getPTOptions6() {
      return {
        context: {
          nested: this.isNested
        }
      };
    }
  }
};
function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root", $options.getPTOptions)), [renderSlot(_ctx.$slots, "default")], 16);
}
script$G.render = render$F;
const _withScopeId$5 = (n) => (pushScopeId("data-v-1c49e664"), n = n(), popScopeId(), n);
const _hoisted_1$G = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", null, null, -1));
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "LiteGraphCanvasSplitterOverlay",
  setup(__props) {
    const settingStore = useSettingStore();
    const sidebarLocation = computed(
      () => settingStore.get("Comfy.Sidebar.Location")
    );
    const sidebarPanelVisible = computed(
      () => useWorkspaceStore().activeSidebarTab !== null
    );
    const gutterClass = computed(() => {
      return sidebarPanelVisible.value ? "" : "gutter-hidden";
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$H), {
        class: "splitter-overlay",
        "pt:gutter": gutterClass.value
      }, {
        default: withCtx(() => [
          sidebarLocation.value === "left" ? withDirectives((openBlock(), createBlock(unref(script$G), {
            key: 0,
            class: "side-bar-panel",
            minSize: 10,
            size: 20
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "side-bar-panel", {}, void 0, true)
            ]),
            _: 3
          }, 512)), [
            [vShow, sidebarPanelVisible.value]
          ]) : createCommentVNode("", true),
          createVNode(unref(script$G), {
            class: "graph-canvas-panel",
            size: 100
          }, {
            default: withCtx(() => [
              _hoisted_1$G
            ]),
            _: 1
          }),
          sidebarLocation.value === "right" ? withDirectives((openBlock(), createBlock(unref(script$G), {
            key: 1,
            class: "side-bar-panel",
            minSize: 10,
            size: 20
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "side-bar-panel", {}, void 0, true)
            ]),
            _: 3
          }, 512)), [
            [vShow, sidebarPanelVisible.value]
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["pt:gutter"]);
    };
  }
});
const LiteGraphCanvasSplitterOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-1c49e664"]]);
var script$F = {
  name: "TimesCircleIcon",
  "extends": script$15
};
var _hoisted_1$F = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7 14C5.61553 14 4.26215 13.5895 3.11101 12.8203C1.95987 12.0511 1.06266 10.9579 0.532846 9.67879C0.00303296 8.3997 -0.13559 6.99224 0.134506 5.63437C0.404603 4.2765 1.07129 3.02922 2.05026 2.05026C3.02922 1.07129 4.2765 0.404603 5.63437 0.134506C6.99224 -0.13559 8.3997 0.00303296 9.67879 0.532846C10.9579 1.06266 12.0511 1.95987 12.8203 3.11101C13.5895 4.26215 14 5.61553 14 7C14 8.85652 13.2625 10.637 11.9497 11.9497C10.637 13.2625 8.85652 14 7 14ZM7 1.16667C5.84628 1.16667 4.71846 1.50879 3.75918 2.14976C2.79989 2.79074 2.05222 3.70178 1.61071 4.76768C1.16919 5.83358 1.05367 7.00647 1.27876 8.13803C1.50384 9.26958 2.05941 10.309 2.87521 11.1248C3.69102 11.9406 4.73042 12.4962 5.86198 12.7212C6.99353 12.9463 8.16642 12.8308 9.23232 12.3893C10.2982 11.9478 11.2093 11.2001 11.8502 10.2408C12.4912 9.28154 12.8333 8.15373 12.8333 7C12.8333 5.45291 12.2188 3.96918 11.1248 2.87521C10.0308 1.78125 8.5471 1.16667 7 1.16667ZM4.66662 9.91668C4.58998 9.91704 4.51404 9.90209 4.44325 9.87271C4.37246 9.84333 4.30826 9.8001 4.2544 9.74557C4.14516 9.6362 4.0838 9.48793 4.0838 9.33335C4.0838 9.17876 4.14516 9.0305 4.2544 8.92113L6.17553 7L4.25443 5.07891C4.15139 4.96832 4.09529 4.82207 4.09796 4.67094C4.10063 4.51982 4.16185 4.37563 4.26872 4.26876C4.3756 4.16188 4.51979 4.10066 4.67091 4.09799C4.82204 4.09532 4.96829 4.15142 5.07887 4.25446L6.99997 6.17556L8.92106 4.25446C9.03164 4.15142 9.1779 4.09532 9.32903 4.09799C9.48015 4.10066 9.62434 4.16188 9.73121 4.26876C9.83809 4.37563 9.89931 4.51982 9.90198 4.67094C9.90464 4.82207 9.84855 4.96832 9.74551 5.07891L7.82441 7L9.74554 8.92113C9.85478 9.0305 9.91614 9.17876 9.91614 9.33335C9.91614 9.48793 9.85478 9.6362 9.74554 9.74557C9.69168 9.8001 9.62748 9.84333 9.55669 9.87271C9.4859 9.90209 9.40996 9.91704 9.33332 9.91668C9.25668 9.91704 9.18073 9.90209 9.10995 9.87271C9.03916 9.84333 8.97495 9.8001 8.9211 9.74557L6.99997 7.82444L5.07884 9.74557C5.02499 9.8001 4.96078 9.84333 4.88999 9.87271C4.81921 9.90209 4.74326 9.91704 4.66662 9.91668Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$y = [_hoisted_1$F];
function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$y, 16);
}
script$F.render = render$E;
var theme$c = function theme23(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-chip {\n    display: inline-flex;\n    align-items: center;\n    background: ".concat(dt3("chip.background"), ";\n    color: ").concat(dt3("chip.color"), ";\n    border-radius: ").concat(dt3("chip.border.radius"), ";\n    padding: ").concat(dt3("chip.padding.y"), " ").concat(dt3("chip.padding.x"), ";\n    gap: ").concat(dt3("chip.gap"), ";\n}\n\n.p-chip-icon {\n    color: ").concat(dt3("chip.icon.color"), ";\n    font-size: ").concat(dt3("chip.icon.font.size"), ";\n    width: ").concat(dt3("chip.icon.size"), ";\n    height: ").concat(dt3("chip.icon.size"), ";\n}\n\n.p-chip-image {\n    border-radius: 50%;\n    width: ").concat(dt3("chip.image.width"), ";\n    height: ").concat(dt3("chip.image.height"), ";\n    margin-left: calc(-1 * ").concat(dt3("chip.padding.y"), ");\n}\n\n.p-chip:has(.p-chip-remove-icon) {\n    padding-right: ").concat(dt3("chip.padding.y"), ";\n}\n\n.p-chip:has(.p-chip-image) {\n    padding-top: calc(").concat(dt3("chip.padding.y"), " / 2);\n    padding-bottom: calc(").concat(dt3("chip.padding.y"), " / 2);\n}\n\n.p-chip-remove-icon {\n    cursor: pointer;\n    font-size: ").concat(dt3("chip.remove.icon.size"), ";\n    width: ").concat(dt3("chip.remove.icon.size"), ";\n    height: ").concat(dt3("chip.remove.icon.size"), ";\n    color: ").concat(dt3("chip.remove.icon.color"), ";\n    border-radius: 50%;\n    transition: outline-color ").concat(dt3("chip.transition.duration"), ", box-shadow ").concat(dt3("chip.transition.duration"), ";\n    outline-color: transparent;\n}\n\n.p-chip-remove-icon:focus-visible {\n    box-shadow: ").concat(dt3("chip.remove.icon.focus.ring.shadow"), ";\n    outline: ").concat(dt3("chip.remove.icon.focus.ring.width"), " ").concat(dt3("chip.remove.icon.focus.ring.style"), " ").concat(dt3("chip.remove.icon.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("chip.remove.icon.focus.ring.offset"), ";\n}\n");
};
var classes$c = {
  root: "p-chip p-component",
  image: "p-chip-image",
  icon: "p-chip-icon",
  label: "p-chip-label",
  removeIcon: "p-chip-remove-icon"
};
var ChipStyle = BaseStyle.extend({
  name: "chip",
  theme: theme$c,
  classes: classes$c
});
var script$1$d = {
  name: "BaseChip",
  "extends": script$1a,
  props: {
    label: {
      type: String,
      "default": null
    },
    icon: {
      type: String,
      "default": null
    },
    image: {
      type: String,
      "default": null
    },
    removable: {
      type: Boolean,
      "default": false
    },
    removeIcon: {
      type: String,
      "default": void 0
    }
  },
  style: ChipStyle,
  provide: function provide25() {
    return {
      $pcChip: this,
      $parentInstance: this
    };
  }
};
var script$E = {
  name: "Chip",
  "extends": script$1$d,
  inheritAttrs: false,
  emits: ["remove"],
  data: function data10() {
    return {
      visible: true
    };
  },
  methods: {
    onKeydown: function onKeydown2(event2) {
      if (event2.key === "Enter" || event2.key === "Backspace") {
        this.close(event2);
      }
    },
    close: function close(event2) {
      this.visible = false;
      this.$emit("remove", event2);
    }
  },
  components: {
    TimesCircleIcon: script$F
  }
};
var _hoisted_1$E = ["aria-label"];
var _hoisted_2$x = ["src"];
function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return $data.visible ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("root"),
    "aria-label": _ctx.label
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [_ctx.image ? (openBlock(), createElementBlock("img", mergeProps({
      key: 0,
      src: _ctx.image
    }, _ctx.ptm("image"), {
      "class": _ctx.cx("image")
    }), null, 16, _hoisted_2$x)) : _ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), mergeProps({
      key: 1,
      "class": _ctx.cx("icon")
    }, _ctx.ptm("icon")), null, 16, ["class"])) : _ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
      key: 2,
      "class": [_ctx.cx("icon"), _ctx.icon]
    }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true), _ctx.label ? (openBlock(), createElementBlock("div", mergeProps({
      key: 3,
      "class": _ctx.cx("label")
    }, _ctx.ptm("label")), toDisplayString$1(_ctx.label), 17)) : createCommentVNode("", true)];
  }), _ctx.removable ? renderSlot(_ctx.$slots, "removeicon", {
    key: 0,
    removeCallback: $options.close,
    keydownCallback: $options.onKeydown
  }, function() {
    return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.removeIcon ? "span" : "TimesCircleIcon"), mergeProps({
      tabindex: "0",
      "class": [_ctx.cx("removeIcon"), _ctx.removeIcon],
      onClick: $options.close,
      onKeydown: $options.onKeydown
    }, _ctx.ptm("removeIcon")), null, 16, ["class", "onClick", "onKeydown"]))];
  }) : createCommentVNode("", true)], 16, _hoisted_1$E)) : createCommentVNode("", true);
}
script$E.render = render$D;
var theme$b = function theme24(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-autocomplete {\n    display: inline-flex;\n}\n\n.p-autocomplete-loader {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n    right: ".concat(dt3("autocomplete.padding.x"), ";\n}\n\n.p-autocomplete:has(.p-autocomplete-dropdown) .p-autocomplete-loader {\n    right: calc(").concat(dt3("autocomplete.dropdown.width"), " + ").concat(dt3("autocomplete.padding.x"), ");\n}\n\n.p-autocomplete:has(.p-autocomplete-dropdown) .p-autocomplete-input {\n    flex: 1 1 auto;\n    width: 1%;\n}\n\n.p-autocomplete:has(.p-autocomplete-dropdown) .p-autocomplete-input,\n.p-autocomplete:has(.p-autocomplete-dropdown) .p-autocomplete-input-multiple {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n}\n\n.p-autocomplete-dropdown {\n    cursor: pointer;\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    width: ").concat(dt3("autocomplete.dropdown.width"), ";\n    border-top-right-radius: ").concat(dt3("autocomplete.dropdown.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("autocomplete.dropdown.border.radius"), ";\n    background: ").concat(dt3("autocomplete.dropdown.background"), ";\n    border: 1px solid ").concat(dt3("autocomplete.dropdown.border.color"), ";\n    border-left: 0 none;\n    color: ").concat(dt3("autocomplete.dropdown.color"), ";\n    transition: background ").concat(dt3("autocomplete.transition.duration"), ", color ").concat(dt3("autocomplete.transition.duration"), ", border-color ").concat(dt3("autocomplete.transition.duration"), ", outline-color ").concat(dt3("autocomplete.transition.duration"), ", box-shadow ").concat(dt3("autocomplete.transition.duration"), ";\n    outline-color: transparent;\n}\n\n.p-autocomplete-dropdown:not(:disabled):hover {\n    background: ").concat(dt3("autocomplete.dropdown.hover.background"), ";\n    border-color: ").concat(dt3("autocomplete.dropdown.hover.border.color"), ";\n    color: ").concat(dt3("autocomplete.dropdown.hover.color"), ";\n}\n\n.p-autocomplete-dropdown:not(:disabled):active {\n    background: ").concat(dt3("autocomplete.dropdown.active.background"), ";\n    border-color: ").concat(dt3("autocomplete.dropdown.active.border.color"), ";\n    color: ").concat(dt3("autocomplete.dropdown.active.color"), ";\n}\n\n.p-autocomplete-dropdown:focus-visible {\n    box-shadow: ").concat(dt3("autocomplete.dropdown.focus.ring.shadow"), ";\n    outline: ").concat(dt3("autocomplete.dropdown.focus.ring.width"), " ").concat(dt3("autocomplete.dropdown.focus.ring.style"), " ").concat(dt3("autocomplete.dropdown.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("autocomplete.dropdown.focus.ring.offset"), ";\n}\n\n.p-autocomplete .p-autocomplete-overlay {\n    min-width: 100%;\n}\n\n.p-autocomplete-overlay {\n    position: absolute;\n    overflow: auto;\n    top: 0;\n    left: 0;\n    background: ").concat(dt3("autocomplete.overlay.background"), ";\n    color: ").concat(dt3("autocomplete.overlay.color"), ";\n    border: 1px solid ").concat(dt3("autocomplete.overlay.border.color"), ";\n    border-radius: ").concat(dt3("autocomplete.overlay.border.radius"), ";\n    box-shadow: ").concat(dt3("autocomplete.overlay.shadow"), ";\n}\n\n.p-autocomplete-list {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("autocomplete.list.gap"), ";\n    padding: ").concat(dt3("autocomplete.list.padding"), ";\n}\n\n.p-autocomplete-option {\n    cursor: pointer;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt3("autocomplete.option.padding"), ";\n    border: 0 none;\n    color: ").concat(dt3("autocomplete.option.color"), ";\n    background: transparent;\n    transition: background ").concat(dt3("autocomplete.transition.duration"), ", color ").concat(dt3("autocomplete.transition.duration"), ", border-color ").concat(dt3("autocomplete.transition.duration"), ";\n    border-radius: ").concat(dt3("autocomplete.option.border.radius"), ";\n}\n\n.p-autocomplete-option:not(.p-autocomplete-option-selected):not(.p-disabled).p-focus {\n    background: ").concat(dt3("autocomplete.option.focus.background"), ";\n    color: ").concat(dt3("autocomplete.option.focus.color"), ";\n}\n\n.p-autocomplete-option-selected {\n    background: ").concat(dt3("autocomplete.option.selected.background"), ";\n    color: ").concat(dt3("autocomplete.option.selected.color"), ";\n}\n\n.p-autocomplete-option-selected.p-focus {\n    background: ").concat(dt3("autocomplete.option.selected.focus.background"), ";\n    color: ").concat(dt3("autocomplete.option.selected.focus.color"), ";\n}\n\n.p-autocomplete-option-group {\n    margin: 0;\n    padding: ").concat(dt3("autocomplete.option.group.padding"), ";\n    color: ").concat(dt3("autocomplete.option.group.color"), ";\n    background: ").concat(dt3("autocomplete.option.group.background"), ";\n    font-weight: ").concat(dt3("autocomplete.option.group.font.weight"), ";\n}\n\n.p-autocomplete-input-multiple {\n    margin: 0;\n    list-style-type: none;\n    cursor: text;\n    overflow: hidden;\n    display: flex;\n    align-items: center;\n    flex-wrap: wrap;\n    padding: calc(").concat(dt3("autocomplete.padding.y"), " / 2) ").concat(dt3("autocomplete.padding.x"), ";\n    gap: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    color: ").concat(dt3("autocomplete.color"), ";\n    background: ").concat(dt3("autocomplete.background"), ";\n    border: 1px solid ").concat(dt3("autocomplete.border.color"), ";\n    border-radius: ").concat(dt3("autocomplete.border.radius"), ";\n    width: 100%;\n    transition: background ").concat(dt3("autocomplete.transition.duration"), ", color ").concat(dt3("autocomplete.transition.duration"), ", border-color ").concat(dt3("autocomplete.transition.duration"), ", outline-color ").concat(dt3("autocomplete.transition.duration"), ", box-shadow ").concat(dt3("autocomplete.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("autocomplete.shadow"), ";\n}\n\n.p-autocomplete:not(.p-disabled):hover .p-autocomplete-input-multiple {\n    border-color: ").concat(dt3("autocomplete.hover.border.color"), ";\n}\n\n.p-autocomplete:not(.p-disabled).p-focus .p-autocomplete-input-multiple {\n    border-color: ").concat(dt3("autocomplete.focus.border.color"), ";\n    box-shadow: ").concat(dt3("autocomplete.focus.ring.shadow"), ";\n    outline: ").concat(dt3("autocomplete.focus.ring.width"), " ").concat(dt3("autocomplete.focus.ring.style"), " ").concat(dt3("autocomplete.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("autocomplete.focus.ring.offset"), ";\n}\n\n.p-autocomplete.p-invalid .p-autocomplete-input-multiple {\n    border-color: ").concat(dt3("autocomplete.invalid.border.color"), ";\n}\n\n.p-variant-filled.p-autocomplete-input-multiple {\n    background: ").concat(dt3("autocomplete.filled.background"), ";\n}\n\n.p-autocomplete:not(.p-disabled).p-focus .p-variant-filled.p-autocomplete-input-multiple  {\n    background: ").concat(dt3("autocomplete.filled.focus.background"), ";\n}\n\n.p-autocomplete.p-disabled .p-autocomplete-input-multiple {\n    opacity: 1;\n    background: ").concat(dt3("autocomplete.disabled.background"), ";\n    color: ").concat(dt3("autocomplete.disabled.color"), ";\n}\n\n.p-autocomplete-chip.p-chip {\n    padding-top: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    padding-bottom: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    border-radius: ").concat(dt3("autocomplete.chip.border.radius"), ";\n}\n\n.p-autocomplete-input-multiple:has(.p-autocomplete-chip) {\n    padding-left: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    padding-right: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n}\n\n.p-autocomplete-chip-item.p-focus .p-autocomplete-chip {\n    background: ").concat(dt3("inputchips.chip.focus.background"), ";\n    color: ").concat(dt3("inputchips.chip.focus.color"), ";\n}\n\n.p-autocomplete-input-chip {\n    flex: 1 1 auto;\n    display: inline-flex;\n    padding-top: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n    padding-bottom: calc(").concat(dt3("autocomplete.padding.y"), " / 2);\n}\n\n.p-autocomplete-input-chip input {\n    border: 0 none;\n    outline: 0 none;\n    background: transparent;\n    margin: 0;\n    padding: 0;\n    box-shadow: none;\n    border-radius: 0;\n    width: 100%;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    font-size: 1rem;\n    color: inherit;\n}\n\n.p-autocomplete-input-chip input::placeholder {\n    color: ").concat(dt3("autocomplete.placeholder.color"), ";\n}\n\n.p-autocomplete-empty-message {\n    padding: ").concat(dt3("autocomplete.empty.message.padding"), ";\n}\n\n.p-autocomplete-fluid {\n    display: flex;\n}\n\n.p-autocomplete-fluid:has(.p-autocomplete-dropdown) .p-autocomplete-input {\n    width: 1%;\n}\n");
};
var inlineStyles$3 = {
  root: {
    position: "relative"
  }
};
var classes$b = {
  root: function root17(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-autocomplete p-component p-inputwrapper", {
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-focus": instance.focused,
      "p-inputwrapper-filled": props.modelValue || isNotEmpty(instance.inputValue),
      "p-inputwrapper-focus": instance.focused,
      "p-autocomplete-open": instance.overlayVisible,
      "p-autocomplete-fluid": props.fluid
    }];
  },
  pcInput: "p-autocomplete-input",
  inputMultiple: function inputMultiple(_ref3) {
    var props = _ref3.props, instance = _ref3.instance;
    return ["p-autocomplete-input-multiple", {
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled"
    }];
  },
  chipItem: function chipItem(_ref4) {
    var instance = _ref4.instance, i2 = _ref4.i;
    return ["p-autocomplete-chip-item", {
      "p-focus": instance.focusedMultipleOptionIndex === i2
    }];
  },
  pcChip: "p-autocomplete-chip",
  chipIcon: "p-autocomplete-chip-icon",
  inputChip: "p-autocomplete-input-chip",
  loader: "p-autocomplete-loader",
  dropdown: "p-autocomplete-dropdown",
  overlay: "p-autocomplete-overlay p-component",
  list: "p-autocomplete-list",
  optionGroup: "p-autocomplete-option-group",
  option: function option3(_ref5) {
    var instance = _ref5.instance, _option = _ref5.option, i2 = _ref5.i, getItemOptions = _ref5.getItemOptions;
    return ["p-autocomplete-option", {
      "p-autocomplete-option-selected": instance.isSelected(_option),
      "p-focus": instance.focusedOptionIndex === instance.getOptionIndex(i2, getItemOptions),
      "p-disabled": instance.isOptionDisabled(_option)
    }];
  },
  emptyMessage: "p-autocomplete-empty-message"
};
var AutoCompleteStyle = BaseStyle.extend({
  name: "autocomplete",
  theme: theme$b,
  classes: classes$b,
  inlineStyles: inlineStyles$3
});
var script$1$c = {
  name: "BaseAutoComplete",
  "extends": script$1a,
  props: {
    modelValue: null,
    suggestions: {
      type: Array,
      "default": null
    },
    optionLabel: null,
    optionDisabled: null,
    optionGroupLabel: null,
    optionGroupChildren: null,
    scrollHeight: {
      type: String,
      "default": "14rem"
    },
    dropdown: {
      type: Boolean,
      "default": false
    },
    dropdownMode: {
      type: String,
      "default": "blank"
    },
    multiple: {
      type: Boolean,
      "default": false
    },
    loading: {
      type: Boolean,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    placeholder: {
      type: String,
      "default": null
    },
    dataKey: {
      type: String,
      "default": null
    },
    minLength: {
      type: Number,
      "default": 1
    },
    delay: {
      type: Number,
      "default": 300
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    forceSelection: {
      type: Boolean,
      "default": false
    },
    completeOnFocus: {
      type: Boolean,
      "default": false
    },
    inputId: {
      type: String,
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    panelStyle: {
      type: Object,
      "default": null
    },
    panelClass: {
      type: [String, Object],
      "default": null
    },
    overlayStyle: {
      type: Object,
      "default": null
    },
    overlayClass: {
      type: [String, Object],
      "default": null
    },
    dropdownIcon: {
      type: String,
      "default": null
    },
    dropdownClass: {
      type: [String, Object],
      "default": null
    },
    loader: {
      type: String,
      "default": null
    },
    loadingIcon: {
      type: String,
      "default": null
    },
    removeTokenIcon: {
      type: String,
      "default": null
    },
    chipIcon: {
      type: String,
      "default": null
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    autoOptionFocus: {
      type: Boolean,
      "default": false
    },
    selectOnFocus: {
      type: Boolean,
      "default": false
    },
    focusOnHover: {
      type: Boolean,
      "default": true
    },
    searchLocale: {
      type: String,
      "default": void 0
    },
    searchMessage: {
      type: String,
      "default": null
    },
    selectionMessage: {
      type: String,
      "default": null
    },
    emptySelectionMessage: {
      type: String,
      "default": null
    },
    emptySearchMessage: {
      type: String,
      "default": null
    },
    tabindex: {
      type: Number,
      "default": 0
    },
    typeahead: {
      type: Boolean,
      "default": true
    },
    ariaLabel: {
      type: String,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    fluid: {
      type: Boolean,
      "default": false
    }
  },
  style: AutoCompleteStyle,
  provide: function provide26() {
    return {
      $pcAutoComplete: this,
      $parentInstance: this
    };
  }
};
function _typeof$1$3(o) {
  "@babel/helpers - typeof";
  return _typeof$1$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$3(o);
}
function _toConsumableArray$8(r) {
  return _arrayWithoutHoles$8(r) || _iterableToArray$8(r) || _unsupportedIterableToArray$a(r) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$a(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$a(r, a) : void 0;
  }
}
function _iterableToArray$8(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$8(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$a(r);
}
function _arrayLikeToArray$a(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$D = {
  name: "AutoComplete",
  "extends": script$1$c,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "item-select", "item-unselect", "option-select", "option-unselect", "dropdown-click", "clear", "complete", "before-show", "before-hide", "show", "hide"],
  outsideClickListener: null,
  resizeListener: null,
  scrollHandler: null,
  overlay: null,
  virtualScroller: null,
  searchTimeout: null,
  dirty: false,
  data: function data11() {
    return {
      id: this.$attrs.id,
      clicked: false,
      focused: false,
      focusedOptionIndex: -1,
      focusedMultipleOptionIndex: -1,
      overlayVisible: false,
      searching: false
    };
  },
  watch: {
    "$attrs.id": function $attrsId4(newValue) {
      this.id = newValue || UniqueComponentId();
    },
    suggestions: function suggestions() {
      if (this.searching) {
        this.show();
        this.focusedOptionIndex = this.overlayVisible && this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
        this.searching = false;
      }
      this.autoUpdateModel();
    }
  },
  mounted: function mounted9() {
    this.id = this.id || UniqueComponentId();
    this.autoUpdateModel();
  },
  updated: function updated5() {
    if (this.overlayVisible) {
      this.alignOverlay();
    }
  },
  beforeUnmount: function beforeUnmount5() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    if (this.overlay) {
      ZIndex.clear(this.overlay);
      this.overlay = null;
    }
  },
  methods: {
    getOptionIndex: function getOptionIndex3(index2, fn) {
      return this.virtualScrollerDisabled ? index2 : fn && fn(index2)["index"];
    },
    getOptionLabel: function getOptionLabel3(option4) {
      return this.optionLabel ? resolveFieldData(option4, this.optionLabel) : option4;
    },
    getOptionValue: function getOptionValue4(option4) {
      return option4;
    },
    getOptionRenderKey: function getOptionRenderKey3(option4, index2) {
      return (this.dataKey ? resolveFieldData(option4, this.dataKey) : this.getOptionLabel(option4)) + "_" + index2;
    },
    getPTOptions: function getPTOptions7(option4, itemOptions, index2, key) {
      return this.ptm(key, {
        context: {
          selected: this.isSelected(option4),
          focused: this.focusedOptionIndex === this.getOptionIndex(index2, itemOptions),
          disabled: this.isOptionDisabled(option4)
        }
      });
    },
    isOptionDisabled: function isOptionDisabled3(option4) {
      return this.optionDisabled ? resolveFieldData(option4, this.optionDisabled) : false;
    },
    isOptionGroup: function isOptionGroup3(option4) {
      return this.optionGroupLabel && option4.optionGroup && option4.group;
    },
    getOptionGroupLabel: function getOptionGroupLabel3(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupLabel);
    },
    getOptionGroupChildren: function getOptionGroupChildren3(optionGroup) {
      return resolveFieldData(optionGroup, this.optionGroupChildren);
    },
    getAriaPosInset: function getAriaPosInset3(index2) {
      var _this = this;
      return (this.optionGroupLabel ? index2 - this.visibleOptions.slice(0, index2).filter(function(option4) {
        return _this.isOptionGroup(option4);
      }).length : index2) + 1;
    },
    show: function show3(isFocus) {
      this.$emit("before-show");
      this.dirty = true;
      this.overlayVisible = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
      isFocus && focus(this.multiple ? this.$refs.focusInput : this.$refs.focusInput.$el);
    },
    hide: function hide3(isFocus) {
      var _this2 = this;
      var _hide = function _hide2() {
        _this2.$emit("before-hide");
        _this2.dirty = isFocus;
        _this2.overlayVisible = false;
        _this2.clicked = false;
        _this2.focusedOptionIndex = -1;
        isFocus && focus(_this2.multiple ? _this2.$refs.focusInput : _this2.$refs.focusInput.$el);
      };
      setTimeout(function() {
        _hide();
      }, 0);
    },
    onFocus: function onFocus4(event2) {
      if (this.disabled) {
        return;
      }
      if (!this.dirty && this.completeOnFocus) {
        this.search(event2, event2.target.value, "focus");
      }
      this.dirty = true;
      this.focused = true;
      if (this.overlayVisible) {
        this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.overlayVisible && this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
        this.scrollInView(this.focusedOptionIndex);
      }
      this.$emit("focus", event2);
    },
    onBlur: function onBlur4(event2) {
      this.dirty = false;
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.$emit("blur", event2);
    },
    onKeyDown: function onKeyDown3(event2) {
      if (this.disabled) {
        event2.preventDefault();
        return;
      }
      switch (event2.code) {
        case "ArrowDown":
          this.onArrowDownKey(event2);
          break;
        case "ArrowUp":
          this.onArrowUpKey(event2);
          break;
        case "ArrowLeft":
          this.onArrowLeftKey(event2);
          break;
        case "ArrowRight":
          this.onArrowRightKey(event2);
          break;
        case "Home":
          this.onHomeKey(event2);
          break;
        case "End":
          this.onEndKey(event2);
          break;
        case "PageDown":
          this.onPageDownKey(event2);
          break;
        case "PageUp":
          this.onPageUpKey(event2);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(event2);
          break;
        case "Escape":
          this.onEscapeKey(event2);
          break;
        case "Tab":
          this.onTabKey(event2);
          break;
        case "Backspace":
          this.onBackspaceKey(event2);
          break;
      }
      this.clicked = false;
    },
    onInput: function onInput2(event2) {
      var _this3 = this;
      if (this.typeahead) {
        if (this.searchTimeout) {
          clearTimeout(this.searchTimeout);
        }
        var query = event2.target.value;
        if (!this.multiple) {
          this.updateModel(event2, query);
        }
        if (query.length === 0) {
          this.hide();
          this.$emit("clear");
        } else {
          if (query.length >= this.minLength) {
            this.focusedOptionIndex = -1;
            this.searchTimeout = setTimeout(function() {
              _this3.search(event2, query, "input");
            }, this.delay);
          } else {
            this.hide();
          }
        }
      }
    },
    onChange: function onChange2(event2) {
      var _this4 = this;
      if (this.forceSelection) {
        var valid = false;
        if (this.visibleOptions && !this.multiple) {
          var value3 = this.multiple ? this.$refs.focusInput.value : this.$refs.focusInput.$el.value;
          var matchedValue = this.visibleOptions.find(function(option4) {
            return _this4.isOptionMatched(option4, value3 || "");
          });
          if (matchedValue !== void 0) {
            valid = true;
            !this.isSelected(matchedValue) && this.onOptionSelect(event2, matchedValue);
          }
        }
        if (!valid) {
          if (this.multiple) this.$refs.focusInput.value = "";
          else this.$refs.focusInput.$el.value = "";
          this.$emit("clear");
          !this.multiple && this.updateModel(event2, null);
        }
      }
    },
    onMultipleContainerFocus: function onMultipleContainerFocus() {
      if (this.disabled) {
        return;
      }
      this.focused = true;
    },
    onMultipleContainerBlur: function onMultipleContainerBlur() {
      this.focusedMultipleOptionIndex = -1;
      this.focused = false;
    },
    onMultipleContainerKeyDown: function onMultipleContainerKeyDown(event2) {
      if (this.disabled) {
        event2.preventDefault();
        return;
      }
      switch (event2.code) {
        case "ArrowLeft":
          this.onArrowLeftKeyOnMultiple(event2);
          break;
        case "ArrowRight":
          this.onArrowRightKeyOnMultiple(event2);
          break;
        case "Backspace":
          this.onBackspaceKeyOnMultiple(event2);
          break;
      }
    },
    onContainerClick: function onContainerClick2(event2) {
      this.clicked = true;
      if (this.disabled || this.searching || this.loading || this.isInputClicked(event2) || this.isDropdownClicked(event2)) {
        return;
      }
      if (!this.overlay || !this.overlay.contains(event2.target)) {
        focus(this.multiple ? this.$refs.focusInput : this.$refs.focusInput.$el);
      }
    },
    onDropdownClick: function onDropdownClick(event2) {
      var query = void 0;
      if (this.overlayVisible) {
        this.hide(true);
      } else {
        focus(this.multiple ? this.$refs.focusInput : this.$refs.focusInput.$el);
        query = this.$refs.focusInput.$el.value;
        if (this.dropdownMode === "blank") this.search(event2, "", "dropdown");
        else if (this.dropdownMode === "current") this.search(event2, query, "dropdown");
      }
      this.$emit("dropdown-click", {
        originalEvent: event2,
        query
      });
    },
    onOptionSelect: function onOptionSelect3(event2, option4) {
      var isHide = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var value3 = this.getOptionValue(option4);
      if (this.multiple) {
        this.$refs.focusInput.value = "";
        if (!this.isSelected(option4)) {
          this.updateModel(event2, [].concat(_toConsumableArray$8(this.modelValue || []), [value3]));
        }
      } else {
        this.updateModel(event2, value3);
      }
      this.$emit("item-select", {
        originalEvent: event2,
        value: option4
      });
      this.$emit("option-select", {
        originalEvent: event2,
        value: option4
      });
      isHide && this.hide(true);
    },
    onOptionMouseMove: function onOptionMouseMove3(event2, index2) {
      if (this.focusOnHover) {
        this.changeFocusedOptionIndex(event2, index2);
      }
    },
    onOverlayClick: function onOverlayClick2(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.$el
      });
    },
    onOverlayKeyDown: function onOverlayKeyDown2(event2) {
      switch (event2.code) {
        case "Escape":
          this.onEscapeKey(event2);
          break;
      }
    },
    onArrowDownKey: function onArrowDownKey3(event2) {
      if (!this.overlayVisible) {
        return;
      }
      var optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findFirstOptionIndex() : this.findFirstFocusedOptionIndex();
      this.changeFocusedOptionIndex(event2, optionIndex);
      event2.preventDefault();
    },
    onArrowUpKey: function onArrowUpKey3(event2) {
      if (!this.overlayVisible) {
        return;
      }
      if (event2.altKey) {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
        }
        this.overlayVisible && this.hide();
        event2.preventDefault();
      } else {
        var optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findLastOptionIndex() : this.findLastFocusedOptionIndex();
        this.changeFocusedOptionIndex(event2, optionIndex);
        event2.preventDefault();
      }
    },
    onArrowLeftKey: function onArrowLeftKey3(event2) {
      var target = event2.currentTarget;
      this.focusedOptionIndex = -1;
      if (this.multiple) {
        if (isEmpty(target.value) && this.hasSelectedOption) {
          focus(this.$refs.multiContainer);
          this.focusedMultipleOptionIndex = this.modelValue.length;
        } else {
          event2.stopPropagation();
        }
      }
    },
    onArrowRightKey: function onArrowRightKey(event2) {
      this.focusedOptionIndex = -1;
      this.multiple && event2.stopPropagation();
    },
    onHomeKey: function onHomeKey3(event2) {
      var currentTarget = event2.currentTarget;
      var len = currentTarget.value.length;
      currentTarget.setSelectionRange(0, event2.shiftKey ? len : 0);
      this.focusedOptionIndex = -1;
      event2.preventDefault();
    },
    onEndKey: function onEndKey3(event2) {
      var currentTarget = event2.currentTarget;
      var len = currentTarget.value.length;
      currentTarget.setSelectionRange(event2.shiftKey ? 0 : len, len);
      this.focusedOptionIndex = -1;
      event2.preventDefault();
    },
    onPageUpKey: function onPageUpKey3(event2) {
      this.scrollInView(0);
      event2.preventDefault();
    },
    onPageDownKey: function onPageDownKey3(event2) {
      this.scrollInView(this.visibleOptions.length - 1);
      event2.preventDefault();
    },
    onEnterKey: function onEnterKey3(event2) {
      if (!this.typeahead) {
        if (this.multiple) {
          this.updateModel(event2, [].concat(_toConsumableArray$8(this.modelValue || []), [event2.target.value]));
          this.$refs.focusInput.value = "";
        }
      } else {
        if (!this.overlayVisible) {
          this.focusedOptionIndex = -1;
          this.onArrowDownKey(event2);
        } else {
          if (this.focusedOptionIndex !== -1) {
            this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
          }
          this.hide();
        }
      }
    },
    onEscapeKey: function onEscapeKey2(event2) {
      this.overlayVisible && this.hide(true);
      event2.preventDefault();
    },
    onTabKey: function onTabKey2(event2) {
      if (this.focusedOptionIndex !== -1) {
        this.onOptionSelect(event2, this.visibleOptions[this.focusedOptionIndex]);
      }
      this.overlayVisible && this.hide();
    },
    onBackspaceKey: function onBackspaceKey2(event2) {
      if (this.multiple) {
        if (isNotEmpty(this.modelValue) && !this.$refs.focusInput.value) {
          var removedValue = this.modelValue[this.modelValue.length - 1];
          var newValue = this.modelValue.slice(0, -1);
          this.$emit("update:modelValue", newValue);
          this.$emit("item-unselect", {
            originalEvent: event2,
            value: removedValue
          });
          this.$emit("option-unselect", {
            originalEvent: event2,
            value: removedValue
          });
        }
        event2.stopPropagation();
      }
    },
    onArrowLeftKeyOnMultiple: function onArrowLeftKeyOnMultiple() {
      this.focusedMultipleOptionIndex = this.focusedMultipleOptionIndex < 1 ? 0 : this.focusedMultipleOptionIndex - 1;
    },
    onArrowRightKeyOnMultiple: function onArrowRightKeyOnMultiple() {
      this.focusedMultipleOptionIndex++;
      if (this.focusedMultipleOptionIndex > this.modelValue.length - 1) {
        this.focusedMultipleOptionIndex = -1;
        focus(this.$refs.focusInput);
      }
    },
    onBackspaceKeyOnMultiple: function onBackspaceKeyOnMultiple(event2) {
      if (this.focusedMultipleOptionIndex !== -1) {
        this.removeOption(event2, this.focusedMultipleOptionIndex);
      }
    },
    onOverlayEnter: function onOverlayEnter2(el) {
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
      addStyle(el, {
        position: "absolute",
        top: "0",
        left: "0"
      });
      this.alignOverlay();
    },
    onOverlayAfterEnter: function onOverlayAfterEnter2() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.$emit("show");
    },
    onOverlayLeave: function onOverlayLeave2() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit("hide");
      this.overlay = null;
    },
    onOverlayAfterLeave: function onOverlayAfterLeave2(el) {
      ZIndex.clear(el);
    },
    alignOverlay: function alignOverlay3() {
      var target = this.multiple ? this.$refs.multiContainer : this.$refs.focusInput.$el;
      if (this.appendTo === "self") {
        relativePosition(this.overlay, target);
      } else {
        this.overlay.style.minWidth = getOuterWidth(target) + "px";
        absolutePosition(this.overlay, target);
      }
    },
    bindOutsideClickListener: function bindOutsideClickListener2() {
      var _this5 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this5.overlayVisible && _this5.overlay && _this5.isOutsideClicked(event2)) {
            _this5.hide();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    },
    unbindOutsideClickListener: function unbindOutsideClickListener2() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },
    bindScrollListener: function bindScrollListener3() {
      var _this6 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, function() {
          if (_this6.overlayVisible) {
            _this6.hide();
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    },
    unbindScrollListener: function unbindScrollListener3() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },
    bindResizeListener: function bindResizeListener3() {
      var _this7 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this7.overlayVisible && !isTouchDevice()) {
            _this7.hide();
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    },
    unbindResizeListener: function unbindResizeListener3() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    },
    isOutsideClicked: function isOutsideClicked(event2) {
      return !this.overlay.contains(event2.target) && !this.isInputClicked(event2) && !this.isDropdownClicked(event2);
    },
    isInputClicked: function isInputClicked(event2) {
      if (this.multiple) return event2.target === this.$refs.multiContainer || this.$refs.multiContainer.contains(event2.target);
      else return event2.target === this.$refs.focusInput.$el;
    },
    isDropdownClicked: function isDropdownClicked(event2) {
      return this.$refs.dropdownButton ? event2.target === this.$refs.dropdownButton || this.$refs.dropdownButton.contains(event2.target) : false;
    },
    isOptionMatched: function isOptionMatched3(option4, value3) {
      var _this$getOptionLabel;
      return this.isValidOption(option4) && ((_this$getOptionLabel = this.getOptionLabel(option4)) === null || _this$getOptionLabel === void 0 ? void 0 : _this$getOptionLabel.toLocaleLowerCase(this.searchLocale)) === value3.toLocaleLowerCase(this.searchLocale);
    },
    isValidOption: function isValidOption3(option4) {
      return isNotEmpty(option4) && !(this.isOptionDisabled(option4) || this.isOptionGroup(option4));
    },
    isValidSelectedOption: function isValidSelectedOption3(option4) {
      return this.isValidOption(option4) && this.isSelected(option4);
    },
    isEquals: function isEquals2(value1, value22) {
      return equals(value1, value22, this.equalityKey);
    },
    isSelected: function isSelected3(option4) {
      var _this8 = this;
      var optionValue = this.getOptionValue(option4);
      return this.multiple ? (this.modelValue || []).some(function(value3) {
        return _this8.isEquals(value3, optionValue);
      }) : this.isEquals(this.modelValue, this.getOptionValue(option4));
    },
    findFirstOptionIndex: function findFirstOptionIndex3() {
      var _this9 = this;
      return this.visibleOptions.findIndex(function(option4) {
        return _this9.isValidOption(option4);
      });
    },
    findLastOptionIndex: function findLastOptionIndex3() {
      var _this10 = this;
      return findLastIndex(this.visibleOptions, function(option4) {
        return _this10.isValidOption(option4);
      });
    },
    findNextOptionIndex: function findNextOptionIndex3(index2) {
      var _this11 = this;
      var matchedOptionIndex = index2 < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index2 + 1).findIndex(function(option4) {
        return _this11.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index2 + 1 : index2;
    },
    findPrevOptionIndex: function findPrevOptionIndex3(index2) {
      var _this12 = this;
      var matchedOptionIndex = index2 > 0 ? findLastIndex(this.visibleOptions.slice(0, index2), function(option4) {
        return _this12.isValidOption(option4);
      }) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index2;
    },
    findSelectedOptionIndex: function findSelectedOptionIndex3() {
      var _this13 = this;
      return this.hasSelectedOption ? this.visibleOptions.findIndex(function(option4) {
        return _this13.isValidSelectedOption(option4);
      }) : -1;
    },
    findFirstFocusedOptionIndex: function findFirstFocusedOptionIndex3() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    },
    findLastFocusedOptionIndex: function findLastFocusedOptionIndex3() {
      var selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    },
    search: function search2(event2, query, source) {
      if (query === void 0 || query === null) {
        return;
      }
      if (source === "input" && query.trim().length === 0) {
        return;
      }
      this.searching = true;
      this.$emit("complete", {
        originalEvent: event2,
        query
      });
    },
    removeOption: function removeOption2(event2, index2) {
      var _this14 = this;
      var removedOption = this.modelValue[index2];
      var value3 = this.modelValue.filter(function(_2, i2) {
        return i2 !== index2;
      }).map(function(option4) {
        return _this14.getOptionValue(option4);
      });
      this.updateModel(event2, value3);
      this.$emit("item-unselect", {
        originalEvent: event2,
        value: removedOption
      });
      this.$emit("option-unselect", {
        originalEvent: event2,
        value: removedOption
      });
      this.dirty = true;
      focus(this.multiple ? this.$refs.focusInput : this.$refs.focusInput.$el);
    },
    changeFocusedOptionIndex: function changeFocusedOptionIndex3(event2, index2) {
      if (this.focusedOptionIndex !== index2) {
        this.focusedOptionIndex = index2;
        this.scrollInView();
        if (this.selectOnFocus) {
          this.onOptionSelect(event2, this.visibleOptions[index2], false);
        }
      }
    },
    scrollInView: function scrollInView5() {
      var _this15 = this;
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var id2 = index2 !== -1 ? "".concat(_this15.id, "_").concat(index2) : _this15.focusedOptionId;
        var element = findSingle(_this15.list, 'li[id="'.concat(id2, '"]'));
        if (element) {
          element.scrollIntoView && element.scrollIntoView({
            block: "nearest",
            inline: "start"
          });
        } else if (!_this15.virtualScrollerDisabled) {
          _this15.virtualScroller && _this15.virtualScroller.scrollToIndex(index2 !== -1 ? index2 : _this15.focusedOptionIndex);
        }
      });
    },
    autoUpdateModel: function autoUpdateModel3() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], false);
      }
    },
    updateModel: function updateModel5(event2, value3) {
      this.$emit("update:modelValue", value3);
      this.$emit("change", {
        originalEvent: event2,
        value: value3
      });
    },
    flatOptions: function flatOptions3(options3) {
      var _this16 = this;
      return (options3 || []).reduce(function(result, option4, index2) {
        result.push({
          optionGroup: option4,
          group: true,
          index: index2
        });
        var optionGroupChildren = _this16.getOptionGroupChildren(option4);
        optionGroupChildren && optionGroupChildren.forEach(function(o) {
          return result.push(o);
        });
        return result;
      }, []);
    },
    overlayRef: function overlayRef2(el) {
      this.overlay = el;
    },
    listRef: function listRef3(el, contentRef3) {
      this.list = el;
      contentRef3 && contentRef3(el);
    },
    virtualScrollerRef: function virtualScrollerRef3(el) {
      this.virtualScroller = el;
    }
  },
  computed: {
    visibleOptions: function visibleOptions3() {
      return this.optionGroupLabel ? this.flatOptions(this.suggestions) : this.suggestions || [];
    },
    inputValue: function inputValue() {
      if (isNotEmpty(this.modelValue)) {
        if (_typeof$1$3(this.modelValue) === "object") {
          var label5 = this.getOptionLabel(this.modelValue);
          return label5 != null ? label5 : this.modelValue;
        } else {
          return this.modelValue;
        }
      } else {
        return "";
      }
    },
    hasSelectedOption: function hasSelectedOption3() {
      return isNotEmpty(this.modelValue);
    },
    equalityKey: function equalityKey3() {
      return this.dataKey;
    },
    searchResultMessageText: function searchResultMessageText() {
      return isNotEmpty(this.visibleOptions) && this.overlayVisible ? this.searchMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptySearchMessageText;
    },
    searchMessageText: function searchMessageText() {
      return this.searchMessage || this.$primevue.config.locale.searchMessage || "";
    },
    emptySearchMessageText: function emptySearchMessageText() {
      return this.emptySearchMessage || this.$primevue.config.locale.emptySearchMessage || "";
    },
    selectionMessageText: function selectionMessageText3() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    },
    emptySelectionMessageText: function emptySelectionMessageText3() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    },
    selectedMessageText: function selectedMessageText3() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll("{0}", this.multiple ? this.modelValue.length : "1") : this.emptySelectionMessageText;
    },
    listAriaLabel: function listAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.listLabel : void 0;
    },
    focusedOptionId: function focusedOptionId3() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.id, "_").concat(this.focusedOptionIndex) : null;
    },
    focusedMultipleOptionId: function focusedMultipleOptionId() {
      return this.focusedMultipleOptionIndex !== -1 ? "".concat(this.id, "_multiple_option_").concat(this.focusedMultipleOptionIndex) : null;
    },
    ariaSetSize: function ariaSetSize3() {
      var _this17 = this;
      return this.visibleOptions.filter(function(option4) {
        return !_this17.isOptionGroup(option4);
      }).length;
    },
    virtualScrollerDisabled: function virtualScrollerDisabled3() {
      return !this.virtualScrollerOptions;
    },
    panelId: function panelId() {
      return this.id + "_panel";
    }
  },
  components: {
    InputText: script$Z,
    VirtualScroller: script$Y,
    Portal: script$N,
    ChevronDownIcon: script$P,
    SpinnerIcon: script$14,
    Chip: script$E
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$h(o) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$h(o);
}
function ownKeys$h(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$h(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$h(Object(t), true).forEach(function(r2) {
      _defineProperty$g(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$g(e, r, t) {
  return (r = _toPropertyKey$f(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$f(t) {
  var i2 = _toPrimitive$f(t, "string");
  return "symbol" == _typeof$h(i2) ? i2 : i2 + "";
}
function _toPrimitive$f(t, r) {
  if ("object" != _typeof$h(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$h(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var _hoisted_1$D = ["aria-activedescendant"];
var _hoisted_2$w = ["id", "aria-label", "aria-setsize", "aria-posinset"];
var _hoisted_3$7 = ["id", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid"];
var _hoisted_4$6 = ["disabled", "aria-expanded", "aria-controls"];
var _hoisted_5$5 = ["id"];
var _hoisted_6$4 = ["id", "aria-label"];
var _hoisted_7$1 = ["id"];
var _hoisted_8$1 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousemove", "data-p-selected", "data-p-focus", "data-p-disabled"];
function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_InputText = resolveComponent("InputText");
  var _component_Chip = resolveComponent("Chip");
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_VirtualScroller = resolveComponent("VirtualScroller");
  var _component_Portal = resolveComponent("Portal");
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "container",
    "class": _ctx.cx("root"),
    style: _ctx.sx("root"),
    onClick: _cache[11] || (_cache[11] = function() {
      return $options.onContainerClick && $options.onContainerClick.apply($options, arguments);
    })
  }, _ctx.ptmi("root")), [!_ctx.multiple ? (openBlock(), createBlock(_component_InputText, {
    key: 0,
    ref: "focusInput",
    id: _ctx.inputId,
    type: "text",
    "class": normalizeClass([_ctx.cx("pcInput"), _ctx.inputClass]),
    style: normalizeStyle(_ctx.inputStyle),
    value: $options.inputValue,
    placeholder: _ctx.placeholder,
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    disabled: _ctx.disabled,
    invalid: _ctx.invalid,
    variant: _ctx.variant,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.panelId,
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    onFocus: $options.onFocus,
    onBlur: $options.onBlur,
    onKeydown: $options.onKeyDown,
    onInput: $options.onInput,
    onChange: $options.onChange,
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcInput")
  }, null, 8, ["id", "class", "style", "value", "placeholder", "tabindex", "disabled", "invalid", "variant", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "onFocus", "onBlur", "onKeydown", "onInput", "onChange", "unstyled", "pt"])) : createCommentVNode("", true), _ctx.multiple ? (openBlock(), createElementBlock("ul", mergeProps({
    key: 1,
    ref: "multiContainer",
    "class": _ctx.cx("inputMultiple"),
    tabindex: "-1",
    role: "listbox",
    "aria-orientation": "horizontal",
    "aria-activedescendant": $data.focused ? $options.focusedMultipleOptionId : void 0,
    onFocus: _cache[5] || (_cache[5] = function() {
      return $options.onMultipleContainerFocus && $options.onMultipleContainerFocus.apply($options, arguments);
    }),
    onBlur: _cache[6] || (_cache[6] = function() {
      return $options.onMultipleContainerBlur && $options.onMultipleContainerBlur.apply($options, arguments);
    }),
    onKeydown: _cache[7] || (_cache[7] = function() {
      return $options.onMultipleContainerKeyDown && $options.onMultipleContainerKeyDown.apply($options, arguments);
    })
  }, _ctx.ptm("inputMultiple")), [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.modelValue, function(option4, i2) {
    return openBlock(), createElementBlock("li", mergeProps({
      key: "".concat(i2, "_").concat($options.getOptionLabel(option4)),
      id: $data.id + "_multiple_option_" + i2,
      "class": _ctx.cx("chipItem", {
        i: i2
      }),
      role: "option",
      "aria-label": $options.getOptionLabel(option4),
      "aria-selected": true,
      "aria-setsize": _ctx.modelValue.length,
      "aria-posinset": i2 + 1,
      ref_for: true
    }, _ctx.ptm("chipItem")), [renderSlot(_ctx.$slots, "chip", mergeProps({
      "class": _ctx.cx("pcChip"),
      value: option4,
      index: i2,
      removeCallback: function removeCallback(event2) {
        return $options.removeOption(event2, i2);
      },
      ref_for: true
    }, _ctx.ptm("pcChip")), function() {
      return [createVNode(_component_Chip, {
        "class": normalizeClass(_ctx.cx("pcChip")),
        label: $options.getOptionLabel(option4),
        removeIcon: _ctx.chipIcon || _ctx.removeTokenIcon,
        removable: "",
        unstyled: _ctx.unstyled,
        onRemove: function onRemove2($event) {
          return $options.removeOption($event, i2);
        },
        pt: _ctx.ptm("pcChip")
      }, {
        removeicon: withCtx(function() {
          return [renderSlot(_ctx.$slots, _ctx.$slots.chipicon ? "chipicon" : "removetokenicon", {
            "class": normalizeClass(_ctx.cx("chipIcon")),
            index: i2,
            removeCallback: function removeCallback(event2) {
              return $options.removeOption(event2, i2);
            }
          })];
        }),
        _: 2
      }, 1032, ["class", "label", "removeIcon", "unstyled", "onRemove", "pt"])];
    })], 16, _hoisted_2$w);
  }), 128)), createBaseVNode("li", mergeProps({
    "class": _ctx.cx("inputChip"),
    role: "option"
  }, _ctx.ptm("inputChip")), [createBaseVNode("input", mergeProps({
    ref: "focusInput",
    id: _ctx.inputId,
    type: "text",
    style: _ctx.inputStyle,
    "class": _ctx.inputClass,
    placeholder: _ctx.placeholder,
    tabindex: !_ctx.disabled ? _ctx.tabindex : -1,
    disabled: _ctx.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $data.id + "_list",
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : void 0,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onKeydown: _cache[2] || (_cache[2] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    }),
    onInput: _cache[3] || (_cache[3] = function() {
      return $options.onInput && $options.onInput.apply($options, arguments);
    }),
    onChange: _cache[4] || (_cache[4] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, _ctx.ptm("input")), null, 16, _hoisted_3$7)], 16)], 16, _hoisted_1$D)) : createCommentVNode("", true), $data.searching || _ctx.loading ? renderSlot(_ctx.$slots, _ctx.$slots.loader ? "loader" : "loadingicon", {
    key: 2,
    "class": normalizeClass(_ctx.cx("loader"))
  }, function() {
    return [_ctx.loader || _ctx.loadingIcon ? (openBlock(), createElementBlock("i", mergeProps({
      key: 0,
      "class": ["pi-spin", _ctx.cx("loader"), _ctx.loader, _ctx.loadingIcon],
      "aria-hidden": "true"
    }, _ctx.ptm("loader")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
      key: 1,
      "class": _ctx.cx("loader"),
      spin: "",
      "aria-hidden": "true"
    }, _ctx.ptm("loader")), null, 16, ["class"]))];
  }) : createCommentVNode("", true), renderSlot(_ctx.$slots, _ctx.$slots.dropdown ? "dropdown" : "dropdownbutton", {
    toggleCallback: function toggleCallback(event2) {
      return $options.onDropdownClick(event2);
    }
  }, function() {
    return [_ctx.dropdown ? (openBlock(), createElementBlock("button", mergeProps({
      key: 0,
      ref: "dropdownButton",
      type: "button",
      "class": [_ctx.cx("dropdown"), _ctx.dropdownClass],
      disabled: _ctx.disabled,
      "aria-haspopup": "listbox",
      "aria-expanded": $data.overlayVisible,
      "aria-controls": $options.panelId,
      onClick: _cache[8] || (_cache[8] = function() {
        return $options.onDropdownClick && $options.onDropdownClick.apply($options, arguments);
      })
    }, _ctx.ptm("dropdown")), [renderSlot(_ctx.$slots, "dropdownicon", {
      "class": normalizeClass(_ctx.dropdownIcon)
    }, function() {
      return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.dropdownIcon ? "span" : "ChevronDownIcon"), mergeProps({
        "class": _ctx.dropdownIcon
      }, _ctx.ptm("dropdownIcon")), null, 16, ["class"]))];
    })], 16, _hoisted_4$6)) : createCommentVNode("", true)];
  }), createBaseVNode("span", mergeProps({
    role: "status",
    "aria-live": "polite",
    "class": "p-hidden-accessible"
  }, _ctx.ptm("hiddenSearchResult"), {
    "data-p-hidden-accessible": true
  }), toDisplayString$1($options.searchResultMessageText), 17), createVNode(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-connected-overlay",
        onEnter: $options.onOverlayEnter,
        onAfterEnter: $options.onOverlayAfterEnter,
        onLeave: $options.onOverlayLeave,
        onAfterLeave: $options.onOverlayAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.overlayRef,
            id: $options.panelId,
            "class": [_ctx.cx("overlay"), _ctx.panelClass, _ctx.overlayClass],
            style: _objectSpread$h(_objectSpread$h(_objectSpread$h({}, _ctx.panelStyle), _ctx.overlayStyle), {}, {
              "max-height": $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
            }),
            onClick: _cache[9] || (_cache[9] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            onKeydown: _cache[10] || (_cache[10] = function() {
              return $options.onOverlayKeyDown && $options.onOverlayKeyDown.apply($options, arguments);
            })
          }, _ctx.ptm("overlay")), [renderSlot(_ctx.$slots, "header", {
            value: _ctx.modelValue,
            suggestions: $options.visibleOptions
          }), createVNode(_component_VirtualScroller, mergeProps({
            ref: $options.virtualScrollerRef
          }, _ctx.virtualScrollerOptions, {
            style: {
              height: _ctx.scrollHeight
            },
            items: $options.visibleOptions,
            tabindex: -1,
            disabled: $options.virtualScrollerDisabled,
            pt: _ctx.ptm("virtualScroller")
          }), createSlots({
            content: withCtx(function(_ref) {
              var styleClass = _ref.styleClass, contentRef3 = _ref.contentRef, items2 = _ref.items, getItemOptions = _ref.getItemOptions, contentStyle = _ref.contentStyle, itemSize2 = _ref.itemSize;
              return [createBaseVNode("ul", mergeProps({
                ref: function ref2(el) {
                  return $options.listRef(el, contentRef3);
                },
                id: $data.id + "_list",
                "class": [_ctx.cx("list"), styleClass],
                style: contentStyle,
                role: "listbox",
                "aria-label": $options.listAriaLabel
              }, _ctx.ptm("list")), [(openBlock(true), createElementBlock(Fragment, null, renderList(items2, function(option4, i2) {
                return openBlock(), createElementBlock(Fragment, {
                  key: $options.getOptionRenderKey(option4, $options.getOptionIndex(i2, getItemOptions))
                }, [$options.isOptionGroup(option4) ? (openBlock(), createElementBlock("li", mergeProps({
                  key: 0,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  "class": _ctx.cx("optionGroup"),
                  role: "option",
                  ref_for: true
                }, _ctx.ptm("optionGroup")), [renderSlot(_ctx.$slots, "optiongroup", {
                  option: option4.optionGroup,
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createTextVNode(toDisplayString$1($options.getOptionGroupLabel(option4.optionGroup)), 1)];
                })], 16, _hoisted_7$1)) : withDirectives((openBlock(), createElementBlock("li", mergeProps({
                  key: 1,
                  id: $data.id + "_" + $options.getOptionIndex(i2, getItemOptions),
                  style: {
                    height: itemSize2 ? itemSize2 + "px" : void 0
                  },
                  "class": _ctx.cx("option", {
                    option: option4,
                    i: i2,
                    getItemOptions
                  }),
                  role: "option",
                  "aria-label": $options.getOptionLabel(option4),
                  "aria-selected": $options.isSelected(option4),
                  "aria-disabled": $options.isOptionDisabled(option4),
                  "aria-setsize": $options.ariaSetSize,
                  "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i2, getItemOptions)),
                  onClick: function onClick5($event) {
                    return $options.onOptionSelect($event, option4);
                  },
                  onMousemove: function onMousemove($event) {
                    return $options.onOptionMouseMove($event, $options.getOptionIndex(i2, getItemOptions));
                  },
                  "data-p-selected": $options.isSelected(option4),
                  "data-p-focus": $data.focusedOptionIndex === $options.getOptionIndex(i2, getItemOptions),
                  "data-p-disabled": $options.isOptionDisabled(option4),
                  ref_for: true
                }, $options.getPTOptions(option4, getItemOptions, i2, "option")), [renderSlot(_ctx.$slots, "option", {
                  option: option4,
                  index: $options.getOptionIndex(i2, getItemOptions)
                }, function() {
                  return [createTextVNode(toDisplayString$1($options.getOptionLabel(option4)), 1)];
                })], 16, _hoisted_8$1)), [[_directive_ripple]])], 64);
              }), 128)), !items2 || items2 && items2.length === 0 ? (openBlock(), createElementBlock("li", mergeProps({
                key: 0,
                "class": _ctx.cx("emptyMessage"),
                role: "option"
              }, _ctx.ptm("emptyMessage")), [renderSlot(_ctx.$slots, "empty", {}, function() {
                return [createTextVNode(toDisplayString$1($options.searchResultMessageText), 1)];
              })], 16)) : createCommentVNode("", true)], 16, _hoisted_6$4)];
            }),
            _: 2
          }, [_ctx.$slots.loader ? {
            name: "loader",
            fn: withCtx(function(_ref2) {
              var options3 = _ref2.options;
              return [renderSlot(_ctx.$slots, "loader", {
                options: options3
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["style", "items", "disabled", "pt"]), renderSlot(_ctx.$slots, "footer", {
            value: _ctx.modelValue,
            suggestions: $options.visibleOptions
          }), createBaseVNode("span", mergeProps({
            role: "status",
            "aria-live": "polite",
            "class": "p-hidden-accessible"
          }, _ctx.ptm("hiddenSelectedMessage"), {
            "data-p-hidden-accessible": true
          }), toDisplayString$1($options.selectedMessageText), 17)], 16, _hoisted_5$5)) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"])], 16);
}
script$D.render = render$C;
const _sfc_main$d = {
  name: "AutoCompletePlus",
  extends: script$D,
  emits: ["focused-option-changed"],
  mounted() {
    if (typeof script$D.mounted === "function") {
      script$D.mounted.call(this);
    }
    this.$watch(
      () => this.focusedOptionIndex,
      (newVal, oldVal) => {
        this.$emit("focused-option-changed", newVal);
      }
    );
  }
};
var script$C = {
  name: "WindowMaximizeIcon",
  "extends": script$15
};
var _hoisted_1$C = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14ZM9.77805 7.42192C9.89013 7.534 10.0415 7.59788 10.2 7.59995C10.3585 7.59788 10.5099 7.534 10.622 7.42192C10.7341 7.30985 10.798 7.15844 10.8 6.99995V3.94242C10.8066 3.90505 10.8096 3.86689 10.8089 3.82843C10.8079 3.77159 10.7988 3.7157 10.7824 3.6623C10.756 3.55552 10.701 3.45698 10.622 3.37798C10.5099 3.2659 10.3585 3.20202 10.2 3.19995H7.00002C6.84089 3.19995 6.68828 3.26317 6.57576 3.37569C6.46324 3.48821 6.40002 3.64082 6.40002 3.79995C6.40002 3.95908 6.46324 4.11169 6.57576 4.22422C6.68828 4.33674 6.84089 4.39995 7.00002 4.39995H8.80006L6.19997 7.00005C6.10158 7.11005 6.04718 7.25246 6.04718 7.40005C6.04718 7.54763 6.10158 7.69004 6.19997 7.80005C6.30202 7.91645 6.44561 7.98824 6.59997 8.00005C6.75432 7.98824 6.89791 7.91645 6.99997 7.80005L9.60002 5.26841V6.99995C9.6021 7.15844 9.66598 7.30985 9.77805 7.42192ZM1.4 14H3.8C4.17066 13.9979 4.52553 13.8498 4.78763 13.5877C5.04973 13.3256 5.1979 12.9707 5.2 12.6V10.2C5.1979 9.82939 5.04973 9.47452 4.78763 9.21242C4.52553 8.95032 4.17066 8.80215 3.8 8.80005H1.4C1.02934 8.80215 0.674468 8.95032 0.412371 9.21242C0.150274 9.47452 0.00210008 9.82939 0 10.2V12.6C0.00210008 12.9707 0.150274 13.3256 0.412371 13.5877C0.674468 13.8498 1.02934 13.9979 1.4 14ZM1.25858 10.0586C1.29609 10.0211 1.34696 10 1.4 10H3.8C3.85304 10 3.90391 10.0211 3.94142 10.0586C3.97893 10.0961 4 10.147 4 10.2V12.6C4 12.6531 3.97893 12.704 3.94142 12.7415C3.90391 12.779 3.85304 12.8 3.8 12.8H1.4C1.34696 12.8 1.29609 12.779 1.25858 12.7415C1.22107 12.704 1.2 12.6531 1.2 12.6V10.2C1.2 10.147 1.22107 10.0961 1.25858 10.0586Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$v = [_hoisted_1$C];
function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$v, 16);
}
script$C.render = render$B;
var script$B = {
  name: "WindowMinimizeIcon",
  "extends": script$15
};
var _hoisted_1$B = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0ZM6.368 7.952C6.44137 7.98326 6.52025 7.99958 6.6 8H9.8C9.95913 8 10.1117 7.93678 10.2243 7.82426C10.3368 7.71174 10.4 7.55913 10.4 7.4C10.4 7.24087 10.3368 7.08826 10.2243 6.97574C10.1117 6.86321 9.95913 6.8 9.8 6.8H8.048L10.624 4.224C10.73 4.11026 10.7877 3.95982 10.7849 3.80438C10.7822 3.64894 10.7192 3.50063 10.6093 3.3907C10.4994 3.28077 10.3511 3.2178 10.1956 3.21506C10.0402 3.21232 9.88974 3.27002 9.776 3.376L7.2 5.952V4.2C7.2 4.04087 7.13679 3.88826 7.02426 3.77574C6.91174 3.66321 6.75913 3.6 6.6 3.6C6.44087 3.6 6.28826 3.66321 6.17574 3.77574C6.06321 3.88826 6 4.04087 6 4.2V7.4C6.00042 7.47975 6.01674 7.55862 6.048 7.632C6.07656 7.70442 6.11971 7.7702 6.17475 7.82524C6.2298 7.88029 6.29558 7.92344 6.368 7.952ZM1.4 8.80005H3.8C4.17066 8.80215 4.52553 8.95032 4.78763 9.21242C5.04973 9.47452 5.1979 9.82939 5.2 10.2V12.6C5.1979 12.9707 5.04973 13.3256 4.78763 13.5877C4.52553 13.8498 4.17066 13.9979 3.8 14H1.4C1.02934 13.9979 0.674468 13.8498 0.412371 13.5877C0.150274 13.3256 0.00210008 12.9707 0 12.6V10.2C0.00210008 9.82939 0.150274 9.47452 0.412371 9.21242C0.674468 8.95032 1.02934 8.80215 1.4 8.80005ZM3.94142 12.7415C3.97893 12.704 4 12.6531 4 12.6V10.2C4 10.147 3.97893 10.0961 3.94142 10.0586C3.90391 10.0211 3.85304 10 3.8 10H1.4C1.34696 10 1.29609 10.0211 1.25858 10.0586C1.22107 10.0961 1.2 10.147 1.2 10.2V12.6C1.2 12.6531 1.22107 12.704 1.25858 12.7415C1.29609 12.779 1.34696 12.8 1.4 12.8H3.8C3.85304 12.8 3.90391 12.779 3.94142 12.7415Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$u = [_hoisted_1$B];
function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$u, 16);
}
script$B.render = render$A;
var FocusTrapStyle = BaseStyle.extend({
  name: "focustrap-directive"
});
var BaseFocusTrap = BaseDirective.extend({
  style: FocusTrapStyle
});
function _typeof$g(o) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$g(o);
}
function ownKeys$g(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$g(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$g(Object(t), true).forEach(function(r2) {
      _defineProperty$f(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$f(e, r, t) {
  return (r = _toPropertyKey$e(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$e(t) {
  var i2 = _toPrimitive$e(t, "string");
  return "symbol" == _typeof$g(i2) ? i2 : i2 + "";
}
function _toPrimitive$e(t, r) {
  if ("object" != _typeof$g(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$g(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var FocusTrap = BaseFocusTrap.extend("focustrap", {
  mounted: function mounted10(el, binding) {
    var _ref = binding.value || {}, disabled2 = _ref.disabled;
    if (!disabled2) {
      this.createHiddenFocusableElements(el, binding);
      this.bind(el, binding);
      this.autoElementFocus(el, binding);
    }
    el.setAttribute("data-pd-focustrap", true);
    this.$el = el;
  },
  updated: function updated6(el, binding) {
    var _ref2 = binding.value || {}, disabled2 = _ref2.disabled;
    disabled2 && this.unbind(el);
  },
  unmounted: function unmounted5(el) {
    this.unbind(el);
  },
  methods: {
    getComputedSelector: function getComputedSelector(selector) {
      return ':not(.p-hidden-focusable):not([data-p-hidden-focusable="true"])'.concat(selector !== null && selector !== void 0 ? selector : "");
    },
    bind: function bind2(el, binding) {
      var _this = this;
      var _ref3 = binding.value || {}, onFocusIn = _ref3.onFocusIn, onFocusOut = _ref3.onFocusOut;
      el.$_pfocustrap_mutationobserver = new MutationObserver(function(mutationList) {
        mutationList.forEach(function(mutation) {
          if (mutation.type === "childList" && !el.contains(document.activeElement)) {
            var findNextFocusableElement = function findNextFocusableElement2(_el) {
              var focusableElement = isFocusableElement(_el) ? isFocusableElement(_el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) ? _el : getFirstFocusableElement(el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) : getFirstFocusableElement(_el);
              return isNotEmpty(focusableElement) ? focusableElement : _el.nextSibling && findNextFocusableElement2(_el.nextSibling);
            };
            focus(findNextFocusableElement(mutation.nextSibling));
          }
        });
      });
      el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_mutationobserver.observe(el, {
        childList: true
      });
      el.$_pfocustrap_focusinlistener = function(event2) {
        return onFocusIn && onFocusIn(event2);
      };
      el.$_pfocustrap_focusoutlistener = function(event2) {
        return onFocusOut && onFocusOut(event2);
      };
      el.addEventListener("focusin", el.$_pfocustrap_focusinlistener);
      el.addEventListener("focusout", el.$_pfocustrap_focusoutlistener);
    },
    unbind: function unbind(el) {
      el.$_pfocustrap_mutationobserver && el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_focusinlistener && el.removeEventListener("focusin", el.$_pfocustrap_focusinlistener) && (el.$_pfocustrap_focusinlistener = null);
      el.$_pfocustrap_focusoutlistener && el.removeEventListener("focusout", el.$_pfocustrap_focusoutlistener) && (el.$_pfocustrap_focusoutlistener = null);
    },
    autoFocus: function autoFocus(options3) {
      this.autoElementFocus(this.$el, {
        value: _objectSpread$g(_objectSpread$g({}, options3), {}, {
          autoFocus: true
        })
      });
    },
    autoElementFocus: function autoElementFocus(el, binding) {
      var _ref4 = binding.value || {}, _ref4$autoFocusSelect = _ref4.autoFocusSelector, autoFocusSelector = _ref4$autoFocusSelect === void 0 ? "" : _ref4$autoFocusSelect, _ref4$firstFocusableS = _ref4.firstFocusableSelector, firstFocusableSelector = _ref4$firstFocusableS === void 0 ? "" : _ref4$firstFocusableS, _ref4$autoFocus = _ref4.autoFocus, autoFocus2 = _ref4$autoFocus === void 0 ? false : _ref4$autoFocus;
      var focusableElement = getFirstFocusableElement(el, "[autofocus]".concat(this.getComputedSelector(autoFocusSelector)));
      autoFocus2 && !focusableElement && (focusableElement = getFirstFocusableElement(el, this.getComputedSelector(firstFocusableSelector)));
      focus(focusableElement);
    },
    onFirstHiddenElementFocus: function onFirstHiddenElementFocus(event2) {
      var _this$$el;
      var currentTarget = event2.currentTarget, relatedTarget = event2.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_lasthiddenfocusableelement || !((_this$$el = this.$el) !== null && _this$$el !== void 0 && _this$$el.contains(relatedTarget)) ? getFirstFocusableElement(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_lasthiddenfocusableelement;
      focus(focusableElement);
    },
    onLastHiddenElementFocus: function onLastHiddenElementFocus(event2) {
      var _this$$el2;
      var currentTarget = event2.currentTarget, relatedTarget = event2.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_firsthiddenfocusableelement || !((_this$$el2 = this.$el) !== null && _this$$el2 !== void 0 && _this$$el2.contains(relatedTarget)) ? getLastFocusableElement(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_firsthiddenfocusableelement;
      focus(focusableElement);
    },
    createHiddenFocusableElements: function createHiddenFocusableElements(el, binding) {
      var _this2 = this;
      var _ref5 = binding.value || {}, _ref5$tabIndex = _ref5.tabIndex, tabIndex = _ref5$tabIndex === void 0 ? 0 : _ref5$tabIndex, _ref5$firstFocusableS = _ref5.firstFocusableSelector, firstFocusableSelector = _ref5$firstFocusableS === void 0 ? "" : _ref5$firstFocusableS, _ref5$lastFocusableSe = _ref5.lastFocusableSelector, lastFocusableSelector = _ref5$lastFocusableSe === void 0 ? "" : _ref5$lastFocusableSe;
      var createFocusableElement = function createFocusableElement2(onFocus7) {
        return createElement("span", {
          "class": "p-hidden-accessible p-hidden-focusable",
          tabIndex,
          role: "presentation",
          "aria-hidden": true,
          "data-p-hidden-accessible": true,
          "data-p-hidden-focusable": true,
          onFocus: onFocus7 === null || onFocus7 === void 0 ? void 0 : onFocus7.bind(_this2)
        });
      };
      var firstFocusableElement = createFocusableElement(this.onFirstHiddenElementFocus);
      var lastFocusableElement = createFocusableElement(this.onLastHiddenElementFocus);
      firstFocusableElement.$_pfocustrap_lasthiddenfocusableelement = lastFocusableElement;
      firstFocusableElement.$_pfocustrap_focusableselector = firstFocusableSelector;
      firstFocusableElement.setAttribute("data-pc-section", "firstfocusableelement");
      lastFocusableElement.$_pfocustrap_firsthiddenfocusableelement = firstFocusableElement;
      lastFocusableElement.$_pfocustrap_focusableselector = lastFocusableSelector;
      lastFocusableElement.setAttribute("data-pc-section", "lastfocusableelement");
      el.prepend(firstFocusableElement);
      el.append(lastFocusableElement);
    }
  }
});
var theme$a = function theme25(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-dialog {\n    max-height: 90%;\n    transform: scale(1);\n    border-radius: ".concat(dt3("dialog.border.radius"), ";\n    box-shadow: ").concat(dt3("dialog.shadow"), ";\n    background: ").concat(dt3("dialog.background"), ";\n    border: 1px solid ").concat(dt3("dialog.border.color"), ";\n    color: ").concat(dt3("dialog.color"), ";\n}\n\n.p-dialog-content {\n    overflow-y: auto;\n    padding: ").concat(dt3("dialog.content.padding"), ";\n}\n\n.p-dialog-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-shrink: 0;\n    padding: ").concat(dt3("dialog.header.padding"), ";\n}\n\n.p-dialog-title {\n    font-weight: ").concat(dt3("dialog.title.font.weight"), ";\n    font-size: ").concat(dt3("dialog.title.font.size"), ";\n}\n\n.p-dialog-footer {\n    flex-shrink: 0;\n    padding: ").concat(dt3("dialog.footer.padding"), ";\n    display: flex;\n    justify-content: flex-end;\n    gap: ").concat(dt3("dialog.footer.gap"), ";\n}\n\n.p-dialog-header-actions {\n    display: flex;\n    align-items: center;\n    gap: ").concat(dt3("dialog.header.gap"), ";\n}\n.p-dialog-enter-active {\n    transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-dialog-leave-active {\n    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.p-dialog-enter-from,\n.p-dialog-leave-to {\n    opacity: 0;\n    transform: scale(0.7);\n}\n\n.p-dialog-top .p-dialog,\n.p-dialog-bottom .p-dialog,\n.p-dialog-left .p-dialog,\n.p-dialog-right .p-dialog,\n.p-dialog-topleft .p-dialog,\n.p-dialog-topright .p-dialog,\n.p-dialog-bottomleft .p-dialog,\n.p-dialog-bottomright .p-dialog {\n    margin: 0.75rem;\n    transform: translate3d(0px, 0px, 0px);\n}\n\n.p-dialog-top .p-dialog-enter-active,\n.p-dialog-top .p-dialog-leave-active,\n.p-dialog-bottom .p-dialog-enter-active,\n.p-dialog-bottom .p-dialog-leave-active,\n.p-dialog-left .p-dialog-enter-active,\n.p-dialog-left .p-dialog-leave-active,\n.p-dialog-right .p-dialog-enter-active,\n.p-dialog-right .p-dialog-leave-active,\n.p-dialog-topleft .p-dialog-enter-active,\n.p-dialog-topleft .p-dialog-leave-active,\n.p-dialog-topright .p-dialog-enter-active,\n.p-dialog-topright .p-dialog-leave-active,\n.p-dialog-bottomleft .p-dialog-enter-active,\n.p-dialog-bottomleft .p-dialog-leave-active,\n.p-dialog-bottomright .p-dialog-enter-active,\n.p-dialog-bottomright .p-dialog-leave-active {\n    transition: all 0.3s ease-out;\n}\n\n.p-dialog-top .p-dialog-enter-from,\n.p-dialog-top .p-dialog-leave-to {\n    transform: translate3d(0px, -100%, 0px);\n}\n\n.p-dialog-bottom .p-dialog-enter-from,\n.p-dialog-bottom .p-dialog-leave-to {\n    transform: translate3d(0px, 100%, 0px);\n}\n\n.p-dialog-left .p-dialog-enter-from,\n.p-dialog-left .p-dialog-leave-to,\n.p-dialog-topleft .p-dialog-enter-from,\n.p-dialog-topleft .p-dialog-leave-to,\n.p-dialog-bottomleft .p-dialog-enter-from,\n.p-dialog-bottomleft .p-dialog-leave-to {\n    transform: translate3d(-100%, 0px, 0px);\n}\n\n.p-dialog-right .p-dialog-enter-from,\n.p-dialog-right .p-dialog-leave-to,\n.p-dialog-topright .p-dialog-enter-from,\n.p-dialog-topright .p-dialog-leave-to,\n.p-dialog-bottomright .p-dialog-enter-from,\n.p-dialog-bottomright .p-dialog-leave-to {\n    transform: translate3d(100%, 0px, 0px);\n}\n\n.p-dialog-maximized {\n    width: 100vw !important;\n    height: 100vh !important;\n    top: 0px !important;\n    left: 0px !important;\n    max-height: 100%;\n    height: 100%;\n    border-radius: 0;\n}\n\n.p-dialog-maximized .p-dialog-content {\n    flex-grow: 1;\n}\n");
};
var inlineStyles$2 = {
  mask: function mask(_ref2) {
    var position = _ref2.position, modal = _ref2.modal;
    return {
      position: "fixed",
      height: "100%",
      width: "100%",
      left: 0,
      top: 0,
      display: "flex",
      justifyContent: position === "left" || position === "topleft" || position === "bottomleft" ? "flex-start" : position === "right" || position === "topright" || position === "bottomright" ? "flex-end" : "center",
      alignItems: position === "top" || position === "topleft" || position === "topright" ? "flex-start" : position === "bottom" || position === "bottomleft" || position === "bottomright" ? "flex-end" : "center",
      pointerEvents: modal ? "auto" : "none"
    };
  },
  root: {
    display: "flex",
    flexDirection: "column",
    pointerEvents: "auto"
  }
};
var classes$a = {
  mask: function mask2(_ref3) {
    var props = _ref3.props;
    var positions = ["left", "right", "top", "topleft", "topright", "bottom", "bottomleft", "bottomright"];
    var pos2 = positions.find(function(item) {
      return item === props.position;
    });
    return ["p-dialog-mask", {
      "p-overlay-mask p-overlay-mask-enter": props.modal
    }, pos2 ? "p-dialog-".concat(pos2) : ""];
  },
  root: function root18(_ref4) {
    var props = _ref4.props, instance = _ref4.instance;
    return ["p-dialog p-component", {
      "p-dialog-maximized": props.maximizable && instance.maximized
    }];
  },
  header: "p-dialog-header",
  title: "p-dialog-title",
  headerActions: "p-dialog-header-actions",
  pcMaximizeButton: "p-dialog-maximize-button",
  pcCloseButton: "p-dialog-close-button",
  content: "p-dialog-content",
  footer: "p-dialog-footer"
};
var DialogStyle = BaseStyle.extend({
  name: "dialog",
  theme: theme$a,
  classes: classes$a,
  inlineStyles: inlineStyles$2
});
var script$1$b = {
  name: "BaseDialog",
  "extends": script$1a,
  props: {
    header: {
      type: null,
      "default": null
    },
    footer: {
      type: null,
      "default": null
    },
    visible: {
      type: Boolean,
      "default": false
    },
    modal: {
      type: Boolean,
      "default": null
    },
    contentStyle: {
      type: null,
      "default": null
    },
    contentClass: {
      type: String,
      "default": null
    },
    contentProps: {
      type: null,
      "default": null
    },
    maximizable: {
      type: Boolean,
      "default": false
    },
    dismissableMask: {
      type: Boolean,
      "default": false
    },
    closable: {
      type: Boolean,
      "default": true
    },
    closeOnEscape: {
      type: Boolean,
      "default": true
    },
    showHeader: {
      type: Boolean,
      "default": true
    },
    blockScroll: {
      type: Boolean,
      "default": false
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    position: {
      type: String,
      "default": "center"
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    draggable: {
      type: Boolean,
      "default": true
    },
    keepInViewport: {
      type: Boolean,
      "default": true
    },
    minX: {
      type: Number,
      "default": 0
    },
    minY: {
      type: Number,
      "default": 0
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    closeIcon: {
      type: String,
      "default": void 0
    },
    maximizeIcon: {
      type: String,
      "default": void 0
    },
    minimizeIcon: {
      type: String,
      "default": void 0
    },
    closeButtonProps: {
      type: Object,
      "default": function _default2() {
        return {
          severity: "secondary",
          text: true,
          rounded: true
        };
      }
    },
    maximizeButtonProps: {
      type: Object,
      "default": function _default3() {
        return {
          severity: "secondary",
          text: true,
          rounded: true
        };
      }
    },
    _instance: null
  },
  style: DialogStyle,
  provide: function provide27() {
    return {
      $pcDialog: this,
      $parentInstance: this
    };
  }
};
var script$A = {
  name: "Dialog",
  "extends": script$1$b,
  inheritAttrs: false,
  emits: ["update:visible", "show", "hide", "after-hide", "maximize", "unmaximize", "dragend"],
  provide: function provide28() {
    var _this = this;
    return {
      dialogRef: computed(function() {
        return _this._instance;
      })
    };
  },
  data: function data12() {
    return {
      id: this.$attrs.id,
      containerVisible: this.visible,
      maximized: false,
      focusableMax: null,
      focusableClose: null
    };
  },
  watch: {
    "$attrs.id": function $attrsId5(newValue) {
      this.id = newValue || UniqueComponentId();
    }
  },
  documentKeydownListener: null,
  container: null,
  mask: null,
  content: null,
  headerContainer: null,
  footerContainer: null,
  maximizableButton: null,
  closeButton: null,
  styleElement: null,
  dragging: null,
  documentDragListener: null,
  documentDragEndListener: null,
  lastPageX: null,
  lastPageY: null,
  updated: function updated7() {
    if (this.visible) {
      this.containerVisible = this.visible;
    }
  },
  beforeUnmount: function beforeUnmount6() {
    this.unbindDocumentState();
    this.unbindGlobalListeners();
    this.destroyStyle();
    if (this.mask && this.autoZIndex) {
      ZIndex.clear(this.mask);
    }
    this.container = null;
    this.mask = null;
  },
  mounted: function mounted11() {
    this.id = this.id || UniqueComponentId();
    if (this.breakpoints) {
      this.createStyle();
    }
  },
  methods: {
    close: function close2() {
      this.$emit("update:visible", false);
    },
    onBeforeEnter: function onBeforeEnter(el) {
      el.setAttribute(this.attributeSelector, "");
    },
    onEnter: function onEnter() {
      this.$emit("show");
      this.focus();
      this.enableDocumentSettings();
      this.bindGlobalListeners();
      if (this.autoZIndex) {
        ZIndex.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
      }
    },
    onBeforeLeave: function onBeforeLeave() {
      if (this.modal) {
        !this.isUnstyled && addClass(this.mask, "p-overlay-mask-leave");
      }
    },
    onLeave: function onLeave() {
      this.$emit("hide");
      this.focusableClose = null;
      this.focusableMax = null;
    },
    onAfterLeave: function onAfterLeave() {
      if (this.autoZIndex) {
        ZIndex.clear(this.mask);
      }
      this.containerVisible = false;
      this.unbindDocumentState();
      this.unbindGlobalListeners();
      this.$emit("after-hide");
    },
    onMaskClick: function onMaskClick(event2) {
      if (this.dismissableMask && this.modal && this.mask === event2.target) {
        this.close();
      }
    },
    focus: function focus$1() {
      var findFocusableElement = function findFocusableElement2(container) {
        return container && container.querySelector("[autofocus]");
      };
      var focusTarget = this.$slots.footer && findFocusableElement(this.footerContainer);
      if (!focusTarget) {
        focusTarget = this.$slots.header && findFocusableElement(this.headerContainer);
        if (!focusTarget) {
          focusTarget = this.$slots["default"] && findFocusableElement(this.content);
          if (!focusTarget) {
            if (this.maximizable) {
              this.focusableMax = true;
              focusTarget = this.maximizableButton;
            } else {
              this.focusableClose = true;
              focusTarget = this.closeButton;
            }
          }
        }
      }
      if (focusTarget) {
        focus(focusTarget, {
          focusVisible: true
        });
      }
    },
    maximize: function maximize(event2) {
      if (this.maximized) {
        this.maximized = false;
        this.$emit("unmaximize", event2);
      } else {
        this.maximized = true;
        this.$emit("maximize", event2);
      }
      if (!this.modal) {
        this.maximized ? blockBodyScroll() : unblockBodyScroll();
      }
    },
    enableDocumentSettings: function enableDocumentSettings() {
      if (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) {
        blockBodyScroll();
      }
    },
    unbindDocumentState: function unbindDocumentState() {
      if (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) {
        unblockBodyScroll();
      }
    },
    onKeyDown: function onKeyDown4(event2) {
      if (event2.code === "Escape" && this.closeOnEscape) {
        this.close();
      }
    },
    bindDocumentKeyDownListener: function bindDocumentKeyDownListener() {
      if (!this.documentKeydownListener) {
        this.documentKeydownListener = this.onKeyDown.bind(this);
        window.document.addEventListener("keydown", this.documentKeydownListener);
      }
    },
    unbindDocumentKeyDownListener: function unbindDocumentKeyDownListener() {
      if (this.documentKeydownListener) {
        window.document.removeEventListener("keydown", this.documentKeydownListener);
        this.documentKeydownListener = null;
      }
    },
    containerRef: function containerRef(el) {
      this.container = el;
    },
    maskRef: function maskRef(el) {
      this.mask = el;
    },
    contentRef: function contentRef2(el) {
      this.content = el;
    },
    headerContainerRef: function headerContainerRef(el) {
      this.headerContainer = el;
    },
    footerContainerRef: function footerContainerRef(el) {
      this.footerContainer = el;
    },
    maximizableRef: function maximizableRef(el) {
      this.maximizableButton = el ? el.$el : void 0;
    },
    closeButtonRef: function closeButtonRef(el) {
      this.closeButton = el ? el.$el : void 0;
    },
    createStyle: function createStyle() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-dialog[").concat(this.attributeSelector, "] {\n                                width: ").concat(this.breakpoints[breakpoint], " !important;\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    },
    destroyStyle: function destroyStyle() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    },
    initDrag: function initDrag(event2) {
      if (event2.target.closest("div").getAttribute("data-pc-section") === "headeractions") {
        return;
      }
      if (this.draggable) {
        this.dragging = true;
        this.lastPageX = event2.pageX;
        this.lastPageY = event2.pageY;
        this.container.style.margin = "0";
        document.body.setAttribute("data-p-unselectable-text", "true");
        !this.isUnstyled && addStyle(document.body, {
          "user-select": "none"
        });
      }
    },
    bindGlobalListeners: function bindGlobalListeners() {
      if (this.draggable) {
        this.bindDocumentDragListener();
        this.bindDocumentDragEndListener();
      }
      if (this.closeOnEscape && this.closable) {
        this.bindDocumentKeyDownListener();
      }
    },
    unbindGlobalListeners: function unbindGlobalListeners() {
      this.unbindDocumentDragListener();
      this.unbindDocumentDragEndListener();
      this.unbindDocumentKeyDownListener();
    },
    bindDocumentDragListener: function bindDocumentDragListener() {
      var _this2 = this;
      this.documentDragListener = function(event2) {
        if (_this2.dragging) {
          var width2 = getOuterWidth(_this2.container);
          var height = getOuterHeight(_this2.container);
          var deltaX = event2.pageX - _this2.lastPageX;
          var deltaY = event2.pageY - _this2.lastPageY;
          var offset = _this2.container.getBoundingClientRect();
          var leftPos = offset.left + deltaX;
          var topPos = offset.top + deltaY;
          var viewport = getViewport();
          var containerComputedStyle = getComputedStyle(_this2.container);
          var marginLeft = parseFloat(containerComputedStyle.marginLeft);
          var marginTop = parseFloat(containerComputedStyle.marginTop);
          _this2.container.style.position = "fixed";
          if (_this2.keepInViewport) {
            if (leftPos >= _this2.minX && leftPos + width2 < viewport.width) {
              _this2.lastPageX = event2.pageX;
              _this2.container.style.left = leftPos - marginLeft + "px";
            }
            if (topPos >= _this2.minY && topPos + height < viewport.height) {
              _this2.lastPageY = event2.pageY;
              _this2.container.style.top = topPos - marginTop + "px";
            }
          } else {
            _this2.lastPageX = event2.pageX;
            _this2.container.style.left = leftPos - marginLeft + "px";
            _this2.lastPageY = event2.pageY;
            _this2.container.style.top = topPos - marginTop + "px";
          }
        }
      };
      window.document.addEventListener("mousemove", this.documentDragListener);
    },
    unbindDocumentDragListener: function unbindDocumentDragListener() {
      if (this.documentDragListener) {
        window.document.removeEventListener("mousemove", this.documentDragListener);
        this.documentDragListener = null;
      }
    },
    bindDocumentDragEndListener: function bindDocumentDragEndListener() {
      var _this3 = this;
      this.documentDragEndListener = function(event2) {
        if (_this3.dragging) {
          _this3.dragging = false;
          document.body.removeAttribute("data-p-unselectable-text");
          !_this3.isUnstyled && (document.body.style["user-select"] = "");
          _this3.$emit("dragend", event2);
        }
      };
      window.document.addEventListener("mouseup", this.documentDragEndListener);
    },
    unbindDocumentDragEndListener: function unbindDocumentDragEndListener() {
      if (this.documentDragEndListener) {
        window.document.removeEventListener("mouseup", this.documentDragEndListener);
        this.documentDragEndListener = null;
      }
    }
  },
  computed: {
    maximizeIconComponent: function maximizeIconComponent() {
      return this.maximized ? this.minimizeIcon ? "span" : "WindowMinimizeIcon" : this.maximizeIcon ? "span" : "WindowMaximizeIcon";
    },
    ariaLabelledById: function ariaLabelledById() {
      return this.header != null || this.$attrs["aria-labelledby"] !== null ? this.id + "_header" : null;
    },
    closeAriaLabel: function closeAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    },
    attributeSelector: function attributeSelector() {
      return UniqueComponentId();
    }
  },
  directives: {
    ripple: Ripple,
    focustrap: FocusTrap
  },
  components: {
    Button: script$13,
    Portal: script$N,
    WindowMinimizeIcon: script$B,
    WindowMaximizeIcon: script$C,
    TimesIcon: script$O
  }
};
function _typeof$f(o) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$f(o);
}
function ownKeys$f(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$f(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$f(Object(t), true).forEach(function(r2) {
      _defineProperty$e(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$e(e, r, t) {
  return (r = _toPropertyKey$d(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$d(t) {
  var i2 = _toPrimitive$d(t, "string");
  return "symbol" == _typeof$f(i2) ? i2 : i2 + "";
}
function _toPrimitive$d(t, r) {
  if ("object" != _typeof$f(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$f(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var _hoisted_1$A = ["aria-labelledby", "aria-modal"];
var _hoisted_2$t = ["id"];
function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Button = resolveComponent("Button");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [$data.containerVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.maskRef,
        "class": _ctx.cx("mask"),
        style: _ctx.sx("mask", true, {
          position: _ctx.position,
          modal: _ctx.modal
        }),
        onClick: _cache[1] || (_cache[1] = function() {
          return $options.onMaskClick && $options.onMaskClick.apply($options, arguments);
        })
      }, _ctx.ptm("mask")), [createVNode(Transition, mergeProps({
        name: "p-dialog",
        onBeforeEnter: $options.onBeforeEnter,
        onEnter: $options.onEnter,
        onBeforeLeave: $options.onBeforeLeave,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave,
        appear: ""
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [_ctx.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            "class": _ctx.cx("root"),
            style: _ctx.sx("root"),
            role: "dialog",
            "aria-labelledby": $options.ariaLabelledById,
            "aria-modal": _ctx.modal
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            closeCallback: $options.close,
            maximizeCallback: function maximizeCallback(event2) {
              return $options.maximize(event2);
            }
          }) : (openBlock(), createElementBlock(Fragment, {
            key: 1
          }, [_ctx.showHeader ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.headerContainerRef,
            "class": _ctx.cx("header"),
            onMousedown: _cache[0] || (_cache[0] = function() {
              return $options.initDrag && $options.initDrag.apply($options, arguments);
            })
          }, _ctx.ptm("header")), [renderSlot(_ctx.$slots, "header", {
            "class": normalizeClass(_ctx.cx("title"))
          }, function() {
            return [_ctx.header ? (openBlock(), createElementBlock("span", mergeProps({
              key: 0,
              id: $options.ariaLabelledById,
              "class": _ctx.cx("title")
            }, _ctx.ptm("title")), toDisplayString$1(_ctx.header), 17, _hoisted_2$t)) : createCommentVNode("", true)];
          }), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("headerActions")
          }, _ctx.ptm("headerActions")), [_ctx.maximizable ? (openBlock(), createBlock(_component_Button, mergeProps({
            key: 0,
            ref: $options.maximizableRef,
            autofocus: $data.focusableMax,
            "class": _ctx.cx("pcMaximizeButton"),
            onClick: $options.maximize,
            tabindex: _ctx.maximizable ? "0" : "-1",
            unstyled: _ctx.unstyled
          }, _ctx.maximizeButtonProps, {
            pt: _ctx.ptm("pcMaximizeButton"),
            "data-pc-group-section": "headericon"
          }), {
            icon: withCtx(function(slotProps) {
              return [renderSlot(_ctx.$slots, "maximizeicon", {
                maximized: $data.maximized
              }, function() {
                return [(openBlock(), createBlock(resolveDynamicComponent($options.maximizeIconComponent), mergeProps({
                  "class": [slotProps["class"], $data.maximized ? _ctx.minimizeIcon : _ctx.maximizeIcon]
                }, _ctx.ptm("pcMaximizeButton")["icon"]), null, 16, ["class"]))];
              })];
            }),
            _: 3
          }, 16, ["autofocus", "class", "onClick", "tabindex", "unstyled", "pt"])) : createCommentVNode("", true), _ctx.closable ? (openBlock(), createBlock(_component_Button, mergeProps({
            key: 1,
            ref: $options.closeButtonRef,
            autofocus: $data.focusableClose,
            "class": _ctx.cx("pcCloseButton"),
            onClick: $options.close,
            "aria-label": $options.closeAriaLabel,
            unstyled: _ctx.unstyled
          }, _ctx.closeButtonProps, {
            pt: _ctx.ptm("pcCloseButton"),
            "data-pc-group-section": "headericon"
          }), {
            icon: withCtx(function(slotProps) {
              return [renderSlot(_ctx.$slots, "closeicon", {}, function() {
                return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon ? "span" : "TimesIcon"), mergeProps({
                  "class": [_ctx.closeIcon, slotProps["class"]]
                }, _ctx.ptm("pcCloseButton")["icon"]), null, 16, ["class"]))];
              })];
            }),
            _: 3
          }, 16, ["autofocus", "class", "onClick", "aria-label", "unstyled", "pt"])) : createCommentVNode("", true)], 16)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            ref: $options.contentRef,
            "class": [_ctx.cx("content"), _ctx.contentClass],
            style: _ctx.contentStyle
          }, _objectSpread$f(_objectSpread$f({}, _ctx.contentProps), _ctx.ptm("content"))), [renderSlot(_ctx.$slots, "default")], 16), _ctx.footer || _ctx.$slots.footer ? (openBlock(), createElementBlock("div", mergeProps({
            key: 1,
            ref: $options.footerContainerRef,
            "class": _ctx.cx("footer")
          }, _ctx.ptm("footer")), [renderSlot(_ctx.$slots, "footer", {}, function() {
            return [createTextVNode(toDisplayString$1(_ctx.footer), 1)];
          })], 16)) : createCommentVNode("", true)], 64))], 16, _hoisted_1$A)), [[_directive_focustrap, {
            disabled: !_ctx.modal
          }]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onBeforeEnter", "onEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])], 16)) : createCommentVNode("", true)];
    }),
    _: 3
  }, 8, ["appendTo"]);
}
script$A.render = render$z;
var theme$9 = function theme26(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-togglebutton {\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    color: ".concat(dt3("togglebutton.color"), ";\n    background: ").concat(dt3("togglebutton.background"), ";\n    border: 1px solid ").concat(dt3("togglebutton.border.color"), ";\n    padding: ").concat(dt3("togglebutton.padding"), ";\n    font-size: 1rem;\n    font-family: inherit;\n    font-feature-settings: inherit;\n    transition: background ").concat(dt3("togglebutton.transition.duration"), ", color ").concat(dt3("togglebutton.transition.duration"), ", border-color ").concat(dt3("togglebutton.transition.duration"), ",\n        outline-color ").concat(dt3("togglebutton.transition.duration"), ", box-shadow ").concat(dt3("togglebutton.transition.duration"), ";\n    border-radius: ").concat(dt3("togglebutton.border.radius"), ";\n    outline-color: transparent;\n    font-weight: ").concat(dt3("togglebutton.font.weight"), ";\n}\n\n.p-togglebutton-content {\n    position: relative;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    gap: ").concat(dt3("togglebutton.gap"), ';\n}\n\n.p-togglebutton-label,\n.p-togglebutton-icon {\n    position: relative;\n    transition: none;\n}\n\n.p-togglebutton::before {\n    content: "";\n    background: transparent;\n    transition: background ').concat(dt3("togglebutton.transition.duration"), ", color ").concat(dt3("togglebutton.transition.duration"), ", border-color ").concat(dt3("togglebutton.transition.duration"), ",\n            outline-color ").concat(dt3("togglebutton.transition.duration"), ", box-shadow ").concat(dt3("togglebutton.transition.duration"), ";\n    position: absolute;\n    left: ").concat(dt3("togglebutton.content.left"), ";\n    top: ").concat(dt3("togglebutton.content.top"), ";\n    width: calc(100% - calc(2 *  ").concat(dt3("togglebutton.content.left"), "));\n    height: calc(100% - calc(2 *  ").concat(dt3("togglebutton.content.top"), "));\n    border-radius: ").concat(dt3("togglebutton.border.radius"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked::before {\n    background: ").concat(dt3("togglebutton.content.checked.background"), ";\n    box-shadow: ").concat(dt3("togglebutton.content.checked.shadow"), ";\n}\n\n.p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover {\n    background: ").concat(dt3("togglebutton.hover.background"), ";\n    color: ").concat(dt3("togglebutton.hover.color"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked {\n    background: ").concat(dt3("togglebutton.checked.background"), ";\n    border-color: ").concat(dt3("togglebutton.checked.border.color"), ";\n    color: ").concat(dt3("togglebutton.checked.color"), ";\n}\n\n.p-togglebutton:focus-visible {\n    box-shadow: ").concat(dt3("togglebutton.focus.ring.shadow"), ";\n    outline: ").concat(dt3("togglebutton.focus.ring.width"), " ").concat(dt3("togglebutton.focus.ring.style"), " ").concat(dt3("togglebutton.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("togglebutton.focus.ring.offset"), ";\n}\n\n.p-togglebutton.p-invalid {\n    border-color: ").concat(dt3("togglebutton.invalid.border.color"), ";\n}\n\n.p-togglebutton:disabled {\n    opacity: 1;\n    cursor: default;\n    background: ").concat(dt3("togglebutton.disabled.background"), ";\n    border-color: ").concat(dt3("togglebutton.disabled.border.color"), ";\n    color: ").concat(dt3("togglebutton.disabled.color"), ";\n}\n\n.p-togglebutton-icon {\n    color: ").concat(dt3("togglebutton.icon.color"), ";\n}\n\n.p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover .p-togglebutton-icon {\n    color: ").concat(dt3("togglebutton.icon.hover.color"), ";\n}\n\n.p-togglebutton.p-togglebutton-checked .p-togglebutton-icon {\n    color: ").concat(dt3("togglebutton.icon.checked.color"), ";\n}\n\n.p-togglebutton:disabled .p-togglebutton-icon {\n    color: ").concat(dt3("togglebutton.icon.disabled.color"), ";\n}\n");
};
var classes$9 = {
  root: function root19(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-togglebutton p-component", {
      "p-togglebutton-checked": instance.active,
      "p-invalid": props.invalid
    }];
  },
  content: "p-togglebutton-content",
  icon: "p-togglebutton-icon",
  label: "p-togglebutton-label"
};
var ToggleButtonStyle = BaseStyle.extend({
  name: "togglebutton",
  theme: theme$9,
  classes: classes$9
});
var script$1$a = {
  name: "BaseToggleButton",
  "extends": script$1a,
  props: {
    modelValue: Boolean,
    onIcon: String,
    offIcon: String,
    onLabel: {
      type: String,
      "default": "Yes"
    },
    offLabel: {
      type: String,
      "default": "No"
    },
    iconPos: {
      type: String,
      "default": "left"
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: ToggleButtonStyle,
  provide: function provide29() {
    return {
      $pcToggleButton: this,
      $parentInstance: this
    };
  }
};
var script$z = {
  name: "ToggleButton",
  "extends": script$1$a,
  inheritAttrs: false,
  emits: ["update:modelValue", "change"],
  methods: {
    getPTOptions: function getPTOptions8(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          active: this.active,
          disabled: this.disabled
        }
      });
    },
    onChange: function onChange3(event2) {
      if (!this.disabled && !this.readonly) {
        this.$emit("update:modelValue", !this.modelValue);
        this.$emit("change", event2);
      }
    }
  },
  computed: {
    active: function active2() {
      return this.modelValue === true;
    },
    hasLabel: function hasLabel() {
      return isNotEmpty(this.onLabel) && isNotEmpty(this.offLabel);
    },
    label: function label3() {
      return this.hasLabel ? this.modelValue ? this.onLabel : this.offLabel : "&nbsp;";
    }
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$z = ["tabindex", "disabled", "aria-pressed", "data-p-checked", "data-p-disabled"];
function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return withDirectives((openBlock(), createElementBlock("button", mergeProps({
    type: "button",
    "class": _ctx.cx("root"),
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    "aria-pressed": _ctx.modelValue,
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.active,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("span", mergeProps({
    "class": _ctx.cx("content")
  }, $options.getPTOptions("content")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [renderSlot(_ctx.$slots, "icon", {
      value: _ctx.modelValue,
      "class": normalizeClass(_ctx.cx("icon"))
    }, function() {
      return [_ctx.onIcon || _ctx.offIcon ? (openBlock(), createElementBlock("span", mergeProps({
        key: 0,
        "class": [_ctx.cx("icon"), _ctx.modelValue ? _ctx.onIcon : _ctx.offIcon]
      }, $options.getPTOptions("icon")), null, 16)) : createCommentVNode("", true)];
    }), createBaseVNode("span", mergeProps({
      "class": _ctx.cx("label")
    }, $options.getPTOptions("label")), toDisplayString$1($options.label), 17)];
  })], 16)], 16, _hoisted_1$z)), [[_directive_ripple]]);
}
script$z.render = render$y;
var theme$8 = function theme27(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-selectbutton {\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    outline-color: transparent;\n    border-radius: ".concat(dt3("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton .p-togglebutton {\n    border-radius: 0;\n    border-width: 1px 1px 1px 0;\n}\n\n.p-selectbutton .p-togglebutton:focus-visible {\n    position: relative;\n    z-index: 1;\n}\n\n.p-selectbutton .p-togglebutton:first-child {\n    border-left-width: 1px;\n    border-top-left-radius: ").concat(dt3("selectbutton.border.radius"), ";\n    border-bottom-left-radius: ").concat(dt3("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton .p-togglebutton:last-child {\n    border-top-right-radius: ").concat(dt3("selectbutton.border.radius"), ";\n    border-bottom-right-radius: ").concat(dt3("selectbutton.border.radius"), ";\n}\n\n.p-selectbutton.p-invalid {\n    outline: 1px solid ").concat(dt3("selectbutton.invalid.border.color"), ";\n    outline-offset: 0;\n}\n");
};
var classes$8 = {
  root: function root20(_ref2) {
    var props = _ref2.props;
    return ["p-selectbutton p-component", {
      "p-invalid": props.invalid
    }];
  }
};
var SelectButtonStyle = BaseStyle.extend({
  name: "selectbutton",
  theme: theme$8,
  classes: classes$8
});
var script$1$9 = {
  name: "BaseSelectButton",
  "extends": script$1a,
  props: {
    modelValue: null,
    options: Array,
    optionLabel: null,
    optionValue: null,
    optionDisabled: null,
    multiple: Boolean,
    allowEmpty: {
      type: Boolean,
      "default": true
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: Boolean,
    dataKey: null,
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: SelectButtonStyle,
  provide: function provide30() {
    return {
      $pcSelectButton: this,
      $parentInstance: this
    };
  }
};
function _createForOfIteratorHelper$6(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$9(r)) || e) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  } };
}
function _toConsumableArray$7(r) {
  return _arrayWithoutHoles$7(r) || _iterableToArray$7(r) || _unsupportedIterableToArray$9(r) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$9(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$9(r, a) : void 0;
  }
}
function _iterableToArray$7(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$7(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$9(r);
}
function _arrayLikeToArray$9(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$y = {
  name: "SelectButton",
  "extends": script$1$9,
  inheritAttrs: false,
  emits: ["update:modelValue", "change"],
  methods: {
    getOptionLabel: function getOptionLabel4(option4) {
      return this.optionLabel ? resolveFieldData(option4, this.optionLabel) : option4;
    },
    getOptionValue: function getOptionValue5(option4) {
      return this.optionValue ? resolveFieldData(option4, this.optionValue) : option4;
    },
    getOptionRenderKey: function getOptionRenderKey4(option4) {
      return this.dataKey ? resolveFieldData(option4, this.dataKey) : this.getOptionLabel(option4);
    },
    getPTOptions: function getPTOptions9(option4, key) {
      return this.ptm(key, {
        context: {
          active: this.isSelected(option4),
          disabled: this.isOptionDisabled(option4),
          option: option4
        }
      });
    },
    isOptionDisabled: function isOptionDisabled4(option4) {
      return this.optionDisabled ? resolveFieldData(option4, this.optionDisabled) : false;
    },
    onOptionSelect: function onOptionSelect4(event2, option4, index2) {
      var _this = this;
      if (this.disabled || this.isOptionDisabled(option4)) {
        return;
      }
      var selected2 = this.isSelected(option4);
      if (selected2 && !this.allowEmpty) {
        return;
      }
      var optionValue = this.getOptionValue(option4);
      var newValue;
      if (this.multiple) {
        if (selected2) newValue = this.modelValue.filter(function(val) {
          return !equals(val, optionValue, _this.equalityKey);
        });
        else newValue = this.modelValue ? [].concat(_toConsumableArray$7(this.modelValue), [optionValue]) : [optionValue];
      } else {
        newValue = selected2 ? null : optionValue;
      }
      this.focusedIndex = index2;
      this.$emit("update:modelValue", newValue);
      this.$emit("change", {
        event: event2,
        value: newValue
      });
    },
    isSelected: function isSelected4(option4) {
      var selected2 = false;
      var optionValue = this.getOptionValue(option4);
      if (this.multiple) {
        if (this.modelValue) {
          var _iterator = _createForOfIteratorHelper$6(this.modelValue), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var val = _step.value;
              if (equals(val, optionValue, this.equalityKey)) {
                selected2 = true;
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      } else {
        selected2 = equals(this.modelValue, optionValue, this.equalityKey);
      }
      return selected2;
    }
  },
  computed: {
    equalityKey: function equalityKey4() {
      return this.optionValue ? null : this.dataKey;
    }
  },
  directives: {
    ripple: Ripple
  },
  components: {
    ToggleButton: script$z
  }
};
var _hoisted_1$y = ["aria-labelledby"];
function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_ToggleButton = resolveComponent("ToggleButton");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "group",
    "aria-labelledby": _ctx.ariaLabelledby
  }, _ctx.ptmi("root")), [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, function(option4, index2) {
    return openBlock(), createBlock(_component_ToggleButton, {
      key: $options.getOptionRenderKey(option4),
      modelValue: $options.isSelected(option4),
      onLabel: $options.getOptionLabel(option4),
      offLabel: $options.getOptionLabel(option4),
      disabled: _ctx.disabled || $options.isOptionDisabled(option4),
      unstyled: _ctx.unstyled,
      onChange: function onChange12($event) {
        return $options.onOptionSelect($event, option4, index2);
      },
      pt: _ctx.ptm("pcButton")
    }, createSlots({
      _: 2
    }, [_ctx.$slots.option ? {
      name: "default",
      fn: withCtx(function() {
        return [renderSlot(_ctx.$slots, "option", {
          option: option4,
          index: index2
        }, function() {
          return [createBaseVNode("span", mergeProps({
            ref_for: true
          }, _ctx.ptm("pcButton")["label"]), toDisplayString$1($options.getOptionLabel(option4)), 17)];
        })];
      }),
      key: "0"
    } : void 0]), 1032, ["modelValue", "onLabel", "offLabel", "disabled", "unstyled", "onChange", "pt"]);
  }), 128))], 16, _hoisted_1$y);
}
script$y.render = render$x;
const _withScopeId$4 = (n) => (pushScopeId("data-v-071f55e3"), n = n(), popScopeId(), n);
const _hoisted_1$x = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("h3", null, "Add node filter condition", -1));
const _hoisted_2$s = { class: "_dialog-body" };
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "NodeSearchFilter",
  emits: ["addFilter"],
  setup(__props, { emit: __emit }) {
    const visible = ref(false);
    const filters = ref([]);
    const selectedFilter = ref();
    const filterValues = ref([]);
    const selectedFilterValue = ref("");
    onMounted(() => {
      const nodeSearchService = useNodeDefStore().nodeSearchService;
      filters.value = nodeSearchService.nodeFilters;
      selectedFilter.value = nodeSearchService.nodeFilters[0];
    });
    const emit2 = __emit;
    const updateSelectedFilterValue = () => {
      updateFilterValues("");
      if (filterValues.value.includes(selectedFilterValue.value)) {
        return;
      }
      selectedFilterValue.value = filterValues.value[0];
    };
    const updateFilterValues = (query) => {
      filterValues.value = selectedFilter.value.fuseSearch.search(query);
    };
    const submit = () => {
      visible.value = false;
      emit2("addFilter", [
        selectedFilter.value,
        selectedFilterValue.value
      ]);
    };
    const showModal = () => {
      updateSelectedFilterValue();
      visible.value = true;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(script$13), {
          icon: "pi pi-filter",
          severity: "secondary",
          class: "_filter-button",
          onClick: showModal
        }),
        createVNode(unref(script$A), {
          visible: visible.value,
          "onUpdate:visible": _cache[3] || (_cache[3] = ($event) => visible.value = $event),
          class: "_dialog"
        }, {
          header: withCtx(() => [
            _hoisted_1$x
          ]),
          footer: withCtx(() => [
            createVNode(unref(script$13), {
              type: "button",
              label: "Add",
              onClick: submit
            })
          ]),
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_2$s, [
              createVNode(unref(script$y), {
                modelValue: selectedFilter.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedFilter.value = $event),
                options: filters.value,
                allowEmpty: false,
                optionLabel: "name",
                onChange: updateSelectedFilterValue
              }, null, 8, ["modelValue", "options"]),
              createVNode(unref(script$D), {
                modelValue: selectedFilterValue.value,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedFilterValue.value = $event),
                suggestions: filterValues.value,
                "min-length": 0,
                onComplete: _cache[2] || (_cache[2] = (event2) => updateFilterValues(event2.query)),
                completeOnFocus: "",
                forceSelection: "",
                dropdown: ""
              }, null, 8, ["modelValue", "suggestions"])
            ])
          ]),
          _: 1
        }, 8, ["visible"])
      ], 64);
    };
  }
});
const NodeSearchFilter = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-071f55e3"]]);
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "NodeSourceChip",
  props: {
    python_module: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const nodeSource = computed(() => getNodeSource(props.python_module));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script$E), {
        class: normalizeClass(nodeSource.value.className)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString$1(nodeSource.value.displayText), 1)
        ]),
        _: 1
      }, 8, ["class"]);
    };
  }
});
const NodeSourceChip = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-1d7c94e5"]]);
const _withScopeId$3 = (n) => (pushScopeId("data-v-d926c92a"), n = n(), popScopeId(), n);
const _hoisted_1$w = { class: "_sb_node_preview" };
const _hoisted_2$r = { class: "_sb_table" };
const _hoisted_3$6 = { class: "node_header" };
const _hoisted_4$5 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_dot headdot" }, null, -1));
const _hoisted_5$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_preview_badge" }, "PREVIEW", -1));
const _hoisted_6$3 = { class: "_sb_col" };
const _hoisted_7 = { class: "_sb_col" };
const _hoisted_8 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col middle-column" }, null, -1));
const _hoisted_9 = { class: "_sb_col _sb_inherit" };
const _hoisted_10 = { class: "_sb_col" };
const _hoisted_11 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col _sb_arrow" }, "◀", -1));
const _hoisted_12 = { class: "_sb_col" };
const _hoisted_13 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col middle-column" }, null, -1));
const _hoisted_14 = { class: "_sb_col _sb_inherit" };
const _hoisted_15 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "_sb_col _sb_arrow" }, "▶", -1));
const _hoisted_16 = {
  key: 0,
  class: "_sb_description"
};
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "NodePreview",
  props: {
    nodeDef: {
      type: ComfyNodeDefImpl,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const nodeDefStore = useNodeDefStore();
    const nodeDef = props.nodeDef;
    const allInputDefs = nodeDef.input.all;
    const allOutputDefs = nodeDef.output.all;
    const slotInputDefs = allInputDefs.filter(
      (input) => !nodeDefStore.inputIsWidget(input)
    );
    const widgetInputDefs = allInputDefs.filter(
      (input) => nodeDefStore.inputIsWidget(input)
    );
    const truncateDefaultValue = (value3, charLimit = 32) => {
      let stringValue;
      if (typeof value3 === "object" && value3 !== null) {
        stringValue = JSON.stringify(value3);
      } else if (Array.isArray(value3)) {
        stringValue = JSON.stringify(value3);
      } else if (typeof value3 === "string") {
        stringValue = value3;
      } else {
        stringValue = String(value3);
      }
      return _.truncate(stringValue, { length: charLimit });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$w, [
        createBaseVNode("div", _hoisted_2$r, [
          createBaseVNode("div", _hoisted_3$6, [
            _hoisted_4$5,
            createTextVNode(" " + toDisplayString$1(unref(nodeDef).display_name), 1)
          ]),
          _hoisted_5$4,
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(_).zip(unref(slotInputDefs), unref(allOutputDefs)), ([slotInput, slotOutput]) => {
            return openBlock(), createElementBlock("div", {
              class: "_sb_row slot_row",
              key: ((slotInput == null ? void 0 : slotInput.name) || "") + ((slotOutput == null ? void 0 : slotOutput.index.toString()) || "")
            }, [
              createBaseVNode("div", _hoisted_6$3, [
                slotInput ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["_sb_dot", slotInput.type])
                }, null, 2)) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_7, toDisplayString$1(slotInput ? slotInput.name : ""), 1),
              _hoisted_8,
              createBaseVNode("div", _hoisted_9, toDisplayString$1(slotOutput ? slotOutput.name : ""), 1),
              createBaseVNode("div", _hoisted_10, [
                slotOutput ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["_sb_dot", slotOutput.type])
                }, null, 2)) : createCommentVNode("", true)
              ])
            ]);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(widgetInputDefs), (widgetInput) => {
            return openBlock(), createElementBlock("div", {
              class: "_sb_row _long_field",
              key: widgetInput.name
            }, [
              _hoisted_11,
              createBaseVNode("div", _hoisted_12, toDisplayString$1(widgetInput.name), 1),
              _hoisted_13,
              createBaseVNode("div", _hoisted_14, toDisplayString$1(truncateDefaultValue(widgetInput.default)), 1),
              _hoisted_15
            ]);
          }), 128))
        ]),
        unref(nodeDef).description ? (openBlock(), createElementBlock("div", _hoisted_16, toDisplayString$1(unref(nodeDef).description), 1)) : createCommentVNode("", true)
      ]);
    };
  }
});
const NodePreview = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-d926c92a"]]);
const _withScopeId$2 = (n) => (pushScopeId("data-v-9b4aa1b3"), n = n(), popScopeId(), n);
const _hoisted_1$v = { class: "comfy-vue-node-search-container" };
const _hoisted_2$q = {
  key: 0,
  class: "comfy-vue-node-preview-container"
};
const _hoisted_3$5 = { class: "option-container" };
const _hoisted_4$4 = { class: "option-display-name" };
const _hoisted_5$3 = ["innerHTML"];
const _hoisted_6$2 = { class: "option-category" };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "NodeSearchBox",
  props: {
    filters: {
      type: Array
    },
    searchLimit: {
      type: Number,
      default: 64
    }
  },
  emits: ["addFilter", "removeFilter", "addNode"],
  setup(__props, { emit: __emit }) {
    const settingStore = useSettingStore();
    const enableNodePreview = computed(
      () => settingStore.get("Comfy.NodeSearchBoxImpl.NodePreview")
    );
    const props = __props;
    const inputId = `comfy-vue-node-search-box-input-${Math.random()}`;
    const suggestions2 = ref([]);
    const hoveredSuggestion = ref(null);
    const currentQuery = ref("");
    const placeholder = computed(() => {
      return props.filters.length === 0 ? "Search for nodes" : "";
    });
    const search3 = (query) => {
      currentQuery.value = query;
      suggestions2.value = useNodeDefStore().nodeSearchService.searchNode(
        query,
        props.filters,
        {
          limit: props.searchLimit
        }
      );
    };
    const highlightQuery = (text2, query) => {
      if (!query) return text2;
      const regex = new RegExp(`(${query})`, "gi");
      return text2.replace(regex, '<span class="highlight">$1</span>');
    };
    const emit2 = __emit;
    const reFocusInput = () => {
      const inputElement = document.getElementById(inputId);
      if (inputElement) {
        inputElement.blur();
        inputElement.focus();
      }
    };
    onMounted(reFocusInput);
    const onAddFilter = (filterAndValue) => {
      emit2("addFilter", filterAndValue);
      reFocusInput();
    };
    const onRemoveFilter = (event2, filterAndValue) => {
      event2.stopPropagation();
      event2.preventDefault();
      emit2("removeFilter", filterAndValue);
      reFocusInput();
    };
    const setHoverSuggestion = (index2) => {
      if (index2 === -1) {
        hoveredSuggestion.value = null;
        return;
      }
      const value3 = suggestions2.value[index2];
      hoveredSuggestion.value = value3;
    };
    return (_ctx, _cache) => {
      var _a2;
      return openBlock(), createElementBlock("div", _hoisted_1$v, [
        enableNodePreview.value ? (openBlock(), createElementBlock("div", _hoisted_2$q, [
          hoveredSuggestion.value ? (openBlock(), createBlock(NodePreview, {
            nodeDef: hoveredSuggestion.value,
            key: ((_a2 = hoveredSuggestion.value) == null ? void 0 : _a2.name) || ""
          }, null, 8, ["nodeDef"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createVNode(NodeSearchFilter, { onAddFilter }),
        createVNode(_sfc_main$d, {
          "model-value": props.filters,
          class: "comfy-vue-node-search-box",
          scrollHeight: "40vh",
          placeholder: placeholder.value,
          "input-id": inputId,
          "append-to": "self",
          suggestions: suggestions2.value,
          "min-length": 0,
          onComplete: _cache[0] || (_cache[0] = ($event) => search3($event.query)),
          onOptionSelect: _cache[1] || (_cache[1] = ($event) => emit2("addNode", $event.value)),
          onFocusedOptionChanged: _cache[2] || (_cache[2] = ($event) => setHoverSuggestion($event)),
          "complete-on-focus": "",
          "auto-option-focus": "",
          "force-selection": "",
          multiple: ""
        }, {
          option: withCtx(({ option: option4 }) => [
            createBaseVNode("div", _hoisted_3$5, [
              createBaseVNode("div", _hoisted_4$4, [
                createBaseVNode("span", {
                  innerHTML: highlightQuery(option4.display_name, currentQuery.value)
                }, null, 8, _hoisted_5$3),
                option4.python_module !== void 0 ? (openBlock(), createBlock(NodeSourceChip, {
                  key: 0,
                  python_module: option4.python_module
                }, null, 8, ["python_module"])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_6$2, toDisplayString$1(option4.category.replaceAll("/", " > ")), 1)
            ])
          ]),
          chip: withCtx(({ value: value3 }) => [
            createVNode(unref(script$E), {
              removable: "",
              onRemove: ($event) => onRemoveFilter($event, value3)
            }, {
              default: withCtx(() => [
                createVNode(unref(script$17), {
                  size: "small",
                  class: normalizeClass(value3[0].invokeSequence + "-badge")
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString$1(value3[0].invokeSequence.toUpperCase()), 1)
                  ]),
                  _: 2
                }, 1032, ["class"]),
                createTextVNode(" " + toDisplayString$1(value3[1]), 1)
              ]),
              _: 2
            }, 1032, ["onRemove"])
          ]),
          _: 1
        }, 8, ["model-value", "placeholder", "suggestions"])
      ]);
    };
  }
});
const NodeSearchBox = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-9b4aa1b3"]]);
class ConnectingLinkImpl {
  constructor(node3, slot, input, output, pos2) {
    __publicField2(this, "node");
    __publicField2(this, "slot");
    __publicField2(this, "input");
    __publicField2(this, "output");
    __publicField2(this, "pos");
    this.node = node3;
    this.slot = slot;
    this.input = input;
    this.output = output;
    this.pos = pos2;
  }
  static createFromPlainObject(obj) {
    return new ConnectingLinkImpl(
      obj.node,
      obj.slot,
      obj.input,
      obj.output,
      obj.pos
    );
  }
  get type() {
    const result = this.input ? this.input.type : this.output.type;
    return result === -1 ? null : result;
  }
  /**
   * Which slot type is release and need to be reconnected.
   * - 'output' means we need a new node's outputs slot to connect with this link
   */
  get releaseSlotType() {
    return this.output ? "input" : "output";
  }
  connectTo(newNode) {
    const newNodeSlots = this.releaseSlotType === "output" ? newNode.outputs : newNode.inputs;
    const newNodeSlot = newNodeSlots.findIndex(
      (slot) => slot.type === this.type
    );
    if (newNodeSlot === -1) {
      console.warn(
        `Could not find slot with type ${this.type} on node ${newNode.title}. This should never happen`
      );
      return;
    }
    if (this.releaseSlotType === "input") {
      this.node.connect(this.slot, newNode, newNodeSlot);
    } else {
      newNode.connect(newNodeSlot, this.node, this.slot);
    }
  }
}
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "NodeSearchBoxPopover",
  setup(__props) {
    const settingStore = useSettingStore();
    const visible = ref(false);
    const dismissable = ref(true);
    const triggerEvent2 = ref(null);
    const getNewNodeLocation = () => {
      if (triggerEvent2.value === null) {
        return [100, 100];
      }
      const originalEvent = triggerEvent2.value.detail.originalEvent;
      return [originalEvent.canvasX, originalEvent.canvasY];
    };
    const nodeFilters = reactive([]);
    const addFilter = (filter5) => {
      nodeFilters.push(filter5);
    };
    const removeFilter = (filter5) => {
      const index2 = nodeFilters.findIndex((f) => f === filter5);
      if (index2 !== -1) {
        nodeFilters.splice(index2, 1);
      }
    };
    const clearFilters = () => {
      nodeFilters.splice(0, nodeFilters.length);
    };
    const closeDialog = () => {
      visible.value = false;
    };
    const addNode = (nodeDef) => {
      const node3 = app$1.addNodeOnGraph(nodeDef, { pos: getNewNodeLocation() });
      const eventDetail = triggerEvent2.value.detail;
      if (eventDetail.subType === "empty-release") {
        eventDetail.linkReleaseContext.links.forEach((link) => {
          ConnectingLinkImpl.createFromPlainObject(link).connectTo(node3);
        });
      }
      window.setTimeout(() => {
        closeDialog();
      }, 100);
    };
    const linkReleaseTriggerMode = computed(() => {
      return settingStore.get(
        "Comfy.NodeSearchBoxImpl.LinkReleaseTrigger"
      );
    });
    const canvasEventHandler = (e) => {
      const shiftPressed = e.detail.originalEvent.shiftKey;
      if (e.detail.subType === "empty-release") {
        if (linkReleaseTriggerMode.value === LinkReleaseTriggerMode.HOLD_SHIFT && !shiftPressed || linkReleaseTriggerMode.value === LinkReleaseTriggerMode.NOT_HOLD_SHIFT && shiftPressed) {
          return;
        }
        const context = e.detail.linkReleaseContext;
        if (context.links.length === 0) {
          console.warn("Empty release with no links! This should never happen");
          return;
        }
        const firstLink = ConnectingLinkImpl.createFromPlainObject(context.links[0]);
        const filter5 = useNodeDefStore().nodeSearchService.getFilterById(
          firstLink.releaseSlotType
        );
        const dataType = firstLink.type;
        addFilter([filter5, dataType]);
      }
      triggerEvent2.value = e;
      visible.value = true;
      dismissable.value = false;
      setTimeout(() => {
        dismissable.value = true;
      }, 300);
    };
    const handleEscapeKeyPress = (event2) => {
      if (event2.key === "Escape") {
        closeDialog();
      }
    };
    onMounted(() => {
      document.addEventListener("litegraph:canvas", canvasEventHandler);
      document.addEventListener("keydown", handleEscapeKeyPress);
    });
    onUnmounted(() => {
      document.removeEventListener("litegraph:canvas", canvasEventHandler);
      document.removeEventListener("keydown", handleEscapeKeyPress);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(unref(script$A), {
          visible: visible.value,
          "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => visible.value = $event),
          modal: "",
          "dismissable-mask": dismissable.value,
          onHide: clearFilters,
          pt: {
            root: { class: "invisible-dialog-root" },
            mask: { class: "node-search-box-dialog-mask" },
            transition: {
              enterFromClass: "opacity-0 scale-75",
              // 100ms is the duration of the transition in the dialog component
              enterActiveClass: "transition-all duration-100 ease-out",
              leaveActiveClass: "transition-all duration-100 ease-in",
              leaveToClass: "opacity-0 scale-75"
            }
          }
        }, {
          container: withCtx(() => [
            createVNode(NodeSearchBox, {
              filters: nodeFilters,
              onAddFilter: addFilter,
              onRemoveFilter: removeFilter,
              onAddNode: addNode
            }, null, 8, ["filters"])
          ]),
          _: 1
        }, 8, ["visible", "dismissable-mask"])
      ]);
    };
  }
});
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "NodeTooltip",
  setup(__props) {
    let idleTimeout;
    const nodeDefStore = useNodeDefStore();
    const settingStore = useSettingStore();
    const tooltipRef = ref();
    const tooltipText = ref("");
    const left = ref();
    const top = ref();
    const getHoveredWidget = () => {
      const node3 = app$1.canvas.node_over;
      if (!node3.widgets) return;
      const graphPos = app$1.canvas.graph_mouse;
      const x2 = graphPos[0] - node3.pos[0];
      const y2 = graphPos[1] - node3.pos[1];
      for (const w2 of node3.widgets) {
        let widgetWidth, widgetHeight;
        if (w2.computeSize) {
          ;
          [widgetWidth, widgetHeight] = w2.computeSize(node3.size[0]);
        } else {
          widgetWidth = w2.width || node3.size[0];
          widgetHeight = LiteGraph.NODE_WIDGET_HEIGHT;
        }
        if (w2.last_y !== void 0 && x2 >= 6 && x2 <= widgetWidth - 12 && y2 >= w2.last_y && y2 <= w2.last_y + widgetHeight) {
          return w2;
        }
      }
    };
    const hideTooltip = () => tooltipText.value = null;
    const showTooltip = (tooltip) => __async(this, null, function* () {
      if (!tooltip) return;
      left.value = app$1.canvas.mouse[0] + "px";
      top.value = app$1.canvas.mouse[1] + "px";
      tooltipText.value = tooltip;
      yield nextTick();
      const rect = tooltipRef.value.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        left.value = app$1.canvas.mouse[0] - rect.width + "px";
      }
      if (rect.top < 0) {
        top.value = app$1.canvas.mouse[1] + rect.height + "px";
      }
    });
    const onIdle = () => {
      var _a2, _b, _c, _d, _e;
      const { canvas } = app$1;
      const node3 = canvas.node_over;
      if (!node3) return;
      const ctor = node3.constructor;
      const nodeDef = nodeDefStore.nodeDefsByName[node3.type];
      if (ctor.title_mode !== LiteGraph.NO_TITLE && canvas.graph_mouse[1] < node3.pos[1]) {
        return showTooltip(nodeDef.description);
      }
      if ((_a2 = node3.flags) == null ? void 0 : _a2.collapsed) return;
      const inputSlot = canvas.isOverNodeInput(
        node3,
        canvas.graph_mouse[0],
        canvas.graph_mouse[1],
        [0, 0]
      );
      if (inputSlot !== -1) {
        const inputName = node3.inputs[inputSlot].name;
        return showTooltip((_b = nodeDef.input.getInput(inputName)) == null ? void 0 : _b.tooltip);
      }
      const outputSlot = canvas.isOverNodeOutput(
        node3,
        canvas.graph_mouse[0],
        canvas.graph_mouse[1],
        [0, 0]
      );
      if (outputSlot !== -1) {
        return showTooltip((_c = nodeDef.output.all) == null ? void 0 : _c[outputSlot].tooltip);
      }
      const widget = getHoveredWidget();
      if (widget && !widget.element) {
        return showTooltip(
          (_e = widget.tooltip) != null ? _e : (_d = nodeDef.input.getInput(widget.name)) == null ? void 0 : _d.tooltip
        );
      }
    };
    const onMouseMove = (e) => {
      hideTooltip();
      clearTimeout(idleTimeout);
      if (e.target.nodeName !== "CANVAS") return;
      idleTimeout = window.setTimeout(onIdle, 500);
    };
    watch(
      () => settingStore.get("Comfy.EnableTooltips"),
      (enabled) => {
        if (enabled) {
          window.addEventListener("mousemove", onMouseMove);
          window.addEventListener("click", hideTooltip);
        } else {
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("click", hideTooltip);
        }
      },
      { immediate: true }
    );
    onBeforeUnmount(() => {
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("click", hideTooltip);
    });
    return (_ctx, _cache) => {
      return tooltipText.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref_key: "tooltipRef",
        ref: tooltipRef,
        class: "node-tooltip",
        style: normalizeStyle({ left: left.value, top: top.value })
      }, toDisplayString$1(tooltipText.value), 5)) : createCommentVNode("", true);
    };
  }
});
const NodeTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-d6edb6a0"]]);
function _arrayWithHoles$2(r) {
  if (Array.isArray(r)) return r;
}
function _iterableToArrayLimit$2(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayLikeToArray$8(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _unsupportedIterableToArray$8(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$8(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$8(r, a) : void 0;
  }
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray$2(r, e) {
  return _arrayWithHoles$2(r) || _iterableToArrayLimit$2(r, e) || _unsupportedIterableToArray$8(r, e) || _nonIterableRest$2();
}
var dist = {};
var bind$1 = {};
"use strict";
Object.defineProperty(bind$1, "__esModule", { value: true });
var bind_2 = bind$1.bind = void 0;
function bind(target, _a2) {
  var type = _a2.type, listener = _a2.listener, options3 = _a2.options;
  target.addEventListener(type, listener, options3);
  return function unbind2() {
    target.removeEventListener(type, listener, options3);
  };
}
bind_2 = bind$1.bind = bind;
var bindAll$1 = {};
"use strict";
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2))
        t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(bindAll$1, "__esModule", { value: true });
var bindAll_2 = bindAll$1.bindAll = void 0;
var bind_1 = bind$1;
function toOptions(value3) {
  if (typeof value3 === "undefined") {
    return void 0;
  }
  if (typeof value3 === "boolean") {
    return {
      capture: value3
    };
  }
  return value3;
}
function getBinding(original, sharedOptions) {
  if (sharedOptions == null) {
    return original;
  }
  var binding = __assign(__assign({}, original), { options: __assign(__assign({}, toOptions(sharedOptions)), toOptions(original.options)) });
  return binding;
}
function bindAll(target, bindings, sharedOptions) {
  var unbinds = bindings.map(function(original) {
    var binding = getBinding(original, sharedOptions);
    return (0, bind_1.bind)(target, binding);
  });
  return function unbindAll() {
    unbinds.forEach(function(unbind2) {
      return unbind2();
    });
  };
}
bindAll_2 = bindAll$1.bindAll = bindAll;
(function(exports) {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindAll = exports.bind = void 0;
  var bind_12 = bind$1;
  Object.defineProperty(exports, "bind", { enumerable: true, get: function() {
    return bind_12.bind;
  } });
  var bind_all_1 = bindAll$1;
  Object.defineProperty(exports, "bindAll", { enumerable: true, get: function() {
    return bind_all_1.bindAll;
  } });
})(dist);
const index = /* @__PURE__ */ getDefaultExportFromCjs(dist);
var honeyPotDataAttribute = "data-pdnd-honey-pot";
function isHoneyPotElement(target) {
  return target instanceof Element && target.hasAttribute(honeyPotDataAttribute);
}
function getElementFromPointWithoutHoneypot(client) {
  var _document$elementsFro = document.elementsFromPoint(client.x, client.y), _document$elementsFro2 = _slicedToArray$2(_document$elementsFro, 2), top = _document$elementsFro2[0], second = _document$elementsFro2[1];
  if (!top) {
    return null;
  }
  if (isHoneyPotElement(top)) {
    return second !== null && second !== void 0 ? second : null;
  }
  return top;
}
function _typeof$e(o) {
  "@babel/helpers - typeof";
  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$e(o);
}
function toPrimitive(t, r) {
  if ("object" != _typeof$e(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$e(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i2 = toPrimitive(t, "string");
  return "symbol" == _typeof$e(i2) ? i2 : i2 + "";
}
function _defineProperty$d(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
var maxZIndex = 2147483647;
function ownKeys$e(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$e(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$e(Object(t), true).forEach(function(r2) {
      _defineProperty$d(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var honeyPotSize = 2;
var halfHoneyPotSize = honeyPotSize / 2;
function floorToClosestPixel(point) {
  return {
    x: Math.floor(point.x),
    y: Math.floor(point.y)
  };
}
function pullBackByHalfHoneyPotSize(point) {
  return {
    x: point.x - halfHoneyPotSize,
    y: point.y - halfHoneyPotSize
  };
}
function preventGoingBackwardsOffScreen(point) {
  return {
    x: Math.max(point.x, 0),
    y: Math.max(point.y, 0)
  };
}
function preventGoingForwardsOffScreen(point) {
  return {
    x: Math.min(point.x, window.innerWidth - honeyPotSize),
    y: Math.min(point.y, window.innerHeight - honeyPotSize)
  };
}
function getHoneyPotRectFor(_ref) {
  var client = _ref.client;
  var point = preventGoingForwardsOffScreen(preventGoingBackwardsOffScreen(pullBackByHalfHoneyPotSize(floorToClosestPixel(client))));
  return DOMRect.fromRect({
    x: point.x,
    y: point.y,
    width: honeyPotSize,
    height: honeyPotSize
  });
}
function getRectStyles(_ref2) {
  var clientRect = _ref2.clientRect;
  return {
    left: "".concat(clientRect.left, "px"),
    top: "".concat(clientRect.top, "px"),
    width: "".concat(clientRect.width, "px"),
    height: "".concat(clientRect.height, "px")
  };
}
function isWithin(_ref3) {
  var client = _ref3.client, clientRect = _ref3.clientRect;
  return (
    // is within horizontal bounds
    client.x >= clientRect.x && client.x <= clientRect.x + clientRect.width && // is within vertical bounds
    client.y >= clientRect.y && client.y <= clientRect.y + clientRect.height
  );
}
function mountHoneyPot(_ref4) {
  var initial = _ref4.initial;
  var element = document.createElement("div");
  element.setAttribute(honeyPotDataAttribute, "true");
  var clientRect = getHoneyPotRectFor({
    client: initial
  });
  Object.assign(element.style, _objectSpread$e(_objectSpread$e({
    // Setting a background color explicitly to avoid any inherited styles.
    // Looks like this could be `opacity: 0`, but worried that _might_
    // cause the element to be ignored on some platforms.
    // When debugging, set backgroundColor to something like "red".
    backgroundColor: "transparent",
    position: "fixed",
    // Being explicit to avoid inheriting styles
    padding: 0,
    margin: 0,
    boxSizing: "border-box"
  }, getRectStyles({
    clientRect
  })), {}, {
    // We want this element to absorb pointer events,
    // it's kind of the whole point 😉
    pointerEvents: "auto",
    // Want to make sure the honey pot is top of everything else.
    // Don't need to worry about native drag previews, as they will
    // have been rendered (and removed) before the honey pot is rendered
    zIndex: maxZIndex
  }));
  document.body.appendChild(element);
  var unbindPointerMove = dist.bind(window, {
    type: "pointermove",
    listener: function listener(event2) {
      var client = {
        x: event2.clientX,
        y: event2.clientY
      };
      clientRect = getHoneyPotRectFor({
        client
      });
      Object.assign(element.style, getRectStyles({
        clientRect
      }));
    },
    // using capture so we are less likely to be impacted by event stopping
    options: {
      capture: true
    }
  });
  return function finish(_ref5) {
    var current = _ref5.current;
    unbindPointerMove();
    if (isWithin({
      client: current,
      clientRect
    })) {
      element.remove();
      return;
    }
    function cleanup() {
      unbindPostDragEvents();
      element.remove();
    }
    var unbindPostDragEvents = dist.bindAll(window, [
      {
        type: "pointerdown",
        listener: cleanup
      },
      {
        type: "pointermove",
        listener: cleanup
      },
      {
        type: "focusin",
        listener: cleanup
      },
      {
        type: "focusout",
        listener: cleanup
      },
      // a 'pointerdown' should happen before 'dragstart', but just being super safe
      {
        type: "dragstart",
        listener: cleanup
      },
      // if the user has dragged something out of the window
      // and then is dragging something back into the window
      // the first events we will see are "dragenter" (and then "dragover").
      // So if we see any of these we need to clear the post drag fix.
      {
        type: "dragenter",
        listener: cleanup
      },
      {
        type: "dragover",
        listener: cleanup
      }
      // Not adding a "wheel" event listener, as "wheel" by itself does not
      // resolve the bug.
    ], {
      // Using `capture` so less likely to be impacted by other code stopping events
      capture: true
    });
  };
}
function makeHoneyPotFix() {
  var latestPointerMove = null;
  function bindEvents3() {
    latestPointerMove = null;
    return dist.bind(window, {
      type: "pointermove",
      listener: function listener(event2) {
        latestPointerMove = {
          x: event2.clientX,
          y: event2.clientY
        };
      },
      // listening for pointer move in capture phase
      // so we are less likely to be impacted by events being stopped.
      options: {
        capture: true
      }
    });
  }
  function getOnPostDispatch() {
    var finish = null;
    return function onPostEvent(_ref6) {
      var eventName = _ref6.eventName, payload = _ref6.payload;
      if (eventName === "onDragStart") {
        var _latestPointerMove;
        var input = payload.location.initial.input;
        var initial = (_latestPointerMove = latestPointerMove) !== null && _latestPointerMove !== void 0 ? _latestPointerMove : {
          x: input.clientX,
          y: input.clientY
        };
        finish = mountHoneyPot({
          initial
        });
      }
      if (eventName === "onDrop") {
        var _finish;
        var _input = payload.location.current.input;
        (_finish = finish) === null || _finish === void 0 || _finish({
          current: {
            x: _input.clientX,
            y: _input.clientY
          }
        });
        finish = null;
        latestPointerMove = null;
      }
    };
  }
  return {
    bindEvents: bindEvents3,
    getOnPostDispatch
  };
}
function _arrayWithoutHoles$6(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$8(r);
}
function _iterableToArray$6(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray$6(r) {
  return _arrayWithoutHoles$6(r) || _iterableToArray$6(r) || _unsupportedIterableToArray$8(r) || _nonIterableSpread$6();
}
function once(fn) {
  var cache2 = null;
  return function wrapped() {
    if (!cache2) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var result = fn.apply(this, args);
      cache2 = {
        result
      };
    }
    return cache2.result;
  };
}
var isFirefox = once(function isFirefox2() {
  if (false) {
    return false;
  }
  return navigator.userAgent.includes("Firefox");
});
var isSafari = once(function isSafari2() {
  if (false) {
    return false;
  }
  var _navigator2 = navigator, userAgent = _navigator2.userAgent;
  return userAgent.includes("AppleWebKit") && !userAgent.includes("Chrome");
});
var symbols = {
  isLeavingWindow: Symbol("leaving"),
  isEnteringWindow: Symbol("entering")
};
function isEnteringWindowInSafari(_ref) {
  var dragEnter = _ref.dragEnter;
  if (!isSafari()) {
    return false;
  }
  return dragEnter.hasOwnProperty(symbols.isEnteringWindow);
}
function isLeavingWindowInSafari(_ref2) {
  var dragLeave = _ref2.dragLeave;
  if (!isSafari()) {
    return false;
  }
  return dragLeave.hasOwnProperty(symbols.isLeavingWindow);
}
(function fixSafari() {
  if (typeof window === "undefined") {
    return;
  }
  if (false) {
    return;
  }
  if (!isSafari()) {
    return;
  }
  function getInitialState() {
    return {
      enterCount: 0,
      isOverWindow: false
    };
  }
  var state = getInitialState();
  function resetState() {
    state = getInitialState();
  }
  dist.bindAll(
    window,
    [{
      type: "dragstart",
      listener: function listener() {
        state.enterCount = 0;
        state.isOverWindow = true;
      }
    }, {
      type: "drop",
      listener: resetState
    }, {
      type: "dragend",
      listener: resetState
    }, {
      type: "dragenter",
      listener: function listener(event2) {
        if (!state.isOverWindow && state.enterCount === 0) {
          event2[symbols.isEnteringWindow] = true;
        }
        state.isOverWindow = true;
        state.enterCount++;
      }
    }, {
      type: "dragleave",
      listener: function listener(event2) {
        state.enterCount--;
        if (state.isOverWindow && state.enterCount === 0) {
          event2[symbols.isLeavingWindow] = true;
          state.isOverWindow = false;
        }
      }
    }],
    // using `capture: true` so that adding event listeners
    // in bubble phase will have the correct symbols
    {
      capture: true
    }
  );
})();
function isNodeLike(target) {
  return "nodeName" in target;
}
function isFromAnotherWindow(eventTarget) {
  return isNodeLike(eventTarget) && eventTarget.ownerDocument !== document;
}
function isLeavingWindow(_ref) {
  var dragLeave = _ref.dragLeave;
  var type = dragLeave.type, relatedTarget = dragLeave.relatedTarget;
  if (type !== "dragleave") {
    return false;
  }
  if (isSafari()) {
    return isLeavingWindowInSafari({
      dragLeave
    });
  }
  if (relatedTarget == null) {
    return true;
  }
  if (isFirefox()) {
    return isFromAnotherWindow(relatedTarget);
  }
  return relatedTarget instanceof HTMLIFrameElement;
}
function getBindingsForBrokenDrags(_ref) {
  var onDragEnd2 = _ref.onDragEnd;
  return [
    // ## Detecting drag ending for removed draggables
    //
    // If a draggable element is removed during a drag and the user drops:
    // 1. if over a valid drop target: we get a "drop" event to know the drag is finished
    // 2. if not over a valid drop target (or cancelled): we get nothing
    // The "dragend" event will not fire on the source draggable if it has been
    // removed from the DOM.
    // So we need to figure out if a drag operation has finished by looking at other events
    // We can do this by looking at other events
    // ### First detection: "pointermove" events
    // 1. "pointermove" events cannot fire during a drag and drop operation
    // according to the spec. So if we get a "pointermove" it means that
    // the drag and drop operations has finished. So if we get a "pointermove"
    // we know that the drag is over
    // 2. 🦊😤 Drag and drop operations are _supposed_ to suppress
    // other pointer events. However, firefox will allow a few
    // pointer event to get through after a drag starts.
    // The most I've seen is 3
    {
      type: "pointermove",
      listener: /* @__PURE__ */ function() {
        var callCount = 0;
        return function listener() {
          if (callCount < 20) {
            callCount++;
            return;
          }
          onDragEnd2();
        };
      }()
    },
    // ### Second detection: "pointerdown" events
    // If we receive this event then we know that a drag operation has finished
    // and potentially another one is about to start.
    // Note: `pointerdown` fires on all browsers / platforms before "dragstart"
    {
      type: "pointerdown",
      listener: onDragEnd2
    }
  ];
}
function getInput(event2) {
  return {
    altKey: event2.altKey,
    button: event2.button,
    buttons: event2.buttons,
    ctrlKey: event2.ctrlKey,
    metaKey: event2.metaKey,
    shiftKey: event2.shiftKey,
    clientX: event2.clientX,
    clientY: event2.clientY,
    pageX: event2.pageX,
    pageY: event2.pageY
  };
}
var rafSchd = function rafSchd2(fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
var scheduleOnDrag = rafSchd(function(fn) {
  return fn();
});
var dragStart = /* @__PURE__ */ function() {
  var scheduled = null;
  function schedule(fn) {
    var frameId = requestAnimationFrame(function() {
      scheduled = null;
      fn();
    });
    scheduled = {
      frameId,
      fn
    };
  }
  function flush() {
    if (scheduled) {
      cancelAnimationFrame(scheduled.frameId);
      scheduled.fn();
      scheduled = null;
    }
  }
  return {
    schedule,
    flush
  };
}();
function makeDispatch(_ref) {
  var source = _ref.source, initial = _ref.initial, dispatchEvent = _ref.dispatchEvent;
  var previous = {
    dropTargets: []
  };
  function safeDispatch(args) {
    dispatchEvent(args);
    previous = {
      dropTargets: args.payload.location.current.dropTargets
    };
  }
  var dispatch = {
    start: function start2(_ref2) {
      var nativeSetDragImage = _ref2.nativeSetDragImage;
      var location2 = {
        current: initial,
        previous,
        initial
      };
      safeDispatch({
        eventName: "onGenerateDragPreview",
        payload: {
          source,
          location: location2,
          nativeSetDragImage
        }
      });
      dragStart.schedule(function() {
        safeDispatch({
          eventName: "onDragStart",
          payload: {
            source,
            location: location2
          }
        });
      });
    },
    dragUpdate: function dragUpdate(_ref3) {
      var current = _ref3.current;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDropTargetChange",
        payload: {
          source,
          location: {
            initial,
            previous,
            current
          }
        }
      });
    },
    drag: function drag(_ref4) {
      var current = _ref4.current;
      scheduleOnDrag(function() {
        dragStart.flush();
        var location2 = {
          initial,
          previous,
          current
        };
        safeDispatch({
          eventName: "onDrag",
          payload: {
            source,
            location: location2
          }
        });
      });
    },
    drop: function drop(_ref5) {
      var current = _ref5.current, updatedSourcePayload = _ref5.updatedSourcePayload;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDrop",
        payload: {
          source: updatedSourcePayload !== null && updatedSourcePayload !== void 0 ? updatedSourcePayload : source,
          location: {
            current,
            previous,
            initial
          }
        }
      });
    }
  };
  return dispatch;
}
var globalState = {
  isActive: false
};
function canStart() {
  return !globalState.isActive;
}
function getNativeSetDragImage(event2) {
  if (event2.dataTransfer) {
    return event2.dataTransfer.setDragImage.bind(event2.dataTransfer);
  }
  return null;
}
function hasHierarchyChanged(_ref) {
  var current = _ref.current, next2 = _ref.next;
  if (current.length !== next2.length) {
    return true;
  }
  for (var i2 = 0; i2 < current.length; i2++) {
    if (current[i2].element !== next2[i2].element) {
      return true;
    }
  }
  return false;
}
function start(_ref2) {
  var event2 = _ref2.event, dragType = _ref2.dragType, getDropTargetsOver = _ref2.getDropTargetsOver, dispatchEvent = _ref2.dispatchEvent;
  if (!canStart()) {
    return;
  }
  var initial = getStartLocation({
    event: event2,
    dragType,
    getDropTargetsOver
  });
  globalState.isActive = true;
  var state = {
    current: initial
  };
  setDropEffectOnEvent({
    event: event2,
    current: initial.dropTargets
  });
  var dispatch = makeDispatch({
    source: dragType.payload,
    dispatchEvent,
    initial
  });
  function updateState(next2) {
    var hasChanged2 = hasHierarchyChanged({
      current: state.current.dropTargets,
      next: next2.dropTargets
    });
    state.current = next2;
    if (hasChanged2) {
      dispatch.dragUpdate({
        current: state.current
      });
    }
  }
  function onUpdateEvent(event3) {
    var input = getInput(event3);
    var target = isHoneyPotElement(event3.target) ? getElementFromPointWithoutHoneypot({
      x: input.clientX,
      y: input.clientY
    }) : event3.target;
    var nextDropTargets = getDropTargetsOver({
      target,
      input,
      source: dragType.payload,
      current: state.current.dropTargets
    });
    if (nextDropTargets.length) {
      event3.preventDefault();
      setDropEffectOnEvent({
        event: event3,
        current: nextDropTargets
      });
    }
    updateState({
      dropTargets: nextDropTargets,
      input
    });
  }
  function cancel() {
    if (state.current.dropTargets.length) {
      updateState({
        dropTargets: [],
        input: state.current.input
      });
    }
    dispatch.drop({
      current: state.current,
      updatedSourcePayload: null
    });
    finish();
  }
  function finish() {
    globalState.isActive = false;
    unbindEvents3();
  }
  var unbindEvents3 = dist.bindAll(
    window,
    [{
      // 👋 Note: we are repurposing the `dragover` event as our `drag` event
      // this is because firefox does not publish pointer coordinates during
      // a `drag` event, but does for every other type of drag event
      // `dragover` fires on all elements that are being dragged over
      // Because we are binding to `window` - our `dragover` is effectively the same as a `drag`
      // 🦊😤
      type: "dragover",
      listener: function listener(event3) {
        onUpdateEvent(event3);
        dispatch.drag({
          current: state.current
        });
      }
    }, {
      type: "dragenter",
      listener: onUpdateEvent
    }, {
      type: "dragleave",
      listener: function listener(event3) {
        if (!isLeavingWindow({
          dragLeave: event3
        })) {
          return;
        }
        updateState({
          input: state.current.input,
          dropTargets: []
        });
        if (dragType.startedFrom === "external") {
          cancel();
        }
      }
    }, {
      // A "drop" can only happen if the browser allowed the drop
      type: "drop",
      listener: function listener(event3) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event3)
        };
        if (!state.current.dropTargets.length) {
          cancel();
          return;
        }
        event3.preventDefault();
        setDropEffectOnEvent({
          event: event3,
          current: state.current.dropTargets
        });
        dispatch.drop({
          current: state.current,
          // When dropping something native, we need to extract the latest
          // `.items` from the "drop" event as it is now accessible
          updatedSourcePayload: dragType.type === "external" ? dragType.getDropPayload(event3) : null
        });
        finish();
      }
    }, {
      // "dragend" fires when on the drag source (eg a draggable element)
      // when the drag is finished.
      // "dragend" will fire after "drop" (if there was a successful drop)
      // "dragend" does not fire if the draggable source has been removed during the drag
      // or for external drag sources (eg files)
      // This "dragend" listener will not fire if there was a successful drop
      // as we will have already removed the event listener
      type: "dragend",
      listener: function listener(event3) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event3)
        };
        cancel();
      }
    }].concat(_toConsumableArray$6(getBindingsForBrokenDrags({
      onDragEnd: cancel
    }))),
    // Once we have started a managed drag operation it is important that we see / own all drag events
    // We got one adoption bug pop up where some code was stopping (`event.stopPropagation()`)
    // all "drop" events in the bubble phase on the `document.body`.
    // This meant that we never saw the "drop" event.
    {
      capture: true
    }
  );
  dispatch.start({
    nativeSetDragImage: getNativeSetDragImage(event2)
  });
}
function setDropEffectOnEvent(_ref3) {
  var _current$;
  var event2 = _ref3.event, current = _ref3.current;
  var innerMost = (_current$ = current[0]) === null || _current$ === void 0 ? void 0 : _current$.dropEffect;
  if (innerMost != null && event2.dataTransfer) {
    event2.dataTransfer.dropEffect = innerMost;
  }
}
function getStartLocation(_ref4) {
  var event2 = _ref4.event, dragType = _ref4.dragType, getDropTargetsOver = _ref4.getDropTargetsOver;
  var input = getInput(event2);
  if (dragType.startedFrom === "external") {
    return {
      input,
      dropTargets: []
    };
  }
  var dropTargets = getDropTargetsOver({
    input,
    source: dragType.payload,
    target: event2.target,
    current: []
  });
  return {
    input,
    dropTargets
  };
}
var lifecycle = {
  canStart,
  start
};
var ledger = /* @__PURE__ */ new Map();
function registerUsage(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount;
  var entry = ledger.get(typeKey);
  if (entry) {
    entry.usageCount++;
    return entry;
  }
  var initial = {
    typeKey,
    unmount: mount2(),
    usageCount: 1
  };
  ledger.set(typeKey, initial);
  return initial;
}
function register(args) {
  var entry = registerUsage(args);
  return function unregister() {
    entry.usageCount--;
    if (entry.usageCount > 0) {
      return;
    }
    entry.unmount();
    ledger.delete(args.typeKey);
  };
}
function combine() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function cleanup() {
    fns.forEach(function(fn) {
      return fn();
    });
  };
}
function addAttribute(element, _ref) {
  var attribute = _ref.attribute, value3 = _ref.value;
  element.setAttribute(attribute, value3);
  return function() {
    return element.removeAttribute(attribute);
  };
}
function ownKeys$d(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$d(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$d(Object(t), true).forEach(function(r2) {
      _defineProperty$d(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _createForOfIteratorHelper$5(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function copyReverse(array) {
  return array.slice(0).reverse();
}
function makeDropTarget(_ref) {
  var typeKey = _ref.typeKey, defaultDropEffect = _ref.defaultDropEffect;
  var registry = /* @__PURE__ */ new WeakMap();
  var dropTargetDataAtt = "data-drop-target-for-".concat(typeKey);
  var dropTargetSelector = "[".concat(dropTargetDataAtt, "]");
  function addToRegistry2(args) {
    registry.set(args.element, args);
    return function() {
      return registry.delete(args.element);
    };
  }
  function dropTargetForConsumers(args) {
    if (false) {
      var existing = registry.get(args.element);
      if (existing) {
        console.warn("You have already registered a [".concat(typeKey, "] dropTarget on the same element"), {
          existing,
          proposed: args
        });
      }
      if (args.element instanceof HTMLIFrameElement) {
        console.warn("\n            We recommend not registering <iframe> elements as drop targets\n            as it can result in some strange browser event ordering.\n          ".replace(/\s{2,}/g, " ").trim());
      }
    }
    return combine(addAttribute(args.element, {
      attribute: dropTargetDataAtt,
      value: "true"
    }), addToRegistry2(args));
  }
  function getActualDropTargets(_ref2) {
    var _args$getData, _args$getData2, _args$getDropEffect, _args$getDropEffect2;
    var source = _ref2.source, target = _ref2.target, input = _ref2.input, _ref2$result = _ref2.result, result = _ref2$result === void 0 ? [] : _ref2$result;
    if (target == null) {
      return result;
    }
    if (!(target instanceof Element)) {
      if (target instanceof Node) {
        return getActualDropTargets({
          source,
          target: target.parentElement,
          input,
          result
        });
      }
      return result;
    }
    var closest = target.closest(dropTargetSelector);
    if (closest == null) {
      return result;
    }
    var args = registry.get(closest);
    if (args == null) {
      return result;
    }
    var feedback = {
      input,
      source,
      element: args.element
    };
    if (args.canDrop && !args.canDrop(feedback)) {
      return getActualDropTargets({
        source,
        target: args.element.parentElement,
        input,
        result
      });
    }
    var data28 = (_args$getData = (_args$getData2 = args.getData) === null || _args$getData2 === void 0 ? void 0 : _args$getData2.call(args, feedback)) !== null && _args$getData !== void 0 ? _args$getData : {};
    var dropEffect = (_args$getDropEffect = (_args$getDropEffect2 = args.getDropEffect) === null || _args$getDropEffect2 === void 0 ? void 0 : _args$getDropEffect2.call(args, feedback)) !== null && _args$getDropEffect !== void 0 ? _args$getDropEffect : defaultDropEffect;
    var record = {
      data: data28,
      element: args.element,
      dropEffect,
      // we are collecting _actual_ drop targets, so these are
      // being applied _not_ due to stickiness
      isActiveDueToStickiness: false
    };
    return getActualDropTargets({
      source,
      target: args.element.parentElement,
      input,
      // Using bubble ordering. Same ordering as `event.getPath()`
      result: [].concat(_toConsumableArray$6(result), [record])
    });
  }
  function notifyCurrent(_ref3) {
    var eventName = _ref3.eventName, payload = _ref3.payload;
    var _iterator = _createForOfIteratorHelper$5(payload.location.current.dropTargets), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _entry$eventName;
        var record = _step.value;
        var entry = registry.get(record.element);
        var _args = _objectSpread$d(_objectSpread$d({}, payload), {}, {
          self: record
        });
        entry === null || entry === void 0 || (_entry$eventName = entry[eventName]) === null || _entry$eventName === void 0 || _entry$eventName.call(
          entry,
          // I cannot seem to get the types right here.
          // TS doesn't seem to like that one event can need `nativeSetDragImage`
          // @ts-expect-error
          _args
        );
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  var actions = {
    onGenerateDragPreview: notifyCurrent,
    onDrag: notifyCurrent,
    onDragStart: notifyCurrent,
    onDrop: notifyCurrent,
    onDropTargetChange: function onDropTargetChange(_ref4) {
      var payload = _ref4.payload;
      var isCurrent = new Set(payload.location.current.dropTargets.map(function(record2) {
        return record2.element;
      }));
      var visited = /* @__PURE__ */ new Set();
      var _iterator2 = _createForOfIteratorHelper$5(payload.location.previous.dropTargets), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _entry$onDropTargetCh;
          var record = _step2.value;
          visited.add(record.element);
          var entry = registry.get(record.element);
          var isOver = isCurrent.has(record.element);
          var _args2 = _objectSpread$d(_objectSpread$d({}, payload), {}, {
            self: record
          });
          entry === null || entry === void 0 || (_entry$onDropTargetCh = entry.onDropTargetChange) === null || _entry$onDropTargetCh === void 0 || _entry$onDropTargetCh.call(entry, _args2);
          if (!isOver) {
            var _entry$onDragLeave;
            entry === null || entry === void 0 || (_entry$onDragLeave = entry.onDragLeave) === null || _entry$onDragLeave === void 0 || _entry$onDragLeave.call(entry, _args2);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper$5(payload.location.current.dropTargets), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _entry$onDropTargetCh2, _entry$onDragEnter;
          var _record = _step3.value;
          if (visited.has(_record.element)) {
            continue;
          }
          var _args3 = _objectSpread$d(_objectSpread$d({}, payload), {}, {
            self: _record
          });
          var _entry = registry.get(_record.element);
          _entry === null || _entry === void 0 || (_entry$onDropTargetCh2 = _entry.onDropTargetChange) === null || _entry$onDropTargetCh2 === void 0 || _entry$onDropTargetCh2.call(_entry, _args3);
          _entry === null || _entry === void 0 || (_entry$onDragEnter = _entry.onDragEnter) === null || _entry$onDragEnter === void 0 || _entry$onDragEnter.call(_entry, _args3);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  };
  function dispatchEvent(args) {
    actions[args.eventName](args);
  }
  function getIsOver(_ref5) {
    var source = _ref5.source, target = _ref5.target, input = _ref5.input, current = _ref5.current;
    var actual = getActualDropTargets({
      source,
      target,
      input
    });
    if (actual.length >= current.length) {
      return actual;
    }
    var lastCaptureOrdered = copyReverse(current);
    var actualCaptureOrdered = copyReverse(actual);
    var resultCaptureOrdered = [];
    for (var index2 = 0; index2 < lastCaptureOrdered.length; index2++) {
      var _argsForLast$getIsSti;
      var last2 = lastCaptureOrdered[index2];
      var fresh = actualCaptureOrdered[index2];
      if (fresh != null) {
        resultCaptureOrdered.push(fresh);
        continue;
      }
      var parent = resultCaptureOrdered[index2 - 1];
      var lastParent = lastCaptureOrdered[index2 - 1];
      if ((parent === null || parent === void 0 ? void 0 : parent.element) !== (lastParent === null || lastParent === void 0 ? void 0 : lastParent.element)) {
        break;
      }
      var argsForLast = registry.get(last2.element);
      if (!argsForLast) {
        break;
      }
      var feedback = {
        input,
        source,
        element: argsForLast.element
      };
      if (argsForLast.canDrop && !argsForLast.canDrop(feedback)) {
        break;
      }
      if (!((_argsForLast$getIsSti = argsForLast.getIsSticky) !== null && _argsForLast$getIsSti !== void 0 && _argsForLast$getIsSti.call(argsForLast, feedback))) {
        break;
      }
      resultCaptureOrdered.push(_objectSpread$d(_objectSpread$d({}, last2), {}, {
        // making it clear to consumers this drop target is active due to stickiness
        isActiveDueToStickiness: true
      }));
    }
    return copyReverse(resultCaptureOrdered);
  }
  return {
    dropTargetForConsumers,
    getIsOver,
    dispatchEvent
  };
}
function _createForOfIteratorHelper$4(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$c(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$c(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$c(Object(t), true).forEach(function(r2) {
      _defineProperty$d(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function makeMonitor() {
  var registry = /* @__PURE__ */ new Set();
  var dragging = null;
  function tryAddToActive(monitor) {
    if (!dragging) {
      return;
    }
    if (!monitor.canMonitor || monitor.canMonitor(dragging.canMonitorArgs)) {
      dragging.active.add(monitor);
    }
  }
  function monitorForConsumers(args) {
    var entry = _objectSpread$c({}, args);
    registry.add(entry);
    tryAddToActive(entry);
    return function cleanup() {
      registry.delete(entry);
      if (dragging) {
        dragging.active.delete(entry);
      }
    };
  }
  function dispatchEvent(_ref) {
    var eventName = _ref.eventName, payload = _ref.payload;
    if (eventName === "onGenerateDragPreview") {
      dragging = {
        canMonitorArgs: {
          initial: payload.location.initial,
          source: payload.source
        },
        active: /* @__PURE__ */ new Set()
      };
      var _iterator = _createForOfIteratorHelper$4(registry), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var monitor = _step.value;
          tryAddToActive(monitor);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    if (!dragging) {
      return;
    }
    var active3 = Array.from(dragging.active);
    for (var _i = 0, _active = active3; _i < _active.length; _i++) {
      var _monitor = _active[_i];
      if (dragging.active.has(_monitor)) {
        var _monitor$eventName;
        (_monitor$eventName = _monitor[eventName]) === null || _monitor$eventName === void 0 || _monitor$eventName.call(_monitor, payload);
      }
    }
    if (eventName === "onDrop") {
      dragging.active.clear();
      dragging = null;
    }
  }
  return {
    dispatchEvent,
    monitorForConsumers
  };
}
function makeAdapter(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount, dispatchEventToSource2 = _ref.dispatchEventToSource, onPostDispatch = _ref.onPostDispatch, defaultDropEffect = _ref.defaultDropEffect;
  var monitorAPI = makeMonitor();
  var dropTargetAPI = makeDropTarget({
    typeKey,
    defaultDropEffect
  });
  function dispatchEvent(args) {
    dispatchEventToSource2 === null || dispatchEventToSource2 === void 0 || dispatchEventToSource2(args);
    dropTargetAPI.dispatchEvent(args);
    monitorAPI.dispatchEvent(args);
    onPostDispatch === null || onPostDispatch === void 0 || onPostDispatch(args);
  }
  function start2(_ref2) {
    var event2 = _ref2.event, dragType = _ref2.dragType;
    lifecycle.start({
      event: event2,
      dragType,
      getDropTargetsOver: dropTargetAPI.getIsOver,
      dispatchEvent
    });
  }
  function registerUsage2() {
    function mountAdapter() {
      var api2 = {
        canStart: lifecycle.canStart,
        start: start2
      };
      return mount2(api2);
    }
    return register({
      typeKey,
      mount: mountAdapter
    });
  }
  return {
    registerUsage: registerUsage2,
    dropTarget: dropTargetAPI.dropTargetForConsumers,
    monitor: monitorAPI.monitorForConsumers
  };
}
var isAndroid = once(function isAndroid2() {
  return navigator.userAgent.toLocaleLowerCase().includes("android");
});
var androidFallbackText = "pdnd:android-fallback";
var textMediaType = "text/plain";
var urlMediaType = "text/uri-list";
var elementAdapterNativeDataKey = "application/vnd.pdnd";
var draggableRegistry = /* @__PURE__ */ new WeakMap();
function addToRegistry(args) {
  draggableRegistry.set(args.element, args);
  return function cleanup() {
    draggableRegistry.delete(args.element);
  };
}
var honeyPotFix = makeHoneyPotFix();
var adapter = makeAdapter({
  typeKey: "element",
  defaultDropEffect: "move",
  mount: function mount(api2) {
    return combine(honeyPotFix.bindEvents(), dist.bind(document, {
      type: "dragstart",
      listener: function listener(event2) {
        var _entry$dragHandle, _entry$getInitialData, _entry$getInitialData2, _entry$dragHandle2, _entry$getInitialData3, _entry$getInitialData4;
        if (!api2.canStart(event2)) {
          return;
        }
        if (event2.defaultPrevented) {
          return;
        }
        if (!event2.dataTransfer) {
          if (false) {
            console.warn("\n              It appears as though you have are not testing DragEvents correctly.\n\n              - If you are unit testing, ensure you have polyfilled DragEvent.\n              - If you are browser testing, ensure you are dispatching drag events correctly.\n\n              Please see our testing guides for more information:\n              https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n            ".replace(/ {2}/g, ""));
          }
          return;
        }
        var target = event2.target;
        if (!(target instanceof HTMLElement)) {
          return null;
        }
        var entry = draggableRegistry.get(target);
        if (!entry) {
          return null;
        }
        var input = getInput(event2);
        var feedback = {
          element: entry.element,
          dragHandle: (_entry$dragHandle = entry.dragHandle) !== null && _entry$dragHandle !== void 0 ? _entry$dragHandle : null,
          input
        };
        if (entry.canDrag && !entry.canDrag(feedback)) {
          event2.preventDefault();
          return null;
        }
        if (entry.dragHandle) {
          var over = getElementFromPointWithoutHoneypot({
            x: input.clientX,
            y: input.clientY
          });
          if (!entry.dragHandle.contains(over)) {
            event2.preventDefault();
            return null;
          }
        }
        var nativeData = (_entry$getInitialData = (_entry$getInitialData2 = entry.getInitialDataForExternal) === null || _entry$getInitialData2 === void 0 ? void 0 : _entry$getInitialData2.call(entry, feedback)) !== null && _entry$getInitialData !== void 0 ? _entry$getInitialData : null;
        if (nativeData) {
          for (var _i = 0, _Object$entries = Object.entries(nativeData); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray$2(_Object$entries[_i], 2), key = _Object$entries$_i[0], data28 = _Object$entries$_i[1];
            event2.dataTransfer.setData(key, data28 !== null && data28 !== void 0 ? data28 : "");
          }
        }
        var types = event2.dataTransfer.types;
        if (isAndroid() && !types.includes(textMediaType) && !types.includes(urlMediaType)) {
          event2.dataTransfer.setData(textMediaType, androidFallbackText);
        }
        event2.dataTransfer.setData(elementAdapterNativeDataKey, "");
        var payload = {
          element: entry.element,
          dragHandle: (_entry$dragHandle2 = entry.dragHandle) !== null && _entry$dragHandle2 !== void 0 ? _entry$dragHandle2 : null,
          data: (_entry$getInitialData3 = (_entry$getInitialData4 = entry.getInitialData) === null || _entry$getInitialData4 === void 0 ? void 0 : _entry$getInitialData4.call(entry, feedback)) !== null && _entry$getInitialData3 !== void 0 ? _entry$getInitialData3 : {}
        };
        var dragType = {
          type: "element",
          payload,
          startedFrom: "internal"
        };
        api2.start({
          event: event2,
          dragType
        });
      }
    }));
  },
  dispatchEventToSource: function dispatchEventToSource(_ref) {
    var _draggableRegistry$ge, _draggableRegistry$ge2;
    var eventName = _ref.eventName, payload = _ref.payload;
    (_draggableRegistry$ge = draggableRegistry.get(payload.source.element)) === null || _draggableRegistry$ge === void 0 || (_draggableRegistry$ge2 = _draggableRegistry$ge[eventName]) === null || _draggableRegistry$ge2 === void 0 || _draggableRegistry$ge2.call(
      _draggableRegistry$ge,
      // I cannot seem to get the types right here.
      // TS doesn't seem to like that one event can need `nativeSetDragImage`
      // @ts-expect-error
      payload
    );
  },
  onPostDispatch: honeyPotFix.getOnPostDispatch()
});
var dropTargetForElements = adapter.dropTarget;
var monitorForElements = adapter.monitor;
function draggable(args) {
  if (false) {
    if (args.dragHandle && !args.element.contains(args.dragHandle)) {
      console.warn("Drag handle element must be contained in draggable element", {
        element: args.element,
        dragHandle: args.dragHandle
      });
    }
  }
  if (false) {
    var existing = draggableRegistry.get(args.element);
    if (existing) {
      console.warn("You have already registered a `draggable` on the same element", {
        existing,
        proposed: args
      });
    }
  }
  return combine(
    // making the draggable register the adapter rather than drop targets
    // this is because you *must* have a draggable element to start a drag
    // but you _might_ not have any drop targets immediately
    // (You might create drop targets async)
    adapter.registerUsage(),
    addToRegistry(args),
    addAttribute(args.element, {
      attribute: "draggable",
      value: "true"
    })
  );
}
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "GraphCanvas",
  emits: ["ready"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const canvasRef = ref(null);
    const settingStore = useSettingStore();
    const workspaceStore = useWorkspaceStore();
    const betaMenuEnabled = computed(
      () => settingStore.get("Comfy.UseNewMenu") !== "Disabled"
    );
    const nodeSearchEnabled = computed(
      () => settingStore.get("Comfy.NodeSearchBoxImpl") === "default"
    );
    watch(
      nodeSearchEnabled,
      (newVal) => {
        LiteGraph.release_link_on_empty_shows_menu = !newVal;
        if (app$1.canvas) app$1.canvas.allow_searchbox = !newVal;
      },
      { immediate: true }
    );
    let dropTargetCleanup = () => {
    };
    onMounted(() => __async(this, null, function* () {
      window["LiteGraph"] = LiteGraph;
      window["LGraph"] = LGraph;
      window["LLink"] = LLink;
      window["LGraphNode"] = LGraphNode;
      window["LGraphGroup"] = LGraphGroup;
      window["DragAndScale"] = DragAndScale;
      window["LGraphCanvas"] = LGraphCanvas;
      window["ContextMenu"] = ContextMenu;
      app$1.vueAppReady = true;
      workspaceStore.spinner = true;
      yield app$1.setup(canvasRef.value);
      app$1.canvas.allow_searchbox = !nodeSearchEnabled.value;
      workspaceStore.spinner = false;
      window["app"] = app$1;
      window["graph"] = app$1.graph;
      dropTargetCleanup = dropTargetForElements({
        element: canvasRef.value,
        onDrop: (event2) => {
          const loc = event2.location.current.input;
          const pos2 = app$1.clientPosToCanvasPos([loc.clientX - 20, loc.clientY]);
          const comfyNodeName = event2.source.element.getAttribute(
            "data-comfy-node-name"
          );
          const nodeDef = useNodeDefStore().nodeDefsByName[comfyNodeName];
          app$1.addNodeOnGraph(nodeDef, { pos: pos2 });
        }
      });
      emit2("ready");
    }));
    onUnmounted(() => {
      dropTargetCleanup();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (openBlock(), createBlock(Teleport, { to: ".graph-canvas-container" }, [
          betaMenuEnabled.value ? (openBlock(), createBlock(LiteGraphCanvasSplitterOverlay, { key: 0 }, {
            "side-bar-panel": withCtx(() => [
              createVNode(SideToolbar)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createBaseVNode("canvas", {
            ref_key: "canvasRef",
            ref: canvasRef,
            id: "graph-canvas",
            tabindex: "1"
          }, null, 512)
        ])),
        nodeSearchEnabled.value ? (openBlock(), createBlock(_sfc_main$8, { key: 0 })) : createCommentVNode("", true),
        createVNode(NodeTooltip)
      ], 64);
    };
  }
});
var script$x = {
  name: "ArrowDownIcon",
  "extends": script$15
};
var _hoisted_1$u = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M6.99994 14C6.91097 14.0004 6.82281 13.983 6.74064 13.9489C6.65843 13.9148 6.58387 13.8646 6.52133 13.8013L1.10198 8.38193C0.982318 8.25351 0.917175 8.08367 0.920272 7.90817C0.923368 7.73267 0.994462 7.56523 1.11858 7.44111C1.24269 7.317 1.41014 7.2459 1.58563 7.2428C1.76113 7.23971 1.93098 7.30485 2.0594 7.42451L6.32263 11.6877V0.677419C6.32263 0.497756 6.394 0.325452 6.52104 0.198411C6.64808 0.0713706 6.82039 0 7.00005 0C7.17971 0 7.35202 0.0713706 7.47906 0.198411C7.6061 0.325452 7.67747 0.497756 7.67747 0.677419V11.6877L11.9407 7.42451C12.0691 7.30485 12.2389 7.23971 12.4144 7.2428C12.5899 7.2459 12.7574 7.317 12.8815 7.44111C13.0056 7.56523 13.0767 7.73267 13.0798 7.90817C13.0829 8.08367 13.0178 8.25351 12.8981 8.38193L7.47875 13.8013C7.41621 13.8646 7.34164 13.9148 7.25944 13.9489C7.17727 13.983 7.08912 14.0004 7.00015 14C7.00012 14 7.00009 14 7.00005 14C7.00001 14 6.99998 14 6.99994 14Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$p = [_hoisted_1$u];
function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$p, 16);
}
script$x.render = render$w;
var script$w = {
  name: "ArrowUpIcon",
  "extends": script$15
};
var _hoisted_1$t = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M6.51551 13.799C6.64205 13.9255 6.813 13.9977 6.99193 14C7.17087 13.9977 7.34182 13.9255 7.46835 13.799C7.59489 13.6725 7.66701 13.5015 7.66935 13.3226V2.31233L11.9326 6.57554C11.9951 6.63887 12.0697 6.68907 12.1519 6.72319C12.2341 6.75731 12.3223 6.77467 12.4113 6.77425C12.5003 6.77467 12.5885 6.75731 12.6707 6.72319C12.7529 6.68907 12.8274 6.63887 12.89 6.57554C13.0168 6.44853 13.0881 6.27635 13.0881 6.09683C13.0881 5.91732 13.0168 5.74514 12.89 5.61812L7.48846 0.216594C7.48274 0.210436 7.4769 0.204374 7.47094 0.198411C7.3439 0.0713707 7.1716 0 6.99193 0C6.81227 0 6.63997 0.0713707 6.51293 0.198411C6.50704 0.204296 6.50128 0.210278 6.49563 0.216354L1.09386 5.61812C0.974201 5.74654 0.909057 5.91639 0.912154 6.09189C0.91525 6.26738 0.986345 6.43483 1.11046 6.55894C1.23457 6.68306 1.40202 6.75415 1.57752 6.75725C1.75302 6.76035 1.92286 6.6952 2.05128 6.57554L6.31451 2.31231V13.3226C6.31685 13.5015 6.38898 13.6725 6.51551 13.799Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$o = [_hoisted_1$t];
function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$o, 16);
}
script$w.render = render$v;
function _typeof$d(o) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$d(o);
}
function _defineProperty$c(e, r, t) {
  return (r = _toPropertyKey$c(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$c(t) {
  var i2 = _toPrimitive$c(t, "string");
  return "symbol" == _typeof$d(i2) ? i2 : i2 + "";
}
function _toPrimitive$c(t, r) {
  if ("object" != _typeof$d(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$d(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var theme$7 = function theme28(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-paginator {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-wrap: wrap;\n    background: ".concat(dt3("paginator.background"), ";\n    color: ").concat(dt3("paginator.color"), ";\n    padding: ").concat(dt3("paginator.padding"), ";\n    border-radius: ").concat(dt3("paginator.border.radius"), ";\n    gap: ").concat(dt3("paginator.gap"), ";\n}\n\n.p-paginator-content {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-wrap: wrap;\n    gap: ").concat(dt3("paginator.gap"), ";\n}\n\n.p-paginator-content-start {\n    margin-right: auto;\n}\n\n.p-paginator-content-end {\n    margin-left: auto;\n}\n\n.p-paginator-page,\n.p-paginator-next,\n.p-paginator-last,\n.p-paginator-first,\n.p-paginator-prev {\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    line-height: 1;\n    user-select: none;\n    overflow: hidden;\n    position: relative;\n    background: ").concat(dt3("paginator.nav.button.background"), ";\n    border: 0 none;\n    color: ").concat(dt3("paginator.nav.button.color"), ";\n    min-width: ").concat(dt3("paginator.nav.button.width"), ";\n    height: ").concat(dt3("paginator.nav.button.height"), ";\n    transition: background ").concat(dt3("paginator.transition.duration"), ", color ").concat(dt3("paginator.transition.duration"), ", outline-color ").concat(dt3("paginator.transition.duration"), ", box-shadow ").concat(dt3("paginator.transition.duration"), ";\n    border-radius: ").concat(dt3("paginator.nav.button.border.radius"), ";\n    padding: 0;\n    margin: 0;\n}\n\n.p-paginator-page:focus-visible,\n.p-paginator-next:focus-visible,\n.p-paginator-last:focus-visible,\n.p-paginator-first:focus-visible,\n.p-paginator-prev:focus-visible {\n    box-shadow: ").concat(dt3("paginator.nav.button.focus.ring.shadow"), ";\n    outline: ").concat(dt3("paginator.nav.button.focus.ring.width"), " ").concat(dt3("paginator.nav.button.focus.ring.style"), " ").concat(dt3("paginator.nav.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("paginator.nav.button.focus.ring.offset"), ";\n}\n\n.p-paginator-page:not(.p-disabled):not(.p-paginator-page-selected):hover,\n.p-paginator-first:not(.p-disabled):hover,\n.p-paginator-prev:not(.p-disabled):hover,\n.p-paginator-next:not(.p-disabled):hover,\n.p-paginator-last:not(.p-disabled):hover {\n    background: ").concat(dt3("paginator.nav.button.hover.background"), ";\n    color: ").concat(dt3("paginator.nav.button.hover.color"), ";\n}\n\n.p-paginator-page.p-paginator-page-selected {\n    background: ").concat(dt3("paginator.nav.button.selected.background"), ";\n    color: ").concat(dt3("paginator.nav.button.selected.color"), ";\n}\n\n.p-paginator-current {\n    color: ").concat(dt3("paginator.current.page.report.color"), ";\n}\n\n.p-paginator-pages {\n    display: flex;\n    align-items: center;\n    gap: ").concat(dt3("paginator.gap"), ";\n}\n\n.p-paginator-jtp-input .p-inputtext {\n    max-width: ").concat(dt3("paginator.jump.to.page.input.max.width"), ";\n}\n");
};
var classes$7 = {
  paginator: function paginator(_ref2) {
    var instance = _ref2.instance, key = _ref2.key;
    return ["p-paginator p-component", _defineProperty$c({
      "p-paginator-default": !instance.hasBreakpoints()
    }, "p-paginator-".concat(key), instance.hasBreakpoints())];
  },
  content: "p-paginator-content",
  contentStart: "p-paginator-content-start",
  contentEnd: "p-paginator-content-end",
  first: function first(_ref4) {
    var instance = _ref4.instance;
    return ["p-paginator-first", {
      "p-disabled": instance.$attrs.disabled
    }];
  },
  firstIcon: "p-paginator-first-icon",
  prev: function prev(_ref5) {
    var instance = _ref5.instance;
    return ["p-paginator-prev", {
      "p-disabled": instance.$attrs.disabled
    }];
  },
  prevIcon: "p-paginator-prev-icon",
  next: function next(_ref6) {
    var instance = _ref6.instance;
    return ["p-paginator-next", {
      "p-disabled": instance.$attrs.disabled
    }];
  },
  nextIcon: "p-paginator-next-icon",
  last: function last(_ref7) {
    var instance = _ref7.instance;
    return ["p-paginator-last", {
      "p-disabled": instance.$attrs.disabled
    }];
  },
  lastIcon: "p-paginator-last-icon",
  pages: "p-paginator-pages",
  page: function page(_ref8) {
    var props = _ref8.props, pageLink = _ref8.pageLink;
    return ["p-paginator-page", {
      "p-paginator-page-selected": pageLink - 1 === props.page
    }];
  },
  current: "p-paginator-current",
  pcRowPerPageDropdown: "p-paginator-rpp-dropdown",
  pcJumpToPageDropdown: "p-paginator-jtp-dropdown",
  pcJumpToPageInput: "p-paginator-jtp-input"
};
var PaginatorStyle = BaseStyle.extend({
  name: "paginator",
  theme: theme$7,
  classes: classes$7
});
var script$v = {
  name: "AngleDoubleLeftIcon",
  "extends": script$15
};
var _hoisted_1$s = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M5.71602 11.164C5.80782 11.2021 5.9063 11.2215 6.00569 11.221C6.20216 11.2301 6.39427 11.1612 6.54025 11.0294C6.68191 10.8875 6.76148 10.6953 6.76148 10.4948C6.76148 10.2943 6.68191 10.1021 6.54025 9.96024L3.51441 6.9344L6.54025 3.90855C6.624 3.76126 6.65587 3.59011 6.63076 3.42254C6.60564 3.25498 6.525 3.10069 6.40175 2.98442C6.2785 2.86815 6.11978 2.79662 5.95104 2.7813C5.78229 2.76598 5.61329 2.80776 5.47112 2.89994L1.97123 6.39983C1.82957 6.54167 1.75 6.73393 1.75 6.9344C1.75 7.13486 1.82957 7.32712 1.97123 7.46896L5.47112 10.9991C5.54096 11.0698 5.62422 11.1259 5.71602 11.164ZM11.0488 10.9689C11.1775 11.1156 11.3585 11.2061 11.5531 11.221C11.7477 11.2061 11.9288 11.1156 12.0574 10.9689C12.1815 10.8302 12.25 10.6506 12.25 10.4645C12.25 10.2785 12.1815 10.0989 12.0574 9.96024L9.03158 6.93439L12.0574 3.90855C12.1248 3.76739 12.1468 3.60881 12.1204 3.45463C12.0939 3.30045 12.0203 3.15826 11.9097 3.04765C11.7991 2.93703 11.6569 2.86343 11.5027 2.83698C11.3486 2.81053 11.19 2.83252 11.0488 2.89994L7.51865 6.36957C7.37699 6.51141 7.29742 6.70367 7.29742 6.90414C7.29742 7.1046 7.37699 7.29686 7.51865 7.4387L11.0488 10.9689Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$n = [_hoisted_1$s];
function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$n, 16);
}
script$v.render = render$u;
var script$u = {
  name: "AngleDoubleRightIcon",
  "extends": script$15
};
var _hoisted_1$r = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7.68757 11.1451C7.7791 11.1831 7.8773 11.2024 7.9764 11.2019C8.07769 11.1985 8.17721 11.1745 8.26886 11.1312C8.36052 11.088 8.44238 11.0265 8.50943 10.9505L12.0294 7.49085C12.1707 7.34942 12.25 7.15771 12.25 6.95782C12.25 6.75794 12.1707 6.56622 12.0294 6.42479L8.50943 2.90479C8.37014 2.82159 8.20774 2.78551 8.04633 2.80192C7.88491 2.81833 7.73309 2.88635 7.6134 2.99588C7.4937 3.10541 7.41252 3.25061 7.38189 3.40994C7.35126 3.56927 7.37282 3.73423 7.44337 3.88033L10.4605 6.89748L7.44337 9.91463C7.30212 10.0561 7.22278 10.2478 7.22278 10.4477C7.22278 10.6475 7.30212 10.8393 7.44337 10.9807C7.51301 11.0512 7.59603 11.1071 7.68757 11.1451ZM1.94207 10.9505C2.07037 11.0968 2.25089 11.1871 2.44493 11.2019C2.63898 11.1871 2.81949 11.0968 2.94779 10.9505L6.46779 7.49085C6.60905 7.34942 6.68839 7.15771 6.68839 6.95782C6.68839 6.75793 6.60905 6.56622 6.46779 6.42479L2.94779 2.90479C2.80704 2.83757 2.6489 2.81563 2.49517 2.84201C2.34143 2.86839 2.19965 2.94178 2.08936 3.05207C1.97906 3.16237 1.90567 3.30415 1.8793 3.45788C1.85292 3.61162 1.87485 3.76975 1.94207 3.9105L4.95922 6.92765L1.94207 9.9448C1.81838 10.0831 1.75 10.2621 1.75 10.4477C1.75 10.6332 1.81838 10.8122 1.94207 10.9505Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$m = [_hoisted_1$r];
function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$m, 16);
}
script$u.render = render$t;
var script$t = {
  name: "AngleRightIcon",
  "extends": script$15
};
var _hoisted_1$q = /* @__PURE__ */ createBaseVNode("path", {
  d: "M5.25 11.1728C5.14929 11.1694 5.05033 11.1455 4.9592 11.1025C4.86806 11.0595 4.78666 10.9984 4.72 10.9228C4.57955 10.7822 4.50066 10.5916 4.50066 10.3928C4.50066 10.1941 4.57955 10.0035 4.72 9.86283L7.72 6.86283L4.72 3.86283C4.66067 3.71882 4.64765 3.55991 4.68275 3.40816C4.71785 3.25642 4.79932 3.11936 4.91585 3.01602C5.03238 2.91268 5.17819 2.84819 5.33305 2.83149C5.4879 2.81479 5.64411 2.84671 5.78 2.92283L9.28 6.42283C9.42045 6.56346 9.49934 6.75408 9.49934 6.95283C9.49934 7.15158 9.42045 7.34221 9.28 7.48283L5.78 10.9228C5.71333 10.9984 5.63193 11.0595 5.5408 11.1025C5.44966 11.1455 5.35071 11.1694 5.25 11.1728Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$l = [_hoisted_1$q];
function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$l, 16);
}
script$t.render = render$s;
var script$s = {
  name: "AngleLeftIcon",
  "extends": script$15
};
var _hoisted_1$p = /* @__PURE__ */ createBaseVNode("path", {
  d: "M8.75 11.185C8.65146 11.1854 8.55381 11.1662 8.4628 11.1284C8.37179 11.0906 8.28924 11.0351 8.22 10.965L4.72 7.46496C4.57955 7.32433 4.50066 7.13371 4.50066 6.93496C4.50066 6.73621 4.57955 6.54558 4.72 6.40496L8.22 2.93496C8.36095 2.84357 8.52851 2.80215 8.69582 2.81733C8.86312 2.83252 9.02048 2.90344 9.14268 3.01872C9.26487 3.134 9.34483 3.28696 9.36973 3.4531C9.39463 3.61924 9.36303 3.78892 9.28 3.93496L6.28 6.93496L9.28 9.93496C9.42045 10.0756 9.49934 10.2662 9.49934 10.465C9.49934 10.6637 9.42045 10.8543 9.28 10.995C9.13526 11.1257 8.9448 11.1939 8.75 11.185Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$k = [_hoisted_1$p];
function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$k, 16);
}
script$s.render = render$r;
var script$a$1 = {
  name: "BasePaginator",
  "extends": script$1a,
  props: {
    totalRecords: {
      type: Number,
      "default": 0
    },
    rows: {
      type: Number,
      "default": 0
    },
    first: {
      type: Number,
      "default": 0
    },
    pageLinkSize: {
      type: Number,
      "default": 5
    },
    rowsPerPageOptions: {
      type: Array,
      "default": null
    },
    template: {
      type: [Object, String],
      "default": "FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown"
    },
    currentPageReportTemplate: {
      type: null,
      "default": "({currentPage} of {totalPages})"
    },
    alwaysShow: {
      type: Boolean,
      "default": true
    }
  },
  style: PaginatorStyle,
  provide: function provide31() {
    return {
      $pcPaginator: this,
      $parentInstance: this
    };
  }
};
var script$9$1 = {
  name: "CurrentPageReport",
  hostName: "Paginator",
  "extends": script$1a,
  props: {
    pageCount: {
      type: Number,
      "default": 0
    },
    currentPage: {
      type: Number,
      "default": 0
    },
    page: {
      type: Number,
      "default": 0
    },
    first: {
      type: Number,
      "default": 0
    },
    rows: {
      type: Number,
      "default": 0
    },
    totalRecords: {
      type: Number,
      "default": 0
    },
    template: {
      type: String,
      "default": "({currentPage} of {totalPages})"
    }
  },
  computed: {
    text: function text() {
      var text2 = this.template.replace("{currentPage}", this.currentPage).replace("{totalPages}", this.pageCount).replace("{first}", this.pageCount > 0 ? this.first + 1 : 0).replace("{last}", Math.min(this.first + this.rows, this.totalRecords)).replace("{rows}", this.rows).replace("{totalRecords}", this.totalRecords);
      return text2;
    }
  }
};
function render$9$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("current")
  }, _ctx.ptm("current")), toDisplayString$1($options.text), 17);
}
script$9$1.render = render$9$1;
var script$8$2 = {
  name: "FirstPageLink",
  hostName: "Paginator",
  "extends": script$1a,
  props: {
    template: {
      type: Function,
      "default": null
    }
  },
  methods: {
    getPTOptions: function getPTOptions10(key) {
      return this.ptm(key, {
        context: {
          disabled: this.$attrs.disabled
        }
      });
    }
  },
  components: {
    AngleDoubleLeftIcon: script$v
  },
  directives: {
    ripple: Ripple
  }
};
function render$8$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return withDirectives((openBlock(), createElementBlock("button", mergeProps({
    "class": _ctx.cx("first"),
    type: "button"
  }, $options.getPTOptions("first"), {
    "data-pc-group-section": "pagebutton"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.template || "AngleDoubleLeftIcon"), mergeProps({
    "class": _ctx.cx("firstIcon")
  }, $options.getPTOptions("firstIcon")), null, 16, ["class"]))], 16)), [[_directive_ripple]]);
}
script$8$2.render = render$8$1;
var script$7$2 = {
  name: "JumpToPageDropdown",
  hostName: "Paginator",
  "extends": script$1a,
  emits: ["page-change"],
  props: {
    page: Number,
    pageCount: Number,
    disabled: Boolean,
    templates: null
  },
  methods: {
    onChange: function onChange4(value3) {
      this.$emit("page-change", value3);
    }
  },
  computed: {
    pageOptions: function pageOptions() {
      var opts = [];
      for (var i2 = 0; i2 < this.pageCount; i2++) {
        opts.push({
          label: String(i2 + 1),
          value: i2
        });
      }
      return opts;
    }
  },
  components: {
    JTPSelect: script$M
  }
};
function render$7$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_JTPSelect = resolveComponent("JTPSelect");
  return openBlock(), createBlock(_component_JTPSelect, {
    modelValue: $props.page,
    options: $options.pageOptions,
    optionLabel: "label",
    optionValue: "value",
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function($event) {
      return $options.onChange($event);
    }),
    "class": normalizeClass(_ctx.cx("pcJumpToPageDropdown")),
    disabled: $props.disabled,
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcJumpToPageDropdown"),
    "data-pc-group-section": "pagedropdown"
  }, createSlots({
    _: 2
  }, [$props.templates["jumptopagedropdownicon"] ? {
    name: "dropdownicon",
    fn: withCtx(function(slotProps) {
      return [(openBlock(), createBlock(resolveDynamicComponent($props.templates["jumptopagedropdownicon"]), {
        "class": normalizeClass(slotProps["class"])
      }, null, 8, ["class"]))];
    }),
    key: "0"
  } : void 0]), 1032, ["modelValue", "options", "class", "disabled", "unstyled", "pt"]);
}
script$7$2.render = render$7$1;
var script$6$2 = {
  name: "JumpToPageInput",
  hostName: "Paginator",
  "extends": script$1a,
  inheritAttrs: false,
  emits: ["page-change"],
  props: {
    page: Number,
    pageCount: Number,
    disabled: Boolean
  },
  data: function data13() {
    return {
      d_page: this.page
    };
  },
  watch: {
    page: function page2(newValue) {
      this.d_page = newValue;
    }
  },
  methods: {
    onChange: function onChange5(value3) {
      if (value3 !== this.page) {
        this.d_page = value3;
        this.$emit("page-change", value3 - 1);
      }
    }
  },
  computed: {
    inputArialabel: function inputArialabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.jumpToPageInputLabel : void 0;
    }
  },
  components: {
    JTPInput: script$Q
  }
};
function render$6$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_JTPInput = resolveComponent("JTPInput");
  return openBlock(), createBlock(_component_JTPInput, {
    ref: "jtpInput",
    modelValue: $data.d_page,
    "class": normalizeClass(_ctx.cx("pcJumpToPageInput")),
    "aria-label": $options.inputArialabel,
    disabled: $props.disabled,
    "onUpdate:modelValue": $options.onChange,
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcJumpToPageInput")
  }, null, 8, ["modelValue", "class", "aria-label", "disabled", "onUpdate:modelValue", "unstyled", "pt"]);
}
script$6$2.render = render$6$2;
var script$5$2 = {
  name: "LastPageLink",
  hostName: "Paginator",
  "extends": script$1a,
  props: {
    template: {
      type: Function,
      "default": null
    }
  },
  methods: {
    getPTOptions: function getPTOptions11(key) {
      return this.ptm(key, {
        context: {
          disabled: this.$attrs.disabled
        }
      });
    }
  },
  components: {
    AngleDoubleRightIcon: script$u
  },
  directives: {
    ripple: Ripple
  }
};
function render$5$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return withDirectives((openBlock(), createElementBlock("button", mergeProps({
    "class": _ctx.cx("last"),
    type: "button"
  }, $options.getPTOptions("last"), {
    "data-pc-group-section": "pagebutton"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.template || "AngleDoubleRightIcon"), mergeProps({
    "class": _ctx.cx("lastIcon")
  }, $options.getPTOptions("lastIcon")), null, 16, ["class"]))], 16)), [[_directive_ripple]]);
}
script$5$2.render = render$5$2;
var script$4$2 = {
  name: "NextPageLink",
  hostName: "Paginator",
  "extends": script$1a,
  props: {
    template: {
      type: Function,
      "default": null
    }
  },
  methods: {
    getPTOptions: function getPTOptions12(key) {
      return this.ptm(key, {
        context: {
          disabled: this.$attrs.disabled
        }
      });
    }
  },
  components: {
    AngleRightIcon: script$t
  },
  directives: {
    ripple: Ripple
  }
};
function render$4$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return withDirectives((openBlock(), createElementBlock("button", mergeProps({
    "class": _ctx.cx("next"),
    type: "button"
  }, $options.getPTOptions("next"), {
    "data-pc-group-section": "pagebutton"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.template || "AngleRightIcon"), mergeProps({
    "class": _ctx.cx("nextIcon")
  }, $options.getPTOptions("nextIcon")), null, 16, ["class"]))], 16)), [[_directive_ripple]]);
}
script$4$2.render = render$4$2;
var script$3$2 = {
  name: "PageLinks",
  hostName: "Paginator",
  "extends": script$1a,
  inheritAttrs: false,
  emits: ["click"],
  props: {
    value: Array,
    page: Number
  },
  methods: {
    getPTOptions: function getPTOptions13(pageLink, key) {
      return this.ptm(key, {
        context: {
          active: pageLink === this.page
        }
      });
    },
    onPageLinkClick: function onPageLinkClick(event2, pageLink) {
      this.$emit("click", {
        originalEvent: event2,
        value: pageLink
      });
    },
    ariaPageLabel: function ariaPageLabel(value3) {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.pageLabel.replace(/{page}/g, value3) : void 0;
    }
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$o = ["aria-label", "aria-current", "onClick", "data-p-active"];
function render$3$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("pages")
  }, _ctx.ptm("pages")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.value, function(pageLink) {
    return withDirectives((openBlock(), createElementBlock("button", mergeProps({
      key: pageLink,
      "class": _ctx.cx("page", {
        pageLink
      }),
      type: "button",
      "aria-label": $options.ariaPageLabel(pageLink),
      "aria-current": pageLink - 1 === $props.page ? "page" : void 0,
      onClick: function onClick5($event) {
        return $options.onPageLinkClick($event, pageLink);
      },
      ref_for: true
    }, $options.getPTOptions(pageLink - 1, "page"), {
      "data-p-active": pageLink - 1 === $props.page
    }), [createTextVNode(toDisplayString$1(pageLink), 1)], 16, _hoisted_1$o)), [[_directive_ripple]]);
  }), 128))], 16);
}
script$3$2.render = render$3$2;
var script$2$3 = {
  name: "PrevPageLink",
  hostName: "Paginator",
  "extends": script$1a,
  props: {
    template: {
      type: Function,
      "default": null
    }
  },
  methods: {
    getPTOptions: function getPTOptions14(key) {
      return this.ptm(key, {
        context: {
          disabled: this.$attrs.disabled
        }
      });
    }
  },
  components: {
    AngleLeftIcon: script$s
  },
  directives: {
    ripple: Ripple
  }
};
function render$2$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return withDirectives((openBlock(), createElementBlock("button", mergeProps({
    "class": _ctx.cx("prev"),
    type: "button"
  }, $options.getPTOptions("prev"), {
    "data-pc-group-section": "pagebutton"
  }), [(openBlock(), createBlock(resolveDynamicComponent($props.template || "AngleLeftIcon"), mergeProps({
    "class": _ctx.cx("prevIcon")
  }, $options.getPTOptions("prevIcon")), null, 16, ["class"]))], 16)), [[_directive_ripple]]);
}
script$2$3.render = render$2$2;
var script$1$8 = {
  name: "RowsPerPageDropdown",
  hostName: "Paginator",
  "extends": script$1a,
  emits: ["rows-change"],
  props: {
    options: Array,
    rows: Number,
    disabled: Boolean,
    templates: null
  },
  methods: {
    onChange: function onChange6(value3) {
      this.$emit("rows-change", value3);
    }
  },
  computed: {
    rowsOptions: function rowsOptions() {
      var opts = [];
      if (this.options) {
        for (var i2 = 0; i2 < this.options.length; i2++) {
          opts.push({
            label: String(this.options[i2]),
            value: this.options[i2]
          });
        }
      }
      return opts;
    }
  },
  components: {
    RPPSelect: script$M
  }
};
function render$1$3(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_RPPSelect = resolveComponent("RPPSelect");
  return openBlock(), createBlock(_component_RPPSelect, {
    modelValue: $props.rows,
    options: $options.rowsOptions,
    optionLabel: "label",
    optionValue: "value",
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function($event) {
      return $options.onChange($event);
    }),
    "class": normalizeClass(_ctx.cx("pcRowPerPageDropdown")),
    disabled: $props.disabled,
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcRowPerPageDropdown"),
    "data-pc-group-section": "pagedropdown"
  }, createSlots({
    _: 2
  }, [$props.templates["rowsperpagedropdownicon"] ? {
    name: "dropdownicon",
    fn: withCtx(function(slotProps) {
      return [(openBlock(), createBlock(resolveDynamicComponent($props.templates["rowsperpagedropdownicon"]), {
        "class": normalizeClass(slotProps["class"])
      }, null, 8, ["class"]))];
    }),
    key: "0"
  } : void 0]), 1032, ["modelValue", "options", "class", "disabled", "unstyled", "pt"]);
}
script$1$8.render = render$1$3;
function _toConsumableArray$5(r) {
  return _arrayWithoutHoles$5(r) || _iterableToArray$5(r) || _unsupportedIterableToArray$5(r) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$5(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$5(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$5(r);
}
function _typeof$c(o) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$c(o);
}
function _slicedToArray$1(r, e) {
  return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$5(r, e) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$5(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$5(r, a) : void 0;
  }
}
function _arrayLikeToArray$5(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit$1(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles$1(r) {
  if (Array.isArray(r)) return r;
}
var script$r = {
  name: "Paginator",
  "extends": script$a$1,
  inheritAttrs: false,
  emits: ["update:first", "update:rows", "page"],
  data: function data14() {
    return {
      d_first: this.first,
      d_rows: this.rows
    };
  },
  watch: {
    first: function first2(newValue) {
      this.d_first = newValue;
    },
    rows: function rows(newValue) {
      this.d_rows = newValue;
    },
    totalRecords: function totalRecords(newValue) {
      if (this.page > 0 && newValue && this.d_first >= newValue) {
        this.changePage(this.pageCount - 1);
      }
    }
  },
  mounted: function mounted12() {
    this.setPaginatorAttribute();
    this.createStyle();
  },
  methods: {
    changePage: function changePage(p2) {
      var pc = this.pageCount;
      if (p2 >= 0 && p2 < pc) {
        this.d_first = this.d_rows * p2;
        var state = {
          page: p2,
          first: this.d_first,
          rows: this.d_rows,
          pageCount: pc
        };
        this.$emit("update:first", this.d_first);
        this.$emit("update:rows", this.d_rows);
        this.$emit("page", state);
      }
    },
    changePageToFirst: function changePageToFirst(event2) {
      if (!this.isFirstPage) {
        this.changePage(0);
      }
      event2.preventDefault();
    },
    changePageToPrev: function changePageToPrev(event2) {
      this.changePage(this.page - 1);
      event2.preventDefault();
    },
    changePageLink: function changePageLink(event2) {
      this.changePage(event2.value - 1);
      event2.originalEvent.preventDefault();
    },
    changePageToNext: function changePageToNext(event2) {
      this.changePage(this.page + 1);
      event2.preventDefault();
    },
    changePageToLast: function changePageToLast(event2) {
      if (!this.isLastPage) {
        this.changePage(this.pageCount - 1);
      }
      event2.preventDefault();
    },
    onRowChange: function onRowChange(value3) {
      this.d_rows = value3;
      this.changePage(this.page);
    },
    createStyle: function createStyle2() {
      var _this = this;
      if (this.hasBreakpoints() && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        var keys = Object.keys(this.template);
        var sortedBreakpoints = {};
        keys.sort(function(a, b) {
          return parseInt(a) - parseInt(b);
        }).forEach(function(key2) {
          sortedBreakpoints[key2] = _this.template[key2];
        });
        for (var _i = 0, _Object$entries = Object.entries(Object.entries(sortedBreakpoints)); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2), index2 = _Object$entries$_i[0], _Object$entries$_i$ = _slicedToArray$1(_Object$entries$_i[1], 1), key = _Object$entries$_i$[0];
          var minValue = void 0, calculatedMinValue = void 0;
          if (key !== "default" && typeof Object.keys(sortedBreakpoints)[index2 - 1] === "string") {
            calculatedMinValue = Number(Object.keys(sortedBreakpoints)[index2 - 1].slice(0, -2)) + 1 + "px";
          } else {
            calculatedMinValue = Object.keys(sortedBreakpoints)[index2 - 1];
          }
          minValue = Object.entries(sortedBreakpoints)[index2 - 1] ? "and (min-width:".concat(calculatedMinValue, ")") : "";
          if (key === "default") {
            innerHTML += "\n                            @media screen ".concat(minValue, " {\n                                .paginator[").concat(this.attributeSelector, "],\n                                    display: flex;\n                                }\n                            }\n                        ");
          } else {
            innerHTML += "\n.paginator[".concat(this.attributeSelector, "], .p-paginator-").concat(key, " {\n    display: none;\n}\n@media screen ").concat(minValue, " and (max-width: ").concat(key, ") {\n    .paginator[").concat(this.attributeSelector, "], .p-paginator-").concat(key, " {\n        display: flex;\n    }\n    .paginator[").concat(this.attributeSelector, "],\n    .p-paginator-default{\n        display: none;\n    }\n}\n                    ");
          }
        }
        this.styleElement.innerHTML = innerHTML;
      }
    },
    hasBreakpoints: function hasBreakpoints() {
      return _typeof$c(this.template) === "object";
    },
    setPaginatorAttribute: function setPaginatorAttribute() {
      var _this2 = this;
      if (this.$refs.paginator && this.$refs.paginator.length >= 0) {
        _toConsumableArray$5(this.$refs.paginator).forEach(function(el) {
          el.setAttribute(_this2.attributeSelector, "");
        });
      }
    },
    getAriaLabel: function getAriaLabel(labelType) {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria[labelType] : void 0;
    }
  },
  computed: {
    templateItems: function templateItems() {
      var keys = {};
      if (this.hasBreakpoints()) {
        keys = this.template;
        if (!keys["default"]) {
          keys["default"] = "FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown";
        }
        for (var item in keys) {
          keys[item] = this.template[item].split(" ").map(function(value3) {
            return value3.trim();
          });
        }
        return keys;
      }
      keys["default"] = this.template.split(" ").map(function(value3) {
        return value3.trim();
      });
      return keys;
    },
    page: function page3() {
      return Math.floor(this.d_first / this.d_rows);
    },
    pageCount: function pageCount() {
      return Math.ceil(this.totalRecords / this.d_rows);
    },
    isFirstPage: function isFirstPage() {
      return this.page === 0;
    },
    isLastPage: function isLastPage() {
      return this.page === this.pageCount - 1;
    },
    calculatePageLinkBoundaries: function calculatePageLinkBoundaries() {
      var numberOfPages = this.pageCount;
      var visiblePages = Math.min(this.pageLinkSize, numberOfPages);
      var start2 = Math.max(0, Math.ceil(this.page - visiblePages / 2));
      var end = Math.min(numberOfPages - 1, start2 + visiblePages - 1);
      var delta2 = this.pageLinkSize - (end - start2 + 1);
      start2 = Math.max(0, start2 - delta2);
      return [start2, end];
    },
    pageLinks: function pageLinks() {
      var pageLinks2 = [];
      var boundaries = this.calculatePageLinkBoundaries;
      var start2 = boundaries[0];
      var end = boundaries[1];
      for (var i2 = start2; i2 <= end; i2++) {
        pageLinks2.push(i2 + 1);
      }
      return pageLinks2;
    },
    currentState: function currentState() {
      return {
        page: this.page,
        first: this.d_first,
        rows: this.d_rows
      };
    },
    empty: function empty() {
      return this.pageCount === 0;
    },
    currentPage: function currentPage() {
      return this.pageCount > 0 ? this.page + 1 : 0;
    },
    attributeSelector: function attributeSelector2() {
      return UniqueComponentId();
    }
  },
  components: {
    CurrentPageReport: script$9$1,
    FirstPageLink: script$8$2,
    LastPageLink: script$5$2,
    NextPageLink: script$4$2,
    PageLinks: script$3$2,
    PrevPageLink: script$2$3,
    RowsPerPageDropdown: script$1$8,
    JumpToPageDropdown: script$7$2,
    JumpToPageInput: script$6$2
  }
};
function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_FirstPageLink = resolveComponent("FirstPageLink");
  var _component_PrevPageLink = resolveComponent("PrevPageLink");
  var _component_NextPageLink = resolveComponent("NextPageLink");
  var _component_LastPageLink = resolveComponent("LastPageLink");
  var _component_PageLinks = resolveComponent("PageLinks");
  var _component_CurrentPageReport = resolveComponent("CurrentPageReport");
  var _component_RowsPerPageDropdown = resolveComponent("RowsPerPageDropdown");
  var _component_JumpToPageDropdown = resolveComponent("JumpToPageDropdown");
  var _component_JumpToPageInput = resolveComponent("JumpToPageInput");
  return (_ctx.alwaysShow ? true : $options.pageLinks && $options.pageLinks.length > 1) ? (openBlock(), createElementBlock("nav", normalizeProps(mergeProps({
    key: 0
  }, _ctx.ptmi("paginatorContainer"))), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.templateItems, function(value3, key) {
    return openBlock(), createElementBlock("div", mergeProps({
      key,
      ref_for: true,
      ref: "paginator",
      "class": _ctx.cx("paginator", {
        key
      })
    }, _ctx.ptm("root")), [_ctx.$slots.start ? (openBlock(), createElementBlock("div", mergeProps({
      key: 0,
      "class": _ctx.cx("contentStart"),
      ref_for: true
    }, _ctx.ptm("contentStart")), [renderSlot(_ctx.$slots, "start", {
      state: $options.currentState
    })], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
      "class": _ctx.cx("content"),
      ref_for: true
    }, _ctx.ptm("content")), [(openBlock(true), createElementBlock(Fragment, null, renderList(value3, function(item) {
      return openBlock(), createElementBlock(Fragment, {
        key: item
      }, [item === "FirstPageLink" ? (openBlock(), createBlock(_component_FirstPageLink, {
        key: 0,
        "aria-label": $options.getAriaLabel("firstPageLabel"),
        template: _ctx.$slots.firsticon || _ctx.$slots.firstpagelinkicon,
        onClick: _cache[0] || (_cache[0] = function($event) {
          return $options.changePageToFirst($event);
        }),
        disabled: $options.isFirstPage || $options.empty,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["aria-label", "template", "disabled", "unstyled", "pt"])) : item === "PrevPageLink" ? (openBlock(), createBlock(_component_PrevPageLink, {
        key: 1,
        "aria-label": $options.getAriaLabel("prevPageLabel"),
        template: _ctx.$slots.previcon || _ctx.$slots.prevpagelinkicon,
        onClick: _cache[1] || (_cache[1] = function($event) {
          return $options.changePageToPrev($event);
        }),
        disabled: $options.isFirstPage || $options.empty,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["aria-label", "template", "disabled", "unstyled", "pt"])) : item === "NextPageLink" ? (openBlock(), createBlock(_component_NextPageLink, {
        key: 2,
        "aria-label": $options.getAriaLabel("nextPageLabel"),
        template: _ctx.$slots.nexticon || _ctx.$slots.nextpagelinkicon,
        onClick: _cache[2] || (_cache[2] = function($event) {
          return $options.changePageToNext($event);
        }),
        disabled: $options.isLastPage || $options.empty,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["aria-label", "template", "disabled", "unstyled", "pt"])) : item === "LastPageLink" ? (openBlock(), createBlock(_component_LastPageLink, {
        key: 3,
        "aria-label": $options.getAriaLabel("lastPageLabel"),
        template: _ctx.$slots.lasticon || _ctx.$slots.lastpagelinkicon,
        onClick: _cache[3] || (_cache[3] = function($event) {
          return $options.changePageToLast($event);
        }),
        disabled: $options.isLastPage || $options.empty,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["aria-label", "template", "disabled", "unstyled", "pt"])) : item === "PageLinks" ? (openBlock(), createBlock(_component_PageLinks, {
        key: 4,
        "aria-label": $options.getAriaLabel("pageLabel"),
        value: $options.pageLinks,
        page: $options.page,
        onClick: _cache[4] || (_cache[4] = function($event) {
          return $options.changePageLink($event);
        }),
        pt: _ctx.pt
      }, null, 8, ["aria-label", "value", "page", "pt"])) : item === "CurrentPageReport" ? (openBlock(), createBlock(_component_CurrentPageReport, {
        key: 5,
        "aria-live": "polite",
        template: _ctx.currentPageReportTemplate,
        currentPage: $options.currentPage,
        page: $options.page,
        pageCount: $options.pageCount,
        first: $data.d_first,
        rows: $data.d_rows,
        totalRecords: _ctx.totalRecords,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["template", "currentPage", "page", "pageCount", "first", "rows", "totalRecords", "unstyled", "pt"])) : item === "RowsPerPageDropdown" && _ctx.rowsPerPageOptions ? (openBlock(), createBlock(_component_RowsPerPageDropdown, {
        key: 6,
        "aria-label": $options.getAriaLabel("rowsPerPageLabel"),
        rows: $data.d_rows,
        options: _ctx.rowsPerPageOptions,
        onRowsChange: _cache[5] || (_cache[5] = function($event) {
          return $options.onRowChange($event);
        }),
        disabled: $options.empty,
        templates: _ctx.$slots,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["aria-label", "rows", "options", "disabled", "templates", "unstyled", "pt"])) : item === "JumpToPageDropdown" ? (openBlock(), createBlock(_component_JumpToPageDropdown, {
        key: 7,
        "aria-label": $options.getAriaLabel("jumpToPageDropdownLabel"),
        page: $options.page,
        pageCount: $options.pageCount,
        onPageChange: _cache[6] || (_cache[6] = function($event) {
          return $options.changePage($event);
        }),
        disabled: $options.empty,
        templates: _ctx.$slots,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["aria-label", "page", "pageCount", "disabled", "templates", "unstyled", "pt"])) : item === "JumpToPageInput" ? (openBlock(), createBlock(_component_JumpToPageInput, {
        key: 8,
        page: $options.currentPage,
        onPageChange: _cache[7] || (_cache[7] = function($event) {
          return $options.changePage($event);
        }),
        disabled: $options.empty,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["page", "disabled", "unstyled", "pt"])) : createCommentVNode("", true)], 64);
    }), 128))], 16), _ctx.$slots.end ? (openBlock(), createElementBlock("div", mergeProps({
      key: 1,
      "class": _ctx.cx("contentEnd"),
      ref_for: true
    }, _ctx.ptm("contentEnd")), [renderSlot(_ctx.$slots, "end", {
      state: $options.currentState
    })], 16)) : createCommentVNode("", true)], 16);
  }), 128))], 16)) : createCommentVNode("", true);
}
script$r.render = render$q;
var theme$6 = function theme29(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-datatable {\n    position: relative;\n}\n\n.p-datatable-table {\n    border-spacing: 0;\n    width: 100%;\n}\n\n.p-datatable-scrollable > .p-datatable-table-container {\n    position: relative;\n}\n\n.p-datatable-scrollable-table > .p-datatable-thead {\n    top: 0;\n    z-index: 1;\n}\n\n.p-datatable-scrollable-table > .p-datatable-frozen-tbody {\n    position: sticky;\n    z-index: 1;\n}\n\n.p-datatable-scrollable-table>.p-datatable-tfoot {\n    bottom: 0;\n    z-index: 1;\n}\n\n.p-datatable-scrollable .p-datatable-frozen-column {\n    position: sticky;\n    background: inherit;\n}\n\n.p-datatable-scrollable th.p-datatable-frozen-column {\n    z-index: 1;\n}\n\n.p-datatable-scrollable > .p-datatable-table-container > .p-datatable-table > .p-datatable-thead,\n.p-datatable-scrollable > .p-datatable-table-container > .p-virtualscroller > .p-datatable-table > .p-datatable-thead {\n    background: ".concat(dt3("datatable.header.cell.background"), ";\n}\n\n.p-datatable-scrollable > .p-datatable-table-container > .p-datatable-table > .p-datatable-tfoot,\n.p-datatable-scrollable > .p-datatable-table-container > .p-virtualscroller > .p-datatable-table > .p-datatable-tfoot {\n    background: ").concat(dt3("datatable.footer.cell.background"), ";\n}\n\n.p-datatable-flex-scrollable {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.p-datatable-flex-scrollable > .p-datatable-table-container {\n    display: flex;\n    flex-direction: column;\n    flex: 1;\n    height: 100%;\n}\n\n.p-datatable-scrollable-table > .p-datatable-tbody > .p-datatable-row-group-header {\n    position: sticky;\n    z-index: 1;\n}\n\n.p-datatable-resizable-table > .p-datatable-thead > tr > th,\n.p-datatable-resizable-table > .p-datatable-tfoot > tr > td,\n.p-datatable-resizable-table > .p-datatable-tbody > tr > td {\n    overflow: hidden;\n    white-space: nowrap;\n}\n\n.p-datatable-resizable-table > .p-datatable-thead > tr > th.p-datatable-resizable-column:not(.p-datatable-frozen-column) {\n    background-clip: padding-box;\n    position: relative;\n}\n\n.p-datatable-resizable-table-fit > .p-datatable-thead > tr > th.p-datatable-resizable-column:last-child .p-datatable-column-resizer {\n    display: none;\n}\n\n.p-datatable-column-resizer {\n    display: block;\n    position: absolute;\n    top: 0;\n    right: 0;\n    margin: 0;\n    width: ").concat(dt3("datatable.column.resizer.width"), ";\n    height: 100%;\n    padding: 0px;\n    cursor: col-resize;\n    border: 1px solid transparent;\n}\n\n.p-datatable-column-header-content {\n    display: flex;\n    align-items: center;\n    gap: ").concat(dt3("datatable.header.cell.gap"), ";\n}\n\n.p-datatable-column-resize-indicator {\n    width: ").concat(dt3("datatable.resize.indicator.width"), ";\n    position: absolute;\n    z-index: 10;\n    display: none;\n    background: ").concat(dt3("datatable.resize.indicator.color"), ";\n}\n\n.p-datatable-row-reorder-indicator-up,\n.p-datatable-row-reorder-indicator-down {\n    position: absolute;\n    display: none;\n}\n\n.p-datatable-reorderable-column,\n.p-datatable-reorderable-row-handle {\n    cursor: move;\n}\n\n.p-datatable-mask {\n    position: absolute;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 2;\n}\n\n.p-datatable-inline-filter {\n    display: flex;\n    align-items: center;\n    width: 100%;\n    gap: ").concat(dt3("datatable.filter.inline.gap"), ";\n}\n\n.p-datatable-inline-filter .p-datatable-filter-element-container {\n    flex: 1 1 auto;\n    width: 1%;\n}\n\n.p-datatable-filter-overlay {\n    background: ").concat(dt3("datatable.filter.overlay.select.background"), ";\n    color: ").concat(dt3("datatable.filter.overlay.select.color"), ";\n    border: 1px solid ").concat(dt3("datatable.filter.overlay.select.border.color"), ";\n    border-radius: ").concat(dt3("datatable.filter.overlay.select.border.radius"), ";\n    box-shadow: ").concat(dt3("datatable.filter.overlay.select.shadow"), ";\n    min-width: 12.5rem;\n}\n\n.p-datatable-filter-constraint-list {\n    margin: 0;\n    list-style: none;\n    display: flex;\n    flex-direction: column;\n    padding: ").concat(dt3("datatable.filter.constraint.list.padding"), ";\n    gap: ").concat(dt3("datatable.filter.constraint.list.gap"), ";\n}\n\n.p-datatable-filter-constraint {\n    padding: ").concat(dt3("datatable.filter.constraint.padding"), ";\n    color: ").concat(dt3("datatable.filter.constraint.color"), ";\n    border-radius: ").concat(dt3("datatable.filter.constraint.border.radius"), ";\n    cursor: pointer;\n    transition: background ").concat(dt3("datatable.transition.duration"), ", color ").concat(dt3("datatable.transition.duration"), ", border-color ").concat(dt3("datatable.transition.duration"), ",\n        box-shadow ").concat(dt3("datatable.transition.duration"), ";\n}\n\n.p-datatable-filter-constraint-selected {\n    background: ").concat(dt3("datatable.filter.constraint.selected.background"), ";\n    color: ").concat(dt3("datatable.filter.constraint.selected.color"), ";\n}\n\n.p-datatable-filter-constraint:not(.p-datatable-filter-constraint-selected):not(.p-disabled):hover {\n    background: ").concat(dt3("datatable.filter.constraint.focus.background"), ";\n    color: ").concat(dt3("datatable.filter.constraint.focus.color"), ";\n}\n\n.p-datatable-filter-constraint:focus-visible {\n    outline: 0 none;\n    background: ").concat(dt3("datatable.filter.constraint.focus.background"), ";\n    color: ").concat(dt3("datatable.filter.constraint.focus.color"), ";\n}\n\n.p-datatable-filter-constraint-selected:focus-visible {\n    outline: 0 none;\n    background: ").concat(dt3("datatable.filter.constraint.selected.focus.background"), ";\n    color: ").concat(dt3("datatable.filter.constraint.selected.focus.color"), ";\n}\n\n.p-datatable-filter-constraint-separator {\n    border-top: 1px solid ").concat(dt3("datatable.filter.constraint.separator.border.color"), ";\n}\n\n.p-datatable-popover-filter {\n    display: inline-flex;\n    margin-left: auto;\n}\n\n.p-datatable-filter-overlay-popover {\n    background: ").concat(dt3("datatable.filter.overlay.popover.background"), ";\n    color: ").concat(dt3("datatable.filter.overlay.popover.color"), ";\n    border: 1px solid ").concat(dt3("datatable.filter.overlay.popover.border.color"), ";\n    border-radius: ").concat(dt3("datatable.filter.overlay.popover.border.radius"), ";\n    box-shadow: ").concat(dt3("datatable.filter.overlay.popover.shadow"), ";\n    min-width: 12.5rem;\n    padding: ").concat(dt3("datatable.filter.overlay.popover.padding"), ";\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("datatable.filter.overlay.popover.gap"), ";\n}\n\n.p-datatable-filter-operator-dropdown {\n    width: 100%;\n}\n\n.p-datatable-filter-rule-list,\n.p-datatable-filter-rule {\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("datatable.filter.overlay.popover.gap"), ";\n}\n\n.p-datatable-filter-rule {\n    border-bottom: 1px solid ").concat(dt3("datatable.filter.rule.border.color"), ";\n}\n\n.p-datatable-filter-rule:last-child {\n    border-bottom: 0 none;\n}\n\n.p-datatable-filter-add-rule-button {\n    width: 100%;\n}\n\n.p-datatable-filter-remove-button {\n    width: 100%;\n}\n\n.p-datatable-filter-buttonbar {\n    padding: 0;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.p-datatable-virtualscroller-spacer {\n    display: flex;\n}\n\n.p-datatable .p-virtualscroller .p-virtualscroller-loading {\n    transform: none !important;\n    min-height: 0;\n    position: sticky;\n    top: 0;\n    left: 0;\n}\n\n.p-datatable-paginator-top {\n    border-color: ").concat(dt3("datatable.paginator.top.border.color"), ";\n    border-style: solid;\n    border-width: ").concat(dt3("datatable.paginator.top.border.width"), ";\n}\n\n.p-datatable-paginator-bottom {\n    border-color: ").concat(dt3("datatable.paginator.bottom.border.color"), ";\n    border-style: solid;\n    border-width: ").concat(dt3("datatable.paginator.bottom.border.width"), ";\n}\n\n.p-datatable-header {\n    background: ").concat(dt3("datatable.header.background"), ";\n    color: ").concat(dt3("datatable.header.color"), ";\n    border-color: ").concat(dt3("datatable.header.border.color"), ";\n    border-style: solid;\n    border-width: ").concat(dt3("datatable.header.border.width"), ";\n    padding: ").concat(dt3("datatable.header.padding"), ";\n}\n\n.p-datatable-footer {\n    background: ").concat(dt3("datatable.footer.background"), ";\n    color: ").concat(dt3("datatable.footer.color"), ";\n    border-color: ").concat(dt3("datatable.footer.border.color"), ";\n    border-style: solid;\n    border-width: ").concat(dt3("datatable.footer.border.width"), ";\n    padding: ").concat(dt3("datatable.footer.padding"), ";\n}\n\n.p-datatable-header-cell {\n    padding: ").concat(dt3("datatable.header.cell.padding"), ";\n    background: ").concat(dt3("datatable.header.cell.background"), ";\n    border-color: ").concat(dt3("datatable.header.cell.border.color"), ";\n    border-style: solid;\n    border-width: 0 0 1px 0;\n    color: ").concat(dt3("datatable.header.cell.color"), ";\n    font-weight: normal;\n    text-align: left;\n    transition: background ").concat(dt3("datatable.transition.duration"), ", color ").concat(dt3("datatable.transition.duration"), ", border-color ").concat(dt3("datatable.transition.duration"), ",\n            outline-color ").concat(dt3("datatable.transition.duration"), ", box-shadow ").concat(dt3("datatable.transition.duration"), ";\n}\n\n.p-datatable-column-title {\n    font-weight: ").concat(dt3("datatable.column.title.font.weight"), ";\n}\n\n.p-datatable-tbody > tr {\n    outline-color: transparent;\n    background: ").concat(dt3("datatable.row.background"), ";\n    color: ").concat(dt3("datatable.row.color"), ";\n    transition: background ").concat(dt3("datatable.transition.duration"), ", color ").concat(dt3("datatable.transition.duration"), ", border-color ").concat(dt3("datatable.transition.duration"), ",\n            outline-color ").concat(dt3("datatable.transition.duration"), ", box-shadow ").concat(dt3("datatable.transition.duration"), ";\n}\n\n.p-datatable-tbody > tr > td {\n    text-align: left;\n    border-color: ").concat(dt3("datatable.body.cell.border.color"), ";\n    border-style: solid;\n    border-width: 0 0 1px 0;\n    padding: ").concat(dt3("datatable.body.cell.padding"), ";\n}\n\n.p-datatable-hoverable .p-datatable-tbody > tr:not(.p-datatable-row-selected):hover {\n    background: ").concat(dt3("datatable.row.hover.background"), ";\n    color: ").concat(dt3("datatable.row.hover.color"), ";\n}\n\n.p-datatable-tbody > tr.p-datatable-row-selected {\n    background: ").concat(dt3("datatable.row.selected.background"), ";\n    color: ").concat(dt3("datatable.row.selected.color"), ";\n}\n\n.p-datatable-tbody > tr:has(+ .p-datatable-row-selected) > td {\n    border-bottom-color: ").concat(dt3("datatable.body.cell.selected.border.color"), ";\n}\n\n.p-datatable-tbody > tr.p-datatable-row-selected > td {\n    border-bottom-color: ").concat(dt3("datatable.body.cell.selected.border.color"), ";\n}\n\n.p-datatable-tbody > tr:focus-visible,\n.p-datatable-tbody > tr.p-datatable-contextmenu-row-selected {\n    box-shadow: ").concat(dt3("datatable.body.cell.focus.ring.shadow"), ";\n    outline: ").concat(dt3("datatable.body.cell.focus.ring.width"), " ").concat(dt3("datatable.body.cell.focus.ring.style"), " ").concat(dt3("datatable.body.cell.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("datatable.body.cell.focus.ring.offset"), ";\n}\n\n.p-datatable-tfoot > tr > td {\n    text-align: left;\n    padding: ").concat(dt3("datatable.footer.cell.padding"), ";\n    border-color: ").concat(dt3("datatable.footer.cell.border.color"), ";\n    border-style: solid;\n    border-width: 0 0 1px 0;\n    color: ").concat(dt3("datatable.footer.cell.color"), ";\n    background: ").concat(dt3("datatable.footer.cell.background"), ";\n}\n\n.p-datatable-column-footer {\n    font-weight: ").concat(dt3("datatable.column.footer.font.weight"), ";\n}\n\n.p-datatable-sortable-column {\n    cursor: pointer;\n    user-select: none;\n    outline-color: transparent;\n}\n\n.p-datatable-column-title,\n.p-datatable-sort-icon,\n.p-datatable-sort-badge {\n    vertical-align: middle;\n}\n\n.p-datatable-sort-icon {\n    color: ").concat(dt3("datatable.sort.icon.color"), ";\n    transition: color ").concat(dt3("datatable.transition.duration"), ";\n}\n\n.p-datatable-sortable-column:not(.p-datatable-column-sorted):hover {\n    background: ").concat(dt3("datatable.header.cell.hover.background"), ";\n    color: ").concat(dt3("datatable.header.cell.hover.color"), ";\n}\n\n.p-datatable-sortable-column:not(.p-datatable-column-sorted):hover .p-datatable-sort-icon {\n    color: ").concat(dt3("datatable.sort.icon.hover.color"), ";\n}\n\n.p-datatable-column-sorted {\n    background: ").concat(dt3("datatable.header.cell.selected.background"), ";\n    color: ").concat(dt3("datatable.header.cell.selected.color"), ";\n}\n\n.p-datatable-column-sorted .p-datatable-sort-icon {\n    color: ").concat(dt3("datatable.header.cell.selected.color"), ";\n}\n\n.p-datatable-sortable-column:focus-visible {\n    box-shadow: ").concat(dt3("datatable.header.cell.focus.ring.shadow"), ";\n    outline: ").concat(dt3("datatable.header.cell.focus.ring.width"), " ").concat(dt3("datatable.header.cell.focus.ring.style"), " ").concat(dt3("datatable.header.cell.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("datatable.header.cell.focus.ring.offset"), ";\n}\n\n.p-datatable-hoverable .p-datatable-selectable-row {\n    cursor: pointer;\n}\n\n.p-datatable-tbody > tr.p-datatable-dragpoint-top > td {\n    box-shadow: inset 0 2px 0 0 ").concat(dt3("datatable.drop.point.color"), ";\n}\n\n.p-datatable-tbody > tr.p-datatable-dragpoint-bottom > td {\n    box-shadow: inset 0 -2px 0 0 ").concat(dt3("datatable.drop.point.color"), ";\n}\n\n.p-datatable-loading-icon {\n    font-size: ").concat(dt3("datatable.loading.icon.size"), ";\n    width: ").concat(dt3("datatable.loading.icon.size"), ";\n    height: ").concat(dt3("datatable.loading.icon.size"), ";\n}\n\n.p-datatable-gridlines .p-datatable-header {\n    border-width: 1px 1px 0 1px;\n}\n\n.p-datatable-gridlines .p-datatable-footer {\n    border-width: 0 1px 1px 1px;\n}\n\n.p-datatable-gridlines .p-datatable-paginator-top {\n    border-width: 1px 1px 0 1px;\n}\n\n.p-datatable-gridlines .p-datatable-paginator-bottom {\n    border-width: 0 1px 1px 1px;\n}\n\n.p-datatable-gridlines .p-datatable-thead > tr > th {\n    border-width: 1px 0 1px 1px;\n}\n\n.p-datatable-gridlines .p-datatable-thead > tr > th:last-child {\n    border-width: 1px;\n}\n\n.p-datatable-gridlines .p-datatable-tbody > tr > td {\n    border-width: 1px 0 0 1px;\n}\n\n.p-datatable-gridlines .p-datatable-tbody > tr > td:last-child {\n    border-width: 1px 1px 0 1px;\n}\n\np-datatable-gridlines .p-datatable-tbody > tr:last-child > td {\n    border-width: 1px 0 1px 1px;\n}\n\n.p-datatable-gridlines .p-datatable-tbody > tr:last-child > td:last-child {\n    border-width: 1px;\n}\n\n.p-datatable-gridlines .p-datatable-tfoot > tr > td {\n    border-width: 1px 0 1px 1px;\n}\n\n.p-datatable-gridlines .p-datatable-tfoot > tr > td:last-child {\n    border-width: 1px 1px 1px 1px;\n}\n\n.p-datatable.p-datatable-gridlines .p-datatable-thead + .p-datatable-tfoot > tr > td {\n    border-width: 0 0 1px 1px;\n}\n\n.p-datatable.p-datatable-gridlines .p-datatable-thead + .p-datatable-tfoot > tr > td:last-child {\n    border-width: 0 1px 1px 1px;\n}\n\n.p-datatable.p-datatable-gridlines:has(.p-datatable-thead):has(.p-datatable-tbody) .p-datatable-tbody > tr > td {\n    border-width: 0 0 1px 1px;\n}\n\n.p-datatable.p-datatable-gridlines:has(.p-datatable-thead):has(.p-datatable-tbody) .p-datatable-tbody > tr > td:last-child {\n    border-width: 0 1px 1px 1px;\n}\n\n.p-datatable.p-datatable-gridlines:has(.p-datatable-tbody):has(.p-datatable-tfoot) .p-datatable-tbody > tr:last-child > td {\n    border-width: 0 0 0 1px;\n}\n\n.p-datatable.p-datatable-gridlines:has(.p-datatable-tbody):has(.p-datatable-tfoot) .p-datatable-tbody > tr:last-child > td:last-child {\n    border-width: 0 1px 0 1px;\n}\n\n.p-datatable.p-datatable-striped .p-datatable-tbody > tr.p-row-odd {\n    background: ").concat(dt3("datatable.row.striped.background"), ";\n}\n\n.p-datatable.p-datatable-striped .p-datatable-tbody > tr.p-row-odd.p-datatable-row-selected {\n    background: ").concat(dt3("datatable.row.selected.background"), ";\n    color: ").concat(dt3("datatable.row.selected.color"), ";\n}\n\n.p-datatable.p-datatable-sm .p-datatable-header {\n    padding: 0.375rem 0.5rem;\n}\n\n.p-datatable.p-datatable-sm .p-datatable-thead > tr > th {\n    padding: 0.375rem 0.5rem;\n}\n\n.p-datatable.p-datatable-sm .p-datatable-tbody > tr > td {\n    padding: 0.375rem 0.5rem;\n}\n\n.p-datatable.p-datatable-sm .p-datatable-tfoot > tr > td {\n    padding: 0.375rem 0.5rem;\n}\n\n.p-datatable.p-datatable-sm .p-datatable-footer {\n    padding: 0.375rem 0.5rem;\n}\n\n.p-datatable.p-datatable-lg .p-datatable-header {\n    padding: 0.9375rem 1.25rem;\n}\n\n.p-datatable.p-datatable-lg .p-datatable-thead > tr > th {\n    padding: 0.9375rem 1.25rem;\n}\n\n.p-datatable.p-datatable-lg .p-datatable-tbody>tr>td {\n    padding: 0.9375rem 1.25rem;\n}\n\n.p-datatable.p-datatable-lg .p-datatable-tfoot>tr>td {\n    padding: 0.9375rem 1.25rem;\n}\n\n.p-datatable.p-datatable-lg .p-datatable-footer {\n    padding: 0.9375rem 1.25rem;\n}\n\n.p-datatable-row-toggle-button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    width: ").concat(dt3("datatable.row.toggle.button.size"), ";\n    height: ").concat(dt3("datatable.row.toggle.button.size"), ";\n    color: ").concat(dt3("datatable.row.toggle.button.color"), ";\n    border: 0 none;\n    background: transparent;\n    cursor: pointer;\n    border-radius: ").concat(dt3("datatable.row.toggle.button.border.radius"), ";\n    transition: background ").concat(dt3("datatable.transition.duration"), ", color ").concat(dt3("datatable.transition.duration"), ", border-color ").concat(dt3("datatable.transition.duration"), ",\n            outline-color ").concat(dt3("datatable.transition.duration"), ", box-shadow ").concat(dt3("datatable.transition.duration"), ";\n    outline-color: transparent;\n    user-select: none;\n}\n\n.p-datatable-row-toggle-button:enabled:hover {\n    color: ").concat(dt3("datatable.row.toggle.button.hover.color"), ";\n    background: ").concat(dt3("datatable.row.toggle.button.hover.background"), ";\n}\n\n.p-datatable-tbody > tr.p-datatable-row-selected .p-datatable-row-toggle-button:hover {\n    background: ").concat(dt3("datatable.row.toggle.button.selected.hover.background"), ";\n    ").concat(dt3("datatable.row.toggle.button.selected.hover.color"), ";\n}\n\n.p-datatable-row-toggle-button:focus-visible {\n    box-shadow: ").concat(dt3("datatable.row.toggle.button.focus.ring.shadow"), ";\n    outline: ").concat(dt3("datatable.row.toggle.button.focus.ring.width"), " ").concat(dt3("datatable.row.toggle.button.focus.ring.style"), " ").concat(dt3("datatable.row.toggle.button.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("datatable.row.toggle.button.focus.ring.offset"), ";\n}\n");
};
var classes$6 = {
  root: function root21(_ref2) {
    var props = _ref2.props;
    return ["p-datatable p-component", {
      "p-datatable-hoverable": props.rowHover || props.selectionMode,
      "p-datatable-resizable": props.resizableColumns,
      "p-datatable-resizable-fit": props.resizableColumns && props.columnResizeMode === "fit",
      "p-datatable-scrollable": props.scrollable,
      "p-datatable-flex-scrollable": props.scrollable && props.scrollHeight === "flex",
      "p-datatable-striped": props.stripedRows,
      "p-datatable-gridlines": props.showGridlines,
      "p-datatable-sm": props.size === "small",
      "p-datatable-lg": props.size === "large"
    }];
  },
  mask: "p-datatable-mask p-overlay-mask",
  loadingIcon: "p-datatable-loading-icon",
  header: "p-datatable-header",
  pcPaginator: function pcPaginator(_ref3) {
    var position = _ref3.position;
    return "p-datatable-paginator-" + position;
  },
  tableContainer: "p-datatable-table-container",
  table: function table(_ref4) {
    var props = _ref4.props;
    return ["p-datatable-table", {
      "p-datatable-scrollable-table": props.scrollable,
      "p-datatable-resizable-table": props.resizableColumns,
      "p-datatable-resizable-table-fit": props.resizableColumns && props.columnResizeMode === "fit"
    }];
  },
  thead: "p-datatable-thead",
  headerCell: function headerCell(_ref5) {
    var instance = _ref5.instance, props = _ref5.props, column = _ref5.column;
    return column && !instance.columnProp(column, "hidden") && (props.rowGroupMode !== "subheader" || props.groupRowsBy !== instance.columnProp(column, "field")) ? ["p-datatable-header-cell", {
      "p-datatable-frozen-column": instance.columnProp(column, "frozen")
    }] : ["p-datatable-header-cell", {
      "p-datatable-sortable-column": instance.columnProp("sortable"),
      "p-datatable-resizable-column": instance.resizableColumns,
      "p-datatable-column-sorted": instance.isColumnSorted(),
      "p-datatable-frozen-column": instance.columnProp("frozen"),
      "p-datatable-reorderable-column": props.reorderableColumns
    }];
  },
  columnResizer: "p-datatable-column-resizer",
  columnHeaderContent: "p-datatable-column-header-content",
  columnTitle: "p-datatable-column-title",
  columnFooter: "p-datatable-column-footer",
  sortIcon: "p-datatable-sort-icon",
  pcSortBadge: "p-datatable-sort-badge",
  filter: function filter3(_ref6) {
    var props = _ref6.props;
    return ["p-datatable-filter", {
      "p-datatable-inline-filter": props.display === "row",
      "p-datatable-popover-filter": props.display === "menu"
    }];
  },
  filterElementContainer: "p-datatable-filter-element-container",
  pcColumnFilterButton: "p-datatable-column-filter-button",
  pcColumnFilterClearButton: "p-datatable-column-filter-clear-button",
  filterOverlay: function filterOverlay(_ref7) {
    _ref7.instance;
    var props = _ref7.props;
    return ["p-datatable-filter-overlay p-component", {
      "p-datatable-filter-overlay-popover": props.display === "menu"
    }];
  },
  filterConstraintList: "p-datatable-filter-constraint-list",
  filterConstraint: function filterConstraint(_ref8) {
    var instance = _ref8.instance, matchMode = _ref8.matchMode;
    return ["p-datatable-filter-constraint", {
      "p-datatable-filter-constraint-selected": matchMode && instance.isRowMatchModeSelected(matchMode.value)
    }];
  },
  filterConstraintSeparator: "p-datatable-filter-constraint-separator",
  filterOperator: "p-datatable-filter-operator",
  pcFilterOperatorDropdown: "p-datatable-filter-operator-dropdown",
  filterRuleList: "p-datatable-filter-rule-list",
  filterRule: "p-datatable-filter-rule",
  pcFilterConstraintDropdown: "p-datatable-filter-constraint-dropdown",
  pcFilterRemoveRuleButton: "p-datatable-filter-remove-rule-button",
  pcFilterAddRuleButton: "p-datatable-filter-add-rule-button",
  filterButtonbar: "p-datatable-filter-buttonbar",
  pcFilterClearButton: "p-datatable-filter-clear-button",
  pcFilterApplyButton: "p-datatable-filter-apply-button",
  tbody: function tbody(_ref9) {
    var props = _ref9.props;
    return props.frozenRow ? "p-datatable-tbody p-datatable-frozen-tbody" : "p-datatable-tbody";
  },
  rowGroupHeader: "p-datatable-row-group-header",
  rowToggleButton: "p-datatable-row-toggle-button",
  rowToggleIcon: "p-datatable-row-toggle-icon",
  row: function row(_ref10) {
    var instance = _ref10.instance, props = _ref10.props, index2 = _ref10.index, columnSelectionMode = _ref10.columnSelectionMode;
    var rowStyleClass = [];
    if (props.selectionMode) {
      rowStyleClass.push("p-datatable-selectable-row");
    }
    if (props.selection) {
      rowStyleClass.push({
        "p-datatable-row-selected": columnSelectionMode ? instance.isSelected && instance.$parentInstance.$parentInstance.highlightOnSelect : instance.isSelected
      });
    }
    if (props.contextMenuSelection) {
      rowStyleClass.push({
        "p-datatable-contextmenu-row-selected": instance.isSelectedWithContextMenu
      });
    }
    rowStyleClass.push(index2 % 2 === 0 ? "p-row-even" : "p-row-odd");
    return rowStyleClass;
  },
  rowExpansion: "p-datatable-row-expansion",
  rowGroupFooter: "p-datatable-row-group-footer",
  emptyMessage: "p-datatable-empty-message",
  bodyCell: function bodyCell(_ref11) {
    var instance = _ref11.instance;
    return [{
      "p-datatable-frozen-column": instance.columnProp("frozen")
    }];
  },
  reorderableRowHandle: "p-datatable-reorderable-row-handle",
  pcRowEditorInit: "p-datatable-row-editor-init",
  pcRowEditorSave: "p-datatable-row-editor-save",
  pcRowEditorCancel: "p-datatable-row-editor-cancel",
  tfoot: "p-datatable-tfoot",
  footerCell: function footerCell(_ref12) {
    var instance = _ref12.instance;
    return [{
      "p-datatable-frozen-column": instance.columnProp("frozen")
    }];
  },
  virtualScrollerSpacer: "p-datatable-virtualscroller-spacer",
  footer: "p-datatable-footer",
  columnResizeIndicator: "p-datatable-column-resize-indicator",
  rowReorderIndicatorUp: "p-datatable-row-reorder-indicator-up",
  rowReorderIndicatorDown: "p-datatable-row-reorder-indicator-down"
};
var inlineStyles$1 = {
  tableContainer: {
    overflow: "auto"
  },
  thead: {
    position: "sticky"
  },
  tfoot: {
    position: "sticky"
  }
};
var DataTableStyle = BaseStyle.extend({
  name: "datatable",
  theme: theme$6,
  classes: classes$6,
  inlineStyles: inlineStyles$1
});
var script$q = {
  name: "ChevronRightIcon",
  "extends": script$15
};
var _hoisted_1$n = /* @__PURE__ */ createBaseVNode("path", {
  d: "M4.38708 13C4.28408 13.0005 4.18203 12.9804 4.08691 12.9409C3.99178 12.9014 3.9055 12.8433 3.83313 12.7701C3.68634 12.6231 3.60388 12.4238 3.60388 12.2161C3.60388 12.0084 3.68634 11.8091 3.83313 11.6622L8.50507 6.99022L3.83313 2.31827C3.69467 2.16968 3.61928 1.97313 3.62287 1.77005C3.62645 1.56698 3.70872 1.37322 3.85234 1.22959C3.99596 1.08597 4.18972 1.00371 4.3928 1.00012C4.59588 0.996539 4.79242 1.07192 4.94102 1.21039L10.1669 6.43628C10.3137 6.58325 10.3962 6.78249 10.3962 6.99022C10.3962 7.19795 10.3137 7.39718 10.1669 7.54416L4.94102 12.7701C4.86865 12.8433 4.78237 12.9014 4.68724 12.9409C4.59212 12.9804 4.49007 13.0005 4.38708 13Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$j = [_hoisted_1$n];
function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$j, 16);
}
script$q.render = render$p;
var script$p = {
  name: "BarsIcon",
  "extends": script$15
};
var _hoisted_1$m = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M13.3226 3.6129H0.677419C0.497757 3.6129 0.325452 3.54152 0.198411 3.41448C0.0713707 3.28744 0 3.11514 0 2.93548C0 2.75581 0.0713707 2.58351 0.198411 2.45647C0.325452 2.32943 0.497757 2.25806 0.677419 2.25806H13.3226C13.5022 2.25806 13.6745 2.32943 13.8016 2.45647C13.9286 2.58351 14 2.75581 14 2.93548C14 3.11514 13.9286 3.28744 13.8016 3.41448C13.6745 3.54152 13.5022 3.6129 13.3226 3.6129ZM13.3226 7.67741H0.677419C0.497757 7.67741 0.325452 7.60604 0.198411 7.479C0.0713707 7.35196 0 7.17965 0 6.99999C0 6.82033 0.0713707 6.64802 0.198411 6.52098C0.325452 6.39394 0.497757 6.32257 0.677419 6.32257H13.3226C13.5022 6.32257 13.6745 6.39394 13.8016 6.52098C13.9286 6.64802 14 6.82033 14 6.99999C14 7.17965 13.9286 7.35196 13.8016 7.479C13.6745 7.60604 13.5022 7.67741 13.3226 7.67741ZM0.677419 11.7419H13.3226C13.5022 11.7419 13.6745 11.6706 13.8016 11.5435C13.9286 11.4165 14 11.2442 14 11.0645C14 10.8848 13.9286 10.7125 13.8016 10.5855C13.6745 10.4585 13.5022 10.3871 13.3226 10.3871H0.677419C0.497757 10.3871 0.325452 10.4585 0.198411 10.5855C0.0713707 10.7125 0 10.8848 0 11.0645C0 11.2442 0.0713707 11.4165 0.198411 11.5435C0.325452 11.6706 0.497757 11.7419 0.677419 11.7419Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$i = [_hoisted_1$m];
function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$i, 16);
}
script$p.render = render$o;
var script$o = {
  name: "PencilIcon",
  "extends": script$15
};
var _hoisted_1$l = /* @__PURE__ */ createBaseVNode("path", {
  d: "M0.609628 13.959C0.530658 13.9599 0.452305 13.9451 0.379077 13.9156C0.305849 13.8861 0.239191 13.8424 0.18294 13.787C0.118447 13.7234 0.0688234 13.6464 0.0376166 13.5614C0.00640987 13.4765 -0.00560954 13.3857 0.00241768 13.2956L0.25679 10.1501C0.267698 10.0041 0.331934 9.86709 0.437312 9.76516L9.51265 0.705715C10.0183 0.233014 10.6911 -0.0203041 11.3835 0.00127367C12.0714 0.00660201 12.7315 0.27311 13.2298 0.746671C13.7076 1.23651 13.9824 1.88848 13.9992 2.57201C14.0159 3.25554 13.7733 3.92015 13.32 4.4327L4.23648 13.5331C4.13482 13.6342 4.0017 13.6978 3.85903 13.7133L0.667067 14L0.609628 13.959ZM1.43018 10.4696L1.25787 12.714L3.50619 12.5092L12.4502 3.56444C12.6246 3.35841 12.7361 3.10674 12.7714 2.83933C12.8067 2.57193 12.7644 2.30002 12.6495 2.05591C12.5346 1.8118 12.3519 1.60575 12.1231 1.46224C11.8943 1.31873 11.6291 1.2438 11.3589 1.24633C11.1813 1.23508 11.0033 1.25975 10.8355 1.31887C10.6677 1.37798 10.5136 1.47033 10.3824 1.59036L1.43018 10.4696Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$h = [_hoisted_1$l];
function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$h, 16);
}
script$o.render = render$n;
var script$n = {
  name: "MinusIcon",
  "extends": script$15
};
var _hoisted_1$k = /* @__PURE__ */ createBaseVNode("path", {
  d: "M13.2222 7.77778H0.777778C0.571498 7.77778 0.373667 7.69584 0.227806 7.54998C0.0819442 7.40412 0 7.20629 0 7.00001C0 6.79373 0.0819442 6.5959 0.227806 6.45003C0.373667 6.30417 0.571498 6.22223 0.777778 6.22223H13.2222C13.4285 6.22223 13.6263 6.30417 13.7722 6.45003C13.9181 6.5959 14 6.79373 14 7.00001C14 7.20629 13.9181 7.40412 13.7722 7.54998C13.6263 7.69584 13.4285 7.77778 13.2222 7.77778Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$g = [_hoisted_1$k];
function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$g, 16);
}
script$n.render = render$m;
var theme$5 = function theme30(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-checkbox {\n    position: relative;\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    width: ".concat(dt3("checkbox.width"), ";\n    height: ").concat(dt3("checkbox.height"), ";\n}\n\n.p-checkbox-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border: 1px solid transparent;\n    border-radius: ").concat(dt3("checkbox.border.radius"), ";\n}\n\n.p-checkbox-box {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: ").concat(dt3("checkbox.border.radius"), ";\n    border: 1px solid ").concat(dt3("checkbox.border.color"), ";\n    background: ").concat(dt3("checkbox.background"), ";\n    width: ").concat(dt3("checkbox.width"), ";\n    height: ").concat(dt3("checkbox.height"), ";\n    transition: background ").concat(dt3("checkbox.transition.duration"), ", color ").concat(dt3("checkbox.transition.duration"), ", border-color ").concat(dt3("checkbox.transition.duration"), ", box-shadow ").concat(dt3("checkbox.transition.duration"), ", outline-color ").concat(dt3("checkbox.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("checkbox.shadow"), ";\n}\n\n.p-checkbox-icon {\n    transition-duration: ").concat(dt3("checkbox.transition.duration"), ";\n    color: ").concat(dt3("checkbox.icon.color"), ";\n    font-size: ").concat(dt3("checkbox.icon.size"), ";\n    width: ").concat(dt3("checkbox.icon.size"), ";\n    height: ").concat(dt3("checkbox.icon.size"), ";\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.hover.border.color"), ";\n}\n\n.p-checkbox-checked .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.checked.border.color"), ";\n    background: ").concat(dt3("checkbox.checked.background"), ";\n}\n\n.p-checkbox-checked .p-checkbox-icon {\n    color: ").concat(dt3("checkbox.icon.checked.color"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    background: ").concat(dt3("checkbox.checked.hover.background"), ";\n    border-color: ").concat(dt3("checkbox.checked.hover.border.color"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-icon {\n    color: ").concat(dt3("checkbox.icon.checked.hover.color"), ";\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.focus.border.color"), ";\n    box-shadow: ").concat(dt3("checkbox.focus.ring.shadow"), ";\n    outline: ").concat(dt3("checkbox.focus.ring.width"), " ").concat(dt3("checkbox.focus.ring.style"), " ").concat(dt3("checkbox.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("checkbox.focus.ring.offset"), ";\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.checked.focus.border.color"), ";\n}\n\n.p-checkbox.p-invalid > .p-checkbox-box {\n    border-color: ").concat(dt3("checkbox.invalid.border.color"), ";\n}\n\n.p-checkbox.p-variant-filled .p-checkbox-box {\n    background: ").concat(dt3("checkbox.filled.background"), ";\n}\n\n.p-checkbox-checked.p-variant-filled .p-checkbox-box {\n    background: ").concat(dt3("checkbox.checked.background"), ";\n}\n\n.p-checkbox-checked.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n    background: ").concat(dt3("checkbox.checked.hover.background"), ";\n}\n\n.p-checkbox.p-disabled {\n    opacity: 1;\n}\n\n.p-checkbox.p-disabled .p-checkbox-box {\n    background: ").concat(dt3("checkbox.disabled.background"), ";\n    border-color: ").concat(dt3("checkbox.checked.disabled.border.color"), ";\n}\n\n.p-checkbox.p-disabled .p-checkbox-box .p-checkbox-icon {\n    color: ").concat(dt3("checkbox.icon.disabled.color"), ";\n}\n");
};
var classes$5 = {
  root: function root22(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-checkbox p-component", {
      "p-checkbox-checked": instance.checked,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled"
    }];
  },
  box: "p-checkbox-box",
  input: "p-checkbox-input",
  icon: "p-checkbox-icon"
};
var CheckboxStyle = BaseStyle.extend({
  name: "checkbox",
  theme: theme$5,
  classes: classes$5
});
var script$1$7 = {
  name: "BaseCheckbox",
  "extends": script$1a,
  props: {
    value: null,
    modelValue: null,
    binary: Boolean,
    name: {
      type: String,
      "default": null
    },
    indeterminate: {
      type: Boolean,
      "default": false
    },
    trueValue: {
      type: null,
      "default": true
    },
    falseValue: {
      type: null,
      "default": false
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    required: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: CheckboxStyle,
  provide: function provide32() {
    return {
      $pcCheckbox: this,
      $parentInstance: this
    };
  }
};
function _toConsumableArray$4(r) {
  return _arrayWithoutHoles$4(r) || _iterableToArray$4(r) || _unsupportedIterableToArray$4(r) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$4(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0;
  }
}
function _iterableToArray$4(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$4(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$4(r);
}
function _arrayLikeToArray$4(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$m = {
  name: "Checkbox",
  "extends": script$1$7,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur", "update:indeterminate"],
  data: function data15() {
    return {
      d_indeterminate: this.indeterminate
    };
  },
  watch: {
    indeterminate: function indeterminate(newValue) {
      this.d_indeterminate = newValue;
    }
  },
  methods: {
    getPTOptions: function getPTOptions15(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          checked: this.checked,
          disabled: this.disabled
        }
      });
    },
    onChange: function onChange7(event2) {
      var _this = this;
      if (!this.disabled && !this.readonly) {
        var newModelValue;
        if (this.binary) {
          newModelValue = this.d_indeterminate ? this.trueValue : this.checked ? this.falseValue : this.trueValue;
        } else {
          if (this.checked || this.d_indeterminate) newModelValue = this.modelValue.filter(function(val) {
            return !equals(val, _this.value);
          });
          else newModelValue = this.modelValue ? [].concat(_toConsumableArray$4(this.modelValue), [this.value]) : [this.value];
        }
        if (this.d_indeterminate) {
          this.d_indeterminate = false;
          this.$emit("update:indeterminate", this.d_indeterminate);
        }
        this.$emit("update:modelValue", newModelValue);
        this.$emit("change", event2);
      }
    },
    onFocus: function onFocus5(event2) {
      this.$emit("focus", event2);
    },
    onBlur: function onBlur5(event2) {
      this.$emit("blur", event2);
    }
  },
  computed: {
    checked: function checked2() {
      return this.d_indeterminate ? false : this.binary ? this.modelValue === this.trueValue : contains(this.value, this.modelValue);
    }
  },
  components: {
    CheckIcon: script$11,
    MinusIcon: script$n
  }
};
var _hoisted_1$j = ["data-p-checked", "data-p-indeterminate", "data-p-disabled"];
var _hoisted_2$f = ["id", "value", "name", "checked", "tabindex", "disabled", "readonly", "required", "aria-labelledby", "aria-label", "aria-invalid", "aria-checked"];
function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_MinusIcon = resolveComponent("MinusIcon");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.checked,
    "data-p-indeterminate": $data.d_indeterminate || void 0,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("input", mergeProps({
    id: _ctx.inputId,
    type: "checkbox",
    "class": [_ctx.cx("input"), _ctx.inputClass],
    style: _ctx.inputStyle,
    value: _ctx.value,
    name: _ctx.name,
    checked: $options.checked,
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    required: _ctx.required,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-invalid": _ctx.invalid || void 0,
    "aria-checked": $data.d_indeterminate ? "mixed" : void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("input")), null, 16, _hoisted_2$f), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("box")
  }, $options.getPTOptions("box")), [renderSlot(_ctx.$slots, "icon", {
    checked: $options.checked,
    indeterminate: $data.d_indeterminate,
    "class": normalizeClass(_ctx.cx("icon"))
  }, function() {
    return [$options.checked ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
      key: 0,
      "class": _ctx.cx("icon")
    }, $options.getPTOptions("icon")), null, 16, ["class"])) : $data.d_indeterminate ? (openBlock(), createBlock(_component_MinusIcon, mergeProps({
      key: 1,
      "class": _ctx.cx("icon")
    }, $options.getPTOptions("icon")), null, 16, ["class"])) : createCommentVNode("", true)];
  })], 16)], 16, _hoisted_1$j);
}
script$m.render = render$l;
var theme$4 = function theme31(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-radiobutton {\n    position: relative;\n    display: inline-flex;\n    user-select: none;\n    vertical-align: bottom;\n    width: ".concat(dt3("radiobutton.width"), ";\n    height: ").concat(dt3("radiobutton.height"), ";\n}\n\n.p-radiobutton-input {\n    cursor: pointer;\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    opacity: 0;\n    z-index: 1;\n    outline: 0 none;\n    border: 1px solid transparent;\n    border-radius: 50%;\n}\n\n.p-radiobutton-box {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: 50%;\n    border: 1px solid ").concat(dt3("radiobutton.border.color"), ";\n    background: ").concat(dt3("radiobutton.background"), ";\n    width: ").concat(dt3("radiobutton.width"), ";\n    height: ").concat(dt3("radiobutton.height"), ";\n    transition: background ").concat(dt3("radiobutton.transition.duration"), ", color ").concat(dt3("radiobutton.transition.duration"), ", border-color ").concat(dt3("radiobutton.transition.duration"), ", box-shadow ").concat(dt3("radiobutton.transition.duration"), ", outline-color ").concat(dt3("radiobutton.transition.duration"), ";\n    outline-color: transparent;\n    box-shadow: ").concat(dt3("radiobutton.shadow"), ";\n}\n\n.p-radiobutton-icon {\n    transition-duration: ").concat(dt3("radiobutton.transition.duration"), ";\n    background: transparent;\n    font-size: ").concat(dt3("radiobutton.icon.size"), ";\n    width: ").concat(dt3("radiobutton.icon.size"), ";\n    height: ").concat(dt3("radiobutton.icon.size"), ";\n    border-radius: 50%;\n    backface-visibility: hidden;\n    transform: translateZ(0) scale(0.1);\n}\n\n.p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover) .p-radiobutton-box {\n    border-color: ").concat(dt3("radiobutton.hover.border.color"), ";\n}\n\n.p-radiobutton-checked .p-radiobutton-box {\n    border-color: ").concat(dt3("radiobutton.checked.border.color"), ";\n    background: ").concat(dt3("radiobutton.checked.background"), ";\n}\n\n.p-radiobutton-checked .p-radiobutton-box .p-radiobutton-icon {\n    background: ").concat(dt3("radiobutton.icon.checked.color"), ";\n    transform: translateZ(0) scale(1, 1);\n    visibility: visible;\n}\n\n.p-radiobutton-checked:not(.p-disabled):has(.p-radiobutton-input:hover) .p-radiobutton-box {\n    border-color: ").concat(dt3("radiobutton.checked.hover.border.color"), ";\n    background: ").concat(dt3("radiobutton.checked.hover.background"), ";\n}\n\n.p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover).p-radiobutton-checked .p-radiobutton-box .p-radiobutton-icon {\n    background: ").concat(dt3("radiobutton.icon.checked.hover.color"), ";\n}\n\n.p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:focus-visible) .p-radiobutton-box {\n    border-color: ").concat(dt3("radiobutton.focus.border.color"), ";\n    box-shadow: ").concat(dt3("radiobutton.focus.ring.shadow"), ";\n    outline: ").concat(dt3("radiobutton.focus.ring.width"), " ").concat(dt3("radiobutton.focus.ring.style"), " ").concat(dt3("radiobutton.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("radiobutton.focus.ring.offset"), ";\n}\n\n.p-radiobutton-checked:not(.p-disabled):has(.p-radiobutton-input:focus-visible) .p-radiobutton-box {\n    border-color: ").concat(dt3("radiobutton.checked.focus.border.color"), ";\n}\n\n.p-radiobutton.p-invalid > .p-radiobutton-box {\n    border-color: ").concat(dt3("radiobutton.invalid.border.color"), ";\n}\n\n.p-radiobutton.p-variant-filled .p-radiobutton-box {\n    background: ").concat(dt3("radiobutton.filled.background"), ";\n}\n\n.p-radiobutton.p-variant-filled.p-radiobutton-checked .p-radiobutton-box {\n    background: ").concat(dt3("radiobutton.checked.background"), ";\n}\n\n.p-radiobutton.p-variant-filled:not(.p-disabled):has(.p-radiobutton-input:hover).p-radiobutton-checked .p-radiobutton-box {\n    background: ").concat(dt3("radiobutton.checked.hover.background"), ";\n}\n\n.p-radiobutton.p-disabled {\n    opacity: 1;\n}\n\n.p-radiobutton.p-disabled .p-radiobutton-box {\n    background: ").concat(dt3("radiobutton.disabled.background"), ";\n    border-color: ").concat(dt3("radiobutton.checked.disabled.border.color"), ";\n}\n\n.p-radiobutton-checked.p-disabled .p-radiobutton-box .p-radiobutton-icon {\n    background: ").concat(dt3("radiobutton.icon.disabled.color"), ";\n}\n");
};
var classes$4 = {
  root: function root23(_ref2) {
    var instance = _ref2.instance, props = _ref2.props;
    return ["p-radiobutton p-component", {
      "p-radiobutton-checked": instance.checked,
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : instance.$primevue.config.inputStyle === "filled" || instance.$primevue.config.inputVariant === "filled"
    }];
  },
  box: "p-radiobutton-box",
  input: "p-radiobutton-input",
  icon: "p-radiobutton-icon"
};
var RadioButtonStyle = BaseStyle.extend({
  name: "radiobutton",
  theme: theme$4,
  classes: classes$4
});
var script$1$6 = {
  name: "BaseRadioButton",
  "extends": script$1a,
  props: {
    value: null,
    modelValue: null,
    binary: Boolean,
    name: {
      type: String,
      "default": null
    },
    variant: {
      type: String,
      "default": null
    },
    invalid: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    tabindex: {
      type: Number,
      "default": null
    },
    inputId: {
      type: String,
      "default": null
    },
    inputClass: {
      type: [String, Object],
      "default": null
    },
    inputStyle: {
      type: Object,
      "default": null
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: RadioButtonStyle,
  provide: function provide33() {
    return {
      $pcRadioButton: this,
      $parentInstance: this
    };
  }
};
var script$l = {
  name: "RadioButton",
  "extends": script$1$6,
  inheritAttrs: false,
  emits: ["update:modelValue", "change", "focus", "blur"],
  methods: {
    getPTOptions: function getPTOptions16(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          checked: this.checked,
          disabled: this.disabled
        }
      });
    },
    onChange: function onChange8(event2) {
      if (!this.disabled && !this.readonly) {
        var newModelValue = this.binary ? !this.checked : this.value;
        this.$emit("update:modelValue", newModelValue);
        this.$emit("change", event2);
      }
    },
    onFocus: function onFocus6(event2) {
      this.$emit("focus", event2);
    },
    onBlur: function onBlur6(event2) {
      this.$emit("blur", event2);
    }
  },
  computed: {
    checked: function checked3() {
      return this.modelValue != null && (this.binary ? !!this.modelValue : equals(this.modelValue, this.value));
    }
  }
};
var _hoisted_1$i = ["data-p-checked", "data-p-disabled"];
var _hoisted_2$e = ["id", "value", "name", "checked", "tabindex", "disabled", "readonly", "aria-labelledby", "aria-label", "aria-invalid"];
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, $options.getPTOptions("root"), {
    "data-p-checked": $options.checked,
    "data-p-disabled": _ctx.disabled
  }), [createBaseVNode("input", mergeProps({
    id: _ctx.inputId,
    type: "radio",
    "class": [_ctx.cx("input"), _ctx.inputClass],
    style: _ctx.inputStyle,
    value: _ctx.value,
    name: _ctx.name,
    checked: $options.checked,
    tabindex: _ctx.tabindex,
    disabled: _ctx.disabled,
    readonly: _ctx.readonly,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-invalid": _ctx.invalid || void 0,
    onFocus: _cache[0] || (_cache[0] = function() {
      return $options.onFocus && $options.onFocus.apply($options, arguments);
    }),
    onBlur: _cache[1] || (_cache[1] = function() {
      return $options.onBlur && $options.onBlur.apply($options, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function() {
      return $options.onChange && $options.onChange.apply($options, arguments);
    })
  }, $options.getPTOptions("input")), null, 16, _hoisted_2$e), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("box")
  }, $options.getPTOptions("box")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("icon")
  }, $options.getPTOptions("icon")), null, 16)], 16)], 16, _hoisted_1$i);
}
script$l.render = render$k;
var script$k = {
  name: "FilterIcon",
  "extends": script$15
};
var _hoisted_1$h = /* @__PURE__ */ createBaseVNode("path", {
  d: "M8.64708 14H5.35296C5.18981 13.9979 5.03395 13.9321 4.91858 13.8167C4.8032 13.7014 4.73745 13.5455 4.73531 13.3824V7L0.329431 0.98C0.259794 0.889466 0.217389 0.780968 0.20718 0.667208C0.19697 0.553448 0.219379 0.439133 0.271783 0.337647C0.324282 0.236453 0.403423 0.151519 0.500663 0.0920138C0.597903 0.0325088 0.709548 0.000692754 0.823548 0H13.1765C13.2905 0.000692754 13.4021 0.0325088 13.4994 0.0920138C13.5966 0.151519 13.6758 0.236453 13.7283 0.337647C13.7807 0.439133 13.8031 0.553448 13.7929 0.667208C13.7826 0.780968 13.7402 0.889466 13.6706 0.98L9.26472 7V13.3824C9.26259 13.5455 9.19683 13.7014 9.08146 13.8167C8.96609 13.9321 8.81022 13.9979 8.64708 14ZM5.97061 12.7647H8.02943V6.79412C8.02878 6.66289 8.07229 6.53527 8.15296 6.43177L11.9412 1.23529H2.05884L5.86355 6.43177C5.94422 6.53527 5.98773 6.66289 5.98708 6.79412L5.97061 12.7647Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$d = [_hoisted_1$h];
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$d, 16);
}
script$k.render = render$j;
var script$j = {
  name: "FilterSlashIcon",
  "extends": script$15
};
var _hoisted_1$g = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M13.4994 0.0920138C13.5967 0.151519 13.6758 0.236453 13.7283 0.337647C13.7807 0.439133 13.8031 0.553448 13.7929 0.667208C13.7827 0.780968 13.7403 0.889466 13.6707 0.98L11.406 4.06823C11.3099 4.19928 11.1656 4.28679 11.005 4.3115C10.8444 4.33621 10.6805 4.2961 10.5495 4.2C10.4184 4.1039 10.3309 3.95967 10.3062 3.79905C10.2815 3.63843 10.3216 3.47458 10.4177 3.34353L11.9412 1.23529H7.41184C7.24803 1.23529 7.09093 1.17022 6.97509 1.05439C6.85926 0.938558 6.79419 0.781457 6.79419 0.617647C6.79419 0.453837 6.85926 0.296736 6.97509 0.180905C7.09093 0.0650733 7.24803 0 7.41184 0H13.1765C13.2905 0.000692754 13.4022 0.0325088 13.4994 0.0920138ZM4.20008 0.181168H4.24126L13.2013 9.03411C13.3169 9.14992 13.3819 9.3069 13.3819 9.47058C13.3819 9.63426 13.3169 9.79124 13.2013 9.90705C13.1445 9.96517 13.0766 10.0112 13.0016 10.0423C12.9266 10.0735 12.846 10.0891 12.7648 10.0882C12.6836 10.0886 12.6032 10.0728 12.5283 10.0417C12.4533 10.0106 12.3853 9.96479 12.3283 9.90705L9.3142 6.92587L9.26479 6.99999V13.3823C9.26265 13.5455 9.19689 13.7014 9.08152 13.8167C8.96615 13.9321 8.81029 13.9979 8.64714 14H5.35302C5.18987 13.9979 5.03401 13.9321 4.91864 13.8167C4.80327 13.7014 4.73751 13.5455 4.73537 13.3823V6.99999L0.329492 1.02117C0.259855 0.930634 0.21745 0.822137 0.207241 0.708376C0.197031 0.594616 0.21944 0.480301 0.271844 0.378815C0.324343 0.277621 0.403484 0.192687 0.500724 0.133182C0.597964 0.073677 0.709609 0.041861 0.823609 0.0411682H3.86243C3.92448 0.0461551 3.9855 0.060022 4.04361 0.0823446C4.10037 0.10735 4.15311 0.140655 4.20008 0.181168ZM8.02949 6.79411C8.02884 6.66289 8.07235 6.53526 8.15302 6.43176L8.42478 6.05293L3.55773 1.23529H2.0589L5.84714 6.43176C5.92781 6.53526 5.97132 6.66289 5.97067 6.79411V12.7647H8.02949V6.79411Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$c = [_hoisted_1$g];
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$c, 16);
}
script$j.render = render$i;
var script$i = {
  name: "PlusIcon",
  "extends": script$15
};
var _hoisted_1$f = /* @__PURE__ */ createBaseVNode("path", {
  d: "M7.67742 6.32258V0.677419C7.67742 0.497757 7.60605 0.325452 7.47901 0.198411C7.35197 0.0713707 7.17966 0 7 0C6.82034 0 6.64803 0.0713707 6.52099 0.198411C6.39395 0.325452 6.32258 0.497757 6.32258 0.677419V6.32258H0.677419C0.497757 6.32258 0.325452 6.39395 0.198411 6.52099C0.0713707 6.64803 0 6.82034 0 7C0 7.17966 0.0713707 7.35197 0.198411 7.47901C0.325452 7.60605 0.497757 7.67742 0.677419 7.67742H6.32258V13.3226C6.32492 13.5015 6.39704 13.6725 6.52358 13.799C6.65012 13.9255 6.82106 13.9977 7 14C7.17966 14 7.35197 13.9286 7.47901 13.8016C7.60605 13.6745 7.67742 13.5022 7.67742 13.3226V7.67742H13.3226C13.5022 7.67742 13.6745 7.60605 13.8016 7.47901C13.9286 7.35197 14 7.17966 14 7C13.9977 6.82106 13.9255 6.65012 13.799 6.52358C13.6725 6.39704 13.5015 6.32492 13.3226 6.32258H7.67742Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$b = [_hoisted_1$f];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$b, 16);
}
script$i.render = render$h;
var script$h = {
  name: "TrashIcon",
  "extends": script$15
};
var _hoisted_1$e = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M3.44802 13.9955H10.552C10.8056 14.0129 11.06 13.9797 11.3006 13.898C11.5412 13.8163 11.7632 13.6877 11.9537 13.5196C12.1442 13.3515 12.2995 13.1473 12.4104 12.9188C12.5213 12.6903 12.5858 12.442 12.6 12.1884V4.36041H13.4C13.5591 4.36041 13.7117 4.29722 13.8243 4.18476C13.9368 4.07229 14 3.91976 14 3.76071C14 3.60166 13.9368 3.44912 13.8243 3.33666C13.7117 3.22419 13.5591 3.16101 13.4 3.16101H12.0537C12.0203 3.1557 11.9863 3.15299 11.952 3.15299C11.9178 3.15299 11.8838 3.1557 11.8503 3.16101H11.2285C11.2421 3.10893 11.2487 3.05513 11.248 3.00106V1.80966C11.2171 1.30262 10.9871 0.828306 10.608 0.48989C10.229 0.151475 9.73159 -0.0236625 9.22402 0.00257442H4.77602C4.27251 -0.0171866 3.78126 0.160868 3.40746 0.498617C3.03365 0.836366 2.807 1.30697 2.77602 1.80966V3.00106C2.77602 3.0556 2.78346 3.10936 2.79776 3.16101H0.6C0.521207 3.16101 0.443185 3.17652 0.37039 3.20666C0.297595 3.2368 0.231451 3.28097 0.175736 3.33666C0.120021 3.39235 0.0758251 3.45846 0.0456722 3.53121C0.0155194 3.60397 0 3.68196 0 3.76071C0 3.83946 0.0155194 3.91744 0.0456722 3.9902C0.0758251 4.06296 0.120021 4.12907 0.175736 4.18476C0.231451 4.24045 0.297595 4.28462 0.37039 4.31476C0.443185 4.3449 0.521207 4.36041 0.6 4.36041H1.40002V12.1884C1.41426 12.442 1.47871 12.6903 1.58965 12.9188C1.7006 13.1473 1.85582 13.3515 2.04633 13.5196C2.23683 13.6877 2.45882 13.8163 2.69944 13.898C2.94005 13.9797 3.1945 14.0129 3.44802 13.9955ZM2.60002 4.36041H11.304V12.1884C11.304 12.5163 10.952 12.7961 10.504 12.7961H3.40002C2.97602 12.7961 2.60002 12.5163 2.60002 12.1884V4.36041ZM3.95429 3.16101C3.96859 3.10936 3.97602 3.0556 3.97602 3.00106V1.80966C3.97602 1.48183 4.33602 1.20197 4.77602 1.20197H9.24802C9.66403 1.20197 10.048 1.48183 10.048 1.80966V3.00106C10.0473 3.05515 10.054 3.10896 10.0678 3.16101H3.95429ZM5.57571 10.997C5.41731 10.995 5.26597 10.9311 5.15395 10.8191C5.04193 10.7071 4.97808 10.5558 4.97601 10.3973V6.77517C4.97601 6.61612 5.0392 6.46359 5.15166 6.35112C5.26413 6.23866 5.41666 6.17548 5.57571 6.17548C5.73476 6.17548 5.8873 6.23866 5.99976 6.35112C6.11223 6.46359 6.17541 6.61612 6.17541 6.77517V10.3894C6.17647 10.4688 6.16174 10.5476 6.13208 10.6213C6.10241 10.695 6.05841 10.762 6.00261 10.8186C5.94682 10.8751 5.88035 10.92 5.80707 10.9506C5.73378 10.9813 5.65514 10.9971 5.57571 10.997ZM7.99968 10.8214C8.11215 10.9339 8.26468 10.997 8.42373 10.997C8.58351 10.9949 8.73604 10.93 8.84828 10.8163C8.96052 10.7025 9.02345 10.5491 9.02343 10.3894V6.77517C9.02343 6.61612 8.96025 6.46359 8.84778 6.35112C8.73532 6.23866 8.58278 6.17548 8.42373 6.17548C8.26468 6.17548 8.11215 6.23866 7.99968 6.35112C7.88722 6.46359 7.82404 6.61612 7.82404 6.77517V10.3973C7.82404 10.5564 7.88722 10.7089 7.99968 10.8214Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$a = [_hoisted_1$e];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$a, 16);
}
script$h.render = render$g;
var script$g = {
  name: "SortAltIcon",
  "extends": script$15
};
var _hoisted_1$d = /* @__PURE__ */ createBaseVNode("path", {
  d: "M5.64515 3.61291C5.47353 3.61291 5.30192 3.54968 5.16644 3.4142L3.38708 1.63484L1.60773 3.4142C1.34579 3.67613 0.912244 3.67613 0.650309 3.4142C0.388374 3.15226 0.388374 2.71871 0.650309 2.45678L2.90837 0.198712C3.17031 -0.0632236 3.60386 -0.0632236 3.86579 0.198712L6.12386 2.45678C6.38579 2.71871 6.38579 3.15226 6.12386 3.4142C5.98837 3.54968 5.81676 3.61291 5.64515 3.61291Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$9 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M3.38714 14C3.01681 14 2.70972 13.6929 2.70972 13.3226V0.677419C2.70972 0.307097 3.01681 0 3.38714 0C3.75746 0 4.06456 0.307097 4.06456 0.677419V13.3226C4.06456 13.6929 3.75746 14 3.38714 14Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_3$4 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M10.6129 14C10.4413 14 10.2697 13.9368 10.1342 13.8013L7.87611 11.5432C7.61418 11.2813 7.61418 10.8477 7.87611 10.5858C8.13805 10.3239 8.5716 10.3239 8.83353 10.5858L10.6129 12.3652L12.3922 10.5858C12.6542 10.3239 13.0877 10.3239 13.3497 10.5858C13.6116 10.8477 13.6116 11.2813 13.3497 11.5432L11.0916 13.8013C10.9561 13.9368 10.7845 14 10.6129 14Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_4$3 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M10.6129 14C10.2426 14 9.93552 13.6929 9.93552 13.3226V0.677419C9.93552 0.307097 10.2426 0 10.6129 0C10.9833 0 11.2904 0.307097 11.2904 0.677419V13.3226C11.2904 13.6929 10.9832 14 10.6129 14Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_5$2 = [_hoisted_1$d, _hoisted_2$9, _hoisted_3$4, _hoisted_4$3];
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_5$2, 16);
}
script$g.render = render$f;
var script$f = {
  name: "SortAmountDownIcon",
  "extends": script$15
};
var _hoisted_1$c = /* @__PURE__ */ createBaseVNode("path", {
  d: "M4.93953 10.5858L3.83759 11.6877V0.677419C3.83759 0.307097 3.53049 0 3.16017 0C2.78985 0 2.48275 0.307097 2.48275 0.677419V11.6877L1.38082 10.5858C1.11888 10.3239 0.685331 10.3239 0.423396 10.5858C0.16146 10.8477 0.16146 11.2813 0.423396 11.5432L2.68146 13.8013C2.74469 13.8645 2.81694 13.9097 2.89823 13.9458C2.97952 13.9819 3.06985 14 3.16017 14C3.25049 14 3.33178 13.9819 3.42211 13.9458C3.5034 13.9097 3.57565 13.8645 3.63888 13.8013L5.89694 11.5432C6.15888 11.2813 6.15888 10.8477 5.89694 10.5858C5.63501 10.3239 5.20146 10.3239 4.93953 10.5858ZM13.0957 0H7.22468C6.85436 0 6.54726 0.307097 6.54726 0.677419C6.54726 1.04774 6.85436 1.35484 7.22468 1.35484H13.0957C13.466 1.35484 13.7731 1.04774 13.7731 0.677419C13.7731 0.307097 13.466 0 13.0957 0ZM7.22468 5.41935H9.48275C9.85307 5.41935 10.1602 5.72645 10.1602 6.09677C10.1602 6.4671 9.85307 6.77419 9.48275 6.77419H7.22468C6.85436 6.77419 6.54726 6.4671 6.54726 6.09677C6.54726 5.72645 6.85436 5.41935 7.22468 5.41935ZM7.6763 8.12903H7.22468C6.85436 8.12903 6.54726 8.43613 6.54726 8.80645C6.54726 9.17677 6.85436 9.48387 7.22468 9.48387H7.6763C8.04662 9.48387 8.35372 9.17677 8.35372 8.80645C8.35372 8.43613 8.04662 8.12903 7.6763 8.12903ZM7.22468 2.70968H11.2892C11.6595 2.70968 11.9666 3.01677 11.9666 3.3871C11.9666 3.75742 11.6595 4.06452 11.2892 4.06452H7.22468C6.85436 4.06452 6.54726 3.75742 6.54726 3.3871C6.54726 3.01677 6.85436 2.70968 7.22468 2.70968Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$8 = [_hoisted_1$c];
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$8, 16);
}
script$f.render = render$e;
var script$e = {
  name: "SortAmountUpAltIcon",
  "extends": script$15
};
var _hoisted_1$b = /* @__PURE__ */ createBaseVNode("path", {
  d: "M3.63435 0.19871C3.57113 0.135484 3.49887 0.0903226 3.41758 0.0541935C3.255 -0.0180645 3.06532 -0.0180645 2.90274 0.0541935C2.82145 0.0903226 2.74919 0.135484 2.68597 0.19871L0.427901 2.45677C0.165965 2.71871 0.165965 3.15226 0.427901 3.41419C0.689836 3.67613 1.12338 3.67613 1.38532 3.41419L2.48726 2.31226V13.3226C2.48726 13.6929 2.79435 14 3.16467 14C3.535 14 3.84209 13.6929 3.84209 13.3226V2.31226L4.94403 3.41419C5.07951 3.54968 5.25113 3.6129 5.42274 3.6129C5.59435 3.6129 5.76597 3.54968 5.90145 3.41419C6.16338 3.15226 6.16338 2.71871 5.90145 2.45677L3.64338 0.19871H3.63435ZM13.7685 13.3226C13.7685 12.9523 13.4615 12.6452 13.0911 12.6452H7.22016C6.84984 12.6452 6.54274 12.9523 6.54274 13.3226C6.54274 13.6929 6.84984 14 7.22016 14H13.0911C13.4615 14 13.7685 13.6929 13.7685 13.3226ZM7.22016 8.58064C6.84984 8.58064 6.54274 8.27355 6.54274 7.90323C6.54274 7.5329 6.84984 7.22581 7.22016 7.22581H9.47823C9.84855 7.22581 10.1556 7.5329 10.1556 7.90323C10.1556 8.27355 9.84855 8.58064 9.47823 8.58064H7.22016ZM7.22016 5.87097H7.67177C8.0421 5.87097 8.34919 5.56387 8.34919 5.19355C8.34919 4.82323 8.0421 4.51613 7.67177 4.51613H7.22016C6.84984 4.51613 6.54274 4.82323 6.54274 5.19355C6.54274 5.56387 6.84984 5.87097 7.22016 5.87097ZM11.2847 11.2903H7.22016C6.84984 11.2903 6.54274 10.9832 6.54274 10.6129C6.54274 10.2426 6.84984 9.93548 7.22016 9.93548H11.2847C11.655 9.93548 11.9621 10.2426 11.9621 10.6129C11.9621 10.9832 11.655 11.2903 11.2847 11.2903Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$7 = [_hoisted_1$b];
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$7, 16);
}
script$e.render = render$d;
var script$c = {
  name: "BaseDataTable",
  "extends": script$1a,
  props: {
    value: {
      type: Array,
      "default": null
    },
    dataKey: {
      type: [String, Function],
      "default": null
    },
    rows: {
      type: Number,
      "default": 0
    },
    first: {
      type: Number,
      "default": 0
    },
    totalRecords: {
      type: Number,
      "default": 0
    },
    paginator: {
      type: Boolean,
      "default": false
    },
    paginatorPosition: {
      type: String,
      "default": "bottom"
    },
    alwaysShowPaginator: {
      type: Boolean,
      "default": true
    },
    paginatorTemplate: {
      type: [Object, String],
      "default": "FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown"
    },
    pageLinkSize: {
      type: Number,
      "default": 5
    },
    rowsPerPageOptions: {
      type: Array,
      "default": null
    },
    currentPageReportTemplate: {
      type: String,
      "default": "({currentPage} of {totalPages})"
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    sortField: {
      type: [String, Function],
      "default": null
    },
    sortOrder: {
      type: Number,
      "default": null
    },
    defaultSortOrder: {
      type: Number,
      "default": 1
    },
    nullSortOrder: {
      type: Number,
      "default": 1
    },
    multiSortMeta: {
      type: Array,
      "default": null
    },
    sortMode: {
      type: String,
      "default": "single"
    },
    removableSort: {
      type: Boolean,
      "default": false
    },
    filters: {
      type: Object,
      "default": null
    },
    filterDisplay: {
      type: String,
      "default": null
    },
    globalFilterFields: {
      type: Array,
      "default": null
    },
    filterLocale: {
      type: String,
      "default": void 0
    },
    selection: {
      type: [Array, Object],
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    compareSelectionBy: {
      type: String,
      "default": "deepEquals"
    },
    metaKeySelection: {
      type: Boolean,
      "default": false
    },
    contextMenu: {
      type: Boolean,
      "default": false
    },
    contextMenuSelection: {
      type: Object,
      "default": null
    },
    selectAll: {
      type: Boolean,
      "default": null
    },
    rowHover: {
      type: Boolean,
      "default": false
    },
    csvSeparator: {
      type: String,
      "default": ","
    },
    exportFilename: {
      type: String,
      "default": "download"
    },
    exportFunction: {
      type: Function,
      "default": null
    },
    resizableColumns: {
      type: Boolean,
      "default": false
    },
    columnResizeMode: {
      type: String,
      "default": "fit"
    },
    reorderableColumns: {
      type: Boolean,
      "default": false
    },
    expandedRows: {
      type: [Array, Object],
      "default": null
    },
    expandedRowIcon: {
      type: String,
      "default": void 0
    },
    collapsedRowIcon: {
      type: String,
      "default": void 0
    },
    rowGroupMode: {
      type: String,
      "default": null
    },
    groupRowsBy: {
      type: [Array, String, Function],
      "default": null
    },
    expandableRowGroups: {
      type: Boolean,
      "default": false
    },
    expandedRowGroups: {
      type: Array,
      "default": null
    },
    stateStorage: {
      type: String,
      "default": "session"
    },
    stateKey: {
      type: String,
      "default": null
    },
    editMode: {
      type: String,
      "default": null
    },
    editingRows: {
      type: Array,
      "default": null
    },
    rowClass: {
      type: Function,
      "default": null
    },
    rowStyle: {
      type: Function,
      "default": null
    },
    scrollable: {
      type: Boolean,
      "default": false
    },
    virtualScrollerOptions: {
      type: Object,
      "default": null
    },
    scrollHeight: {
      type: String,
      "default": null
    },
    frozenValue: {
      type: Array,
      "default": null
    },
    breakpoint: {
      type: String,
      "default": "960px"
    },
    showGridlines: {
      type: Boolean,
      "default": false
    },
    stripedRows: {
      type: Boolean,
      "default": false
    },
    highlightOnSelect: {
      type: Boolean,
      "default": false
    },
    size: {
      type: String,
      "default": null
    },
    tableStyle: {
      type: null,
      "default": null
    },
    tableClass: {
      type: [String, Object],
      "default": null
    },
    tableProps: {
      type: Object,
      "default": null
    },
    filterInputProps: {
      type: null,
      "default": null
    },
    filterButtonProps: {
      type: Object,
      "default": function _default4() {
        return {
          filter: {
            severity: "secondary",
            text: true,
            rounded: true
          },
          inline: {
            clear: {
              severity: "secondary",
              text: true,
              rounded: true
            }
          },
          popover: {
            addRule: {
              severity: "info",
              text: true,
              size: "small"
            },
            removeRule: {
              severity: "danger",
              text: true,
              size: "small"
            },
            apply: {
              size: "small"
            },
            clear: {
              outlined: true,
              size: "small"
            }
          }
        };
      }
    },
    editButtonProps: {
      type: Object,
      "default": function _default5() {
        return {
          init: {
            severity: "secondary",
            text: true,
            rounded: true
          },
          save: {
            severity: "secondary",
            text: true,
            rounded: true
          },
          cancel: {
            severity: "secondary",
            text: true,
            rounded: true
          }
        };
      }
    }
  },
  style: DataTableStyle,
  provide: function provide34() {
    return {
      $pcDataTable: this,
      $parentInstance: this
    };
  }
};
var script$b = {
  name: "RowCheckbox",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["change"],
  props: {
    value: null,
    checked: null,
    column: null,
    rowCheckboxIconTemplate: {
      type: Function,
      "default": null
    },
    index: {
      type: Number,
      "default": null
    }
  },
  methods: {
    getColumnPT: function getColumnPT(key) {
      var columnMetaData = {
        props: this.column.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: this.index,
          checked: this.checked,
          disabled: this.$attrs.disabled
        }
      };
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.getColumnProp(), key, columnMetaData));
    },
    getColumnProp: function getColumnProp() {
      return this.column.props && this.column.props.pt ? this.column.props.pt : void 0;
    },
    onChange: function onChange9(event2) {
      if (!this.$attrs.disabled) {
        this.$emit("change", {
          originalEvent: event2,
          data: this.value
        });
      }
    }
  },
  computed: {
    checkboxAriaLabel: function checkboxAriaLabel() {
      return this.$primevue.config.locale.aria ? this.checked ? this.$primevue.config.locale.aria.selectRow : this.$primevue.config.locale.aria.unselectRow : void 0;
    }
  },
  components: {
    CheckIcon: script$11,
    Checkbox: script$m
  }
};
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_Checkbox = resolveComponent("Checkbox");
  return openBlock(), createBlock(_component_Checkbox, {
    modelValue: $props.checked,
    binary: true,
    disabled: _ctx.$attrs.disabled,
    "aria-label": $options.checkboxAriaLabel,
    onChange: $options.onChange,
    unstyled: _ctx.unstyled,
    pt: $options.getColumnPT("pcRowCheckbox")
  }, {
    icon: withCtx(function(slotProps) {
      return [$props.rowCheckboxIconTemplate ? (openBlock(), createBlock(resolveDynamicComponent($props.rowCheckboxIconTemplate), {
        key: 0,
        checked: slotProps.checked,
        "class": normalizeClass(slotProps["class"])
      }, null, 8, ["checked", "class"])) : !$props.rowCheckboxIconTemplate && slotProps.checked ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
        key: 1,
        "class": slotProps["class"]
      }, $options.getColumnPT("pcRowCheckbox.icon")), null, 16, ["class"])) : createCommentVNode("", true)];
    }),
    _: 1
  }, 8, ["modelValue", "disabled", "aria-label", "onChange", "unstyled", "pt"]);
}
script$b.render = render$b;
var script$a = {
  name: "RowRadioButton",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["change"],
  props: {
    value: null,
    checked: null,
    name: null,
    column: null,
    index: {
      type: Number,
      "default": null
    }
  },
  methods: {
    getColumnPT: function getColumnPT2(key) {
      var columnMetaData = {
        props: this.column.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: this.index,
          checked: this.checked,
          disabled: this.$attrs.disabled
        }
      };
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.getColumnProp(), key, columnMetaData));
    },
    getColumnProp: function getColumnProp2() {
      return this.column.props && this.column.props.pt ? this.column.props.pt : void 0;
    },
    onChange: function onChange10(event2) {
      if (!this.$attrs.disabled) {
        this.$emit("change", {
          originalEvent: event2,
          data: this.value
        });
      }
    }
  },
  components: {
    RadioButton: script$l
  }
};
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_RadioButton = resolveComponent("RadioButton");
  return openBlock(), createBlock(_component_RadioButton, {
    modelValue: $props.checked,
    binary: true,
    disabled: _ctx.$attrs.disabled,
    name: $props.name,
    onChange: $options.onChange,
    unstyled: _ctx.unstyled,
    pt: $options.getColumnPT("pcRowRadiobutton")
  }, null, 8, ["modelValue", "disabled", "name", "onChange", "unstyled", "pt"]);
}
script$a.render = render$a;
var script$9 = {
  name: "BodyCell",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["cell-edit-init", "cell-edit-complete", "cell-edit-cancel", "row-edit-init", "row-edit-save", "row-edit-cancel", "row-toggle", "radio-change", "checkbox-change", "editing-meta-change"],
  props: {
    rowData: {
      type: Object,
      "default": null
    },
    column: {
      type: Object,
      "default": null
    },
    frozenRow: {
      type: Boolean,
      "default": false
    },
    rowIndex: {
      type: Number,
      "default": null
    },
    index: {
      type: Number,
      "default": null
    },
    isRowExpanded: {
      type: Boolean,
      "default": false
    },
    selected: {
      type: Boolean,
      "default": false
    },
    editing: {
      type: Boolean,
      "default": false
    },
    editingMeta: {
      type: Object,
      "default": null
    },
    editMode: {
      type: String,
      "default": null
    },
    virtualScrollerContentProps: {
      type: Object,
      "default": null
    },
    ariaControls: {
      type: String,
      "default": null
    },
    name: {
      type: String,
      "default": null
    },
    expandedRowIcon: {
      type: String,
      "default": null
    },
    collapsedRowIcon: {
      type: String,
      "default": null
    },
    editButtonProps: {
      type: Object,
      "default": null
    }
  },
  documentEditListener: null,
  selfClick: false,
  overlayEventListener: null,
  data: function data16() {
    return {
      d_editing: this.editing,
      styleObject: {}
    };
  },
  watch: {
    editing: function editing(newValue) {
      this.d_editing = newValue;
    },
    "$data.d_editing": function $dataD_editing(newValue) {
      this.$emit("editing-meta-change", {
        data: this.rowData,
        field: this.field || "field_".concat(this.index),
        index: this.rowIndex,
        editing: newValue
      });
    }
  },
  mounted: function mounted13() {
    if (this.columnProp("frozen")) {
      this.updateStickyPosition();
    }
  },
  updated: function updated8() {
    var _this = this;
    if (this.columnProp("frozen")) {
      this.updateStickyPosition();
    }
    if (this.d_editing && (this.editMode === "cell" || this.editMode === "row" && this.columnProp("rowEditor"))) {
      setTimeout(function() {
        var focusableEl = getFirstFocusableElement(_this.$el);
        focusableEl && focusableEl.focus();
      }, 1);
    }
  },
  beforeUnmount: function beforeUnmount7() {
    if (this.overlayEventListener) {
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
    }
  },
  methods: {
    columnProp: function columnProp(prop2) {
      return getVNodeProp(this.column, prop2);
    },
    getColumnPT: function getColumnPT3(key) {
      var _this$$parentInstance, _this$$parentInstance2;
      var columnMetaData = {
        props: this.column.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: this.index,
          size: (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 || (_this$$parentInstance = _this$$parentInstance.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.size,
          showGridlines: (_this$$parentInstance2 = this.$parentInstance) === null || _this$$parentInstance2 === void 0 || (_this$$parentInstance2 = _this$$parentInstance2.$parentInstance) === null || _this$$parentInstance2 === void 0 ? void 0 : _this$$parentInstance2.showGridlines
        }
      };
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.getColumnProp(), key, columnMetaData));
    },
    getColumnProp: function getColumnProp3() {
      return this.column.props && this.column.props.pt ? this.column.props.pt : void 0;
    },
    resolveFieldData: function resolveFieldData$1() {
      return resolveFieldData(this.rowData, this.field);
    },
    toggleRow: function toggleRow(event2) {
      this.$emit("row-toggle", {
        originalEvent: event2,
        data: this.rowData
      });
    },
    toggleRowWithRadio: function toggleRowWithRadio(event2, index2) {
      this.$emit("radio-change", {
        originalEvent: event2.originalEvent,
        index: index2,
        data: event2.data
      });
    },
    toggleRowWithCheckbox: function toggleRowWithCheckbox(event2, index2) {
      this.$emit("checkbox-change", {
        originalEvent: event2.originalEvent,
        index: index2,
        data: event2.data
      });
    },
    isEditable: function isEditable() {
      return this.column.children && this.column.children.editor != null;
    },
    bindDocumentEditListener: function bindDocumentEditListener() {
      var _this2 = this;
      if (!this.documentEditListener) {
        this.documentEditListener = function(event2) {
          if (!_this2.selfClick) {
            _this2.completeEdit(event2, "outside");
          }
          _this2.selfClick = false;
        };
        document.addEventListener("click", this.documentEditListener);
      }
    },
    unbindDocumentEditListener: function unbindDocumentEditListener() {
      if (this.documentEditListener) {
        document.removeEventListener("click", this.documentEditListener);
        this.documentEditListener = null;
        this.selfClick = false;
      }
    },
    switchCellToViewMode: function switchCellToViewMode() {
      this.d_editing = false;
      this.unbindDocumentEditListener();
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
    },
    onClick: function onClick2(event2) {
      var _this3 = this;
      if (this.editMode === "cell" && this.isEditable()) {
        this.selfClick = true;
        if (!this.d_editing) {
          this.d_editing = true;
          this.bindDocumentEditListener();
          this.$emit("cell-edit-init", {
            originalEvent: event2,
            data: this.rowData,
            field: this.field,
            index: this.rowIndex
          });
          this.overlayEventListener = function(e) {
            if (_this3.$el && _this3.$el.contains(e.target)) {
              _this3.selfClick = true;
            }
          };
          OverlayEventBus.on("overlay-click", this.overlayEventListener);
        }
      }
    },
    completeEdit: function completeEdit(event2, type) {
      var completeEvent = {
        originalEvent: event2,
        data: this.rowData,
        newData: this.editingRowData,
        value: this.rowData[this.field],
        newValue: this.editingRowData[this.field],
        field: this.field,
        index: this.rowIndex,
        type,
        defaultPrevented: false,
        preventDefault: function preventDefault() {
          this.defaultPrevented = true;
        }
      };
      this.$emit("cell-edit-complete", completeEvent);
      if (!completeEvent.defaultPrevented) {
        this.switchCellToViewMode();
      }
    },
    onKeyDown: function onKeyDown5(event2) {
      if (this.editMode === "cell") {
        switch (event2.code) {
          case "Enter":
          case "NumpadEnter":
            this.completeEdit(event2, "enter");
            break;
          case "Escape":
            this.switchCellToViewMode();
            this.$emit("cell-edit-cancel", {
              originalEvent: event2,
              data: this.rowData,
              field: this.field,
              index: this.rowIndex
            });
            break;
          case "Tab":
            this.completeEdit(event2, "tab");
            if (event2.shiftKey) this.moveToPreviousCell(event2);
            else this.moveToNextCell(event2);
            break;
        }
      }
    },
    moveToPreviousCell: function moveToPreviousCell(event2) {
      var currentCell = this.findCell(event2.target);
      var targetCell = this.findPreviousEditableColumn(currentCell);
      if (targetCell) {
        invokeElementMethod(targetCell, "click");
        event2.preventDefault();
      }
    },
    moveToNextCell: function moveToNextCell(event2) {
      var currentCell = this.findCell(event2.target);
      var targetCell = this.findNextEditableColumn(currentCell);
      if (targetCell) {
        invokeElementMethod(targetCell, "click");
        event2.preventDefault();
      }
    },
    findCell: function findCell(element) {
      if (element) {
        var cell = element;
        while (cell && !getAttribute(cell, "data-p-cell-editing")) {
          cell = cell.parentElement;
        }
        return cell;
      } else {
        return null;
      }
    },
    findPreviousEditableColumn: function findPreviousEditableColumn(cell) {
      var prevCell = cell.previousElementSibling;
      if (!prevCell) {
        var previousRow = cell.parentElement.previousElementSibling;
        if (previousRow) {
          prevCell = previousRow.lastElementChild;
        }
      }
      if (prevCell) {
        if (getAttribute(prevCell, "data-p-editable-column")) return prevCell;
        else return this.findPreviousEditableColumn(prevCell);
      } else {
        return null;
      }
    },
    findNextEditableColumn: function findNextEditableColumn(cell) {
      var nextCell = cell.nextElementSibling;
      if (!nextCell) {
        var nextRow = cell.parentElement.nextElementSibling;
        if (nextRow) {
          nextCell = nextRow.firstElementChild;
        }
      }
      if (nextCell) {
        if (getAttribute(nextCell, "data-p-editable-column")) return nextCell;
        else return this.findNextEditableColumn(nextCell);
      } else {
        return null;
      }
    },
    onRowEditInit: function onRowEditInit(event2) {
      this.$emit("row-edit-init", {
        originalEvent: event2,
        data: this.rowData,
        newData: this.editingRowData,
        field: this.field,
        index: this.rowIndex
      });
    },
    onRowEditSave: function onRowEditSave(event2) {
      this.$emit("row-edit-save", {
        originalEvent: event2,
        data: this.rowData,
        newData: this.editingRowData,
        field: this.field,
        index: this.rowIndex
      });
    },
    onRowEditCancel: function onRowEditCancel(event2) {
      this.$emit("row-edit-cancel", {
        originalEvent: event2,
        data: this.rowData,
        newData: this.editingRowData,
        field: this.field,
        index: this.rowIndex
      });
    },
    editorInitCallback: function editorInitCallback(event2) {
      this.$emit("row-edit-init", {
        originalEvent: event2,
        data: this.rowData,
        newData: this.editingRowData,
        field: this.field,
        index: this.rowIndex
      });
    },
    editorSaveCallback: function editorSaveCallback(event2) {
      if (this.editMode === "row") {
        this.$emit("row-edit-save", {
          originalEvent: event2,
          data: this.rowData,
          newData: this.editingRowData,
          field: this.field,
          index: this.rowIndex
        });
      } else {
        this.completeEdit(event2, "enter");
      }
    },
    editorCancelCallback: function editorCancelCallback(event2) {
      if (this.editMode === "row") {
        this.$emit("row-edit-cancel", {
          originalEvent: event2,
          data: this.rowData,
          newData: this.editingRowData,
          field: this.field,
          index: this.rowIndex
        });
      } else {
        this.switchCellToViewMode();
        this.$emit("cell-edit-cancel", {
          originalEvent: event2,
          data: this.rowData,
          field: this.field,
          index: this.rowIndex
        });
      }
    },
    updateStickyPosition: function updateStickyPosition() {
      if (this.columnProp("frozen")) {
        var align2 = this.columnProp("alignFrozen");
        if (align2 === "right") {
          var right = 0;
          var next2 = getNextElementSibling(this.$el, '[data-p-frozen-column="true"]');
          if (next2) {
            right = getOuterWidth(next2) + parseFloat(next2.style.right || 0);
          }
          this.styleObject.right = right + "px";
        } else {
          var left = 0;
          var prev2 = getPreviousElementSibling(this.$el, '[data-p-frozen-column="true"]');
          if (prev2) {
            left = getOuterWidth(prev2) + parseFloat(prev2.style.left || 0);
          }
          this.styleObject.left = left + "px";
        }
      }
    },
    getVirtualScrollerProp: function getVirtualScrollerProp(option4) {
      return this.virtualScrollerContentProps ? this.virtualScrollerContentProps[option4] : null;
    }
  },
  computed: {
    editingRowData: function editingRowData() {
      return this.editingMeta[this.rowIndex] ? this.editingMeta[this.rowIndex].data : this.rowData;
    },
    field: function field() {
      return this.columnProp("field");
    },
    containerClass: function containerClass3() {
      return [this.columnProp("bodyClass"), this.columnProp("class"), this.cx("bodyCell")];
    },
    containerStyle: function containerStyle() {
      var bodyStyle = this.columnProp("bodyStyle");
      var columnStyle = this.columnProp("style");
      return this.columnProp("frozen") ? [columnStyle, bodyStyle, this.styleObject] : [columnStyle, bodyStyle];
    },
    loading: function loading2() {
      return this.getVirtualScrollerProp("loading");
    },
    loadingOptions: function loadingOptions() {
      var getLoaderOptions2 = this.getVirtualScrollerProp("getLoaderOptions");
      return getLoaderOptions2 && getLoaderOptions2(this.rowIndex, {
        cellIndex: this.index,
        cellFirst: this.index === 0,
        cellLast: this.index === this.getVirtualScrollerProp("columns").length - 1,
        cellEven: this.index % 2 === 0,
        cellOdd: this.index % 2 !== 0,
        column: this.column,
        field: this.field
      });
    },
    expandButtonAriaLabel: function expandButtonAriaLabel() {
      return this.$primevue.config.locale.aria ? this.isRowExpanded ? this.$primevue.config.locale.aria.expandRow : this.$primevue.config.locale.aria.collapseRow : void 0;
    },
    initButtonAriaLabel: function initButtonAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.editRow : void 0;
    },
    saveButtonAriaLabel: function saveButtonAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.saveEdit : void 0;
    },
    cancelButtonAriaLabel: function cancelButtonAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.cancelEdit : void 0;
    }
  },
  components: {
    DTRadioButton: script$a,
    DTCheckbox: script$b,
    Button: script$13,
    ChevronDownIcon: script$P,
    ChevronRightIcon: script$q,
    BarsIcon: script$p,
    PencilIcon: script$o,
    CheckIcon: script$11,
    TimesIcon: script$O
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$a(o) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$a(o);
}
function ownKeys$a(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$a(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$a(Object(t), true).forEach(function(r2) {
      _defineProperty$a(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$a(e, r, t) {
  return (r = _toPropertyKey$a(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$a(t) {
  var i2 = _toPrimitive$a(t, "string");
  return "symbol" == _typeof$a(i2) ? i2 : i2 + "";
}
function _toPrimitive$a(t, r) {
  if ("object" != _typeof$a(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$a(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var _hoisted_1$4$1 = ["colspan", "rowspan", "data-p-selection-column", "data-p-editable-column", "data-p-cell-editing", "data-p-frozen-column"];
var _hoisted_2$2$1 = ["aria-expanded", "aria-controls", "aria-label"];
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_DTRadioButton = resolveComponent("DTRadioButton");
  var _component_DTCheckbox = resolveComponent("DTCheckbox");
  var _component_BarsIcon = resolveComponent("BarsIcon");
  var _component_ChevronDownIcon = resolveComponent("ChevronDownIcon");
  var _component_ChevronRightIcon = resolveComponent("ChevronRightIcon");
  var _component_Button = resolveComponent("Button");
  var _directive_ripple = resolveDirective("ripple");
  return $options.loading ? (openBlock(), createElementBlock("td", mergeProps({
    key: 0,
    style: $options.containerStyle,
    "class": $options.containerClass,
    role: "cell"
  }, _objectSpread$a(_objectSpread$a({}, $options.getColumnPT("root")), $options.getColumnPT("bodyCell"))), [(openBlock(), createBlock(resolveDynamicComponent($props.column.children.loading), {
    data: $props.rowData,
    column: $props.column,
    field: $options.field,
    index: $props.rowIndex,
    frozenRow: $props.frozenRow,
    loadingOptions: $options.loadingOptions
  }, null, 8, ["data", "column", "field", "index", "frozenRow", "loadingOptions"]))], 16)) : (openBlock(), createElementBlock("td", mergeProps({
    key: 1,
    style: $options.containerStyle,
    "class": $options.containerClass,
    colspan: $options.columnProp("colspan"),
    rowspan: $options.columnProp("rowspan"),
    onClick: _cache[3] || (_cache[3] = function() {
      return $options.onClick && $options.onClick.apply($options, arguments);
    }),
    onKeydown: _cache[4] || (_cache[4] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    }),
    role: "cell"
  }, _objectSpread$a(_objectSpread$a({}, $options.getColumnPT("root")), $options.getColumnPT("bodyCell")), {
    "data-p-selection-column": $options.columnProp("selectionMode") != null,
    "data-p-editable-column": $options.isEditable(),
    "data-p-cell-editing": $data.d_editing,
    "data-p-frozen-column": $options.columnProp("frozen")
  }), [$props.column.children && $props.column.children.body && !$data.d_editing ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.body), {
    key: 0,
    data: $props.rowData,
    column: $props.column,
    field: $options.field,
    index: $props.rowIndex,
    frozenRow: $props.frozenRow,
    editorInitCallback: $options.editorInitCallback,
    rowTogglerCallback: $options.toggleRow
  }, null, 8, ["data", "column", "field", "index", "frozenRow", "editorInitCallback", "rowTogglerCallback"])) : $props.column.children && $props.column.children.editor && $data.d_editing ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.editor), {
    key: 1,
    data: $options.editingRowData,
    column: $props.column,
    field: $options.field,
    index: $props.rowIndex,
    frozenRow: $props.frozenRow,
    editorSaveCallback: $options.editorSaveCallback,
    editorCancelCallback: $options.editorCancelCallback
  }, null, 8, ["data", "column", "field", "index", "frozenRow", "editorSaveCallback", "editorCancelCallback"])) : $props.column.children && $props.column.children.body && !$props.column.children.editor && $data.d_editing ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.body), {
    key: 2,
    data: $options.editingRowData,
    column: $props.column,
    field: $options.field,
    index: $props.rowIndex,
    frozenRow: $props.frozenRow
  }, null, 8, ["data", "column", "field", "index", "frozenRow"])) : $options.columnProp("selectionMode") ? (openBlock(), createElementBlock(Fragment, {
    key: 3
  }, [$options.columnProp("selectionMode") === "single" ? (openBlock(), createBlock(_component_DTRadioButton, {
    key: 0,
    value: $props.rowData,
    name: $props.name,
    checked: $props.selected,
    onChange: _cache[0] || (_cache[0] = function($event) {
      return $options.toggleRowWithRadio($event, $props.rowIndex);
    }),
    column: $props.column,
    index: $props.index,
    unstyled: _ctx.unstyled,
    pt: _ctx.pt
  }, null, 8, ["value", "name", "checked", "column", "index", "unstyled", "pt"])) : $options.columnProp("selectionMode") === "multiple" ? (openBlock(), createBlock(_component_DTCheckbox, {
    key: 1,
    value: $props.rowData,
    checked: $props.selected,
    rowCheckboxIconTemplate: $props.column.children && $props.column.children.rowcheckboxicon,
    "aria-selected": $props.selected ? true : void 0,
    onChange: _cache[1] || (_cache[1] = function($event) {
      return $options.toggleRowWithCheckbox($event, $props.rowIndex);
    }),
    column: $props.column,
    index: $props.index,
    unstyled: _ctx.unstyled,
    pt: _ctx.pt
  }, null, 8, ["value", "checked", "rowCheckboxIconTemplate", "aria-selected", "column", "index", "unstyled", "pt"])) : createCommentVNode("", true)], 64)) : $options.columnProp("rowReorder") ? (openBlock(), createElementBlock(Fragment, {
    key: 4
  }, [$props.column.children && $props.column.children.rowreordericon ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.rowreordericon), {
    key: 0,
    "class": normalizeClass(_ctx.cx("reorderableRowHandle"))
  }, null, 8, ["class"])) : $options.columnProp("rowReorderIcon") ? (openBlock(), createElementBlock("i", mergeProps({
    key: 1,
    "class": [_ctx.cx("reorderableRowHandle"), $options.columnProp("rowReorderIcon")]
  }, $options.getColumnPT("reorderableRowHandle")), null, 16)) : (openBlock(), createBlock(_component_BarsIcon, mergeProps({
    key: 2,
    "class": _ctx.cx("reorderableRowHandle")
  }, $options.getColumnPT("reorderableRowHandle")), null, 16, ["class"]))], 64)) : $options.columnProp("expander") ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 5,
    "class": _ctx.cx("rowToggleButton"),
    type: "button",
    "aria-expanded": $props.isRowExpanded,
    "aria-controls": $props.ariaControls,
    "aria-label": $options.expandButtonAriaLabel,
    onClick: _cache[2] || (_cache[2] = function() {
      return $options.toggleRow && $options.toggleRow.apply($options, arguments);
    })
  }, $options.getColumnPT("rowToggleButton"), {
    "data-pc-group-section": "rowactionbutton"
  }), [$props.column.children && $props.column.children.rowtogglericon ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.rowtogglericon), {
    key: 0,
    "class": normalizeClass(_ctx.cx("rowToggleIcon")),
    rowExpanded: $props.isRowExpanded
  }, null, 8, ["class", "rowExpanded"])) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [$props.isRowExpanded && $props.expandedRowIcon ? (openBlock(), createElementBlock("span", {
    key: 0,
    "class": normalizeClass([_ctx.cx("rowToggleIcon"), $props.expandedRowIcon])
  }, null, 2)) : $props.isRowExpanded && !$props.expandedRowIcon ? (openBlock(), createBlock(_component_ChevronDownIcon, mergeProps({
    key: 1,
    "class": _ctx.cx("rowToggleIcon")
  }, $options.getColumnPT("rowToggleIcon")), null, 16, ["class"])) : !$props.isRowExpanded && $props.collapsedRowIcon ? (openBlock(), createElementBlock("span", {
    key: 2,
    "class": normalizeClass([_ctx.cx("rowToggleIcon"), $props.collapsedRowIcon])
  }, null, 2)) : !$props.isRowExpanded && !$props.collapsedRowIcon ? (openBlock(), createBlock(_component_ChevronRightIcon, mergeProps({
    key: 3,
    "class": _ctx.cx("rowToggleIcon")
  }, $options.getColumnPT("rowToggleIcon")), null, 16, ["class"])) : createCommentVNode("", true)], 64))], 16, _hoisted_2$2$1)), [[_directive_ripple]]) : $props.editMode === "row" && $options.columnProp("rowEditor") ? (openBlock(), createElementBlock(Fragment, {
    key: 6
  }, [!$data.d_editing ? (openBlock(), createBlock(_component_Button, mergeProps({
    key: 0,
    "class": _ctx.cx("pcRowEditorInit"),
    "aria-label": $options.initButtonAriaLabel,
    unstyled: _ctx.unstyled,
    onClick: $options.onRowEditInit
  }, _objectSpread$a(_objectSpread$a({}, $options.getColumnPT("pcRowEditorInit")), $props.editButtonProps.init), {
    "data-pc-group-section": "rowactionbutton"
  }), {
    icon: withCtx(function(slotProps) {
      return [(openBlock(), createBlock(resolveDynamicComponent($props.column.children && $props.column.children.roweditoriniticon || "PencilIcon"), mergeProps({
        "class": slotProps["class"]
      }, $options.getColumnPT("pcRowEditorInit")["icon"]), null, 16, ["class"]))];
    }),
    _: 1
  }, 16, ["class", "aria-label", "unstyled", "onClick"])) : createCommentVNode("", true), $data.d_editing ? (openBlock(), createBlock(_component_Button, mergeProps({
    key: 1,
    "class": _ctx.cx("pcRowEditorSave"),
    "aria-label": $options.saveButtonAriaLabel,
    unstyled: _ctx.unstyled,
    onClick: $options.onRowEditSave
  }, _objectSpread$a(_objectSpread$a({}, $options.getColumnPT("pcRowEditorSave")), $props.editButtonProps.save), {
    "data-pc-group-section": "rowactionbutton"
  }), {
    icon: withCtx(function(slotProps) {
      return [(openBlock(), createBlock(resolveDynamicComponent($props.column.children && $props.column.children.roweditorsaveicon || "CheckIcon"), mergeProps({
        "class": slotProps["class"]
      }, $options.getColumnPT("pcRowEditorSave")["icon"]), null, 16, ["class"]))];
    }),
    _: 1
  }, 16, ["class", "aria-label", "unstyled", "onClick"])) : createCommentVNode("", true), $data.d_editing ? (openBlock(), createBlock(_component_Button, mergeProps({
    key: 2,
    "class": _ctx.cx("pcRowEditorCancel"),
    "aria-label": $options.cancelButtonAriaLabel,
    unstyled: _ctx.unstyled,
    onClick: $options.onRowEditCancel
  }, _objectSpread$a(_objectSpread$a({}, $options.getColumnPT("pcRowEditorCancel")), $props.editButtonProps.cancel), {
    "data-pc-group-section": "rowactionbutton"
  }), {
    icon: withCtx(function(slotProps) {
      return [(openBlock(), createBlock(resolveDynamicComponent($props.column.children && $props.column.children.roweditorcancelicon || "TimesIcon"), mergeProps({
        "class": slotProps["class"]
      }, $options.getColumnPT("pcRowEditorCancel")["icon"]), null, 16, ["class"]))];
    }),
    _: 1
  }, 16, ["class", "aria-label", "unstyled", "onClick"])) : createCommentVNode("", true)], 64)) : (openBlock(), createElementBlock(Fragment, {
    key: 7
  }, [createTextVNode(toDisplayString$1($options.resolveFieldData()), 1)], 64))], 16, _hoisted_1$4$1));
}
script$9.render = render$9;
function _typeof$9(o) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$9(o);
}
function _createForOfIteratorHelper$2(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$2$1(r)) || e) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray$2$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$2$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2$1(r, a) : void 0;
  }
}
function _arrayLikeToArray$2$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function ownKeys$9(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$9(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$9(Object(t), true).forEach(function(r2) {
      _defineProperty$9(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$9(e, r, t) {
  return (r = _toPropertyKey$9(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$9(t) {
  var i2 = _toPrimitive$9(t, "string");
  return "symbol" == _typeof$9(i2) ? i2 : i2 + "";
}
function _toPrimitive$9(t, r) {
  if ("object" != _typeof$9(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$9(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var script$8$1 = {
  name: "BodyRow",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["rowgroup-toggle", "row-click", "row-dblclick", "row-rightclick", "row-touchend", "row-keydown", "row-mousedown", "row-dragstart", "row-dragover", "row-dragleave", "row-dragend", "row-drop", "row-toggle", "radio-change", "checkbox-change", "cell-edit-init", "cell-edit-complete", "cell-edit-cancel", "row-edit-init", "row-edit-save", "row-edit-cancel", "editing-meta-change"],
  props: {
    rowData: {
      type: Object,
      "default": null
    },
    index: {
      type: Number,
      "default": 0
    },
    value: {
      type: Array,
      "default": null
    },
    columns: {
      type: null,
      "default": null
    },
    frozenRow: {
      type: Boolean,
      "default": false
    },
    empty: {
      type: Boolean,
      "default": false
    },
    rowGroupMode: {
      type: String,
      "default": null
    },
    groupRowsBy: {
      type: [Array, String, Function],
      "default": null
    },
    expandableRowGroups: {
      type: Boolean,
      "default": false
    },
    expandedRowGroups: {
      type: Array,
      "default": null
    },
    first: {
      type: Number,
      "default": 0
    },
    dataKey: {
      type: [String, Function],
      "default": null
    },
    expandedRowIcon: {
      type: String,
      "default": null
    },
    collapsedRowIcon: {
      type: String,
      "default": null
    },
    expandedRows: {
      type: [Array, Object],
      "default": null
    },
    selection: {
      type: [Array, Object],
      "default": null
    },
    selectionKeys: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    contextMenu: {
      type: Boolean,
      "default": false
    },
    contextMenuSelection: {
      type: Object,
      "default": null
    },
    rowClass: {
      type: null,
      "default": null
    },
    rowStyle: {
      type: null,
      "default": null
    },
    rowGroupHeaderStyle: {
      type: null,
      "default": null
    },
    editMode: {
      type: String,
      "default": null
    },
    compareSelectionBy: {
      type: String,
      "default": "deepEquals"
    },
    editingRows: {
      type: Array,
      "default": null
    },
    editingRowKeys: {
      type: null,
      "default": null
    },
    editingMeta: {
      type: Object,
      "default": null
    },
    templates: {
      type: null,
      "default": null
    },
    scrollable: {
      type: Boolean,
      "default": false
    },
    editButtonProps: {
      type: Object,
      "default": null
    },
    virtualScrollerContentProps: {
      type: Object,
      "default": null
    },
    isVirtualScrollerDisabled: {
      type: Boolean,
      "default": false
    },
    expandedRowId: {
      type: String,
      "default": null
    },
    nameAttributeSelector: {
      type: String,
      "default": null
    }
  },
  data: function data17() {
    return {
      d_rowExpanded: false
    };
  },
  watch: {
    expandedRows: {
      deep: true,
      immediate: true,
      handler: function handler4(newValue) {
        var _this = this;
        this.d_rowExpanded = this.dataKey ? (newValue === null || newValue === void 0 ? void 0 : newValue[resolveFieldData(this.rowData, this.dataKey)]) !== void 0 : newValue === null || newValue === void 0 ? void 0 : newValue.some(function(d) {
          return _this.equals(_this.rowData, d);
        });
      }
    }
  },
  methods: {
    columnProp: function columnProp2(col, prop2) {
      return getVNodeProp(col, prop2);
    },
    //@todo - update this method
    getColumnPT: function getColumnPT4(key) {
      var columnMetaData = {
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        }
      };
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.columnProp({}, "pt"), key, columnMetaData));
    },
    //@todo - update this method
    getBodyRowPTOptions: function getBodyRowPTOptions(key) {
      var _this$$parentInstance;
      var datatable = (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.$parentInstance;
      return this.ptm(key, {
        context: {
          index: this.rowIndex,
          selectable: (datatable === null || datatable === void 0 ? void 0 : datatable.rowHover) || (datatable === null || datatable === void 0 ? void 0 : datatable.selectionMode),
          selected: this.isSelected,
          stripedRows: (datatable === null || datatable === void 0 ? void 0 : datatable.stripedRows) || false
        }
      });
    },
    shouldRenderBodyCell: function shouldRenderBodyCell(column) {
      var isHidden2 = this.columnProp(column, "hidden");
      if (this.rowGroupMode && !isHidden2) {
        var field2 = this.columnProp(column, "field");
        if (this.rowGroupMode === "subheader") {
          return this.groupRowsBy !== field2;
        } else if (this.rowGroupMode === "rowspan") {
          if (this.isGrouped(column)) {
            var prevRowData = this.value[this.rowIndex - 1];
            if (prevRowData) {
              var currentRowFieldData = resolveFieldData(this.value[this.rowIndex], field2);
              var previousRowFieldData = resolveFieldData(prevRowData, field2);
              return currentRowFieldData !== previousRowFieldData;
            } else {
              return true;
            }
          } else {
            return true;
          }
        }
      } else {
        return !isHidden2;
      }
    },
    calculateRowGroupSize: function calculateRowGroupSize(column) {
      if (this.isGrouped(column)) {
        var index2 = this.rowIndex;
        var field2 = this.columnProp(column, "field");
        var currentRowFieldData = resolveFieldData(this.value[index2], field2);
        var nextRowFieldData = currentRowFieldData;
        var groupRowSpan = 0;
        while (currentRowFieldData === nextRowFieldData) {
          groupRowSpan++;
          var nextRowData = this.value[++index2];
          if (nextRowData) {
            nextRowFieldData = resolveFieldData(nextRowData, field2);
          } else {
            break;
          }
        }
        return groupRowSpan === 1 ? null : groupRowSpan;
      } else {
        return null;
      }
    },
    isGrouped: function isGrouped(column) {
      var field2 = this.columnProp(column, "field");
      if (this.groupRowsBy && field2) {
        if (Array.isArray(this.groupRowsBy)) return this.groupRowsBy.indexOf(field2) > -1;
        else return this.groupRowsBy === field2;
      } else {
        return false;
      }
    },
    findIndexInSelection: function findIndexInSelection(data28) {
      return this.findIndex(data28, this.selection);
    },
    findIndex: function findIndex(data28, collection) {
      var index2 = -1;
      if (collection && collection.length) {
        for (var i2 = 0; i2 < collection.length; i2++) {
          if (this.equals(data28, collection[i2])) {
            index2 = i2;
            break;
          }
        }
      }
      return index2;
    },
    equals: function equals$1(data1, data28) {
      return this.compareSelectionBy === "equals" ? data1 === data28 : equals(data1, data28, this.dataKey);
    },
    onRowGroupToggle: function onRowGroupToggle(event2) {
      this.$emit("rowgroup-toggle", {
        originalEvent: event2,
        data: this.rowData
      });
    },
    onRowClick: function onRowClick(event2) {
      this.$emit("row-click", {
        originalEvent: event2,
        data: this.rowData,
        index: this.rowIndex
      });
    },
    onRowDblClick: function onRowDblClick(event2) {
      this.$emit("row-dblclick", {
        originalEvent: event2,
        data: this.rowData,
        index: this.rowIndex
      });
    },
    onRowRightClick: function onRowRightClick(event2) {
      this.$emit("row-rightclick", {
        originalEvent: event2,
        data: this.rowData,
        index: this.rowIndex
      });
    },
    onRowTouchEnd: function onRowTouchEnd(event2) {
      this.$emit("row-touchend", event2);
    },
    onRowKeyDown: function onRowKeyDown(event2) {
      this.$emit("row-keydown", {
        originalEvent: event2,
        data: this.rowData,
        index: this.rowIndex
      });
    },
    onRowMouseDown: function onRowMouseDown(event2) {
      this.$emit("row-mousedown", event2);
    },
    onRowDragStart: function onRowDragStart(event2) {
      this.$emit("row-dragstart", {
        originalEvent: event2,
        index: this.rowIndex
      });
    },
    onRowDragOver: function onRowDragOver(event2) {
      this.$emit("row-dragover", {
        originalEvent: event2,
        index: this.rowIndex
      });
    },
    onRowDragLeave: function onRowDragLeave(event2) {
      this.$emit("row-dragleave", event2);
    },
    onRowDragEnd: function onRowDragEnd(event2) {
      this.$emit("row-dragend", event2);
    },
    onRowDrop: function onRowDrop(event2) {
      this.$emit("row-drop", event2);
    },
    onRowToggle: function onRowToggle(event2) {
      this.d_rowExpanded = !this.d_rowExpanded;
      this.$emit("row-toggle", _objectSpread$9(_objectSpread$9({}, event2), {}, {
        expanded: this.d_rowExpanded
      }));
    },
    onRadioChange: function onRadioChange(event2) {
      this.$emit("radio-change", event2);
    },
    onCheckboxChange: function onCheckboxChange(event2) {
      this.$emit("checkbox-change", event2);
    },
    onCellEditInit: function onCellEditInit(event2) {
      this.$emit("cell-edit-init", event2);
    },
    onCellEditComplete: function onCellEditComplete(event2) {
      this.$emit("cell-edit-complete", event2);
    },
    onCellEditCancel: function onCellEditCancel(event2) {
      this.$emit("cell-edit-cancel", event2);
    },
    onRowEditInit: function onRowEditInit2(event2) {
      this.$emit("row-edit-init", event2);
    },
    onRowEditSave: function onRowEditSave2(event2) {
      this.$emit("row-edit-save", event2);
    },
    onRowEditCancel: function onRowEditCancel2(event2) {
      this.$emit("row-edit-cancel", event2);
    },
    onEditingMetaChange: function onEditingMetaChange(event2) {
      this.$emit("editing-meta-change", event2);
    },
    getVirtualScrollerProp: function getVirtualScrollerProp2(option4, options3) {
      options3 = options3 || this.virtualScrollerContentProps;
      return options3 ? options3[option4] : null;
    }
  },
  computed: {
    rowIndex: function rowIndex() {
      var getItemOptions = this.getVirtualScrollerProp("getItemOptions");
      return getItemOptions ? getItemOptions(this.index).index : this.index;
    },
    rowStyles: function rowStyles() {
      var _this$rowStyle;
      return (_this$rowStyle = this.rowStyle) === null || _this$rowStyle === void 0 ? void 0 : _this$rowStyle.call(this, this.rowData);
    },
    rowClasses: function rowClasses() {
      var rowStyleClass = [];
      var columnSelectionMode = null;
      if (this.rowClass) {
        var rowClassValue = this.rowClass(this.rowData);
        if (rowClassValue) {
          rowStyleClass.push(rowClassValue);
        }
      }
      if (this.columns) {
        var _iterator = _createForOfIteratorHelper$2(this.columns), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var col = _step.value;
            var _selectionMode = this.columnProp(col, "selectionMode");
            if (isNotEmpty(_selectionMode)) {
              columnSelectionMode = _selectionMode;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return [this.cx("row", {
        rowData: this.rowData,
        index: this.rowIndex,
        columnSelectionMode
      }), rowStyleClass];
    },
    rowTabindex: function rowTabindex() {
      if (this.selection === null && (this.selectionMode === "single" || this.selectionMode === "multiple")) {
        return this.rowIndex === 0 ? 0 : -1;
      }
      return -1;
    },
    isRowEditing: function isRowEditing() {
      if (this.rowData && this.editingRows) {
        if (this.dataKey) return this.editingRowKeys ? this.editingRowKeys[resolveFieldData(this.rowData, this.dataKey)] !== void 0 : false;
        else return this.findIndex(this.rowData, this.editingRows) > -1;
      }
      return false;
    },
    isRowGroupExpanded: function isRowGroupExpanded() {
      if (this.expandableRowGroups && this.expandedRowGroups) {
        var groupFieldValue = resolveFieldData(this.rowData, this.groupRowsBy);
        return this.expandedRowGroups.indexOf(groupFieldValue) > -1;
      }
      return false;
    },
    isSelected: function isSelected5() {
      if (this.rowData && this.selection) {
        if (this.dataKey) {
          return this.selectionKeys ? this.selectionKeys[resolveFieldData(this.rowData, this.dataKey)] !== void 0 : false;
        } else {
          if (this.selection instanceof Array) return this.findIndexInSelection(this.rowData) > -1;
          else return this.equals(this.rowData, this.selection);
        }
      }
      return false;
    },
    isSelectedWithContextMenu: function isSelectedWithContextMenu() {
      if (this.rowData && this.contextMenuSelection) {
        return this.equals(this.rowData, this.contextMenuSelection, this.dataKey);
      }
      return false;
    },
    shouldRenderRowGroupHeader: function shouldRenderRowGroupHeader() {
      var currentRowFieldData = resolveFieldData(this.rowData, this.groupRowsBy);
      var prevRowData = this.value[this.rowIndex - 1];
      if (prevRowData) {
        var previousRowFieldData = resolveFieldData(prevRowData, this.groupRowsBy);
        return currentRowFieldData !== previousRowFieldData;
      } else {
        return true;
      }
    },
    shouldRenderRowGroupFooter: function shouldRenderRowGroupFooter() {
      if (this.expandableRowGroups && !this.isRowGroupExpanded) {
        return false;
      } else {
        var currentRowFieldData = resolveFieldData(this.rowData, this.groupRowsBy);
        var nextRowData = this.value[this.rowIndex + 1];
        if (nextRowData) {
          var nextRowFieldData = resolveFieldData(nextRowData, this.groupRowsBy);
          return currentRowFieldData !== nextRowFieldData;
        } else {
          return true;
        }
      }
    },
    columnsLength: function columnsLength() {
      var _this2 = this;
      if (this.columns) {
        var hiddenColLength = 0;
        this.columns.forEach(function(column) {
          if (_this2.columnProp(column, "selectionMode") === "single") hiddenColLength--;
          if (_this2.columnProp(column, "hidden")) hiddenColLength++;
        });
        return this.columns.length - hiddenColLength;
      }
      return 0;
    }
  },
  components: {
    DTBodyCell: script$9,
    ChevronDownIcon: script$P,
    ChevronRightIcon: script$q
  }
};
function _typeof$8(o) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$8(o);
}
function ownKeys$8(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$8(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$8(Object(t), true).forEach(function(r2) {
      _defineProperty$8(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$8(e, r, t) {
  return (r = _toPropertyKey$8(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$8(t) {
  var i2 = _toPrimitive$8(t, "string");
  return "symbol" == _typeof$8(i2) ? i2 : i2 + "";
}
function _toPrimitive$8(t, r) {
  if ("object" != _typeof$8(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$8(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var _hoisted_1$3$1 = ["colspan"];
var _hoisted_2$1$1 = ["tabindex", "aria-selected", "data-p-index", "data-p-selectable-row", "data-p-selected", "data-p-selected-contextmenu"];
var _hoisted_3$3 = ["id"];
var _hoisted_4$2 = ["colspan"];
var _hoisted_5$1 = ["colspan"];
var _hoisted_6$1 = ["colspan"];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_ChevronDownIcon = resolveComponent("ChevronDownIcon");
  var _component_ChevronRightIcon = resolveComponent("ChevronRightIcon");
  var _component_DTBodyCell = resolveComponent("DTBodyCell");
  return !$props.empty ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [$props.templates["groupheader"] && $props.rowGroupMode === "subheader" && $options.shouldRenderRowGroupHeader ? (openBlock(), createElementBlock("tr", mergeProps({
    key: 0,
    "class": _ctx.cx("rowGroupHeader"),
    style: $props.rowGroupHeaderStyle,
    role: "row"
  }, _ctx.ptm("rowGroupHeader")), [createBaseVNode("td", mergeProps({
    colspan: $options.columnsLength - 1
  }, _objectSpread$8(_objectSpread$8({}, $options.getColumnPT("bodycell")), _ctx.ptm("rowGroupHeaderCell"))), [$props.expandableRowGroups ? (openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    "class": _ctx.cx("rowToggleButton"),
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onRowGroupToggle && $options.onRowGroupToggle.apply($options, arguments);
    }),
    type: "button"
  }, _ctx.ptm("rowToggleButton")), [$props.templates["rowtoggleicon"] || $props.templates["rowgrouptogglericon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["rowtoggleicon"] || $props.templates["rowgrouptogglericon"]), {
    key: 0,
    expanded: $options.isRowGroupExpanded
  }, null, 8, ["expanded"])) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [$options.isRowGroupExpanded && $props.expandedRowIcon ? (openBlock(), createElementBlock("span", mergeProps({
    key: 0,
    "class": [_ctx.cx("rowToggleIcon"), $props.expandedRowIcon]
  }, _ctx.ptm("rowToggleIcon")), null, 16)) : $options.isRowGroupExpanded && !$props.expandedRowIcon ? (openBlock(), createBlock(_component_ChevronDownIcon, mergeProps({
    key: 1,
    "class": _ctx.cx("rowToggleIcon")
  }, _ctx.ptm("rowToggleIcon")), null, 16, ["class"])) : !$options.isRowGroupExpanded && $props.collapsedRowIcon ? (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    "class": [_ctx.cx("rowToggleIcon"), $props.collapsedRowIcon]
  }, _ctx.ptm("rowToggleIcon")), null, 16)) : !$options.isRowGroupExpanded && !$props.collapsedRowIcon ? (openBlock(), createBlock(_component_ChevronRightIcon, mergeProps({
    key: 3,
    "class": _ctx.cx("rowToggleIcon")
  }, _ctx.ptm("rowToggleIcon")), null, 16, ["class"])) : createCommentVNode("", true)], 64))], 16)) : createCommentVNode("", true), (openBlock(), createBlock(resolveDynamicComponent($props.templates["groupheader"]), {
    data: $props.rowData,
    index: $options.rowIndex
  }, null, 8, ["data", "index"]))], 16, _hoisted_1$3$1)], 16)) : createCommentVNode("", true), ($props.expandableRowGroups ? $options.isRowGroupExpanded : true) ? (openBlock(), createElementBlock("tr", mergeProps({
    key: 1,
    "class": $options.rowClasses,
    style: $options.rowStyles,
    tabindex: $options.rowTabindex,
    role: "row",
    "aria-selected": $props.selectionMode ? $options.isSelected : null,
    onClick: _cache[1] || (_cache[1] = function() {
      return $options.onRowClick && $options.onRowClick.apply($options, arguments);
    }),
    onDblclick: _cache[2] || (_cache[2] = function() {
      return $options.onRowDblClick && $options.onRowDblClick.apply($options, arguments);
    }),
    onContextmenu: _cache[3] || (_cache[3] = function() {
      return $options.onRowRightClick && $options.onRowRightClick.apply($options, arguments);
    }),
    onTouchend: _cache[4] || (_cache[4] = function() {
      return $options.onRowTouchEnd && $options.onRowTouchEnd.apply($options, arguments);
    }),
    onKeydown: _cache[5] || (_cache[5] = withModifiers(function() {
      return $options.onRowKeyDown && $options.onRowKeyDown.apply($options, arguments);
    }, ["self"])),
    onMousedown: _cache[6] || (_cache[6] = function() {
      return $options.onRowMouseDown && $options.onRowMouseDown.apply($options, arguments);
    }),
    onDragstart: _cache[7] || (_cache[7] = function() {
      return $options.onRowDragStart && $options.onRowDragStart.apply($options, arguments);
    }),
    onDragover: _cache[8] || (_cache[8] = function() {
      return $options.onRowDragOver && $options.onRowDragOver.apply($options, arguments);
    }),
    onDragleave: _cache[9] || (_cache[9] = function() {
      return $options.onRowDragLeave && $options.onRowDragLeave.apply($options, arguments);
    }),
    onDragend: _cache[10] || (_cache[10] = function() {
      return $options.onRowDragEnd && $options.onRowDragEnd.apply($options, arguments);
    }),
    onDrop: _cache[11] || (_cache[11] = function() {
      return $options.onRowDrop && $options.onRowDrop.apply($options, arguments);
    })
  }, $options.getBodyRowPTOptions("bodyRow"), {
    "data-p-index": $options.rowIndex,
    "data-p-selectable-row": $props.selectionMode ? true : false,
    "data-p-selected": $props.selection && $options.isSelected,
    "data-p-selected-contextmenu": $props.contextMenuSelection && $options.isSelectedWithContextMenu
  }), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, function(col, i2) {
    return openBlock(), createElementBlock(Fragment, null, [$options.shouldRenderBodyCell(col) ? (openBlock(), createBlock(_component_DTBodyCell, {
      key: $options.columnProp(col, "columnKey") || $options.columnProp(col, "field") || i2,
      rowData: $props.rowData,
      column: col,
      rowIndex: $options.rowIndex,
      index: i2,
      selected: $options.isSelected,
      frozenRow: $props.frozenRow,
      rowspan: $props.rowGroupMode === "rowspan" ? $options.calculateRowGroupSize(col) : null,
      editMode: $props.editMode,
      editing: $props.editMode === "row" && $options.isRowEditing,
      editingMeta: $props.editingMeta,
      virtualScrollerContentProps: $props.virtualScrollerContentProps,
      ariaControls: $props.expandedRowId + "_" + $options.rowIndex + "_expansion",
      name: $props.nameAttributeSelector,
      isRowExpanded: $data.d_rowExpanded,
      expandedRowIcon: $props.expandedRowIcon,
      collapsedRowIcon: $props.collapsedRowIcon,
      editButtonProps: $props.editButtonProps,
      onRadioChange: $options.onRadioChange,
      onCheckboxChange: $options.onCheckboxChange,
      onRowToggle: $options.onRowToggle,
      onCellEditInit: $options.onCellEditInit,
      onCellEditComplete: $options.onCellEditComplete,
      onCellEditCancel: $options.onCellEditCancel,
      onRowEditInit: $options.onRowEditInit,
      onRowEditSave: $options.onRowEditSave,
      onRowEditCancel: $options.onRowEditCancel,
      onEditingMetaChange: $options.onEditingMetaChange,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["rowData", "column", "rowIndex", "index", "selected", "frozenRow", "rowspan", "editMode", "editing", "editingMeta", "virtualScrollerContentProps", "ariaControls", "name", "isRowExpanded", "expandedRowIcon", "collapsedRowIcon", "editButtonProps", "onRadioChange", "onCheckboxChange", "onRowToggle", "onCellEditInit", "onCellEditComplete", "onCellEditCancel", "onRowEditInit", "onRowEditSave", "onRowEditCancel", "onEditingMetaChange", "unstyled", "pt"])) : createCommentVNode("", true)], 64);
  }), 256))], 16, _hoisted_2$1$1)) : createCommentVNode("", true), $props.templates["expansion"] && $props.expandedRows && $data.d_rowExpanded ? (openBlock(), createElementBlock("tr", mergeProps({
    key: 2,
    id: $props.expandedRowId + "_" + $options.rowIndex + "_expansion",
    "class": _ctx.cx("rowExpansion"),
    role: "row"
  }, _ctx.ptm("rowExpansion")), [createBaseVNode("td", mergeProps({
    colspan: $options.columnsLength
  }, _objectSpread$8(_objectSpread$8({}, $options.getColumnPT("bodycell")), _ctx.ptm("rowExpansionCell"))), [(openBlock(), createBlock(resolveDynamicComponent($props.templates["expansion"]), {
    data: $props.rowData,
    index: $options.rowIndex
  }, null, 8, ["data", "index"]))], 16, _hoisted_4$2)], 16, _hoisted_3$3)) : createCommentVNode("", true), $props.templates["groupfooter"] && $props.rowGroupMode === "subheader" && $options.shouldRenderRowGroupFooter ? (openBlock(), createElementBlock("tr", mergeProps({
    key: 3,
    "class": _ctx.cx("rowGroupFooter"),
    role: "row"
  }, _ctx.ptm("rowGroupFooter")), [createBaseVNode("td", mergeProps({
    colspan: $options.columnsLength - 1
  }, _objectSpread$8(_objectSpread$8({}, $options.getColumnPT("bodycell")), _ctx.ptm("rowGroupFooterCell"))), [(openBlock(), createBlock(resolveDynamicComponent($props.templates["groupfooter"]), {
    data: $props.rowData,
    index: $options.rowIndex
  }, null, 8, ["data", "index"]))], 16, _hoisted_5$1)], 16)) : createCommentVNode("", true)], 64)) : (openBlock(), createElementBlock("tr", mergeProps({
    key: 1,
    "class": _ctx.cx("emptyMessage"),
    role: "row"
  }, _ctx.ptm("emptyMessage")), [createBaseVNode("td", mergeProps({
    colspan: $options.columnsLength
  }, _objectSpread$8(_objectSpread$8({}, $options.getColumnPT("bodycell")), _ctx.ptm("emptyMessageCell"))), [$props.templates.empty ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.empty), {
    key: 0
  })) : createCommentVNode("", true)], 16, _hoisted_6$1)], 16));
}
script$8$1.render = render$8;
var script$7$1 = {
  name: "TableBody",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["rowgroup-toggle", "row-click", "row-dblclick", "row-rightclick", "row-touchend", "row-keydown", "row-mousedown", "row-dragstart", "row-dragover", "row-dragleave", "row-dragend", "row-drop", "row-toggle", "radio-change", "checkbox-change", "cell-edit-init", "cell-edit-complete", "cell-edit-cancel", "row-edit-init", "row-edit-save", "row-edit-cancel", "editing-meta-change"],
  props: {
    value: {
      type: Array,
      "default": null
    },
    columns: {
      type: null,
      "default": null
    },
    frozenRow: {
      type: Boolean,
      "default": false
    },
    empty: {
      type: Boolean,
      "default": false
    },
    rowGroupMode: {
      type: String,
      "default": null
    },
    groupRowsBy: {
      type: [Array, String, Function],
      "default": null
    },
    expandableRowGroups: {
      type: Boolean,
      "default": false
    },
    expandedRowGroups: {
      type: Array,
      "default": null
    },
    first: {
      type: Number,
      "default": 0
    },
    dataKey: {
      type: [String, Function],
      "default": null
    },
    expandedRowIcon: {
      type: String,
      "default": null
    },
    collapsedRowIcon: {
      type: String,
      "default": null
    },
    expandedRows: {
      type: [Array, Object],
      "default": null
    },
    selection: {
      type: [Array, Object],
      "default": null
    },
    selectionKeys: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    contextMenu: {
      type: Boolean,
      "default": false
    },
    contextMenuSelection: {
      type: Object,
      "default": null
    },
    rowClass: {
      type: null,
      "default": null
    },
    rowStyle: {
      type: null,
      "default": null
    },
    editMode: {
      type: String,
      "default": null
    },
    compareSelectionBy: {
      type: String,
      "default": "deepEquals"
    },
    editingRows: {
      type: Array,
      "default": null
    },
    editingRowKeys: {
      type: null,
      "default": null
    },
    editingMeta: {
      type: Object,
      "default": null
    },
    templates: {
      type: null,
      "default": null
    },
    scrollable: {
      type: Boolean,
      "default": false
    },
    editButtonProps: {
      type: Object,
      "default": null
    },
    virtualScrollerContentProps: {
      type: Object,
      "default": null
    },
    isVirtualScrollerDisabled: {
      type: Boolean,
      "default": false
    }
  },
  data: function data18() {
    return {
      rowGroupHeaderStyleObject: {}
    };
  },
  mounted: function mounted14() {
    if (this.frozenRow) {
      this.updateFrozenRowStickyPosition();
    }
    if (this.scrollable && this.rowGroupMode === "subheader") {
      this.updateFrozenRowGroupHeaderStickyPosition();
    }
  },
  updated: function updated9() {
    if (this.frozenRow) {
      this.updateFrozenRowStickyPosition();
    }
    if (this.scrollable && this.rowGroupMode === "subheader") {
      this.updateFrozenRowGroupHeaderStickyPosition();
    }
  },
  methods: {
    getRowKey: function getRowKey(rowData, rowIndex2) {
      return this.dataKey ? resolveFieldData(rowData, this.dataKey) : rowIndex2;
    },
    updateFrozenRowStickyPosition: function updateFrozenRowStickyPosition() {
      this.$el.style.top = getOuterHeight(this.$el.previousElementSibling) + "px";
    },
    updateFrozenRowGroupHeaderStickyPosition: function updateFrozenRowGroupHeaderStickyPosition() {
      var tableHeaderHeight = getOuterHeight(this.$el.previousElementSibling);
      this.rowGroupHeaderStyleObject.top = tableHeaderHeight + "px";
    },
    getVirtualScrollerProp: function getVirtualScrollerProp3(option4, options3) {
      options3 = options3 || this.virtualScrollerContentProps;
      return options3 ? options3[option4] : null;
    },
    bodyRef: function bodyRef(el) {
      var contentRef3 = this.getVirtualScrollerProp("contentRef");
      contentRef3 && contentRef3(el);
    }
  },
  computed: {
    rowGroupHeaderStyle: function rowGroupHeaderStyle() {
      if (this.scrollable) {
        return {
          top: this.rowGroupHeaderStyleObject.top
        };
      }
      return null;
    },
    bodyContentStyle: function bodyContentStyle() {
      return this.getVirtualScrollerProp("contentStyle");
    },
    ptmTBodyOptions: function ptmTBodyOptions() {
      var _this$$parentInstance;
      return {
        context: {
          scrollable: (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 || (_this$$parentInstance = _this$$parentInstance.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.scrollable
        }
      };
    },
    expandedRowId: function expandedRowId() {
      return UniqueComponentId();
    },
    nameAttributeSelector: function nameAttributeSelector() {
      return UniqueComponentId();
    }
  },
  components: {
    DTBodyRow: script$8$1
  }
};
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_DTBodyRow = resolveComponent("DTBodyRow");
  return openBlock(), createElementBlock("tbody", mergeProps({
    ref: $options.bodyRef,
    "class": _ctx.cx("tbody"),
    role: "rowgroup",
    style: $options.bodyContentStyle
  }, _ctx.ptm("tbody", $options.ptmTBodyOptions)), [!$props.empty ? (openBlock(true), createElementBlock(Fragment, {
    key: 0
  }, renderList($props.value, function(rowData, rowIndex2) {
    return openBlock(), createBlock(_component_DTBodyRow, {
      key: $options.getRowKey(rowData, rowIndex2),
      rowData,
      index: rowIndex2,
      value: $props.value,
      columns: $props.columns,
      frozenRow: $props.frozenRow,
      empty: $props.empty,
      first: $props.first,
      dataKey: $props.dataKey,
      selection: $props.selection,
      selectionKeys: $props.selectionKeys,
      selectionMode: $props.selectionMode,
      contextMenu: $props.contextMenu,
      contextMenuSelection: $props.contextMenuSelection,
      rowGroupMode: $props.rowGroupMode,
      groupRowsBy: $props.groupRowsBy,
      expandableRowGroups: $props.expandableRowGroups,
      rowClass: $props.rowClass,
      rowStyle: $props.rowStyle,
      editMode: $props.editMode,
      compareSelectionBy: $props.compareSelectionBy,
      scrollable: $props.scrollable,
      expandedRowIcon: $props.expandedRowIcon,
      collapsedRowIcon: $props.collapsedRowIcon,
      expandedRows: $props.expandedRows,
      expandedRowGroups: $props.expandedRowGroups,
      editingRows: $props.editingRows,
      editingRowKeys: $props.editingRowKeys,
      templates: $props.templates,
      editButtonProps: $props.editButtonProps,
      virtualScrollerContentProps: $props.virtualScrollerContentProps,
      isVirtualScrollerDisabled: $props.isVirtualScrollerDisabled,
      editingMeta: $props.editingMeta,
      rowGroupHeaderStyle: $options.rowGroupHeaderStyle,
      expandedRowId: $options.expandedRowId,
      nameAttributeSelector: $options.nameAttributeSelector,
      onRowgroupToggle: _cache[0] || (_cache[0] = function($event) {
        return _ctx.$emit("rowgroup-toggle", $event);
      }),
      onRowClick: _cache[1] || (_cache[1] = function($event) {
        return _ctx.$emit("row-click", $event);
      }),
      onRowDblclick: _cache[2] || (_cache[2] = function($event) {
        return _ctx.$emit("row-dblclick", $event);
      }),
      onRowRightclick: _cache[3] || (_cache[3] = function($event) {
        return _ctx.$emit("row-rightclick", $event);
      }),
      onRowTouchend: _cache[4] || (_cache[4] = function($event) {
        return _ctx.$emit("row-touchend", $event);
      }),
      onRowKeydown: _cache[5] || (_cache[5] = function($event) {
        return _ctx.$emit("row-keydown", $event);
      }),
      onRowMousedown: _cache[6] || (_cache[6] = function($event) {
        return _ctx.$emit("row-mousedown", $event);
      }),
      onRowDragstart: _cache[7] || (_cache[7] = function($event) {
        return _ctx.$emit("row-dragstart", $event);
      }),
      onRowDragover: _cache[8] || (_cache[8] = function($event) {
        return _ctx.$emit("row-dragover", $event);
      }),
      onRowDragleave: _cache[9] || (_cache[9] = function($event) {
        return _ctx.$emit("row-dragleave", $event);
      }),
      onRowDragend: _cache[10] || (_cache[10] = function($event) {
        return _ctx.$emit("row-dragend", $event);
      }),
      onRowDrop: _cache[11] || (_cache[11] = function($event) {
        return _ctx.$emit("row-drop", $event);
      }),
      onRowToggle: _cache[12] || (_cache[12] = function($event) {
        return _ctx.$emit("row-toggle", $event);
      }),
      onRadioChange: _cache[13] || (_cache[13] = function($event) {
        return _ctx.$emit("radio-change", $event);
      }),
      onCheckboxChange: _cache[14] || (_cache[14] = function($event) {
        return _ctx.$emit("checkbox-change", $event);
      }),
      onCellEditInit: _cache[15] || (_cache[15] = function($event) {
        return _ctx.$emit("cell-edit-init", $event);
      }),
      onCellEditComplete: _cache[16] || (_cache[16] = function($event) {
        return _ctx.$emit("cell-edit-complete", $event);
      }),
      onCellEditCancel: _cache[17] || (_cache[17] = function($event) {
        return _ctx.$emit("cell-edit-cancel", $event);
      }),
      onRowEditInit: _cache[18] || (_cache[18] = function($event) {
        return _ctx.$emit("row-edit-init", $event);
      }),
      onRowEditSave: _cache[19] || (_cache[19] = function($event) {
        return _ctx.$emit("row-edit-save", $event);
      }),
      onRowEditCancel: _cache[20] || (_cache[20] = function($event) {
        return _ctx.$emit("row-edit-cancel", $event);
      }),
      onEditingMetaChange: _cache[21] || (_cache[21] = function($event) {
        return _ctx.$emit("editing-meta-change", $event);
      }),
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["rowData", "index", "value", "columns", "frozenRow", "empty", "first", "dataKey", "selection", "selectionKeys", "selectionMode", "contextMenu", "contextMenuSelection", "rowGroupMode", "groupRowsBy", "expandableRowGroups", "rowClass", "rowStyle", "editMode", "compareSelectionBy", "scrollable", "expandedRowIcon", "collapsedRowIcon", "expandedRows", "expandedRowGroups", "editingRows", "editingRowKeys", "templates", "editButtonProps", "virtualScrollerContentProps", "isVirtualScrollerDisabled", "editingMeta", "rowGroupHeaderStyle", "expandedRowId", "nameAttributeSelector", "unstyled", "pt"]);
  }), 128)) : (openBlock(), createBlock(_component_DTBodyRow, {
    key: 1,
    empty: $props.empty,
    columns: $props.columns,
    templates: $props.templates
  }, null, 8, ["empty", "columns", "templates"]))], 16);
}
script$7$1.render = render$7;
var script$6$1 = {
  name: "FooterCell",
  hostName: "DataTable",
  "extends": script$1a,
  props: {
    column: {
      type: Object,
      "default": null
    },
    index: {
      type: Number,
      "default": null
    }
  },
  data: function data19() {
    return {
      styleObject: {}
    };
  },
  mounted: function mounted15() {
    if (this.columnProp("frozen")) {
      this.updateStickyPosition();
    }
  },
  updated: function updated10() {
    if (this.columnProp("frozen")) {
      this.updateStickyPosition();
    }
  },
  methods: {
    columnProp: function columnProp3(prop2) {
      return getVNodeProp(this.column, prop2);
    },
    getColumnPT: function getColumnPT5(key) {
      var _this$$parentInstance, _this$$parentInstance2;
      var columnMetaData = {
        props: this.column.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: this.index,
          size: (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 || (_this$$parentInstance = _this$$parentInstance.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.size,
          showGridlines: ((_this$$parentInstance2 = this.$parentInstance) === null || _this$$parentInstance2 === void 0 || (_this$$parentInstance2 = _this$$parentInstance2.$parentInstance) === null || _this$$parentInstance2 === void 0 ? void 0 : _this$$parentInstance2.showGridlines) || false
        }
      };
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.getColumnProp(), key, columnMetaData));
    },
    getColumnProp: function getColumnProp4() {
      return this.column.props && this.column.props.pt ? this.column.props.pt : void 0;
    },
    updateStickyPosition: function updateStickyPosition2() {
      if (this.columnProp("frozen")) {
        var align2 = this.columnProp("alignFrozen");
        if (align2 === "right") {
          var right = 0;
          var next2 = getNextElementSibling(this.$el, '[data-p-frozen-column="true"]');
          if (next2) {
            right = getOuterWidth(next2) + parseFloat(next2.style.right || 0);
          }
          this.styleObject.right = right + "px";
        } else {
          var left = 0;
          var prev2 = getPreviousElementSibling(this.$el, '[data-p-frozen-column="true"]');
          if (prev2) {
            left = getOuterWidth(prev2) + parseFloat(prev2.style.left || 0);
          }
          this.styleObject.left = left + "px";
        }
      }
    }
  },
  computed: {
    containerClass: function containerClass4() {
      return [this.columnProp("footerClass"), this.columnProp("class"), this.cx("footerCell")];
    },
    containerStyle: function containerStyle2() {
      var bodyStyle = this.columnProp("footerStyle");
      var columnStyle = this.columnProp("style");
      return this.columnProp("frozen") ? [columnStyle, bodyStyle, this.styleObject] : [columnStyle, bodyStyle];
    }
  }
};
function _typeof$7(o) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$7(o);
}
function ownKeys$7(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$7(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$7(Object(t), true).forEach(function(r2) {
      _defineProperty$7(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$7(e, r, t) {
  return (r = _toPropertyKey$7(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$7(t) {
  var i2 = _toPrimitive$7(t, "string");
  return "symbol" == _typeof$7(i2) ? i2 : i2 + "";
}
function _toPrimitive$7(t, r) {
  if ("object" != _typeof$7(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$7(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var _hoisted_1$2$1 = ["colspan", "rowspan", "data-p-frozen-column"];
function render$6$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("td", mergeProps({
    style: $options.containerStyle,
    "class": $options.containerClass,
    role: "cell",
    colspan: $options.columnProp("colspan"),
    rowspan: $options.columnProp("rowspan")
  }, _objectSpread$7(_objectSpread$7({}, $options.getColumnPT("root")), $options.getColumnPT("footerCell")), {
    "data-p-frozen-column": $options.columnProp("frozen")
  }), [$props.column.children && $props.column.children.footer ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.footer), {
    key: 0,
    column: $props.column
  }, null, 8, ["column"])) : createCommentVNode("", true), $options.columnProp("footer") ? (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    "class": _ctx.cx("columnFooter")
  }, $options.getColumnPT("columnFooter")), toDisplayString$1($options.columnProp("footer")), 17)) : createCommentVNode("", true)], 16, _hoisted_1$2$1);
}
script$6$1.render = render$6$1;
function _createForOfIteratorHelper$1$1(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$1$1(r)) || e) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray$1$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1$1(r, a) : void 0;
  }
}
function _arrayLikeToArray$1$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$5$1 = {
  name: "TableFooter",
  hostName: "DataTable",
  "extends": script$1a,
  props: {
    columnGroup: {
      type: null,
      "default": null
    },
    columns: {
      type: Object,
      "default": null
    }
  },
  provide: function provide35() {
    return {
      $rows: this.d_footerRows,
      $columns: this.d_footerColumns
    };
  },
  data: function data20() {
    return {
      d_footerRows: new _default({
        type: "Row"
      }),
      d_footerColumns: new _default({
        type: "Column"
      })
    };
  },
  beforeUnmount: function beforeUnmount8() {
    this.d_footerRows.clear();
    this.d_footerColumns.clear();
  },
  methods: {
    columnProp: function columnProp4(col, prop2) {
      return getVNodeProp(col, prop2);
    },
    getColumnGroupPT: function getColumnGroupPT(key) {
      var columnGroupMetaData = {
        props: this.getColumnGroupProps(),
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          type: "footer",
          scrollable: this.ptmTFootOptions.context.scrollable
        }
      };
      return mergeProps(this.ptm("columnGroup.".concat(key), {
        columnGroup: columnGroupMetaData
      }), this.ptm("columnGroup.".concat(key), columnGroupMetaData), this.ptmo(this.getColumnGroupProps(), key, columnGroupMetaData));
    },
    getColumnGroupProps: function getColumnGroupProps() {
      return this.columnGroup && this.columnGroup.props && this.columnGroup.props.pt ? this.columnGroup.props.pt : void 0;
    },
    getRowPT: function getRowPT(row2, key, index2) {
      var rowMetaData = {
        props: row2.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: index2
        }
      };
      return mergeProps(this.ptm("row.".concat(key), {
        row: rowMetaData
      }), this.ptm("row.".concat(key), rowMetaData), this.ptmo(this.getRowProp(row2), key, rowMetaData));
    },
    getRowProp: function getRowProp(row2) {
      return row2.props && row2.props.pt ? row2.props.pt : void 0;
    },
    getFooterRows: function getFooterRows() {
      var _this$d_footerRows;
      return (_this$d_footerRows = this.d_footerRows) === null || _this$d_footerRows === void 0 ? void 0 : _this$d_footerRows.get(this.columnGroup, this.columnGroup.children);
    },
    getFooterColumns: function getFooterColumns(row2) {
      var _this$d_footerColumns;
      return (_this$d_footerColumns = this.d_footerColumns) === null || _this$d_footerColumns === void 0 ? void 0 : _this$d_footerColumns.get(row2, row2.children);
    }
  },
  computed: {
    hasFooter: function hasFooter() {
      var hasFooter2 = false;
      if (this.columnGroup) {
        hasFooter2 = true;
      } else if (this.columns) {
        var _iterator = _createForOfIteratorHelper$1$1(this.columns), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var col = _step.value;
            if (this.columnProp(col, "footer") || col.children && col.children.footer) {
              hasFooter2 = true;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return hasFooter2;
    },
    ptmTFootOptions: function ptmTFootOptions() {
      var _this$$parentInstance;
      return {
        context: {
          scrollable: (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 || (_this$$parentInstance = _this$$parentInstance.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.scrollable
        }
      };
    }
  },
  components: {
    DTFooterCell: script$6$1
  }
};
function _typeof$6(o) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$6(o);
}
function ownKeys$6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$6(Object(t), true).forEach(function(r2) {
      _defineProperty$6(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$6(e, r, t) {
  return (r = _toPropertyKey$6(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$6(t) {
  var i2 = _toPrimitive$6(t, "string");
  return "symbol" == _typeof$6(i2) ? i2 : i2 + "";
}
function _toPrimitive$6(t, r) {
  if ("object" != _typeof$6(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function render$5$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_DTFooterCell = resolveComponent("DTFooterCell");
  return $options.hasFooter ? (openBlock(), createElementBlock("tfoot", mergeProps({
    key: 0,
    "class": _ctx.cx("tfoot"),
    style: _ctx.sx("tfoot"),
    role: "rowgroup"
  }, $props.columnGroup ? _objectSpread$6(_objectSpread$6({}, _ctx.ptm("tfoot", $options.ptmTFootOptions)), $options.getColumnGroupPT("root")) : _ctx.ptm("tfoot", $options.ptmTFootOptions), {
    "data-pc-section": "tfoot"
  }), [!$props.columnGroup ? (openBlock(), createElementBlock("tr", mergeProps({
    key: 0,
    role: "row"
  }, _ctx.ptm("footerRow")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, function(col, i2) {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.columnProp(col, "columnKey") || $options.columnProp(col, "field") || i2
    }, [!$options.columnProp(col, "hidden") ? (openBlock(), createBlock(_component_DTFooterCell, {
      key: 0,
      column: col,
      pt: _ctx.pt
    }, null, 8, ["column", "pt"])) : createCommentVNode("", true)], 64);
  }), 128))], 16)) : (openBlock(true), createElementBlock(Fragment, {
    key: 1
  }, renderList($options.getFooterRows(), function(row2, i2) {
    return openBlock(), createElementBlock("tr", mergeProps({
      key: i2,
      role: "row",
      ref_for: true
    }, _objectSpread$6(_objectSpread$6({}, _ctx.ptm("footerRow")), $options.getRowPT(row2, "root", i2))), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.getFooterColumns(row2), function(col, j) {
      return openBlock(), createElementBlock(Fragment, {
        key: $options.columnProp(col, "columnKey") || $options.columnProp(col, "field") || j
      }, [!$options.columnProp(col, "hidden") ? (openBlock(), createBlock(_component_DTFooterCell, {
        key: 0,
        column: col,
        index: i2,
        pt: _ctx.pt
      }, null, 8, ["column", "index", "pt"])) : createCommentVNode("", true)], 64);
    }), 128))], 16);
  }), 128))], 16)) : createCommentVNode("", true);
}
script$5$1.render = render$5$1;
function _typeof$5(o) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$5(o);
}
function ownKeys$5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$5(Object(t), true).forEach(function(r2) {
      _defineProperty$5(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$5(e, r, t) {
  return (r = _toPropertyKey$5(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$5(t) {
  var i2 = _toPrimitive$5(t, "string");
  return "symbol" == _typeof$5(i2) ? i2 : i2 + "";
}
function _toPrimitive$5(t, r) {
  if ("object" != _typeof$5(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var script$4$1 = {
  name: "ColumnFilter",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["filter-change", "filter-apply", "operator-change", "matchmode-change", "constraint-add", "constraint-remove", "filter-clear", "apply-click"],
  props: {
    field: {
      type: String,
      "default": null
    },
    type: {
      type: String,
      "default": "text"
    },
    display: {
      type: String,
      "default": null
    },
    showMenu: {
      type: Boolean,
      "default": true
    },
    matchMode: {
      type: String,
      "default": null
    },
    showOperator: {
      type: Boolean,
      "default": true
    },
    showClearButton: {
      type: Boolean,
      "default": true
    },
    showApplyButton: {
      type: Boolean,
      "default": true
    },
    showMatchModes: {
      type: Boolean,
      "default": true
    },
    showAddButton: {
      type: Boolean,
      "default": true
    },
    matchModeOptions: {
      type: Array,
      "default": null
    },
    maxConstraints: {
      type: Number,
      "default": 2
    },
    filterElement: {
      type: Function,
      "default": null
    },
    filterHeaderTemplate: {
      type: Function,
      "default": null
    },
    filterFooterTemplate: {
      type: Function,
      "default": null
    },
    filterClearTemplate: {
      type: Function,
      "default": null
    },
    filterApplyTemplate: {
      type: Function,
      "default": null
    },
    filterIconTemplate: {
      type: Function,
      "default": null
    },
    filterAddIconTemplate: {
      type: Function,
      "default": null
    },
    filterRemoveIconTemplate: {
      type: Function,
      "default": null
    },
    filterClearIconTemplate: {
      type: Function,
      "default": null
    },
    filters: {
      type: Object,
      "default": null
    },
    filtersStore: {
      type: Object,
      "default": null
    },
    filterMenuClass: {
      type: String,
      "default": null
    },
    filterMenuStyle: {
      type: null,
      "default": null
    },
    filterInputProps: {
      type: null,
      "default": null
    },
    filterButtonProps: {
      type: null,
      "default": null
    },
    column: null
  },
  data: function data21() {
    return {
      id: this.$attrs.id,
      overlayVisible: false,
      defaultMatchMode: null,
      defaultOperator: null
    };
  },
  watch: {
    "$attrs.id": function $attrsId6(newValue) {
      this.id = newValue || UniqueComponentId();
    }
  },
  overlay: null,
  selfClick: false,
  overlayEventListener: null,
  beforeUnmount: function beforeUnmount9() {
    if (this.overlayEventListener) {
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
    }
    if (this.overlay) {
      ZIndex.clear(this.overlay);
      this.onOverlayHide();
    }
  },
  mounted: function mounted16() {
    this.id = this.id || UniqueComponentId();
    if (this.filters && this.filters[this.field]) {
      var fieldFilters = this.filters[this.field];
      if (fieldFilters.operator) {
        this.defaultMatchMode = fieldFilters.constraints[0].matchMode;
        this.defaultOperator = fieldFilters.operator;
      } else {
        this.defaultMatchMode = this.filters[this.field].matchMode;
      }
    }
  },
  methods: {
    getColumnPT: function getColumnPT6(key, params) {
      var columnMetaData = _objectSpread$5({
        props: this.column.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        }
      }, params);
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.getColumnProp(), key, columnMetaData));
    },
    getColumnProp: function getColumnProp5() {
      return this.column.props && this.column.props.pt ? this.column.props.pt : void 0;
    },
    ptmFilterConstraintOptions: function ptmFilterConstraintOptions(matchMode) {
      return {
        context: {
          highlighted: matchMode && this.isRowMatchModeSelected(matchMode.value)
        }
      };
    },
    clearFilter: function clearFilter() {
      var _filters = _objectSpread$5({}, this.filters);
      if (_filters[this.field].operator) {
        _filters[this.field].constraints.splice(1);
        _filters[this.field].operator = this.defaultOperator;
        _filters[this.field].constraints[0] = {
          value: null,
          matchMode: this.defaultMatchMode
        };
      } else {
        _filters[this.field].value = null;
        _filters[this.field].matchMode = this.defaultMatchMode;
      }
      this.$emit("filter-clear");
      this.$emit("filter-change", _filters);
      this.$emit("filter-apply");
      this.hide();
    },
    applyFilter: function applyFilter() {
      this.$emit("apply-click", {
        field: this.field,
        constraints: this.filters[this.field]
      });
      this.$emit("filter-apply");
      this.hide();
    },
    hasFilter: function hasFilter() {
      if (this.filtersStore) {
        var fieldFilter = this.filtersStore[this.field];
        if (fieldFilter) {
          if (fieldFilter.operator) return !this.isFilterBlank(fieldFilter.constraints[0].value);
          else return !this.isFilterBlank(fieldFilter.value);
        }
      }
      return false;
    },
    hasRowFilter: function hasRowFilter() {
      return this.filters[this.field] && !this.isFilterBlank(this.filters[this.field].value);
    },
    isFilterBlank: function isFilterBlank(filter5) {
      if (filter5 !== null && filter5 !== void 0) {
        if (typeof filter5 === "string" && filter5.trim().length == 0 || filter5 instanceof Array && filter5.length == 0) return true;
        else return false;
      }
      return true;
    },
    toggleMenu: function toggleMenu(event2) {
      this.overlayVisible = !this.overlayVisible;
      event2.preventDefault();
    },
    onToggleButtonKeyDown: function onToggleButtonKeyDown(event2) {
      switch (event2.code) {
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.toggleMenu(event2);
          break;
        case "Escape":
          this.overlayVisible = false;
          break;
      }
    },
    onRowMatchModeChange: function onRowMatchModeChange(matchMode) {
      var _filters = _objectSpread$5({}, this.filters);
      _filters[this.field].matchMode = matchMode;
      this.$emit("matchmode-change", {
        field: this.field,
        matchMode
      });
      this.$emit("filter-change", _filters);
      this.$emit("filter-apply");
      this.hide();
    },
    onRowMatchModeKeyDown: function onRowMatchModeKeyDown(event2) {
      var item = event2.target;
      switch (event2.code) {
        case "ArrowDown":
          var nextItem = this.findNextItem(item);
          if (nextItem) {
            item.removeAttribute("tabindex");
            nextItem.tabIndex = "0";
            nextItem.focus();
          }
          event2.preventDefault();
          break;
        case "ArrowUp":
          var prevItem = this.findPrevItem(item);
          if (prevItem) {
            item.removeAttribute("tabindex");
            prevItem.tabIndex = "0";
            prevItem.focus();
          }
          event2.preventDefault();
          break;
      }
    },
    isRowMatchModeSelected: function isRowMatchModeSelected(matchMode) {
      return this.filters[this.field].matchMode === matchMode;
    },
    onOperatorChange: function onOperatorChange(value3) {
      var _filters = _objectSpread$5({}, this.filters);
      _filters[this.field].operator = value3;
      this.$emit("filter-change", _filters);
      this.$emit("operator-change", {
        field: this.field,
        operator: value3
      });
      if (!this.showApplyButton) {
        this.$emit("filter-apply");
      }
    },
    onMenuMatchModeChange: function onMenuMatchModeChange(value3, index2) {
      var _filters = _objectSpread$5({}, this.filters);
      _filters[this.field].constraints[index2].matchMode = value3;
      this.$emit("matchmode-change", {
        field: this.field,
        matchMode: value3,
        index: index2
      });
      if (!this.showApplyButton) {
        this.$emit("filter-apply");
      }
    },
    addConstraint: function addConstraint() {
      var _filters = _objectSpread$5({}, this.filters);
      var newConstraint = {
        value: null,
        matchMode: this.defaultMatchMode
      };
      _filters[this.field].constraints.push(newConstraint);
      this.$emit("constraint-add", {
        field: this.field,
        constraing: newConstraint
      });
      this.$emit("filter-change", _filters);
      if (!this.showApplyButton) {
        this.$emit("filter-apply");
      }
    },
    removeConstraint: function removeConstraint(index2) {
      var _filters = _objectSpread$5({}, this.filters);
      var removedConstraint = _filters[this.field].constraints.splice(index2, 1);
      this.$emit("constraint-remove", {
        field: this.field,
        constraing: removedConstraint
      });
      this.$emit("filter-change", _filters);
      if (!this.showApplyButton) {
        this.$emit("filter-apply");
      }
    },
    filterCallback: function filterCallback() {
      this.$emit("filter-apply");
    },
    findNextItem: function findNextItem(item) {
      var nextItem = item.nextElementSibling;
      if (nextItem) return getAttribute(nextItem, "data-pc-section") === "filterconstraintseparator" ? this.findNextItem(nextItem) : nextItem;
      else return item.parentElement.firstElementChild;
    },
    findPrevItem: function findPrevItem(item) {
      var prevItem = item.previousElementSibling;
      if (prevItem) return getAttribute(prevItem, "data-pc-section") === "filterconstraintseparator" ? this.findPrevItem(prevItem) : prevItem;
      else return item.parentElement.lastElementChild;
    },
    hide: function hide4() {
      this.overlayVisible = false;
      this.showMenuButton && focus(this.$refs.icon.$el);
    },
    onContentClick: function onContentClick(event2) {
      this.selfClick = true;
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.overlay
      });
    },
    onContentMouseDown: function onContentMouseDown() {
      this.selfClick = true;
    },
    onOverlayEnter: function onOverlayEnter3(el) {
      var _this = this;
      if (this.filterMenuStyle) {
        addStyle(this.overlay, this.filterMenuStyle);
      }
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
      addStyle(el, {
        position: "absolute",
        top: "0",
        left: "0"
      });
      absolutePosition(this.overlay, this.$refs.icon.$el);
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.overlayEventListener = function(e) {
        if (!_this.isOutsideClicked(e.target)) {
          _this.selfClick = true;
        }
      };
      OverlayEventBus.on("overlay-click", this.overlayEventListener);
    },
    onOverlayAfterEnter: function onOverlayAfterEnter3() {
      var _this$overlay;
      (_this$overlay = this.overlay) === null || _this$overlay === void 0 || (_this$overlay = _this$overlay.$focustrap) === null || _this$overlay === void 0 || _this$overlay.autoFocus();
    },
    onOverlayLeave: function onOverlayLeave3() {
      this.onOverlayHide();
    },
    onOverlayAfterLeave: function onOverlayAfterLeave3(el) {
      ZIndex.clear(el);
    },
    onOverlayHide: function onOverlayHide() {
      this.unbindOutsideClickListener();
      this.unbindResizeListener();
      this.unbindScrollListener();
      this.overlay = null;
      OverlayEventBus.off("overlay-click", this.overlayEventListener);
      this.overlayEventListener = null;
    },
    overlayRef: function overlayRef3(el) {
      this.overlay = el;
    },
    isOutsideClicked: function isOutsideClicked2(target) {
      return !this.isTargetClicked(target) && this.overlay && !(this.overlay.isSameNode(target) || this.overlay.contains(target));
    },
    isTargetClicked: function isTargetClicked(target) {
      return this.$refs.icon && (this.$refs.icon.$el.isSameNode(target) || this.$refs.icon.$el.contains(target));
    },
    bindOutsideClickListener: function bindOutsideClickListener3() {
      var _this2 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this2.overlayVisible && !_this2.selfClick && _this2.isOutsideClicked(event2.target)) {
            _this2.overlayVisible = false;
          }
          _this2.selfClick = false;
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    },
    unbindOutsideClickListener: function unbindOutsideClickListener3() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
        this.selfClick = false;
      }
    },
    bindScrollListener: function bindScrollListener4() {
      var _this3 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.icon.$el, function() {
          if (_this3.overlayVisible) {
            _this3.hide();
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    },
    unbindScrollListener: function unbindScrollListener4() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },
    bindResizeListener: function bindResizeListener4() {
      var _this4 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this4.overlayVisible && !isTouchDevice()) {
            _this4.hide();
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    },
    unbindResizeListener: function unbindResizeListener4() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    }
  },
  computed: {
    showMenuButton: function showMenuButton() {
      return this.showMenu && (this.display === "row" ? this.type !== "boolean" : true);
    },
    overlayId: function overlayId() {
      return this.id + "_overlay";
    },
    matchModes: function matchModes() {
      var _this5 = this;
      return this.matchModeOptions || this.$primevue.config.filterMatchModeOptions[this.type].map(function(key) {
        return {
          label: _this5.$primevue.config.locale[key],
          value: key
        };
      });
    },
    isShowMatchModes: function isShowMatchModes() {
      return this.type !== "boolean" && this.showMatchModes && this.matchModes;
    },
    operatorOptions: function operatorOptions() {
      return [{
        label: this.$primevue.config.locale.matchAll,
        value: FilterOperator.AND
      }, {
        label: this.$primevue.config.locale.matchAny,
        value: FilterOperator.OR
      }];
    },
    noFilterLabel: function noFilterLabel() {
      return this.$primevue.config.locale ? this.$primevue.config.locale.noFilter : void 0;
    },
    isShowOperator: function isShowOperator() {
      return this.showOperator && this.filters[this.field].operator;
    },
    operator: function operator() {
      return this.filters[this.field].operator;
    },
    fieldConstraints: function fieldConstraints() {
      return this.filters[this.field].constraints || [this.filters[this.field]];
    },
    showRemoveIcon: function showRemoveIcon() {
      return this.fieldConstraints.length > 1;
    },
    removeRuleButtonLabel: function removeRuleButtonLabel() {
      return this.$primevue.config.locale ? this.$primevue.config.locale.removeRule : void 0;
    },
    addRuleButtonLabel: function addRuleButtonLabel() {
      return this.$primevue.config.locale ? this.$primevue.config.locale.addRule : void 0;
    },
    isShowAddConstraint: function isShowAddConstraint() {
      return this.showAddButton && this.filters[this.field].operator && this.fieldConstraints && this.fieldConstraints.length < this.maxConstraints;
    },
    clearButtonLabel: function clearButtonLabel() {
      return this.$primevue.config.locale ? this.$primevue.config.locale.clear : void 0;
    },
    applyButtonLabel: function applyButtonLabel() {
      return this.$primevue.config.locale ? this.$primevue.config.locale.apply : void 0;
    },
    columnFilterButtonAriaLabel: function columnFilterButtonAriaLabel() {
      return this.$primevue.config.locale ? this.overlayVisible ? this.$primevue.config.locale.showFilterMenu : this.$primevue.config.locale.hideFilterMenu : void 0;
    },
    filterOperatorAriaLabel: function filterOperatorAriaLabel() {
      return this.$primevue.config.locale ? this.$primevue.config.locale.filterOperator : void 0;
    },
    filterRuleAriaLabel: function filterRuleAriaLabel() {
      return this.$primevue.config.locale ? this.$primevue.config.locale.filterConstraint : void 0;
    },
    ptmHeaderFilterClearParams: function ptmHeaderFilterClearParams() {
      return {
        context: {
          hidden: this.hasRowFilter()
        }
      };
    },
    ptmFilterMenuParams: function ptmFilterMenuParams() {
      return {
        context: {
          overlayVisible: this.overlayVisible,
          active: this.hasFilter()
        }
      };
    }
  },
  components: {
    Select: script$M,
    Button: script$13,
    Portal: script$N,
    FilterSlashIcon: script$j,
    FilterIcon: script$k,
    TrashIcon: script$h,
    PlusIcon: script$i
  },
  directives: {
    focustrap: FocusTrap
  }
};
function _typeof$4(o) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$4(o);
}
function ownKeys$4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$4(Object(t), true).forEach(function(r2) {
      _defineProperty$4(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$4(e, r, t) {
  return (r = _toPropertyKey$4(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$4(t) {
  var i2 = _toPrimitive$4(t, "string");
  return "symbol" == _typeof$4(i2) ? i2 : i2 + "";
}
function _toPrimitive$4(t, r) {
  if ("object" != _typeof$4(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$4(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var _hoisted_1$1$2 = ["id", "aria-modal"];
var _hoisted_2$6 = ["onClick", "onKeydown", "tabindex"];
function render$4$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Button = resolveComponent("Button");
  var _component_Select = resolveComponent("Select");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("filter")
  }, $options.getColumnPT("filter")), [$props.display === "row" ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("filterElementContainer")
  }, _objectSpread$4(_objectSpread$4({}, $props.filterInputProps), $options.getColumnPT("filterElementContainer"))), [(openBlock(), createBlock(resolveDynamicComponent($props.filterElement), {
    field: $props.field,
    filterModel: $props.filters[$props.field],
    filterCallback: $options.filterCallback
  }, null, 8, ["field", "filterModel", "filterCallback"]))], 16)) : createCommentVNode("", true), $options.showMenuButton ? (openBlock(), createBlock(_component_Button, mergeProps({
    key: 1,
    ref: "icon",
    "aria-label": $options.columnFilterButtonAriaLabel,
    "aria-haspopup": "true",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.overlayId,
    "class": _ctx.cx("pcColumnFilterButton"),
    unstyled: _ctx.unstyled,
    onClick: _cache[0] || (_cache[0] = function($event) {
      return $options.toggleMenu($event);
    }),
    onKeydown: _cache[1] || (_cache[1] = function($event) {
      return $options.onToggleButtonKeyDown($event);
    })
  }, _objectSpread$4(_objectSpread$4({}, $options.getColumnPT("pcColumnFilterButton", $options.ptmFilterMenuParams)), $props.filterButtonProps.filter)), {
    icon: withCtx(function(slotProps) {
      return [(openBlock(), createBlock(resolveDynamicComponent($props.filterIconTemplate || "FilterIcon"), mergeProps({
        "class": slotProps["class"]
      }, $options.getColumnPT("filterMenuIcon")), null, 16, ["class"]))];
    }),
    _: 1
  }, 16, ["aria-label", "aria-expanded", "aria-controls", "class", "unstyled"])) : createCommentVNode("", true), $props.showClearButton && $props.display === "row" && $options.hasRowFilter() ? (openBlock(), createBlock(_component_Button, mergeProps({
    key: 2,
    "class": _ctx.cx("pcColumnFilterClearButton"),
    unstyled: _ctx.unstyled,
    onClick: _cache[2] || (_cache[2] = function($event) {
      return $options.clearFilter();
    })
  }, _objectSpread$4(_objectSpread$4({}, $options.getColumnPT("pcColumnFilterClearButton", $options.ptmHeaderFilterClearParams)), $props.filterButtonProps.inline.clear)), {
    icon: withCtx(function(slotProps) {
      return [(openBlock(), createBlock(resolveDynamicComponent($props.filterClearIconTemplate || "FilterSlashIcon"), mergeProps({
        "class": slotProps["class"]
      }, $options.getColumnPT("filterClearIcon")), null, 16, ["class"]))];
    }),
    _: 1
  }, 16, ["class", "unstyled"])) : createCommentVNode("", true), createVNode(_component_Portal, null, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-connected-overlay",
        onEnter: $options.onOverlayEnter,
        onAfterEnter: $options.onOverlayAfterEnter,
        onLeave: $options.onOverlayLeave,
        onAfterLeave: $options.onOverlayAfterLeave
      }, $options.getColumnPT("transition")), {
        "default": withCtx(function() {
          return [$data.overlayVisible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.overlayRef,
            id: $options.overlayId,
            "aria-modal": $data.overlayVisible,
            role: "dialog",
            "class": [_ctx.cx("filterOverlay"), $props.filterMenuClass],
            onKeydown: _cache[10] || (_cache[10] = withKeys(function() {
              return $options.hide && $options.hide.apply($options, arguments);
            }, ["escape"])),
            onClick: _cache[11] || (_cache[11] = function() {
              return $options.onContentClick && $options.onContentClick.apply($options, arguments);
            }),
            onMousedown: _cache[12] || (_cache[12] = function() {
              return $options.onContentMouseDown && $options.onContentMouseDown.apply($options, arguments);
            })
          }, $options.getColumnPT("filterOverlay")), [(openBlock(), createBlock(resolveDynamicComponent($props.filterHeaderTemplate), {
            field: $props.field,
            filterModel: $props.filters[$props.field],
            filterCallback: $options.filterCallback
          }, null, 8, ["field", "filterModel", "filterCallback"])), $props.display === "row" ? (openBlock(), createElementBlock("ul", mergeProps({
            key: 0,
            "class": _ctx.cx("filterConstraintList")
          }, $options.getColumnPT("filterConstraintList")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.matchModes, function(matchMode, i2) {
            return openBlock(), createElementBlock("li", mergeProps({
              key: matchMode.label,
              "class": _ctx.cx("filterConstraint", {
                matchMode
              }),
              onClick: function onClick5($event) {
                return $options.onRowMatchModeChange(matchMode.value);
              },
              onKeydown: [_cache[3] || (_cache[3] = function($event) {
                return $options.onRowMatchModeKeyDown($event);
              }), withKeys(withModifiers(function($event) {
                return $options.onRowMatchModeChange(matchMode.value);
              }, ["prevent"]), ["enter"])],
              tabindex: i2 === 0 ? "0" : null,
              ref_for: true
            }, $options.getColumnPT("filterConstraint", $options.ptmFilterConstraintOptions(matchMode))), toDisplayString$1(matchMode.label), 17, _hoisted_2$6);
          }), 128)), createBaseVNode("li", mergeProps({
            "class": _ctx.cx("filterConstraintSeparator")
          }, $options.getColumnPT("filterConstraintSeparator")), null, 16), createBaseVNode("li", mergeProps({
            "class": _ctx.cx("filterConstraint"),
            onClick: _cache[4] || (_cache[4] = function($event) {
              return $options.clearFilter();
            }),
            onKeydown: [_cache[5] || (_cache[5] = function($event) {
              return $options.onRowMatchModeKeyDown($event);
            }), _cache[6] || (_cache[6] = withKeys(function($event) {
              return _ctx.onRowClearItemClick();
            }, ["enter"]))]
          }, $options.getColumnPT("filterConstraint")), toDisplayString$1($options.noFilterLabel), 17)], 16)) : (openBlock(), createElementBlock(Fragment, {
            key: 1
          }, [$options.isShowOperator ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            "class": _ctx.cx("filterOperator")
          }, $options.getColumnPT("filterOperator")), [createVNode(_component_Select, {
            options: $options.operatorOptions,
            modelValue: $options.operator,
            "aria-label": $options.filterOperatorAriaLabel,
            "class": normalizeClass(_ctx.cx("pcFilterOperatorDropdown")),
            optionLabel: "label",
            optionValue: "value",
            "onUpdate:modelValue": _cache[7] || (_cache[7] = function($event) {
              return $options.onOperatorChange($event);
            }),
            unstyled: _ctx.unstyled,
            pt: $options.getColumnPT("pcFilterOperatorDropdown")
          }, null, 8, ["options", "modelValue", "aria-label", "class", "unstyled", "pt"])], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("filterRuleList")
          }, $options.getColumnPT("filterRuleList")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.fieldConstraints, function(fieldConstraint, i2) {
            return openBlock(), createElementBlock("div", mergeProps({
              key: i2,
              "class": _ctx.cx("filterRule"),
              ref_for: true
            }, $options.getColumnPT("filterRule")), [$options.isShowMatchModes ? (openBlock(), createBlock(_component_Select, {
              key: 0,
              options: $options.matchModes,
              modelValue: fieldConstraint.matchMode,
              "class": normalizeClass(_ctx.cx("pcFilterConstraintDropdown")),
              optionLabel: "label",
              optionValue: "value",
              "aria-label": $options.filterRuleAriaLabel,
              "onUpdate:modelValue": function onUpdateModelValue($event) {
                return $options.onMenuMatchModeChange($event, i2);
              },
              unstyled: _ctx.unstyled,
              pt: $options.getColumnPT("pcFilterConstraintDropdown")
            }, null, 8, ["options", "modelValue", "class", "aria-label", "onUpdate:modelValue", "unstyled", "pt"])) : createCommentVNode("", true), $props.display === "menu" ? (openBlock(), createBlock(resolveDynamicComponent($props.filterElement), {
              key: 1,
              field: $props.field,
              filterModel: fieldConstraint,
              filterCallback: $options.filterCallback,
              applyFilter: $options.applyFilter
            }, null, 8, ["field", "filterModel", "filterCallback", "applyFilter"])) : createCommentVNode("", true), $options.showRemoveIcon ? (openBlock(), createElementBlock("div", mergeProps({
              key: 2,
              ref_for: true
            }, $options.getColumnPT("filterRemove")), [createVNode(_component_Button, mergeProps({
              type: "button",
              "class": _ctx.cx("pcFilterRemoveRuleButton"),
              onClick: function onClick5($event) {
                return $options.removeConstraint(i2);
              },
              label: $options.removeRuleButtonLabel,
              unstyled: _ctx.unstyled,
              ref_for: true
            }, $props.filterButtonProps.popover.removeRule, {
              pt: $options.getColumnPT("pcFilterRemoveRuleButton")
            }), {
              icon: withCtx(function(iconProps) {
                return [(openBlock(), createBlock(resolveDynamicComponent($props.filterRemoveIconTemplate || "TrashIcon"), mergeProps({
                  "class": iconProps["class"],
                  ref_for: true
                }, $options.getColumnPT("pcFilterRemoveRuleButton")["icon"]), null, 16, ["class"]))];
              }),
              _: 2
            }, 1040, ["class", "onClick", "label", "unstyled", "pt"])], 16)) : createCommentVNode("", true)], 16);
          }), 128))], 16), $options.isShowAddConstraint ? (openBlock(), createElementBlock("div", normalizeProps(mergeProps({
            key: 1
          }, $options.getColumnPT("filterAddButtonContainer"))), [createVNode(_component_Button, mergeProps({
            type: "button",
            label: $options.addRuleButtonLabel,
            iconPos: "left",
            "class": _ctx.cx("pcFilterAddRuleButton"),
            onClick: _cache[8] || (_cache[8] = function($event) {
              return $options.addConstraint();
            }),
            unstyled: _ctx.unstyled
          }, $props.filterButtonProps.popover.addRule, {
            pt: $options.getColumnPT("pcFilterAddRuleButton")
          }), {
            icon: withCtx(function(iconProps) {
              return [(openBlock(), createBlock(resolveDynamicComponent($props.filterAddIconTemplate || "PlusIcon"), mergeProps({
                "class": iconProps["class"]
              }, $options.getColumnPT("pcFilterAddRuleButton")["icon"]), null, 16, ["class"]))];
            }),
            _: 1
          }, 16, ["label", "class", "unstyled", "pt"])], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("filterButtonbar")
          }, $options.getColumnPT("filterButtonbar")), [!$props.filterClearTemplate && $props.showClearButton ? (openBlock(), createBlock(_component_Button, mergeProps({
            key: 0,
            type: "button",
            "class": _ctx.cx("pcFilterClearButton"),
            label: $options.clearButtonLabel,
            onClick: $options.clearFilter,
            unstyled: _ctx.unstyled
          }, $props.filterButtonProps.popover.clear, {
            pt: $options.getColumnPT("pcFilterClearButton")
          }), null, 16, ["class", "label", "onClick", "unstyled", "pt"])) : (openBlock(), createBlock(resolveDynamicComponent($props.filterClearTemplate), {
            key: 1,
            field: $props.field,
            filterModel: $props.filters[$props.field],
            filterCallback: $options.clearFilter
          }, null, 8, ["field", "filterModel", "filterCallback"])), $props.showApplyButton ? (openBlock(), createElementBlock(Fragment, {
            key: 2
          }, [!$props.filterApplyTemplate ? (openBlock(), createBlock(_component_Button, mergeProps({
            key: 0,
            type: "button",
            "class": _ctx.cx("pcFilterApplyButton"),
            label: $options.applyButtonLabel,
            onClick: _cache[9] || (_cache[9] = function($event) {
              return $options.applyFilter();
            }),
            unstyled: _ctx.unstyled
          }, $props.filterButtonProps.popover.apply, {
            pt: $options.getColumnPT("pcFilterApplyButton")
          }), null, 16, ["class", "label", "unstyled", "pt"])) : (openBlock(), createBlock(resolveDynamicComponent($props.filterApplyTemplate), {
            key: 1,
            field: $props.field,
            filterModel: $props.filters[$props.field],
            filterCallback: $options.applyFilter
          }, null, 8, ["field", "filterModel", "filterCallback"]))], 64)) : createCommentVNode("", true)], 16)], 64)), (openBlock(), createBlock(resolveDynamicComponent($props.filterFooterTemplate), {
            field: $props.field,
            filterModel: $props.filters[$props.field],
            filterCallback: $options.filterCallback
          }, null, 8, ["field", "filterModel", "filterCallback"]))], 16, _hoisted_1$1$2)), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 1
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 1
  })], 16);
}
script$4$1.render = render$4$1;
var script$3$1 = {
  name: "HeaderCheckbox",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["change"],
  props: {
    checked: null,
    disabled: null,
    column: null,
    headerCheckboxIconTemplate: {
      type: Function,
      "default": null
    }
  },
  methods: {
    getColumnPT: function getColumnPT7(key) {
      var columnMetaData = {
        props: this.column.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          checked: this.checked,
          disabled: this.disabled
        }
      };
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.getColumnProp(), key, columnMetaData));
    },
    getColumnProp: function getColumnProp6() {
      return this.column.props && this.column.props.pt ? this.column.props.pt : void 0;
    },
    onChange: function onChange11(event2) {
      this.$emit("change", {
        originalEvent: event2,
        checked: !this.checked
      });
    }
  },
  computed: {
    headerCheckboxAriaLabel: function headerCheckboxAriaLabel() {
      return this.$primevue.config.locale.aria ? this.checked ? this.$primevue.config.locale.aria.selectAll : this.$primevue.config.locale.aria.unselectAll : void 0;
    }
  },
  components: {
    CheckIcon: script$11,
    Checkbox: script$m
  }
};
function render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_CheckIcon = resolveComponent("CheckIcon");
  var _component_Checkbox = resolveComponent("Checkbox");
  return openBlock(), createBlock(_component_Checkbox, {
    modelValue: $props.checked,
    binary: true,
    disabled: $props.disabled,
    "aria-label": $options.headerCheckboxAriaLabel,
    onChange: $options.onChange,
    pt: $options.getColumnPT("pcHeaderCheckbox")
  }, {
    icon: withCtx(function(slotProps) {
      return [$props.headerCheckboxIconTemplate ? (openBlock(), createBlock(resolveDynamicComponent($props.headerCheckboxIconTemplate), {
        key: 0,
        checked: slotProps.checked,
        "class": normalizeClass(slotProps["class"])
      }, null, 8, ["checked", "class"])) : !$props.headerCheckboxIconTemplate && slotProps.checked ? (openBlock(), createBlock(_component_CheckIcon, mergeProps({
        key: 1,
        "class": slotProps["class"]
      }, $options.getColumnPT("pcHeaderCheckbox.icon")), null, 16, ["class"])) : createCommentVNode("", true)];
    }),
    _: 1
  }, 8, ["modelValue", "disabled", "aria-label", "onChange", "pt"]);
}
script$3$1.render = render$3$1;
var script$2$2 = {
  name: "HeaderCell",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["column-click", "column-mousedown", "column-dragstart", "column-dragover", "column-dragleave", "column-drop", "column-resizestart", "checkbox-change", "filter-change", "filter-apply", "operator-change", "matchmode-change", "constraint-add", "constraint-remove", "filter-clear", "apply-click"],
  props: {
    column: {
      type: Object,
      "default": null
    },
    index: {
      type: Number,
      "default": null
    },
    resizableColumns: {
      type: Boolean,
      "default": false
    },
    groupRowsBy: {
      type: [Array, String, Function],
      "default": null
    },
    sortMode: {
      type: String,
      "default": "single"
    },
    groupRowSortField: {
      type: [String, Function],
      "default": null
    },
    sortField: {
      type: [String, Function],
      "default": null
    },
    sortOrder: {
      type: Number,
      "default": null
    },
    multiSortMeta: {
      type: Array,
      "default": null
    },
    allRowsSelected: {
      type: Boolean,
      "default": false
    },
    empty: {
      type: Boolean,
      "default": false
    },
    filterDisplay: {
      type: String,
      "default": null
    },
    filters: {
      type: Object,
      "default": null
    },
    filtersStore: {
      type: Object,
      "default": null
    },
    filterColumn: {
      type: Boolean,
      "default": false
    },
    reorderableColumns: {
      type: Boolean,
      "default": false
    },
    filterInputProps: {
      type: null,
      "default": null
    },
    filterButtonProps: {
      type: null,
      "default": null
    }
  },
  data: function data22() {
    return {
      styleObject: {}
    };
  },
  mounted: function mounted17() {
    if (this.columnProp("frozen")) {
      this.updateStickyPosition();
    }
  },
  updated: function updated11() {
    if (this.columnProp("frozen")) {
      this.updateStickyPosition();
    }
  },
  methods: {
    columnProp: function columnProp5(prop2) {
      return getVNodeProp(this.column, prop2);
    },
    getColumnPT: function getColumnPT8(key) {
      var _this$$parentInstance, _this$$parentInstance2;
      var columnMetaData = {
        props: this.column.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: this.index,
          sortable: this.columnProp("sortable") === "" || this.columnProp("sortable"),
          sorted: this.isColumnSorted(),
          resizable: this.resizableColumns,
          size: (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 || (_this$$parentInstance = _this$$parentInstance.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.size,
          showGridlines: ((_this$$parentInstance2 = this.$parentInstance) === null || _this$$parentInstance2 === void 0 || (_this$$parentInstance2 = _this$$parentInstance2.$parentInstance) === null || _this$$parentInstance2 === void 0 ? void 0 : _this$$parentInstance2.showGridlines) || false
        }
      };
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.getColumnProp(), key, columnMetaData));
    },
    getColumnProp: function getColumnProp7() {
      return this.column.props && this.column.props.pt ? this.column.props.pt : void 0;
    },
    onClick: function onClick3(event2) {
      this.$emit("column-click", {
        originalEvent: event2,
        column: this.column
      });
    },
    onKeyDown: function onKeyDown6(event2) {
      if ((event2.code === "Enter" || event2.code === "NumpadEnter" || event2.code === "Space") && event2.currentTarget.nodeName === "TH" && getAttribute(event2.currentTarget, "data-p-sortable-column")) {
        this.$emit("column-click", {
          originalEvent: event2,
          column: this.column
        });
        event2.preventDefault();
      }
    },
    onMouseDown: function onMouseDown3(event2) {
      this.$emit("column-mousedown", {
        originalEvent: event2,
        column: this.column
      });
    },
    onDragStart: function onDragStart2(event2) {
      this.$emit("column-dragstart", {
        originalEvent: event2,
        column: this.column
      });
    },
    onDragOver: function onDragOver(event2) {
      this.$emit("column-dragover", {
        originalEvent: event2,
        column: this.column
      });
    },
    onDragLeave: function onDragLeave(event2) {
      this.$emit("column-dragleave", {
        originalEvent: event2,
        column: this.column
      });
    },
    onDrop: function onDrop(event2) {
      this.$emit("column-drop", {
        originalEvent: event2,
        column: this.column
      });
    },
    onResizeStart: function onResizeStart2(event2) {
      this.$emit("column-resizestart", event2);
    },
    getMultiSortMetaIndex: function getMultiSortMetaIndex() {
      var _this = this;
      return this.multiSortMeta.findIndex(function(meta) {
        return meta.field === _this.columnProp("field") || meta.field === _this.columnProp("sortField");
      });
    },
    getBadgeValue: function getBadgeValue() {
      var index2 = this.getMultiSortMetaIndex();
      return this.groupRowsBy && this.groupRowsBy === this.groupRowSortField && index2 > -1 ? index2 : index2 + 1;
    },
    isMultiSorted: function isMultiSorted() {
      return this.sortMode === "multiple" && this.columnProp("sortable") && this.getMultiSortMetaIndex() > -1;
    },
    isColumnSorted: function isColumnSorted() {
      return this.sortMode === "single" ? this.sortField && (this.sortField === this.columnProp("field") || this.sortField === this.columnProp("sortField")) : this.isMultiSorted();
    },
    updateStickyPosition: function updateStickyPosition3() {
      if (this.columnProp("frozen")) {
        var align2 = this.columnProp("alignFrozen");
        if (align2 === "right") {
          var right = 0;
          var next2 = getNextElementSibling(this.$el, '[data-p-frozen-column="true"]');
          if (next2) {
            right = getOuterWidth(next2) + parseFloat(next2.style.right || 0);
          }
          this.styleObject.right = right + "px";
        } else {
          var left = 0;
          var prev2 = getPreviousElementSibling(this.$el, '[data-p-frozen-column="true"]');
          if (prev2) {
            left = getOuterWidth(prev2) + parseFloat(prev2.style.left || 0);
          }
          this.styleObject.left = left + "px";
        }
        var filterRow = this.$el.parentElement.nextElementSibling;
        if (filterRow) {
          var index2 = getIndex(this.$el);
          if (filterRow.children[index2]) {
            filterRow.children[index2].style.left = this.styleObject.left;
            filterRow.children[index2].style.right = this.styleObject.right;
          }
        }
      }
    },
    onHeaderCheckboxChange: function onHeaderCheckboxChange(event2) {
      this.$emit("checkbox-change", event2);
    }
  },
  computed: {
    containerClass: function containerClass5() {
      return [this.cx("headerCell"), this.filterColumn ? this.columnProp("filterHeaderClass") : this.columnProp("headerClass"), this.columnProp("class")];
    },
    containerStyle: function containerStyle3() {
      var headerStyle = this.filterColumn ? this.columnProp("filterHeaderStyle") : this.columnProp("headerStyle");
      var columnStyle = this.columnProp("style");
      return this.columnProp("frozen") ? [columnStyle, headerStyle, this.styleObject] : [columnStyle, headerStyle];
    },
    sortState: function sortState() {
      var sorted2 = false;
      var sortOrder2 = null;
      if (this.sortMode === "single") {
        sorted2 = this.sortField && (this.sortField === this.columnProp("field") || this.sortField === this.columnProp("sortField"));
        sortOrder2 = sorted2 ? this.sortOrder : 0;
      } else if (this.sortMode === "multiple") {
        var metaIndex = this.getMultiSortMetaIndex();
        if (metaIndex > -1) {
          sorted2 = true;
          sortOrder2 = this.multiSortMeta[metaIndex].order;
        }
      }
      return {
        sorted: sorted2,
        sortOrder: sortOrder2
      };
    },
    sortableColumnIcon: function sortableColumnIcon() {
      var _this$sortState = this.sortState, sorted2 = _this$sortState.sorted, sortOrder2 = _this$sortState.sortOrder;
      if (!sorted2) return script$g;
      else if (sorted2 && sortOrder2 > 0) return script$e;
      else if (sorted2 && sortOrder2 < 0) return script$f;
      return null;
    },
    ariaSort: function ariaSort() {
      if (this.columnProp("sortable")) {
        var _this$sortState2 = this.sortState, sorted2 = _this$sortState2.sorted, sortOrder2 = _this$sortState2.sortOrder;
        if (sorted2 && sortOrder2 < 0) return "descending";
        else if (sorted2 && sortOrder2 > 0) return "ascending";
        else return "none";
      } else {
        return null;
      }
    }
  },
  components: {
    Badge: script$17,
    DTHeaderCheckbox: script$3$1,
    DTColumnFilter: script$4$1,
    SortAltIcon: script$g,
    SortAmountUpAltIcon: script$e,
    SortAmountDownIcon: script$f
  }
};
function _typeof$3$1(o) {
  "@babel/helpers - typeof";
  return _typeof$3$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3$1(o);
}
function ownKeys$3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$3(Object(t), true).forEach(function(r2) {
      _defineProperty$3$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$3$1(e, r, t) {
  return (r = _toPropertyKey$3$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$3$1(t) {
  var i2 = _toPrimitive$3$1(t, "string");
  return "symbol" == _typeof$3$1(i2) ? i2 : i2 + "";
}
function _toPrimitive$3$1(t, r) {
  if ("object" != _typeof$3$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$3$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var _hoisted_1$a = ["tabindex", "colspan", "rowspan", "aria-sort", "data-p-sortable-column", "data-p-resizable-column", "data-p-sorted", "data-p-filter-column", "data-p-frozen-column", "data-p-reorderable-column"];
function render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Badge = resolveComponent("Badge");
  var _component_DTHeaderCheckbox = resolveComponent("DTHeaderCheckbox");
  var _component_DTColumnFilter = resolveComponent("DTColumnFilter");
  return openBlock(), createElementBlock("th", mergeProps({
    style: $options.containerStyle,
    "class": $options.containerClass,
    tabindex: $options.columnProp("sortable") ? "0" : null,
    role: "columnheader",
    colspan: $options.columnProp("colspan"),
    rowspan: $options.columnProp("rowspan"),
    "aria-sort": $options.ariaSort,
    onClick: _cache[8] || (_cache[8] = function() {
      return $options.onClick && $options.onClick.apply($options, arguments);
    }),
    onKeydown: _cache[9] || (_cache[9] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    }),
    onMousedown: _cache[10] || (_cache[10] = function() {
      return $options.onMouseDown && $options.onMouseDown.apply($options, arguments);
    }),
    onDragstart: _cache[11] || (_cache[11] = function() {
      return $options.onDragStart && $options.onDragStart.apply($options, arguments);
    }),
    onDragover: _cache[12] || (_cache[12] = function() {
      return $options.onDragOver && $options.onDragOver.apply($options, arguments);
    }),
    onDragleave: _cache[13] || (_cache[13] = function() {
      return $options.onDragLeave && $options.onDragLeave.apply($options, arguments);
    }),
    onDrop: _cache[14] || (_cache[14] = function() {
      return $options.onDrop && $options.onDrop.apply($options, arguments);
    })
  }, _objectSpread$3(_objectSpread$3({}, $options.getColumnPT("root")), $options.getColumnPT("headerCell")), {
    "data-p-sortable-column": $options.columnProp("sortable"),
    "data-p-resizable-column": $props.resizableColumns,
    "data-p-sorted": $options.isColumnSorted(),
    "data-p-filter-column": $props.filterColumn,
    "data-p-frozen-column": $options.columnProp("frozen"),
    "data-p-reorderable-column": $props.reorderableColumns
  }), [$props.resizableColumns && !$options.columnProp("frozen") ? (openBlock(), createElementBlock("span", mergeProps({
    key: 0,
    "class": _ctx.cx("columnResizer"),
    onMousedown: _cache[0] || (_cache[0] = function() {
      return $options.onResizeStart && $options.onResizeStart.apply($options, arguments);
    })
  }, $options.getColumnPT("columnResizer")), null, 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("columnHeaderContent")
  }, $options.getColumnPT("columnHeaderContent")), [$props.column.children && $props.column.children.header ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.header), {
    key: 0,
    column: $props.column
  }, null, 8, ["column"])) : createCommentVNode("", true), $options.columnProp("header") ? (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    "class": _ctx.cx("columnTitle")
  }, $options.getColumnPT("columnTitle")), toDisplayString$1($options.columnProp("header")), 17)) : createCommentVNode("", true), $options.columnProp("sortable") ? (openBlock(), createElementBlock("span", normalizeProps(mergeProps({
    key: 2
  }, $options.getColumnPT("sort"))), [(openBlock(), createBlock(resolveDynamicComponent($props.column.children && $props.column.children.sorticon || $options.sortableColumnIcon), mergeProps({
    sorted: $options.sortState.sorted,
    sortOrder: $options.sortState.sortOrder,
    "class": _ctx.cx("sortIcon")
  }, $options.getColumnPT("sorticon")), null, 16, ["sorted", "sortOrder", "class"]))], 16)) : createCommentVNode("", true), $options.isMultiSorted() ? (openBlock(), createBlock(_component_Badge, mergeProps({
    key: 3,
    "class": _ctx.cx("pcSortBadge")
  }, $options.getColumnPT("pcSortBadge"), {
    value: $options.getBadgeValue(),
    size: "small"
  }), null, 16, ["class", "value"])) : createCommentVNode("", true), $options.columnProp("selectionMode") === "multiple" && $props.filterDisplay !== "row" ? (openBlock(), createBlock(_component_DTHeaderCheckbox, {
    key: 4,
    checked: $props.allRowsSelected,
    onChange: $options.onHeaderCheckboxChange,
    disabled: $props.empty,
    headerCheckboxIconTemplate: $props.column.children && $props.column.children.headercheckboxicon,
    column: $props.column,
    unstyled: _ctx.unstyled,
    pt: _ctx.pt
  }, null, 8, ["checked", "onChange", "disabled", "headerCheckboxIconTemplate", "column", "unstyled", "pt"])) : createCommentVNode("", true), $props.filterDisplay === "menu" && $props.column.children && $props.column.children.filter ? (openBlock(), createBlock(_component_DTColumnFilter, {
    key: 5,
    field: $options.columnProp("filterField") || $options.columnProp("field"),
    type: $options.columnProp("dataType"),
    display: "menu",
    showMenu: $options.columnProp("showFilterMenu"),
    filterElement: $props.column.children && $props.column.children.filter,
    filterHeaderTemplate: $props.column.children && $props.column.children.filterheader,
    filterFooterTemplate: $props.column.children && $props.column.children.filterfooter,
    filterClearTemplate: $props.column.children && $props.column.children.filterclear,
    filterApplyTemplate: $props.column.children && $props.column.children.filterapply,
    filterIconTemplate: $props.column.children && $props.column.children.filtericon,
    filterAddIconTemplate: $props.column.children && $props.column.children.filteraddicon,
    filterRemoveIconTemplate: $props.column.children && $props.column.children.filterremoveicon,
    filterClearIconTemplate: $props.column.children && $props.column.children.filterclearicon,
    filters: $props.filters,
    filtersStore: $props.filtersStore,
    filterInputProps: $props.filterInputProps,
    filterButtonProps: $props.filterButtonProps,
    onFilterChange: _cache[1] || (_cache[1] = function($event) {
      return _ctx.$emit("filter-change", $event);
    }),
    onFilterApply: _cache[2] || (_cache[2] = function($event) {
      return _ctx.$emit("filter-apply");
    }),
    filterMenuStyle: $options.columnProp("filterMenuStyle"),
    filterMenuClass: $options.columnProp("filterMenuClass"),
    showOperator: $options.columnProp("showFilterOperator"),
    showClearButton: $options.columnProp("showClearButton"),
    showApplyButton: $options.columnProp("showApplyButton"),
    showMatchModes: $options.columnProp("showFilterMatchModes"),
    showAddButton: $options.columnProp("showAddButton"),
    matchModeOptions: $options.columnProp("filterMatchModeOptions"),
    maxConstraints: $options.columnProp("maxConstraints"),
    onOperatorChange: _cache[3] || (_cache[3] = function($event) {
      return _ctx.$emit("operator-change", $event);
    }),
    onMatchmodeChange: _cache[4] || (_cache[4] = function($event) {
      return _ctx.$emit("matchmode-change", $event);
    }),
    onConstraintAdd: _cache[5] || (_cache[5] = function($event) {
      return _ctx.$emit("constraint-add", $event);
    }),
    onConstraintRemove: _cache[6] || (_cache[6] = function($event) {
      return _ctx.$emit("constraint-remove", $event);
    }),
    onApplyClick: _cache[7] || (_cache[7] = function($event) {
      return _ctx.$emit("apply-click", $event);
    }),
    column: $props.column,
    unstyled: _ctx.unstyled,
    pt: _ctx.pt
  }, null, 8, ["field", "type", "showMenu", "filterElement", "filterHeaderTemplate", "filterFooterTemplate", "filterClearTemplate", "filterApplyTemplate", "filterIconTemplate", "filterAddIconTemplate", "filterRemoveIconTemplate", "filterClearIconTemplate", "filters", "filtersStore", "filterInputProps", "filterButtonProps", "filterMenuStyle", "filterMenuClass", "showOperator", "showClearButton", "showApplyButton", "showMatchModes", "showAddButton", "matchModeOptions", "maxConstraints", "column", "unstyled", "pt"])) : createCommentVNode("", true)], 16)], 16, _hoisted_1$a);
}
script$2$2.render = render$2$1;
var script$1$5 = {
  name: "TableHeader",
  hostName: "DataTable",
  "extends": script$1a,
  emits: ["column-click", "column-mousedown", "column-dragstart", "column-dragover", "column-dragleave", "column-drop", "column-resizestart", "checkbox-change", "filter-change", "filter-apply", "operator-change", "matchmode-change", "constraint-add", "constraint-remove", "filter-clear", "apply-click"],
  props: {
    columnGroup: {
      type: null,
      "default": null
    },
    columns: {
      type: null,
      "default": null
    },
    rowGroupMode: {
      type: String,
      "default": null
    },
    groupRowsBy: {
      type: [Array, String, Function],
      "default": null
    },
    resizableColumns: {
      type: Boolean,
      "default": false
    },
    allRowsSelected: {
      type: Boolean,
      "default": false
    },
    empty: {
      type: Boolean,
      "default": false
    },
    sortMode: {
      type: String,
      "default": "single"
    },
    groupRowSortField: {
      type: [String, Function],
      "default": null
    },
    sortField: {
      type: [String, Function],
      "default": null
    },
    sortOrder: {
      type: Number,
      "default": null
    },
    multiSortMeta: {
      type: Array,
      "default": null
    },
    filterDisplay: {
      type: String,
      "default": null
    },
    filters: {
      type: Object,
      "default": null
    },
    filtersStore: {
      type: Object,
      "default": null
    },
    reorderableColumns: {
      type: Boolean,
      "default": false
    },
    first: {
      type: Number,
      "default": 0
    },
    filterInputProps: {
      type: null,
      "default": null
    },
    filterButtonProps: {
      type: null,
      "default": null
    }
  },
  provide: function provide36() {
    return {
      $rows: this.d_headerRows,
      $columns: this.d_headerColumns
    };
  },
  data: function data23() {
    return {
      d_headerRows: new _default({
        type: "Row"
      }),
      d_headerColumns: new _default({
        type: "Column"
      })
    };
  },
  beforeUnmount: function beforeUnmount10() {
    this.d_headerRows.clear();
    this.d_headerColumns.clear();
  },
  methods: {
    columnProp: function columnProp6(col, prop2) {
      return getVNodeProp(col, prop2);
    },
    getColumnGroupPT: function getColumnGroupPT2(key) {
      var _this$$parentInstance;
      var columnGroupMetaData = {
        props: this.getColumnGroupProps(),
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          type: "header",
          scrollable: (_this$$parentInstance = this.$parentInstance) === null || _this$$parentInstance === void 0 || (_this$$parentInstance = _this$$parentInstance.$parentInstance) === null || _this$$parentInstance === void 0 ? void 0 : _this$$parentInstance.scrollable
        }
      };
      return mergeProps(this.ptm("columnGroup.".concat(key), {
        columnGroup: columnGroupMetaData
      }), this.ptm("columnGroup.".concat(key), columnGroupMetaData), this.ptmo(this.getColumnGroupProps(), key, columnGroupMetaData));
    },
    getColumnGroupProps: function getColumnGroupProps2() {
      return this.columnGroup && this.columnGroup.props && this.columnGroup.props.pt ? this.columnGroup.props.pt : void 0;
    },
    getRowPT: function getRowPT2(row2, key, index2) {
      var rowMetaData = {
        props: row2.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: index2
        }
      };
      return mergeProps(this.ptm("row.".concat(key), {
        row: rowMetaData
      }), this.ptm("row.".concat(key), rowMetaData), this.ptmo(this.getRowProp(row2), key, rowMetaData));
    },
    getRowProp: function getRowProp2(row2) {
      return row2.props && row2.props.pt ? row2.props.pt : void 0;
    },
    getColumnPT: function getColumnPT9(column, key, index2) {
      var columnMetaData = {
        props: column.props,
        parent: {
          instance: this,
          props: this.$props,
          state: this.$data
        },
        context: {
          index: index2
        }
      };
      return mergeProps(this.ptm("column.".concat(key), {
        column: columnMetaData
      }), this.ptm("column.".concat(key), columnMetaData), this.ptmo(this.getColumnProp(column), key, columnMetaData));
    },
    getColumnProp: function getColumnProp8(column) {
      return column.props && column.props.pt ? column.props.pt : void 0;
    },
    getFilterColumnHeaderClass: function getFilterColumnHeaderClass(column) {
      return [this.cx("headerCell", {
        column
      }), this.columnProp(column, "filterHeaderClass"), this.columnProp(column, "class")];
    },
    getFilterColumnHeaderStyle: function getFilterColumnHeaderStyle(column) {
      return [this.columnProp(column, "filterHeaderStyle"), this.columnProp(column, "style")];
    },
    getHeaderRows: function getHeaderRows() {
      var _this$d_headerRows;
      return (_this$d_headerRows = this.d_headerRows) === null || _this$d_headerRows === void 0 ? void 0 : _this$d_headerRows.get(this.columnGroup, this.columnGroup.children);
    },
    getHeaderColumns: function getHeaderColumns(row2) {
      var _this$d_headerColumns;
      return (_this$d_headerColumns = this.d_headerColumns) === null || _this$d_headerColumns === void 0 ? void 0 : _this$d_headerColumns.get(row2, row2.children);
    }
  },
  computed: {
    ptmTHeadOptions: function ptmTHeadOptions() {
      var _this$$parentInstance2;
      return {
        context: {
          scrollable: (_this$$parentInstance2 = this.$parentInstance) === null || _this$$parentInstance2 === void 0 || (_this$$parentInstance2 = _this$$parentInstance2.$parentInstance) === null || _this$$parentInstance2 === void 0 ? void 0 : _this$$parentInstance2.scrollable
        }
      };
    }
  },
  components: {
    DTHeaderCell: script$2$2,
    DTHeaderCheckbox: script$3$1,
    DTColumnFilter: script$4$1
  }
};
function _typeof$2$1(o) {
  "@babel/helpers - typeof";
  return _typeof$2$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2$1(o);
}
function ownKeys$2$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$2$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2$1(Object(t), true).forEach(function(r2) {
      _defineProperty$2$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$2$1(e, r, t) {
  return (r = _toPropertyKey$2$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$2$1(t) {
  var i2 = _toPrimitive$2$1(t, "string");
  return "symbol" == _typeof$2$1(i2) ? i2 : i2 + "";
}
function _toPrimitive$2$1(t, r) {
  if ("object" != _typeof$2$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$2$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_DTHeaderCell = resolveComponent("DTHeaderCell");
  var _component_DTHeaderCheckbox = resolveComponent("DTHeaderCheckbox");
  var _component_DTColumnFilter = resolveComponent("DTColumnFilter");
  return openBlock(), createElementBlock("thead", mergeProps({
    "class": _ctx.cx("thead"),
    style: _ctx.sx("thead"),
    role: "rowgroup"
  }, $props.columnGroup ? _objectSpread$2$1(_objectSpread$2$1({}, _ctx.ptm("thead", $options.ptmTHeadOptions)), $options.getColumnGroupPT("root")) : _ctx.ptm("thead", $options.ptmTHeadOptions), {
    "data-pc-section": "thead"
  }), [!$props.columnGroup ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [createBaseVNode("tr", mergeProps({
    role: "row"
  }, _ctx.ptm("headerRow")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, function(col, i2) {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.columnProp(col, "columnKey") || $options.columnProp(col, "field") || i2
    }, [!$options.columnProp(col, "hidden") && ($props.rowGroupMode !== "subheader" || $props.groupRowsBy !== $options.columnProp(col, "field")) ? (openBlock(), createBlock(_component_DTHeaderCell, {
      key: 0,
      column: col,
      index: i2,
      onColumnClick: _cache[0] || (_cache[0] = function($event) {
        return _ctx.$emit("column-click", $event);
      }),
      onColumnMousedown: _cache[1] || (_cache[1] = function($event) {
        return _ctx.$emit("column-mousedown", $event);
      }),
      onColumnDragstart: _cache[2] || (_cache[2] = function($event) {
        return _ctx.$emit("column-dragstart", $event);
      }),
      onColumnDragover: _cache[3] || (_cache[3] = function($event) {
        return _ctx.$emit("column-dragover", $event);
      }),
      onColumnDragleave: _cache[4] || (_cache[4] = function($event) {
        return _ctx.$emit("column-dragleave", $event);
      }),
      onColumnDrop: _cache[5] || (_cache[5] = function($event) {
        return _ctx.$emit("column-drop", $event);
      }),
      groupRowsBy: $props.groupRowsBy,
      groupRowSortField: $props.groupRowSortField,
      reorderableColumns: $props.reorderableColumns,
      resizableColumns: $props.resizableColumns,
      onColumnResizestart: _cache[6] || (_cache[6] = function($event) {
        return _ctx.$emit("column-resizestart", $event);
      }),
      sortMode: $props.sortMode,
      sortField: $props.sortField,
      sortOrder: $props.sortOrder,
      multiSortMeta: $props.multiSortMeta,
      allRowsSelected: $props.allRowsSelected,
      empty: $props.empty,
      onCheckboxChange: _cache[7] || (_cache[7] = function($event) {
        return _ctx.$emit("checkbox-change", $event);
      }),
      filters: $props.filters,
      filterDisplay: $props.filterDisplay,
      filtersStore: $props.filtersStore,
      filterInputProps: $props.filterInputProps,
      filterButtonProps: $props.filterButtonProps,
      first: $props.first,
      onFilterChange: _cache[8] || (_cache[8] = function($event) {
        return _ctx.$emit("filter-change", $event);
      }),
      onFilterApply: _cache[9] || (_cache[9] = function($event) {
        return _ctx.$emit("filter-apply");
      }),
      onOperatorChange: _cache[10] || (_cache[10] = function($event) {
        return _ctx.$emit("operator-change", $event);
      }),
      onMatchmodeChange: _cache[11] || (_cache[11] = function($event) {
        return _ctx.$emit("matchmode-change", $event);
      }),
      onConstraintAdd: _cache[12] || (_cache[12] = function($event) {
        return _ctx.$emit("constraint-add", $event);
      }),
      onConstraintRemove: _cache[13] || (_cache[13] = function($event) {
        return _ctx.$emit("constraint-remove", $event);
      }),
      onApplyClick: _cache[14] || (_cache[14] = function($event) {
        return _ctx.$emit("apply-click", $event);
      }),
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["column", "index", "groupRowsBy", "groupRowSortField", "reorderableColumns", "resizableColumns", "sortMode", "sortField", "sortOrder", "multiSortMeta", "allRowsSelected", "empty", "filters", "filterDisplay", "filtersStore", "filterInputProps", "filterButtonProps", "first", "unstyled", "pt"])) : createCommentVNode("", true)], 64);
  }), 128))], 16), $props.filterDisplay === "row" ? (openBlock(), createElementBlock("tr", mergeProps({
    key: 0,
    role: "row"
  }, _ctx.ptm("headerRow")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, function(col, i2) {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.columnProp(col, "columnKey") || $options.columnProp(col, "field") || i2
    }, [!$options.columnProp(col, "hidden") && ($props.rowGroupMode !== "subheader" || $props.groupRowsBy !== $options.columnProp(col, "field")) ? (openBlock(), createElementBlock("th", mergeProps({
      key: 0,
      style: $options.getFilterColumnHeaderStyle(col),
      "class": $options.getFilterColumnHeaderClass(col),
      ref_for: true
    }, _objectSpread$2$1(_objectSpread$2$1({}, $options.getColumnPT(col, "root", i2)), $options.getColumnPT(col, "headerCell", i2))), [$options.columnProp(col, "selectionMode") === "multiple" ? (openBlock(), createBlock(_component_DTHeaderCheckbox, {
      key: 0,
      checked: $props.allRowsSelected,
      disabled: $props.empty,
      onChange: _cache[15] || (_cache[15] = function($event) {
        return _ctx.$emit("checkbox-change", $event);
      }),
      column: col,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["checked", "disabled", "column", "unstyled", "pt"])) : createCommentVNode("", true), col.children && col.children.filter ? (openBlock(), createBlock(_component_DTColumnFilter, {
      key: 1,
      field: $options.columnProp(col, "filterField") || $options.columnProp(col, "field"),
      type: $options.columnProp(col, "dataType"),
      display: "row",
      showMenu: $options.columnProp(col, "showFilterMenu"),
      filterElement: col.children && col.children.filter,
      filterHeaderTemplate: col.children && col.children.filterheader,
      filterFooterTemplate: col.children && col.children.filterfooter,
      filterClearTemplate: col.children && col.children.filterclear,
      filterApplyTemplate: col.children && col.children.filterapply,
      filterIconTemplate: col.children && col.children.filtericon,
      filterAddIconTemplate: col.children && col.children.filteraddicon,
      filterRemoveIconTemplate: col.children && col.children.filterremoveicon,
      filterClearIconTemplate: col.children && col.children.filterclearicon,
      filters: $props.filters,
      filtersStore: $props.filtersStore,
      filterInputProps: $props.filterInputProps,
      filterButtonProps: $props.filterButtonProps,
      onFilterChange: _cache[16] || (_cache[16] = function($event) {
        return _ctx.$emit("filter-change", $event);
      }),
      onFilterApply: _cache[17] || (_cache[17] = function($event) {
        return _ctx.$emit("filter-apply");
      }),
      filterMenuStyle: $options.columnProp(col, "filterMenuStyle"),
      filterMenuClass: $options.columnProp(col, "filterMenuClass"),
      showOperator: $options.columnProp(col, "showFilterOperator"),
      showClearButton: $options.columnProp(col, "showClearButton"),
      showApplyButton: $options.columnProp(col, "showApplyButton"),
      showMatchModes: $options.columnProp(col, "showFilterMatchModes"),
      showAddButton: $options.columnProp(col, "showAddButton"),
      matchModeOptions: $options.columnProp(col, "filterMatchModeOptions"),
      maxConstraints: $options.columnProp(col, "maxConstraints"),
      onOperatorChange: _cache[18] || (_cache[18] = function($event) {
        return _ctx.$emit("operator-change", $event);
      }),
      onMatchmodeChange: _cache[19] || (_cache[19] = function($event) {
        return _ctx.$emit("matchmode-change", $event);
      }),
      onConstraintAdd: _cache[20] || (_cache[20] = function($event) {
        return _ctx.$emit("constraint-add", $event);
      }),
      onConstraintRemove: _cache[21] || (_cache[21] = function($event) {
        return _ctx.$emit("constraint-remove", $event);
      }),
      onApplyClick: _cache[22] || (_cache[22] = function($event) {
        return _ctx.$emit("apply-click", $event);
      }),
      column: col,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["field", "type", "showMenu", "filterElement", "filterHeaderTemplate", "filterFooterTemplate", "filterClearTemplate", "filterApplyTemplate", "filterIconTemplate", "filterAddIconTemplate", "filterRemoveIconTemplate", "filterClearIconTemplate", "filters", "filtersStore", "filterInputProps", "filterButtonProps", "filterMenuStyle", "filterMenuClass", "showOperator", "showClearButton", "showApplyButton", "showMatchModes", "showAddButton", "matchModeOptions", "maxConstraints", "column", "unstyled", "pt"])) : createCommentVNode("", true)], 16)) : createCommentVNode("", true)], 64);
  }), 128))], 16)) : createCommentVNode("", true)], 64)) : (openBlock(true), createElementBlock(Fragment, {
    key: 1
  }, renderList($options.getHeaderRows(), function(row2, i2) {
    return openBlock(), createElementBlock("tr", mergeProps({
      key: i2,
      role: "row",
      ref_for: true
    }, _objectSpread$2$1(_objectSpread$2$1({}, _ctx.ptm("headerRow")), $options.getRowPT(row2, "root", i2))), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.getHeaderColumns(row2), function(col, j) {
      return openBlock(), createElementBlock(Fragment, {
        key: $options.columnProp(col, "columnKey") || $options.columnProp(col, "field") || j
      }, [!$options.columnProp(col, "hidden") && ($props.rowGroupMode !== "subheader" || $props.groupRowsBy !== $options.columnProp(col, "field")) && typeof col.children !== "string" ? (openBlock(), createBlock(_component_DTHeaderCell, {
        key: 0,
        column: col,
        onColumnClick: _cache[23] || (_cache[23] = function($event) {
          return _ctx.$emit("column-click", $event);
        }),
        onColumnMousedown: _cache[24] || (_cache[24] = function($event) {
          return _ctx.$emit("column-mousedown", $event);
        }),
        groupRowsBy: $props.groupRowsBy,
        groupRowSortField: $props.groupRowSortField,
        sortMode: $props.sortMode,
        sortField: $props.sortField,
        sortOrder: $props.sortOrder,
        multiSortMeta: $props.multiSortMeta,
        allRowsSelected: $props.allRowsSelected,
        empty: $props.empty,
        onCheckboxChange: _cache[25] || (_cache[25] = function($event) {
          return _ctx.$emit("checkbox-change", $event);
        }),
        filters: $props.filters,
        filterDisplay: $props.filterDisplay,
        filtersStore: $props.filtersStore,
        onFilterChange: _cache[26] || (_cache[26] = function($event) {
          return _ctx.$emit("filter-change", $event);
        }),
        onFilterApply: _cache[27] || (_cache[27] = function($event) {
          return _ctx.$emit("filter-apply");
        }),
        onOperatorChange: _cache[28] || (_cache[28] = function($event) {
          return _ctx.$emit("operator-change", $event);
        }),
        onMatchmodeChange: _cache[29] || (_cache[29] = function($event) {
          return _ctx.$emit("matchmode-change", $event);
        }),
        onConstraintAdd: _cache[30] || (_cache[30] = function($event) {
          return _ctx.$emit("constraint-add", $event);
        }),
        onConstraintRemove: _cache[31] || (_cache[31] = function($event) {
          return _ctx.$emit("constraint-remove", $event);
        }),
        onApplyClick: _cache[32] || (_cache[32] = function($event) {
          return _ctx.$emit("apply-click", $event);
        }),
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["column", "groupRowsBy", "groupRowSortField", "sortMode", "sortField", "sortOrder", "multiSortMeta", "allRowsSelected", "empty", "filters", "filterDisplay", "filtersStore", "unstyled", "pt"])) : createCommentVNode("", true)], 64);
    }), 128))], 16);
  }), 128))], 16);
}
script$1$5.render = render$1$2;
function _typeof$1$2(o) {
  "@babel/helpers - typeof";
  return _typeof$1$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$2(o);
}
var _excluded = ["expanded"];
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i2 = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i2[o] = e[o]);
  }
  return i2;
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) >= 0) continue;
    t[n] = r[n];
  }
  return t;
}
function ownKeys$1$2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1$2(Object(t), true).forEach(function(r2) {
      _defineProperty$1$2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$1$2(e, r, t) {
  return (r = _toPropertyKey$1$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$1$2(t) {
  var i2 = _toPrimitive$1$2(t, "string");
  return "symbol" == _typeof$1$2(i2) ? i2 : i2 + "";
}
function _toPrimitive$1$2(t, r) {
  if ("object" != _typeof$1$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$3(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _createForOfIteratorHelper$3(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  } };
}
function _toConsumableArray$3(r) {
  return _arrayWithoutHoles$3(r) || _iterableToArray$3(r) || _unsupportedIterableToArray$3(r) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$3(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0;
  }
}
function _iterableToArray$3(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$3(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$3(r);
}
function _arrayLikeToArray$3(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$d = {
  name: "DataTable",
  "extends": script$c,
  inheritAttrs: false,
  emits: ["value-change", "update:first", "update:rows", "page", "update:sortField", "update:sortOrder", "update:multiSortMeta", "sort", "filter", "row-click", "row-dblclick", "update:selection", "row-select", "row-unselect", "update:contextMenuSelection", "row-contextmenu", "row-unselect-all", "row-select-all", "select-all-change", "column-resize-end", "column-reorder", "row-reorder", "update:expandedRows", "row-collapse", "row-expand", "update:expandedRowGroups", "rowgroup-collapse", "rowgroup-expand", "update:filters", "state-restore", "state-save", "cell-edit-init", "cell-edit-complete", "cell-edit-cancel", "update:editingRows", "row-edit-init", "row-edit-save", "row-edit-cancel"],
  provide: function provide37() {
    return {
      $columns: this.d_columns,
      $columnGroups: this.d_columnGroups
    };
  },
  data: function data24() {
    return {
      d_first: this.first,
      d_rows: this.rows,
      d_sortField: this.sortField,
      d_sortOrder: this.sortOrder,
      d_nullSortOrder: this.nullSortOrder,
      d_multiSortMeta: this.multiSortMeta ? _toConsumableArray$3(this.multiSortMeta) : [],
      d_groupRowsSortMeta: null,
      d_selectionKeys: null,
      d_columnOrder: null,
      d_editingRowKeys: null,
      d_editingMeta: {},
      d_filters: this.cloneFilters(this.filters),
      d_columns: new _default({
        type: "Column"
      }),
      d_columnGroups: new _default({
        type: "ColumnGroup"
      })
    };
  },
  rowTouched: false,
  anchorRowIndex: null,
  rangeRowIndex: null,
  documentColumnResizeListener: null,
  documentColumnResizeEndListener: null,
  lastResizeHelperX: null,
  resizeColumnElement: null,
  columnResizing: false,
  colReorderIconWidth: null,
  colReorderIconHeight: null,
  draggedColumn: null,
  draggedColumnElement: null,
  draggedRowIndex: null,
  droppedRowIndex: null,
  rowDragging: null,
  columnWidthsState: null,
  tableWidthState: null,
  columnWidthsRestored: false,
  watch: {
    first: function first3(newValue) {
      this.d_first = newValue;
    },
    rows: function rows2(newValue) {
      this.d_rows = newValue;
    },
    sortField: function sortField(newValue) {
      this.d_sortField = newValue;
    },
    sortOrder: function sortOrder(newValue) {
      this.d_sortOrder = newValue;
    },
    nullSortOrder: function nullSortOrder(newValue) {
      this.d_nullSortOrder = newValue;
    },
    multiSortMeta: function multiSortMeta(newValue) {
      this.d_multiSortMeta = newValue;
    },
    selection: {
      immediate: true,
      handler: function handler5(newValue) {
        if (this.dataKey) {
          this.updateSelectionKeys(newValue);
        }
      }
    },
    editingRows: {
      immediate: true,
      handler: function handler6(newValue) {
        if (this.dataKey) {
          this.updateEditingRowKeys(newValue);
        }
      }
    },
    filters: {
      deep: true,
      handler: function handler7(newValue) {
        this.d_filters = this.cloneFilters(newValue);
      }
    }
  },
  mounted: function mounted18() {
    this.$el.setAttribute(this.attributeSelector, "");
    if (this.isStateful()) {
      this.restoreState();
      this.resizableColumns && this.restoreColumnWidths();
    }
    if (this.editMode === "row" && this.dataKey && !this.d_editingRowKeys) {
      this.updateEditingRowKeys(this.editingRows);
    }
  },
  beforeUnmount: function beforeUnmount11() {
    this.unbindColumnResizeEvents();
    this.destroyStyleElement();
    this.d_columns.clear();
    this.d_columnGroups.clear();
  },
  updated: function updated12() {
    if (this.isStateful()) {
      this.saveState();
    }
    if (this.editMode === "row" && this.dataKey && !this.d_editingRowKeys) {
      this.updateEditingRowKeys(this.editingRows);
    }
  },
  methods: {
    columnProp: function columnProp7(col, prop2) {
      return getVNodeProp(col, prop2);
    },
    onPage: function onPage(event2) {
      var _this = this;
      this.clearEditingMetaData();
      this.d_first = event2.first;
      this.d_rows = event2.rows;
      var pageEvent = this.createLazyLoadEvent(event2);
      pageEvent.pageCount = event2.pageCount;
      pageEvent.page = event2.page;
      this.$emit("update:first", this.d_first);
      this.$emit("update:rows", this.d_rows);
      this.$emit("page", pageEvent);
      this.$nextTick(function() {
        _this.$emit("value-change", _this.processedData);
      });
    },
    onColumnHeaderClick: function onColumnHeaderClick(e) {
      var _this2 = this;
      var event2 = e.originalEvent;
      var column = e.column;
      if (this.columnProp(column, "sortable")) {
        var targetNode = event2.target;
        var columnField = this.columnProp(column, "sortField") || this.columnProp(column, "field");
        if (getAttribute(targetNode, "data-p-sortable-column") === true || getAttribute(targetNode, "data-pc-section") === "columntitle" || getAttribute(targetNode, "data-pc-section") === "columnheadercontent" || getAttribute(targetNode, "data-pc-section") === "sorticon" || getAttribute(targetNode.parentElement, "data-pc-section") === "sorticon" || getAttribute(targetNode.parentElement.parentElement, "data-pc-section") === "sorticon" || targetNode.closest('[data-p-sortable-column="true"]') && !targetNode.closest('[data-pc-section="columnfilterbutton"]') && !isClickable(event2.target)) {
          clearSelection();
          if (this.sortMode === "single") {
            if (this.d_sortField === columnField) {
              if (this.removableSort && this.d_sortOrder * -1 === this.defaultSortOrder) {
                this.d_sortOrder = null;
                this.d_sortField = null;
              } else {
                this.d_sortOrder = this.d_sortOrder * -1;
              }
            } else {
              this.d_sortOrder = this.defaultSortOrder;
              this.d_sortField = columnField;
            }
            this.$emit("update:sortField", this.d_sortField);
            this.$emit("update:sortOrder", this.d_sortOrder);
            this.resetPage();
          } else if (this.sortMode === "multiple") {
            var metaKey = event2.metaKey || event2.ctrlKey;
            if (!metaKey) {
              this.d_multiSortMeta = this.d_multiSortMeta.filter(function(meta) {
                return meta.field === columnField;
              });
            }
            this.addMultiSortField(columnField);
            this.$emit("update:multiSortMeta", this.d_multiSortMeta);
          }
          this.$emit("sort", this.createLazyLoadEvent(event2));
          this.$nextTick(function() {
            _this2.$emit("value-change", _this2.processedData);
          });
        }
      }
    },
    sortSingle: function sortSingle(value3) {
      var _this3 = this;
      this.clearEditingMetaData();
      if (this.groupRowsBy && this.groupRowsBy === this.sortField) {
        this.d_multiSortMeta = [{
          field: this.sortField,
          order: this.sortOrder || this.defaultSortOrder
        }, {
          field: this.d_sortField,
          order: this.d_sortOrder
        }];
        return this.sortMultiple(value3);
      }
      var data28 = _toConsumableArray$3(value3);
      var resolvedFieldData = /* @__PURE__ */ new Map();
      var _iterator = _createForOfIteratorHelper$3(data28), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var item = _step.value;
          resolvedFieldData.set(item, resolveFieldData(item, this.d_sortField));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var comparer = localeComparator();
      data28.sort(function(data1, data29) {
        var value1 = resolvedFieldData.get(data1);
        var value22 = resolvedFieldData.get(data29);
        return sort(value1, value22, _this3.d_sortOrder, comparer, _this3.d_nullSortOrder);
      });
      return data28;
    },
    sortMultiple: function sortMultiple(value3) {
      var _this4 = this;
      this.clearEditingMetaData();
      if (this.groupRowsBy && (this.d_groupRowsSortMeta || this.d_multiSortMeta.length && this.groupRowsBy === this.d_multiSortMeta[0].field)) {
        var firstSortMeta = this.d_multiSortMeta[0];
        !this.d_groupRowsSortMeta && (this.d_groupRowsSortMeta = firstSortMeta);
        if (firstSortMeta.field !== this.d_groupRowsSortMeta.field) {
          this.d_multiSortMeta = [this.d_groupRowsSortMeta].concat(_toConsumableArray$3(this.d_multiSortMeta));
        }
      }
      var data28 = _toConsumableArray$3(value3);
      data28.sort(function(data1, data29) {
        return _this4.multisortField(data1, data29, 0);
      });
      return data28;
    },
    multisortField: function multisortField(data1, data28, index2) {
      var value1 = resolveFieldData(data1, this.d_multiSortMeta[index2].field);
      var value22 = resolveFieldData(data28, this.d_multiSortMeta[index2].field);
      var comparer = localeComparator();
      if (value1 === value22) {
        return this.d_multiSortMeta.length - 1 > index2 ? this.multisortField(data1, data28, index2 + 1) : 0;
      }
      return sort(value1, value22, this.d_multiSortMeta[index2].order, comparer, this.d_nullSortOrder);
    },
    addMultiSortField: function addMultiSortField(field2) {
      var index2 = this.d_multiSortMeta.findIndex(function(meta) {
        return meta.field === field2;
      });
      if (index2 >= 0) {
        if (this.removableSort && this.d_multiSortMeta[index2].order * -1 === this.defaultSortOrder) this.d_multiSortMeta.splice(index2, 1);
        else this.d_multiSortMeta[index2] = {
          field: field2,
          order: this.d_multiSortMeta[index2].order * -1
        };
      } else {
        this.d_multiSortMeta.push({
          field: field2,
          order: this.defaultSortOrder
        });
      }
      this.d_multiSortMeta = _toConsumableArray$3(this.d_multiSortMeta);
    },
    getActiveFilters: function getActiveFilters(filters) {
      var removeEmptyFilters = function removeEmptyFilters2(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value3 = _ref2[1];
        if (value3.constraints) {
          var filteredConstraints = value3.constraints.filter(function(constraint) {
            return constraint.value !== null;
          });
          if (filteredConstraints.length > 0) {
            return [key, _objectSpread$1$2(_objectSpread$1$2({}, value3), {}, {
              constraints: filteredConstraints
            })];
          }
        } else if (value3.value !== null) {
          return [key, value3];
        }
        return void 0;
      };
      var filterValidEntries = function filterValidEntries2(entry) {
        return entry !== void 0;
      };
      var entries = Object.entries(filters).map(removeEmptyFilters).filter(filterValidEntries);
      return Object.fromEntries(entries);
    },
    filter: function filter4(data28) {
      var _this5 = this;
      if (!data28) {
        return;
      }
      this.clearEditingMetaData();
      var activeFilters = this.getActiveFilters(this.filters);
      var globalFilterFieldsArray;
      if (activeFilters["global"]) {
        globalFilterFieldsArray = this.globalFilterFields || this.columns.map(function(col) {
          return _this5.columnProp(col, "filterField") || _this5.columnProp(col, "field");
        });
      }
      var filteredValue2 = [];
      for (var i2 = 0; i2 < data28.length; i2++) {
        var localMatch = true;
        var globalMatch = false;
        var localFiltered = false;
        for (var prop2 in activeFilters) {
          if (Object.prototype.hasOwnProperty.call(activeFilters, prop2) && prop2 !== "global") {
            localFiltered = true;
            var filterField = prop2;
            var filterMeta = activeFilters[filterField];
            if (filterMeta.operator) {
              var _iterator2 = _createForOfIteratorHelper$3(filterMeta.constraints), _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                  var filterConstraint2 = _step2.value;
                  localMatch = this.executeLocalFilter(filterField, data28[i2], filterConstraint2);
                  if (filterMeta.operator === FilterOperator.OR && localMatch || filterMeta.operator === FilterOperator.AND && !localMatch) {
                    break;
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            } else {
              localMatch = this.executeLocalFilter(filterField, data28[i2], filterMeta);
            }
            if (!localMatch) {
              break;
            }
          }
        }
        if (localMatch && activeFilters["global"] && !globalMatch && globalFilterFieldsArray) {
          for (var j = 0; j < globalFilterFieldsArray.length; j++) {
            var globalFilterField = globalFilterFieldsArray[j];
            globalMatch = FilterService.filters[activeFilters["global"].matchMode || FilterMatchMode.CONTAINS](resolveFieldData(data28[i2], globalFilterField), activeFilters["global"].value, this.filterLocale);
            if (globalMatch) {
              break;
            }
          }
        }
        var matches2 = void 0;
        if (activeFilters["global"]) {
          matches2 = localFiltered ? localFiltered && localMatch && globalMatch : globalMatch;
        } else {
          matches2 = localFiltered && localMatch;
        }
        if (matches2) {
          filteredValue2.push(data28[i2]);
        }
      }
      if (filteredValue2.length === this.value.length || Object.keys(activeFilters).length == 0) {
        filteredValue2 = data28;
      }
      var filterEvent = this.createLazyLoadEvent();
      filterEvent.filteredValue = filteredValue2;
      this.$emit("filter", filterEvent);
      this.$nextTick(function() {
        _this5.$emit("value-change", _this5.processedData);
      });
      return filteredValue2;
    },
    executeLocalFilter: function executeLocalFilter(field2, rowData, filterMeta) {
      var filterValue = filterMeta.value;
      var filterMatchMode = filterMeta.matchMode || FilterMatchMode.STARTS_WITH;
      var dataFieldValue = resolveFieldData(rowData, field2);
      var filterConstraint2 = FilterService.filters[filterMatchMode];
      return filterConstraint2(dataFieldValue, filterValue, this.filterLocale);
    },
    onRowClick: function onRowClick2(e) {
      var event2 = e.originalEvent;
      var body = this.$refs.bodyRef && this.$refs.bodyRef.$el;
      var focusedItem = findSingle(body, 'tr[data-p-selectable-row="true"][tabindex="0"]');
      if (isClickable(event2.target)) {
        return;
      }
      this.$emit("row-click", e);
      if (this.selectionMode) {
        var rowData = e.data;
        var rowIndex2 = this.d_first + e.index;
        if (this.isMultipleSelectionMode() && event2.shiftKey && this.anchorRowIndex != null) {
          clearSelection();
          this.rangeRowIndex = rowIndex2;
          this.selectRange(event2);
        } else {
          var selected2 = this.isSelected(rowData);
          var metaSelection = this.rowTouched ? false : this.metaKeySelection;
          this.anchorRowIndex = rowIndex2;
          this.rangeRowIndex = rowIndex2;
          if (metaSelection) {
            var metaKey = event2.metaKey || event2.ctrlKey;
            if (selected2 && metaKey) {
              if (this.isSingleSelectionMode()) {
                this.$emit("update:selection", null);
              } else {
                var selectionIndex = this.findIndexInSelection(rowData);
                var _selection = this.selection.filter(function(val, i2) {
                  return i2 != selectionIndex;
                });
                this.$emit("update:selection", _selection);
              }
              this.$emit("row-unselect", {
                originalEvent: event2,
                data: rowData,
                index: rowIndex2,
                type: "row"
              });
            } else {
              if (this.isSingleSelectionMode()) {
                this.$emit("update:selection", rowData);
              } else if (this.isMultipleSelectionMode()) {
                var _selection2 = metaKey ? this.selection || [] : [];
                _selection2 = [].concat(_toConsumableArray$3(_selection2), [rowData]);
                this.$emit("update:selection", _selection2);
              }
              this.$emit("row-select", {
                originalEvent: event2,
                data: rowData,
                index: rowIndex2,
                type: "row"
              });
            }
          } else {
            if (this.selectionMode === "single") {
              if (selected2) {
                this.$emit("update:selection", null);
                this.$emit("row-unselect", {
                  originalEvent: event2,
                  data: rowData,
                  index: rowIndex2,
                  type: "row"
                });
              } else {
                this.$emit("update:selection", rowData);
                this.$emit("row-select", {
                  originalEvent: event2,
                  data: rowData,
                  index: rowIndex2,
                  type: "row"
                });
              }
            } else if (this.selectionMode === "multiple") {
              if (selected2) {
                var _selectionIndex = this.findIndexInSelection(rowData);
                var _selection3 = this.selection.filter(function(val, i2) {
                  return i2 != _selectionIndex;
                });
                this.$emit("update:selection", _selection3);
                this.$emit("row-unselect", {
                  originalEvent: event2,
                  data: rowData,
                  index: rowIndex2,
                  type: "row"
                });
              } else {
                var _selection4 = this.selection ? [].concat(_toConsumableArray$3(this.selection), [rowData]) : [rowData];
                this.$emit("update:selection", _selection4);
                this.$emit("row-select", {
                  originalEvent: event2,
                  data: rowData,
                  index: rowIndex2,
                  type: "row"
                });
              }
            }
          }
        }
      }
      this.rowTouched = false;
      if (focusedItem) {
        var _event$target, _event$target2, _event$target3;
        if (((_event$target = event2.target) === null || _event$target === void 0 ? void 0 : _event$target.getAttribute("data-pc-section")) === "rowtoggleicon" || ((_event$target2 = event2.target) === null || _event$target2 === void 0 || (_event$target2 = _event$target2.parentElement) === null || _event$target2 === void 0 ? void 0 : _event$target2.getAttribute("data-pc-section")) === "rowtoggleicon") return;
        var targetRow = (_event$target3 = event2.target) === null || _event$target3 === void 0 ? void 0 : _event$target3.closest('tr[data-p-selectable-row="true"]');
        focusedItem.tabIndex = "-1";
        targetRow.tabIndex = "0";
      }
    },
    onRowDblClick: function onRowDblClick2(e) {
      var event2 = e.originalEvent;
      if (isClickable(event2.target)) {
        return;
      }
      this.$emit("row-dblclick", e);
    },
    onRowRightClick: function onRowRightClick2(event2) {
      if (this.contextMenu) {
        clearSelection();
        event2.originalEvent.target.focus();
      }
      this.$emit("update:contextMenuSelection", event2.data);
      this.$emit("row-contextmenu", event2);
    },
    onRowTouchEnd: function onRowTouchEnd2() {
      this.rowTouched = true;
    },
    onRowKeyDown: function onRowKeyDown2(e, slotProps) {
      var event2 = e.originalEvent;
      var rowData = e.data;
      var rowIndex2 = e.index;
      var metaKey = event2.metaKey || event2.ctrlKey;
      if (this.selectionMode) {
        var row2 = event2.target;
        switch (event2.code) {
          case "ArrowDown":
            this.onArrowDownKey(event2, row2, rowIndex2, slotProps);
            break;
          case "ArrowUp":
            this.onArrowUpKey(event2, row2, rowIndex2, slotProps);
            break;
          case "Home":
            this.onHomeKey(event2, row2, rowIndex2, slotProps);
            break;
          case "End":
            this.onEndKey(event2, row2, rowIndex2, slotProps);
            break;
          case "Enter":
          case "NumpadEnter":
            this.onEnterKey(event2, rowData, rowIndex2);
            break;
          case "Space":
            this.onSpaceKey(event2, rowData, rowIndex2, slotProps);
            break;
          case "Tab":
            this.onTabKey(event2, rowIndex2);
            break;
          default:
            if (event2.code === "KeyA" && metaKey && this.isMultipleSelectionMode()) {
              var data28 = this.dataToRender(slotProps.rows);
              this.$emit("update:selection", data28);
            }
            event2.preventDefault();
            break;
        }
      }
    },
    onArrowDownKey: function onArrowDownKey4(event2, row2, rowIndex2, slotProps) {
      var nextRow = this.findNextSelectableRow(row2);
      nextRow && this.focusRowChange(row2, nextRow);
      if (event2.shiftKey) {
        var data28 = this.dataToRender(slotProps.rows);
        var nextRowIndex = rowIndex2 + 1 >= data28.length ? data28.length - 1 : rowIndex2 + 1;
        this.onRowClick({
          originalEvent: event2,
          data: data28[nextRowIndex],
          index: nextRowIndex
        });
      }
      event2.preventDefault();
    },
    onArrowUpKey: function onArrowUpKey4(event2, row2, rowIndex2, slotProps) {
      var prevRow = this.findPrevSelectableRow(row2);
      prevRow && this.focusRowChange(row2, prevRow);
      if (event2.shiftKey) {
        var data28 = this.dataToRender(slotProps.rows);
        var prevRowIndex = rowIndex2 - 1 <= 0 ? 0 : rowIndex2 - 1;
        this.onRowClick({
          originalEvent: event2,
          data: data28[prevRowIndex],
          index: prevRowIndex
        });
      }
      event2.preventDefault();
    },
    onHomeKey: function onHomeKey4(event2, row2, rowIndex2, slotProps) {
      var firstRow = this.findFirstSelectableRow();
      firstRow && this.focusRowChange(row2, firstRow);
      if (event2.ctrlKey && event2.shiftKey) {
        var data28 = this.dataToRender(slotProps.rows);
        this.$emit("update:selection", data28.slice(0, rowIndex2 + 1));
      }
      event2.preventDefault();
    },
    onEndKey: function onEndKey4(event2, row2, rowIndex2, slotProps) {
      var lastRow = this.findLastSelectableRow();
      lastRow && this.focusRowChange(row2, lastRow);
      if (event2.ctrlKey && event2.shiftKey) {
        var data28 = this.dataToRender(slotProps.rows);
        this.$emit("update:selection", data28.slice(rowIndex2, data28.length));
      }
      event2.preventDefault();
    },
    onEnterKey: function onEnterKey4(event2, rowData, rowIndex2) {
      this.onRowClick({
        originalEvent: event2,
        data: rowData,
        index: rowIndex2
      });
      event2.preventDefault();
    },
    onSpaceKey: function onSpaceKey3(event2, rowData, rowIndex2, slotProps) {
      this.onEnterKey(event2, rowData, rowIndex2);
      if (event2.shiftKey && this.selection !== null) {
        var data28 = this.dataToRender(slotProps.rows);
        var index2;
        if (this.selection.length > 0) {
          var firstSelectedRowIndex, lastSelectedRowIndex;
          firstSelectedRowIndex = findIndexInList(this.selection[0], data28);
          lastSelectedRowIndex = findIndexInList(this.selection[this.selection.length - 1], data28);
          index2 = rowIndex2 <= firstSelectedRowIndex ? lastSelectedRowIndex : firstSelectedRowIndex;
        } else {
          index2 = findIndexInList(this.selection, data28);
        }
        var _selection = index2 !== rowIndex2 ? data28.slice(Math.min(index2, rowIndex2), Math.max(index2, rowIndex2) + 1) : rowData;
        this.$emit("update:selection", _selection);
      }
    },
    onTabKey: function onTabKey3(event2, rowIndex2) {
      var body = this.$refs.bodyRef && this.$refs.bodyRef.$el;
      var rows3 = find(body, 'tr[data-p-selectable-row="true"]');
      if (event2.code === "Tab" && rows3 && rows3.length > 0) {
        var firstSelectedRow = findSingle(body, 'tr[data-p-selected="true"]');
        var focusedItem = findSingle(body, 'tr[data-p-selectable-row="true"][tabindex="0"]');
        if (firstSelectedRow) {
          firstSelectedRow.tabIndex = "0";
          focusedItem && focusedItem !== firstSelectedRow && (focusedItem.tabIndex = "-1");
        } else {
          rows3[0].tabIndex = "0";
          focusedItem !== rows3[0] && (rows3[rowIndex2].tabIndex = "-1");
        }
      }
    },
    findNextSelectableRow: function findNextSelectableRow(row2) {
      var nextRow = row2.nextElementSibling;
      if (nextRow) {
        if (getAttribute(nextRow, "data-p-selectable-row") === true) return nextRow;
        else return this.findNextSelectableRow(nextRow);
      } else {
        return null;
      }
    },
    findPrevSelectableRow: function findPrevSelectableRow(row2) {
      var prevRow = row2.previousElementSibling;
      if (prevRow) {
        if (getAttribute(prevRow, "data-p-selectable-row") === true) return prevRow;
        else return this.findPrevSelectableRow(prevRow);
      } else {
        return null;
      }
    },
    findFirstSelectableRow: function findFirstSelectableRow() {
      var firstRow = findSingle(this.$refs.table, 'tr[data-p-selectable-row="true"]');
      return firstRow;
    },
    findLastSelectableRow: function findLastSelectableRow() {
      var rows3 = find(this.$refs.table, 'tr[data-p-selectable-row="true"]');
      return rows3 ? rows3[rows3.length - 1] : null;
    },
    focusRowChange: function focusRowChange(firstFocusableRow, currentFocusedRow) {
      firstFocusableRow.tabIndex = "-1";
      currentFocusedRow.tabIndex = "0";
      focus(currentFocusedRow);
    },
    toggleRowWithRadio: function toggleRowWithRadio2(event2) {
      var rowData = event2.data;
      if (this.isSelected(rowData)) {
        this.$emit("update:selection", null);
        this.$emit("row-unselect", {
          originalEvent: event2.originalEvent,
          data: rowData,
          index: event2.index,
          type: "radiobutton"
        });
      } else {
        this.$emit("update:selection", rowData);
        this.$emit("row-select", {
          originalEvent: event2.originalEvent,
          data: rowData,
          index: event2.index,
          type: "radiobutton"
        });
      }
    },
    toggleRowWithCheckbox: function toggleRowWithCheckbox2(event2) {
      var rowData = event2.data;
      if (this.isSelected(rowData)) {
        var selectionIndex = this.findIndexInSelection(rowData);
        var _selection = this.selection.filter(function(val, i2) {
          return i2 != selectionIndex;
        });
        this.$emit("update:selection", _selection);
        this.$emit("row-unselect", {
          originalEvent: event2.originalEvent,
          data: rowData,
          index: event2.index,
          type: "checkbox"
        });
      } else {
        var _selection5 = this.selection ? _toConsumableArray$3(this.selection) : [];
        _selection5 = [].concat(_toConsumableArray$3(_selection5), [rowData]);
        this.$emit("update:selection", _selection5);
        this.$emit("row-select", {
          originalEvent: event2.originalEvent,
          data: rowData,
          index: event2.index,
          type: "checkbox"
        });
      }
    },
    toggleRowsWithCheckbox: function toggleRowsWithCheckbox(event2) {
      if (this.selectAll !== null) {
        this.$emit("select-all-change", event2);
      } else {
        var originalEvent = event2.originalEvent, checked5 = event2.checked;
        var _selection = [];
        if (checked5) {
          _selection = this.frozenValue ? [].concat(_toConsumableArray$3(this.frozenValue), _toConsumableArray$3(this.processedData)) : this.processedData;
          this.$emit("row-select-all", {
            originalEvent,
            data: _selection
          });
        } else {
          this.$emit("row-unselect-all", {
            originalEvent
          });
        }
        this.$emit("update:selection", _selection);
      }
    },
    isSingleSelectionMode: function isSingleSelectionMode() {
      return this.selectionMode === "single";
    },
    isMultipleSelectionMode: function isMultipleSelectionMode() {
      return this.selectionMode === "multiple";
    },
    isSelected: function isSelected6(rowData) {
      if (rowData && this.selection) {
        if (this.dataKey) {
          return this.d_selectionKeys ? this.d_selectionKeys[resolveFieldData(rowData, this.dataKey)] !== void 0 : false;
        } else {
          if (this.selection instanceof Array) return this.findIndexInSelection(rowData) > -1;
          else return this.equals(rowData, this.selection);
        }
      }
      return false;
    },
    findIndexInSelection: function findIndexInSelection2(rowData) {
      return this.findIndex(rowData, this.selection);
    },
    findIndex: function findIndex2(rowData, collection) {
      var index2 = -1;
      if (collection && collection.length) {
        for (var i2 = 0; i2 < collection.length; i2++) {
          if (this.equals(rowData, collection[i2])) {
            index2 = i2;
            break;
          }
        }
      }
      return index2;
    },
    updateSelectionKeys: function updateSelectionKeys(selection) {
      this.d_selectionKeys = {};
      if (Array.isArray(selection)) {
        var _iterator3 = _createForOfIteratorHelper$3(selection), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var data28 = _step3.value;
            this.d_selectionKeys[String(resolveFieldData(data28, this.dataKey))] = 1;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } else {
        this.d_selectionKeys[String(resolveFieldData(selection, this.dataKey))] = 1;
      }
    },
    updateEditingRowKeys: function updateEditingRowKeys(editingRows) {
      if (editingRows && editingRows.length) {
        this.d_editingRowKeys = {};
        var _iterator4 = _createForOfIteratorHelper$3(editingRows), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var data28 = _step4.value;
            this.d_editingRowKeys[String(resolveFieldData(data28, this.dataKey))] = 1;
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      } else {
        this.d_editingRowKeys = null;
      }
    },
    equals: function equals$12(data1, data28) {
      return this.compareSelectionBy === "equals" ? data1 === data28 : equals(data1, data28, this.dataKey);
    },
    selectRange: function selectRange(event2) {
      var rangeStart, rangeEnd;
      if (this.rangeRowIndex > this.anchorRowIndex) {
        rangeStart = this.anchorRowIndex;
        rangeEnd = this.rangeRowIndex;
      } else if (this.rangeRowIndex < this.anchorRowIndex) {
        rangeStart = this.rangeRowIndex;
        rangeEnd = this.anchorRowIndex;
      } else {
        rangeStart = this.rangeRowIndex;
        rangeEnd = this.rangeRowIndex;
      }
      if (this.lazy && this.paginator) {
        rangeStart -= this.first;
        rangeEnd -= this.first;
      }
      var value3 = this.processedData;
      var _selection = [];
      for (var i2 = rangeStart; i2 <= rangeEnd; i2++) {
        var rangeRowData = value3[i2];
        _selection.push(rangeRowData);
        this.$emit("row-select", {
          originalEvent: event2,
          data: rangeRowData,
          type: "row"
        });
      }
      this.$emit("update:selection", _selection);
    },
    exportCSV: function exportCSV$1(options3, data28) {
      var _this6 = this;
      var csv = "\uFEFF";
      if (!data28) {
        data28 = this.processedData;
        if (options3 && options3.selectionOnly) data28 = this.selection || [];
        else if (this.frozenValue) data28 = data28 ? [].concat(_toConsumableArray$3(this.frozenValue), _toConsumableArray$3(data28)) : this.frozenValue;
      }
      var headerInitiated = false;
      for (var i2 = 0; i2 < this.columns.length; i2++) {
        var column = this.columns[i2];
        if (this.columnProp(column, "exportable") !== false && this.columnProp(column, "field")) {
          if (headerInitiated) csv += this.csvSeparator;
          else headerInitiated = true;
          csv += '"' + (this.columnProp(column, "exportHeader") || this.columnProp(column, "header") || this.columnProp(column, "field")) + '"';
        }
      }
      if (data28) {
        data28.forEach(function(record) {
          csv += "\n";
          var rowInitiated = false;
          for (var _i = 0; _i < _this6.columns.length; _i++) {
            var _column = _this6.columns[_i];
            if (_this6.columnProp(_column, "exportable") !== false && _this6.columnProp(_column, "field")) {
              if (rowInitiated) csv += _this6.csvSeparator;
              else rowInitiated = true;
              var cellData = resolveFieldData(record, _this6.columnProp(_column, "field"));
              if (cellData != null) {
                if (_this6.exportFunction) {
                  cellData = _this6.exportFunction({
                    data: cellData,
                    field: _this6.columnProp(_column, "field")
                  });
                } else cellData = String(cellData).replace(/"/g, '""');
              } else cellData = "";
              csv += '"' + cellData + '"';
            }
          }
        });
      }
      var footerInitiated = false;
      for (var _i2 = 0; _i2 < this.columns.length; _i2++) {
        var _column2 = this.columns[_i2];
        if (_i2 === 0) csv += "\n";
        if (this.columnProp(_column2, "exportable") !== false && this.columnProp(_column2, "exportFooter")) {
          if (footerInitiated) csv += this.csvSeparator;
          else footerInitiated = true;
          csv += '"' + (this.columnProp(_column2, "exportFooter") || this.columnProp(_column2, "footer") || this.columnProp(_column2, "field")) + '"';
        }
      }
      exportCSV(csv, this.exportFilename);
    },
    resetPage: function resetPage() {
      this.d_first = 0;
      this.$emit("update:first", this.d_first);
    },
    onColumnResizeStart: function onColumnResizeStart(event2) {
      var containerLeft = getOffset(this.$el).left;
      this.resizeColumnElement = event2.target.parentElement;
      this.columnResizing = true;
      this.lastResizeHelperX = event2.pageX - containerLeft + this.$el.scrollLeft;
      this.bindColumnResizeEvents();
    },
    onColumnResize: function onColumnResize(event2) {
      var containerLeft = getOffset(this.$el).left;
      this.$el.setAttribute("data-p-unselectable-text", "true");
      !this.isUnstyled && addStyle(this.$el, {
        "user-select": "none"
      });
      this.$refs.resizeHelper.style.height = this.$el.offsetHeight + "px";
      this.$refs.resizeHelper.style.top = "0px";
      this.$refs.resizeHelper.style.left = event2.pageX - containerLeft + this.$el.scrollLeft + "px";
      this.$refs.resizeHelper.style.display = "block";
    },
    onColumnResizeEnd: function onColumnResizeEnd() {
      var delta2 = this.$refs.resizeHelper.offsetLeft - this.lastResizeHelperX;
      var columnWidth = this.resizeColumnElement.offsetWidth;
      var newColumnWidth = columnWidth + delta2;
      var minWidth = this.resizeColumnElement.style.minWidth || 15;
      if (columnWidth + delta2 > parseInt(minWidth, 10)) {
        if (this.columnResizeMode === "fit") {
          var nextColumn = this.resizeColumnElement.nextElementSibling;
          var nextColumnWidth = nextColumn.offsetWidth - delta2;
          if (newColumnWidth > 15 && nextColumnWidth > 15) {
            this.resizeTableCells(newColumnWidth, nextColumnWidth);
          }
        } else if (this.columnResizeMode === "expand") {
          var tableWidth = this.$refs.table.offsetWidth + delta2 + "px";
          var updateTableWidth = function updateTableWidth2(el) {
            !!el && (el.style.width = el.style.minWidth = tableWidth);
          };
          this.resizeTableCells(newColumnWidth);
          updateTableWidth(this.$refs.table);
          if (!this.virtualScrollerDisabled) {
            var body = this.$refs.bodyRef && this.$refs.bodyRef.$el;
            var frozenBody = this.$refs.frozenBodyRef && this.$refs.frozenBodyRef.$el;
            updateTableWidth(body);
            updateTableWidth(frozenBody);
          }
        }
        this.$emit("column-resize-end", {
          element: this.resizeColumnElement,
          delta: delta2
        });
      }
      this.$refs.resizeHelper.style.display = "none";
      this.resizeColumn = null;
      this.$el.removeAttribute("data-p-unselectable-text");
      !this.isUnstyled && (this.$el.style["user-select"] = "");
      this.unbindColumnResizeEvents();
      if (this.isStateful()) {
        this.saveState();
      }
    },
    resizeTableCells: function resizeTableCells(newColumnWidth, nextColumnWidth) {
      var colIndex = getIndex(this.resizeColumnElement);
      var widths = [];
      var headers = find(this.$refs.table, 'thead[data-pc-section="thead"] > tr > th');
      headers.forEach(function(header) {
        return widths.push(getOuterWidth(header));
      });
      this.destroyStyleElement();
      this.createStyleElement();
      var innerHTML = "";
      var selector = '[data-pc-name="datatable"]['.concat(this.attributeSelector, '] > [data-pc-section="tablecontainer"] ').concat(this.virtualScrollerDisabled ? "" : '> [data-pc-name="virtualscroller"]', ' > table[data-pc-section="table"]');
      widths.forEach(function(width2, index2) {
        var colWidth = index2 === colIndex ? newColumnWidth : nextColumnWidth && index2 === colIndex + 1 ? nextColumnWidth : width2;
        var style = "width: ".concat(colWidth, "px !important; max-width: ").concat(colWidth, "px !important");
        innerHTML += "\n                    ".concat(selector, ' > thead[data-pc-section="thead"] > tr > th:nth-child(').concat(index2 + 1, "),\n                    ").concat(selector, ' > tbody[data-pc-section="tbody"] > tr > td:nth-child(').concat(index2 + 1, "),\n                    ").concat(selector, ' > tfoot[data-pc-section="tfoot"] > tr > td:nth-child(').concat(index2 + 1, ") {\n                        ").concat(style, "\n                    }\n                ");
      });
      this.styleElement.innerHTML = innerHTML;
    },
    bindColumnResizeEvents: function bindColumnResizeEvents() {
      var _this7 = this;
      if (!this.documentColumnResizeListener) {
        this.documentColumnResizeListener = document.addEventListener("mousemove", function() {
          if (_this7.columnResizing) {
            _this7.onColumnResize(event);
          }
        });
      }
      if (!this.documentColumnResizeEndListener) {
        this.documentColumnResizeEndListener = document.addEventListener("mouseup", function() {
          if (_this7.columnResizing) {
            _this7.columnResizing = false;
            _this7.onColumnResizeEnd();
          }
        });
      }
    },
    unbindColumnResizeEvents: function unbindColumnResizeEvents() {
      if (this.documentColumnResizeListener) {
        document.removeEventListener("document", this.documentColumnResizeListener);
        this.documentColumnResizeListener = null;
      }
      if (this.documentColumnResizeEndListener) {
        document.removeEventListener("document", this.documentColumnResizeEndListener);
        this.documentColumnResizeEndListener = null;
      }
    },
    onColumnHeaderMouseDown: function onColumnHeaderMouseDown(e) {
      var event2 = e.originalEvent;
      var column = e.column;
      if (this.reorderableColumns && this.columnProp(column, "reorderableColumn") !== false) {
        if (event2.target.nodeName === "INPUT" || event2.target.nodeName === "TEXTAREA" || getAttribute(event2.target, '[data-pc-section="columnresizer"]')) event2.currentTarget.draggable = false;
        else event2.currentTarget.draggable = true;
      }
    },
    onColumnHeaderDragStart: function onColumnHeaderDragStart(e) {
      var event2 = e.originalEvent, column = e.column;
      if (this.columnResizing) {
        event2.preventDefault();
        return;
      }
      this.colReorderIconWidth = getHiddenElementOuterWidth(this.$refs.reorderIndicatorUp);
      this.colReorderIconHeight = getHiddenElementOuterHeight(this.$refs.reorderIndicatorUp);
      this.draggedColumn = column;
      this.draggedColumnElement = this.findParentHeader(event2.target);
      event2.dataTransfer.setData("text", "b");
    },
    onColumnHeaderDragOver: function onColumnHeaderDragOver(e) {
      var event2 = e.originalEvent, column = e.column;
      var dropHeader = this.findParentHeader(event2.target);
      if (this.reorderableColumns && this.draggedColumnElement && dropHeader && !this.columnProp(column, "frozen")) {
        event2.preventDefault();
        var containerOffset = getOffset(this.$el);
        var dropHeaderOffset = getOffset(dropHeader);
        if (this.draggedColumnElement !== dropHeader) {
          var targetLeft = dropHeaderOffset.left - containerOffset.left;
          var columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
          this.$refs.reorderIndicatorUp.style.top = dropHeaderOffset.top - containerOffset.top - (this.colReorderIconHeight - 1) + "px";
          this.$refs.reorderIndicatorDown.style.top = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + "px";
          if (event2.pageX > columnCenter) {
            this.$refs.reorderIndicatorUp.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(this.colReorderIconWidth / 2) + "px";
            this.$refs.reorderIndicatorDown.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(this.colReorderIconWidth / 2) + "px";
            this.dropPosition = 1;
          } else {
            this.$refs.reorderIndicatorUp.style.left = targetLeft - Math.ceil(this.colReorderIconWidth / 2) + "px";
            this.$refs.reorderIndicatorDown.style.left = targetLeft - Math.ceil(this.colReorderIconWidth / 2) + "px";
            this.dropPosition = -1;
          }
          this.$refs.reorderIndicatorUp.style.display = "block";
          this.$refs.reorderIndicatorDown.style.display = "block";
        }
      }
    },
    onColumnHeaderDragLeave: function onColumnHeaderDragLeave(e) {
      var event2 = e.originalEvent;
      if (this.reorderableColumns && this.draggedColumnElement) {
        event2.preventDefault();
        this.$refs.reorderIndicatorUp.style.display = "none";
        this.$refs.reorderIndicatorDown.style.display = "none";
      }
    },
    onColumnHeaderDrop: function onColumnHeaderDrop(e) {
      var _this8 = this;
      var event2 = e.originalEvent, column = e.column;
      event2.preventDefault();
      if (this.draggedColumnElement) {
        var dragIndex = getIndex(this.draggedColumnElement);
        var dropIndex = getIndex(this.findParentHeader(event2.target));
        var allowDrop = dragIndex !== dropIndex;
        if (allowDrop && (dropIndex - dragIndex === 1 && this.dropPosition === -1 || dropIndex - dragIndex === -1 && this.dropPosition === 1)) {
          allowDrop = false;
        }
        if (allowDrop) {
          var isSameColumn = function isSameColumn2(col1, col2) {
            return _this8.columnProp(col1, "columnKey") || _this8.columnProp(col2, "columnKey") ? _this8.columnProp(col1, "columnKey") === _this8.columnProp(col2, "columnKey") : _this8.columnProp(col1, "field") === _this8.columnProp(col2, "field");
          };
          var dragColIndex = this.columns.findIndex(function(child) {
            return isSameColumn(child, _this8.draggedColumn);
          });
          var dropColIndex = this.columns.findIndex(function(child) {
            return isSameColumn(child, column);
          });
          var widths = [];
          var headers = find(this.$el, 'thead[data-pc-section="thead"] > tr > th');
          headers.forEach(function(header) {
            return widths.push(getOuterWidth(header));
          });
          var movedItem = widths.find(function(_2, index2) {
            return index2 === dragColIndex;
          });
          var remainingItems = widths.filter(function(_2, index2) {
            return index2 !== dragColIndex;
          });
          var reorderedWidths = [].concat(_toConsumableArray$3(remainingItems.slice(0, dropColIndex)), [movedItem], _toConsumableArray$3(remainingItems.slice(dropColIndex)));
          this.addColumnWidthStyles(reorderedWidths);
          if (dropColIndex < dragColIndex && this.dropPosition === 1) {
            dropColIndex++;
          }
          if (dropColIndex > dragColIndex && this.dropPosition === -1) {
            dropColIndex--;
          }
          reorderArray(this.columns, dragColIndex, dropColIndex);
          this.updateReorderableColumns();
          this.$emit("column-reorder", {
            originalEvent: event2,
            dragIndex: dragColIndex,
            dropIndex: dropColIndex
          });
        }
        this.$refs.reorderIndicatorUp.style.display = "none";
        this.$refs.reorderIndicatorDown.style.display = "none";
        this.draggedColumnElement.draggable = false;
        this.draggedColumnElement = null;
        this.draggedColumn = null;
        this.dropPosition = null;
      }
    },
    findParentHeader: function findParentHeader(element) {
      if (element.nodeName === "TH") {
        return element;
      } else {
        var parent = element.parentElement;
        while (parent.nodeName !== "TH") {
          parent = parent.parentElement;
          if (!parent) break;
        }
        return parent;
      }
    },
    findColumnByKey: function findColumnByKey(columns2, key) {
      if (columns2 && columns2.length) {
        for (var i2 = 0; i2 < columns2.length; i2++) {
          var column = columns2[i2];
          if (this.columnProp(column, "columnKey") === key || this.columnProp(column, "field") === key) {
            return column;
          }
        }
      }
      return null;
    },
    onRowMouseDown: function onRowMouseDown2(event2) {
      if (getAttribute(event2.target, "data-pc-section") === "reorderablerowhandle" || getAttribute(event2.target.parentElement, "data-pc-section") === "reorderablerowhandle") event2.currentTarget.draggable = true;
      else event2.currentTarget.draggable = false;
    },
    onRowDragStart: function onRowDragStart2(e) {
      var event2 = e.originalEvent;
      var index2 = e.index;
      this.rowDragging = true;
      this.draggedRowIndex = index2;
      event2.dataTransfer.setData("text", "b");
    },
    onRowDragOver: function onRowDragOver2(e) {
      var event2 = e.originalEvent;
      var index2 = e.index;
      if (this.rowDragging && this.draggedRowIndex !== index2) {
        var rowElement = event2.currentTarget;
        var rowY = getOffset(rowElement).top + getWindowScrollTop();
        var pageY = event2.pageY;
        var rowMidY = rowY + getOuterHeight(rowElement) / 2;
        var prevRowElement = rowElement.previousElementSibling;
        if (pageY < rowMidY) {
          rowElement.setAttribute("data-p-datatable-dragpoint-bottom", "false");
          !this.isUnstyled && removeClass(rowElement, "p-datatable-dragpoint-bottom");
          this.droppedRowIndex = index2;
          if (prevRowElement) {
            prevRowElement.setAttribute("data-p-datatable-dragpoint-bottom", "true");
            !this.isUnstyled && addClass(prevRowElement, "p-datatable-dragpoint-bottom");
          } else {
            rowElement.setAttribute("data-p-datatable-dragpoint-top", "true");
            !this.isUnstyled && addClass(rowElement, "p-datatable-dragpoint-top");
          }
        } else {
          if (prevRowElement) {
            prevRowElement.setAttribute("data-p-datatable-dragpoint-bottom", "false");
            !this.isUnstyled && removeClass(prevRowElement, "p-datatable-dragpoint-bottom");
          } else {
            rowElement.setAttribute("data-p-datatable-dragpoint-top", "true");
            !this.isUnstyled && addClass(rowElement, "p-datatable-dragpoint-top");
          }
          this.droppedRowIndex = index2 + 1;
          rowElement.setAttribute("data-p-datatable-dragpoint-bottom", "true");
          !this.isUnstyled && addClass(rowElement, "p-datatable-dragpoint-bottom");
        }
        event2.preventDefault();
      }
    },
    onRowDragLeave: function onRowDragLeave2(event2) {
      var rowElement = event2.currentTarget;
      var prevRowElement = rowElement.previousElementSibling;
      if (prevRowElement) {
        prevRowElement.setAttribute("data-p-datatable-dragpoint-bottom", "false");
        !this.isUnstyled && removeClass(prevRowElement, "p-datatable-dragpoint-bottom");
      }
      rowElement.setAttribute("data-p-datatable-dragpoint-bottom", "false");
      !this.isUnstyled && removeClass(rowElement, "p-datatable-dragpoint-bottom");
      rowElement.setAttribute("data-p-datatable-dragpoint-top", "false");
      !this.isUnstyled && removeClass(rowElement, "p-datatable-dragpoint-top");
    },
    onRowDragEnd: function onRowDragEnd2(event2) {
      this.rowDragging = false;
      this.draggedRowIndex = null;
      this.droppedRowIndex = null;
      event2.currentTarget.draggable = false;
    },
    onRowDrop: function onRowDrop2(event2) {
      if (this.droppedRowIndex != null) {
        var dropIndex = this.draggedRowIndex > this.droppedRowIndex ? this.droppedRowIndex : this.droppedRowIndex === 0 ? 0 : this.droppedRowIndex - 1;
        var processedData2 = _toConsumableArray$3(this.processedData);
        reorderArray(processedData2, this.draggedRowIndex + this.d_first, dropIndex + this.d_first);
        this.$emit("row-reorder", {
          originalEvent: event2,
          dragIndex: this.draggedRowIndex,
          dropIndex,
          value: processedData2
        });
      }
      this.onRowDragLeave(event2);
      this.onRowDragEnd(event2);
      event2.preventDefault();
    },
    toggleRow: function toggleRow2(event2) {
      var _this9 = this;
      var expanded2 = event2.expanded, rest = _objectWithoutProperties(event2, _excluded);
      var rowData = event2.data;
      var expandedRows;
      if (this.dataKey) {
        var value3 = resolveFieldData(rowData, this.dataKey);
        expandedRows = this.expandedRows ? _objectSpread$1$2({}, this.expandedRows) : {};
        expanded2 ? expandedRows[value3] = true : delete expandedRows[value3];
      } else {
        expandedRows = this.expandedRows ? _toConsumableArray$3(this.expandedRows) : [];
        expanded2 ? expandedRows.push(rowData) : expandedRows = expandedRows.filter(function(d) {
          return !_this9.equals(rowData, d);
        });
      }
      this.$emit("update:expandedRows", expandedRows);
      expanded2 ? this.$emit("row-expand", rest) : this.$emit("row-collapse", rest);
    },
    toggleRowGroup: function toggleRowGroup(e) {
      var event2 = e.originalEvent;
      var data28 = e.data;
      var groupFieldValue = resolveFieldData(data28, this.groupRowsBy);
      var _expandedRowGroups = this.expandedRowGroups ? _toConsumableArray$3(this.expandedRowGroups) : [];
      if (this.isRowGroupExpanded(data28)) {
        _expandedRowGroups = _expandedRowGroups.filter(function(group) {
          return group !== groupFieldValue;
        });
        this.$emit("update:expandedRowGroups", _expandedRowGroups);
        this.$emit("rowgroup-collapse", {
          originalEvent: event2,
          data: groupFieldValue
        });
      } else {
        _expandedRowGroups.push(groupFieldValue);
        this.$emit("update:expandedRowGroups", _expandedRowGroups);
        this.$emit("rowgroup-expand", {
          originalEvent: event2,
          data: groupFieldValue
        });
      }
    },
    isRowGroupExpanded: function isRowGroupExpanded2(rowData) {
      if (this.expandableRowGroups && this.expandedRowGroups) {
        var groupFieldValue = resolveFieldData(rowData, this.groupRowsBy);
        return this.expandedRowGroups.indexOf(groupFieldValue) > -1;
      }
      return false;
    },
    isStateful: function isStateful2() {
      return this.stateKey != null;
    },
    getStorage: function getStorage2() {
      switch (this.stateStorage) {
        case "local":
          return window.localStorage;
        case "session":
          return window.sessionStorage;
        default:
          throw new Error(this.stateStorage + ' is not a valid value for the state storage, supported values are "local" and "session".');
      }
    },
    saveState: function saveState2() {
      var storage = this.getStorage();
      var state = {};
      if (this.paginator) {
        state.first = this.d_first;
        state.rows = this.d_rows;
      }
      if (this.d_sortField) {
        state.sortField = this.d_sortField;
        state.sortOrder = this.d_sortOrder;
      }
      if (this.d_multiSortMeta) {
        state.multiSortMeta = this.d_multiSortMeta;
      }
      if (this.hasFilters) {
        state.filters = this.filters;
      }
      if (this.resizableColumns) {
        this.saveColumnWidths(state);
      }
      if (this.reorderableColumns) {
        state.columnOrder = this.d_columnOrder;
      }
      if (this.expandedRows) {
        state.expandedRows = this.expandedRows;
      }
      if (this.expandedRowGroups) {
        state.expandedRowGroups = this.expandedRowGroups;
      }
      if (this.selection) {
        state.selection = this.selection;
        state.selectionKeys = this.d_selectionKeys;
      }
      if (Object.keys(state).length) {
        storage.setItem(this.stateKey, JSON.stringify(state));
      }
      this.$emit("state-save", state);
    },
    restoreState: function restoreState2() {
      var storage = this.getStorage();
      var stateString = storage.getItem(this.stateKey);
      var dateFormat = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;
      var reviver = function reviver2(key, value3) {
        if (typeof value3 === "string" && dateFormat.test(value3)) {
          return new Date(value3);
        }
        return value3;
      };
      if (stateString) {
        var restoredState = JSON.parse(stateString, reviver);
        if (this.paginator) {
          this.d_first = restoredState.first;
          this.d_rows = restoredState.rows;
        }
        if (restoredState.sortField) {
          this.d_sortField = restoredState.sortField;
          this.d_sortOrder = restoredState.sortOrder;
        }
        if (restoredState.multiSortMeta) {
          this.d_multiSortMeta = restoredState.multiSortMeta;
        }
        if (restoredState.filters) {
          this.$emit("update:filters", restoredState.filters);
        }
        if (this.resizableColumns) {
          this.columnWidthsState = restoredState.columnWidths;
          this.tableWidthState = restoredState.tableWidth;
        }
        if (this.reorderableColumns) {
          this.d_columnOrder = restoredState.columnOrder;
        }
        if (restoredState.expandedRows) {
          this.$emit("update:expandedRows", restoredState.expandedRows);
        }
        if (restoredState.expandedRowGroups) {
          this.$emit("update:expandedRowGroups", restoredState.expandedRowGroups);
        }
        if (restoredState.selection) {
          this.d_selectionKeys = restoredState.d_selectionKeys;
          this.$emit("update:selection", restoredState.selection);
        }
        this.$emit("state-restore", restoredState);
      }
    },
    saveColumnWidths: function saveColumnWidths(state) {
      var widths = [];
      var headers = find(this.$el, 'thead[data-pc-section="thead"] > tr > th');
      headers.forEach(function(header) {
        return widths.push(getOuterWidth(header));
      });
      state.columnWidths = widths.join(",");
      if (this.columnResizeMode === "expand") {
        state.tableWidth = getOuterWidth(this.$refs.table) + "px";
      }
    },
    addColumnWidthStyles: function addColumnWidthStyles(widths) {
      this.createStyleElement();
      var innerHTML = "";
      var selector = '[data-pc-name="datatable"]['.concat(this.attributeSelector, '] > [data-pc-section="tablecontainer"] ').concat(this.virtualScrollerDisabled ? "" : '> [data-pc-name="virtualscroller"]', ' > table[data-pc-section="table"]');
      widths.forEach(function(width2, index2) {
        var style = "width: ".concat(width2, "px !important; max-width: ").concat(width2, "px !important");
        innerHTML += "\n        ".concat(selector, ' > thead[data-pc-section="thead"] > tr > th:nth-child(').concat(index2 + 1, "),\n        ").concat(selector, ' > tbody[data-pc-section="tbody"] > tr > td:nth-child(').concat(index2 + 1, "),\n        ").concat(selector, ' > tfoot[data-pc-section="tfoot"] > tr > td:nth-child(').concat(index2 + 1, ") {\n            ").concat(style, "\n        }\n    ");
      });
      this.styleElement.innerHTML = innerHTML;
    },
    restoreColumnWidths: function restoreColumnWidths() {
      if (this.columnWidthsState) {
        var widths = this.columnWidthsState.split(",");
        if (this.columnResizeMode === "expand" && this.tableWidthState) {
          this.$refs.table.style.width = this.tableWidthState;
          this.$refs.table.style.minWidth = this.tableWidthState;
        }
        if (isNotEmpty(widths)) {
          this.addColumnWidthStyles(widths);
        }
      }
    },
    onCellEditInit: function onCellEditInit2(event2) {
      this.$emit("cell-edit-init", event2);
    },
    onCellEditComplete: function onCellEditComplete2(event2) {
      this.$emit("cell-edit-complete", event2);
    },
    onCellEditCancel: function onCellEditCancel2(event2) {
      this.$emit("cell-edit-cancel", event2);
    },
    onRowEditInit: function onRowEditInit3(event2) {
      var _editingRows = this.editingRows ? _toConsumableArray$3(this.editingRows) : [];
      _editingRows.push(event2.data);
      this.$emit("update:editingRows", _editingRows);
      this.$emit("row-edit-init", event2);
    },
    onRowEditSave: function onRowEditSave3(event2) {
      var _editingRows = _toConsumableArray$3(this.editingRows);
      _editingRows.splice(this.findIndex(event2.data, _editingRows), 1);
      this.$emit("update:editingRows", _editingRows);
      this.$emit("row-edit-save", event2);
    },
    onRowEditCancel: function onRowEditCancel3(event2) {
      var _editingRows = _toConsumableArray$3(this.editingRows);
      _editingRows.splice(this.findIndex(event2.data, _editingRows), 1);
      this.$emit("update:editingRows", _editingRows);
      this.$emit("row-edit-cancel", event2);
    },
    onEditingMetaChange: function onEditingMetaChange2(event2) {
      var data28 = event2.data, field2 = event2.field, index2 = event2.index, editing2 = event2.editing;
      var editingMeta = _objectSpread$1$2({}, this.d_editingMeta);
      var meta = editingMeta[index2];
      if (editing2) {
        !meta && (meta = editingMeta[index2] = {
          data: _objectSpread$1$2({}, data28),
          fields: []
        });
        meta["fields"].push(field2);
      } else if (meta) {
        var fields = meta["fields"].filter(function(f) {
          return f !== field2;
        });
        !fields.length ? delete editingMeta[index2] : meta["fields"] = fields;
      }
      this.d_editingMeta = editingMeta;
    },
    clearEditingMetaData: function clearEditingMetaData() {
      if (this.editMode) {
        this.d_editingMeta = {};
      }
    },
    createLazyLoadEvent: function createLazyLoadEvent(event2) {
      return {
        originalEvent: event2,
        first: this.d_first,
        rows: this.d_rows,
        sortField: this.d_sortField,
        sortOrder: this.d_sortOrder,
        multiSortMeta: this.d_multiSortMeta,
        filters: this.d_filters
      };
    },
    hasGlobalFilter: function hasGlobalFilter() {
      return this.filters && Object.prototype.hasOwnProperty.call(this.filters, "global");
    },
    onFilterChange: function onFilterChange3(filters) {
      this.d_filters = filters;
    },
    onFilterApply: function onFilterApply() {
      this.d_first = 0;
      this.$emit("update:first", this.d_first);
      this.$emit("update:filters", this.d_filters);
      if (this.lazy) {
        this.$emit("filter", this.createLazyLoadEvent());
      }
    },
    cloneFilters: function cloneFilters() {
      var cloned = {};
      if (this.filters) {
        Object.entries(this.filters).forEach(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), prop2 = _ref4[0], value3 = _ref4[1];
          cloned[prop2] = value3.operator ? {
            operator: value3.operator,
            constraints: value3.constraints.map(function(constraint) {
              return _objectSpread$1$2({}, constraint);
            })
          } : _objectSpread$1$2({}, value3);
        });
      }
      return cloned;
    },
    updateReorderableColumns: function updateReorderableColumns() {
      var _this10 = this;
      var columnOrder = [];
      this.columns.forEach(function(col) {
        return columnOrder.push(_this10.columnProp(col, "columnKey") || _this10.columnProp(col, "field"));
      });
      this.d_columnOrder = columnOrder;
    },
    createStyleElement: function createStyleElement() {
      var _this$$primevue;
      this.styleElement = document.createElement("style");
      this.styleElement.type = "text/css";
      setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
      document.head.appendChild(this.styleElement);
    },
    destroyStyleElement: function destroyStyleElement() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    },
    dataToRender: function dataToRender(data28) {
      var _data = data28 || this.processedData;
      if (_data && this.paginator) {
        var first4 = this.lazy ? 0 : this.d_first;
        return _data.slice(first4, first4 + this.d_rows);
      }
      return _data;
    },
    getVirtualScrollerRef: function getVirtualScrollerRef() {
      return this.$refs.virtualScroller;
    },
    hasSpacerStyle: function hasSpacerStyle(style) {
      return isNotEmpty(style);
    }
  },
  computed: {
    columns: function columns() {
      var cols = this.d_columns.get(this);
      if (this.reorderableColumns && this.d_columnOrder) {
        var orderedColumns = [];
        var _iterator5 = _createForOfIteratorHelper$3(this.d_columnOrder), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var columnKey = _step5.value;
            var column = this.findColumnByKey(cols, columnKey);
            if (column && !this.columnProp(column, "hidden")) {
              orderedColumns.push(column);
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        return [].concat(orderedColumns, _toConsumableArray$3(cols.filter(function(item) {
          return orderedColumns.indexOf(item) < 0;
        })));
      }
      return cols;
    },
    columnGroups: function columnGroups() {
      return this.d_columnGroups.get(this);
    },
    headerColumnGroup: function headerColumnGroup() {
      var _this$columnGroups, _this11 = this;
      return (_this$columnGroups = this.columnGroups) === null || _this$columnGroups === void 0 ? void 0 : _this$columnGroups.find(function(group) {
        return _this11.columnProp(group, "type") === "header";
      });
    },
    footerColumnGroup: function footerColumnGroup() {
      var _this$columnGroups2, _this12 = this;
      return (_this$columnGroups2 = this.columnGroups) === null || _this$columnGroups2 === void 0 ? void 0 : _this$columnGroups2.find(function(group) {
        return _this12.columnProp(group, "type") === "footer";
      });
    },
    hasFilters: function hasFilters() {
      return this.filters && Object.keys(this.filters).length > 0 && this.filters.constructor === Object;
    },
    processedData: function processedData() {
      var _this$virtualScroller;
      var data28 = this.value || [];
      if (!this.lazy && !((_this$virtualScroller = this.virtualScrollerOptions) !== null && _this$virtualScroller !== void 0 && _this$virtualScroller.lazy)) {
        if (data28 && data28.length) {
          if (this.hasFilters) {
            data28 = this.filter(data28);
          }
          if (this.sorted) {
            if (this.sortMode === "single") data28 = this.sortSingle(data28);
            else if (this.sortMode === "multiple") data28 = this.sortMultiple(data28);
          }
        }
      }
      return data28;
    },
    totalRecordsLength: function totalRecordsLength() {
      if (this.lazy) {
        return this.totalRecords;
      } else {
        var data28 = this.processedData;
        return data28 ? data28.length : 0;
      }
    },
    empty: function empty2() {
      var data28 = this.processedData;
      return !data28 || data28.length === 0;
    },
    paginatorTop: function paginatorTop() {
      return this.paginator && (this.paginatorPosition !== "bottom" || this.paginatorPosition === "both");
    },
    paginatorBottom: function paginatorBottom() {
      return this.paginator && (this.paginatorPosition !== "top" || this.paginatorPosition === "both");
    },
    sorted: function sorted() {
      return this.d_sortField || this.d_multiSortMeta && this.d_multiSortMeta.length > 0;
    },
    allRowsSelected: function allRowsSelected() {
      var _this13 = this;
      if (this.selectAll !== null) {
        return this.selectAll;
      } else {
        var val = this.frozenValue ? [].concat(_toConsumableArray$3(this.frozenValue), _toConsumableArray$3(this.processedData)) : this.processedData;
        return isNotEmpty(val) && this.selection && Array.isArray(this.selection) && val.every(function(v2) {
          return _this13.selection.some(function(s) {
            return _this13.equals(s, v2);
          });
        });
      }
    },
    attributeSelector: function attributeSelector3() {
      return UniqueComponentId();
    },
    groupRowSortField: function groupRowSortField() {
      return this.sortMode === "single" ? this.sortField : this.d_groupRowsSortMeta ? this.d_groupRowsSortMeta.field : null;
    },
    headerFilterButtonProps: function headerFilterButtonProps() {
      return _objectSpread$1$2(_objectSpread$1$2({
        filter: {
          severity: "secondary",
          text: true,
          rounded: true
        }
      }, this.filterButtonProps), {}, {
        inline: _objectSpread$1$2({
          clear: {
            severity: "secondary",
            text: true,
            rounded: true
          }
        }, this.filterButtonProps.inline),
        popover: _objectSpread$1$2({
          addRule: {
            severity: "info",
            text: true,
            size: "small"
          },
          removeRule: {
            severity: "danger",
            text: true,
            size: "small"
          },
          apply: {
            size: "small"
          },
          clear: {
            outlined: true,
            size: "small"
          }
        }, this.filterButtonProps.popover)
      });
    },
    rowEditButtonProps: function rowEditButtonProps() {
      return _objectSpread$1$2(_objectSpread$1$2({}, {
        init: {
          severity: "secondary",
          text: true,
          rounded: true
        },
        save: {
          severity: "secondary",
          text: true,
          rounded: true
        },
        cancel: {
          severity: "secondary",
          text: true,
          rounded: true
        }
      }), this.editButtonProps);
    },
    virtualScrollerDisabled: function virtualScrollerDisabled4() {
      return isEmpty(this.virtualScrollerOptions) || !this.scrollable;
    }
  },
  components: {
    DTPaginator: script$r,
    DTTableHeader: script$1$5,
    DTTableBody: script$7$1,
    DTTableFooter: script$5$1,
    DTVirtualScroller: script$Y,
    ArrowDownIcon: script$x,
    ArrowUpIcon: script$w,
    SpinnerIcon: script$14
  }
};
function _typeof$b(o) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$b(o);
}
function ownKeys$b(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$b(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$b(Object(t), true).forEach(function(r2) {
      _defineProperty$b(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$b(e, r, t) {
  return (r = _toPropertyKey$b(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$b(t) {
  var i2 = _toPrimitive$b(t, "string");
  return "symbol" == _typeof$b(i2) ? i2 : i2 + "";
}
function _toPrimitive$b(t, r) {
  if ("object" != _typeof$b(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$b(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_DTPaginator = resolveComponent("DTPaginator");
  var _component_DTTableHeader = resolveComponent("DTTableHeader");
  var _component_DTTableBody = resolveComponent("DTTableBody");
  var _component_DTTableFooter = resolveComponent("DTTableFooter");
  var _component_DTVirtualScroller = resolveComponent("DTVirtualScroller");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    "data-scrollselectors": ".p-datatable-wrapper"
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default"), _ctx.loading ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("mask")
  }, _ctx.ptm("mask")), [_ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", {
    key: 0
  }) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [_ctx.$slots.loadingicon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.loadingicon), {
    key: 0,
    "class": normalizeClass(_ctx.cx("loadingIcon"))
  }, null, 8, ["class"])) : _ctx.loadingIcon ? (openBlock(), createElementBlock("i", mergeProps({
    key: 1,
    "class": [_ctx.cx("loadingIcon"), "pi-spin", _ctx.loadingIcon]
  }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
    key: 2,
    spin: "",
    "class": _ctx.cx("loadingIcon")
  }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))], 64))], 16)) : createCommentVNode("", true), _ctx.$slots.header ? (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": _ctx.cx("header")
  }, _ctx.ptm("header")), [renderSlot(_ctx.$slots, "header")], 16)) : createCommentVNode("", true), $options.paginatorTop ? (openBlock(), createBlock(_component_DTPaginator, {
    key: 2,
    rows: $data.d_rows,
    first: $data.d_first,
    totalRecords: $options.totalRecordsLength,
    pageLinkSize: _ctx.pageLinkSize,
    template: _ctx.paginatorTemplate,
    rowsPerPageOptions: _ctx.rowsPerPageOptions,
    currentPageReportTemplate: _ctx.currentPageReportTemplate,
    "class": normalizeClass(_ctx.cx("pcPaginator", {
      position: "top"
    })),
    onPage: _cache[0] || (_cache[0] = function($event) {
      return $options.onPage($event);
    }),
    alwaysShow: _ctx.alwaysShowPaginator,
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcPaginator")
  }, createSlots({
    _: 2
  }, [_ctx.$slots.paginatorstart ? {
    name: "start",
    fn: withCtx(function() {
      return [renderSlot(_ctx.$slots, "paginatorstart")];
    }),
    key: "0"
  } : void 0, _ctx.$slots.paginatorend ? {
    name: "end",
    fn: withCtx(function() {
      return [renderSlot(_ctx.$slots, "paginatorend")];
    }),
    key: "1"
  } : void 0, _ctx.$slots.paginatorfirstpagelinkicon ? {
    name: "firstpagelinkicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorfirstpagelinkicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "2"
  } : void 0, _ctx.$slots.paginatorprevpagelinkicon ? {
    name: "prevpagelinkicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorprevpagelinkicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "3"
  } : void 0, _ctx.$slots.paginatornextpagelinkicon ? {
    name: "nextpagelinkicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatornextpagelinkicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "4"
  } : void 0, _ctx.$slots.paginatorlastpagelinkicon ? {
    name: "lastpagelinkicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorlastpagelinkicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "5"
  } : void 0, _ctx.$slots.paginatorjumptopagedropdownicon ? {
    name: "jumptopagedropdownicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorjumptopagedropdownicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "6"
  } : void 0, _ctx.$slots.paginatorrowsperpagedropdownicon ? {
    name: "rowsperpagedropdownicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorrowsperpagedropdownicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "7"
  } : void 0]), 1032, ["rows", "first", "totalRecords", "pageLinkSize", "template", "rowsPerPageOptions", "currentPageReportTemplate", "class", "alwaysShow", "unstyled", "pt"])) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("tableContainer"),
    style: [_ctx.sx("tableContainer"), {
      maxHeight: $options.virtualScrollerDisabled ? _ctx.scrollHeight : ""
    }]
  }, _ctx.ptm("tableContainer")), [createVNode(_component_DTVirtualScroller, mergeProps({
    ref: "virtualScroller"
  }, _ctx.virtualScrollerOptions, {
    items: $options.processedData,
    columns: $options.columns,
    style: _ctx.scrollHeight !== "flex" ? {
      height: _ctx.scrollHeight
    } : void 0,
    scrollHeight: _ctx.scrollHeight !== "flex" ? void 0 : "100%",
    disabled: $options.virtualScrollerDisabled,
    loaderDisabled: "",
    inline: "",
    autoSize: "",
    showSpacer: false,
    pt: _ctx.ptm("virtualScroller")
  }), {
    content: withCtx(function(slotProps) {
      return [createBaseVNode("table", mergeProps({
        ref: "table",
        role: "table",
        "class": [_ctx.cx("table"), _ctx.tableClass],
        style: [_ctx.tableStyle, slotProps.spacerStyle]
      }, _objectSpread$b(_objectSpread$b({}, _ctx.tableProps), _ctx.ptm("table"))), [createVNode(_component_DTTableHeader, {
        columnGroup: $options.headerColumnGroup,
        columns: slotProps.columns,
        rowGroupMode: _ctx.rowGroupMode,
        groupRowsBy: _ctx.groupRowsBy,
        groupRowSortField: $options.groupRowSortField,
        reorderableColumns: _ctx.reorderableColumns,
        resizableColumns: _ctx.resizableColumns,
        allRowsSelected: $options.allRowsSelected,
        empty: $options.empty,
        sortMode: _ctx.sortMode,
        sortField: $data.d_sortField,
        sortOrder: $data.d_sortOrder,
        multiSortMeta: $data.d_multiSortMeta,
        filters: $data.d_filters,
        filtersStore: _ctx.filters,
        filterDisplay: _ctx.filterDisplay,
        filterButtonProps: $options.headerFilterButtonProps,
        filterInputProps: _ctx.filterInputProps,
        first: $data.d_first,
        onColumnClick: _cache[1] || (_cache[1] = function($event) {
          return $options.onColumnHeaderClick($event);
        }),
        onColumnMousedown: _cache[2] || (_cache[2] = function($event) {
          return $options.onColumnHeaderMouseDown($event);
        }),
        onFilterChange: $options.onFilterChange,
        onFilterApply: $options.onFilterApply,
        onColumnDragstart: _cache[3] || (_cache[3] = function($event) {
          return $options.onColumnHeaderDragStart($event);
        }),
        onColumnDragover: _cache[4] || (_cache[4] = function($event) {
          return $options.onColumnHeaderDragOver($event);
        }),
        onColumnDragleave: _cache[5] || (_cache[5] = function($event) {
          return $options.onColumnHeaderDragLeave($event);
        }),
        onColumnDrop: _cache[6] || (_cache[6] = function($event) {
          return $options.onColumnHeaderDrop($event);
        }),
        onColumnResizestart: _cache[7] || (_cache[7] = function($event) {
          return $options.onColumnResizeStart($event);
        }),
        onCheckboxChange: _cache[8] || (_cache[8] = function($event) {
          return $options.toggleRowsWithCheckbox($event);
        }),
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["columnGroup", "columns", "rowGroupMode", "groupRowsBy", "groupRowSortField", "reorderableColumns", "resizableColumns", "allRowsSelected", "empty", "sortMode", "sortField", "sortOrder", "multiSortMeta", "filters", "filtersStore", "filterDisplay", "filterButtonProps", "filterInputProps", "first", "onFilterChange", "onFilterApply", "unstyled", "pt"]), _ctx.frozenValue ? (openBlock(), createBlock(_component_DTTableBody, {
        key: 0,
        ref: "frozenBodyRef",
        value: _ctx.frozenValue,
        frozenRow: true,
        columns: slotProps.columns,
        first: $data.d_first,
        dataKey: _ctx.dataKey,
        selection: _ctx.selection,
        selectionKeys: $data.d_selectionKeys,
        selectionMode: _ctx.selectionMode,
        contextMenu: _ctx.contextMenu,
        contextMenuSelection: _ctx.contextMenuSelection,
        rowGroupMode: _ctx.rowGroupMode,
        groupRowsBy: _ctx.groupRowsBy,
        expandableRowGroups: _ctx.expandableRowGroups,
        rowClass: _ctx.rowClass,
        rowStyle: _ctx.rowStyle,
        editMode: _ctx.editMode,
        compareSelectionBy: _ctx.compareSelectionBy,
        scrollable: _ctx.scrollable,
        expandedRowIcon: _ctx.expandedRowIcon,
        collapsedRowIcon: _ctx.collapsedRowIcon,
        expandedRows: _ctx.expandedRows,
        expandedRowGroups: _ctx.expandedRowGroups,
        editingRows: _ctx.editingRows,
        editingRowKeys: $data.d_editingRowKeys,
        templates: _ctx.$slots,
        editButtonProps: $options.rowEditButtonProps,
        isVirtualScrollerDisabled: true,
        onRowgroupToggle: $options.toggleRowGroup,
        onRowClick: _cache[9] || (_cache[9] = function($event) {
          return $options.onRowClick($event);
        }),
        onRowDblclick: _cache[10] || (_cache[10] = function($event) {
          return $options.onRowDblClick($event);
        }),
        onRowRightclick: _cache[11] || (_cache[11] = function($event) {
          return $options.onRowRightClick($event);
        }),
        onRowTouchend: $options.onRowTouchEnd,
        onRowKeydown: $options.onRowKeyDown,
        onRowMousedown: $options.onRowMouseDown,
        onRowDragstart: _cache[12] || (_cache[12] = function($event) {
          return $options.onRowDragStart($event);
        }),
        onRowDragover: _cache[13] || (_cache[13] = function($event) {
          return $options.onRowDragOver($event);
        }),
        onRowDragleave: _cache[14] || (_cache[14] = function($event) {
          return $options.onRowDragLeave($event);
        }),
        onRowDragend: _cache[15] || (_cache[15] = function($event) {
          return $options.onRowDragEnd($event);
        }),
        onRowDrop: _cache[16] || (_cache[16] = function($event) {
          return $options.onRowDrop($event);
        }),
        onRowToggle: _cache[17] || (_cache[17] = function($event) {
          return $options.toggleRow($event);
        }),
        onRadioChange: _cache[18] || (_cache[18] = function($event) {
          return $options.toggleRowWithRadio($event);
        }),
        onCheckboxChange: _cache[19] || (_cache[19] = function($event) {
          return $options.toggleRowWithCheckbox($event);
        }),
        onCellEditInit: _cache[20] || (_cache[20] = function($event) {
          return $options.onCellEditInit($event);
        }),
        onCellEditComplete: _cache[21] || (_cache[21] = function($event) {
          return $options.onCellEditComplete($event);
        }),
        onCellEditCancel: _cache[22] || (_cache[22] = function($event) {
          return $options.onCellEditCancel($event);
        }),
        onRowEditInit: _cache[23] || (_cache[23] = function($event) {
          return $options.onRowEditInit($event);
        }),
        onRowEditSave: _cache[24] || (_cache[24] = function($event) {
          return $options.onRowEditSave($event);
        }),
        onRowEditCancel: _cache[25] || (_cache[25] = function($event) {
          return $options.onRowEditCancel($event);
        }),
        editingMeta: $data.d_editingMeta,
        onEditingMetaChange: $options.onEditingMetaChange,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["value", "columns", "first", "dataKey", "selection", "selectionKeys", "selectionMode", "contextMenu", "contextMenuSelection", "rowGroupMode", "groupRowsBy", "expandableRowGroups", "rowClass", "rowStyle", "editMode", "compareSelectionBy", "scrollable", "expandedRowIcon", "collapsedRowIcon", "expandedRows", "expandedRowGroups", "editingRows", "editingRowKeys", "templates", "editButtonProps", "onRowgroupToggle", "onRowTouchend", "onRowKeydown", "onRowMousedown", "editingMeta", "onEditingMetaChange", "unstyled", "pt"])) : createCommentVNode("", true), createVNode(_component_DTTableBody, {
        ref: "bodyRef",
        value: $options.dataToRender(slotProps.rows),
        "class": normalizeClass(slotProps.styleClass),
        columns: slotProps.columns,
        empty: $options.empty,
        first: $data.d_first,
        dataKey: _ctx.dataKey,
        selection: _ctx.selection,
        selectionKeys: $data.d_selectionKeys,
        selectionMode: _ctx.selectionMode,
        contextMenu: _ctx.contextMenu,
        contextMenuSelection: _ctx.contextMenuSelection,
        rowGroupMode: _ctx.rowGroupMode,
        groupRowsBy: _ctx.groupRowsBy,
        expandableRowGroups: _ctx.expandableRowGroups,
        rowClass: _ctx.rowClass,
        rowStyle: _ctx.rowStyle,
        editMode: _ctx.editMode,
        compareSelectionBy: _ctx.compareSelectionBy,
        scrollable: _ctx.scrollable,
        expandedRowIcon: _ctx.expandedRowIcon,
        collapsedRowIcon: _ctx.collapsedRowIcon,
        expandedRows: _ctx.expandedRows,
        expandedRowGroups: _ctx.expandedRowGroups,
        editingRows: _ctx.editingRows,
        editingRowKeys: $data.d_editingRowKeys,
        templates: _ctx.$slots,
        editButtonProps: $options.rowEditButtonProps,
        virtualScrollerContentProps: slotProps,
        isVirtualScrollerDisabled: $options.virtualScrollerDisabled,
        onRowgroupToggle: $options.toggleRowGroup,
        onRowClick: _cache[26] || (_cache[26] = function($event) {
          return $options.onRowClick($event);
        }),
        onRowDblclick: _cache[27] || (_cache[27] = function($event) {
          return $options.onRowDblClick($event);
        }),
        onRowRightclick: _cache[28] || (_cache[28] = function($event) {
          return $options.onRowRightClick($event);
        }),
        onRowTouchend: $options.onRowTouchEnd,
        onRowKeydown: function onRowKeydown($event) {
          return $options.onRowKeyDown($event, slotProps);
        },
        onRowMousedown: $options.onRowMouseDown,
        onRowDragstart: _cache[29] || (_cache[29] = function($event) {
          return $options.onRowDragStart($event);
        }),
        onRowDragover: _cache[30] || (_cache[30] = function($event) {
          return $options.onRowDragOver($event);
        }),
        onRowDragleave: _cache[31] || (_cache[31] = function($event) {
          return $options.onRowDragLeave($event);
        }),
        onRowDragend: _cache[32] || (_cache[32] = function($event) {
          return $options.onRowDragEnd($event);
        }),
        onRowDrop: _cache[33] || (_cache[33] = function($event) {
          return $options.onRowDrop($event);
        }),
        onRowToggle: _cache[34] || (_cache[34] = function($event) {
          return $options.toggleRow($event);
        }),
        onRadioChange: _cache[35] || (_cache[35] = function($event) {
          return $options.toggleRowWithRadio($event);
        }),
        onCheckboxChange: _cache[36] || (_cache[36] = function($event) {
          return $options.toggleRowWithCheckbox($event);
        }),
        onCellEditInit: _cache[37] || (_cache[37] = function($event) {
          return $options.onCellEditInit($event);
        }),
        onCellEditComplete: _cache[38] || (_cache[38] = function($event) {
          return $options.onCellEditComplete($event);
        }),
        onCellEditCancel: _cache[39] || (_cache[39] = function($event) {
          return $options.onCellEditCancel($event);
        }),
        onRowEditInit: _cache[40] || (_cache[40] = function($event) {
          return $options.onRowEditInit($event);
        }),
        onRowEditSave: _cache[41] || (_cache[41] = function($event) {
          return $options.onRowEditSave($event);
        }),
        onRowEditCancel: _cache[42] || (_cache[42] = function($event) {
          return $options.onRowEditCancel($event);
        }),
        editingMeta: $data.d_editingMeta,
        onEditingMetaChange: $options.onEditingMetaChange,
        unstyled: _ctx.unstyled,
        pt: _ctx.pt
      }, null, 8, ["value", "class", "columns", "empty", "first", "dataKey", "selection", "selectionKeys", "selectionMode", "contextMenu", "contextMenuSelection", "rowGroupMode", "groupRowsBy", "expandableRowGroups", "rowClass", "rowStyle", "editMode", "compareSelectionBy", "scrollable", "expandedRowIcon", "collapsedRowIcon", "expandedRows", "expandedRowGroups", "editingRows", "editingRowKeys", "templates", "editButtonProps", "virtualScrollerContentProps", "isVirtualScrollerDisabled", "onRowgroupToggle", "onRowTouchend", "onRowKeydown", "onRowMousedown", "editingMeta", "onEditingMetaChange", "unstyled", "pt"]), $options.hasSpacerStyle(slotProps.spacerStyle) ? (openBlock(), createElementBlock("tbody", mergeProps({
        key: 1,
        "class": _ctx.cx("virtualScrollerSpacer"),
        style: {
          height: "calc(".concat(slotProps.spacerStyle.height, " - ").concat(slotProps.rows.length * slotProps.itemSize, "px)")
        }
      }, _ctx.ptm("virtualScrollerSpacer")), null, 16)) : createCommentVNode("", true), createVNode(_component_DTTableFooter, {
        columnGroup: $options.footerColumnGroup,
        columns: slotProps.columns,
        pt: _ctx.pt
      }, null, 8, ["columnGroup", "columns", "pt"])], 16)];
    }),
    _: 1
  }, 16, ["items", "columns", "style", "scrollHeight", "disabled", "pt"])], 16), $options.paginatorBottom ? (openBlock(), createBlock(_component_DTPaginator, {
    key: 3,
    rows: $data.d_rows,
    first: $data.d_first,
    totalRecords: $options.totalRecordsLength,
    pageLinkSize: _ctx.pageLinkSize,
    template: _ctx.paginatorTemplate,
    rowsPerPageOptions: _ctx.rowsPerPageOptions,
    currentPageReportTemplate: _ctx.currentPageReportTemplate,
    "class": normalizeClass(_ctx.cx("pcPaginator", {
      position: "bottom"
    })),
    onPage: _cache[43] || (_cache[43] = function($event) {
      return $options.onPage($event);
    }),
    alwaysShow: _ctx.alwaysShowPaginator,
    unstyled: _ctx.unstyled,
    pt: _ctx.ptm("pcPaginator")
  }, createSlots({
    _: 2
  }, [_ctx.$slots.paginatorstart ? {
    name: "start",
    fn: withCtx(function() {
      return [renderSlot(_ctx.$slots, "paginatorstart")];
    }),
    key: "0"
  } : void 0, _ctx.$slots.paginatorend ? {
    name: "end",
    fn: withCtx(function() {
      return [renderSlot(_ctx.$slots, "paginatorend")];
    }),
    key: "1"
  } : void 0, _ctx.$slots.paginatorfirstpagelinkicon ? {
    name: "firstpagelinkicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorfirstpagelinkicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "2"
  } : void 0, _ctx.$slots.paginatorprevpagelinkicon ? {
    name: "prevpagelinkicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorprevpagelinkicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "3"
  } : void 0, _ctx.$slots.paginatornextpagelinkicon ? {
    name: "nextpagelinkicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatornextpagelinkicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "4"
  } : void 0, _ctx.$slots.paginatorlastpagelinkicon ? {
    name: "lastpagelinkicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorlastpagelinkicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "5"
  } : void 0, _ctx.$slots.paginatorjumptopagedropdownicon ? {
    name: "jumptopagedropdownicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorjumptopagedropdownicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "6"
  } : void 0, _ctx.$slots.paginatorrowsperpagedropdownicon ? {
    name: "rowsperpagedropdownicon",
    fn: withCtx(function(slotProps) {
      return [renderSlot(_ctx.$slots, "paginatorrowsperpagedropdownicon", {
        "class": normalizeClass(slotProps["class"])
      })];
    }),
    key: "7"
  } : void 0]), 1032, ["rows", "first", "totalRecords", "pageLinkSize", "template", "rowsPerPageOptions", "currentPageReportTemplate", "class", "alwaysShow", "unstyled", "pt"])) : createCommentVNode("", true), _ctx.$slots.footer ? (openBlock(), createElementBlock("div", mergeProps({
    key: 4,
    "class": _ctx.cx("footer")
  }, _ctx.ptm("footer")), [renderSlot(_ctx.$slots, "footer")], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    ref: "resizeHelper",
    "class": _ctx.cx("columnResizeIndicator"),
    style: {
      "display": "none"
    }
  }, _ctx.ptm("columnResizeIndicator")), null, 16), _ctx.reorderableColumns ? (openBlock(), createElementBlock("span", mergeProps({
    key: 5,
    ref: "reorderIndicatorUp",
    "class": _ctx.cx("rowReorderIndicatorUp"),
    style: {
      "position": "absolute",
      "display": "none"
    }
  }, _ctx.ptm("rowReorderIndicatorUp")), [(openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.rowreorderindicatorupicon || _ctx.$slots.reorderindicatorupicon || "ArrowDownIcon")))], 16)) : createCommentVNode("", true), _ctx.reorderableColumns ? (openBlock(), createElementBlock("span", mergeProps({
    key: 6,
    ref: "reorderIndicatorDown",
    "class": _ctx.cx("rowReorderIndicatorDown"),
    style: {
      "position": "absolute",
      "display": "none"
    }
  }, _ctx.ptm("rowReorderIndicatorDown")), [(openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.rowreorderindicatordownicon || _ctx.$slots.reorderindicatordownicon || "ArrowUpIcon")))], 16)) : createCommentVNode("", true)], 16);
}
script$d.render = render$c;
var ColumnStyle = BaseStyle.extend({
  name: "column"
});
var script$1$4 = {
  name: "BaseColumn",
  "extends": script$1a,
  props: {
    columnKey: {
      type: null,
      "default": null
    },
    field: {
      type: [String, Function],
      "default": null
    },
    sortField: {
      type: [String, Function],
      "default": null
    },
    filterField: {
      type: [String, Function],
      "default": null
    },
    dataType: {
      type: String,
      "default": "text"
    },
    sortable: {
      type: Boolean,
      "default": false
    },
    header: {
      type: null,
      "default": null
    },
    footer: {
      type: null,
      "default": null
    },
    style: {
      type: null,
      "default": null
    },
    "class": {
      type: String,
      "default": null
    },
    headerStyle: {
      type: null,
      "default": null
    },
    headerClass: {
      type: String,
      "default": null
    },
    bodyStyle: {
      type: null,
      "default": null
    },
    bodyClass: {
      type: String,
      "default": null
    },
    footerStyle: {
      type: null,
      "default": null
    },
    footerClass: {
      type: String,
      "default": null
    },
    showFilterMenu: {
      type: Boolean,
      "default": true
    },
    showFilterOperator: {
      type: Boolean,
      "default": true
    },
    showClearButton: {
      type: Boolean,
      "default": true
    },
    showApplyButton: {
      type: Boolean,
      "default": true
    },
    showFilterMatchModes: {
      type: Boolean,
      "default": true
    },
    showAddButton: {
      type: Boolean,
      "default": true
    },
    filterMatchModeOptions: {
      type: Array,
      "default": null
    },
    maxConstraints: {
      type: Number,
      "default": 2
    },
    excludeGlobalFilter: {
      type: Boolean,
      "default": false
    },
    filterHeaderClass: {
      type: String,
      "default": null
    },
    filterHeaderStyle: {
      type: null,
      "default": null
    },
    filterMenuClass: {
      type: String,
      "default": null
    },
    filterMenuStyle: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    expander: {
      type: Boolean,
      "default": false
    },
    colspan: {
      type: Number,
      "default": null
    },
    rowspan: {
      type: Number,
      "default": null
    },
    rowReorder: {
      type: Boolean,
      "default": false
    },
    rowReorderIcon: {
      type: String,
      "default": void 0
    },
    reorderableColumn: {
      type: Boolean,
      "default": true
    },
    rowEditor: {
      type: Boolean,
      "default": false
    },
    frozen: {
      type: Boolean,
      "default": false
    },
    alignFrozen: {
      type: String,
      "default": "left"
    },
    exportable: {
      type: Boolean,
      "default": true
    },
    exportHeader: {
      type: String,
      "default": null
    },
    exportFooter: {
      type: String,
      "default": null
    },
    filterMatchMode: {
      type: String,
      "default": null
    },
    hidden: {
      type: Boolean,
      "default": false
    }
  },
  style: ColumnStyle,
  provide: function provide38() {
    return {
      $pcColumn: this,
      $parentInstance: this
    };
  }
};
var script$8 = {
  name: "Column",
  "extends": script$1$4,
  inheritAttrs: false,
  inject: ["$columns"],
  mounted: function mounted19() {
    var _this$$columns;
    (_this$$columns = this.$columns) === null || _this$$columns === void 0 || _this$$columns.add(this.$);
  },
  unmounted: function unmounted6() {
    var _this$$columns2;
    (_this$$columns2 = this.$columns) === null || _this$$columns2 === void 0 || _this$$columns2["delete"](this.$);
  },
  render: function render2() {
    return null;
  }
};
var theme$3 = function theme32(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-confirmpopup {\n    position: absolute;\n    margin-top: ".concat(dt3("confirmpopup.gutter"), ";\n    top: 0;\n    left: 0;\n    background: ").concat(dt3("confirmpopup.background"), ";\n    color: ").concat(dt3("confirmpopup.color"), ";\n    border: 1px solid ").concat(dt3("confirmpopup.border.color"), ";\n    border-radius: ").concat(dt3("confirmpopup.border.radius"), ";\n    box-shadow: ").concat(dt3("confirmpopup.shadow"), ";\n}\n\n.p-confirmpopup-content {\n    display: flex;\n    align-items: center;\n    padding: ").concat(dt3("confirmpopup.content.padding"), ";\n    gap: ").concat(dt3("confirmpopup.content.gap"), ";\n}\n\n.p-confirmpopup-icon {\n    font-size: ").concat(dt3("confirmpopup.icon.size"), ";\n    width: ").concat(dt3("confirmpopup.icon.size"), ";\n    height: ").concat(dt3("confirmpopup.icon.size"), ";\n    color: ").concat(dt3("confirmpopup.icon.color"), ";\n}\n\n.p-confirmpopup-footer {\n    display: flex;\n    justify-content: flex-end;\n    gap: ").concat(dt3("confirmpopup.footer.gap"), ";\n    padding: ").concat(dt3("confirmpopup.footer.padding"), ";\n}\n\n.p-confirmpopup-footer button {\n    width: auto;\n}\n\n.p-confirmpopup-footer button:last-child {\n    margin: 0;\n}\n\n.p-confirmpopup-flipped {\n    margin-top: calc(").concat(dt3("confirmpopup.gutter"), " * -1);\n    margin-bottom: ").concat(dt3("confirmpopup.gutter"), ";\n}\n\n.p-confirmpopup-enter-from {\n    opacity: 0;\n    transform: scaleY(0.8);\n}\n\n.p-confirmpopup-leave-to {\n    opacity: 0;\n}\n\n.p-confirmpopup-enter-active {\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n\n.p-confirmpopup-leave-active {\n    transition: opacity 0.1s linear;\n}\n\n.p-confirmpopup:after,\n.p-confirmpopup:before {\n    bottom: 100%;\n    left: ").concat(dt3("confirmpopup.arrow.offset"), ';\n    content: " ";\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none;\n}\n\n.p-confirmpopup:after {\n    border-width: calc(').concat(dt3("confirmpopup.gutter"), " - 2px);\n    margin-left: calc(-1 * (").concat(dt3("confirmpopup.gutter"), " - 2px));\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt3("confirmpopup.background"), ";\n}\n\n.p-confirmpopup:before {\n    border-width: ").concat(dt3("confirmpopup.gutter"), ";\n    margin-left: calc(-1 * ").concat(dt3("confirmpopup.gutter"), ");\n    border-style: solid;\n    border-color: transparent;\n    border-bottom-color: ").concat(dt3("confirmpopup.border.color"), ";\n}\n\n.p-confirmpopup-flipped:after,\n.p-confirmpopup-flipped:before {\n    bottom: auto;\n    top: 100%;\n}\n\n.p-confirmpopup-flipped:after {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt3("confirmpopup.background"), ";\n}\n\n.p-confirmpopup-flipped:before {\n    border-bottom-color: transparent;\n    border-top-color: ").concat(dt3("confirmpopup.border.color"), ";\n}\n");
};
var classes$3 = {
  root: "p-confirmpopup p-component",
  content: "p-confirmpopup-content",
  icon: "p-confirmpopup-icon",
  message: "p-confirmpopup-message",
  footer: "p-confirmpopup-footer",
  pcRejectButton: "p-confirmpopup-reject-button",
  pcAcceptButton: "p-confirmpopup-accept-button"
};
var ConfirmPopupStyle = BaseStyle.extend({
  name: "confirmpopup",
  theme: theme$3,
  classes: classes$3
});
var script$1$3 = {
  name: "BaseConfirmPopup",
  "extends": script$1a,
  props: {
    group: String
  },
  style: ConfirmPopupStyle,
  provide: function provide39() {
    return {
      $pcConfirmPopup: this,
      $parentInstance: this
    };
  }
};
var script$7 = {
  name: "ConfirmPopup",
  "extends": script$1$3,
  inheritAttrs: false,
  data: function data25() {
    return {
      visible: false,
      confirmation: null,
      autoFocusAccept: null,
      autoFocusReject: null
    };
  },
  target: null,
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  container: null,
  confirmListener: null,
  closeListener: null,
  mounted: function mounted20() {
    var _this = this;
    this.confirmListener = function(options3) {
      if (!options3) {
        return;
      }
      if (options3.group === _this.group) {
        _this.confirmation = options3;
        _this.target = options3.target;
        if (_this.confirmation.onShow) {
          _this.confirmation.onShow();
        }
        _this.visible = true;
      }
    };
    this.closeListener = function() {
      _this.visible = false;
      _this.confirmation = null;
    };
    ConfirmationEventBus.on("confirm", this.confirmListener);
    ConfirmationEventBus.on("close", this.closeListener);
  },
  beforeUnmount: function beforeUnmount12() {
    ConfirmationEventBus.off("confirm", this.confirmListener);
    ConfirmationEventBus.off("close", this.closeListener);
    this.unbindOutsideClickListener();
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    this.unbindResizeListener();
    if (this.container) {
      ZIndex.clear(this.container);
      this.container = null;
    }
    this.target = null;
    this.confirmation = null;
  },
  methods: {
    accept: function accept() {
      if (this.confirmation.accept) {
        this.confirmation.accept();
      }
      this.visible = false;
    },
    reject: function reject() {
      if (this.confirmation.reject) {
        this.confirmation.reject();
      }
      this.visible = false;
    },
    onHide: function onHide() {
      if (this.confirmation.onHide) {
        this.confirmation.onHide();
      }
      this.visible = false;
    },
    onAcceptKeydown: function onAcceptKeydown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.accept();
        focus(this.target);
        event2.preventDefault();
      }
    },
    onRejectKeydown: function onRejectKeydown(event2) {
      if (event2.code === "Space" || event2.code === "Enter" || event2.code === "NumpadEnter") {
        this.reject();
        focus(this.target);
        event2.preventDefault();
      }
    },
    onEnter: function onEnter2(el) {
      this.autoFocusAccept = this.confirmation.defaultFocus === void 0 || this.confirmation.defaultFocus === "accept" ? true : false;
      this.autoFocusReject = this.confirmation.defaultFocus === "reject" ? true : false;
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      ZIndex.set("overlay", el, this.$primevue.config.zIndex.overlay);
    },
    onAfterEnter: function onAfterEnter() {
      this.focus();
    },
    onLeave: function onLeave2() {
      this.autoFocusAccept = null;
      this.autoFocusReject = null;
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
    },
    onAfterLeave: function onAfterLeave2(el) {
      ZIndex.clear(el);
    },
    alignOverlay: function alignOverlay4() {
      absolutePosition(this.container, this.target, false);
      var containerOffset = getOffset(this.container);
      var targetOffset = getOffset(this.target);
      var arrowLeft = 0;
      if (containerOffset.left < targetOffset.left) {
        arrowLeft = targetOffset.left - containerOffset.left;
      }
      this.container.style.setProperty($dt("overlay.arrow.left").name, "".concat(arrowLeft, "px"));
      if (containerOffset.top < targetOffset.top) {
        this.container.setAttribute("data-p-confirmpopup-flipped", "true");
        !this.isUnstyled && addClass(this.container, "p-confirmpopup-flipped");
      }
    },
    bindOutsideClickListener: function bindOutsideClickListener4() {
      var _this2 = this;
      if (!this.outsideClickListener) {
        this.outsideClickListener = function(event2) {
          if (_this2.visible && _this2.container && !_this2.container.contains(event2.target) && !_this2.isTargetClicked(event2)) {
            if (_this2.confirmation.onHide) {
              _this2.confirmation.onHide();
            }
            _this2.visible = false;
          } else {
            _this2.alignOverlay();
          }
        };
        document.addEventListener("click", this.outsideClickListener);
      }
    },
    unbindOutsideClickListener: function unbindOutsideClickListener4() {
      if (this.outsideClickListener) {
        document.removeEventListener("click", this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },
    bindScrollListener: function bindScrollListener5() {
      var _this3 = this;
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, function() {
          if (_this3.visible) {
            _this3.visible = false;
          }
        });
      }
      this.scrollHandler.bindScrollListener();
    },
    unbindScrollListener: function unbindScrollListener5() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },
    bindResizeListener: function bindResizeListener5() {
      var _this4 = this;
      if (!this.resizeListener) {
        this.resizeListener = function() {
          if (_this4.visible && !isTouchDevice()) {
            _this4.visible = false;
          }
        };
        window.addEventListener("resize", this.resizeListener);
      }
    },
    unbindResizeListener: function unbindResizeListener5() {
      if (this.resizeListener) {
        window.removeEventListener("resize", this.resizeListener);
        this.resizeListener = null;
      }
    },
    focus: function focus2() {
      var focusTarget = this.container.querySelector("[autofocus]");
      if (focusTarget) {
        focusTarget.focus({
          preventScroll: true
        });
      }
    },
    isTargetClicked: function isTargetClicked2(event2) {
      return this.target && (this.target === event2.target || this.target.contains(event2.target));
    },
    containerRef: function containerRef2(el) {
      this.container = el;
    },
    onOverlayClick: function onOverlayClick3(event2) {
      OverlayEventBus.emit("overlay-click", {
        originalEvent: event2,
        target: this.target
      });
    },
    onOverlayKeydown: function onOverlayKeydown(event2) {
      if (event2.code === "Escape") {
        ConfirmationEventBus.emit("close", this.closeListener);
        focus(this.target);
      }
    },
    getCXOptions: function getCXOptions(icon2, iconProps) {
      return {
        contenxt: {
          icon: icon2,
          iconClass: iconProps["class"]
        }
      };
    }
  },
  computed: {
    message: function message() {
      return this.confirmation ? this.confirmation.message : null;
    },
    acceptLabel: function acceptLabel() {
      if (this.confirmation) {
        var confirmation = this.confirmation;
        return confirmation.acceptLabel ? confirmation.acceptLabel : confirmation.acceptProps ? confirmation.acceptProps.label || this.$primevue.config.locale.accept : null;
      }
      return null;
    },
    rejectLabel: function rejectLabel() {
      if (this.confirmation) {
        var confirmation = this.confirmation;
        return confirmation.rejectLabel ? confirmation.rejectLabel : confirmation.rejectProps ? confirmation.rejectProps.label || this.$primevue.config.locale.reject : null;
      }
      return null;
    },
    acceptIcon: function acceptIcon() {
      var _this$confirmation;
      return this.confirmation ? this.confirmation.acceptIcon : (_this$confirmation = this.confirmation) !== null && _this$confirmation !== void 0 && _this$confirmation.acceptProps ? this.confirmation.acceptProps.icon : null;
    },
    rejectIcon: function rejectIcon() {
      var _this$confirmation2;
      return this.confirmation ? this.confirmation.rejectIcon : (_this$confirmation2 = this.confirmation) !== null && _this$confirmation2 !== void 0 && _this$confirmation2.rejectProps ? this.confirmation.rejectProps.icon : null;
    }
  },
  components: {
    Button: script$13,
    Portal: script$N
  },
  directives: {
    focustrap: FocusTrap
  }
};
var _hoisted_1$9 = ["aria-modal"];
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Button = resolveComponent("Button");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, null, {
    "default": withCtx(function() {
      return [createVNode(Transition, mergeProps({
        name: "p-confirmpopup",
        onEnter: $options.onEnter,
        onAfterEnter: $options.onAfterEnter,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          var _$data$confirmation$r, _$data$confirmation$r2, _$data$confirmation$a;
          return [$data.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            role: "alertdialog",
            "class": _ctx.cx("root"),
            "aria-modal": $data.visible,
            onClick: _cache[2] || (_cache[2] = function() {
              return $options.onOverlayClick && $options.onOverlayClick.apply($options, arguments);
            }),
            onKeydown: _cache[3] || (_cache[3] = function() {
              return $options.onOverlayKeydown && $options.onOverlayKeydown.apply($options, arguments);
            })
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            message: $data.confirmation,
            acceptCallback: $options.accept,
            rejectCallback: $options.reject
          }) : (openBlock(), createElementBlock(Fragment, {
            key: 1
          }, [!_ctx.$slots.message ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            "class": _ctx.cx("content")
          }, _ctx.ptm("content")), [renderSlot(_ctx.$slots, "icon", {}, function() {
            return [_ctx.$slots.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.icon), {
              key: 0,
              "class": normalizeClass(_ctx.cx("icon"))
            }, null, 8, ["class"])) : $data.confirmation.icon ? (openBlock(), createElementBlock("span", mergeProps({
              key: 1,
              "class": [$data.confirmation.icon, _ctx.cx("icon")]
            }, _ctx.ptm("icon")), null, 16)) : createCommentVNode("", true)];
          }), createBaseVNode("span", mergeProps({
            "class": _ctx.cx("message")
          }, _ctx.ptm("message")), toDisplayString$1($data.confirmation.message), 17)], 16)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.message), {
            key: 1,
            message: $data.confirmation
          }, null, 8, ["message"])), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("footer")
          }, _ctx.ptm("footer")), [createVNode(_component_Button, mergeProps({
            "class": [_ctx.cx("pcRejectButton"), $data.confirmation.rejectClass],
            autofocus: $data.autoFocusReject,
            unstyled: _ctx.unstyled,
            size: ((_$data$confirmation$r = $data.confirmation.rejectProps) === null || _$data$confirmation$r === void 0 ? void 0 : _$data$confirmation$r.size) || "small",
            text: ((_$data$confirmation$r2 = $data.confirmation.rejectProps) === null || _$data$confirmation$r2 === void 0 ? void 0 : _$data$confirmation$r2.text) || false,
            onClick: _cache[0] || (_cache[0] = function($event) {
              return $options.reject();
            }),
            onKeydown: $options.onRejectKeydown
          }, $data.confirmation.rejectProps, {
            label: $options.rejectLabel,
            pt: _ctx.ptm("pcRejectButton")
          }), createSlots({
            _: 2
          }, [$options.rejectIcon || _ctx.$slots.rejecticon ? {
            name: "icon",
            fn: withCtx(function(iconProps) {
              return [renderSlot(_ctx.$slots, "rejecticon", {}, function() {
                return [createBaseVNode("span", mergeProps({
                  "class": [$options.rejectIcon, iconProps["class"]]
                }, _ctx.ptm("pcRejectButton")["icon"], {
                  "data-pc-section": "rejectbuttonicon"
                }), null, 16)];
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["class", "autofocus", "unstyled", "size", "text", "onKeydown", "label", "pt"]), createVNode(_component_Button, mergeProps({
            "class": [_ctx.cx("pcAcceptButton"), $data.confirmation.acceptClass],
            autofocus: $data.autoFocusAccept,
            unstyled: _ctx.unstyled,
            size: ((_$data$confirmation$a = $data.confirmation.acceptProps) === null || _$data$confirmation$a === void 0 ? void 0 : _$data$confirmation$a.size) || "small",
            onClick: _cache[1] || (_cache[1] = function($event) {
              return $options.accept();
            }),
            onKeydown: $options.onAcceptKeydown
          }, $data.confirmation.acceptProps, {
            label: $options.acceptLabel,
            pt: _ctx.ptm("pcAcceptButton")
          }), createSlots({
            _: 2
          }, [$options.acceptIcon || _ctx.$slots.accepticon ? {
            name: "icon",
            fn: withCtx(function(iconProps) {
              return [renderSlot(_ctx.$slots, "accepticon", {}, function() {
                return [createBaseVNode("span", mergeProps({
                  "class": [$options.acceptIcon, iconProps["class"]]
                }, _ctx.ptm("pcAcceptButton")["icon"], {
                  "data-pc-section": "acceptbuttonicon"
                }), null, 16)];
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["class", "autofocus", "unstyled", "size", "onKeydown", "label", "pt"])], 16)], 64))], 16, _hoisted_1$9)), [[_directive_focustrap]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  });
}
script$7.render = render$6;
function _typeof$3(o) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3(o);
}
function _defineProperty$3(e, r, t) {
  return (r = _toPropertyKey$3(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$3(t) {
  var i2 = _toPrimitive$3(t, "string");
  return "symbol" == _typeof$3(i2) ? i2 : i2 + "";
}
function _toPrimitive$3(t, r) {
  if ("object" != _typeof$3(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$3(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var theme$2 = function theme33(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-toast {\n    width: ".concat(dt3("toast.width"), ";\n    white-space: pre-line;\n    word-break: break-word;\n}\n\n.p-toast-message {\n    margin: 0 0 1rem 0;\n}\n\n.p-toast-message-icon {\n    flex-shrink: 0;\n    font-size: ").concat(dt3("toast.icon.size"), ";\n    width: ").concat(dt3("toast.icon.size"), ";\n    height: ").concat(dt3("toast.icon.size"), ";\n}\n\n.p-toast-message-content {\n    display: flex;\n    align-items: flex-start;\n    padding: ").concat(dt3("toast.content.padding"), ";\n    gap: ").concat(dt3("toast.content.gap"), ";\n}\n\n.p-toast-message-text {\n    flex: 1 1 auto;\n    display: flex;\n    flex-direction: column;\n    gap: ").concat(dt3("toast.text.gap"), ";\n}\n\n.p-toast-summary {\n    font-weight: ").concat(dt3("toast.summary.font.weight"), ";\n    font-size: ").concat(dt3("toast.summary.font.size"), ";\n}\n\n.p-toast-detail {\n    font-weight: ").concat(dt3("toast.detail.font.weight"), ";\n    font-size: ").concat(dt3("toast.detail.font.size"), ";\n}\n\n.p-toast-close-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    cursor: pointer;\n    background: transparent;\n    transition: background ").concat(dt3("toast.transition.duration"), ", color ").concat(dt3("toast.transition.duration"), ", outline-color ").concat(dt3("toast.transition.duration"), ", box-shadow ").concat(dt3("toast.transition.duration"), ";\n    outline-color: transparent;\n    color: inherit;\n    width: ").concat(dt3("toast.close.button.width"), ";\n    height: ").concat(dt3("toast.close.button.height"), ";\n    border-radius: ").concat(dt3("toast.close.button.border.radius"), ";\n    margin: -25% 0 0 0;\n    right: -25%;\n    padding: 0;\n    border: none;\n    user-select: none;\n}\n\n.p-toast-message-info,\n.p-toast-message-success,\n.p-toast-message-warn,\n.p-toast-message-error,\n.p-toast-message-secondary,\n.p-toast-message-contrast {\n    border-width: ").concat(dt3("toast.border.width"), ";\n    border-style: solid;\n    backdrop-filter: blur(").concat(dt3("toast.blur"), ");\n    border-radius: ").concat(dt3("toast.border.radius"), ";\n}\n\n.p-toast-close-icon {\n    font-size: ").concat(dt3("toast.close.icon.size"), ";\n    width: ").concat(dt3("toast.close.icon.size"), ";\n    height: ").concat(dt3("toast.close.icon.size"), ";\n}\n\n.p-toast-close-button:focus-visible {\n    outline-width: ").concat(dt3("focus.ring.width"), ";\n    outline-style: ").concat(dt3("focus.ring.style"), ";\n    outline-offset: ").concat(dt3("focus.ring.offset"), ";\n}\n\n.p-toast-message-info {\n    background: ").concat(dt3("toast.info.background"), ";\n    border-color: ").concat(dt3("toast.info.border.color"), ";\n    color: ").concat(dt3("toast.info.color"), ";\n    box-shadow: ").concat(dt3("toast.info.shadow"), ";\n}\n\n.p-toast-message-info .p-toast-detail {\n    color: ").concat(dt3("toast.info.detail.color"), ";\n}\n\n.p-toast-message-info .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.info.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.info.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-info .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.info.close.button.hover.background"), ";\n}\n\n.p-toast-message-success {\n    background: ").concat(dt3("toast.success.background"), ";\n    border-color: ").concat(dt3("toast.success.border.color"), ";\n    color: ").concat(dt3("toast.success.color"), ";\n    box-shadow: ").concat(dt3("toast.success.shadow"), ";\n}\n\n.p-toast-message-success .p-toast-detail {\n    color: ").concat(dt3("toast.success.detail.color"), ";\n}\n\n.p-toast-message-success .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.success.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.success.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-success .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.success.close.button.hover.background"), ";\n}\n\n.p-toast-message-warn {\n    background: ").concat(dt3("toast.warn.background"), ";\n    border-color: ").concat(dt3("toast.warn.border.color"), ";\n    color: ").concat(dt3("toast.warn.color"), ";\n    box-shadow: ").concat(dt3("toast.warn.shadow"), ";\n}\n\n.p-toast-message-warn .p-toast-detail {\n    color: ").concat(dt3("toast.warn.detail.color"), ";\n}\n\n.p-toast-message-warn .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.warn.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.warn.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-warn .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.warn.close.button.hover.background"), ";\n}\n\n.p-toast-message-error {\n    background: ").concat(dt3("toast.error.background"), ";\n    border-color: ").concat(dt3("toast.error.border.color"), ";\n    color: ").concat(dt3("toast.error.color"), ";\n    box-shadow: ").concat(dt3("toast.error.shadow"), ";\n}\n\n.p-toast-message-error .p-toast-detail {\n    color: ").concat(dt3("toast.error.detail.color"), ";\n}\n\n.p-toast-message-error .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.error.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.error.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-error .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.error.close.button.hover.background"), ";\n}\n\n.p-toast-message-secondary {\n    background: ").concat(dt3("toast.secondary.background"), ";\n    border-color: ").concat(dt3("toast.secondary.border.color"), ";\n    color: ").concat(dt3("toast.secondary.color"), ";\n    box-shadow: ").concat(dt3("toast.secondary.shadow"), ";\n}\n\n.p-toast-message-secondary .p-toast-detail {\n    color: ").concat(dt3("toast.secondary.detail.color"), ";\n}\n\n.p-toast-message-secondary .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.secondary.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.secondary.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-secondary .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.secondary.close.button.hover.background"), ";\n}\n\n.p-toast-message-contrast {\n    background: ").concat(dt3("toast.contrast.background"), ";\n    border-color: ").concat(dt3("toast.contrast.border.color"), ";\n    color: ").concat(dt3("toast.contrast.color"), ";\n    box-shadow: ").concat(dt3("toast.contrast.shadow"), ";\n}\n\n.p-toast-message-contrast .p-toast-detail {\n    color: ").concat(dt3("toast.contrast.detail.color"), ";\n}\n\n.p-toast-message-contrast .p-toast-close-button:focus-visible {\n    outline-color: ").concat(dt3("toast.contrast.close.button.focus.ring.color"), ";\n    box-shadow: ").concat(dt3("toast.contrast.close.button.focus.ring.shadow"), ";\n}\n\n.p-toast-message-contrast .p-toast-close-button:hover {\n    background: ").concat(dt3("toast.contrast.close.button.hover.background"), ";\n}\n\n.p-toast-top-center {\n    transform: translateX(-50%);\n}\n\n.p-toast-bottom-center {\n    transform: translateX(-50%);\n}\n\n.p-toast-center {\n    min-width: 20vw;\n    transform: translate(-50%, -50%);\n}\n\n.p-toast-message-enter-from {\n    opacity: 0;\n    transform: translateY(50%);\n}\n\n.p-toast-message-leave-from {\n    max-height: 1000px;\n}\n\n.p-toast .p-toast-message.p-toast-message-leave-to {\n    max-height: 0;\n    opacity: 0;\n    margin-bottom: 0;\n    overflow: hidden;\n}\n\n.p-toast-message-enter-active {\n    transition: transform 0.3s, opacity 0.3s;\n}\n\n.p-toast-message-leave-active {\n    transition: max-height 0.45s cubic-bezier(0, 1, 0, 1), opacity 0.3s, margin-bottom 0.3s;\n}\n");
};
var inlineStyles = {
  root: function root24(_ref2) {
    var position = _ref2.position;
    return {
      position: "fixed",
      top: position === "top-right" || position === "top-left" || position === "top-center" ? "20px" : position === "center" ? "50%" : null,
      right: (position === "top-right" || position === "bottom-right") && "20px",
      bottom: (position === "bottom-left" || position === "bottom-right" || position === "bottom-center") && "20px",
      left: position === "top-left" || position === "bottom-left" ? "20px" : position === "center" || position === "top-center" || position === "bottom-center" ? "50%" : null
    };
  }
};
var classes$2 = {
  root: function root25(_ref3) {
    var props = _ref3.props;
    return ["p-toast p-component p-toast-" + props.position];
  },
  message: function message2(_ref4) {
    var props = _ref4.props;
    return ["p-toast-message", {
      "p-toast-message-info": props.message.severity === "info" || props.message.severity === void 0,
      "p-toast-message-warn": props.message.severity === "warn",
      "p-toast-message-error": props.message.severity === "error",
      "p-toast-message-success": props.message.severity === "success",
      "p-toast-message-secondary": props.message.severity === "secondary",
      "p-toast-message-contrast": props.message.severity === "contrast"
    }];
  },
  messageContent: "p-toast-message-content",
  messageIcon: function messageIcon(_ref5) {
    var props = _ref5.props;
    return ["p-toast-message-icon", _defineProperty$3(_defineProperty$3(_defineProperty$3(_defineProperty$3({}, props.infoIcon, props.message.severity === "info"), props.warnIcon, props.message.severity === "warn"), props.errorIcon, props.message.severity === "error"), props.successIcon, props.message.severity === "success")];
  },
  messageText: "p-toast-message-text",
  summary: "p-toast-summary",
  detail: "p-toast-detail",
  closeButton: "p-toast-close-button",
  closeIcon: "p-toast-close-icon"
};
var ToastStyle = BaseStyle.extend({
  name: "toast",
  theme: theme$2,
  classes: classes$2,
  inlineStyles
});
var script$6 = {
  name: "ExclamationTriangleIcon",
  "extends": script$15
};
var _hoisted_1$8 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M13.4018 13.1893H0.598161C0.49329 13.189 0.390283 13.1615 0.299143 13.1097C0.208003 13.0578 0.131826 12.9832 0.0780112 12.8932C0.0268539 12.8015 0 12.6982 0 12.5931C0 12.4881 0.0268539 12.3848 0.0780112 12.293L6.47985 1.08982C6.53679 1.00399 6.61408 0.933574 6.70484 0.884867C6.7956 0.836159 6.897 0.810669 7 0.810669C7.103 0.810669 7.2044 0.836159 7.29516 0.884867C7.38592 0.933574 7.46321 1.00399 7.52015 1.08982L13.922 12.293C13.9731 12.3848 14 12.4881 14 12.5931C14 12.6982 13.9731 12.8015 13.922 12.8932C13.8682 12.9832 13.792 13.0578 13.7009 13.1097C13.6097 13.1615 13.5067 13.189 13.4018 13.1893ZM1.63046 11.989H12.3695L7 2.59425L1.63046 11.989Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99996 8.78801C6.84143 8.78594 6.68997 8.72204 6.57787 8.60993C6.46576 8.49782 6.40186 8.34637 6.39979 8.18784V5.38703C6.39979 5.22786 6.46302 5.0752 6.57557 4.96265C6.68813 4.85009 6.84078 4.78686 6.99996 4.78686C7.15914 4.78686 7.31179 4.85009 7.42435 4.96265C7.5369 5.0752 7.60013 5.22786 7.60013 5.38703V8.18784C7.59806 8.34637 7.53416 8.49782 7.42205 8.60993C7.30995 8.72204 7.15849 8.78594 6.99996 8.78801Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.99996 11.1887C6.84143 11.1866 6.68997 11.1227 6.57787 11.0106C6.46576 10.8985 6.40186 10.7471 6.39979 10.5885V10.1884C6.39979 10.0292 6.46302 9.87658 6.57557 9.76403C6.68813 9.65147 6.84078 9.58824 6.99996 9.58824C7.15914 9.58824 7.31179 9.65147 7.42435 9.76403C7.5369 9.87658 7.60013 10.0292 7.60013 10.1884V10.5885C7.59806 10.7471 7.53416 10.8985 7.42205 11.0106C7.30995 11.1227 7.15849 11.1866 6.99996 11.1887Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_4$1 = [_hoisted_1$8, _hoisted_2$5, _hoisted_3$2];
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_4$1, 16);
}
script$6.render = render$5;
var script$5 = {
  name: "InfoCircleIcon",
  "extends": script$15
};
var _hoisted_1$7 = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M3.11101 12.8203C4.26215 13.5895 5.61553 14 7 14C8.85652 14 10.637 13.2625 11.9497 11.9497C13.2625 10.637 14 8.85652 14 7C14 5.61553 13.5895 4.26215 12.8203 3.11101C12.0511 1.95987 10.9579 1.06266 9.67879 0.532846C8.3997 0.00303296 6.99224 -0.13559 5.63437 0.134506C4.2765 0.404603 3.02922 1.07129 2.05026 2.05026C1.07129 3.02922 0.404603 4.2765 0.134506 5.63437C-0.13559 6.99224 0.00303296 8.3997 0.532846 9.67879C1.06266 10.9579 1.95987 12.0511 3.11101 12.8203ZM3.75918 2.14976C4.71846 1.50879 5.84628 1.16667 7 1.16667C8.5471 1.16667 10.0308 1.78125 11.1248 2.87521C12.2188 3.96918 12.8333 5.45291 12.8333 7C12.8333 8.15373 12.4912 9.28154 11.8502 10.2408C11.2093 11.2001 10.2982 11.9478 9.23232 12.3893C8.16642 12.8308 6.99353 12.9463 5.86198 12.7212C4.73042 12.4962 3.69102 11.9406 2.87521 11.1248C2.05941 10.309 1.50384 9.26958 1.27876 8.13803C1.05367 7.00647 1.16919 5.83358 1.61071 4.76768C2.05222 3.70178 2.79989 2.79074 3.75918 2.14976ZM7.00002 4.8611C6.84594 4.85908 6.69873 4.79698 6.58977 4.68801C6.48081 4.57905 6.4187 4.43185 6.41669 4.27776V3.88888C6.41669 3.73417 6.47815 3.58579 6.58754 3.4764C6.69694 3.367 6.84531 3.30554 7.00002 3.30554C7.15473 3.30554 7.3031 3.367 7.4125 3.4764C7.52189 3.58579 7.58335 3.73417 7.58335 3.88888V4.27776C7.58134 4.43185 7.51923 4.57905 7.41027 4.68801C7.30131 4.79698 7.1541 4.85908 7.00002 4.8611ZM7.00002 10.6945C6.84594 10.6925 6.69873 10.6304 6.58977 10.5214C6.48081 10.4124 6.4187 10.2652 6.41669 10.1111V6.22225C6.41669 6.06754 6.47815 5.91917 6.58754 5.80977C6.69694 5.70037 6.84531 5.63892 7.00002 5.63892C7.15473 5.63892 7.3031 5.70037 7.4125 5.80977C7.52189 5.91917 7.58335 6.06754 7.58335 6.22225V10.1111C7.58134 10.2652 7.51923 10.4124 7.41027 10.5214C7.30131 10.6304 7.1541 10.6925 7.00002 10.6945Z",
  fill: "currentColor"
}, null, -1);
var _hoisted_2$4 = [_hoisted_1$7];
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _hoisted_2$4, 16);
}
script$5.render = render$4;
var script$2$1 = {
  name: "BaseToast",
  "extends": script$1a,
  props: {
    group: {
      type: String,
      "default": null
    },
    position: {
      type: String,
      "default": "top-right"
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    closeIcon: {
      type: String,
      "default": void 0
    },
    infoIcon: {
      type: String,
      "default": void 0
    },
    warnIcon: {
      type: String,
      "default": void 0
    },
    errorIcon: {
      type: String,
      "default": void 0
    },
    successIcon: {
      type: String,
      "default": void 0
    },
    closeButtonProps: {
      type: null,
      "default": null
    }
  },
  style: ToastStyle,
  provide: function provide40() {
    return {
      $pcToast: this,
      $parentInstance: this
    };
  }
};
var script$1$2 = {
  name: "ToastMessage",
  hostName: "Toast",
  "extends": script$1a,
  emits: ["close"],
  closeTimeout: null,
  props: {
    message: {
      type: null,
      "default": null
    },
    templates: {
      type: Object,
      "default": null
    },
    closeIcon: {
      type: String,
      "default": null
    },
    infoIcon: {
      type: String,
      "default": null
    },
    warnIcon: {
      type: String,
      "default": null
    },
    errorIcon: {
      type: String,
      "default": null
    },
    successIcon: {
      type: String,
      "default": null
    },
    closeButtonProps: {
      type: null,
      "default": null
    }
  },
  mounted: function mounted21() {
    var _this = this;
    if (this.message.life) {
      this.closeTimeout = setTimeout(function() {
        _this.close({
          message: _this.message,
          type: "life-end"
        });
      }, this.message.life);
    }
  },
  beforeUnmount: function beforeUnmount13() {
    this.clearCloseTimeout();
  },
  methods: {
    close: function close3(params) {
      this.$emit("close", params);
    },
    onCloseClick: function onCloseClick() {
      this.clearCloseTimeout();
      this.close({
        message: this.message,
        type: "close"
      });
    },
    clearCloseTimeout: function clearCloseTimeout() {
      if (this.closeTimeout) {
        clearTimeout(this.closeTimeout);
        this.closeTimeout = null;
      }
    }
  },
  computed: {
    iconComponent: function iconComponent() {
      return {
        info: !this.infoIcon && script$5,
        success: !this.successIcon && script$11,
        warn: !this.warnIcon && script$6,
        error: !this.errorIcon && script$F
      }[this.message.severity];
    },
    closeAriaLabel: function closeAriaLabel2() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    }
  },
  components: {
    TimesIcon: script$O,
    InfoCircleIcon: script$5,
    CheckIcon: script$11,
    ExclamationTriangleIcon: script$6,
    TimesCircleIcon: script$F
  },
  directives: {
    ripple: Ripple
  }
};
function _typeof$1$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1$1(o);
}
function ownKeys$1$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1$1(Object(t), true).forEach(function(r2) {
      _defineProperty$1$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$1$1(e, r, t) {
  return (r = _toPropertyKey$1$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$1$1(t) {
  var i2 = _toPrimitive$1$1(t, "string");
  return "symbol" == _typeof$1$1(i2) ? i2 : i2 + "";
}
function _toPrimitive$1$1(t, r) {
  if ("object" != _typeof$1$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var _hoisted_1$6 = ["aria-label"];
function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": [_ctx.cx("message"), $props.message.styleClass],
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true"
  }, _ctx.ptm("message")), [$props.templates.container ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.container), {
    key: 0,
    message: $props.message,
    closeCallback: $options.onCloseClick
  }, null, 8, ["message", "closeCallback"])) : (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    "class": [_ctx.cx("messageContent"), $props.message.contentStyleClass]
  }, _ctx.ptm("messageContent")), [!$props.templates.message ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [(openBlock(), createBlock(resolveDynamicComponent($props.templates.messageicon ? $props.templates.messageicon : $props.templates.icon ? $props.templates.icon : $options.iconComponent && $options.iconComponent.name ? $options.iconComponent : "span"), mergeProps({
    "class": _ctx.cx("messageIcon")
  }, _ctx.ptm("messageIcon")), null, 16, ["class"])), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("messageText")
  }, _ctx.ptm("messageText")), [createBaseVNode("span", mergeProps({
    "class": _ctx.cx("summary")
  }, _ctx.ptm("summary")), toDisplayString$1($props.message.summary), 17), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("detail")
  }, _ctx.ptm("detail")), toDisplayString$1($props.message.detail), 17)], 16)], 64)) : (openBlock(), createBlock(resolveDynamicComponent($props.templates.message), {
    key: 1,
    message: $props.message
  }, null, 8, ["message"])), $props.message.closable !== false ? (openBlock(), createElementBlock("div", normalizeProps(mergeProps({
    key: 2
  }, _ctx.ptm("buttonContainer"))), [withDirectives((openBlock(), createElementBlock("button", mergeProps({
    "class": _ctx.cx("closeButton"),
    type: "button",
    "aria-label": $options.closeAriaLabel,
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.onCloseClick && $options.onCloseClick.apply($options, arguments);
    }),
    autofocus: ""
  }, _objectSpread$1$1(_objectSpread$1$1({}, $props.closeButtonProps), _ctx.ptm("closeButton"))), [(openBlock(), createBlock(resolveDynamicComponent($props.templates.closeicon || "TimesIcon"), mergeProps({
    "class": [_ctx.cx("closeIcon"), $props.closeIcon]
  }, _ctx.ptm("closeIcon")), null, 16, ["class"]))], 16, _hoisted_1$6)), [[_directive_ripple]])], 16)) : createCommentVNode("", true)], 16))], 16);
}
script$1$2.render = render$1$1;
function _toConsumableArray$2(r) {
  return _arrayWithoutHoles$2(r) || _iterableToArray$2(r) || _unsupportedIterableToArray$2(r) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0;
  }
}
function _iterableToArray$2(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$2(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$2(r);
}
function _arrayLikeToArray$2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var messageIdx = 0;
var script$4 = {
  name: "Toast",
  "extends": script$2$1,
  inheritAttrs: false,
  emits: ["close", "life-end"],
  data: function data26() {
    return {
      messages: []
    };
  },
  styleElement: null,
  mounted: function mounted22() {
    ToastEventBus.on("add", this.onAdd);
    ToastEventBus.on("remove", this.onRemove);
    ToastEventBus.on("remove-group", this.onRemoveGroup);
    ToastEventBus.on("remove-all-groups", this.onRemoveAllGroups);
    if (this.breakpoints) {
      this.createStyle();
    }
  },
  beforeUnmount: function beforeUnmount14() {
    this.destroyStyle();
    if (this.$refs.container && this.autoZIndex) {
      ZIndex.clear(this.$refs.container);
    }
    ToastEventBus.off("add", this.onAdd);
    ToastEventBus.off("remove", this.onRemove);
    ToastEventBus.off("remove-group", this.onRemoveGroup);
    ToastEventBus.off("remove-all-groups", this.onRemoveAllGroups);
  },
  methods: {
    add: function add2(message3) {
      if (message3.id == null) {
        message3.id = messageIdx++;
      }
      this.messages = [].concat(_toConsumableArray$2(this.messages), [message3]);
    },
    remove: function remove4(params) {
      var index2 = this.messages.findIndex(function(m) {
        return m.id === params.message.id;
      });
      if (index2 !== -1) {
        this.messages.splice(index2, 1);
        this.$emit(params.type, {
          message: params.message
        });
      }
    },
    onAdd: function onAdd(message3) {
      if (this.group == message3.group) {
        this.add(message3);
      }
    },
    onRemove: function onRemove(message3) {
      this.remove({
        message: message3,
        type: "close"
      });
    },
    onRemoveGroup: function onRemoveGroup(group) {
      if (this.group === group) {
        this.messages = [];
      }
    },
    onRemoveAllGroups: function onRemoveAllGroups() {
      this.messages = [];
    },
    onEnter: function onEnter3() {
      this.$refs.container.setAttribute(this.attributeSelector, "");
      if (this.autoZIndex) {
        ZIndex.set("modal", this.$refs.container, this.baseZIndex || this.$primevue.config.zIndex.modal);
      }
    },
    onLeave: function onLeave3() {
      var _this = this;
      if (this.$refs.container && this.autoZIndex && isEmpty(this.messages)) {
        setTimeout(function() {
          ZIndex.clear(_this.$refs.container);
        }, 200);
      }
    },
    createStyle: function createStyle3() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        setAttribute(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          var breakpointStyle = "";
          for (var styleProp in this.breakpoints[breakpoint]) {
            breakpointStyle += styleProp + ":" + this.breakpoints[breakpoint][styleProp] + "!important;";
          }
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-toast[").concat(this.attributeSelector, "] {\n                                ").concat(breakpointStyle, "\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    },
    destroyStyle: function destroyStyle2() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    }
  },
  computed: {
    attributeSelector: function attributeSelector4() {
      return UniqueComponentId();
    }
  },
  components: {
    ToastMessage: script$1$2,
    Portal: script$N
  }
};
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
function ownKeys$2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2(Object(t), true).forEach(function(r2) {
      _defineProperty$2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$2(e, r, t) {
  return (r = _toPropertyKey$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$2(t) {
  var i2 = _toPrimitive$2(t, "string");
  return "symbol" == _typeof$2(i2) ? i2 : i2 + "";
}
function _toPrimitive$2(t, r) {
  if ("object" != _typeof$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_ToastMessage = resolveComponent("ToastMessage");
  var _component_Portal = resolveComponent("Portal");
  return openBlock(), createBlock(_component_Portal, null, {
    "default": withCtx(function() {
      return [createBaseVNode("div", mergeProps({
        ref: "container",
        "class": _ctx.cx("root"),
        style: _ctx.sx("root", true, {
          position: _ctx.position
        })
      }, _ctx.ptmi("root")), [createVNode(TransitionGroup, mergeProps({
        name: "p-toast-message",
        tag: "div",
        onEnter: $options.onEnter,
        onLeave: $options.onLeave
      }, _objectSpread$2({}, _ctx.ptm("transition"))), {
        "default": withCtx(function() {
          return [(openBlock(true), createElementBlock(Fragment, null, renderList($data.messages, function(msg) {
            return openBlock(), createBlock(_component_ToastMessage, {
              key: msg.id,
              message: msg,
              templates: _ctx.$slots,
              closeIcon: _ctx.closeIcon,
              infoIcon: _ctx.infoIcon,
              warnIcon: _ctx.warnIcon,
              errorIcon: _ctx.errorIcon,
              successIcon: _ctx.successIcon,
              closeButtonProps: _ctx.closeButtonProps,
              onClose: _cache[0] || (_cache[0] = function($event) {
                return $options.remove($event);
              }),
              pt: _ctx.pt
            }, null, 8, ["message", "templates", "closeIcon", "infoIcon", "warnIcon", "errorIcon", "successIcon", "closeButtonProps", "pt"]);
          }), 128))];
        }),
        _: 1
      }, 16, ["onEnter", "onLeave"])], 16)];
    }),
    _: 1
  });
}
script$4.render = render$3;
var TaskItemDisplayStatus = /* @__PURE__ */ ((TaskItemDisplayStatus2) => {
  TaskItemDisplayStatus2["Running"] = "Running";
  TaskItemDisplayStatus2["Pending"] = "Pending";
  TaskItemDisplayStatus2["Completed"] = "Completed";
  TaskItemDisplayStatus2["Failed"] = "Failed";
  TaskItemDisplayStatus2["Cancelled"] = "Cancelled";
  return TaskItemDisplayStatus2;
})(TaskItemDisplayStatus || {});
class TaskItemImpl {
  constructor() {
    __publicField2(this, "taskType");
    __publicField2(this, "prompt");
    __publicField2(this, "status");
    __publicField2(this, "outputs");
  }
  get apiTaskType() {
    switch (this.taskType) {
      case "Running":
      case "Pending":
        return "queue";
      case "History":
        return "history";
    }
  }
  get queueIndex() {
    return this.prompt[0];
  }
  get promptId() {
    return this.prompt[1];
  }
  get promptInputs() {
    return this.prompt[2];
  }
  get extraData() {
    return this.prompt[3];
  }
  get outputsToExecute() {
    return this.prompt[4];
  }
  get extraPngInfo() {
    return this.extraData.extra_pnginfo;
  }
  get clientId() {
    return this.extraData.client_id;
  }
  get workflow() {
    return this.extraPngInfo.workflow;
  }
  get messages() {
    var _a2;
    return ((_a2 = this.status) == null ? void 0 : _a2.messages) || [];
  }
  get interrupted() {
    return _.some(
      this.messages,
      (message3) => message3[0] === "execution_interrupted"
    );
  }
  get isHistory() {
    return this.taskType === "History";
  }
  get isRunning() {
    return this.taskType === "Running";
  }
  get displayStatus() {
    switch (this.taskType) {
      case "Running":
        return "Running";
      case "Pending":
        return "Pending";
      case "History":
        switch (this.status.status_str) {
          case "success":
            return "Completed";
          case "error":
            return this.interrupted ? "Cancelled" : "Failed";
        }
    }
  }
  get executionStartTimestamp() {
    const message3 = this.messages.find(
      (message22) => message22[0] === "execution_start"
    );
    return message3 ? message3[1].timestamp : void 0;
  }
  get executionEndTimestamp() {
    const messages2 = this.messages.filter(
      (message3) => [
        "execution_success",
        "execution_interrupted",
        "execution_error"
      ].includes(message3[0])
    );
    if (!messages2.length) {
      return void 0;
    }
    return _.max(messages2.map((message3) => message3[1].timestamp));
  }
  get executionTime() {
    if (!this.executionStartTimestamp || !this.executionEndTimestamp) {
      return void 0;
    }
    return this.executionEndTimestamp - this.executionStartTimestamp;
  }
  get executionTimeInSeconds() {
    return this.executionTime !== void 0 ? this.executionTime / 1e3 : void 0;
  }
  loadWorkflow() {
    return __async(this, null, function* () {
      yield app$1.loadGraphData(toRaw(this.workflow));
      if (this.outputs) {
        app$1.nodeOutputs = toRaw(this.outputs);
      }
    });
  }
}
const useQueueStore = defineStore("queue", {
  state: () => ({
    runningTasks: [],
    pendingTasks: [],
    historyTasks: [],
    maxHistoryItems: 64
  }),
  getters: {
    tasks(state) {
      return [
        ...state.pendingTasks,
        ...state.runningTasks,
        ...state.historyTasks
      ];
    },
    lastHistoryQueueIndex(state) {
      return state.historyTasks.length ? state.historyTasks[0].queueIndex : -1;
    }
  },
  actions: {
    // Fetch the queue data from the API
    update() {
      return __async(this, null, function* () {
        const [queue2, history] = yield Promise.all([
          api.getQueue(),
          api.getHistory(this.maxHistoryItems)
        ]);
        const toClassAll = (tasks) => tasks.map((task) => validateTaskItem(task)).filter((result) => result.success).map((result) => plainToClass(TaskItemImpl, result.data)).sort((a, b) => b.queueIndex - a.queueIndex);
        this.runningTasks = toClassAll(queue2.Running);
        this.pendingTasks = toClassAll(queue2.Pending);
        const allIndex = new Set(
          history.History.map((item) => item.prompt[0])
        );
        const newHistoryItems = toClassAll(
          history.History.filter(
            (item) => item.prompt[0] > this.lastHistoryQueueIndex
          )
        );
        const existingHistoryItems = this.historyTasks.filter(
          (item) => allIndex.has(item.queueIndex)
        );
        this.historyTasks = [...newHistoryItems, ...existingHistoryItems].slice(0, this.maxHistoryItems).sort((a, b) => b.queueIndex - a.queueIndex);
      });
    },
    clear() {
      return __async(this, null, function* () {
        yield Promise.all(
          ["queue", "history"].map((type) => api.clearItems(type))
        );
        yield this.update();
      });
    },
    delete(task) {
      return __async(this, null, function* () {
        yield api.deleteItem(task.apiTaskType, task.promptId);
        yield this.update();
      });
    }
  }
});
const useQueuePendingTaskCountStore = defineStore(
  "queuePendingTaskCount",
  {
    state: () => ({
      count: 0
    }),
    actions: {
      update(e) {
        var _a2, _b;
        this.count = ((_b = (_a2 = e.detail) == null ? void 0 : _a2.exec_info) == null ? void 0 : _b.queue_remaining) || 0;
      }
    }
  }
);
const _withScopeId$1 = (n) => (pushScopeId("data-v-89313500"), n = n(), popScopeId(), n);
const _hoisted_1$5 = {
  key: 0,
  class: "queue-time-cell-content"
};
const _hoisted_2$3 = {
  key: 1,
  class: "queue-time-cell-content"
};
const _hoisted_3$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("i", { class: "pi pi-spin pi-spinner" }, null, -1));
const _hoisted_4 = [
  _hoisted_3$1
];
const _hoisted_5 = {
  key: 2,
  class: "queue-time-cell-content"
};
const _hoisted_6 = { key: 1 };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "QueueSidebarTab",
  setup(__props) {
    const confirm2 = useConfirm();
    const toast = useToast();
    const queueStore = useQueueStore();
    const tasks = computed(() => queueStore.tasks);
    const taskTagSeverity = (status) => {
      switch (status) {
        case TaskItemDisplayStatus.Pending:
          return "secondary";
        case TaskItemDisplayStatus.Running:
          return "info";
        case TaskItemDisplayStatus.Completed:
          return "success";
        case TaskItemDisplayStatus.Failed:
          return "danger";
        case TaskItemDisplayStatus.Cancelled:
          return "warning";
      }
    };
    const formatTime = (time) => {
      if (time === void 0) {
        return "";
      }
      return `${time.toFixed(2)}s`;
    };
    const removeTask = (task) => {
      if (task.isRunning) {
        api.interrupt();
      }
      queueStore.delete(task);
    };
    const removeAllTasks = () => __async(this, null, function* () {
      yield queueStore.clear();
    });
    const confirmRemoveAll = (event2) => {
      confirm2.require({
        target: event2.currentTarget,
        message: "Do you want to delete all tasks?",
        icon: "pi pi-info-circle",
        rejectProps: {
          label: "Cancel",
          severity: "secondary",
          outlined: true
        },
        acceptProps: {
          label: "Delete",
          severity: "danger"
        },
        accept: () => __async(this, null, function* () {
          yield removeAllTasks();
          toast.add({
            severity: "info",
            summary: "Confirmed",
            detail: "Tasks deleted",
            life: 3e3
          });
        })
      });
    };
    const onStatus = () => queueStore.update();
    onMounted(() => {
      api.addEventListener("status", onStatus);
      queueStore.update();
    });
    onUnmounted(() => {
      api.removeEventListener("status", onStatus);
    });
    return (_ctx, _cache) => {
      return tasks.value.length > 0 ? (openBlock(), createBlock(unref(script$d), {
        key: 0,
        value: tasks.value,
        dataKey: "promptId",
        class: "queue-table"
      }, {
        default: withCtx(() => [
          createVNode(unref(script$8), { header: "STATUS" }, {
            body: withCtx(({ data: data28 }) => [
              createVNode(unref(script$I), {
                severity: taskTagSeverity(data28.displayStatus)
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(data28.displayStatus.toUpperCase()), 1)
                ]),
                _: 2
              }, 1032, ["severity"])
            ]),
            _: 1
          }),
          createVNode(unref(script$8), {
            header: "TIME",
            pt: { root: { class: "queue-time-cell" } }
          }, {
            body: withCtx(({ data: data28 }) => [
              data28.isHistory ? (openBlock(), createElementBlock("div", _hoisted_1$5, toDisplayString$1(formatTime(data28.executionTimeInSeconds)), 1)) : data28.isRunning ? (openBlock(), createElementBlock("div", _hoisted_2$3, _hoisted_4)) : (openBlock(), createElementBlock("div", _hoisted_5, "..."))
            ]),
            _: 1
          }),
          createVNode(unref(script$8), { pt: {
            headerCell: {
              class: "queue-tool-header-cell"
            },
            bodyCell: {
              class: "queue-tool-body-cell"
            }
          } }, {
            header: withCtx(() => [
              createVNode(unref(script$4)),
              createVNode(unref(script$7)),
              createVNode(unref(script$13), {
                icon: "pi pi-trash",
                text: "",
                severity: "primary",
                onClick: _cache[0] || (_cache[0] = ($event) => confirmRemoveAll($event))
              })
            ]),
            body: withCtx(({ data: data28 }) => [
              createVNode(unref(script$13), {
                icon: "pi pi-file-export",
                text: "",
                severity: "primary",
                onClick: ($event) => data28.loadWorkflow()
              }, null, 8, ["onClick"]),
              createVNode(unref(script$13), {
                icon: "pi pi-times",
                text: "",
                severity: "secondary",
                onClick: ($event) => removeTask(data28)
              }, null, 8, ["onClick"])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["value"])) : (openBlock(), createElementBlock("div", _hoisted_6, [
        createVNode(NoResultsPlaceholder, {
          icon: "pi pi-info-circle",
          title: _ctx.$t("noTasksFound"),
          message: _ctx.$t("noTasksFoundMessage")
        }, null, 8, ["title", "message"])
      ]));
    };
  }
});
const QueueSidebarTab = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-89313500"]]);
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
let mark;
let measure;
if (false) {
  const perf2 = inBrowser && window.performance;
  if (perf2 && perf2.mark && perf2.measure && perf2.clearMarks && // @ts-ignore browser compat
  perf2.clearMeasures) {
    mark = (tag) => {
      perf2.mark(tag);
    };
    measure = (name, startTag, endTag) => {
      perf2.measure(name, startTag, endTag);
      perf2.clearMarks(startTag);
      perf2.clearMarks(endTag);
    };
  }
}
const RE_ARGS$1 = /\{([0-9a-zA-Z]+)\}/g;
function format$2(message3, ...args) {
  if (args.length === 1 && isObject$1(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message3.replace(RE_ARGS$1, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale2, key, source) => friendlyJSONstringify({ l: locale2, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign$1 = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isSymbol = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value3) => objectToString.call(value3);
const isPlainObject = (val) => {
  if (!isObject$1(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items2, separator = "") {
  return items2.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
const RANGE = 2;
function generateCodeFrame(source, start2 = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];
  for (let i2 = 0; i2 < lines.length; i2++) {
    count += lines[i2].length + 1;
    if (count >= start2) {
      for (let j = i2 - RANGE; j <= i2 + RANGE || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        if (j === i2) {
          const pad = start2 - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad : end - start2);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i2) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const hasWarned = {};
function warnOnce(msg) {
  if (!hasWarned[msg]) {
    hasWarned[msg] = true;
    warn(msg);
  }
}
function createEmitter() {
  const events = /* @__PURE__ */ new Map();
  const emitter = {
    events,
    on(event2, handler8) {
      const handlers = events.get(event2);
      const added = handlers && handlers.push(handler8);
      if (!added) {
        events.set(event2, [handler8]);
      }
    },
    off(event2, handler8) {
      const handlers = events.get(event2);
      if (handlers) {
        handlers.splice(handlers.indexOf(handler8) >>> 0, 1);
      }
    },
    emit(event2, payload) {
      (events.get(event2) || []).slice().map((handler8) => handler8(payload));
      (events.get("*") || []).slice().map((handler8) => handler8(event2, payload));
    }
  };
  return emitter;
}
const isNotObjectOrIsArray = (val) => !isObject$1(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack2 = [{ src, des }];
  while (stack2.length) {
    const { src: src2, des: des2 } = stack2.pop();
    Object.keys(src2).forEach((key) => {
      if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
        des2[key] = src2[key];
      } else {
        stack2.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const LOCATION_STUB = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function createPosition(line, column, offset) {
  return { line, column, offset };
}
function createLocation(start2, end, source) {
  const loc = { start: start2, end };
  if (source != null) {
    loc.source = source;
  }
  return loc;
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$1(message3, ...args) {
  if (args.length === 1 && isObject(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message3.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const assign = Object.assign;
const isString = (val) => typeof val === "string";
const isObject = (val) => val !== null && typeof val === "object";
function join(items2, separator = "") {
  return items2.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages$2 = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
  const msg = format$1(warnMessages$2[code2] || "", ...args || []);
  const message3 = { message: String(msg), code: code2 };
  if (loc) {
    message3.location = loc;
  }
  return message3;
}
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages$2 = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options3 = {}) {
  const { domain, messages: messages2, args } = options3;
  const msg = format$1((messages2 || errorMessages$2)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
const RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
const detectHtmlTag = (source) => RE_HTML_TAG.test(source);
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
  const isLF = (index3) => _buf[index3] === CHAR_LF;
  const isPS = (index3) => _buf[index3] === CHAR_PS;
  const isLS = (index3) => _buf[index3] === CHAR_LS;
  const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
  const index2 = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next2() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next2();
    }
    _peekOffset = 0;
  }
  return {
    index: index2,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next: next2,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options3 = {}) {
  const location2 = options3.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options3;
  function emitError(code2, pos2, offset, ...args) {
    const ctx = context();
    pos2.column += offset;
    pos2.offset += offset;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos2) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type, value3) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location2) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value3 != null) {
      token.value = value3;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev2 = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev2 === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev2 === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev2 === "%" || detectModulo ? true : !(prev2 === CHAR_SP || prev2 === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value3 = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value3 += `-${getDigits(scnr)}`;
    } else {
      value3 += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value3;
  }
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i2 = 0; i2 < digits; i2++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn = (buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(buf);
      }
    };
    return fn("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "�";
    }
  }
}
function createParser(options3 = {}) {
  const location2 = options3.location !== false;
  const { onError, onWarn } = options3;
  function emitError(tokenzer, code2, start2, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location2 ? createLocation(start2, end) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function emitWarn(tokenzer, code2, start2, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onWarn) {
      const loc = location2 ? createLocation(start2, end) : null;
      onWarn(createCompileWarn(code2, loc, args));
    }
  }
  function startNode(type, offset, loc) {
    const node3 = { type };
    if (location2) {
      node3.start = offset;
      node3.end = offset;
      node3.loc = { start: loc, end: loc };
    }
    return node3;
  }
  function endNode(node3, offset, pos2, type) {
    if (type) {
      node3.type = type;
    }
    if (location2) {
      node3.end = offset;
      if (node3.loc) {
        node3.loc.end = pos2;
      }
    }
  }
  function parseText(tokenizer, value3) {
    const context = tokenizer.context();
    const node3 = startNode(3, context.offset, context.startLoc);
    node3.value = value3;
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseList(tokenizer, index2) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(5, offset, loc);
    node3.index = parseInt(index2, 10);
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseNamed(tokenizer, key, modulo) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(4, offset, loc);
    node3.key = key;
    if (modulo === true) {
      node3.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseLiteral(tokenizer, value3) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(9, offset, loc);
    node3.value = value3.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node3 = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node3.value = "";
      endNode(node3, offset, loc);
      return {
        nextConsumeToken: token,
        node: node3
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node3.value = token.value || "";
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: node3
    };
  }
  function parseLinkedKey(tokenizer, value3) {
    const context = tokenizer.context();
    const node3 = startNode(7, context.offset, context.startLoc);
    node3.value = value3;
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node3 = startNode(2, startOffset, startLoc);
    node3.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node3.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node3.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node3, endOffset, endLoc);
    return node3;
  }
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node3 = startNode(1, offset, loc);
    node3.cases = [];
    node3.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node3.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign({}, options3));
    const context = tokenizer.context();
    const node3 = startNode(0, context.offset, context.startLoc);
    if (location2 && node3.loc) {
      node3.loc.source = source;
    }
    node3.body = parseResource(tokenizer);
    if (options3.onCacheKey) {
      node3.cacheKey = options3.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node3, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node3;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "…" : name;
}
function createTransformer(ast, options3 = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i2 = 0; i2 < nodes.length; i2++) {
    traverseNode(nodes[i2], transformer);
  }
}
function traverseNode(node3, transformer) {
  switch (node3.type) {
    case 1:
      traverseNodes(node3.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node3.items, transformer);
      break;
    case 6: {
      const linked = node3;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options3 = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c) => optimizeMessageNode(c));
  }
  return ast;
}
function optimizeMessageNode(message3) {
  if (message3.items.length === 1) {
    const item = message3.items[0];
    if (item.type === 3 || item.type === 9) {
      message3.static = item.value;
      delete item.value;
    }
  } else {
    const values2 = [];
    for (let i2 = 0; i2 < message3.items.length; i2++) {
      const item = message3.items[i2];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values2.push(item.value);
    }
    if (values2.length === message3.items.length) {
      message3.static = join(values2);
      for (let i2 = 0; i2 < message3.items.length; i2++) {
        const item = message3.items[i2];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
const ERROR_DOMAIN$1 = "minifier";
function minify(node3) {
  node3.t = node3.type;
  switch (node3.type) {
    case 0: {
      const resource = node3;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node3;
      const cases = plural.cases;
      for (let i2 = 0; i2 < cases.length; i2++) {
        minify(cases[i2]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message3 = node3;
      const items2 = message3.items;
      for (let i2 = 0; i2 < items2.length; i2++) {
        minify(items2[i2]);
      }
      message3.i = items2;
      delete message3.items;
      if (message3.static) {
        message3.s = message3.static;
        delete message3.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node3;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node3;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node3;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node3;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node3.type]
      });
    }
  }
  delete node3.type;
}
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options3) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options3;
  const location2 = options3.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code2, node3) {
    _context.code += code2;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node3) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node3.key);
  if (node3.modifier) {
    generator.push(`, `);
    generateNode(generator, node3.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node3) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node3.items.length;
  for (let i2 = 0; i2 < length; i2++) {
    generateNode(generator, node3.items[i2]);
    if (i2 === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node3) {
  const { helper, needIndent } = generator;
  if (node3.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node3.cases.length;
    for (let i2 = 0; i2 < length; i2++) {
      generateNode(generator, node3.cases[i2]);
      if (i2 === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node3) {
  if (node3.body) {
    generateNode(generator, node3.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node3) {
  const { helper } = generator;
  switch (node3.type) {
    case 0:
      generateResource(generator, node3);
      break;
    case 1:
      generatePluralNode(generator, node3);
      break;
    case 2:
      generateMessageNode(generator, node3);
      break;
    case 6:
      generateLinkedNode(generator, node3);
      break;
    case 8:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 7:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node3.index}))`, node3);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node3.key)}))`, node3);
      break;
    case 9:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    case 3:
      generator.push(JSON.stringify(node3.value), node3);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node3.type]
      });
    }
  }
}
const generate = (ast, options3 = {}) => {
  const mode2 = isString(options3.mode) ? options3.mode : "normal";
  const filename = isString(options3.filename) ? options3.filename : "message.intl";
  const sourceMap = !!options3.sourceMap;
  const breakLineCode = options3.breakLineCode != null ? options3.breakLineCode : mode2 === "arrow" ? ";" : "\n";
  const needIndent = options3.needIndent ? options3.needIndent : mode2 !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode: mode2,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode2 === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code2, map: map2 } = generator.context();
  return {
    ast,
    code: code2,
    map: map2 ? map2.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile$1(source, options3 = {}) {
  const assignedOptions = assign({}, options3);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys = [];
  let index2 = -1;
  let mode2 = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode2 = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode2 === 5 && nextChar === "'" || mode2 === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode2 !== null) {
    index2++;
    c = path[index2];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode2];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode2 = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode2 === 7) {
      return keys;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$1(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$1(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last2 = obj;
  let i2 = 0;
  while (i2 < len) {
    const val = last2[hit[i2]];
    if (val === void 0) {
      return null;
    }
    if (isFunction$1(last2)) {
      return null;
    }
    last2 = val;
    i2++;
  }
  return last2;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values2) => values2.length === 0 ? "" : join$1(values2);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options3) {
  const index2 = isNumber(options3.pluralIndex) ? options3.pluralIndex : -1;
  return options3.named && (isNumber(options3.named.count) || isNumber(options3.named.n)) ? isNumber(options3.named.count) ? options3.named.count : isNumber(options3.named.n) ? options3.named.n : index2 : index2;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options3 = {}) {
  const locale2 = options3.locale;
  const pluralIndex = getPluralIndex(options3);
  const pluralRule = isObject$1(options3.pluralRules) && isString$1(locale2) && isFunction$1(options3.pluralRules[locale2]) ? options3.pluralRules[locale2] : pluralDefault;
  const orgPluralRule = isObject$1(options3.pluralRules) && isString$1(locale2) && isFunction$1(options3.pluralRules[locale2]) ? pluralDefault : void 0;
  const plural = (messages2) => {
    return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
  };
  const _list = options3.list || [];
  const list = (index2) => _list[index2];
  const _named = options3.named || {};
  isNumber(options3.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message3(key) {
    const msg = isFunction$1(options3.messages) ? options3.messages(key) : isObject$1(options3.messages) ? options3.messages[key] : false;
    return !msg ? options3.parent ? options3.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options3.modifiers ? options3.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options3.processor) && isFunction$1(options3.processor.normalize) ? options3.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options3.processor) && isFunction$1(options3.processor.interpolate) ? options3.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options3.processor) && isString$1(options3.processor.type) ? options3.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$1(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message3(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message3,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$1({}, _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function getDevToolsHook() {
  return devtools;
}
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  NOT_FOUND_KEY: code$1$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const warnMessages$1 = {
  [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
  [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
  [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
  [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: `This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.`
};
function getWarnMessage$1(code2, ...args) {
  return format$2(warnMessages$1[code2], ...args);
}
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, false ? { messages: errorMessages$1 } : void 0);
}
const errorMessages$1 = {
  [CoreErrorCodes.INVALID_ARGUMENT]: "Invalid arguments",
  [CoreErrorCodes.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function getLocale(context, options3) {
  return options3.locale != null ? resolveLocale(options3.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale2) {
  if (isString$1(locale2)) {
    return locale2;
  } else {
    if (isFunction$1(locale2)) {
      if (locale2.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale2.constructor.name === "Function") {
        const resolve8 = locale2();
        if (isPromise(resolve8)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve8;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start2) {
  return [.../* @__PURE__ */ new Set([
    start2,
    ...isArray(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start2]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start2) {
  const startLocale = isString$1(start2) ? start2 : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block2 = [start2];
    while (isArray(block2)) {
      block2 = appendBlockToChain(chain, block2, fallback);
    }
    const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block2 = isString$1(defaults) ? [defaults] : defaults;
    if (isArray(block2)) {
      appendBlockToChain(chain, block2, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block2, blocks) {
  let follow = true;
  for (let i2 = 0; i2 < block2.length && isBoolean(follow); i2++) {
    const locale2 = block2[i2];
    if (isString$1(locale2)) {
      follow = appendLocaleToChain(chain, block2[i2], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale2, blocks) {
  let follow;
  const tokens = locale2.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale2 = target.replace(/!/g, "");
      chain.push(locale2);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale2]) {
        follow = blocks[locale2];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.13.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options3 = {}) {
  const onWarn = isFunction$1(options3.onWarn) ? options3.onWarn : warn;
  const version2 = isString$1(options3.version) ? options3.version : VERSION$1;
  const locale2 = isString$1(options3.locale) || isFunction$1(options3.locale) ? options3.locale : DEFAULT_LOCALE;
  const _locale = isFunction$1(locale2) ? DEFAULT_LOCALE : locale2;
  const fallbackLocale = isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || isString$1(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale;
  const messages2 = isPlainObject(options3.messages) ? options3.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale]: {} };
  const modifiers = assign$1({}, options3.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options3.pluralRules || {};
  const missing = isFunction$1(options3.missing) ? options3.missing : null;
  const missingWarn = isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  const fallbackWarn = isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  const fallbackFormat = !!options3.fallbackFormat;
  const unresolving = !!options3.unresolving;
  const postTranslation = isFunction$1(options3.postTranslation) ? options3.postTranslation : null;
  const processor = isPlainObject(options3.processor) ? options3.processor : null;
  const warnHtmlMessage = isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  const escapeParameter = !!options3.escapeParameter;
  const messageCompiler = isFunction$1(options3.messageCompiler) ? options3.messageCompiler : _compiler;
  if (false) {
    warnOnce(getWarnMessage$1(CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  }
  const messageResolver = isFunction$1(options3.messageResolver) ? options3.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction$1(options3.localeFallbacker) ? options3.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$1(options3.fallbackContext) ? options3.fallbackContext : void 0;
  const internalOptions = options3;
  const __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (false) {
    context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : void 0;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function isTranslateFallbackWarn(fallback, key) {
  return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
function isTranslateMissingWarn(missing, key) {
  return missing instanceof RegExp ? missing.test(key) : missing;
}
function handleMissing(context, key, locale2, missingWarn, type) {
  const { missing, onWarn } = context;
  if (false) {
    const emitter = context.__v_emitter;
    if (emitter) {
      emitter.emit("missing", {
        locale: locale2,
        key,
        type,
        groupId: `${type}:${key}`
      });
    }
  }
  if (missing !== null) {
    const ret = missing(context, locale2, key, type);
    return isString$1(ret) ? ret : key;
  } else {
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.NOT_FOUND_KEY, { key, locale: locale2 }));
    }
    return key;
  }
}
function updateFallbackLocale(ctx, locale2, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale2);
}
function isAlmostSameLocale(locale2, compareLocale) {
  if (locale2 === compareLocale)
    return false;
  return locale2.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index2 = locales.indexOf(targetLocale);
  if (index2 === -1) {
    return false;
  }
  for (let i2 = index2 + 1; i2 < locales.length; i2++) {
    if (isAlmostSameLocale(targetLocale, locales[i2])) {
      return true;
    }
  }
  return false;
}
function format(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages2, c) => [
      ...messages2,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node3) {
  const _static = node3.s || node3.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages2 = (node3.i || node3.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages2);
  }
}
function formatMessagePart(ctx, node3) {
  const type = node3.t || node3.type;
  switch (type) {
    case 3: {
      const text2 = node3;
      return text2.v || text2.value;
    }
    case 9: {
      const literal = node3;
      return literal.v || literal.value;
    }
    case 4: {
      const named = node3;
      return ctx.interpolate(ctx.named(named.k || named.key));
    }
    case 5: {
      const list = node3;
      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
    }
    case 6: {
      const linked = node3;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      const linkedKey = node3;
      return linkedKey.v || linkedKey.value;
    }
    case 8: {
      const linkedModifier = node3;
      return linkedModifier.v || linkedModifier.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${type}`);
  }
}
const WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;
function checkHtmlMessage(source, warnHtmlMessage) {
  if (warnHtmlMessage && detectHtmlTag(source)) {
    warn(format$2(WARN_MESSAGE, { source }));
  }
}
const defaultOnCacheKey = (message3) => message3;
let compileCache = /* @__PURE__ */ Object.create(null);
function onCompileWarn(_warn) {
  if (_warn.code === CompileWarnCodes.USE_MODULO_SYNTAX) {
    warn(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${_warn.message})`);
  }
}
function clearCompileCache() {
  compileCache = /* @__PURE__ */ Object.create(null);
}
const isMessageAST = (val) => isObject$1(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
function baseCompile(message3, options3 = {}) {
  let detectError = false;
  const onError = options3.onError || defaultOnError;
  options3.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return __spreadProps2(__spreadValues2({}, baseCompile$1(message3, options3)), { detectError });
}
const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message3, context) => {
  if (!isString$1(message3)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  if (false) {
    context.onWarn = onCompileWarn;
  }
  {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message3);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code2, detectError } = baseCompile(message3, context);
    const msg = new Function(`return ${code2}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile(message3, context) {
  if (false) {
    context.onWarn = onCompileWarn;
  }
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$1(message3)) {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message3);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message3, __spreadProps2(__spreadValues2({}, context), {
      location: false,
      jit: true
    }));
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    if (false) {
      warn(`the message that is resolve with key '${context.key}' is not supported for jit compilation`);
      return () => message3;
    }
    const cacheKey = message3.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message3);
    } else {
      return format(message3);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction$1(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
  const [key, options3] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options3.escapeParameter) ? options3.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options3.resolvedMessage;
  const defaultMsgOrKey = isString$1(options3.default) || isBoolean(options3.default) ? !isBoolean(options3.default) ? options3.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale2 = getLocale(context, options3);
  escapeParameter && escapeParams(options3);
  let [formatScope, targetLocale, message3] = !resolvedMessage ? resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale2,
    messages2[locale2] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  if (false) {
    warn(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${key}'.`);
    return key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message3, options3);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options3) {
  if (isArray(options3.list)) {
    options3.list = options3.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$1(options3.named)) {
    Object.keys(options3.named).forEach((key) => {
      if (isString$1(options3.named[key])) {
        options3.named[key] = escapeHtml(options3.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale2);
  let message3 = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "translate";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    message3 = messages2[targetLocale] || {};
    let start2 = null;
    let startTag;
    let endTag;
    if (false) {
      start2 = window.performance.now();
      startTag = "intlify-message-resolve-start";
      endTag = "intlify-message-resolve-end";
      mark && mark(startTag);
    }
    if ((format2 = resolveValue2(message3, key)) === null) {
      format2 = message3[key];
    }
    if (false) {
      const end = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start2 && format2) {
        emitter.emit("message-resolve", {
          type: "message-resolve",
          key,
          message: format2,
          time: end - start2,
          groupId: `${type}:${key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message resolve", startTag, endTag);
      }
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
    from = to;
  }
  return [format2, targetLocale, message3];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  let start2 = null;
  let startTag;
  let endTag;
  if (false) {
    start2 = window.performance.now();
    startTag = "intlify-message-compilation-start";
    endTag = "intlify-message-compilation-end";
    mark && mark(startTag);
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  if (false) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start2) {
      emitter.emit("message-compilation", {
        type: "message-compilation",
        message: format2,
        time: end - start2,
        groupId: `${"translate"}:${key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message compilation", startTag, endTag);
    }
  }
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  let start2 = null;
  let startTag;
  let endTag;
  if (false) {
    start2 = window.performance.now();
    startTag = "intlify-message-evaluation-start";
    endTag = "intlify-message-evaluation-end";
    mark && mark(startTag);
  }
  const messaged = msg(msgCtx);
  if (false) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start2) {
      emitter.emit("message-evaluation", {
        type: "message-evaluation",
        value: messaged,
        time: end - start2,
        groupId: `${"translate"}:${msg.key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message evaluation", startTag, endTag);
    }
  }
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options3 = {};
  if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options3.plural = arg2;
  } else if (isString$1(arg2)) {
    options3.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options3.named = arg2;
  } else if (isArray(arg2)) {
    options3.list = arg2;
  }
  if (isNumber(arg3)) {
    options3.plural = arg3;
  } else if (isString$1(arg3)) {
    options3.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$1(options3, arg3);
  }
  return [key, options3];
}
function getCompileContext(context, locale2, key, source, warnHtmlMessage, onError) {
  return {
    locale: locale2,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      if (false) {
        const _source = getSourceForCodeFrame(source);
        const message3 = `Message compilation error: ${err.message}`;
        const codeFrame = err.location && _source && generateCodeFrame(_source, err.location.start.offset, err.location.end.offset);
        const emitter = context.__v_emitter;
        if (emitter && _source) {
          emitter.emit("compile-error", {
            message: _source,
            error: err.message,
            start: err.location && err.location.start.offset,
            end: err.location && err.location.end.offset,
            groupId: `${"translate"}:${key}`
          });
        }
        console.error(codeFrame ? `${message3}
${codeFrame}` : message3);
      } else {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale2, key, source2)
  };
}
function getSourceForCodeFrame(source) {
  if (isString$1(source)) {
    return source;
  } else {
    if (source.loc && source.loc.source) {
      return source.loc.source;
    }
  }
}
function getMessageContextOptions(context, locale2, message3, options3) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message3, key);
    if (val == null && fallbackContext) {
      const [, , message22] = resolveMessageFormat(fallbackContext, key, locale2, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message22, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale2, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale: locale2,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options3.list) {
    ctxOptions.list = options3.list;
  }
  if (options3.named) {
    ctxOptions.named = options3.named;
  }
  if (isNumber(options3.plural)) {
    ctxOptions.pluralIndex = options3.plural;
  }
  return ctxOptions;
}
const intlDefined = typeof Intl !== "undefined";
const Availabilities = {
  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
  numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
};
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  if (false) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_DATE));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value3, options3, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const part = !!options3.part;
  const locale2 = getLocale(context, options3);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale2
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale2, overrides).format(value3);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "datetime format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to;
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value3) : formatter.formatToParts(value3);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options3 = {};
  let overrides = {};
  let value3;
  if (isString$1(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value3 = new Date(dateTime);
    try {
      value3.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value3 = arg1;
  } else if (isNumber(arg1)) {
    value3 = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options3.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options3[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options3.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options3.key || "", value3, options3, overrides];
}
function clearDateTimeFormat(ctx, locale2, format2) {
  const context = ctx;
  for (const key in format2) {
    const id2 = `${locale2}__${key}`;
    if (!context.__datetimeFormatters.has(id2)) {
      continue;
    }
    context.__datetimeFormatters.delete(id2);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  if (false) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value3, options3, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options3.missingWarn) ? options3.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options3.fallbackWarn) ? options3.fallbackWarn : context.fallbackWarn;
  const part = !!options3.part;
  const locale2 = getLocale(context, options3);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale2
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale2, overrides).format(value3);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  let from = locale2;
  let to = null;
  const type = "number format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = to = locales[i2];
    if (false) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (false) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to;
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value3) : formatter.formatToParts(value3);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options3 = {};
  let overrides = {};
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value3 = arg1;
  if (isString$1(arg2)) {
    options3.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options3[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options3.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options3.key || "", value3, options3, overrides];
}
function clearNumberFormat(ctx, locale2, format2) {
  const context = ctx;
  for (const key in format2) {
    const id2 = `${locale2}__${key}`;
    if (!context.__numberFormatters.has(id2)) {
      continue;
    }
    context.__numberFormatters.delete(id2);
  }
}
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.13.1";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
const I18nWarnCodes = {
  FALLBACK_TO_ROOT: code$1,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
};
const warnMessages = {
  [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
  [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
  [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
  [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
  [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,
  [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`,
  [I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION]: `'allowComposition' option will be dropped in the next major version. For more information, please see 👉 https://tinyurl.com/2p97mcze`,
  [I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: `'translateExistCompatible' option will be dropped in the next major version.`
};
function getWarnMessage(code2, ...args) {
  return format$2(warnMessages[code2], ...args);
}
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, false ? { messages: errorMessages, args } : void 0);
}
const errorMessages = {
  [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [I18nErrorCodes.INVALID_ARGUMENT]: "Invalid argument",
  [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [I18nErrorCodes.NOT_INSTALLED]: "Need to install with `app.use` function",
  [I18nErrorCodes.UNEXPECTED_ERROR]: "Unexpected error",
  [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
  [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
  [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
  [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode",
  [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
};
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const EnableEmitter = /* @__PURE__ */ makeSymbol("__enableEmitter");
const DisableEmitter = /* @__PURE__ */ makeSymbol("__disableEmitter");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
makeSymbol("__intlifyMeta");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
const __VUE_I18N_BRIDGE__ = "__VUE_I18N_BRIDGE__";
function handleFlatJson(obj) {
  if (!isObject$1(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$1(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i2 = 0; i2 < lastIndex; i2++) {
        if (!(subKeys[i2] in currentObj)) {
          currentObj[subKeys[i2]] = {};
        }
        if (!isObject$1(currentObj[subKeys[i2]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i2]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$1(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale2, options3) {
  const { messages: messages2, __i18n, messageResolver, flatJson } = options3;
  const ret = isPlainObject(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale2]: {} };
  if (isArray(__i18n)) {
    __i18n.forEach((custom2) => {
      if ("locale" in custom2 && "resource" in custom2) {
        const { locale: locale22, resource } = custom2;
        if (locale22) {
          ret[locale22] = ret[locale22] || {};
          deepCopy(resource, ret[locale22]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom2) && deepCopy(JSON.parse(custom2), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options3, componentOptions) {
  let messages2 = isObject$1(options3.messages) ? options3.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages2 = getLocaleMessages(gl.locale.value, {
      messages: messages2,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages2);
  if (locales.length) {
    locales.forEach((locale2) => {
      gl.mergeLocaleMessage(locale2, messages2[locale2]);
    });
  }
  {
    if (isObject$1(options3.datetimeFormats)) {
      const locales2 = Object.keys(options3.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale2) => {
          gl.mergeDateTimeFormat(locale2, options3.datetimeFormats[locale2]);
        });
      }
    }
    if (isObject$1(options3.numberFormats)) {
      const locales2 = Object.keys(options3.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale2) => {
          gl.mergeNumberFormat(locale2, options3.numberFormats[locale2]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale2, key, type) => {
    return missing(locale2, key, getCurrentInstance() || void 0, type);
  };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options3 = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options3;
  const _isGlobal = __root === void 0;
  const flatJson = options3.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options3.translateExistCompatible;
  if (false) {
    if (translateExistCompatible && true) {
      warnOnce(getWarnMessage(I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
    }
  }
  let _inheritLocale = isBoolean(options3.inheritLocale) ? options3.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options3.locale) ? options3.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options3));
  const _datetimeFormats = _ref(isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  let _fallbackFormat = !!options3.fallbackFormat;
  let _missing = isFunction$1(options3.missing) ? options3.missing : null;
  let _runtimeMissing = isFunction$1(options3.missing) ? defineCoreMissingHandler(options3.missing) : null;
  let _postTranslation = isFunction$1(options3.postTranslation) ? options3.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  let _escapeParameter = !!options3.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options3.modifiers) ? options3.modifiers : {};
  let _pluralRules = options3.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options3.messageResolver,
      messageCompiler: options3.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    if (false) {
      ctxOptions.__v_emitter = isPlainObject(_context) ? _context.__v_emitter : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale2 = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages2 = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction$1(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler8) {
    _postTranslation = handler8;
    _context.postTranslation = handler8;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler8) {
    if (handler8 !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler8);
    }
    _missing = handler8;
    _context.missing = _runtimeMissing;
  }
  function isResolvedTranslateMessage(type, arg) {
    return type !== "translate" || !arg.resolvedMessage;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(null);
      }
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      if (false) {
        if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
          warn(getWarnMessage(I18nWarnCodes.FALLBACK_TO_ROOT, {
            key,
            type: warnType
          }));
        }
        if (false) {
          const { __v_emitter: emitter } = _context;
          if (emitter && _fallbackRoot) {
            emitter.emit("fallback", {
              type: warnType,
              key,
              to: "global",
              groupId: `${warnType}:${key}`
            });
          }
        }
      }
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root27) => Reflect.apply(root27.t, root27, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$1(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root27) => Reflect.apply(root27.d, root27, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root27) => Reflect.apply(root27.n, root27, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize(values2) {
    return values2.map((val) => isString$1(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root27) => root27[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root27) => root27[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root27) => root27[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale22) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$1(locale22) ? locale22 : _locale.value;
      const message3 = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message3, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
    }, () => [key], "translate exists", (root27) => {
      return Reflect.apply(root27.te, root27, [key, locale22]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages22 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i2 = 0; i2 < locales.length; i2++) {
      const targetLocaleMessages = _messages.value[locales[i2]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages22 = messageValue;
        break;
      }
    }
    return messages22;
  }
  function tm(key) {
    const messages22 = resolveMessages(key);
    return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale22) {
    return _messages.value[locale22] || {};
  }
  function setLocaleMessage(locale22, message3) {
    if (flatJson) {
      const _message = { [locale22]: message3 };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message3 = _message[locale22];
    }
    _messages.value[locale22] = message3;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale22, message3) {
    _messages.value[locale22] = _messages.value[locale22] || {};
    const _message = { [locale22]: message3 };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message3 = _message[locale22];
    deepCopy(message3, _messages.value[locale22]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale22) {
    return _datetimeFormats.value[locale22] || {};
  }
  function setDateTimeFormat(locale22, format2) {
    _datetimeFormats.value[locale22] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale22, format2);
  }
  function mergeDateTimeFormat(locale22, format2) {
    _datetimeFormats.value[locale22] = assign$1(_datetimeFormats.value[locale22] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale22, format2);
  }
  function getNumberFormat(locale22) {
    return _numberFormats.value[locale22] || {};
  }
  function setNumberFormat(locale22, format2) {
    _numberFormats.value[locale22] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale22, format2);
  }
  function mergeNumberFormat(locale22, format2) {
    _numberFormats.value[locale22] = assign$1(_numberFormats.value[locale22] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale22, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale: locale2,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages: messages2,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  if (false) {
    composer[EnableEmitter] = (emitter) => {
      _context.__v_emitter = emitter;
    };
    composer[DisableEmitter] = () => {
      _context.__v_emitter = void 0;
    };
  }
  return composer;
}
function convertComposerOptions(options3) {
  const locale2 = isString$1(options3.locale) ? options3.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$1(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : locale2;
  const missing = isFunction$1(options3.missing) ? options3.missing : void 0;
  const missingWarn = isBoolean(options3.silentTranslationWarn) || isRegExp(options3.silentTranslationWarn) ? !options3.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options3.silentFallbackWarn) || isRegExp(options3.silentFallbackWarn) ? !options3.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  const fallbackFormat = !!options3.formatFallbackMessages;
  const modifiers = isPlainObject(options3.modifiers) ? options3.modifiers : {};
  const pluralizationRules = options3.pluralizationRules;
  const postTranslation = isFunction$1(options3.postTranslation) ? options3.postTranslation : void 0;
  const warnHtmlMessage = isString$1(options3.warnHtmlInMessage) ? options3.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options3.escapeParameterHtml;
  const inheritLocale = isBoolean(options3.sync) ? options3.sync : true;
  if (false) {
    warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
  }
  if (false) {
    warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  }
  let messages2 = options3.messages;
  if (isPlainObject(options3.sharedMessages)) {
    const sharedMessages = options3.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages2 = locales.reduce((messages22, locale22) => {
      const message3 = messages22[locale22] || (messages22[locale22] = {});
      assign$1(message3, sharedMessages[locale22]);
      return messages22;
    }, messages2 || {});
  }
  const { __i18n, __root, __injectWithOption } = options3;
  const datetimeFormats = options3.datetimeFormats;
  const numberFormats = options3.numberFormats;
  const flatJson = options3.flatJson;
  const translateExistCompatible = options3.translateExistCompatible;
  return {
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options3.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options3 = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options3));
    const { __extender } = options3;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler8) {
        composer.setMissingHandler(handler8);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler8) {
        composer.setPostTranslationHandler(handler8);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options22 = {};
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options22.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options22
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options22 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options22.locale = arg2;
        } else if (isNumber(arg2)) {
          options22.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString$1(arg3)) {
          options22.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options22
        ]);
      },
      // te
      te(key, locale2) {
        return composer.te(key, locale2);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale2) {
        return composer.getLocaleMessage(locale2);
      },
      // setLocaleMessage
      setLocaleMessage(locale2, message3) {
        composer.setLocaleMessage(locale2, message3);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale2, message3) {
        composer.mergeLocaleMessage(locale2, message3);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale2) {
        return composer.getDateTimeFormat(locale2);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale2, format2) {
        composer.setDateTimeFormat(locale2, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale2, format2) {
        composer.mergeDateTimeFormat(locale2, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale2) {
        return composer.getNumberFormat(locale2);
      },
      // setNumberFormat
      setNumberFormat(locale2, format2) {
        composer.setNumberFormat(locale2, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale2, format2) {
        composer.mergeNumberFormat(locale2, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    if (false) {
      vueI18n.__enableEmitter = (emitter) => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };
      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs: attrs3 } = context;
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options3 = {};
      if (props.locale) {
        options3.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options3.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options3);
      const assignedAttrs = assign$1({}, attrs3);
      const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
const I18nT = Translation;
function isVNode(target) {
  return isArray(target) && !isString$1(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs: attrs3 } = context;
  return () => {
    const options3 = { part: true };
    let overrides = {};
    if (props.locale) {
      options3.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options3.key = props.format;
    } else if (isObject$1(props.format)) {
      if (isString$1(props.format.key)) {
        options3.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options22, prop2) => {
        return slotKeys.includes(prop2) ? assign$1({}, options22, { [prop2]: props.format[prop2] }) : options22;
      }, {});
    }
    const parts2 = partFormatter(...[props.value, options3, overrides]);
    let children = [options3.key];
    if (isArray(parts2)) {
      children = parts2.map((part, index2) => {
        const slot = slots[part.type];
        const node3 = slot ? slot({ [part.type]: part.value, index: index2, parts: parts2 }) : [part.value];
        if (isVNode(node3)) {
          node3[0].key = `${part.type}-${index2}`;
        }
        return node3;
      });
    } else if (isString$1(parts2)) {
      children = [parts2];
    }
    const assignedAttrs = assign$1({}, attrs3);
    const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const I18nN = NumberFormat;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
const I18nD = DatetimeFormat;
function getComposer$2(i18n2, instance) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
function vTDirective(i18n2) {
  const _process = (binding) => {
    const { instance, modifiers, value: value3 } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance.$);
    if (false) {
      warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE));
    }
    const parsedValue = parseValue(value3);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register3 = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update2 = (el, { value: value3 }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value3);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register3,
    unmounted: unregister,
    beforeUpdate: update2,
    getSSRProps
  };
}
function parseValue(value3) {
  if (isString$1(value3)) {
    return { path: value3 };
  } else if (isPlainObject(value3)) {
    if (!("path" in value3)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value3;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value3) {
  const { path, locale: locale2, args, choice, plural } = value3;
  const options3 = {};
  const named = args || {};
  if (isString$1(locale2)) {
    options3.locale = locale2;
  }
  if (isNumber(choice)) {
    options3.plural = choice;
  }
  if (isNumber(plural)) {
    options3.plural = plural;
  }
  return [path, named, options3];
}
function apply(app2, i18n2, ...options3) {
  const pluginOptions = isPlainObject(options3[0]) ? options3[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (false) {
    warn(getWarnMessage(I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE, {
      name: Translation.name
    }));
  }
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
const VueDevToolsLabels = {
  [
    "vue-devtools-plugin-vue-i18n"
    /* VueDevToolsIDs.PLUGIN */
  ]: "Vue I18n devtools",
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "I18n Resources",
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: "Vue I18n"
};
const VueDevToolsPlaceholders = {
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "Search for scopes ..."
};
const VueDevToolsTimelineColors = {
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: 16764185
};
const VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
let devtoolsApi;
function enableDevTools(app2, i18n2) {
  return __async(this, null, function* () {
    return new Promise((resolve8, reject2) => {
      try {
        setupDevtoolsPlugin({
          id: "vue-devtools-plugin-vue-i18n",
          label: VueDevToolsLabels[
            "vue-devtools-plugin-vue-i18n"
            /* VueDevToolsIDs.PLUGIN */
          ],
          packageName: "vue-i18n",
          homepage: "https://vue-i18n.intlify.dev",
          logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
          componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
          app: app2
          // eslint-disable-line @typescript-eslint/no-explicit-any
        }, (api2) => {
          devtoolsApi = api2;
          api2.on.visitComponentTree(({ componentInstance, treeNode }) => {
            updateComponentTreeTags(componentInstance, treeNode, i18n2);
          });
          api2.on.inspectComponent(({ componentInstance, instanceData }) => {
            if (componentInstance.vnode.el && componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
              if (i18n2.mode === "legacy") {
                if (componentInstance.vnode.el.__VUE_I18N__ !== i18n2.global.__composer) {
                  inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
                }
              } else {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            }
          });
          api2.addInspector({
            id: "vue-i18n-resource-inspector",
            label: VueDevToolsLabels[
              "vue-i18n-resource-inspector"
              /* VueDevToolsIDs.CUSTOM_INSPECTOR */
            ],
            icon: "language",
            treeFilterPlaceholder: VueDevToolsPlaceholders[
              "vue-i18n-resource-inspector"
              /* VueDevToolsIDs.CUSTOM_INSPECTOR */
            ]
          });
          api2.on.getInspectorTree((payload) => {
            if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
              registerScope(payload, i18n2);
            }
          });
          const roots = /* @__PURE__ */ new Map();
          api2.on.getInspectorState((payload) => __async(this, null, function* () {
            if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
              api2.unhighlightElement();
              inspectScope(payload, i18n2);
              if (payload.nodeId === "global") {
                if (!roots.has(payload.app)) {
                  const [root27] = yield api2.getComponentInstances(payload.app);
                  roots.set(payload.app, root27);
                }
                api2.highlightElement(roots.get(payload.app));
              } else {
                const instance = getComponentInstance(payload.nodeId, i18n2);
                instance && api2.highlightElement(instance);
              }
            }
          }));
          api2.on.editInspectorState((payload) => {
            if (payload.app === app2 && payload.inspectorId === "vue-i18n-resource-inspector") {
              editScope(payload, i18n2);
            }
          });
          api2.addTimelineLayer({
            id: "vue-i18n-timeline",
            label: VueDevToolsLabels[
              "vue-i18n-timeline"
              /* VueDevToolsIDs.TIMELINE */
            ],
            color: VueDevToolsTimelineColors[
              "vue-i18n-timeline"
              /* VueDevToolsIDs.TIMELINE */
            ]
          });
          resolve8(true);
        });
      } catch (e) {
        console.error(e);
        reject2(false);
      }
    });
  });
}
function getI18nScopeLable(instance) {
  return instance.type.name || instance.type.displayName || instance.type.__file || "Anonymous";
}
function updateComponentTreeTags(instance, treeNode, i18n2) {
  const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {
    if (instance.vnode.el.__VUE_I18N__ !== global2) {
      const tag = {
        label: `i18n (${getI18nScopeLable(instance)} Scope)`,
        textColor: 0,
        backgroundColor: 16764185
      };
      treeNode.tags.push(tag);
    }
  }
}
function inspectComposer(instanceData, composer) {
  const type = VUE_I18N_COMPONENT_TYPES;
  instanceData.state.push({
    type,
    key: "locale",
    editable: true,
    value: composer.locale.value
  });
  instanceData.state.push({
    type,
    key: "availableLocales",
    editable: false,
    value: composer.availableLocales
  });
  instanceData.state.push({
    type,
    key: "fallbackLocale",
    editable: true,
    value: composer.fallbackLocale.value
  });
  instanceData.state.push({
    type,
    key: "inheritLocale",
    editable: true,
    value: composer.inheritLocale
  });
  instanceData.state.push({
    type,
    key: "messages",
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  });
  {
    instanceData.state.push({
      type,
      key: "datetimeFormats",
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: "numberFormats",
      editable: false,
      value: composer.numberFormats.value
    });
  }
}
function getLocaleMessageValue(messages2) {
  const value3 = {};
  Object.keys(messages2).forEach((key) => {
    const v2 = messages2[key];
    if (isFunction$1(v2) && "source" in v2) {
      value3[key] = getMessageFunctionDetails(v2);
    } else if (isMessageAST(v2) && v2.loc && v2.loc.source) {
      value3[key] = v2.loc.source;
    } else if (isObject$1(v2)) {
      value3[key] = getLocaleMessageValue(v2);
    } else {
      value3[key] = v2;
    }
  });
  return value3;
}
const ESC = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function escape$1(s) {
  return s.replace(/[<>"&]/g, escapeChar);
}
function escapeChar(a) {
  return ESC[a] || a;
}
function getMessageFunctionDetails(func) {
  const argString = func.source ? `("${escape$1(func.source)}")` : `(?)`;
  return {
    _custom: {
      type: "function",
      display: `<span>ƒ</span> ${argString}`
    }
  };
}
function registerScope(payload, i18n2) {
  payload.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  for (const [keyInstance, instance] of i18n2.__instances) {
    const composer = i18n2.mode === "composition" ? instance : instance.__composer;
    if (global2 === composer) {
      continue;
    }
    payload.rootNodes.push({
      id: composer.id.toString(),
      label: `${getI18nScopeLable(keyInstance)} Scope`
    });
  }
}
function getComponentInstance(nodeId, i18n2) {
  let instance = null;
  if (nodeId !== "global") {
    for (const [component, composer] of i18n2.__instances.entries()) {
      if (composer.id.toString() === nodeId) {
        instance = component;
        break;
      }
    }
  }
  return instance;
}
function getComposer$1(nodeId, i18n2) {
  if (nodeId === "global") {
    return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  } else {
    const instance = Array.from(i18n2.__instances.values()).find((item) => item.id.toString() === nodeId);
    if (instance) {
      return i18n2.mode === "composition" ? instance : instance.__composer;
    } else {
      return null;
    }
  }
}
function inspectScope(payload, i18n2) {
  const composer = getComposer$1(payload.nodeId, i18n2);
  if (composer) {
    payload.state = makeScopeInspectState(composer);
  }
  return null;
}
function makeScopeInspectState(composer) {
  const state = {};
  const localeType = "Locale related info";
  const localeStates = [
    {
      type: localeType,
      key: "locale",
      editable: true,
      value: composer.locale.value
    },
    {
      type: localeType,
      key: "fallbackLocale",
      editable: true,
      value: composer.fallbackLocale.value
    },
    {
      type: localeType,
      key: "availableLocales",
      editable: false,
      value: composer.availableLocales
    },
    {
      type: localeType,
      key: "inheritLocale",
      editable: true,
      value: composer.inheritLocale
    }
  ];
  state[localeType] = localeStates;
  const localeMessagesType = "Locale messages info";
  const localeMessagesStates = [
    {
      type: localeMessagesType,
      key: "messages",
      editable: false,
      value: getLocaleMessageValue(composer.messages.value)
    }
  ];
  state[localeMessagesType] = localeMessagesStates;
  {
    const datetimeFormatsType = "Datetime formats info";
    const datetimeFormatsStates = [
      {
        type: datetimeFormatsType,
        key: "datetimeFormats",
        editable: false,
        value: composer.datetimeFormats.value
      }
    ];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = "Datetime formats info";
    const numberFormatsStates = [
      {
        type: numberFormatsType,
        key: "numberFormats",
        editable: false,
        value: composer.numberFormats.value
      }
    ];
    state[numberFormatsType] = numberFormatsStates;
  }
  return state;
}
function addTimelineEvent(event2, payload) {
  if (devtoolsApi) {
    let groupId;
    if (payload && "groupId" in payload) {
      groupId = payload.groupId;
      delete payload.groupId;
    }
    devtoolsApi.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: event2,
        groupId,
        time: Date.now(),
        meta: {},
        data: payload || {},
        logType: event2 === "compile-error" ? "error" : event2 === "fallback" || event2 === "missing" ? "warning" : "default"
      }
    });
  }
}
function editScope(payload, i18n2) {
  const composer = getComposer$1(payload.nodeId, i18n2);
  if (composer) {
    const [field2] = payload.path;
    if (field2 === "locale" && isString$1(payload.state.value)) {
      composer.locale.value = payload.state.value;
    } else if (field2 === "fallbackLocale" && (isString$1(payload.state.value) || isArray(payload.state.value) || isObject$1(payload.state.value))) {
      composer.fallbackLocale.value = payload.state.value;
    } else if (field2 === "inheritLocale" && isBoolean(payload.state.value)) {
      composer.inheritLocale = payload.state.value;
    }
  }
}
function defineMixin(vuei18n, composer, i18n2) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options3 = this.$options;
      if (options3.i18n) {
        const optionsI18n = options3.i18n;
        if (options3.__i18n) {
          optionsI18n.__i18n = options3.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n2.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options3.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options3);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options3.__i18n,
            __injectWithOption: true,
            __extender: i18n2.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options3.__i18nGlobal) {
        adjustI18nResources(composer, options3, options3);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale2) => this.$i18n.te(key, locale2);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n2.__setInstance(instance, this.$i18n);
    },
    mounted() {
      if (false) {
        const _vueI18n = this.$i18n;
        this.$el.__VUE_I18N__ = _vueI18n.__composer;
        const emitter = this.__v_emitter = createEmitter();
        _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
        emitter.on("*", addTimelineEvent);
      }
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      if (false) {
        if (this.__v_emitter) {
          this.__v_emitter.off("*", addTimelineEvent);
          delete this.__v_emitter;
        }
        if (this.$i18n) {
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
      }
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n2.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g, options3) {
  g.locale = options3.locale || g.locale;
  g.fallbackLocale = options3.fallbackLocale || g.fallbackLocale;
  g.missing = options3.missing || g.missing;
  g.silentTranslationWarn = options3.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options3.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options3.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options3.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options3.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options3.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options3.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options3.pluralizationRules || g.pluralizationRules);
  const messages2 = getLocaleMessages(g.locale, {
    messages: options3.messages,
    __i18n: options3.__i18n
  });
  Object.keys(messages2).forEach((locale2) => g.mergeLocaleMessage(locale2, messages2[locale2]));
  if (options3.datetimeFormats) {
    Object.keys(options3.datetimeFormats).forEach((locale2) => g.mergeDateTimeFormat(locale2, options3.datetimeFormats[locale2]));
  }
  if (options3.numberFormats) {
    Object.keys(options3.numberFormats).forEach((locale2) => g.mergeNumberFormat(locale2, options3.numberFormats[locale2]));
  }
  return g;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options3 = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options3.legacy) ? options3.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options3.globalInjection) ? options3.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options3.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options3, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol(false ? "vue-i18n" : "");
  if (false) {
    if (__legacyMode && __allowComposition && true) {
      warn(getWarnMessage(I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION));
    }
  }
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    let _a2;
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      install(app2, ...options22) {
        return __async(this, null, function* () {
          if (false) {
            app2.__VUE_I18N__ = i18n2;
          }
          app2.__VUE_I18N_SYMBOL__ = symbol;
          app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
          if (isPlainObject(options22[0])) {
            const opts = options22[0];
            i18n2.__composerExtend = opts.__composerExtend;
            i18n2.__vueI18nExtend = opts.__vueI18nExtend;
          }
          let globalReleaseHandler = null;
          if (!__legacyMode && __globalInjection) {
            globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
          }
          if (__VUE_I18N_FULL_INSTALL__) {
            apply(app2, i18n2, ...options22);
          }
          if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
            app2.mixin(defineMixin(__global, __global.__composer, i18n2));
          }
          const unmountApp = app2.unmount;
          app2.unmount = () => {
            globalReleaseHandler && globalReleaseHandler();
            i18n2.dispose();
            unmountApp();
          };
          if (false) {
            const ret = yield enableDevTools(app2, i18n2);
            if (!ret) {
              throw createI18nError(I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
            }
            const emitter = createEmitter();
            if (__legacyMode) {
              const _vueI18n = __global;
              _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
            } else {
              const _composer = __global;
              _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
            }
            emitter.on("*", addTimelineEvent);
          }
        });
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
function useI18n(options3 = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options3, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n2.mode === "legacy" && !options3.__useComponent) {
      if (!i18n2.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options3);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options3, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance, options3.__useComponent);
    if (composer2 == null) {
      if (false) {
        warn(getWarnMessage(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
      }
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$1({}, options3);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
const castToVueI18n = /* @__NO_SIDE_EFFECTS__ */ (i18n2) => {
  if (!(__VUE_I18N_BRIDGE__ in i18n2)) {
    throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
  }
  return i18n2;
};
function createGlobal(options3, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options3)) : scope.run(() => createComposer(options3));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
function getScope(options3, componentOptions) {
  return isEmptyObject(options3) ? "__i18n" in componentOptions ? "local" : "global" : !options3.useScope ? "local" : options3.useScope;
}
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target, useComponent = false) {
  let composer = null;
  const root27 = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root27 === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n2, target, composer) {
  let emitter = null;
  {
    onMounted(() => {
      if (false) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter();
        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on("*", addTimelineEvent);
      }
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      if (false) {
        emitter && emitter.off("*", addTimelineEvent);
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }
      i18n2.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root27, options3 = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options3.inheritLocale) ? options3.inheritLocale : !isString$1(options3.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root27.locale.value : isString$1(options3.locale) ? options3.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root27.fallbackLocale.value : isString$1(options3.fallbackLocale) || isArray(options3.fallbackLocale) || isPlainObject(options3.fallbackLocale) || options3.fallbackLocale === false ? options3.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options3));
  const _datetimeFormats = ref(isPlainObject(options3.datetimeFormats) ? options3.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options3.numberFormats) ? options3.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root27.missingWarn : isBoolean(options3.missingWarn) || isRegExp(options3.missingWarn) ? options3.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root27.fallbackWarn : isBoolean(options3.fallbackWarn) || isRegExp(options3.fallbackWarn) ? options3.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root27.fallbackRoot : isBoolean(options3.fallbackRoot) ? options3.fallbackRoot : true;
  const _fallbackFormat = !!options3.fallbackFormat;
  const _missing = isFunction$1(options3.missing) ? options3.missing : null;
  const _postTranslation = isFunction$1(options3.postTranslation) ? options3.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root27.warnHtmlMessage : isBoolean(options3.warnHtmlMessage) ? options3.warnHtmlMessage : true;
  const _escapeParameter = !!options3.escapeParameter;
  const _modifiers = isLocalScope ? root27.modifiers : isPlainObject(options3.modifiers) ? options3.modifiers : {};
  const _pluralRules = options3.pluralRules || isLocalScope && root27.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale2 = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages2 = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler8) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler8);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler8) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler8);
    }
  }
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale22) {
    return _composer.value ? _composer.value.te(key, locale22) : false;
  }
  function getLocaleMessage(locale22) {
    return _composer.value ? _composer.value.getLocaleMessage(locale22) : {};
  }
  function setLocaleMessage(locale22, message3) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale22, message3);
      _messages.value[locale22] = message3;
    }
  }
  function mergeLocaleMessage(locale22, message3) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale22, message3);
    }
  }
  function getDateTimeFormat(locale22) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale22) : {};
  }
  function setDateTimeFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale22, format2);
      _datetimeFormats.value[locale22] = format2;
    }
  }
  function mergeDateTimeFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale22, format2);
    }
  }
  function getNumberFormat(locale22) {
    return _composer.value ? _composer.value.getNumberFormat(locale22) : {};
  }
  function setNumberFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale22, format2);
      _numberFormats.value[locale22] = format2;
    }
  }
  function mergeNumberFormat(locale22, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale22, format2);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale22) => {
      composer.mergeLocaleMessage(locale22, _messages.value[locale22]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale22) => {
      composer.mergeDateTimeFormat(locale22, _datetimeFormats.value[locale22]);
    });
    Object.keys(_numberFormats.value).forEach((locale22) => {
      composer.mergeNumberFormat(locale22, _numberFormats.value[locale22]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop2) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop2);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop2, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
if (false) ;
var theme$1 = function theme34(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-tree {\n    background: ".concat(dt3("tree.background"), ";\n    color: ").concat(dt3("tree.color"), ";\n    padding: ").concat(dt3("tree.padding"), ";\n}\n\n.p-tree-root-children,\n.p-tree-node-children {\n    display: flex;\n    list-style-type: none;\n    flex-direction: column;\n    margin: 0;\n    gap: ").concat(dt3("tree.gap"), ";\n}\n\n.p-tree-root-children {\n    padding: ").concat(dt3("tree.gap"), " 0 0 0;\n}\n\n.p-tree-node-children {\n    padding: ").concat(dt3("tree.gap"), " 0 0 ").concat(dt3("tree.indent"), ";\n}\n\n.p-tree-node {\n    padding: 0;\n    outline: 0 none;\n}\n\n.p-tree-node-content {\n    border-radius: ").concat(dt3("tree.node.border.radius"), ";\n    padding: ").concat(dt3("tree.node.padding"), ";\n    display: flex;\n    align-items: center;\n    outline-color: transparent;\n    color: ").concat(dt3("tree.node.color"), ";\n    gap: ").concat(dt3("tree.node.gap"), ";\n    transition: background ").concat(dt3("tree.transition.duration"), ", color ").concat(dt3("tree.transition.duration"), ", outline-color ").concat(dt3("tree.transition.duration"), ", box-shadow ").concat(dt3("tree.transition.duration"), ";\n}\n\n.p-tree-node:focus-visible > .p-tree-node-content {\n    box-shadow: ").concat(dt3("tree.node.focus.ring.shadow"), ";\n    outline: ").concat(dt3("tree.node.focus.ring.width"), " ").concat(dt3("tree.node.focus.ring.style"), " ").concat(dt3("tree.node.focus.ring.color"), ";\n    outline-offset: ").concat(dt3("tree.node.focus.ring.offset"), ";\n}\n\n.p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover {\n    background: ").concat(dt3("tree.node.hover.background"), ";\n    color: ").concat(dt3("tree.node.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover .p-tree-node-icon {\n    color: ").concat(dt3("tree.node.icon.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected {\n    background: ").concat(dt3("tree.node.selected.background"), ";\n    color: ").concat(dt3("tree.node.selected.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button {\n    color: inherit;\n}\n\n.p-tree-node-toggle-button {\n    cursor: pointer;\n    user-select: none;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n    flex-shrink: 0;\n    width: ").concat(dt3("tree.node.toggle.button.size"), ";\n    height: ").concat(dt3("tree.node.toggle.button.size"), ";\n    color: ").concat(dt3("tree.node.toggle.button.color"), ";\n    border: 0 none;\n    background: transparent;\n    border-radius: ").concat(dt3("tree.node.toggle.button.border.radius"), ";\n    transition: background ").concat(dt3("tree.transition.duration"), ", color ").concat(dt3("tree.transition.duration"), ", border-color ").concat(dt3("tree.transition.duration"), ", outline-color ").concat(dt3("tree.transition.duration"), ", box-shadow ").concat(dt3("tree.transition.duration"), ";\n    outline-color: transparent;\n    padding: 0;\n}\n\n.p-tree-node-toggle-button:enabled:hover {\n    background: ").concat(dt3("tree.node.toggle.button.hover.background"), ";\n    color: ").concat(dt3("tree.node.toggle.button.hover.color"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button:hover {\n    background: ").concat(dt3("tree.node.toggle.button.selected.hover.background"), ";\n    color: ").concat(dt3("tree.node.toggle.button.selected.hover.color"), ";\n}\n\n.p-tree-root {\n    overflow: auto;\n}\n\n.p-tree-node-selectable {\n    cursor: pointer;\n    user-select: none;\n}\n\n.p-tree-node-leaf > .p-tree-node-content .p-tree-node-toggle-button {\n    visibility: hidden;\n}\n\n.p-tree-node-icon {\n    color: ").concat(dt3("tree.node.icon.color"), ";\n    transition: color ").concat(dt3("tree.transition.duration"), ";\n}\n\n.p-tree-node-content.p-tree-node-selected .p-tree-node-icon {\n    color: ").concat(dt3("tree.node.icon.selected.color"), ";\n}\n\n.p-tree-filter-input {\n    width: 100%;\n}\n\n.p-tree-loading {\n    position: relative;\n    height: 100%;\n}\n\n.p-tree-loading-icon {\n    font-size: ").concat(dt3("tree.loading.icon.size"), ";\n    width: ").concat(dt3("tree.loading.icon.size"), ";\n    height: ").concat(dt3("tree.loading.icon.size"), ";\n}\n\n.p-tree .p-tree-mask {\n    position: absolute;\n    z-index: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-tree-flex-scrollable {\n    display: flex;\n    flex: 1;\n    height: 100%;\n    flex-direction: column;\n}\n\n.p-tree-flex-scrollable .p-tree-root {\n    flex: 1;\n}\n");
};
var classes$1 = {
  root: function root26(_ref2) {
    var props = _ref2.props;
    return ["p-tree p-component", {
      "p-tree-selectable": props.selectionMode != null,
      "p-tree-loading": props.loading,
      "p-tree-flex-scrollable": props.scrollHeight === "flex"
    }];
  },
  mask: "p-tree-mask p-overlay-mask",
  loadingIcon: "p-tree-loading-icon",
  pcFilterInput: "p-tree-filter-input",
  wrapper: "p-tree-root",
  //TODO: discuss
  rootChildren: "p-tree-root-children",
  node: function node2(_ref3) {
    var instance = _ref3.instance;
    return ["p-tree-node", {
      "p-tree-node-leaf": instance.leaf
    }];
  },
  nodeContent: function nodeContent(_ref4) {
    var instance = _ref4.instance;
    return ["p-tree-node-content", instance.node.styleClass, {
      "p-tree-node-selectable": instance.selectable,
      "p-tree-node-selected": instance.checkboxMode && instance.$parentInstance.highlightOnSelect ? instance.checked : instance.selected
    }];
  },
  nodeToggleButton: "p-tree-node-toggle-button",
  nodeToggleIcon: "p-tree-node-toggle-icon",
  nodeCheckbox: "p-tree-node-checkbox",
  nodeIcon: "p-tree-node-icon",
  nodeLabel: "p-tree-node-label",
  nodeChildren: "p-tree-node-children"
};
var TreeStyle = BaseStyle.extend({
  name: "tree",
  theme: theme$1,
  classes: classes$1
});
var script$2 = {
  name: "BaseTree",
  "extends": script$1a,
  props: {
    value: {
      type: null,
      "default": null
    },
    expandedKeys: {
      type: null,
      "default": null
    },
    selectionKeys: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    metaKeySelection: {
      type: Boolean,
      "default": false
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    loadingMode: {
      type: String,
      "default": "mask"
    },
    filter: {
      type: Boolean,
      "default": false
    },
    filterBy: {
      type: String,
      "default": "label"
    },
    filterMode: {
      type: String,
      "default": "lenient"
    },
    filterPlaceholder: {
      type: String,
      "default": null
    },
    filterLocale: {
      type: String,
      "default": void 0
    },
    highlightOnSelect: {
      type: Boolean,
      "default": false
    },
    scrollHeight: {
      type: String,
      "default": null
    },
    level: {
      type: Number,
      "default": 0
    },
    ariaLabelledby: {
      type: String,
      "default": null
    },
    ariaLabel: {
      type: String,
      "default": null
    }
  },
  style: TreeStyle,
  provide: function provide41() {
    return {
      $pcTree: this,
      $parentInstance: this
    };
  }
};
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
function _createForOfIteratorHelper$1(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  } };
}
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$1(e, r, t) {
  return (r = _toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey$1(t) {
  var i2 = _toPrimitive$1(t, "string");
  return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
}
function _toPrimitive$1(t, r) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toConsumableArray$1(r) {
  return _arrayWithoutHoles$1(r) || _iterableToArray$1(r) || _unsupportedIterableToArray$1(r) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
  }
}
function _iterableToArray$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$1(r);
}
function _arrayLikeToArray$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var script$1$1 = {
  name: "TreeNode",
  hostName: "Tree",
  "extends": script$1a,
  emits: ["node-toggle", "node-click", "checkbox-change"],
  props: {
    node: {
      type: null,
      "default": null
    },
    expandedKeys: {
      type: null,
      "default": null
    },
    loadingMode: {
      type: String,
      "default": "mask"
    },
    selectionKeys: {
      type: null,
      "default": null
    },
    selectionMode: {
      type: String,
      "default": null
    },
    templates: {
      type: null,
      "default": null
    },
    level: {
      type: Number,
      "default": null
    },
    index: null
  },
  nodeTouched: false,
  toggleClicked: false,
  mounted: function mounted23() {
    this.setAllNodesTabIndexes();
  },
  methods: {
    toggle: function toggle() {
      this.$emit("node-toggle", this.node);
      this.toggleClicked = true;
    },
    label: function label4(node3) {
      return typeof node3.label === "function" ? node3.label() : node3.label;
    },
    onChildNodeToggle: function onChildNodeToggle(node3) {
      this.$emit("node-toggle", node3);
    },
    getPTOptions: function getPTOptions17(key) {
      return this.ptm(key, {
        context: {
          index: this.index,
          expanded: this.expanded,
          selected: this.selected,
          checked: this.checked,
          leaf: this.leaf
        }
      });
    },
    onClick: function onClick4(event2) {
      if (this.toggleClicked || getAttribute(event2.target, '[data-pc-section="nodetogglebutton"]') || getAttribute(event2.target.parentElement, '[data-pc-section="nodetogglebutton"]')) {
        this.toggleClicked = false;
        return;
      }
      if (this.isCheckboxSelectionMode()) {
        this.toggleCheckbox();
      } else {
        this.$emit("node-click", {
          originalEvent: event2,
          nodeTouched: this.nodeTouched,
          node: this.node
        });
      }
      this.nodeTouched = false;
    },
    onChildNodeClick: function onChildNodeClick(event2) {
      this.$emit("node-click", event2);
    },
    onTouchEnd: function onTouchEnd() {
      this.nodeTouched = true;
    },
    onKeyDown: function onKeyDown7(event2) {
      if (!this.isSameNode(event2)) return;
      switch (event2.code) {
        case "Tab":
          this.onTabKey(event2);
          break;
        case "ArrowDown":
          this.onArrowDown(event2);
          break;
        case "ArrowUp":
          this.onArrowUp(event2);
          break;
        case "ArrowRight":
          this.onArrowRight(event2);
          break;
        case "ArrowLeft":
          this.onArrowLeft(event2);
          break;
        case "Enter":
        case "NumpadEnter":
        case "Space":
          this.onEnterKey(event2);
          break;
      }
    },
    onArrowDown: function onArrowDown(event2) {
      var nodeElement = event2.target.getAttribute("data-pc-section") === "nodetogglebutton" ? event2.target.closest('[role="treeitem"]') : event2.target;
      var listElement = nodeElement.children[1];
      if (listElement) {
        this.focusRowChange(nodeElement, listElement.children[0]);
      } else {
        if (nodeElement.nextElementSibling) {
          this.focusRowChange(nodeElement, nodeElement.nextElementSibling);
        } else {
          var nextSiblingAncestor = this.findNextSiblingOfAncestor(nodeElement);
          if (nextSiblingAncestor) {
            this.focusRowChange(nodeElement, nextSiblingAncestor);
          }
        }
      }
      event2.preventDefault();
    },
    onArrowUp: function onArrowUp(event2) {
      var nodeElement = event2.target;
      if (nodeElement.previousElementSibling) {
        this.focusRowChange(nodeElement, nodeElement.previousElementSibling, this.findLastVisibleDescendant(nodeElement.previousElementSibling));
      } else {
        var parentNodeElement = this.getParentNodeElement(nodeElement);
        if (parentNodeElement) {
          this.focusRowChange(nodeElement, parentNodeElement);
        }
      }
      event2.preventDefault();
    },
    onArrowRight: function onArrowRight(event2) {
      var _this = this;
      if (this.leaf || this.expanded) return;
      event2.currentTarget.tabIndex = -1;
      this.$emit("node-toggle", this.node);
      this.$nextTick(function() {
        _this.onArrowDown(event2);
      });
    },
    onArrowLeft: function onArrowLeft(event2) {
      var togglerElement = findSingle(event2.currentTarget, '[data-pc-section="nodetogglebutton"]');
      if (this.level === 0 && !this.expanded) {
        return false;
      }
      if (this.expanded && !this.leaf) {
        togglerElement.click();
        return false;
      }
      var target = this.findBeforeClickableNode(event2.currentTarget);
      if (target) {
        this.focusRowChange(event2.currentTarget, target);
      }
    },
    onEnterKey: function onEnterKey5(event2) {
      this.setTabIndexForSelectionMode(event2, this.nodeTouched);
      this.onClick(event2);
      event2.preventDefault();
    },
    onTabKey: function onTabKey4() {
      this.setAllNodesTabIndexes();
    },
    setAllNodesTabIndexes: function setAllNodesTabIndexes() {
      var nodes = find(this.$refs.currentNode.closest('[data-pc-section="rootchildren"]'), '[role="treeitem"]');
      var hasSelectedNode = _toConsumableArray$1(nodes).some(function(node3) {
        return node3.getAttribute("aria-selected") === "true" || node3.getAttribute("aria-checked") === "true";
      });
      _toConsumableArray$1(nodes).forEach(function(node3) {
        node3.tabIndex = -1;
      });
      if (hasSelectedNode) {
        var selectedNodes = _toConsumableArray$1(nodes).filter(function(node3) {
          return node3.getAttribute("aria-selected") === "true" || node3.getAttribute("aria-checked") === "true";
        });
        selectedNodes[0].tabIndex = 0;
        return;
      }
      _toConsumableArray$1(nodes)[0].tabIndex = 0;
    },
    setTabIndexForSelectionMode: function setTabIndexForSelectionMode(event2, nodeTouched) {
      if (this.selectionMode !== null) {
        var elements = _toConsumableArray$1(find(this.$refs.currentNode.parentElement, '[role="treeitem"]'));
        event2.currentTarget.tabIndex = nodeTouched === false ? -1 : 0;
        if (elements.every(function(element) {
          return element.tabIndex === -1;
        })) {
          elements[0].tabIndex = 0;
        }
      }
    },
    focusRowChange: function focusRowChange2(firstFocusableRow, currentFocusedRow, lastVisibleDescendant) {
      firstFocusableRow.tabIndex = "-1";
      currentFocusedRow.tabIndex = "0";
      this.focusNode(lastVisibleDescendant || currentFocusedRow);
    },
    findBeforeClickableNode: function findBeforeClickableNode(node3) {
      var parentListElement = node3.closest("ul").closest("li");
      if (parentListElement) {
        var prevNodeButton = findSingle(parentListElement, "button");
        if (prevNodeButton && prevNodeButton.style.visibility !== "hidden") {
          return parentListElement;
        }
        return this.findBeforeClickableNode(node3.previousElementSibling);
      }
      return null;
    },
    toggleCheckbox: function toggleCheckbox() {
      var _selectionKeys = this.selectionKeys ? _objectSpread$1({}, this.selectionKeys) : {};
      var _check = !this.checked;
      this.propagateDown(this.node, _check, _selectionKeys);
      this.$emit("checkbox-change", {
        node: this.node,
        check: _check,
        selectionKeys: _selectionKeys
      });
    },
    propagateDown: function propagateDown(node3, check, selectionKeys) {
      if (check) selectionKeys[node3.key] = {
        checked: true,
        partialChecked: false
      };
      else delete selectionKeys[node3.key];
      if (node3.children && node3.children.length) {
        var _iterator = _createForOfIteratorHelper$1(node3.children), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var child = _step.value;
            this.propagateDown(child, check, selectionKeys);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    },
    propagateUp: function propagateUp(event2) {
      var check = event2.check;
      var _selectionKeys = _objectSpread$1({}, event2.selectionKeys);
      var checkedChildCount = 0;
      var childPartialSelected = false;
      var _iterator2 = _createForOfIteratorHelper$1(this.node.children), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var child = _step2.value;
          if (_selectionKeys[child.key] && _selectionKeys[child.key].checked) checkedChildCount++;
          else if (_selectionKeys[child.key] && _selectionKeys[child.key].partialChecked) childPartialSelected = true;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (check && checkedChildCount === this.node.children.length) {
        _selectionKeys[this.node.key] = {
          checked: true,
          partialChecked: false
        };
      } else {
        if (!check) {
          delete _selectionKeys[this.node.key];
        }
        if (childPartialSelected || checkedChildCount > 0 && checkedChildCount !== this.node.children.length) _selectionKeys[this.node.key] = {
          checked: false,
          partialChecked: true
        };
        else delete _selectionKeys[this.node.key];
      }
      this.$emit("checkbox-change", {
        node: event2.node,
        check: event2.check,
        selectionKeys: _selectionKeys
      });
    },
    onChildCheckboxChange: function onChildCheckboxChange(event2) {
      this.$emit("checkbox-change", event2);
    },
    findNextSiblingOfAncestor: function findNextSiblingOfAncestor(nodeElement) {
      var parentNodeElement = this.getParentNodeElement(nodeElement);
      if (parentNodeElement) {
        if (parentNodeElement.nextElementSibling) return parentNodeElement.nextElementSibling;
        else return this.findNextSiblingOfAncestor(parentNodeElement);
      } else {
        return null;
      }
    },
    findLastVisibleDescendant: function findLastVisibleDescendant(nodeElement) {
      var childrenListElement = nodeElement.children[1];
      if (childrenListElement) {
        var lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];
        return this.findLastVisibleDescendant(lastChildElement);
      } else {
        return nodeElement;
      }
    },
    getParentNodeElement: function getParentNodeElement(nodeElement) {
      var parentNodeElement = nodeElement.parentElement.parentElement;
      return getAttribute(parentNodeElement, "role") === "treeitem" ? parentNodeElement : null;
    },
    focusNode: function focusNode(element) {
      element.focus();
    },
    isCheckboxSelectionMode: function isCheckboxSelectionMode() {
      return this.selectionMode === "checkbox";
    },
    isSameNode: function isSameNode(event2) {
      return event2.currentTarget && (event2.currentTarget.isSameNode(event2.target) || event2.currentTarget.isSameNode(event2.target.closest('[role="treeitem"]')));
    }
  },
  computed: {
    hasChildren: function hasChildren() {
      return this.node.children && this.node.children.length > 0;
    },
    expanded: function expanded() {
      return this.expandedKeys && this.expandedKeys[this.node.key] === true;
    },
    leaf: function leaf() {
      return this.node.leaf === false ? false : !(this.node.children && this.node.children.length);
    },
    selectable: function selectable() {
      return this.node.selectable === false ? false : this.selectionMode != null;
    },
    selected: function selected() {
      return this.selectionMode && this.selectionKeys ? this.selectionKeys[this.node.key] === true : false;
    },
    checkboxMode: function checkboxMode() {
      return this.selectionMode === "checkbox" && this.node.selectable !== false;
    },
    checked: function checked4() {
      return this.selectionKeys ? this.selectionKeys[this.node.key] && this.selectionKeys[this.node.key].checked : false;
    },
    partialChecked: function partialChecked() {
      return this.selectionKeys ? this.selectionKeys[this.node.key] && this.selectionKeys[this.node.key].partialChecked : false;
    },
    ariaChecked: function ariaChecked() {
      return this.selectionMode === "single" || this.selectionMode === "multiple" ? this.selected : void 0;
    },
    ariaSelected: function ariaSelected() {
      return this.checkboxMode ? this.checked : void 0;
    }
  },
  components: {
    Checkbox: script$m,
    ChevronDownIcon: script$P,
    ChevronRightIcon: script$q,
    CheckIcon: script$11,
    MinusIcon: script$n,
    SpinnerIcon: script$14
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$1$1 = ["aria-label", "aria-selected", "aria-expanded", "aria-setsize", "aria-posinset", "aria-level", "aria-checked", "tabindex"];
var _hoisted_2$2 = ["data-p-selected", "data-p-selectable"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_Checkbox = resolveComponent("Checkbox");
  var _component_TreeNode = resolveComponent("TreeNode", true);
  var _directive_ripple = resolveDirective("ripple");
  return openBlock(), createElementBlock("li", mergeProps({
    ref: "currentNode",
    "class": _ctx.cx("node"),
    role: "treeitem",
    "aria-label": $options.label($props.node),
    "aria-selected": $options.ariaSelected,
    "aria-expanded": $options.expanded,
    "aria-setsize": $props.node.children ? $props.node.children.length : 0,
    "aria-posinset": $props.index + 1,
    "aria-level": $props.level,
    "aria-checked": $options.ariaChecked,
    tabindex: $props.index === 0 ? 0 : -1,
    onKeydown: _cache[4] || (_cache[4] = function() {
      return $options.onKeyDown && $options.onKeyDown.apply($options, arguments);
    })
  }, $props.level === 1 ? $options.getPTOptions("node") : _ctx.ptm("nodeChildren")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("nodeContent"),
    onClick: _cache[2] || (_cache[2] = function() {
      return $options.onClick && $options.onClick.apply($options, arguments);
    }),
    onTouchend: _cache[3] || (_cache[3] = function() {
      return $options.onTouchEnd && $options.onTouchEnd.apply($options, arguments);
    }),
    style: $props.node.style
  }, $options.getPTOptions("nodeContent"), {
    "data-p-selected": $options.checkboxMode ? $options.checked : $options.selected,
    "data-p-selectable": $options.selectable
  }), [withDirectives((openBlock(), createElementBlock("button", mergeProps({
    type: "button",
    "class": _ctx.cx("nodeToggleButton"),
    onClick: _cache[0] || (_cache[0] = function() {
      return $options.toggle && $options.toggle.apply($options, arguments);
    }),
    tabindex: "-1",
    "aria-hidden": "true"
  }, $options.getPTOptions("nodeToggleButton")), [$props.node.loading && $props.loadingMode === "icon" ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [$props.templates["nodetoggleicon"] || $props.templates["nodetogglericon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodetoggleicon"] || $props.templates["nodetogglericon"]), {
    key: 0,
    "class": normalizeClass(_ctx.cx("nodeToggleIcon"))
  }, null, 8, ["class"])) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
    key: 1,
    spin: "",
    "class": _ctx.cx("nodetogglericon")
  }, _ctx.ptm("nodeToggleIcon")), null, 16, ["class"]))], 64)) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [$props.templates["nodetoggleicon"] || $props.templates["togglericon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodetoggleicon"] || $props.templates["togglericon"]), {
    key: 0,
    node: $props.node,
    expanded: $options.expanded,
    "class": normalizeClass(_ctx.cx("nodeToggleIcon"))
  }, null, 8, ["node", "expanded", "class"])) : $options.expanded ? (openBlock(), createBlock(resolveDynamicComponent($props.node.expandedIcon ? "span" : "ChevronDownIcon"), mergeProps({
    key: 1,
    "class": _ctx.cx("nodeToggleIcon")
  }, $options.getPTOptions("nodeToggleIcon")), null, 16, ["class"])) : (openBlock(), createBlock(resolveDynamicComponent($props.node.collapsedIcon ? "span" : "ChevronRightIcon"), mergeProps({
    key: 2,
    "class": _ctx.cx("nodeToggleIcon")
  }, $options.getPTOptions("nodeToggleIcon")), null, 16, ["class"]))], 64))], 16)), [[_directive_ripple]]), $options.checkboxMode ? (openBlock(), createBlock(_component_Checkbox, {
    key: 0,
    modelValue: $options.checked,
    binary: true,
    indeterminate: $options.partialChecked,
    "class": normalizeClass(_ctx.cx("nodeCheckbox")),
    tabindex: -1,
    unstyled: _ctx.unstyled,
    pt: $options.getPTOptions("nodeCheckbox"),
    "data-p-partialchecked": $options.partialChecked
  }, {
    icon: withCtx(function(slotProps) {
      return [$props.templates["checkboxicon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["checkboxicon"]), {
        key: 0,
        checked: slotProps.checked,
        partialChecked: $options.partialChecked,
        "class": normalizeClass(slotProps["class"])
      }, null, 8, ["checked", "partialChecked", "class"])) : createCommentVNode("", true)];
    }),
    _: 1
  }, 8, ["modelValue", "indeterminate", "class", "unstyled", "pt", "data-p-partialchecked"])) : createCommentVNode("", true), $props.templates["nodeicon"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates["nodeicon"]), mergeProps({
    key: 1,
    node: $props.node,
    "class": [_ctx.cx("nodeIcon")]
  }, $options.getPTOptions("nodeIcon")), null, 16, ["node", "class"])) : (openBlock(), createElementBlock("span", mergeProps({
    key: 2,
    "class": [_ctx.cx("nodeIcon"), $props.node.icon]
  }, $options.getPTOptions("nodeIcon")), null, 16)), createBaseVNode("span", mergeProps({
    "class": _ctx.cx("nodeLabel")
  }, $options.getPTOptions("nodeLabel"), {
    onKeydown: _cache[1] || (_cache[1] = withModifiers(function() {
    }, ["stop"]))
  }), [$props.templates[$props.node.type] || $props.templates["default"] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates[$props.node.type] || $props.templates["default"]), {
    key: 0,
    node: $props.node,
    selected: $options.checkboxMode ? $options.checked : $options.selected
  }, null, 8, ["node", "selected"])) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [createTextVNode(toDisplayString$1($options.label($props.node)), 1)], 64))], 16)], 16, _hoisted_2$2), $options.hasChildren && $options.expanded ? (openBlock(), createElementBlock("ul", mergeProps({
    key: 0,
    "class": _ctx.cx("nodeChildren"),
    role: "group"
  }, _ctx.ptm("nodeChildren")), [(openBlock(true), createElementBlock(Fragment, null, renderList($props.node.children, function(childNode) {
    return openBlock(), createBlock(_component_TreeNode, {
      key: childNode.key,
      node: childNode,
      templates: $props.templates,
      level: $props.level + 1,
      loadingMode: $props.loadingMode,
      expandedKeys: $props.expandedKeys,
      onNodeToggle: $options.onChildNodeToggle,
      onNodeClick: $options.onChildNodeClick,
      selectionMode: $props.selectionMode,
      selectionKeys: $props.selectionKeys,
      onCheckboxChange: $options.propagateUp,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["node", "templates", "level", "loadingMode", "expandedKeys", "onNodeToggle", "onNodeClick", "selectionMode", "selectionKeys", "onCheckboxChange", "unstyled", "pt"]);
  }), 128))], 16)) : createCommentVNode("", true)], 16, _hoisted_1$1$1);
}
script$1$1.render = render$1;
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  } };
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i2 = _toPrimitive(t, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var script$3 = {
  name: "Tree",
  "extends": script$2,
  inheritAttrs: false,
  emits: ["node-expand", "node-collapse", "update:expandedKeys", "update:selectionKeys", "node-select", "node-unselect", "filter"],
  data: function data27() {
    return {
      d_expandedKeys: this.expandedKeys || {},
      filterValue: null
    };
  },
  watch: {
    expandedKeys: function expandedKeys(newValue) {
      this.d_expandedKeys = newValue;
    }
  },
  methods: {
    onNodeToggle: function onNodeToggle(node3) {
      var key = node3.key;
      if (this.d_expandedKeys[key]) {
        delete this.d_expandedKeys[key];
        this.$emit("node-collapse", node3);
      } else {
        this.d_expandedKeys[key] = true;
        this.$emit("node-expand", node3);
      }
      this.d_expandedKeys = _objectSpread({}, this.d_expandedKeys);
      this.$emit("update:expandedKeys", this.d_expandedKeys);
    },
    onNodeClick: function onNodeClick(event2) {
      if (this.selectionMode != null && event2.node.selectable !== false) {
        var metaSelection = event2.nodeTouched ? false : this.metaKeySelection;
        var _selectionKeys = metaSelection ? this.handleSelectionWithMetaKey(event2) : this.handleSelectionWithoutMetaKey(event2);
        this.$emit("update:selectionKeys", _selectionKeys);
      }
    },
    onCheckboxChange: function onCheckboxChange2(event2) {
      this.$emit("update:selectionKeys", event2.selectionKeys);
      if (event2.check) this.$emit("node-select", event2.node);
      else this.$emit("node-unselect", event2.node);
    },
    handleSelectionWithMetaKey: function handleSelectionWithMetaKey(event2) {
      var originalEvent = event2.originalEvent;
      var node3 = event2.node;
      var metaKey = originalEvent.metaKey || originalEvent.ctrlKey;
      var selected2 = this.isNodeSelected(node3);
      var _selectionKeys;
      if (selected2 && metaKey) {
        if (this.isSingleSelectionMode()) {
          _selectionKeys = {};
        } else {
          _selectionKeys = _objectSpread({}, this.selectionKeys);
          delete _selectionKeys[node3.key];
        }
        this.$emit("node-unselect", node3);
      } else {
        if (this.isSingleSelectionMode()) {
          _selectionKeys = {};
        } else if (this.isMultipleSelectionMode()) {
          _selectionKeys = !metaKey ? {} : this.selectionKeys ? _objectSpread({}, this.selectionKeys) : {};
        }
        _selectionKeys[node3.key] = true;
        this.$emit("node-select", node3);
      }
      return _selectionKeys;
    },
    handleSelectionWithoutMetaKey: function handleSelectionWithoutMetaKey(event2) {
      var node3 = event2.node;
      var selected2 = this.isNodeSelected(node3);
      var _selectionKeys;
      if (this.isSingleSelectionMode()) {
        if (selected2) {
          _selectionKeys = {};
          this.$emit("node-unselect", node3);
        } else {
          _selectionKeys = {};
          _selectionKeys[node3.key] = true;
          this.$emit("node-select", node3);
        }
      } else {
        if (selected2) {
          _selectionKeys = _objectSpread({}, this.selectionKeys);
          delete _selectionKeys[node3.key];
          this.$emit("node-unselect", node3);
        } else {
          _selectionKeys = this.selectionKeys ? _objectSpread({}, this.selectionKeys) : {};
          _selectionKeys[node3.key] = true;
          this.$emit("node-select", node3);
        }
      }
      return _selectionKeys;
    },
    isSingleSelectionMode: function isSingleSelectionMode2() {
      return this.selectionMode === "single";
    },
    isMultipleSelectionMode: function isMultipleSelectionMode2() {
      return this.selectionMode === "multiple";
    },
    isNodeSelected: function isNodeSelected(node3) {
      return this.selectionMode && this.selectionKeys ? this.selectionKeys[node3.key] === true : false;
    },
    isChecked: function isChecked(node3) {
      return this.selectionKeys ? this.selectionKeys[node3.key] && this.selectionKeys[node3.key].checked : false;
    },
    isNodeLeaf: function isNodeLeaf(node3) {
      return node3.leaf === false ? false : !(node3.children && node3.children.length);
    },
    onFilterKeydown: function onFilterKeydown(event2) {
      if (event2.code === "Enter" || event2.code === "NumpadEnter") {
        event2.preventDefault();
      }
      this.$emit("filter", {
        originalEvent: event2,
        value: event2.target.value
      });
    },
    findFilteredNodes: function findFilteredNodes(node3, paramsWithoutNode) {
      if (node3) {
        var matched = false;
        if (node3.children) {
          var childNodes = _toConsumableArray(node3.children);
          node3.children = [];
          var _iterator = _createForOfIteratorHelper(childNodes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var childNode = _step.value;
              var copyChildNode = _objectSpread({}, childNode);
              if (this.isFilterMatched(copyChildNode, paramsWithoutNode)) {
                matched = true;
                node3.children.push(copyChildNode);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        if (matched) {
          return true;
        }
      }
    },
    isFilterMatched: function isFilterMatched(node3, _ref) {
      var searchFields3 = _ref.searchFields, filterText = _ref.filterText, strict = _ref.strict;
      var matched = false;
      var _iterator2 = _createForOfIteratorHelper(searchFields3), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var field2 = _step2.value;
          var fieldValue = String(resolveFieldData(node3, field2)).toLocaleLowerCase(this.filterLocale);
          if (fieldValue.indexOf(filterText) > -1) {
            matched = true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (!matched || strict && !this.isNodeLeaf(node3)) {
        matched = this.findFilteredNodes(node3, {
          searchFields: searchFields3,
          filterText,
          strict
        }) || matched;
      }
      return matched;
    }
  },
  computed: {
    filteredValue: function filteredValue() {
      var filteredNodes = [];
      var searchFields3 = this.filterBy.split(",");
      var filterText = this.filterValue.trim().toLocaleLowerCase(this.filterLocale);
      var strict = this.filterMode === "strict";
      var _iterator3 = _createForOfIteratorHelper(this.value), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var node3 = _step3.value;
          var _node = _objectSpread({}, node3);
          var paramsWithoutNode = {
            searchFields: searchFields3,
            filterText,
            strict
          };
          if (strict && (this.findFilteredNodes(_node, paramsWithoutNode) || this.isFilterMatched(_node, paramsWithoutNode)) || !strict && (this.isFilterMatched(_node, paramsWithoutNode) || this.findFilteredNodes(_node, paramsWithoutNode))) {
            filteredNodes.push(_node);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return filteredNodes;
    },
    valueToRender: function valueToRender() {
      if (this.filterValue && this.filterValue.trim().length > 0) return this.filteredValue;
      else return this.value;
    }
  },
  components: {
    TreeNode: script$1$1,
    InputText: script$Z,
    InputIcon: script$_,
    IconField: script$$,
    SearchIcon: script$10,
    SpinnerIcon: script$14
  }
};
var _hoisted_1$4 = ["aria-labelledby", "aria-label"];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_InputText = resolveComponent("InputText");
  var _component_SearchIcon = resolveComponent("SearchIcon");
  var _component_InputIcon = resolveComponent("InputIcon");
  var _component_IconField = resolveComponent("IconField");
  var _component_TreeNode = resolveComponent("TreeNode");
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root")
  }, _ctx.ptmi("root")), [_ctx.loading && _ctx.loadingMode === "mask" ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    "class": _ctx.cx("mask")
  }, _ctx.ptm("mask")), [renderSlot(_ctx.$slots, "loadingicon", {
    "class": normalizeClass(_ctx.cx("loadingIcon"))
  }, function() {
    return [_ctx.loadingIcon ? (openBlock(), createElementBlock("i", mergeProps({
      key: 0,
      "class": [_ctx.cx("loadingIcon"), "pi-spin", _ctx.loadingIcon]
    }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
      key: 1,
      spin: "",
      "class": _ctx.cx("loadingIcon")
    }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
  })], 16)) : createCommentVNode("", true), _ctx.filter ? (openBlock(), createBlock(_component_IconField, mergeProps({
    key: 1,
    unstyled: _ctx.unstyled
  }, _ctx.ptm("pcFilterContainer")), {
    "default": withCtx(function() {
      return [createVNode(_component_InputText, mergeProps({
        modelValue: $data.filterValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function($event) {
          return $data.filterValue = $event;
        }),
        autocomplete: "off",
        "class": _ctx.cx("pcFilterInput"),
        placeholder: _ctx.filterPlaceholder,
        unstyled: _ctx.unstyled,
        onKeydown: $options.onFilterKeydown
      }, _ctx.ptm("pcFilterInput")), null, 16, ["modelValue", "class", "placeholder", "unstyled", "onKeydown"]), createVNode(_component_InputIcon, mergeProps({
        unstyled: _ctx.unstyled
      }, _ctx.ptm("pcFilterIconContainer")), {
        "default": withCtx(function() {
          return [renderSlot(_ctx.$slots, _ctx.$slots.filtericon ? "filtericon" : "searchicon", {
            "class": normalizeClass(_ctx.cx("filterIcon"))
          }, function() {
            return [createVNode(_component_SearchIcon, mergeProps({
              "class": _ctx.cx("filterIcon")
            }, _ctx.ptm("filterIcon")), null, 16, ["class"])];
          })];
        }),
        _: 3
      }, 16, ["unstyled"])];
    }),
    _: 3
  }, 16, ["unstyled"])) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("wrapper"),
    style: {
      maxHeight: _ctx.scrollHeight
    }
  }, _ctx.ptm("wrapper")), [createBaseVNode("ul", mergeProps({
    "class": _ctx.cx("rootChildren"),
    role: "tree",
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel
  }, _ctx.ptm("rootChildren")), [(openBlock(true), createElementBlock(Fragment, null, renderList($options.valueToRender, function(node3, index2) {
    return openBlock(), createBlock(_component_TreeNode, {
      key: node3.key,
      node: node3,
      templates: _ctx.$slots,
      level: _ctx.level + 1,
      index: index2,
      expandedKeys: $data.d_expandedKeys,
      onNodeToggle: $options.onNodeToggle,
      onNodeClick: $options.onNodeClick,
      selectionMode: _ctx.selectionMode,
      selectionKeys: _ctx.selectionKeys,
      onCheckboxChange: $options.onCheckboxChange,
      loadingMode: _ctx.loadingMode,
      unstyled: _ctx.unstyled,
      pt: _ctx.pt
    }, null, 8, ["node", "templates", "level", "index", "expandedKeys", "onNodeToggle", "onNodeClick", "selectionMode", "selectionKeys", "onCheckboxChange", "loadingMode", "unstyled", "pt"]);
  }), 128))], 16, _hoisted_1$4)], 16)], 16);
}
script$3.render = render$2;
const _sfc_main$4 = {
  name: "TreePlus",
  extends: script$3,
  props: {
    dragSelector: {
      type: String,
      default: ".p-tree-node"
    },
    // Explicitly declare all v-model props
    expandedKeys: {
      type: Object,
      default: () => ({})
    },
    selectionKeys: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:expandedKeys", "update:selectionKeys"],
  setup(props, context) {
    const computedExpandedKeys = computed({
      get: () => props.expandedKeys,
      set: (value3) => context.emit("update:expandedKeys", value3)
    });
    const computedSelectionKeys = computed({
      get: () => props.selectionKeys,
      set: (value3) => context.emit("update:selectionKeys", value3)
    });
    let observer = null;
    const makeDraggable = (element) => {
      if (!element._draggableCleanup) {
        element._draggableCleanup = draggable({
          element
        });
      }
    };
    const observeTreeChanges = (treeElement) => {
      observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "childList") {
            mutation.addedNodes.forEach((node3) => {
              if (node3.nodeType === Node.ELEMENT_NODE) {
                node3.querySelectorAll(props.dragSelector).forEach(makeDraggable);
              }
            });
          }
        });
      });
      observer.observe(treeElement, { childList: true, subtree: true });
      treeElement.querySelectorAll(props.dragSelector).forEach(makeDraggable);
    };
    onMounted(() => {
      const treeElement = document.querySelector(".p-tree");
      if (treeElement) {
        observeTreeChanges(treeElement);
      }
    });
    onBeforeUnmount(() => {
      if (observer) {
        observer.disconnect();
      }
      const treeElement = document.querySelector(".p-tree");
      if (treeElement) {
        treeElement.querySelectorAll(props.dragSelector).forEach((node3) => {
          if (node3._draggableCleanup) {
            node3._draggableCleanup();
          }
        });
      }
    });
    return () => h(
      script$3,
      __spreadProps2(__spreadValues2(__spreadValues2({}, context.attrs), props), {
        expandedKeys: computedExpandedKeys.value,
        selectionKeys: computedSelectionKeys.value,
        "onUpdate:expandedKeys": (value3) => computedExpandedKeys.value = value3,
        "onUpdate:selectionKeys": (value3) => computedSelectionKeys.value = value3
      }),
      context.slots
    );
  }
};
var theme = function theme35(_ref) {
  var dt3 = _ref.dt;
  return "\n.p-toolbar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex-wrap: wrap;\n    padding: ".concat(dt3("toolbar.padding"), ";\n    background: ").concat(dt3("toolbar.background"), ";\n    border: 1px solid ").concat(dt3("toolbar.border.color"), ";\n    color: ").concat(dt3("toolbar.color"), ";\n    border-radius: ").concat(dt3("toolbar.border.radius"), ";\n    gap: ").concat(dt3("toolbar.gap"), ";\n}\n\n.p-toolbar-start,\n.p-toolbar-center,\n.p-toolbar-end {\n    display: flex;\n    align-items: center;\n}\n");
};
var classes = {
  root: "p-toolbar p-component",
  start: "p-toolbar-start",
  center: "p-toolbar-center",
  end: "p-toolbar-end"
};
var ToolbarStyle = BaseStyle.extend({
  name: "toolbar",
  theme,
  classes
});
var script$1 = {
  name: "BaseToolbar",
  "extends": script$1a,
  props: {
    ariaLabelledby: {
      type: String,
      "default": null
    }
  },
  style: ToolbarStyle,
  provide: function provide42() {
    return {
      $pcToolbar: this,
      $parentInstance: this
    };
  }
};
var script = {
  name: "Toolbar",
  "extends": script$1,
  inheritAttrs: false
};
var _hoisted_1$3 = ["aria-labelledby"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    "class": _ctx.cx("root"),
    role: "toolbar",
    "aria-labelledby": _ctx.ariaLabelledby
  }, _ctx.ptmi("root")), [createBaseVNode("div", mergeProps({
    "class": _ctx.cx("start")
  }, _ctx.ptm("start")), [renderSlot(_ctx.$slots, "start")], 16), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("center")
  }, _ctx.ptm("center")), [renderSlot(_ctx.$slots, "center")], 16), createBaseVNode("div", mergeProps({
    "class": _ctx.cx("end")
  }, _ctx.ptm("end")), [renderSlot(_ctx.$slots, "end")], 16)], 16, _hoisted_1$3);
}
script.render = render;
const _withScopeId = (n) => (pushScopeId("data-v-68eb78dd"), n = n(), popScopeId(), n);
const _hoisted_1$2 = { class: "comfy-vue-side-bar-container" };
const _hoisted_2$1 = { class: "comfy-vue-side-bar-header-span" };
const _hoisted_3 = { class: "comfy-vue-side-bar-body" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "SidebarTabTemplate",
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createVNode(unref(script), { class: "comfy-vue-side-bar-header" }, {
          start: withCtx(() => [
            createBaseVNode("span", _hoisted_2$1, toDisplayString$1(props.title.toUpperCase()), 1)
          ]),
          end: withCtx(() => [
            renderSlot(_ctx.$slots, "tool-buttons", {}, void 0, true)
          ]),
          _: 3
        }),
        createBaseVNode("div", _hoisted_3, [
          renderSlot(_ctx.$slots, "body", {}, void 0, true)
        ])
      ]);
    };
  }
});
const SidebarTabTemplate = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-68eb78dd"]]);
const _hoisted_1$1 = { class: "folder-label" };
const _hoisted_2 = { class: "node-label" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "NodeLibrarySidebarTab",
  setup(__props) {
    const nodeDefStore = useNodeDefStore();
    const alphabeticalSort = ref(false);
    const expandedKeys2 = ref({});
    const hoveredComfyNodeName = ref(null);
    const hoveredComfyNode = computed(() => {
      if (!hoveredComfyNodeName.value) {
        return null;
      }
      return nodeDefStore.nodeDefsByName[hoveredComfyNodeName.value] || null;
    });
    const settingStore = useSettingStore();
    const sidebarLocation = computed(
      () => settingStore.get("Comfy.Sidebar.Location")
    );
    const nodePreviewStyle = ref({
      position: "absolute",
      top: "0px",
      left: "0px"
    });
    const root27 = computed(
      () => alphabeticalSort.value ? nodeDefStore.sortedNodeTree : nodeDefStore.nodeTree
    );
    const renderedRoot = computed(() => {
      return fillNodeInfo(root27.value);
    });
    const fillNodeInfo = (node3) => {
      var _a2;
      const isExpanded = expandedKeys2.value[node3.key];
      const icon2 = node3.leaf ? "pi pi-circle-fill" : isExpanded ? "pi pi-folder-open" : "pi pi-folder";
      const children = (_a2 = node3.children) == null ? void 0 : _a2.map(fillNodeInfo);
      return __spreadProps2(__spreadValues2({}, node3), {
        icon: icon2,
        children,
        type: node3.leaf ? "node" : "folder",
        totalNodes: node3.leaf ? 1 : children.reduce((acc, child) => acc + child.totalNodes, 0)
      });
    };
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createBlock(SidebarTabTemplate, {
        title: _ctx.$t("sideToolbar.nodeLibrary")
      }, {
        "tool-buttons": withCtx(() => [
          withDirectives(createVNode(unref(script$z), {
            "model-value": alphabeticalSort.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => alphabeticalSort.value = $event),
            "on-icon": "pi pi-sort-alpha-down",
            "off-icon": "pi pi-sort-alt",
            "aria-label": "Sort",
            pt: {
              label: { style: { display: "none" } }
            }
          }, null, 8, ["model-value"]), [
            [_directive_tooltip, _ctx.$t("sideToolbar.nodeLibraryTab.sortOrder")]
          ])
        ]),
        body: withCtx(() => [
          createVNode(_sfc_main$4, {
            class: "node-lib-tree",
            expandedKeys: expandedKeys2.value,
            "onUpdate:expandedKeys": _cache[1] || (_cache[1] = ($event) => expandedKeys2.value = $event),
            selectionMode: "single",
            value: renderedRoot.value.children,
            filter: true,
            filterMode: "lenient",
            dragSelector: ".p-tree-node-leaf",
            pt: {
              nodeLabel: "node-lib-tree-node-label",
              nodeChildren: ({ props }) => {
                var _a2, _b;
                return {
                  "data-comfy-node-name": (_b = (_a2 = props.node) == null ? void 0 : _a2.data) == null ? void 0 : _b.name,
                  onMouseenter: (event2) => {
                    var _a3, _b2;
                    hoveredComfyNodeName.value = (_b2 = (_a3 = props.node) == null ? void 0 : _a3.data) == null ? void 0 : _b2.name;
                    const hoverTarget = event2.target;
                    const targetRect = hoverTarget.getBoundingClientRect();
                    if (sidebarLocation.value === "left") {
                      nodePreviewStyle.value.top = `${targetRect.top - 40}px`;
                      nodePreviewStyle.value.left = `${targetRect.right}px`;
                    } else {
                      nodePreviewStyle.value.top = `${targetRect.top - 40}px`;
                      nodePreviewStyle.value.left = `${targetRect.left - 400}px`;
                    }
                  },
                  onMouseleave: () => {
                    hoveredComfyNodeName.value = null;
                  }
                };
              }
            }
          }, {
            folder: withCtx(({ node: node3 }) => [
              createBaseVNode("span", _hoisted_1$1, toDisplayString$1(node3.label), 1),
              createVNode(unref(script$17), {
                value: node3.totalNodes,
                severity: "secondary",
                style: { marginLeft: "0.5rem" }
              }, null, 8, ["value"])
            ]),
            node: withCtx(({ node: node3 }) => [
              createBaseVNode("span", _hoisted_2, toDisplayString$1(node3.label), 1)
            ]),
            _: 1
          }, 8, ["expandedKeys", "value", "pt"]),
          hoveredComfyNode.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "node-lib-node-preview",
            style: normalizeStyle(nodePreviewStyle.value)
          }, [
            (openBlock(), createBlock(NodePreview, {
              key: hoveredComfyNode.value.name,
              nodeDef: hoveredComfyNode.value
            }, null, 8, ["nodeDef"]))
          ], 4)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["title"]);
    };
  }
});
const _hoisted_1 = { key: 1 };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "GlobalDialog",
  setup(__props) {
    const dialogStore = useDialogStore();
    const maximized = ref(false);
    return (_ctx, _cache) => {
      var _a2;
      return openBlock(), createBlock(unref(script$A), {
        visible: unref(dialogStore).isVisible,
        "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => unref(dialogStore).isVisible = $event),
        modal: "",
        closable: "",
        closeOnEscape: "",
        dismissableMask: "",
        maximizable: (_a2 = unref(dialogStore).props.maximizable) != null ? _a2 : false,
        onHide: unref(dialogStore).closeDialog,
        onMaximize: _cache[1] || (_cache[1] = ($event) => maximized.value = true),
        onUnmaximize: _cache[2] || (_cache[2] = ($event) => maximized.value = false)
      }, {
        header: withCtx(() => [
          unref(dialogStore).headerComponent ? (openBlock(), createBlock(resolveDynamicComponent(unref(dialogStore).headerComponent), { key: 0 })) : (openBlock(), createElementBlock("h3", _hoisted_1, toDisplayString$1(unref(dialogStore).title || " "), 1))
        ]),
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(unref(dialogStore).component), mergeProps(unref(dialogStore).props, { maximized: maximized.value }), null, 16, ["maximized"]))
        ]),
        _: 1
      }, 8, ["visible", "maximizable", "onHide"]);
    };
  }
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const isLoading = computed(() => useWorkspaceStore().spinner);
    const theme36 = computed(
      () => useSettingStore().get("Comfy.ColorPalette")
    );
    watch(
      theme36,
      (newTheme) => {
        const DARK_THEME_CLASS = "dark-theme";
        const isDarkTheme = newTheme !== "light";
        if (isDarkTheme) {
          document.body.classList.add(DARK_THEME_CLASS);
        } else {
          document.body.classList.remove(DARK_THEME_CLASS);
        }
      },
      { immediate: true }
    );
    const { t } = useI18n();
    const init2 = () => {
      useSettingStore().addSettings(app$1.ui.settings);
      app$1.extensionManager = useWorkspaceStore();
      app$1.extensionManager.registerSidebarTab({
        id: "queue",
        icon: "pi pi-history",
        iconBadge: () => {
          const value3 = useQueuePendingTaskCountStore().count.toString();
          return value3 === "0" ? null : value3;
        },
        title: t("sideToolbar.queue"),
        tooltip: t("sideToolbar.queue"),
        component: markRaw(QueueSidebarTab),
        type: "vue"
      });
      app$1.extensionManager.registerSidebarTab({
        id: "node-library",
        icon: "pi pi-book",
        title: t("sideToolbar.nodeLibrary"),
        tooltip: t("sideToolbar.nodeLibrary"),
        component: markRaw(_sfc_main$2),
        type: "vue"
      });
    };
    const queuePendingTaskCountStore = useQueuePendingTaskCountStore();
    const onStatus = (e) => queuePendingTaskCountStore.update(e);
    onMounted(() => {
      api.addEventListener("status", onStatus);
      try {
        init2();
      } catch (e) {
        console.error("Failed to init Vue app", e);
      }
    });
    onUnmounted(() => {
      api.removeEventListener("status", onStatus);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        isLoading.value ? (openBlock(), createBlock(unref(script$18), {
          key: 0,
          class: "spinner"
        })) : createCommentVNode("", true),
        createVNode(unref(script$19), {
          "full-screen": "",
          blocked: isLoading.value
        }, null, 8, ["blocked"]),
        createVNode(_sfc_main$1),
        createVNode(_sfc_main$6)
      ], 64);
    };
  }
});
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-2a1001f4"]]);
const messages = {
  en: {
    settings: "Settings",
    searchSettings: "Search Settings",
    noResultsFound: "No Results Found",
    searchFailedMessage: "We couldn't find any settings matching your search. Try adjusting your search terms.",
    noTasksFound: "No Tasks Found",
    noTasksFoundMessage: "There are no tasks in the queue.",
    sideToolbar: {
      themeToggle: "Toggle Theme",
      queue: "Queue",
      nodeLibrary: "Node Library",
      nodeLibraryTab: {
        sortOrder: "Sort Order"
      }
    }
  },
  zh: {
    settings: "设置",
    searchSettings: "搜索设置",
    noResultsFound: "未找到结果",
    noTasksFound: "未找到任务",
    noTasksFoundMessage: "队列中没有任务。",
    searchFailedMessage: "我们找不到与您的搜索匹配的任何设置。请尝试调整搜索条件。",
    sideToolbar: {
      themeToggle: "主题切换",
      queue: "队列",
      nodeLibrary: "节点库",
      nodeLibraryTab: {
        sortOrder: "排序顺序"
      }
    }
  }
  // TODO: Add more languages
};
const i18n = createI18n({
  // Must set `false`, as Vue I18n Legacy API is for Vue 2
  legacy: false,
  locale: navigator.language.split("-")[0] || "en",
  fallbackLocale: "en",
  messages
});
const ComfyUIPreset = definePreset(index$1, {
  semantic: {
    primary: index$1["primitive"].blue
  }
});
const app = createApp(App);
const pinia = createPinia();
app.directive("tooltip", Tooltip);
app.use(PrimeVue, {
  theme: {
    preset: ComfyUIPreset,
    options: {
      prefix: "p",
      cssLayer: false,
      // This is a workaround for the issue with the dark mode selector
      // https://github.com/primefaces/primevue/issues/5515
      darkModeSelector: ".dark-theme, :root:has(.dark-theme)"
    }
  }
}).use(ConfirmationService).use(ToastService).use(pinia).use(i18n).mount("#vue-app");
export {
  $el as $,
  ComfyDialog as C,
  DraggableList as D,
  LGraphCanvas as L,
  ComfyApp as a,
  app$1 as b,
  LiteGraph as c,
  applyTextReplacements as d,
  ComfyWidgets as e,
  addValueControlWidgets as f,
  api as g,
  LGraphGroup as h,
  LGraphNode as i,
  createSpinner as j
};
//# sourceMappingURL=index-DIiqwEjy.js.map
